[
  {
    "owner": "pardeike",
    "repo": "harmony",
    "content": "TITLE: Automatic Patch Application\nDESCRIPTION: Applies all patches in an assembly using annotation-based patching.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nharmony.PatchAll(Assembly.GetExecutingAssembly());\n```\n\n----------------------------------------\n\nTITLE: Defining Harmony Patch Methods in a Patch Class\nDESCRIPTION: Example showing how to define patch methods in a Harmony patch class. It demonstrates both convention-based naming (using 'Prefix' method name) and attribute-based definition (using [HarmonyPostfix] attribute).\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(...)]\nclass Patch\n{\n\tstatic void Prefix()\n\t{\n\t\t// this method uses the name \"Prefix\", no annotation necessary\n\t}\n\n\t[HarmonyPostfix]\n\tstatic void MyOwnName()\n\t{\n\t\t// this method is a Postfix as defined by the attribute\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Harmony Annotation-based Patching Example\nDESCRIPTION: Demonstrates how to patch methods using Harmony's annotation-based approach with HarmonyPatch attributes.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/intro.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(GameLogic))]\n[HarmonyPatch(\"DoGameLogic\")]\nclass Patch {\n    static void Prefix() {\n        Log.Message(\"Before original\");\n    }\n\n    static void Postfix() {\n        Log.Message(\"After original\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Harmony Instance\nDESCRIPTION: Creates a new Harmony instance with a unique identifier in reverse domain notation.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar harmony = new Harmony(\"com.company.project\");\n```\n\n----------------------------------------\n\nTITLE: Manual Patch Application\nDESCRIPTION: Demonstrates manual patch application with specific prefix and postfix methods.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nharmony.Patch(original, prefix, postfix);\n```\n\n----------------------------------------\n\nTITLE: Basic Harmony Patch Class Example in C#\nDESCRIPTION: A basic example showing how to create a patch class with annotations that identify the method to patch, along with Prefix and Postfix methods.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/annotations.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(SomeTypeHere))]  // target class/type\n[HarmonyPatch(\"SomeMethodName\")]  // target method\nclass MyPatches\n{\n    // If Prefix returns false, the original method and Postfix will be skipped\n    static bool Prefix()\n    {\n        return true; // run the original method\n    }\n\n    // Postfixes can access and change the result of the original method (ref result)\n    static void Postfix(ref string __result)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Harmony Manual Reflection-based Patching Example\nDESCRIPTION: Shows how to implement Harmony patches manually using reflection instead of attributes.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/intro.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar harmony = new Harmony(\"com.example.patch\");\nvar mOriginal = typeof(GameLogic).GetMethod(\"DoGameLogic\");\nvar mPrefix = typeof(MyPatchClass).GetMethod(\"MyPrefix\");\nvar mPostfix = typeof(MyPatchClass).GetMethod(\"MyPostfix\");\nharmony.Patch(mOriginal, new HarmonyMethod(mPrefix), new HarmonyMethod(mPostfix));\n```\n\n----------------------------------------\n\nTITLE: Importing Harmony Library\nDESCRIPTION: Example showing how to import Harmony namespace into a C# project.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing HarmonyLib;\n```\n\n----------------------------------------\n\nTITLE: Original Game Code Sample in C#\nDESCRIPTION: Example showing original game code that will be patched, containing a simple class GameLogic with a DoGameLogic method.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/intro.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GameLogic {\n    public void DoGameLogic() {\n        if (someCondition) {\n            Log.Message(\"Success\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Patch Methods with Factory Methods in Harmony\nDESCRIPTION: Shows how to implement factory methods that generate dynamic patches at runtime. These factory methods return either MethodInfo or DynamicMethod objects that Harmony will use as the actual patch implementation.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(...)]\nclass Patch\n{\n\t// the return type of factory methods can be either MethodInfo or DynamicMethod\n\t[HarmonyPrefix]\n\tstatic MethodInfo PrefixFactory(MethodBase originalMethod)\n\t{\n\t\t// return an instance of MethodInfo or an instance of DynamicMethod\n\t}\n\n\t[HarmonyPostfix]\n\tstatic MethodInfo PostfixFactory(MethodBase originalMethod)\n\t{\n\t\t// return an instance of MethodInfo or an instance of DynamicMethod\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Harmony Transpiler Methods in C#\nDESCRIPTION: Shows the basic API structure for creating transpiler methods in Harmony. Transpilers can be defined either as static methods or with the [HarmonyTranspiler] attribute, and they accept specific argument types including the required CodeInstruction collection and optional ILGenerator and MethodBase parameters.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic IEnumerable<CodeInstruction> Transpiler(<arguments>)\n// or\n[HarmonyTranspiler]\nstatic IEnumerable<CodeInstruction> MyTranspiler(<arguments>)\n\n// Arguments are identified by their type and can have any name:\nIEnumerable<CodeInstruction> instructions // [REQUIRED]\nILGenerator generator // [OPTIONAL]\nMethodBase original // [OPTIONAL]\n```\n\n----------------------------------------\n\nTITLE: Using AccessTools for Reflection in Harmony\nDESCRIPTION: AccessTools provides helper methods to simplify reflection operations. These methods work with any member regardless of visibility (public, private, static, etc.) using the 'all' BindingFlags.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/utilities.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static BindingFlags all = ....\\npublic static Type TypeByName(string name)\\npublic static FieldInfo Field(Type type, string name)\\npublic static PropertyInfo Property(Type type, string name)\\npublic static MethodInfo Method(Type type, string name, Type[] parameters = null, Type[] generics = null)\\npublic static ConstructorInfo Constructor(Type type, Type[] parameters = null)\\npublic static Type Inner(Type type, string name)\\npublic static Type FirstInner(Type type, Func<Type, bool> predicate)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Typical Harmony Transpiler in C#\nDESCRIPTION: Example of a typical transpiler implementation that processes a collection of CodeInstructions. The example references a separate code file (patching-transpiler.cs) that would contain the full implementation details of how to manipulate the IL code instructions.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[example](../examples/patching-transpiler.cs?name=typical)]\n```\n\n----------------------------------------\n\nTITLE: Implementing TargetMethod in C#\nDESCRIPTION: Demonstrates how to implement the TargetMethod which calculates and returns the method to be patched. This is an alternative to using HarmonyPatch annotations.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-auxiliary.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic MethodBase TargetMethod(...)\n// or\n[HarmonyTargetMethod]\nstatic MethodBase CalculateMethod(...)\n```\n\n----------------------------------------\n\nTITLE: Implementing Harmony Patch Flow Without Finalizer\nDESCRIPTION: Demonstrates the basic execution flow of a Harmony-patched method without Finalizer patches. Shows how Prefix patches can control execution flow and how Postfix patches are always executed.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/execution.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = default(T);\nvar run = true;\n\n// prefix patches can use ref/out to change result\nrun = Prefix1(ref result);\nif (run) run = Prefix2(ref result);\nif (run) run = Prefix3(ref result);\n\n// prefixes with no result changes are always run\nPrefix4();\nPrefix5();\n\nif (run)\n    result = Original(...);\n\n// postfixes are always run\nPostfix1();\nPostfix2();\nPostfix3();\n\nreturn result;\n```\n\n----------------------------------------\n\nTITLE: Implementing TargetMethods in C#\nDESCRIPTION: Shows how to implement TargetMethods for patching multiple methods with the same patch. Returns an enumeration of MethodBase instead of a single method.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-auxiliary.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic IEnumerable<MethodBase> TargetMethods(...)\n// or\n[HarmonyTargetMethods]\nstatic IEnumerable<MethodBase> CalculateMethods(...)\n```\n\n----------------------------------------\n\nTITLE: Manipulating Arguments in Harmony Prefix Patch (C#)\nDESCRIPTION: Demonstrates how to read and modify arguments in a Harmony prefix patch. The example shows changing the 'name' argument to uppercase before the original method executes.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-prefix.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Prefix(ref string name)\n{\n    name = name.ToUpper();\n}\n```\n\n----------------------------------------\n\nTITLE: Patching Multiple Methods Using TargetMethods in C#\nDESCRIPTION: Example demonstrating how to patch multiple methods by combining annotations with TargetMethod() and TargetMethods() to simplify multiple patches while still using annotations.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/annotations.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch]\nclass Patches\n{\n    // Here you list all methods you want to patch with the same patch\n    static IEnumerable<MethodBase> TargetMethods()\n    {\n        // get all \"Move\" prefixed methods in class SomeType\n        var someType = typeof(SomeType);\n        return someType.GetMethods()\n            .Where(method => method.Name.StartsWith(\"Move\"));\n    }\n\n    // Use yield to define a particular method\n    static IEnumerable<MethodBase> TargetMethods()\n    {\n        yield return AccessTools.Method(typeof(TestType), \"Test\");\n        yield return AccessTools.Method(typeof(TestType), \"Test2\");\n    }\n\n    // Alternatively, use TargetMethod (singular) to return a single method\n    static MethodBase TargetMethod()\n    {\n        return AccessTools.Method(typeof(TestType), \"Test\");\n    }\n\n    static void Prefix()\n    {\n        // here your code for all patches\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Method Results with Postfix Patch in C#\nDESCRIPTION: Demonstrates how to read or modify the result of an original method using a postfix patch. The __result parameter allows access to the original method's return value.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-postfix.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPostfix]\npublic static void Postfix(ref string __result)\n{\n    __result = \"prefix override: \" + __result;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in Harmony Prefix Patch (C#)\nDESCRIPTION: Illustrates conditional execution of the original method based on input in a Harmony prefix patch. The prefix may or may not skip the original method execution depending on the 'name' parameter.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-prefix.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool Prefix(string name, ref string __result)\n{\n    if (name == \"foo\")\n    {\n        __result = \"bar\";\n        return false; // skip original\n    }\n    return true; // run original\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Result and Skipping Original Method in Harmony Prefix Patch (C#)\nDESCRIPTION: Shows how to change the result of the original method and skip its execution in a Harmony prefix patch. The prefix sets a custom result and returns false to prevent the original method from running.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-prefix.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool Prefix(ref string __result)\n{\n    __result = \"Hello\";\n    return false; // skip original\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Reverse Patch in C#\nDESCRIPTION: Demonstrates how to create a reverse patch using the HarmonyReversePatch attribute. The example shows patching a private method from the Random class.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/reverse-patching.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(Random), \"Next\", new Type[] { typeof(int), typeof(int) })]\nclass Patch\n{\n    [HarmonyReversePatch]\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    public static int GetRandomNumber(object instance, int min, int max)\n    {\n        // this code is never executed, it's just a stub to define the method\n        throw new NotImplementedException();\n    }\n\n    static void Postfix(Random __instance, ref int __result, int maxValue)\n    {\n        // call the original private Random.Next(int, int)\n        __result = GetRandomNumber(__instance, 0, maxValue);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pass-through Postfix Implementation in C#\nDESCRIPTION: Shows how to implement a pass-through postfix that can modify the result using IEnumerable operations. This approach is particularly useful for types that can't be used with ref parameters.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-postfix.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPostfix]\npublic static IEnumerable<string> Postfix(IEnumerable<string> values)\n{\n    foreach (var value in values)\n        yield return value.ToUpper();\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Exceptions with Harmony Finalizer in C#\nDESCRIPTION: This code shows how to create a finalizer that observes exceptions without modifying them. It receives the exception as a parameter but doesn't return anything, allowing the exception to propagate normally.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-finalizer.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Finalizer(Exception __exception)\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Method Call Replacement Using CodeMatcher\nDESCRIPTION: Demonstrates how to replace a Kill() method call with MyDeathHandler() using CodeMatcher. The matcher finds the specific instruction pattern and performs the replacement while validating the match.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler-matcher.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar codes = new CodeMatcher(instructions)\n    .MatchStartForward(new CodeMatch(OpCodes.Callvirt, typeof(DamageHandler).GetMethod(\"Kill\")))\n    .ThrowIfInvalid(\"Cannot find the Kill method\")\n    .Set(OpCodes.Call, typeof(MyClass).GetMethod(\"MyDeathHandler\"))\n    .InstructionEnumeration();\n```\n\n----------------------------------------\n\nTITLE: Changing and Rethrowing Exceptions with Harmony Finalizer in C#\nDESCRIPTION: This snippet illustrates how to use a finalizer to modify and rethrow exceptions. It checks the type of the exception and either returns it as-is or wraps it in a new exception type.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-finalizer.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[example](../examples/patching-finalizer.cs?name=rethrow)]\n```\n\n----------------------------------------\n\nTITLE: Suppressing Exceptions with Harmony Finalizer in C#\nDESCRIPTION: This snippet demonstrates how to use a finalizer to suppress any exceptions that occur during method execution. It returns null, effectively preventing any exception from being thrown.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-finalizer.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Exception Finalizer()\n{\n\treturn null;\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Private Field Access in C#\nDESCRIPTION: Demonstrates how to access private fields using triple underscore prefix. Fields can be read or written using the ref keyword for modification.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-injections.md#2025-04-17_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n___someField     // Reading private field 'someField'\nref string ___name  // Writing to private field 'name'\n```\n\n----------------------------------------\n\nTITLE: Arguments Array Injection in C#\nDESCRIPTION: Shows how to access all method arguments as an array using the __args parameter. Array contents can be modified to update corresponding arguments.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-injections.md#2025-04-17_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nobject[] __args\n```\n\n----------------------------------------\n\nTITLE: Sharing State Between Prefix and Postfix in Harmony Patch (C#)\nDESCRIPTION: Demonstrates how to share state between prefix and postfix methods using the __state parameter in Harmony patches. The example stores the original health value to be used in the postfix method.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-prefix.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Prefix(Monster __instance, ref int __state)\n{\n    __state = __instance.Health; // remember old value\n}\n\nstatic void Postfix(Monster __instance, int __state)\n{\n    int diff = __instance.Health - __state;\n    if (diff > 0)\n        Console.WriteLine(\"Health increased by \" + diff);\n}\n```\n\n----------------------------------------\n\nTITLE: Result Reference Handling in C#\nDESCRIPTION: Demonstrates how to handle ref return values using RefResult<T> with the __resultRef parameter.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-injections.md#2025-04-17_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nref RefResult<string> __resultRef\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reverse Patch Transpiler in C#\nDESCRIPTION: Shows how to use a transpiler within a reverse patch stub to modify the original IL code. This example extracts a specific part of the original method.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/reverse-patching.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyReversePatch]\n[HarmonyTranspiler]\nstatic IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)\n{\n    var codes = new List<CodeInstruction>(instructions);\n    var idx1 = ...\n    var idx2 = ...\n    return codes.GetRange(idx1, idx2 - idx1 + 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Original Method Arguments in Postfix Patch\nDESCRIPTION: Example showing how to access the original method's arguments in a postfix patch using parameter naming conventions.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-postfix.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPostfix]\npublic static void Postfix(string name)\n{\n    FileLog.Log($\"after method with name {name}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Method Call Replacement Using ThrowIfNotMatchForward\nDESCRIPTION: Shows a more concise way to perform method replacement using ThrowIfNotMatchForward, which combines MatchStartForward and ThrowIfInvalid into a single call.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler-matcher.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar codes = new CodeMatcher(instructions)\n    .ThrowIfNotMatchForward(new CodeMatch(OpCodes.Callvirt, typeof(DamageHandler).GetMethod(\"Kill\")))\n    .Set(OpCodes.Call, typeof(MyClass).GetMethod(\"MyDeathHandler\"))\n    .InstructionEnumeration();\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Matches Using Repeat()\nDESCRIPTION: Demonstrates how to handle multiple occurrences of a pattern using the Repeat() method, with error handling for when no matches are found.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler-matcher.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nreturn new CodeMatcher(instructions)\n    .MatchStartForward(new CodeMatch(OpCodes.Callvirt, typeof(DamageHandler).GetMethod(\"Kill\")))\n    .Repeat(matcher => {\n        matcher.Set(OpCodes.Call, typeof(MyClass).GetMethod(\"MyDeathHandler\"));\n    }, \n    failedMatch => {\n        FileLog.Log($\"Cannot find Kill method: {failedMatch}\");\n    })\n    .InstructionEnumeration();\n```\n\n----------------------------------------\n\nTITLE: Basic Harmony Transpiler Structure\nDESCRIPTION: Demonstrates the basic structure of a Harmony transpiler patch that targets the CheckForErrors method in Dialog_FormCaravan class. Shows the required method signature and attributes for transpiler implementation.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(Dialog_FormCaravan))]\n[HarmonyPatch(\"CheckForErrors\")]\npublic static class Dialog_FormCaravan_CheckForErrors_Patch\n{\n\tstatic IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)\n\t{\n\t\t// do something\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Traverse in Harmony for Reflection Navigation\nDESCRIPTION: Traverse provides a LINQ-like interface for navigating and manipulating class hierarchies via reflection. It handles null protection and caches lookups for performance, while allowing access to private members.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/utilities.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// starting from a type or instance\\npublic static Traverse Create(Type type)\\npublic static Traverse Create<T>()\\npublic static Traverse CreateWithType(string name)\\n\\n// digging deeper\\npublic Traverse Type(string name)\\npublic Traverse Field(string name)\\npublic Traverse Property(string name, object[] index = null)\\npublic Traverse Method(string name, params object[] arguments)\\npublic Traverse Method(string name, Type[] paramTypes, object[] arguments = null)\\n\\n// calling getter or method\\npublic object GetValue()\\npublic T GetValue<T>()\\npublic object GetValue(params object[] arguments)\\npublic T GetValue<T>(params object[] arguments)\\npublic override string ToString()\\n\\n// calling setter\\npublic Traverse SetValue(object value)\\n\\n// iterating\\npublic static void IterateFields(object source, Action<Traverse> action)\\npublic static void IterateFields(object source, object target, Action<Traverse, Traverse> action)\\npublic static void IterateProperties(object source, Action<Traverse> action)\\npublic static void IterateProperties(object source, object target, Action<Traverse, Traverse> action)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Patched Methods\nDESCRIPTION: Gets a list of all methods patched by Harmony in the current AppDomain.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar methods = Harmony.GetAllPatchedMethods();\nforeach (var method in methods) {\n    FileLog.Log($\"Found patched method: {method.FullDescription()}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using FileLog in Harmony for Simple Logging\nDESCRIPTION: FileLog provides basic logging functionality for Harmony, allowing for text and binary data logging to a file on the desktop. It supports creating new logs, appending data, and resetting the log file.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/utilities.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Log(string str)\\n// Creates a new log file called \"harmony.log.txt\" on the computers Desktop (if it not already exists) and appends *str* to it. \\n\\npublic static void Reset()\\n// Deletes the log file.\\n\\npublic static unsafe void LogBytes(long ptr, int len)\\n// Same as Log(string str) but logs a hex dump and md5 hash.\n```\n\n----------------------------------------\n\nTITLE: Checking Patch Info\nDESCRIPTION: Retrieves detailed patch information for a specific method.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar info = Harmony.GetPatchInfo(method);\n```\n\n----------------------------------------\n\nTITLE: Checking Patch Existence\nDESCRIPTION: Checks if a Harmony instance has applied any patches.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar hasPatches = harmony.HasAnyPatches();\n```\n\n----------------------------------------\n\nTITLE: Modified Plugin 1 with HarmonyAfter Annotation\nDESCRIPTION: Updated Plugin 1 implementation that specifies it should run after Plugin 2 using the HarmonyAfter attribute. This ensures Plugin 1 gets the final modification regardless of registration order.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/priorities.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(Foo), \"Bar\")]\npublic class Plugin1\n{\n    [HarmonyPostfix]\n    [HarmonyAfter(new string[] { \"net.example.plugin2\" })]\n    public static void Postfix(ref string __result)\n    {\n        __result = \"new \" + __result;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Harmony Versions\nDESCRIPTION: Retrieves version information for all Harmony instances in use.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar dict = Harmony.VersionInfo(out var myVersion);\n```\n\n----------------------------------------\n\nTITLE: Unpatching Methods\nDESCRIPTION: Demonstrates how to remove all patches from methods.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nharmony.UnpatchAll(harmonyID); // unpatch one instance\nharmony.UnpatchAll(); // unpatch everything\n```\n\n----------------------------------------\n\nTITLE: Matcher Validation with Start() Method\nDESCRIPTION: Shows how to validate matches and handle failure cases by checking if the matcher reached the end of instructions, with the ability to reset position using Start().\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler-matcher.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar matcher = new CodeMatcher(instructions)\n    .MatchStartForward(new CodeMatch(OpCodes.Callvirt, typeof(DamageHandler).GetMethod(\"Kill\")));\nif (!matcher.ReportFailure(\"Cannot find the Kill method\"))\n    return instructions;\nreturn matcher\n    .Set(OpCodes.Call, typeof(MyClass).GetMethod(\"MyDeathHandler\"))\n    .InstructionEnumeration();\n```\n\n----------------------------------------\n\nTITLE: Removing Specific Patches\nDESCRIPTION: Shows how to remove specific patches from a method.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nharmony.Unpatch(original, HarmonyPatchType.All, harmonyID);\nharmony.Unpatch(original, patch);\n```\n\n----------------------------------------\n\nTITLE: Enabling Harmony Debug Logging\nDESCRIPTION: Enables detailed debug logging for Harmony operations to harmony.log.txt on the desktop.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nHarmony.DEBUG = true;\n```\n\n----------------------------------------\n\nTITLE: Original Method Patched by Multiple Plugins\nDESCRIPTION: The original method 'Bar' in class 'Foo' that returns a simple string. This is the method that will be patched by multiple plugins to demonstrate priority handling.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/priorities.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo\n{\n    public static string Bar()\n    {\n        return \"secret\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Harmony FileLog\nDESCRIPTION: Demonstrates how to use Harmony's FileLog for custom logging messages.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nFileLog.Log(\"Something happened\");\n```\n\n----------------------------------------\n\nTITLE: Solution for Patching Methods That Call Unity External Methods\nDESCRIPTION: This snippet shows how to properly time Harmony patching in Unity to avoid MissingMethodException. It uses the SceneManager.sceneLoaded event to ensure Unity has finished its startup phase before applying patches.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-edgecases.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class YourPatchManager : MonoBehaviour\n{\n    private void Awake()\n    {\n        SceneManager.sceneLoaded += OnSceneLoaded;\n    }\n\n    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)\n    {\n        SceneManager.sceneLoaded -= OnSceneLoaded;\n        \n        // Now it's safe to patch\n        var harmony = new Harmony(\"com.example.patch\");\n        harmony.PatchAll();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating HarmonyMethod\nDESCRIPTION: Shows how to create a HarmonyMethod instance from a MethodInfo.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar harmony = new HarmonyMethod(typeof(MyPatchClass).GetMethod(nameof(MyPatchClass.MyPrefix)));\n```\n\n----------------------------------------\n\nTITLE: Getting Instance Patches\nDESCRIPTION: Retrieves methods patched by a specific Harmony instance.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/basics.md#2025-04-17_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar myPatchedMethods = harmony.GetPatchedMethods();\n```\n\n----------------------------------------\n\nTITLE: Caravan Mass Usage Transpiler Implementation\nDESCRIPTION: Implements a transpiler that searches for and removes code sections related to caravan mass usage checks. Uses pattern matching to identify specific IL code sections by searching for return statements and specific string references.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(Dialog_FormCaravan))]\n[HarmonyPatch(\"CheckForErrors\")]\npublic static class Dialog_FormCaravan_CheckForErrors_Patch\n{\n\tstatic IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)\n\t{\n\t\tvar codes = new List<CodeInstruction>(instructions);\n\t\tvar retCount = 0;\n\t\tvar originalCount = codes.Count;\n\t\tvar beginIndex = -1;\n\t\tvar endIndex = -1;\n\t\t\n\t\tfor (var i = 0; i < codes.Count; i++)\n\t\t{\n\t\t\tif (codes[i].opcode != OpCodes.Ret) continue;\n\t\t\tretCount++;\n\t\t\t\n\t\t\tvar j = i + 1;\n\t\t\tif (j < codes.Count)\n\t\t\t{\n\t\t\t\twhile (j < codes.Count && codes[j].opcode != OpCodes.Ret)\n\t\t\t\t{\n\t\t\t\t\tif (codes[j].operand is string s && s == \"TooBigCaravanMassUsage\")\n\t\t\t\t\t{\n\t\t\t\t\t\tbeginIndex = i + 1;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\twhile (j < codes.Count && codes[j].opcode != OpCodes.Ret) j++;\n\t\t\t\t\t\tendIndex = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (beginIndex > -1 && endIndex > -1)\n\t\t{\n\t\t\tcodes.RemoveRange(beginIndex, endIndex - beginIndex + 1);\n\t\t}\n\t\t\n\t\treturn codes.AsEnumerable();\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Prepare Method in C#\nDESCRIPTION: Shows different signatures for implementing the Prepare method which is called before patching starts. The method can optionally take MethodBase and other parameters, and can return bool to control if patching should proceed.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-auxiliary.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Prepare(...)\nstatic void Prepare(MethodBase original, ...)\nstatic bool Prepare(MethodBase original, ...)\n// or\n[HarmonyPrepare]\nstatic void MyInitializer(...)\nstatic void MyInitializer(MethodBase original, ...)\nstatic bool MyInitializer(MethodBase original, ...)\n```\n\n----------------------------------------\n\nTITLE: Implementing Cleanup Method in C#\nDESCRIPTION: Shows different signatures for implementing the Cleanup method which is called after patching completes. Can handle exceptions and perform cleanup operations.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-auxiliary.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Cleanup(...)\nstatic void Cleanup(MethodBase original, ...)\nstatic Exception Cleanup(MethodBase original, ...)\n// or\n[HarmonyCleanup]\nstatic void MyCleanup(...)\nstatic void MyCleanup(MethodBase original, ...)\nstatic Exception MyCleanup(MethodBase original, ...)\n```\n\n----------------------------------------\n\nTITLE: Argument Index Reference in C#\nDESCRIPTION: Shows the format for referencing method arguments by their zero-based index using __n format.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-injections.md#2025-04-17_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n__n  // where n is the zero-based index of the argument\n```\n\n----------------------------------------\n\nTITLE: Implementing Harmony Patch Flow With Finalizer\nDESCRIPTION: Shows the complex execution flow when Finalizer patches are involved, including exception handling and how exceptions can be modified or suppressed by Finalizer patches.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/execution.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nException __exception = null;\nvar __result = default(T);\nvar __state = new object[];\ntry\n{\n    __result = Original(...);\n}\ncatch (Exception __e)\n{\n    __exception = __e;\n}\n\nFinalizer1(ref __exception, ref __result, __state);\nFinalizer2(ref __exception, ref __result, __state);\nFinalizer3(ref __exception, ref __result, __state);\n\nif (__exception != null)\n    throw __exception;\nreturn __result;\n```\n\n----------------------------------------\n\nTITLE: Combining Harmony Annotations in C#\nDESCRIPTION: Example showing how annotations are inherited from class to method, allowing you to combine annotations at different levels for more flexible patching definitions.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/annotations.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(SomeType))]\nclass MyPatches\n{\n    [HarmonyPatch(\"Method1\")]\n    static void Postfix1()\n    {\n        // patch for SomeType.Method1\n    }\n\n    [HarmonyPatch(\"Method2\")]\n    [HarmonyPatch(new Type[] { typeof(int), typeof(string) })]\n    static void Postfix2()\n    {\n        // patch for SomeType.Method2(int, string)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Plugin 1 Implementation - Basic Patch\nDESCRIPTION: First plugin that patches the Bar method with a Postfix. Without priority specifications, plugins are executed in registration order with the same default priority.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/priorities.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(Foo), \"Bar\")]\npublic class Plugin1\n{\n    [HarmonyPostfix]\n    public static void Postfix(ref string __result)\n    {\n        __result = \"new \" + __result;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Plugin 2 Implementation - Competing Patch\nDESCRIPTION: Second plugin that also patches the Bar method with a Postfix. This will execute with the same priority as Plugin 1 if registered later, overriding Plugin 1's changes.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/priorities.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[HarmonyPatch(typeof(Foo), \"Bar\")]\npublic class Plugin2\n{\n    [HarmonyPostfix]\n    public static void Postfix(ref string __result)\n    {\n        __result = __result + \" 2\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Causing MissingMethodException When Patching Too Early in Unity\nDESCRIPTION: This code demonstrates a situation where patching methods that directly or indirectly call external UnityEngine methods too early (like at assembly entry point) will cause a MissingMethodException in Unity.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-edgecases.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GameManager : MonoBehaviour\n{\n    private void Awake()\n    {\n        SomeMethod();\n    }\n\n    private void SomeMethod()\n    {\n        SomeOtherMethod();\n    }\n\n    private void SomeOtherMethod()\n    {\n        DontDestroyOnLoad(gameObject);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Base Method Calling Issue in Harmony Patching\nDESCRIPTION: This snippet demonstrates why using base.SomeMethod() doesn't work as expected in Harmony patch code. The compiler resolves base method calls at compile time, making them difficult to access through reflection or delegates at runtime.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-edgecases.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyClass : BaseClass\n{\n   public override void SomeMethod()\n   {\n      // do something before\n      base.SomeMethod();\n      // do something after\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing IL Code Example in RimWorld's CheckForErrors Method\nDESCRIPTION: This snippet shows the beginning of the IL code for the CheckForErrors method in RimWorld's Dialog_FormCaravan class, including method signature, locals initialization, and the first few instructions.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_2\n\nLANGUAGE: il\nCODE:\n```\n.method private hidebysig\n\tinstance bool CheckForErrors (\n\t\tclass [mscorlib]System.Collections.Generic.List`1<class Verse.Pawn> pawns\n\t) cil managed\n{\n\t// Method begins at RVA 0xbb290\n\t// Code size 617 (0x269)\n\t.maxstack 64\n\t.locals init (\n\t\t[0] class Verse.Pawn,\n\t\t[1] int32,\n\t\t[2] int32,\n\t\t[3] int32,\n\t\t[4] int32,\n\t\t[5] class RimWorld.Dialog_FormCaravan/'<CheckForErrors>c__AnonStorey3F6',\n\t\t[6] class RimWorld.Dialog_FormCaravan/'<CheckForErrors>c__AnonStorey3F8'\n\t)\n\n\tIL_0000: newobj instance void RimWorld.Dialog_FormCaravan/'<CheckForErrors>c__AnonStorey3F6'::.ctor()\n\tIL_0005: stloc.s 5\n\t...\n```\n\n----------------------------------------\n\nTITLE: Analyzing IL Code for a Conditional Check in RimWorld\nDESCRIPTION: This IL code snippet represents a conditional check that evaluates if the caravan's mass usage exceeds its capacity while not in reform mode, followed by message display and early return if the condition is true.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_3\n\nLANGUAGE: il\nCODE:\n```\nIL_0078: ldarg.0\nIL_0079: ldfld bool RimWorld.Dialog_FormCaravan::reform\nIL_007e: brtrue IL_00ac\nIL_0083: ldarg.0\nIL_0084: call instance float32 RimWorld.Dialog_FormCaravan::get_MassUsage()\nIL_0089: ldarg.0\nIL_008a: call instance float32 RimWorld.Dialog_FormCaravan::get_MassCapacity()\nIL_008f: ble.un IL_00ac\nIL_0094: ldarg.0\nIL_0095: call instance void RimWorld.Dialog_FormCaravan::FlashMass()\nIL_009a: ldstr \"TooBigCaravanMassUsage\"\nIL_009f: call string Verse.Translator::Translate(string)\nIL_00a4: ldc.i4.2\nIL_00a5: call void Verse.Messages::Message(string, valuetype Verse.MessageSound)\nIL_00aa: ldc.i4.0\nIL_00ab: ret\n```\n\n----------------------------------------\n\nTITLE: C# Code Equivalent to the IL Conditional Check\nDESCRIPTION: This C# code snippet shows the equivalent high-level code for the IL operations in the previous snippet, demonstrating how the compiler translates conditional logic into IL instructions.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nif (!this.reform && this.MassUsage > this.MassCapacity)\n{\n\tthis.FlashMass();\n\tMessages.Message(\"TooBigCaravanMassUsage\".Translate(), MessageSound.RejectInput);\n\treturn false;\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Method Chaining in IL Code\nDESCRIPTION: This IL code example demonstrates how method chaining works at the IL level, showing how the stack is used to pass objects between method calls without needing temporary variables.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_5\n\nLANGUAGE: il\nCODE:\n```\nldfld Foo SomeStaticClass::theFoo\nldfld Bar Foo::theBar\ncall instance void Bar::Cool()\n```\n\n----------------------------------------\n\nTITLE: Harmony Documentation Table of Contents in Markdown\nDESCRIPTION: A hierarchical structure of documentation links for the Harmony library, organized by topics and subtopics. The main sections include introduction, new features, basics, patching methods, annotations, execution flow, priorities, and utilities.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/toc.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# [Introduction](intro.md)\n\n# [What's New](new.md)\n\n# [Basics](basics.md)\n\n# [Patching](patching.md)\n\n## [Prefix](patching-prefix.md)\n\n## [Postfix](patching-postfix.md)\n\n## [Transpiler](patching-transpiler.md)\n\n## [Transpiler - CodeInstruction](patching-transpiler-codes.md)\n\n## [Transpiler - CodeMatcher](patching-transpiler-matcher.md)\n\n## [Finalizer](patching-finalizer.md)\n\n## [Injections](patching-injections.md)\n\n## [Reverse Patch](reverse-patching.md)\n\n## [Auxiliary methods](patching-auxiliary.md)\n\n## [Edge Cases](patching-edgecases.md)\n\n# [Annotations](annotations.md)\n\n# [Execution Flow](execution.md)\n\n# [Priorities](priorities.md)\n\n# [Utilities](utilities.md)\n```\n\n----------------------------------------\n\nTITLE: C# Equivalent of Method Chaining Example\nDESCRIPTION: This C# code snippet shows the equivalent high-level code for the IL method chaining operations in the previous snippet, demonstrating how nested property access translates to a stack-based sequence of operations.\nSOURCE: https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching-transpiler.md#2025-04-17_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nSomeStaticClass.theFoo.theBar.Cool()\n```"
  }
]