[
  {
    "owner": "google",
    "repo": "or-tools",
    "content": "TITLE: OR-Tools VRP Implementation with Node Max Constraint\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem solver that uses maximum node values to calculate route costs. The solution includes distance constraints, node value tracking across routes, and custom dimension handling for tracking maximum values. Uses OR-Tools' routing solver with a 4-vehicle configuration and 17 nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_node_max.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"value\"] = [\n        0,  # depot\n        42,  # 1\n        42,  # 2\n        8,  # 3\n        8,  # 4\n        8,  # 5\n        8,  # 6\n        8,  # 7\n        8,  # 8\n        8,  # 9\n        8,  # 10\n        8,  # 11\n        8,  # 12\n        8,  # 13\n        8,  # 14\n        42,  # 15\n        42,  # 16\n    ]\n    assert len(data[\"distance_matrix\"]) == len(data[\"value\"])\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    dim_one = routing.GetDimensionOrDie(\"One\")\n    dim_two = routing.GetDimensionOrDie(\"Two\")\n\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            one_var = dim_one.CumulVar(index)\n            one_slack_var = dim_one.SlackVar(index)\n            two_var = dim_two.CumulVar(index)\n            two_slack_var = dim_two.SlackVar(index)\n            plan_output += (\n                f\" N:{manager.IndexToNode(index)}\"\n                f\" one:({solution.Value(one_var)}, {solution.Value(one_slack_var)})\"\n                f\" two:({solution.Value(two_var)}, {solution.Value(two_slack_var)})\"\n                \" -> \"\n            )\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        one_var = dim_one.CumulVar(index)\n        two_var = dim_two.CumulVar(index)\n        plan_output += (\n            f\"N:{manager.IndexToNode(index)}\"\n            f\" one:{solution.Value(one_var)}\"\n            f\" two:{solution.Value(two_var)}\\n\"\n        )\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\n\n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3_000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(10)\n\n    # Max Node value Constraint.\n    # Dimension One will be used to compute the max node value up to the node in\n    # the route and store the result in the SlackVar of the node.\n    routing.AddConstantDimensionWithSlack(\n        0,  # transit 0\n        42 * 16,  # capacity: be able to store PEAK*ROUTE_LENGTH in worst case\n        42,  # slack_max: to be able to store peak in slack\n        True,  #  Fix StartCumulToZero not really matter here\n        \"One\",\n    )\n    dim_one = routing.GetDimensionOrDie(\"One\")\n\n    # Dimension Two will be used to store the max node value in the route end node\n    # CumulVar so we can use it as an objective cost.\n    routing.AddConstantDimensionWithSlack(\n        0,  # transit 0\n        42 * 16,  # capacity: be able to have PEAK value in CumulVar(End)\n        42,  # slack_max: to be able to store peak in slack\n        True,  #  Fix StartCumulToZero YES here\n        \"Two\",\n    )\n    dim_two = routing.GetDimensionOrDie(\"Two\")\n\n    # force depot Slack to be value since we don't have any predecessor...\n    for v in range(manager.GetNumberOfVehicles()):\n        start = routing.Start(v)\n        dim_one.SlackVar(start).SetValue(data[\"value\"][0])\n        routing.AddToAssignment(dim_one.SlackVar(start))\n\n        dim_two.SlackVar(start).SetValue(data[\"value\"][0])\n        routing.AddToAssignment(dim_two.SlackVar(start))\n\n    # Step by step relation\n    # Slack(N) = max( Slack(N-1) , value(N) )\n    solver = routing.solver()\n    for node in range(1, 17):\n        index = manager.NodeToIndex(node)\n        routing.AddToAssignment(dim_one.SlackVar(index))\n        routing.AddToAssignment(dim_two.SlackVar(index))\n        test = []\n        for v in range(manager.GetNumberOfVehicles()):\n            previous_index = routing.Start(v)\n            cond = routing.NextVar(previous_index) == index\n            value = solver.Max(dim_one.SlackVar(previous_index), data[\"value\"][node])\n            test.append((cond * value).Var())\n        for previous in range(1, 17):\n            previous_index = manager.NodeToIndex(previous)\n            cond = routing.NextVar(previous_index) == index\n            value = solver.Max(dim_one.SlackVar(previous_index), data[\"value\"][node])\n            test.append((cond * value).Var())\n        solver.Add(solver.Sum(test) == dim_one.SlackVar(index))\n\n    # relation between dimensions, copy last node Slack from dim ONE to dim TWO\n    for node in range(1, 17):\n        index = manager.NodeToIndex(node)\n        values = []\n        for v in range(manager.GetNumberOfVehicles()):\n            next_index = routing.End(v)\n            cond = routing.NextVar(index) == next_index\n            value = dim_one.SlackVar(index)\n            values.append((cond * value).Var())\n        solver.Add(solver.Sum(values) == dim_two.SlackVar(index))\n\n    # Should force all others dim_two slack var to zero...\n    for v in range(manager.GetNumberOfVehicles()):\n        end = routing.End(v)\n        dim_two.SetCumulVarSoftUpperBound(end, 0, 4200)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    # search_parameters.log_search = True\n    search_parameters.time_limit.FromSeconds(5)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Knapsack Problem using Google CP Solver in Python\nDESCRIPTION: This code defines the knapsack problem constraints, sets up the solver, and implements the solution search. It includes functions for defining the knapsack constraints and a main function to run the solver with a specific problem instance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/knapsack_cp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef knapsack(solver, values, weights, n):\n  z = solver.IntVar(0, 10000)\n  x = [solver.IntVar(0, 1, \"x(%i)\" % i) for i in range(len(values))]\n  solver.Add(z >= 0)\n  solver.Add(z == solver.ScalProd(x, values))\n  solver.Add(solver.ScalProd(x, weights) <= n)\n\n  return [x, z]\n\n\ndef main(values, weights, n):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"knapsack_cp\")\n\n  #\n  # data\n  #\n  print(\"values:\", values)\n  print(\"weights:\", weights)\n  print(\"n:\", n)\n  print()\n\n  # declare variables\n\n  #\n  # constraints\n  #\n  [x, z] = knapsack(solver, values, weights, n)\n\n  # objective\n  objective = solver.Maximize(z, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(z)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MAX_VALUE)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"x:\", [x[i].Value() for i in range(len(values))])\n    print(\"z:\", z.Value())\n    print()\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nvalues = [15, 100, 90, 60, 40, 15, 10, 1, 12, 12, 100]\nweights = [2, 20, 20, 30, 40, 30, 60, 10, 21, 12, 2]\nn = 102\n\nmain(values, weights, n)\n```\n\n----------------------------------------\n\nTITLE: VRP Time Windows Implementation\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem solver with time windows constraints. The code includes data model creation, routing setup, constraint definition, and solution optimization using OR-Tools. It handles multiple vehicles, time matrix calculations, and prints optimized routes with time windows.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_time_windows.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"time_matrix\"] = [\n        [0, 6, 9, 8, 7, 3, 6, 2, 3, 2, 6, 6, 4, 4, 5, 9, 7],\n        [6, 0, 8, 3, 2, 6, 8, 4, 8, 8, 13, 7, 5, 8, 12, 10, 14],\n        [9, 8, 0, 11, 10, 6, 3, 9, 5, 8, 4, 15, 14, 13, 9, 18, 9],\n        [8, 3, 11, 0, 1, 7, 10, 6, 10, 10, 14, 6, 7, 9, 14, 6, 16],\n        [7, 2, 10, 1, 0, 6, 9, 4, 8, 9, 13, 4, 6, 8, 12, 8, 14],\n        [3, 6, 6, 7, 6, 0, 2, 3, 2, 2, 7, 9, 7, 7, 6, 12, 8],\n        [6, 8, 3, 10, 9, 2, 0, 6, 2, 5, 4, 12, 10, 10, 6, 15, 5],\n        [2, 4, 9, 6, 4, 3, 6, 0, 4, 4, 8, 5, 4, 3, 7, 8, 10],\n        [3, 8, 5, 10, 8, 2, 2, 4, 0, 3, 4, 9, 8, 7, 3, 13, 6],\n        [2, 8, 8, 10, 9, 2, 5, 4, 3, 0, 4, 6, 5, 4, 3, 9, 5],\n        [6, 13, 4, 14, 13, 7, 4, 8, 4, 4, 0, 10, 9, 8, 4, 13, 4],\n        [6, 7, 15, 6, 4, 9, 12, 5, 9, 6, 10, 0, 1, 3, 7, 3, 10],\n        [4, 5, 14, 7, 6, 7, 10, 4, 8, 5, 9, 1, 0, 2, 6, 4, 8],\n        [4, 8, 13, 9, 8, 7, 10, 3, 7, 4, 8, 3, 2, 0, 4, 5, 6],\n        [5, 12, 9, 14, 12, 6, 6, 7, 3, 3, 4, 7, 6, 4, 0, 9, 2],\n        [9, 10, 18, 6, 8, 12, 15, 8, 13, 9, 13, 3, 4, 5, 9, 0, 9],\n        [7, 14, 9, 16, 14, 8, 5, 10, 6, 5, 4, 10, 8, 6, 2, 9, 0],\n    ]\n    data[\"time_windows\"] = [\n        (0, 5),  # depot\n        (7, 12),  # 1\n        (10, 15),  # 2\n        (16, 18),  # 3\n        (10, 13),  # 4\n        (0, 5),  # 5\n        (5, 10),  # 6\n        (0, 4),  # 7\n        (5, 10),  # 8\n        (0, 3),  # 9\n        (10, 16),  # 10\n        (10, 15),  # 11\n        (0, 5),  # 12\n        (5, 10),  # 13\n        (7, 8),  # 14\n        (10, 15),  # 15\n        (11, 15),  # 16\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    total_time = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        while not routing.IsEnd(index):\n            time_var = time_dimension.CumulVar(index)\n            plan_output += (\n                f\"{manager.IndexToNode(index)}\"\n                f\" Time({solution.Min(time_var)},{solution.Max(time_var)})\"\n                \" -> \"\n            )\n            index = solution.Value(routing.NextVar(index))\n        time_var = time_dimension.CumulVar(index)\n        plan_output += (\n            f\"{manager.IndexToNode(index)}\"\n            f\" Time({solution.Min(time_var)},{solution.Max(time_var)})\\n\"\n        )\n        plan_output += f\"Time of the route: {solution.Min(time_var)}min\\n\"\n        print(plan_output)\n        total_time += solution.Min(time_var)\n    print(f\"Total time of all routes: {total_time}min\")\n\n\ndef main():\n    \"\"\"Solve the VRP with time windows.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"time_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def time_callback(from_index, to_index):\n        \"\"\"Returns the travel time between the two nodes.\"\"\"\n        # Convert from routing variable Index to time matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"time_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(time_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Time Windows constraint.\n    time = \"Time\"\n    routing.AddDimension(\n        transit_callback_index,\n        30,  # allow waiting time\n        30,  # maximum time per vehicle\n        False,  # Don't force start cumul to zero.\n        time,\n    )\n    time_dimension = routing.GetDimensionOrDie(time)\n    # Add time window constraints for each location except depot.\n    for location_idx, time_window in enumerate(data[\"time_windows\"]):\n        if location_idx == data[\"depot\"]:\n            continue\n        index = manager.NodeToIndex(location_idx)\n        time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])\n    # Add time window constraints for each vehicle start node.\n    depot_idx = data[\"depot\"]\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        time_dimension.CumulVar(index).SetRange(\n            data[\"time_windows\"][depot_idx][0], data[\"time_windows\"][depot_idx][1]\n        )\n\n    # Instantiate route start and end times to produce feasible times.\n    for i in range(data[\"num_vehicles\"]):\n        routing.AddVariableMinimizedByFinalizer(\n            time_dimension.CumulVar(routing.Start(i))\n        )\n        routing.AddVariableMinimizedByFinalizer(time_dimension.CumulVar(routing.End(i)))\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with MIP in Python\nDESCRIPTION: Implements a Mixed Integer Programming solution to assign workers to tasks while minimizing total cost, using constraints to ensure each worker is assigned to at most one task and each task is assigned to exactly one worker\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\ndef main():\n    # Data\n    costs = [\n        [90, 80, 75, 70],\n        [35, 85, 55, 65],\n        [125, 95, 90, 95],\n        [45, 110, 95, 115],\n        [50, 100, 90, 100],\n    ]\n    num_workers = len(costs)\n    num_tasks = len(costs[0])\n\n    # Solver\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n\n    if not solver:\n        return\n\n    # Variables\n    x = {}\n    for i in range(num_workers):\n        for j in range(num_tasks):\n            x[i, j] = solver.IntVar(0, 1, \"\")\n\n    # Constraints\n    for i in range(num_workers):\n        solver.Add(solver.Sum([x[i, j] for j in range(num_tasks)]) <= 1)\n\n    for j in range(num_tasks):\n        solver.Add(solver.Sum([x[i, j] for i in range(num_workers)]) == 1)\n\n    # Objective\n    objective_terms = []\n    for i in range(num_workers):\n        for j in range(num_tasks):\n            objective_terms.append(costs[i][j] * x[i, j])\n    solver.Minimize(solver.Sum(objective_terms))\n\n    # Solve\n    status = solver.Solve()\n\n    # Print solution\n    if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n        print(f\"Total cost = {solver.Objective().Value()}\\n\")\n        for i in range(num_workers):\n            for j in range(num_tasks):\n                if x[i, j].solution_value() > 0.5:\n                    print(f\"Worker {i} assigned to task {j}.\" + f\" Cost: {costs[i][j]}\")\n    else:\n        print(\"No solution found.\")\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with OR-Tools Python\nDESCRIPTION: Solves an assignment problem using OR-Tools by creating a solver, defining boolean variables for each worker-task pair, setting constraints on task assignments, enforcing team size limits, and minimizing the total assignment cost. It requires the OR-Tools library and configures the SCIP solver backend. Expected output is the optimal task assignment with minimized costs for available workers.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_teams_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef main():\n    # Data\n    costs = [\n        [90, 76, 75, 70],\n        [35, 85, 55, 65],\n        [125, 95, 90, 105],\n        [45, 110, 95, 115],\n        [60, 105, 80, 75],\n        [45, 65, 110, 95],\n    ]\n    num_workers = len(costs)\n    num_tasks = len(costs[0])\n\n    team1 = [0, 2, 4]\n    team2 = [1, 3, 5]\n    # Maximum total of tasks for any team\n    team_max = 2\n\n    # Solver\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n    if not solver:\n        return\n\n    # Variables\n    # x[i, j] is an array of 0-1 variables, which will be 1\n    # if worker i is assigned to task j.\n    x = {}\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            x[worker, task] = solver.BoolVar(f\"x[{worker},{task}]\")\n\n    # Constraints\n    # Each worker is assigned at most 1 task.\n    for worker in range(num_workers):\n        solver.Add(solver.Sum([x[worker, task] for task in range(num_tasks)]) <= 1)\n\n    # Each task is assigned to exactly one worker.\n    for task in range(num_tasks):\n        solver.Add(solver.Sum([x[worker, task] for worker in range(num_workers)]) == 1)\n\n    # Each team takes at most two tasks.\n    team1_tasks = []\n    for worker in team1:\n        for task in range(num_tasks):\n            team1_tasks.append(x[worker, task])\n    solver.Add(solver.Sum(team1_tasks) <= team_max)\n\n    team2_tasks = []\n    for worker in team2:\n        for task in range(num_tasks):\n            team2_tasks.append(x[worker, task])\n    solver.Add(solver.Sum(team2_tasks) <= team_max)\n\n    # Objective\n    objective_terms = []\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            objective_terms.append(costs[worker][task] * x[worker, task])\n    solver.Minimize(solver.Sum(objective_terms))\n\n    # Solve\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    # Print solution.\n    if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n        print(f\"Total cost = {solver.Objective().Value()}\\n\")\n        for worker in range(num_workers):\n            for task in range(num_tasks):\n                if x[worker, task].solution_value() > 0.5:\n                    print(\n                        f\"Worker {worker} assigned to task {task}.\"\n                        + f\" Cost = {costs[worker][task]}\"\n                    )\n    else:\n        print(\"No solution found.\")\n    print(f\"Time = {solver.WallTime()} ms\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Solving Magic Sequence Problem with CP-SAT in Python\nDESCRIPTION: This code snippet defines and solves the magic sequence problem for a sequence of length 100. It creates integer variables, sets constraints to ensure each number represents its frequency, and uses the CP-SAT solver to find a solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_sequence_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef main():\n  \"\"\"Magic sequence problem.\"\"\"\n  n = 100\n  values = range(n)\n\n  model = cp_model.CpModel()\n\n  x = [model.NewIntVar(0, n, 'x%i' % i) for i in values]\n\n  for k in values:\n    tmp_array = []\n    for i in values:\n      tmp_var = model.NewBoolVar('')\n      model.Add(x[i] == k).OnlyEnforceIf(tmp_var)\n      model.Add(x[i] != k).OnlyEnforceIf(tmp_var.Not())\n      tmp_array.append(tmp_var)\n    model.Add(sum(tmp_array) == x[k])\n\n  # Redundant constraint.\n  model.Add(sum(x) == n)\n\n  solver = cp_model.CpSolver()\n  # No solution printer, this problem has only 1 solution.\n  solver.parameters.log_search_progress = True\n  solver.Solve(model)\n  print(solver.ResponseStats())\n  for k in values:\n    print('x[%i] = %i ' % (k, solver.Value(x[k])), end='')\n  print()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Shift Scheduling with CP-SAT Solver\nDESCRIPTION: Complete implementation of a shift scheduling solver using Google OR-Tools CP-SAT. The code includes functions for handling sequence constraints, sum constraints, and the main solver implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/shift_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\n    \"params\", \"max_time_in_seconds:10.0\", \"Sat solver parameters.\"\n)\n\n\ndef negated_bounded_span(\n    works: list[cp_model.BoolVarT], start: int, length: int\n) -> list[cp_model.BoolVarT]:\n    \"\"\"Filters an isolated sub-sequence of variables assined to True.\n\n    Extract the span of Boolean variables [start, start + length), negate them,\n    and if there is variables to the left/right of this span, surround the span by\n    them in non negated form.\n\n    Args:\n      works: a list of variables to extract the span from.\n      start: the start to the span.\n      length: the length of the span.\n\n    Returns:\n      a list of variables which conjunction will be false if the sub-list is\n      assigned to True, and correctly bounded by variables assigned to False,\n      or by the start or end of works.\n    \"\"\"\n    sequence = []\n    # left border (start of works, or works[start - 1])\n    if start > 0:\n        sequence.append(works[start - 1])\n    for i in range(length):\n        sequence.append(~works[start + i])\n    # right border (end of works or works[start + length])\n    if start + length < len(works):\n        sequence.append(works[start + length])\n    return sequence\n\n\ndef add_soft_sequence_constraint(\n    model: cp_model.CpModel,\n    works: list[cp_model.BoolVarT],\n    hard_min: int,\n    soft_min: int,\n    min_cost: int,\n    soft_max: int,\n    hard_max: int,\n    max_cost: int,\n    prefix: str,\n) -> tuple[list[cp_model.BoolVarT], list[int]]:\n    \"\"\"Sequence constraint on true variables with soft and hard bounds.\n\n    This constraint look at every maximal contiguous sequence of variables\n    assigned to true. If forbids sequence of length < hard_min or > hard_max.\n    Then it creates penalty terms if the length is < soft_min or > soft_max.\n\n    Args:\n      model: the sequence constraint is built on this model.\n      works: a list of Boolean variables.\n      hard_min: any sequence of true variables must have a length of at least\n        hard_min.\n      soft_min: any sequence should have a length of at least soft_min, or a\n        linear penalty on the delta will be added to the objective.\n      min_cost: the coefficient of the linear penalty if the length is less than\n        soft_min.\n      soft_max: any sequence should have a length of at most soft_max, or a linear\n        penalty on the delta will be added to the objective.\n      hard_max: any sequence of true variables must have a length of at most\n        hard_max.\n      max_cost: the coefficient of the linear penalty if the length is more than\n        soft_max.\n      prefix: a base name for penalty literals.\n\n    Returns:\n      a tuple (variables_list, coefficient_list) containing the different\n      penalties created by the sequence constraint.\n    \"\"\"\n    cost_literals = []\n    cost_coefficients = []\n\n    # Forbid sequences that are too short.\n    for length in range(1, hard_min):\n        for start in range(len(works) - length + 1):\n            model.add_bool_or(negated_bounded_span(works, start, length))\n\n    # Penalize sequences that are below the soft limit.\n    if min_cost > 0:\n        for length in range(hard_min, soft_min):\n            for start in range(len(works) - length + 1):\n                span = negated_bounded_span(works, start, length)\n                name = f\": under_span(start={start}, length={length})\"\n                lit = model.new_bool_var(prefix + name)\n                span.append(lit)\n                model.add_bool_or(span)\n                cost_literals.append(lit)\n                # We filter exactly the sequence with a short length.\n                # The penalty is proportional to the delta with soft_min.\n                cost_coefficients.append(min_cost * (soft_min - length))\n\n    # Penalize sequences that are above the soft limit.\n    if max_cost > 0:\n        for length in range(soft_max + 1, hard_max + 1):\n            for start in range(len(works) - length + 1):\n                span = negated_bounded_span(works, start, length)\n                name = f\": over_span(start={start}, length={length})\"\n                lit = model.new_bool_var(prefix + name)\n                span.append(lit)\n                model.add_bool_or(span)\n                cost_literals.append(lit)\n                # Cost paid is max_cost * excess length.\n                cost_coefficients.append(max_cost * (length - soft_max))\n\n    # Just forbid any sequence of true variables with length hard_max + 1\n    for start in range(len(works) - hard_max):\n        model.add_bool_or([~works[i] for i in range(start, start + hard_max + 1)])\n    return cost_literals, cost_coefficients\n\n\ndef add_soft_sum_constraint(\n    model: cp_model.CpModel,\n    works: list[cp_model.BoolVarT],\n    hard_min: int,\n    soft_min: int,\n    min_cost: int,\n    soft_max: int,\n    hard_max: int,\n    max_cost: int,\n    prefix: str,\n) -> tuple[list[cp_model.IntVar], list[int]]:\n    \"\"\"sum constraint with soft and hard bounds.\n\n    This constraint counts the variables assigned to true from works.\n    If forbids sum < hard_min or > hard_max.\n    Then it creates penalty terms if the sum is < soft_min or > soft_max.\n\n    Args:\n      model: the sequence constraint is built on this model.\n      works: a list of Boolean variables.\n      hard_min: any sequence of true variables must have a sum of at least\n        hard_min.\n      soft_min: any sequence should have a sum of at least soft_min, or a linear\n        penalty on the delta will be added to the objective.\n      min_cost: the coefficient of the linear penalty if the sum is less than\n        soft_min.\n      soft_max: any sequence should have a sum of at most soft_max, or a linear\n        penalty on the delta will be added to the objective.\n      hard_max: any sequence of true variables must have a sum of at most\n        hard_max.\n      max_cost: the coefficient of the linear penalty if the sum is more than\n        soft_max.\n      prefix: a base name for penalty variables.\n\n    Returns:\n      a tuple (variables_list, coefficient_list) containing the different\n      penalties created by the sequence constraint.\n    \"\"\"\n    cost_variables = []\n    cost_coefficients = []\n    sum_var = model.new_int_var(hard_min, hard_max, \"\")\n    # This adds the hard constraints on the sum.\n    model.add(sum_var == sum(works))\n\n    # Penalize sums below the soft_min target.\n    if soft_min > hard_min and min_cost > 0:\n        delta = model.new_int_var(-len(works), len(works), \"\")\n        model.add(delta == soft_min - sum_var)\n        # TODO(user): Compare efficiency with only excess >= soft_min - sum_var.\n        excess = model.new_int_var(0, 7, prefix + \": under_sum\")\n        model.add_max_equality(excess, [delta, 0])\n        cost_variables.append(excess)\n        cost_coefficients.append(min_cost)\n\n    # Penalize sums above the soft_max target.\n    if soft_max < hard_max and max_cost > 0:\n        delta = model.new_int_var(-7, 7, \"\")\n        model.add(delta == sum_var - soft_max)\n        excess = model.new_int_var(0, 7, prefix + \": over_sum\")\n        model.add_max_equality(excess, [delta, 0])\n        cost_variables.append(excess)\n        cost_coefficients.append(max_cost)\n\n    return cost_variables, cost_coefficients\n\n\ndef solve_shift_scheduling(params: str, output_proto: str):\n    \"\"\"Solves the shift scheduling problem.\"\"\"\n    # Data\n    num_employees = 8\n    num_weeks = 3\n    shifts = [\"O\", \"M\", \"A\", \"N\"]\n\n    # Fixed assignment: (employee, shift, day).\n    # This fixes the first 2 days of the schedule.\n    fixed_assignments = [\n        (0, 0, 0),\n        (1, 0, 0),\n        (2, 1, 0),\n        (3, 1, 0),\n        (4, 2, 0),\n        (5, 2, 0),\n        (6, 2, 3),\n        (7, 3, 0),\n        (0, 1, 1),\n        (1, 1, 1),\n        (2, 2, 1),\n        (3, 2, 1),\n        (4, 2, 1),\n        (5, 0, 1),\n        (6, 0, 1),\n        (7, 3, 1),\n    ]\n\n    # Request: (employee, shift, day, weight)\n    # A negative weight indicates that the employee desire this assignment.\n    requests = [\n        # Employee 3 does not want to work on the first Saturday (negative weight\n        # for the Off shift).\n        (3, 0, 5, -2),\n        # Employee 5 wants a night shift on the second Thursday (negative weight).\n        (5, 3, 10, -2),\n        # Employee 2 does not want a night shift on the first Friday (positive\n        # weight).\n        (2, 3, 4, 4),\n    ]\n\n    # Shift constraints on continuous sequence :\n    #     (shift, hard_min, soft_min, min_penalty,\n    #             soft_max, hard_max, max_penalty)\n    shift_constraints = [\n        # One or two consecutive days of rest, this is a hard constraint.\n        (0, 1, 1, 0, 2, 2, 0),\n        # between 2 and 3 consecutive days of night shifts, 1 and 4 are\n        # possible but penalized.\n        (3, 1, 2, 20, 3, 4, 5),\n    ]\n\n    # Weekly sum constraints on shifts days:\n    #     (shift, hard_min, soft_min, min_penalty,\n    #             soft_max, hard_max, max_penalty)\n    weekly_sum_constraints = [\n        # Constraints on rests per week.\n        (0, 1, 2, 7, 2, 3, 4),\n\n```\n\n----------------------------------------\n\nTITLE: Solving Cryptarithmetic Puzzle with CP-SAT in Python\nDESCRIPTION: This code snippet implements a cryptarithmetic solver using OR-Tools' CP-SAT solver in Python. It defines variables for each letter in the equation CP + IS + FUN = TRUE, ensures all are different using 'add_all_different', and constructs the equation as a constraint. The snippet includes a custom solution printer and performs the solving with an enumeration of all solutions upon execution of 'main'. Dependencies include the ortools package. Inputs involve executing the script, and outputs are the multiple solutions printed to the console.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cp_is_fun_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"python\\nfrom ortools.sat.python import cp_model\\n\\n\\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\\n    \\\"\\\"\\\"Print intermediate solutions.\\\"\\\"\\\"\\n\\n    def __init__(self, variables: list[cp_model.IntVar]):\\n        cp_model.CpSolverSolutionCallback.__init__(self)\\n        self.__variables = variables\\n        self.__solution_count = 0\\n\\n    def on_solution_callback(self) -> None:\\n        self.__solution_count += 1\\n        for v in self.__variables:\\n            print(f\\\"{v}={self.value(v)}\\\", end=\\\" \\\")\\n        print()\\n\\n    @property\\n    def solution_count(self) -> int:\\n        return self.__solution_count\\n\\n\\ndef main() -> None:\\n    \\\"\\\"\\\"solve the CP+IS+FUN==TRUE cryptarithm.\\\"\\\"\\\"\\n    # Constraint programming engine\\n    model = cp_model.CpModel()\\n\\n    base = 10\\n\\n    c = model.new_int_var(1, base - 1, \\\"C\\\")\\n    p = model.new_int_var(0, base - 1, \\\"P\\\")\\n    i = model.new_int_var(1, base - 1, \\\"I\\\")\\n    s = model.new_int_var(0, base - 1, \\\"S\\\")\\n    f = model.new_int_var(1, base - 1, \\\"F\\\")\\n    u = model.new_int_var(0, base - 1, \\\"U\\\")\\n    n = model.new_int_var(0, base - 1, \\\"N\\\")\\n    t = model.new_int_var(1, base - 1, \\\"T\\\")\\n    r = model.new_int_var(0, base - 1, \\\"R\\\")\\n    e = model.new_int_var(0, base - 1, \\\"E\\\")\\n\\n    # We need to group variables in a list to use the constraint AllDifferent.\\n    letters = [c, p, i, s, f, u, n, t, r, e]\\n\\n    # Verify that we have enough digits.\\n    assert base >= len(letters)\\n\\n    # Define constraints.\\n    model.add_all_different(letters)\\n\\n    # CP + IS + FUN = TRUE\\n    model.add(\\n        c * base + p + i * base + s + f * base * base + u * base + n\\n        == t * base * base * base + r * base * base + u * base + e\\n    )\\n\\n    # Creates a solver and solves the model.\\n    solver = cp_model.CpSolver()\\n    solution_printer = VarArraySolutionPrinter(letters)\\n    # Enumerate all solutions.\\n    solver.parameters.enumerate_all_solutions = True\\n    # Solve.\\n    status = solver.solve(model, solution_printer)\\n\\n    # Statistics.\\n    print(\\\"\\nStatistics\\\")\\n    print(f\\\"  status   : {solver.status_name(status)}\\\")\\n    print(f\\\"  conflicts: {solver.num_conflicts}\\\")\\n    print(f\\\"  branches : {solver.num_branches}\\\")\\n    print(f\\\"  wall time: {solver.wall_time} s\\\")\\n    print(f\\\"  sol found: {solution_printer.solution_count}\\\")\\n\\n\\nmain()\\n\\n\\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Data Initialization for Vehicle Routing using OR-Tools\nDESCRIPTION: This snippet initializes data for the vehicle routing problem using OR-Tools, including vehicle properties, location coordinates based on a defined city block size, and demands and time windows for service locations. Dependencies include the OR-Tools library and a proper understanding of routing and distance metrics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/transit_time.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.constraint_solver import pywrapcp\\nfrom ortools.constraint_solver import routing_enums_pb2\\nclass Vehicle():\\n    def __init__(self):\\n        self._capacity = 15\\n        self._speed = 5 * 60 / 3.6\\n    @property\\n    def speed(self):\\n        return self._speed\\nclass CityBlock():\\n    @property\\n    def width(self):\\n        return 228 / 2\\n    @property\\n    def height(self):\\n        return 80\\nclass DataProblem():\\n    def __init__(self):\\n        self._vehicle = Vehicle()\\n        locations = \\\n              [(4, 4), (2, 0), (8, 0), (0, 1), (1, 1), (5, 2), (7, 2), (3, 3), (6, 3), (5, 5), (8, 5), (1, 6), (2, 6), (3, 7), (6, 7), (0, 8), (7, 8)]\\n        city_block = CityBlock()\\n        self._locations = [(loc[0] * city_block.width, loc[1] * city_block.height) for loc in locations]\\n        self._depot = 0\\n        self._demands = \\\n            [0, 1, 1, 2, 4, 2, 4, 8, 8, 1, 2, 1, 2, 4, 4, 8, 8]\\n        self._time_windows = \\\n            [(0, 0), (75, 85), (75, 85), (60, 70), (45, 55), (0, 8), (50, 60), (0, 10), (10, 20), (0, 10), (75, 85), (85, 95), (5, 15), (15, 25), (10, 20), (45, 55), (30, 40)]\\n    @property\\n    def vehicle(self):\\n        return self._vehicle\\n    @property\\n    def locations(self):\\n        return self._locations\\n    @property\\n    def num_locations(self):\\n        return len(self.locations)\\n    @property\\n    def depot(self):\\n        return self._depot\\n    @property\\n    def demands(self):\\n        return self._demands\\n    @property\\n    def time_per_demand_unit(self):\\n        return 5\\n    @property\\n    def time_windows(self):\\n        return self._time_windows\"\n```\n\n----------------------------------------\n\nTITLE: TSP Implementation Using Location Coordinates\nDESCRIPTION: Demonstrates solving TSP by providing location coordinates directly to the Vehicle Routing solver. The solver calculates distances between points and finds the optimal route.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/TSP.md#2025-04-17_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ntsp.cc\n```\n\nLANGUAGE: Python\nCODE:\n```\ntsp.py\n```\n\nLANGUAGE: Java\nCODE:\n```\nTsp.java\n```\n\nLANGUAGE: C#\nCODE:\n```\nTsp.cs\n```\n\n----------------------------------------\n\nTITLE: Maze Escape Algorithm Implementation\nDESCRIPTION: Complete implementation of a 3D maze escape solver using OR-Tools CP-SAT. The algorithm finds a path through a 4x4x4 maze that starts at a given position, collects treasures in order, and ends at a specified position while visiting each block exactly once. It uses constraint programming to model valid moves in six directions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/maze_escape_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Dict, Sequence, Tuple\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:8,log_search_progress:true\",\n    \"Sat solver parameters.\",\n)\n\n\ndef add_neighbor(\n    size: int,\n    x: int,\n    y: int,\n    z: int,\n    dx: int,\n    dy: int,\n    dz: int,\n    model: cp_model.CpModel,\n    index_map: Dict[Tuple[int, int, int], int],\n    position_to_rank: Dict[Tuple[int, int, int], cp_model.IntVar],\n    arcs: list[Tuple[int, int, cp_model.LiteralT]],\n) -> None:\n    \"\"\"Checks if the neighbor is valid, and adds it to the model.\"\"\"\n    if (\n        x + dx < 0\n        or x + dx >= size\n        or y + dy < 0\n        or y + dy >= size\n        or z + dz < 0\n        or z + dz >= size\n    ):\n        return\n    before_index = index_map[(x, y, z)]\n    before_rank = position_to_rank[(x, y, z)]\n    after_index = index_map[(x + dx, y + dy, z + dz)]\n    after_rank = position_to_rank[(x + dx, y + dy, z + dz)]\n    move_literal = model.new_bool_var(\"\")\n    model.add(after_rank == before_rank + 1).only_enforce_if(move_literal)\n    arcs.append((before_index, after_index, move_literal))\n\n\ndef escape_the_maze(params: str, output_proto: str) -> None:\n    \"\"\"Escapes the maze.\"\"\"\n    size = 4\n    boxes = [(0, 1, 0), (2, 0, 1), (1, 3, 1), (3, 1, 3)]\n    start = (3, 3, 0)\n    end = (1, 0, 0)\n\n    # Builds a map between each position in the grid and a unique integer between\n    # 0 and size^3 - 1.\n    index_map = {}\n    reverse_map = []\n    counter = 0\n    for x in range(size):\n        for y in range(size):\n            for z in range(size):\n                index_map[(x, y, z)] = counter\n                reverse_map.append((x, y, z))\n                counter += 1\n\n    # Starts building the model.\n    model = cp_model.CpModel()\n    position_to_rank = {}\n\n    for coord in reverse_map:\n        position_to_rank[coord] = model.new_int_var(0, counter - 1, f\"rank_{coord}\")\n\n    # Path constraints.\n    model.add(position_to_rank[start] == 0)\n    model.add(position_to_rank[end] == counter - 1)\n    for i in range(len(boxes) - 1):\n        model.add(position_to_rank[boxes[i]] < position_to_rank[boxes[i + 1]])\n\n    # Circuit constraint: visit all blocks exactly once, and maintains the rank\n    # of each block.\n    arcs: list[Tuple[int, int, cp_model.LiteralT]] = []\n    for x in range(size):\n        for y in range(size):\n            for z in range(size):\n                add_neighbor(\n                    size, x, y, z, -1, 0, 0, model, index_map, position_to_rank, arcs\n                )\n                add_neighbor(\n                    size, x, y, z, 1, 0, 0, model, index_map, position_to_rank, arcs\n                )\n                add_neighbor(\n                    size, x, y, z, 0, -1, 0, model, index_map, position_to_rank, arcs\n                )\n                add_neighbor(\n                    size, x, y, z, 0, 1, 0, model, index_map, position_to_rank, arcs\n                )\n                add_neighbor(\n                    size, x, y, z, 0, 0, -1, model, index_map, position_to_rank, arcs\n                )\n                add_neighbor(\n                    size, x, y, z, 0, 0, 1, model, index_map, position_to_rank, arcs\n                )\n\n    # Closes the loop as the constraint expects a circuit, not a path.\n    arcs.append((index_map[end], index_map[start], True))\n\n    # Adds the circuit (hamiltonian path) constraint.\n    model.add_circuit(arcs)\n\n    # Exports the model if required.\n    if output_proto:\n        model.export_to_file(output_proto)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    if params:\n        text_format.Parse(params, solver.parameters)\n    solver.parameters.log_search_progress = True\n    result = solver.solve(model)\n\n    # Prints solution.\n    if result == cp_model.OPTIMAL:\n        path = [\"\"] * counter\n        for x in range(size):\n            for y in range(size):\n                for z in range(size):\n                    position = (x, y, z)\n                    rank = solver.value(position_to_rank[position])\n                    msg = f\"({x}, {y}, {z})\"\n                    if position == start:\n                        msg += \" [start]\"\n                    elif position == end:\n                        msg += \" [end]\"\n                    else:\n                        for b, box in enumerate(boxes):\n                            if position == box:\n                                msg += f\" [boxes {b}]\"\n                    path[rank] = msg\n        print(path)\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    escape_the_maze(_PARAMS.value, _OUTPUT_PROTO.value)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Main Function for Vehicle Routing Problem with OR-Tools in Python\nDESCRIPTION: Main entry point that sets up and solves a vehicle routing problem with optional visits using Google OR-Tools. It creates a routing model with distance constraints, allows dropping nodes based on visit values, configures search parameters, and solves the problem using Guided Local Search with a time limit.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    num_nodes = len(DISTANCE_MATRIX)\n    print(f'Num nodes = {num_nodes}')\n    num_vehicles = 4\n    depot = 0\n    all_nodes = range(num_nodes)\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n            num_nodes,\n            num_vehicles,\n            depot)\n\n    # Create routing model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return DISTANCE_MATRIX[from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Limit Vehicle distance.\n    dimension_name = 'Distance'\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        MAX_DISTANCE,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name)\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(1)\n\n    # Allow to drop nodes.\n    for node in range(1, num_nodes):\n        routing.AddDisjunction(\n                [manager.NodeToIndex(node)],\n                VISIT_VALUES[node])\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH)\n    search_parameters.time_limit.FromSeconds(15)\n    #search_parameters.log_search = True\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(manager, routing, assignment)\n```\n\n----------------------------------------\n\nTITLE: Implementing Capacitated Vehicle Routing Problem with Droppable Nodes in Python\nDESCRIPTION: A complete implementation of a CVRP solver that allows nodes to be dropped if including them would violate constraints. The code creates a distance matrix, defines vehicle capacities and node demands, and includes penalties for dropping nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_drop_nodes.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"demands\"] = [0, 1, 1, 3, 6, 3, 6, 8, 8, 1, 2, 1, 2, 6, 6, 8, 8]\n    data[\"vehicle_capacities\"] = [15, 15, 15, 15]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    # Display dropped nodes.\n    dropped_nodes = \"Dropped nodes:\"\n    for node in range(routing.Size()):\n        if routing.IsStart(node) or routing.IsEnd(node):\n            continue\n        if assignment.Value(routing.NextVar(node)) == node:\n            dropped_nodes += f\" {manager.IndexToNode(node)}\"\n    print(dropped_nodes)\n    # Display routes\n    total_distance = 0\n    total_load = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        route_load = 0\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index)\n            route_load += data[\"demands\"][node_index]\n            plan_output += f\" {node_index} Load({route_load}) -> \"\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\" {manager.IndexToNode(index)} Load({route_load})\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        plan_output += f\"Load of the route: {route_load}\\n\"\n        print(plan_output)\n        total_distance += route_distance\n        total_load += route_load\n    print(f\"Total Distance of all routes: {total_distance}m\")\n    print(f\"Total Load of all routes: {total_load}\")\n\n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Capacity constraint.\n    def demand_callback(from_index):\n        \"\"\"Returns the demand of the node.\"\"\"\n        # Convert from routing variable Index to demands NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        return data[\"demands\"][from_node]\n\n    demand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)\n    routing.AddDimensionWithVehicleCapacity(\n        demand_callback_index,\n        0,  # null capacity slack\n        data[\"vehicle_capacities\"],  # vehicle maximum capacities\n        True,  # start cumul to zero\n        \"Capacity\",\n    )\n    # Allow to drop nodes.\n    penalty = 1000\n    for node in range(1, len(data[\"distance_matrix\"])):\n        routing.AddDisjunction([manager.NodeToIndex(node)], penalty)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(1)\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(data, manager, routing, assignment)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Vehicle Routing Problem with Time Limit using OR-Tools\nDESCRIPTION: Demonstrates a complete implementation of solving a Vehicle Routing Problem with a time limit constraint. The code creates a routing problem with 20 locations and 5 vehicles, defines a simple distance calculation, sets up constraints including maximum travel distance, configures search parameters with a 5-second time limit, and solves the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_with_time_limit.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    num_locations = 20\n    num_vehicles = 5\n    depot = 0\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(num_locations, num_vehicles, depot)\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        # pylint: disable=unused-argument\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        return 1\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.log_search = True\n    search_parameters.time_limit.FromSeconds(5)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing Problem using OR-Tools in Python\nDESCRIPTION: This code implements a simple vehicle routing problem using Google OR-Tools. It creates a routing model for one vehicle visiting 5 locations, defines a distance callback function, sets up the solver parameters, and solves the problem. The solution is then printed, showing the route and total distance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/simple_routing_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    num_locations = 5\n    num_vehicles = 1\n    depot = 0\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(num_locations, num_vehicles, depot)\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the absolute difference between the two nodes.\"\"\"\n        # Convert from routing variable Index to user NodeIndex.\n        from_node = int(manager.IndexToNode(from_index))\n        to_node = int(manager.IndexToNode(to_index))\n        return abs(to_node - from_node)\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )  # pylint: disable=no-member\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    index = routing.Start(0)\n    plan_output = \"Route for vehicle 0:\\n\"\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += f\"{manager.IndexToNode(index)} -> \"\n        previous_index = index\n        index = assignment.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += f\"{manager.IndexToNode(index)}\\n\"\n    plan_output += f\"Distance of the route: {route_distance}m\\n\"\n    print(plan_output)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Production Planning Optimization Implementation\nDESCRIPTION: Main implementation of the production planning optimization model using OR-Tools linear solver. The model optimizes production quantities for three pasta products considering resource constraints and costs for both internal and external production. It uses the GLOP solver to minimize total production costs while meeting demand requirements.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/production.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywraplp.Solver.CreateSolver('glop')\n  if not solver:\n    return\n\n  #\n  # data\n  #\n  kluski = 0\n  capellini = 1\n  fettucine = 2\n  products = ['kluski', 'capellini', 'fettucine']\n  num_products = len(products)\n\n  flour = 0\n  eggs = 1\n  resources = ['flour', 'eggs']\n  num_resources = len(resources)\n\n  consumption = [[0.5, 0.2], [0.4, 0.4], [0.3, 0.6]]\n  capacity = [20, 40]\n  demand = [100, 200, 300]\n  inside_cost = [0.6, 0.8, 0.3]\n  outside_cost = [0.8, 0.9, 0.4]\n\n  #\n  # declare variables\n  #\n  inside = [\n      solver.NumVar(0, 10000, 'inside[%i]' % p) for p in range(num_products)\n  ]\n  outside = [\n      solver.NumVar(0, 10000, 'outside[%i]' % p) for p in range(num_products)\n  ]\n\n  # to minimize\n  z = solver.Sum([\n      inside_cost[p] * inside[p] + outside_cost[p] * outside[p]\n      for p in range(num_products)\n  ])\n\n  #\n  # constraints\n  #\n  for r in range(num_resources):\n    solver.Add(\n        solver.Sum([consumption[p][r] * inside[p]\n                    for p in range(num_products)]) <= capacity[r])\n\n  for p in range(num_products):\n    solver.Add(inside[p] + outside[p] >= demand[p])\n\n  objective = solver.Minimize(z)\n\n  solver.Solve()\n\n  print()\n  print('z = ', solver.Objective().Value())\n\n  for p in range(num_products):\n    print(\n        products[p],\n        ': inside:',\n        inside[p].SolutionValue(),\n        '(ReducedCost:',\n        inside[p].ReducedCost(),\n        ')',\n        end=' ')\n    print('outside:', outside[p].SolutionValue(), ' (ReducedCost:',\n          outside[p].ReducedCost(), ')')\n  print()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with OR-Tools SAT in Python\nDESCRIPTION: This Python code defines and solves an assignment problem using the OR-Tools CP-SAT solver. It defines the problem's data, creates a CP-SAT model, defines boolean variables for worker-task assignments, adds constraints for worker and task assignments and team task limits, sets an objective function to minimize assignment costs, solves the model, and prints the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_teams_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.sat.python import cp_model\n\n\ndef main() -> None:\n    # Data\n    costs = [\n        [90, 76, 75, 70],\n        [35, 85, 55, 65],\n        [125, 95, 90, 105],\n        [45, 110, 95, 115],\n        [60, 105, 80, 75],\n        [45, 65, 110, 95],\n    ]\n    num_workers = len(costs)\n    num_tasks = len(costs[0])\n\n    team1 = [0, 2, 4]\n    team2 = [1, 3, 5]\n    # Maximum total of tasks for any team\n    team_max = 2\n\n    # Model\n    model = cp_model.CpModel()\n\n    # Variables\n    x = {}\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            x[worker, task] = model.new_bool_var(f\\\"x[{worker},{task}]\\\")\n\n    # Constraints\n    # Each worker is assigned to at most one task.\n    for worker in range(num_workers):\n        model.add_at_most_one(x[worker, task] for task in range(num_tasks))\n\n    # Each task is assigned to exactly one worker.\n    for task in range(num_tasks):\n        model.add_exactly_one(x[worker, task] for worker in range(num_workers))\n\n    # Each team takes at most two tasks.\n    team1_tasks = []\n    for worker in team1:\n        for task in range(num_tasks):\n            team1_tasks.append(x[worker, task])\n    model.add(sum(team1_tasks) <= team_max)\n\n    team2_tasks = []\n    for worker in team2:\n        for task in range(num_tasks):\n            team2_tasks.append(x[worker, task])\n    model.add(sum(team2_tasks) <= team_max)\n\n    # Objective\n    objective_terms = []\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            objective_terms.append(costs[worker][task] * x[worker, task])\n    model.minimize(sum(objective_terms))\n\n    # Solve\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Print solution.\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\\\"Total cost = {solver.objective_value}\\n\\\")\n        for worker in range(num_workers):\n            for task in range(num_tasks):\n                if solver.boolean_value(x[worker, task]):\n                    print(\n                        f\\\"Worker {worker} assigned to task {task}.\\\"\\\n                        + f\\\" Cost = {costs[worker][task]}\\\"\n                    )\n    else:\n        print(\\\"No solution found.\\\")\n\n\nmain()\n\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Reified Constraints in Go with OR-Tools\nDESCRIPTION: This Go code snippet demonstrates the implementation of reified constraints using Google's OR-Tools library. It shows three different approaches to logical constraints: using a half-reified bool and, using implications, and using bool or.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\n// The reified_sample_sat command is a simple example of implication constraints.\npackage main\n\nimport (\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n)\n\nfunc reifiedSampleSat() {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tx := model.NewBoolVar()\n\ty := model.NewBoolVar()\n\tb := model.NewBoolVar()\n\n\t// First version using a half-reified bool and.\n\tmodel.AddBoolAnd(x, y.Not()).OnlyEnforceIf(b)\n\n\t// Second version using implications.\n\tmodel.AddImplication(b, x)\n\tmodel.AddImplication(b, y.Not())\n\n\t// Third version using bool or.\n\tmodel.AddBoolOr(b.Not(), x)\n\tmodel.AddBoolOr(b.Not(), y.Not())\n}\n\nfunc main() {\n\treifiedSampleSat()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TSP Solution with OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This code implements a solution to the Traveling Salesman Problem using CP-SAT solver from Google OR-Tools. It creates a circuit constraint model, defines boolean variables for each possible arc between nodes, adds constraints to form a valid circuit, and minimizes the total distance traveled. The solver outputs the optimal route and total distance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/tsp_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    num_nodes = len(DISTANCE_MATRIX)\n    all_nodes = range(num_nodes)\n    print(\"Num nodes =\", num_nodes)\n\n    # Model.\n    model = cp_model.CpModel()\n\n    obj_vars = []\n    obj_coeffs = []\n\n    # Create the circuit constraint.\n    arcs = []\n    arc_literals = {}\n    for i in all_nodes:\n        for j in all_nodes:\n            if i == j:\n                continue\n\n            lit = model.new_bool_var(\"%i follows %i\" % (j, i))\n            arcs.append((i, j, lit))\n            arc_literals[i, j] = lit\n\n            obj_vars.append(lit)\n            obj_coeffs.append(DISTANCE_MATRIX[i][j])\n\n    model.add_circuit(arcs)\n\n    # Minimize weighted sum of arcs. Because this s\n    model.minimize(sum(obj_vars[i] * obj_coeffs[i] for i in range(len(obj_vars))))\n\n    # Solve and print out the solution.\n    solver = cp_model.CpSolver()\n    solver.parameters.log_search_progress = True\n    # To benefit from the linearization of the circuit constraint.\n    solver.parameters.linearization_level = 2\n\n    solver.solve(model)\n    print(solver.response_stats())\n\n    current_node = 0\n    str_route = \"%i\" % current_node\n    route_is_finished = False\n    route_distance = 0\n    while not route_is_finished:\n        for i in all_nodes:\n            if i == current_node:\n                continue\n            if solver.boolean_value(arc_literals[current_node, i]):\n                str_route += \" -> %i\" % i\n                route_distance += DISTANCE_MATRIX[current_node][i]\n                current_node = i\n                if current_node == 0:\n                    route_is_finished = True\n                break\n\n    print(\"Route:\", str_route)\n    print(\"Travelled distance:\", route_distance)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Creating and Solving a Linear Program with GLOP in Python\nDESCRIPTION: This Python script demonstrates the creation of a linear program using OR-Tools' model_builder. It defines variables, constraints, and an objective function to maximize. It requires the ortools package and uses GLOP as the backend solver. Key parameters include variables x and y, constraints, and the maximization objective function. The script outputs the optimal solution if available.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_lp_program_mb.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\nfrom ortools.linear_solver.python import model_builder\n\ndef main():\n    # Create the model.\n    model = model_builder.Model()\n\n    # Create the variables x and y.\n    x = model.new_num_var(0.0, math.inf, \"x\")\n    y = model.new_num_var(0.0, math.inf, \"y\")\n\n    print(\"Number of variables =\", model.num_variables)\n\n    # x + 7 * y <= 17.5.\n    ct = model.add(x + 7 * y <= 17.5)\n\n    # x <= 3.5.\n    model.add(x <= 3.5)\n\n    print(\"Number of constraints =\", model.num_constraints)\n\n    # Maximize x + 10 * y.\n    model.maximize(x + 10 * y)\n\n    # Create the solver with the GLOP backend, and solve the model.\n    solver = model_builder.Solver(\"glop\")\n    if not solver.solver_is_supported():\n        return\n    status = solver.solve(model)\n\n    if status == model_builder.SolveStatus.OPTIMAL:\n        print(\"Solution:\")\n        print(\"Objective value =\", solver.objective_value)\n        print(\"x =\", solver.value(x))\n        print(\"y =\", solver.value(y))\n\n        print(\"dual_value(ct) =\", solver.dual_value(ct))\n        print(\"reduced_cost(x) =\", solver.reduced_cost(x))\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n    print(\"\\nAdvanced usage:\")\n    print(\"Problem solved in %f seconds\" % solver.wall_time)\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Solving 4x4 Linear Assignment Problem\nDESCRIPTION: Implementation of a linear sum assignment solver for a 4x4 cost matrix. The code creates an assignment problem, adds arcs with costs, solves the problem, and outputs the optimal assignment and total cost. The example is based on a reference problem with a unique optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_assignment_api.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.graph.python import linear_sum_assignment\n\ndef run_assignment_on_4x4_matrix():\n    \"\"\"Test linear sum assignment on a 4x4 matrix.\"\"\"\n    num_sources = 4\n    num_targets = 4\n    cost = [[90, 76, 75, 80], [35, 85, 55, 65], [125, 95, 90, 105], [45, 110, 95, 115]]\n    expected_cost = cost[0][3] + cost[1][2] + cost[2][1] + cost[3][0]\n\n    assignment = linear_sum_assignment.SimpleLinearSumAssignment()\n    for source in range(0, num_sources):\n        for target in range(0, num_targets):\n            assignment.add_arc_with_cost(source, target, cost[source][target])\n\n    solve_status = assignment.solve()\n    if solve_status == assignment.OPTIMAL:\n        print(\"Successful solve.\")\n        print(\"Total cost\", assignment.optimal_cost(), \"/\", expected_cost)\n        for i in range(0, assignment.num_nodes()):\n            print(\n                \"Left node %d assigned to right node %d with cost %d.\"\n                % (i, assignment.right_mate(i), assignment.assignment_cost(i))\n            )\n    elif solve_status == assignment.INFEASIBLE:\n        print(\"No perfect matching exists.\")\n    elif solve_status == assignment.POSSIBLE_OVERFLOW:\n        print(\"Some input costs are too large and may cause an integer overflow.\")\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    run_assignment_on_4x4_matrix()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Two Machine Job Scheduling with OR-Tools in Python\nDESCRIPTION: Solves a scheduling optimization problem using CP-SAT solver where jobs with duration and width constraints need to be scheduled on two parallel machines. The code creates interval variables, enforces cumulative constraints for width limits, handles machine assignments, and visualizes the solution. The objective is to minimize the maximum completion time (makespan) while ensuring the sum of concurrent job widths doesn't exceed the maximum width.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/cp_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef TwoMachineScheduling():\n  model = cp_model.CpModel()\n\n  jobs = [[3, 3],  # (duration, width)\n          [2, 5],\n          [1, 3],\n          [3, 7],\n          [7, 3],\n          [2, 2],\n          [2, 2],\n          [5, 5],\n          [10, 2],\n          [4, 3],\n          [2, 6],\n          [1, 2],\n          [6, 8],\n          [4, 5],\n          [3, 7]]\n\n  max_width = 10\n\n  horizon = sum(t[0] for t in jobs)\n  num_jobs = len(jobs)\n  all_jobs = range(num_jobs)\n\n  intervals = []\n  intervals0 = []\n  intervals1 = []\n  performed = []\n  starts = []\n  ends = []\n  demands = []\n\n  for i in all_jobs:\n    # Create main interval (to be used in the cumulative constraint).\n    start = model.NewIntVar(0, horizon, 'start_%i' % i)\n    duration = jobs[i][0]\n    end = model.NewIntVar(0, horizon, 'end_%i' % i)\n    interval = model.NewIntervalVar(start, duration, end, 'interval_%i' % i)\n    starts.append(start)\n    intervals.append(interval)\n    ends.append(end)\n    demands.append(jobs[i][1])\n\n    performed_on_m0 = model.NewBoolVar('perform_%i_on_m0' % i)\n    performed.append(performed_on_m0)\n\n    # Create an optional copy of interval to be executed on machine 0.\n    start0 = model.NewIntVar(\n        0, horizon, 'start_%i_on_m0' % i)\n    end0 = model.NewIntVar(\n        0, horizon, 'end_%i_on_m0' % i)\n    interval0 = model.NewOptionalIntervalVar(\n        start0, duration, end0, performed_on_m0, 'interval_%i_on_m0' % i)\n    intervals0.append(interval0)\n\n    # Create an optional copy of interval to be executed on machine 1.\n    start1 = model.NewIntVar(\n        0, horizon, 'start_%i_on_m1' % i)\n    end1 = model.NewIntVar(\n        0, horizon, 'end_%i_on_m1' % i)\n    interval1 = model.NewOptionalIntervalVar(\n        start1, duration, end1, performed_on_m0.Not(), 'interval_%i_on_m1' % i)\n    intervals1.append(interval1)\n\n    # We only propagate the constraint if the task is performed on the machine.\n    model.Add(start0 == start).OnlyEnforceIf(performed_on_m0)\n    model.Add(start1 == start).OnlyEnforceIf(performed_on_m0.Not())\n\n  # Max width constraint (modeled as a cumulative).\n  model.AddCumulative(intervals, demands, max_width)\n\n  # Choose which machine to perform the jobs on.\n  model.AddNoOverlap(intervals0)\n  model.AddNoOverlap(intervals1)\n\n  # Objective variable.\n  makespan = model.NewIntVar(0, horizon, 'makespan')\n  model.AddMaxEquality(makespan, ends)\n  model.Minimize(makespan)\n\n  # Symmetry breaking.\n  model.Add(performed[0] == 0)\n\n  # Solve model.\n  solver = cp_model.CpSolver()\n  solver.parameters.log_search_progress = True\n  solver.Solve(model)\n\n  # Output solution.\n  output = visualization.SvgWrapper(solver.ObjectiveValue(), max_width, 40.0)\n  output.AddTitle('Makespan = %i' % solver.ObjectiveValue())\n  color_manager = visualization.ColorManager()\n  color_manager.SeedRandomColor(0)\n  for i in all_jobs:\n    performed_machine = 1 - solver.Value(performed[i])\n    start = solver.Value(starts[i])\n    dx = jobs[i][0]\n    dy = jobs[i][1]\n    sy = performed_machine * (max_width - dy)\n    output.AddRectangle(start, sy, dx, dy, color_manager.RandomColor(), 'black',\n                        'j%i' % i)\n\n  output.AddXScale()\n  output.AddYScale()\n  output.Display()\n\n\nTwoMachineScheduling()\n```\n\n----------------------------------------\n\nTITLE: TSP Solution Implementation with OR-Tools\nDESCRIPTION: Complete implementation of a Traveling Salesman Problem solver using OR-Tools, including data model creation, routing manager setup, distance callback implementation, and solution visualization. The code handles a 17-node problem with predefined distances.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp_distance_matrix.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 1\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    index = routing.Start(0)\n    plan_output = \"Route for vehicle 0:\\n\"\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += f\" {manager.IndexToNode(index)} ->\"\n        previous_index = index\n        index = solution.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += f\" {manager.IndexToNode(index)}\\n\"\n    plan_output += f\"Distance of the route: {route_distance}m\\n\"\n    print(plan_output)\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Einav Puzzle Main Implementation\nDESCRIPTION: Complete implementation of the Einav puzzle solver using OR-Tools constraint solver. The code creates variables for row and column signs, calculates sums, and finds the optimal solution that minimizes the total sum while maintaining positive row and column sums.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Einav puzzle')\n\n  # Full problem\n  rows = 27\n  cols = 9\n  data = [[33, 30, 10, -6, 18, -7, -11, 23, -6],\n          [16, -19, 9, -26, -8, -19, -8, -21, -14],\n          # ... [data array truncated for brevity]\n          [-25, 4, -16, 30, 33, 23, -4, -4, 23]]\n\n  x = {}\n  for i in range(rows):\n    for j in range(cols):\n      x[i, j] = solver.IntVar(-100, 100, 'x[%i,%i]' % (i, j))\n\n  x_flat = [x[i, j] for i in range(rows) for j in range(cols)]\n\n  row_sums = [solver.IntVar(0, 300, 'row_sums(%i)' % i) for i in range(rows)]\n  col_sums = [solver.IntVar(0, 300, 'col_sums(%i)' % j) for j in range(cols)]\n\n  row_signs = [solver.IntVar([-1, 1], 'row_signs(%i)' % i) for i in range(rows)]\n  col_signs = [solver.IntVar([-1, 1], 'col_signs(%i)' % j) for j in range(cols)]\n\n  total_sum = solver.IntVar(0, 1000, 'total_sum')\n\n  # Add constraints and objective\n  for i in range(rows):\n    for j in range(cols):\n      solver.Add(x[i, j] == data[i][j] * row_signs[i] * col_signs[j])\n\n  total_sum_a = [\n      data[i][j] * row_signs[i] * col_signs[j]\n      for i in range(rows)\n      for j in range(cols)\n  ]\n  solver.Add(total_sum == solver.Sum(total_sum_a))\n\n  # Calculate row and column sums\n  for i in range(rows):\n    s = [row_signs[i] * col_signs[j] * data[i][j] for j in range(cols)]\n    solver.Add(row_sums[i] == solver.Sum(s))\n\n  for j in range(cols):\n    s = [row_signs[i] * col_signs[j] * data[i][j] for i in range(rows)]\n    solver.Add(col_sums[j] == solver.Sum(s))\n\n  objective = solver.Minimize(total_sum, 1)\n\n  db = solver.Phase(col_signs + row_signs, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_MAX_VALUE)\n\n  solver.NewSearch(db, [objective])\n\n  # Print solutions\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('total_sum:', total_sum.Value())\n    print('row_sums:', [row_sums[i].Value() for i in range(rows)])\n    print('col_sums:', [col_sums[j].Value() for j in range(cols)])\n    print('row_signs:', [row_signs[i].Value() for i in range(rows)])\n    print('col_signs:', [col_signs[j].Value() for j in range(cols)])\n    print('x:')\n    for i in range(rows):\n      for j in range(cols):\n        print('%3i' % x[i, j].Value(), end=' ')\n      print()\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with Constraints using OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This function solves an assignment problem with worker constraints. It sets up the cost matrix, group constraints, and task sizes, then uses the CP-SAT solver to find the optimal assignment that minimizes total cost while respecting all constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/assignment_with_constraints_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\ndef solve_assignment():\n    \"\"\"solve the assignment problem.\"\"\"\n    # Data.\n    cost = [\n        [90, 76, 75, 70, 50, 74],\n        [35, 85, 55, 65, 48, 101],\n        [125, 95, 90, 105, 59, 120],\n        [45, 110, 95, 115, 104, 83],\n        [60, 105, 80, 75, 59, 62],\n        [45, 65, 110, 95, 47, 31],\n        [38, 51, 107, 41, 69, 99],\n        [47, 85, 57, 71, 92, 77],\n        [39, 63, 97, 49, 118, 56],\n        [47, 101, 71, 60, 88, 109],\n        [17, 39, 103, 64, 61, 92],\n        [101, 45, 83, 59, 92, 27],\n    ]\n\n    group1 = [\n        [0, 0, 1, 1],  # Workers 2, 3\n        [0, 1, 0, 1],  # Workers 1, 3\n        [0, 1, 1, 0],  # Workers 1, 2\n        [1, 1, 0, 0],  # Workers 0, 1\n        [1, 0, 1, 0],  # Workers 0, 2\n    ]\n\n    group2 = [\n        [0, 0, 1, 1],  # Workers 6, 7\n        [0, 1, 0, 1],  # Workers 5, 7\n        [0, 1, 1, 0],  # Workers 5, 6\n        [1, 1, 0, 0],  # Workers 4, 5\n        [1, 0, 0, 1],  # Workers 4, 7\n    ]\n\n    group3 = [\n        [0, 0, 1, 1],  # Workers 10, 11\n        [0, 1, 0, 1],  # Workers 9, 11\n        [0, 1, 1, 0],  # Workers 9, 10\n        [1, 0, 1, 0],  # Workers 8, 10\n        [1, 0, 0, 1],  # Workers 8, 11\n    ]\n\n    sizes = [10, 7, 3, 12, 15, 4, 11, 5]\n    total_size_max = 15\n    num_workers = len(cost)\n    num_tasks = len(cost[1])\n    all_workers = range(num_workers)\n    all_tasks = range(num_tasks)\n\n    # Model.\n\n    model = cp_model.CpModel()\n    # Variables\n    selected = [\n        [model.new_bool_var(f\"x[{i},{j}]\") for j in all_tasks] for i in all_workers\n    ]\n    works = [model.new_bool_var(f\"works[{i}]\") for i in all_workers]\n\n    # Constraints\n\n    # Link selected and workers.\n    for i in range(num_workers):\n        model.add_max_equality(works[i], selected[i])\n\n    # Each task is assigned to at least one worker.\n    for j in all_tasks:\n        model.add(sum(selected[i][j] for i in all_workers) >= 1)\n\n    # Total task size for each worker is at most total_size_max\n    for i in all_workers:\n        model.add(sum(sizes[j] * selected[i][j] for j in all_tasks) <= total_size_max)\n\n    # Group constraints.\n    model.add_allowed_assignments([works[0], works[1], works[2], works[3]], group1)\n    model.add_allowed_assignments([works[4], works[5], works[6], works[7]], group2)\n    model.add_allowed_assignments([works[8], works[9], works[10], works[11]], group3)\n\n    # Objective\n    model.minimize(\n        sum(selected[i][j] * cost[i][j] for j in all_tasks for i in all_workers)\n    )\n\n    # Solve and output solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"Total cost = {solver.objective_value}\")\n        print()\n        for i in all_workers:\n            for j in all_tasks:\n                if solver.boolean_value(selected[i][j]):\n                    print(f\"Worker {i} assigned to task {j} with Cost = {cost[i][j]}\")\n\n        print()\n\n    print(solver.response_stats())\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    solve_assignment()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Map Coloring Implementation using OR-Tools\nDESCRIPTION: Complete implementation of a map coloring problem solver using OR-Tools constraint programming. The code creates a solver instance, defines variables for each country's color, sets constraints for adjacent countries to have different colors, and finds all possible solutions using a maximum of 4 colors.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/map.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Map coloring\")\n\n  #\n  # data\n  #\n  Belgium = 0\n  Denmark = 1\n  France = 2\n  Germany = 3\n  Netherlands = 4\n  Luxembourg = 5\n\n  n = 6\n  max_num_colors = 4\n\n  # declare variables\n  color = [solver.IntVar(1, max_num_colors, \"x%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(color[Belgium] == 1)  # Symmetry breaking\n  solver.Add(color[France] != color[Belgium])\n  solver.Add(color[France] != color[Luxembourg])\n  solver.Add(color[France] != color[Germany])\n  solver.Add(color[Luxembourg] != color[Germany])\n  solver.Add(color[Luxembourg] != color[Belgium])\n  solver.Add(color[Belgium] != color[Netherlands])\n  solver.Add(color[Belgium] != color[Germany])\n  solver.Add(color[Germany] != color[Netherlands])\n  solver.Add(color[Germany] != color[Denmark])\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([color[i] for i in range(n)])\n\n  collector = solver.AllSolutionCollector(solution)\n  # collector = solver.FirstSolutionCollector(solution)\n  # search_log = solver.SearchLog(100, x[0])\n  solver.Solve(\n      solver.Phase([color[i] for i in range(n)], solver.INT_VAR_SIMPLE,\n                   solver.ASSIGN_MIN_VALUE), [collector])\n\n  num_solutions = collector.SolutionCount()\n  print(\"num_solutions: \", num_solutions)\n  if num_solutions > 0:\n    for s in range(num_solutions):\n      colorval = [collector.Value(s, color[i]) for i in range(n)]\n      print(\"color:\", colorval)\n\n    print()\n    print(\"num_solutions:\", num_solutions)\n    print(\"failures:\", solver.Failures())\n    print(\"branches:\", solver.Branches())\n    print(\"WallTime:\", solver.WallTime())\n\n  else:\n    print(\"No solutions found\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Defining Shift Scheduling Constraints and Demands in Python\nDESCRIPTION: This snippet defines the constraints and demands for the shift scheduling problem. It includes penalized transitions between shifts, weekly cover demands for different shifts, and penalties for exceeding cover constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/shift_scheduling_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# Penalized transitions:\n#     (previous_shift, next_shift, penalty (0 means forbidden))\npenalized_transitions = [\n    # Afternoon to night has a penalty of 4.\n    (2, 3, 4),\n    # Night to morning is forbidden.\n    (3, 1, 0),\n]\n\n# daily demands for work shifts (morning, afternon, night) for each day\n# of the week starting on Monday.\nweekly_cover_demands = [\n    (2, 3, 1),  # Monday\n    (2, 3, 1),  # Tuesday\n    (2, 2, 2),  # Wednesday\n    (2, 3, 1),  # Thursday\n    (2, 2, 2),  # Friday\n    (1, 2, 3),  # Saturday\n    (1, 3, 1),  # Sunday\n]\n\n# Penalty for exceeding the cover constraint per shift type.\nexcess_cover_penalties = (2, 2, 5)\n```\n\n----------------------------------------\n\nTITLE: Implementing VRP with Time Windows per Vehicle using OR-Tools\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem with time windows specific to each vehicle. The solution handles 4 vehicles serving 16 locations with different time windows for each vehicle, representing different shifts throughout the day.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_time_windows_per_vehicles.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"time_matrix\"] = [\n        [0, 6, 9, 8, 7, 3, 6, 2, 3, 2, 6, 6, 4, 4, 5, 9, 7],\n        [6, 0, 8, 3, 2, 6, 8, 4, 8, 8, 13, 7, 5, 8, 12, 10, 14],\n        [9, 8, 0, 11, 10, 6, 3, 9, 5, 8, 4, 15, 14, 13, 9, 18, 9],\n        [8, 3, 11, 0, 1, 7, 10, 6, 10, 10, 14, 6, 7, 9, 14, 6, 16],\n        [7, 2, 10, 1, 0, 6, 9, 4, 8, 9, 13, 4, 6, 8, 12, 8, 14],\n        [3, 6, 6, 7, 6, 0, 2, 3, 2, 2, 7, 9, 7, 7, 6, 12, 8],\n        [6, 8, 3, 10, 9, 2, 0, 6, 2, 5, 4, 12, 10, 10, 6, 15, 5],\n        [2, 4, 9, 6, 4, 3, 6, 0, 4, 4, 8, 5, 4, 3, 7, 8, 10],\n        [3, 8, 5, 10, 8, 2, 2, 4, 0, 3, 4, 9, 8, 7, 3, 13, 6],\n        [2, 8, 8, 10, 9, 2, 5, 4, 3, 0, 4, 6, 5, 4, 3, 9, 5],\n        [6, 13, 4, 14, 13, 7, 4, 8, 4, 4, 0, 10, 9, 8, 4, 13, 4],\n        [6, 7, 15, 6, 4, 9, 12, 5, 9, 6, 10, 0, 1, 3, 7, 3, 10],\n        [4, 5, 14, 7, 6, 7, 10, 4, 8, 5, 9, 1, 0, 2, 6, 4, 8],\n        [4, 8, 13, 9, 8, 7, 10, 3, 7, 4, 8, 3, 2, 0, 4, 5, 6],\n        [5, 12, 9, 14, 12, 6, 6, 7, 3, 3, 4, 7, 6, 4, 0, 9, 2],\n        [9, 10, 18, 6, 8, 12, 15, 8, 13, 9, 13, 3, 4, 5, 9, 0, 9],\n        [7, 14, 9, 16, 14, 8, 5, 10, 6, 5, 4, 10, 8, 6, 2, 9, 0],\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(manager, routing, assignment):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    # Display dropped nodes.\n    dropped_nodes = \"Dropped nodes:\"\n    for index in range(routing.Size()):\n        if routing.IsStart(index) or routing.IsEnd(index):\n            continue\n        if assignment.Value(routing.NextVar(index)) == index:\n            node = manager.IndexToNode(index)\n            if node > 16:\n                original = node\n                while original > 16:\n                    original = original - 16\n                dropped_nodes += f\" {node}({original})\"\n            else:\n                dropped_nodes += f\" {node}\"\n    print(dropped_nodes)\n    # Display routes\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    total_time = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        index = routing.Start(vehicle_id)\n        start_time = 0\n        while not routing.IsEnd(index):\n            time_var = time_dimension.CumulVar(index)\n            node = manager.IndexToNode(index)\n            if node > 16:\n                original = node\n                while original > 16:\n                    original = original - 16\n                plan_output += f\"{node}({original})\"\n            else:\n                plan_output += f\"{node}\"\n            plan_output += f\" Time:{assignment.Value(time_var)} -> \"\n            if start_time == 0:\n                start_time = assignment.Value(time_var)\n            index = assignment.Value(routing.NextVar(index))\n        time_var = time_dimension.CumulVar(index)\n        node = manager.IndexToNode(index)\n        plan_output += f\"{node} Time:{assignment.Value(time_var)}\\n\"\n        end_time = assignment.Value(time_var)\n        duration = end_time - start_time\n        plan_output += f\"Duration of the route:{duration}min\\n\"\n        print(plan_output)\n        total_time += duration\n    print(f\"Total duration of all routes: {total_time}min\")\n\n\ndef main():\n    \"\"\"Solve the VRP with time windows.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        1 + 16 * 4, data[\"num_vehicles\"], data[\"depot\"]  # number of locations\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Create and register a transit callback.\n    def time_callback(from_index, to_index):\n        \"\"\"Returns the travel time between the two nodes.\"\"\"\n        # Convert from routing variable Index to time matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        # since our matrix is 17x17 map duplicated node to original one to\n        # retrieve the travel time\n        while from_node > 16:\n            from_node = from_node - 16\n        while to_node > 16:\n            to_node = to_node - 16\n        # add service of 25min for each location (except depot)\n        service_time = 0\n        if from_node != data[\"depot\"]:\n            service_time = 25\n        return data[\"time_matrix\"][from_node][to_node] + service_time\n\n    transit_callback_index = routing.RegisterTransitCallback(time_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Time Windows constraint.\n    time = \"Time\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # allow waiting time (0 min)\n        1020,  # maximum time per vehicle (9 hours)\n        False,  # Don't force start cumul to zero.\n        time,\n    )\n    time_dimension = routing.GetDimensionOrDie(time)\n    # Add time window constraints for each location except depot.\n    for location_idx in range(17):\n        if location_idx == data[\"depot\"]:\n            continue\n        # Vehicle 0 location TW: [9am, 11am]\n        index_0 = manager.NodeToIndex(location_idx)\n        time_dimension.CumulVar(index_0).SetRange(540, 660)\n        routing.VehicleVar(index_0).SetValues([-1, 0])\n\n        # Vehicle 1 location TW: [11am, 1pm]\n        index_1 = manager.NodeToIndex(location_idx + 16 * 1)\n        time_dimension.CumulVar(index_1).SetRange(660, 780)\n        routing.VehicleVar(index_1).SetValues([-1, 1])\n\n        # Vehicle 2 location TW: [1pm, 3pm]\n        index_2 = manager.NodeToIndex(location_idx + 16 * 2)\n        time_dimension.CumulVar(index_2).SetRange(780, 900)\n        routing.VehicleVar(index_2).SetValues([-1, 2])\n\n        # Vehicle 3 location TW: [3pm, 5pm]\n        index_3 = manager.NodeToIndex(location_idx + 16 * 3)\n        time_dimension.CumulVar(index_3).SetRange(900, 1020)\n        routing.VehicleVar(index_3).SetValues([-1, 3])\n\n        # Add Disjunction so only one node among duplicate is visited\n        penalty = 100_000  # Give solver strong incentive to visit one node\n        routing.AddDisjunction([index_0, index_1, index_2, index_3], penalty, 1)\n\n    # Add time window constraints for each vehicle start node.\n    depot_idx = data[\"depot\"]\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        time_dimension.CumulVar(index).SetRange(480, 1020)  # (8am, 5pm)\n\n    # Add time window constraints for each vehicle end node.\n    depot_idx = data[\"depot\"]\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.End(vehicle_id)\n        time_dimension.CumulVar(index).SetRange(480, 1020)  # (8am, 5pm)\n\n    # Instantiate route start and end times to produce feasible times.\n    for i in range(data[\"num_vehicles\"]):\n        routing.AddVariableMinimizedByFinalizer(\n            time_dimension.CumulVar(routing.Start(i))\n        )\n        routing.AddVariableMinimizedByFinalizer(time_dimension.CumulVar(routing.End(i)))\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(1)\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(manager, routing, assignment)\n    else:\n        print(\"no solution found !\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Secret Santa Problem Solver Implementation\nDESCRIPTION: Main implementation of the Secret Santa problem solver using OR-Tools. The code creates constraints to ensure no one is their own Secret Santa and people from the same family can't be matched. It uses a constraint solver to find all valid solutions while handling family restrictions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/secret_santa.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Secret Santa problem')\n\n  #\n  # data\n  #\n  family = [1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 4, 4]\n  num_families = max(family)\n  n = len(family)\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, n - 1, 'x[%i]' % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n\n  # Can't be one own's Secret Santa\n  # Ensure that there are no fix-point in the array\n  for i in range(n):\n    solver.Add(x[i] != i)\n\n  # No Secret Santa to a person in the same family\n  for i in range(n):\n    solver.Add(family[i] != solver.Element(family, x[i]))\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(x, solver.INT_VAR_SIMPLE, solver.INT_VALUE_SIMPLE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('x:', [x[i].Value() for i in range(n)])\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing Problem with Resource Constraints\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem (VRP) with time windows and depot capacity constraints. The code creates a data model with time matrices and constraints, sets up a routing model, adds time window and resource constraints, and solves the problem using OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_resources.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"time_matrix\"] = [\n        [0, 6, 9, 8, 7, 3, 6, 2, 3, 2, 6, 6, 4, 4, 5, 9, 7],\n        [6, 0, 8, 3, 2, 6, 8, 4, 8, 8, 13, 7, 5, 8, 12, 10, 14],\n        [9, 8, 0, 11, 10, 6, 3, 9, 5, 8, 4, 15, 14, 13, 9, 18, 9],\n        [8, 3, 11, 0, 1, 7, 10, 6, 10, 10, 14, 6, 7, 9, 14, 6, 16],\n        [7, 2, 10, 1, 0, 6, 9, 4, 8, 9, 13, 4, 6, 8, 12, 8, 14],\n        [3, 6, 6, 7, 6, 0, 2, 3, 2, 2, 7, 9, 7, 7, 6, 12, 8],\n        [6, 8, 3, 10, 9, 2, 0, 6, 2, 5, 4, 12, 10, 10, 6, 15, 5],\n        [2, 4, 9, 6, 4, 3, 6, 0, 4, 4, 8, 5, 4, 3, 7, 8, 10],\n        [3, 8, 5, 10, 8, 2, 2, 4, 0, 3, 4, 9, 8, 7, 3, 13, 6],\n        [2, 8, 8, 10, 9, 2, 5, 4, 3, 0, 4, 6, 5, 4, 3, 9, 5],\n        [6, 13, 4, 14, 13, 7, 4, 8, 4, 4, 0, 10, 9, 8, 4, 13, 4],\n        [6, 7, 15, 6, 4, 9, 12, 5, 9, 6, 10, 0, 1, 3, 7, 3, 10],\n        [4, 5, 14, 7, 6, 7, 10, 4, 8, 5, 9, 1, 0, 2, 6, 4, 8],\n        [4, 8, 13, 9, 8, 7, 10, 3, 7, 4, 8, 3, 2, 0, 4, 5, 6],\n        [5, 12, 9, 14, 12, 6, 6, 7, 3, 3, 4, 7, 6, 4, 0, 9, 2],\n        [9, 10, 18, 6, 8, 12, 15, 8, 13, 9, 13, 3, 4, 5, 9, 0, 9],\n        [7, 14, 9, 16, 14, 8, 5, 10, 6, 5, 4, 10, 8, 6, 2, 9, 0],\n    ]\n    data[\"time_windows\"] = [\n        (0, 5),  # depot\n        (7, 12),  # 1\n        (10, 15),  # 2\n        (5, 14),  # 3\n        (5, 13),  # 4\n        (0, 5),  # 5\n        (5, 10),  # 6\n        (0, 10),  # 7\n        (5, 10),  # 8\n        (0, 5),  # 9\n        (10, 16),  # 10\n        (10, 15),  # 11\n        (0, 5),  # 12\n        (5, 10),  # 13\n        (7, 12),  # 14\n        (10, 15),  # 15\n        (5, 15),  # 16\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"vehicle_load_time\"] = 5\n    data[\"vehicle_unload_time\"] = 5\n    data[\"depot_capacity\"] = 2\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    total_time = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        while not routing.IsEnd(index):\n            time_var = time_dimension.CumulVar(index)\n            plan_output += (\n                f\"{manager.IndexToNode(index)}\"\n                f\" Time({solution.Min(time_var)}, {solution.Max(time_var)})\"\n                \" -> \"\n            )\n            index = solution.Value(routing.NextVar(index))\n        time_var = time_dimension.CumulVar(index)\n        plan_output += (\n            f\"{manager.IndexToNode(index)}\"\n            f\" Time({solution.Min(time_var)},{solution.Max(time_var)})\\n\"\n        )\n        plan_output += f\"Time of the route: {solution.Min(time_var)}min\\n\"\n        print(plan_output)\n        total_time += solution.Min(time_var)\n    print(f\"Total time of all routes: {total_time}min\")\n\n\ndef main():\n    \"\"\"Solve the VRP with time windows.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"time_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def time_callback(from_index, to_index):\n        \"\"\"Returns the travel time between the two nodes.\"\"\"\n        # Convert from routing variable Index to time matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"time_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(time_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Time Windows constraint.\n    time = \"Time\"\n    routing.AddDimension(\n        transit_callback_index,\n        60,  # allow waiting time\n        60,  # maximum time per vehicle\n        False,  # Don't force start cumul to zero.\n        time,\n    )\n    time_dimension = routing.GetDimensionOrDie(time)\n    # Add time window constraints for each location except depot.\n    for location_idx, time_window in enumerate(data[\"time_windows\"]):\n        if location_idx == 0:\n            continue\n        index = manager.NodeToIndex(location_idx)\n        time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])\n    # Add time window constraints for each vehicle start node.\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        time_dimension.CumulVar(index).SetRange(\n            data[\"time_windows\"][0][0], data[\"time_windows\"][0][1]\n        )\n\n    # Add resource constraints at the depot.\n    solver = routing.solver()\n    intervals = []\n    for i in range(data[\"num_vehicles\"]):\n        # Add time windows at start of routes\n        intervals.append(\n            solver.FixedDurationIntervalVar(\n                time_dimension.CumulVar(routing.Start(i)),\n                data[\"vehicle_load_time\"],\n                \"depot_interval\",\n            )\n        )\n        # Add time windows at end of routes.\n        intervals.append(\n            solver.FixedDurationIntervalVar(\n                time_dimension.CumulVar(routing.End(i)),\n                data[\"vehicle_unload_time\"],\n                \"depot_interval\",\n            )\n        )\n\n    depot_usage = [1 for _ in range(len(intervals))]\n    solver.Add(\n        solver.Cumulative(intervals, depot_usage, data[\"depot_capacity\"], \"depot\")\n    )\n\n    # Instantiate route start and end times to produce feasible times.\n    for i in range(data[\"num_vehicles\"]):\n        routing.AddVariableMinimizedByFinalizer(\n            time_dimension.CumulVar(routing.Start(i))\n        )\n        routing.AddVariableMinimizedByFinalizer(time_dimension.CumulVar(routing.End(i)))\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Implementing VRP Solver Main Function with OR-Tools in Python\nDESCRIPTION: Main function that sets up and solves a Vehicle Routing Problem using Google OR-Tools. It creates a routing model with multiple constraints including distance minimization, capacity limits, and time windows. The solver uses PATH_CHEAPEST_ARC strategy with Guided Local Search metaheuristic and a 3-second time limit.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrp_reload.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager\n    manager = pywrapcp.RoutingIndexManager(\n        data[\"num_locations\"], data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Define weight of each edge\n    distance_evaluator_index = routing.RegisterTransitCallback(\n        partial(create_distance_evaluator(data), manager)\n    )\n    routing.SetArcCostEvaluatorOfAllVehicles(distance_evaluator_index)\n\n    # Add Distance constraint to minimize the longuest route\n    add_distance_dimension(routing, manager, data, distance_evaluator_index)\n\n    # Add Capacity constraint\n    demand_evaluator_index = routing.RegisterUnaryTransitCallback(\n        partial(create_demand_evaluator(data), manager)\n    )\n    add_capacity_constraints(routing, manager, data, demand_evaluator_index)\n\n    # Add Time Window constraint\n    time_evaluator_index = routing.RegisterTransitCallback(\n        partial(create_time_evaluator(data), manager)\n    )\n    add_time_window_constraints(routing, manager, data, time_evaluator_index)\n\n    # Setting first solution heuristic (cheapest addition).\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )  # pylint: disable=no-member\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(3)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Vehicle Routing Problem with Constraints using Google OR-Tools in Python\nDESCRIPTION: This code snippet defines the main function for solving a Vehicle Routing Problem. It creates a data model, sets up routing index manager and model, defines constraints (distance, capacity, time windows, breaks), and solves the problem using OR-Tools. The solution is printed if found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrptw_break.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager\n    manager = pywrapcp.RoutingIndexManager(\n        data[\"numlocations_\"], data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Define weight of each edge\n    distance_evaluator_index = routing.RegisterTransitCallback(\n        functools.partial(create_distance_evaluator(data), manager)\n    )\n    routing.SetArcCostEvaluatorOfAllVehicles(distance_evaluator_index)\n\n    # Add Capacity constraint\n    demand_evaluator_index = routing.RegisterUnaryTransitCallback(\n        functools.partial(create_demand_evaluator(data), manager)\n    )\n    add_capacity_constraints(routing, data, demand_evaluator_index)\n\n    # Add Time Window constraint\n    time_evaluator_index = routing.RegisterTransitCallback(\n        functools.partial(create_time_evaluator(data), manager)\n    )\n    add_time_window_constraints(routing, manager, data, time_evaluator_index)\n\n    # Add breaks\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    node_visit_transit = {}\n    for index in range(routing.Size()):\n        node = manager.IndexToNode(index)\n        node_visit_transit[index] = int(\n            data[\"demands\"][node] * data[\"time_per_demand_unit\"]\n        )\n\n    break_intervals = {}\n    for v in range(data[\"num_vehicles\"]):\n        vehicle_break = data[\"breaks\"][v]\n        break_intervals[v] = [\n            routing.solver().FixedDurationIntervalVar(\n                15,\n                100,\n                vehicle_break[0],\n                vehicle_break[1],\n                f\"Break for vehicle {v}\",\n            )\n        ]\n        time_dimension.SetBreakIntervalsOfVehicle(\n            break_intervals[v], v, node_visit_transit.values()\n        )\n\n    # Setting first solution heuristic (cheapest addition).\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )  # pylint: disable=no-member\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(data, manager, routing, assignment)\n    else:\n        print(\"No solution found!\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Test Scheduling Constraint Problem\nDESCRIPTION: Main solving function using CP-SAT solver to schedule tests across operators and power supplies while minimizing makespan and respecting power constraints\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/test_scheduling_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef solve(\n    tests_data: pd.DataFrame,\n    operator_data: pd.DataFrame,\n    supplies_data: pd.DataFrame,\n) -> None:\n    \"\"\"Solve the scheduling of tests problem.\"\"\"\n\n    # Parses data.\n    operator_to_supply: Dict[str, str] = {}\n    for _, row in operator_data.iterrows():\n        operator_to_supply[row[\"Operator\"]] = row[\"Supply\"]\n\n    supply_to_max_power: Dict[str, int] = {}\n    for _, row in supplies_data.iterrows():\n        supply_to_max_power[row[\"Supply\"]] = row[\"MaxAllowedPower\"]\n\n    horizon = tests_data[\"TestTime\"].sum()\n\n    # OR-Tools model.\n    model = cp_model.CpModel()\n\n    # Create containers and scheduling logic...\n    # (truncated for brevity)\n\n```\n\n----------------------------------------\n\nTITLE: Ranking Sample SAT Execution in Python\nDESCRIPTION: This function constructs a CP-SAT model to rank tasks based on given constraints including NoOverlap and optimizing makespan. It initializes task parameters, applies constraints, and solves the model while printing the results of the scheduling.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/ranking_circuit_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef ranking_sample_sat() -> None:\n    \"\"\"Ranks tasks in a NoOverlap constraint.\"\"\"\n\n    model = cp_model.CpModel()\n    horizon = 100\n    num_tasks = 4\n    all_tasks = range(num_tasks)\n\n    starts = []\n    durations = []\n    intervals = []\n    presences = []\n    ranks = []\n\n    # Creates intervals, half of them are optional.\n    for t in all_tasks:\n        start = model.new_int_var(0, horizon, f\"start[{t}]\")\n        duration = t + 1\n        presence = model.new_bool_var(f\"presence[{t}]\")\n        interval = model.new_optional_fixed_size_interval_var(\n            start, duration, presence, f\"opt_interval[{t}]\"\n        )\n        if t < num_tasks // 2:\n            model.add(presence == 1)\n\n        starts.append(start)\n        durations.append(duration)\n        intervals.append(interval)\n        presences.append(presence)\n\n        # Ranks = -1 if and only if the tasks is not performed.\n        ranks.append(model.new_int_var(-1, num_tasks - 1, f\"rank[{t}]\"))\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds ranking constraint.\n    rank_tasks_with_circuit(model, starts, durations, presences, ranks)\n\n    # Adds a constraint on ranks.\n    model.add(ranks[0] < ranks[1])\n\n    # Creates makespan variable.\n    makespan = model.new_int_var(0, horizon, \"makespan\")\n    for t in all_tasks:\n        model.add(starts[t] + durations[t] <= makespan).only_enforce_if(presences[t])\n\n    # Minimizes makespan - fixed gain per tasks performed.\n    # As the fixed cost is less that the duration of the last interval,\n    # the solver will not perform the last interval.\n    model.minimize(2 * makespan - 7 * sum(presences[t] for t in all_tasks))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Prints out the makespan and the start times and ranks of all tasks.\n        print(f\"Optimal cost: {solver.objective_value}\")\n        print(f\"Makespan: {solver.value(makespan)}\")\n        for t in all_tasks:\n            if solver.value(presences[t]):\n                print(\n                    f\"Task {t} starts at {solver.value(starts[t])} \"\n                    f\"with rank {solver.value(ranks[t])}\"\n                )\n            else:\n                print(\n                    f\"Task {t} in not performed and ranked at {solver.value(ranks[t])}\"\n                )\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n\n\nranking_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Kakuro Puzzle Implementation with OR-Tools\nDESCRIPTION: Complete implementation of a Kakuro puzzle solver using Google's OR-Tools. The code sets up constraints for puzzle segments, ensures valid number combinations, and finds solutions using constraint programming techniques. Includes puzzle definition, constraint setup, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/kakuro.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\ndef calc(cc, x, res):\n  solver = list(x.values())[0].solver()\n  for i in cc:\n    solver.Add(x[i[0] - 1, i[1] - 1] >= 1)\n  solver.Add(solver.Sum([x[i[0] - 1, i[1] - 1] for i in cc]) == res)\n\ndef main():\n  solver = pywrapcp.Solver(\"Kakuro\")\n  n = 7\n  problem = [[16, [1, 1], [1, 2]], [24, [1, 5], [1, 6], [1, 7]],\n             [17, [2, 1], [2, 2]], [29, [2, 4], [2, 5], [2, 6], [2, 7]],\n             [35, [3, 1], [3, 2], [3, 3], [3, 4], [3, 5]], [7, [4, 2], [4, 3]],\n             [8, [4, 5], [4, 6]], [16, [5, 3], [5, 4], [5, 5], [5, 6], [5, 7]],\n             [21, [6, 1], [6, 2], [6, 3], [6, 4]], [5, [6, 6], [6, 7]],\n             [6, [7, 1], [7, 2], [7, 3]], [3, [7, 6], [7, 7]],\n             [23, [1, 1], [2, 1], [3, 1]], [30, [1, 2], [2, 2], [3, 2], [4, 2]],\n             [27, [1, 5], [2, 5], [3, 5], [4, 5], [5, 5]], [12, [1, 6], [2, 6]],\n             [16, [1, 7], [2, 7]], [17, [2, 4], [3, 4]],\n             [15, [3, 3], [4, 3], [5, 3], [6, 3], [7, 3]],\n             [12, [4, 6], [5, 6], [6, 6], [7, 6]], [7, [5, 4], [6, 4]],\n             [7, [5, 7], [6, 7], [7, 7]], [11, [6, 1], [7, 1]],\n             [10, [6, 2], [7, 2]]]\n\n  blanks = [[1, 3], [1, 4], [2, 3], [3, 6], [3, 7], [4, 1], [4, 4], [4, 7],\n            [5, 1], [5, 2], [6, 5], [7, 4], [7, 5]]\n  num_blanks = len(blanks)\n  num_p = len(problem)\n\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[i, j] = solver.IntVar(0, 9, \"x[%i,%i]\" % (i, j))\n\n  x_flat = [x[i, j] for i in range(n) for j in range(n)]\n\n  for i in range(num_blanks):\n    solver.Add(x[blanks[i][0] - 1, blanks[i][1] - 1] == 0)\n\n  for i in range(num_p):\n    segment = problem[i][1::]\n    res = problem[i][0]\n    calc(segment, x, res)\n    segment = [x[p[0] - 1, p[1] - 1] for p in segment]\n    solver.Add(solver.AllDifferent(segment))\n\n  db = solver.Phase(x_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    for i in range(n):\n      for j in range(n):\n        val = x[i, j].Value()\n        if val > 0:\n          print(val, end=\" \")\n        else:\n          print(\" \", end=\" \")\n      print()\n\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing Problem with Global Span Constraint in Python\nDESCRIPTION: A complete implementation of a Vehicle Routing Problem that minimizes the maximum route distance. It includes data model creation, routing index manager setup, callback registration for distance calculation, and solving with the PATH_CHEAPEST_ARC strategy. The global span cost coefficient is set to prioritize balanced routes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_global_span.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Rectangle Covering Implementation with CP-SAT\nDESCRIPTION: Main implementation that tries to fill a 60x50 rectangle with a given number of non-overlapping squares. Uses constraint programming to handle placement constraints, symmetry breaking, and area coverage requirements. The solution uses CP-SAT solver with visualization of the result.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cover_rectangle_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\ndef cover_rectangle(num_squares: int) -> bool:\n    \"\"\"Try to fill the rectangle with a given number of squares.\"\"\"\n    size_x = 60\n    size_y = 50\n\n    model = cp_model.CpModel()\n\n    areas = []\n    sizes = []\n    x_intervals = []\n    y_intervals = []\n    x_starts = []\n    y_starts = []\n\n    # Creates intervals for the NoOverlap2D and size variables.\n    for i in range(num_squares):\n        size = model.new_int_var(1, size_y, \"size_%i\" % i)\n        start_x = model.new_int_var(0, size_x, \"sx_%i\" % i)\n        end_x = model.new_int_var(0, size_x, \"ex_%i\" % i)\n        start_y = model.new_int_var(0, size_y, \"sy_%i\" % i)\n        end_y = model.new_int_var(0, size_y, \"ey_%i\" % i)\n\n        interval_x = model.new_interval_var(start_x, size, end_x, \"ix_%i\" % i)\n        interval_y = model.new_interval_var(start_y, size, end_y, \"iy_%i\" % i)\n\n        area = model.new_int_var(1, size_y * size_y, \"area_%i\" % i)\n        model.add_multiplication_equality(area, [size, size])\n\n        areas.append(area)\n        x_intervals.append(interval_x)\n        y_intervals.append(interval_y)\n        sizes.append(size)\n        x_starts.append(start_x)\n        y_starts.append(start_y)\n\n    # Main constraint.\n    model.add_no_overlap_2d(x_intervals, y_intervals)\n\n    # Redundant constraints.\n    model.add_cumulative(x_intervals, sizes, size_y)\n    model.add_cumulative(y_intervals, sizes, size_x)\n\n    # Forces the rectangle to be exactly covered.\n    model.add(sum(areas) == size_x * size_y)\n\n    # Symmetry breaking 1: sizes are ordered.\n    for i in range(num_squares - 1):\n        model.add(sizes[i] <= sizes[i + 1])\n\n        # Define same to be true iff sizes[i] == sizes[i + 1]\n        same = model.new_bool_var(\"\")\n        model.add(sizes[i] == sizes[i + 1]).only_enforce_if(same)\n        model.add(sizes[i] < sizes[i + 1]).only_enforce_if(~same)\n\n        # Tie break with starts.\n        model.add(x_starts[i] <= x_starts[i + 1]).only_enforce_if(same)\n\n    # Symmetry breaking 2: first square in one quadrant.\n    model.add(x_starts[0] < (size_x + 1) // 2)\n    model.add(y_starts[0] < (size_y + 1) // 2)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    solver.parameters.num_workers = 8\n    solver.parameters.max_time_in_seconds = 10.0\n    status = solver.solve(model)\n    print(\"%s found in %0.2fs\" % (solver.status_name(status), solver.wall_time))\n\n    # Prints solution.\n    solution_found = status == cp_model.OPTIMAL or status == cp_model.FEASIBLE\n    if solution_found:\n        display = [[\" \" for _ in range(size_x)] for _ in range(size_y)]\n        for i in range(num_squares):\n            sol_x = solver.value(x_starts[i])\n            sol_y = solver.value(y_starts[i])\n            sol_s = solver.value(sizes[i])\n            char = format(i, \"01x\")\n            for j in range(sol_s):\n                for k in range(sol_s):\n                    if display[sol_y + j][sol_x + k] != \" \":\n                        print(\n                            \"ERROR between %s and %s\"\n                            % (display[sol_y + j][sol_x + k], char)\n                        )\n                    display[sol_y + j][sol_x + k] = char\n\n        for line in range(size_y):\n            print(\" \".join(display[line]))\n    return solution_found\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    for num_squares in range(1, 15):\n        print(\"Trying with size =\", num_squares)\n        if cover_rectangle(num_squares):\n            break\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing in C++\nDESCRIPTION: Basic C++ implementation of a vehicle routing problem using OR-Tools. Demonstrates setting up a routing model, defining distance callbacks, and solving a simple routing scenario with one vehicle and five locations.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/ROUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <sstream>\n\n#include \"ortools/constraint_solver/routing.h\"\n#include \"ortools/constraint_solver/routing_enums.pb.h\"\n#include \"ortools/constraint_solver/routing_index_manager.h\"\n#include \"ortools/constraint_solver/routing_parameters.h\"\n\nnamespace operations_research {\n\nvoid SimpleRoutingProgram() {\n  // Instantiate the data problem.\n  int num_location = 5;\n  int num_vehicles = 1;\n  RoutingIndexManager::NodeIndex depot{0};\n\n  // Create Routing Index Manager\n  RoutingIndexManager manager(num_location, num_vehicles, depot);\n\n  // Create Routing Model.\n  RoutingModel routing(manager);\n\n  // Define cost of each arc.\n  int distance_call_index = routing.RegisterTransitCallback(\n      [&manager](int64_t from_index, int64_t to_index) -> int64_t {\n        // Convert from routing variable Index to user NodeIndex.\n        auto from_node = manager.IndexToNode(from_index).value();\n        auto to_node = manager.IndexToNode(to_index).value();\n        return std::abs(to_node - from_node);\n      });\n  routing.SetArcCostEvaluatorOfAllVehicles(distance_call_index);\n\n  // Setting first solution heuristic.\n  RoutingSearchParameters searchParameters = DefaultRoutingSearchParameters();\n  searchParameters.set_first_solution_strategy(\n      FirstSolutionStrategy::PATH_CHEAPEST_ARC);\n\n  // Solve the problem.\n  const Assignment* solution = routing.SolveWithParameters(searchParameters);\n\n  // Print solution on console.\n  LOG(INFO) << \"Objective: \" << solution->ObjectiveValue();\n  // Inspect solution.\n  int64_t index = routing.Start(0);\n  LOG(INFO) << \"Route for Vehicle 0:\";\n  int64_t route_distance = 0;\n  std::ostringstream route;\n  while (!routing.IsEnd(index)) {\n    route << manager.IndexToNode(index).value() << \" -> \";\n    const int64_t previous_index = index;\n    index = solution->Value(routing.NextVar(index));\n    route_distance +=\n        routing.GetArcCostForVehicle(previous_index, index, int64_t{0});\n  }\n  LOG(INFO) << route.str() << manager.IndexToNode(index).value();\n  LOG(INFO) << \"Distance of the route: \" << route_distance << \"m\";\n}\n\n}  // namespace operations_research\n\nint main(int /*argc*/, char* /*argv*/[]) {\n  operations_research::SimpleRoutingProgram();\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Diet Optimization with Google CP Solver\nDESCRIPTION: Defines the main function that sets up and solves the diet optimization problem using Google CP Solver. It includes data initialization, variable declaration, constraint definition, and solution retrieval.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/diet1_b.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(unused_argv):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Diet\")\n\n  #\n  # data\n  #\n  n = 4\n  price = [50, 20, 30, 80]  # in cents\n  limits = [500, 6, 10, 8]  # requirements for each nutrition type\n\n  # nutritions for each product\n  calories = [400, 200, 150, 500]\n  chocolate = [3, 2, 0, 0]\n  sugar = [2, 2, 4, 4]\n  fat = [2, 4, 1, 5]\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 100, \"x%d\" % i) for i in range(n)]\n  cost = solver.IntVar(0, 10000, \"cost\")\n\n  #\n  # constraints\n  #\n  solver.Add(solver.ScalProd(x, calories) >= limits[0])\n  solver.Add(solver.ScalProd(x, chocolate) >= limits[1])\n  solver.Add(solver.ScalProd(x, sugar) >= limits[2])\n  solver.Add(solver.ScalProd(x, fat) >= limits[3])\n\n  # objective\n  objective = solver.Minimize(cost, 1)\n\n  #\n  # solution\n  #\n  solution = solver.Assignment()\n  solution.AddObjective(cost)\n  solution.Add(x)\n\n  # last solution since it's a minimization problem\n  collector = solver.LastSolutionCollector(solution)\n  search_log = solver.SearchLog(100, cost)\n  solver.Solve(\n      solver.Phase(x + [cost], solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE),\n      [objective, search_log, collector])\n\n  # get the first (and only) solution\n  print(\"cost:\", collector.ObjectiveValue(0))\n  print([((\"abcdefghij\" [i], collector.Value(0, x[i])) for i in range(n))])\n  print()\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print()\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean CP-SAT Model Solver\nDESCRIPTION: Function that implements the Boolean model approach using CP-SAT to solve the assembly line balancing problem. It creates boolean variables for task assignments and pod activity, adding constraints for precedence, cycle time, and contiguity of pods.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef solve_problem_with_boolean_model(\n    problem: Dict[str, SectionInfo], hint: Dict[int, int]\n) -> None:\n    \"\"\"solve the given problem.\"\"\"\n\n    print(\"Solving using the Boolean model\")\n    # problem data\n    num_tasks = problem[\"number of tasks\"].value\n    if num_tasks is None:\n        return\n    all_tasks = range(1, num_tasks + 1)  # Tasks are 1 based in the problem.\n    durations = problem[\"task times\"].index_map\n    precedences = problem[\"precedence relations\"].set_of_pairs\n    cycle_time = problem[\"cycle time\"].value\n\n    num_pods = max(p for _, p in hint.items()) + 1 if hint else num_tasks - 1\n    all_pods = range(num_pods)\n\n    model = cp_model.CpModel()\n\n    # assign[t, p] indicates if task t is done on pod p.\n    assign = {}\n    # possible[t, p] indicates if task t is possible on pod p.\n    possible = {}\n\n    # Create the variables\n    for t in all_tasks:\n        for p in all_pods:\n            assign[t, p] = model.new_bool_var(f\"assign_{t}_{p}\")\n            possible[t, p] = model.new_bool_var(f\"possible_{t}_{p}\")\n\n    # active[p] indicates if pod p is active.\n    active = [model.new_bool_var(f\"active_{p}\") for p in all_pods]\n\n    # Each task is done on exactly one pod.\n    for t in all_tasks:\n        model.add_exactly_one([assign[t, p] for p in all_pods])\n\n    # Total tasks assigned to one pod cannot exceed cycle time.\n    for p in all_pods:\n        model.add(sum(assign[t, p] * durations[t] for t in all_tasks) <= cycle_time)\n\n    # Maintain the possible variables:\n    #   possible at pod p -> possible at any pod after p\n    for t in all_tasks:\n        for p in range(num_pods - 1):\n            model.add_implication(possible[t, p], possible[t, p + 1])\n\n    # Link possible and active variables.\n    for t in all_tasks:\n        for p in all_pods:\n            model.add_implication(assign[t, p], possible[t, p])\n            if p > 1:\n                model.add_implication(assign[t, p], ~possible[t, p - 1])\n\n    # Precedences.\n    for before, after in precedences:\n        for p in range(1, num_pods):\n            model.add_implication(assign[before, p], ~possible[after, p - 1])\n\n    # Link active variables with the assign one.\n    for p in all_pods:\n        all_assign_vars = [assign[t, p] for t in all_tasks]\n        for a in all_assign_vars:\n            model.add_implication(a, active[p])\n        model.add_bool_or(all_assign_vars + [~active[p]])\n\n    # Force pods to be contiguous. This is critical to get good lower bounds\n    # on the objective, even if it makes feasibility harder.\n    for p in range(1, num_pods):\n        model.add_implication(~active[p - 1], ~active[p])\n        for t in all_tasks:\n            model.add_implication(~active[p], possible[t, p - 1])\n\n    # Objective.\n    model.minimize(sum(active))\n\n    # add search hinting from the greedy solution.\n    for t in all_tasks:\n        model.add_hint(assign[t, hint[t]], 1)\n\n    if _OUTPUT_PROTO.value:\n        print(f\"Writing proto to {_OUTPUT_PROTO.value}\")\n        model.export_to_file(_OUTPUT_PROTO.value)\n\n    # solve model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n    solver.parameters.log_search_progress = True\n    solver.solve(model)\n```\n\n----------------------------------------\n\nTITLE: Implementing CP-SAT Solver for N-Queens Problem\nDESCRIPTION: Complete implementation of the N-Queens problem solver using CP-SAT. Includes a solution printer callback, variable creation, constraint definition for row, column, and diagonal attacks, and the main solving function. The code visualizes each solution as it's found and prints final statistics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/nqueens_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom ortools.sat.colab import flags\nfrom ortools.sat.python import cp_model\n\n_SIZE = flags.define_integer(\"size\", 8, \"Number of queens.\")\n\n\nclass NQueenSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, queens: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self._queens = queens\n        self._solution_count = 0\n        self._start_time = time.time()\n\n    @property\n    def solution_count(self) -> int:\n        return self._solution_count\n\n    def on_solution_callback(self) -> None:\n        current_time = time.time()\n        print(\n            f\"Solution{self._solution_count}, time =\"\n            f\" {current_time - self._start_time} s\"\n        )\n        self._solution_count += 1\n\n        all_queens = range(len(self._queens))\n        for i in all_queens:\n            for j in all_queens:\n                if self.value(self._queens[j]) == i:\n                    # There is a queen in column j, row i.\n                    print(\"Q\", end=\" \")\n                else:\n                    print(\"_\", end=\" \")\n            print()\n        print()\n\n\ndef main(_):\n    board_size = _SIZE.value\n\n    ### Creates the solver.\n    model = cp_model.CpModel()\n\n    ### Creates the variables.\n    # The array index is the column, and the value is the row.\n    queens = [\n        model.new_int_var(0, board_size - 1, \"x%i\" % i) for i in range(board_size)\n    ]\n\n    ### Creates the constraints.\n\n    # All columns must be different because the indices of queens are all\n    # different, so we just add the all different constraint on the rows.\n    model.add_all_different(queens)\n\n    # No two queens can be on the same diagonal.\n    diag1 = []\n    diag2 = []\n    for i in range(board_size):\n        q1 = model.new_int_var(0, 2 * board_size, \"diag1_%i\" % i)\n        q2 = model.new_int_var(-board_size, board_size, \"diag2_%i\" % i)\n        diag1.append(q1)\n        diag2.append(q2)\n        model.add(q1 == queens[i] + i)\n        model.add(q2 == queens[i] - i)\n    model.add_all_different(diag1)\n    model.add_all_different(diag2)\n\n    ### Solve model.\n    solver = cp_model.CpSolver()\n    solution_printer = NQueenSolutionPrinter(queens)\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    # solve.\n    solver.solve(model, solution_printer)\n\n    print()\n    print(\"Statistics\")\n    print(\"  - conflicts       : %i\" % solver.num_conflicts)\n    print(\"  - branches        : %i\" % solver.num_branches)\n    print(\"  - wall time       : %f s\" % solver.wall_time)\n    print(\"  - solutions found : %i\" % solution_printer.solution_count)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Stable Marriage Problem Solver Implementation\nDESCRIPTION: Main implementation of the Stable Marriage Problem solver using OR-Tools. Includes variable declaration, constraint definition, and solution search logic. The code handles different problem sizes and includes multiple test cases with different ranking scenarios.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stable_marriage.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(ranks, problem_name):\n\n  # Create the solver\n  solver = pywrapcp.Solver(\"Stable marriage\")\n\n  #\n  # data\n  #\n  print(\"Problem name:\", problem_name)\n\n  rankMen = ranks[\"rankMen\"]\n  rankWomen = ranks[\"rankWomen\"]\n\n  n = len(rankMen)\n\n  #\n  # declare variables\n  #\n  wife = [solver.IntVar(0, n - 1, \"wife[%i]\" % i) for i in range(n)]\n  husband = [solver.IntVar(0, n - 1, \"husband[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n\n  # forall(m in Men)\n  #    cp.post(husband[wife[m]] == m);\n  for m in range(n):\n    solver.Add(solver.Element(husband, wife[m]) == m)\n\n  # forall(w in Women)\n  #    cp.post(wife[husband[w]] == w);\n  for w in range(n):\n    solver.Add(solver.Element(wife, husband[w]) == w)\n\n  # forall(m in Men, o in Women)\n  # cp.post(rankMen[m,o] < rankMen[m, wife[m]] => rankWomen[o,husband[o]] <\n  # rankWomen[o,m]);\n  for m in range(n):\n    for o in range(n):\n      b1 = solver.IsGreaterCstVar(\n          solver.Element(rankMen[m], wife[m]), rankMen[m][o])\n      b2 = (\n          solver.IsLessCstVar(\n              solver.Element(rankWomen[o], husband[o]), rankWomen[o][m]))\n      solver.Add(b1 - b2 <= 0)\n\n  # forall(w in Women, o in Men)\n  # cp.post(rankWomen[w,o] < rankWomen[w,husband[w]] => rankMen[o,wife[o]] <\n  # rankMen[o,w]);\n  for w in range(n):\n    for o in range(n):\n      b1 = solver.IsGreaterCstVar(\n          solver.Element(rankWomen[w], husband[w]), rankWomen[w][o])\n      b2 = solver.IsLessCstVar(\n          solver.Element(rankMen[o], wife[o]), rankMen[o][w])\n      solver.Add(b1 - b2 <= 0)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(wife)\n  solution.Add(husband)\n\n  db = solver.Phase(wife + husband, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  solutions = []\n  while solver.NextSolution():\n    # solutions.append([x[i].Value() for i in range(x_len)])\n    print(\"wife   : \", [wife[i].Value() for i in range(n)])\n    print(\"husband: \", [husband[i].Value() for i in range(n)])\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print(\"#############\")\n  print()\n\n\n#\n# From Van Hentenryck's OPL book\n#\nvan_hentenryck = {\n    \"rankWomen\": [[1, 2, 4, 3, 5], [3, 5, 1, 2, 4], [5, 4, 2, 1, 3],\n                  [1, 3, 5, 4, 2], [4, 2, 3, 5, 1]],\n    \"rankMen\": [[5, 1, 2, 4, 3], [4, 1, 3, 2, 5], [5, 3, 2, 4, 1],\n                [1, 5, 4, 3, 2], [4, 3, 2, 1, 5]]\n}\n\n#\n# Data from MathWorld\n# http://mathworld.wolfram.com/StableMarriageProblem.html\n#\nmathworld = {\n    \"rankWomen\": [[3, 1, 5, 2, 8, 7, 6, 9, 4], [9, 4, 8, 1, 7, 6, 3, 2, 5],\n                  [3, 1, 8, 9, 5, 4, 2, 6, 7], [8, 7, 5, 3, 2, 6, 4, 9, 1],\n                  [6, 9, 2, 5, 1, 4, 7, 3, 8], [2, 4, 5, 1, 6, 8, 3, 9, 7],\n                  [9, 3, 8, 2, 7, 5, 4, 6, 1], [6, 3, 2, 1, 8, 4, 5, 9, 7],\n                  [8, 2, 6, 4, 9, 1, 3, 7, 5]],\n    \"rankMen\": [[7, 3, 8, 9, 6, 4, 2, 1, 5], [5, 4, 8, 3, 1, 2, 6, 7, 9],\n                [4, 8, 3, 9, 7, 5, 6, 1, 2], [9, 7, 4, 2, 5, 8, 3, 1, 6],\n                [2, 6, 4, 9, 8, 7, 5, 1, 3], [2, 7, 8, 6, 5, 3, 4, 1, 9],\n                [1, 6, 2, 3, 8, 5, 4, 9, 7], [5, 6, 9, 1, 2, 8, 4, 3, 7],\n                [6, 1, 4, 7, 5, 8, 3, 9, 2]]\n}\n\n#\n# Data from\n# http://www.csee.wvu.edu/~ksmani/courses/fa01/random/lecnotes/lecture5.pdf\n#\nproblem3 = {\n    \"rankWomen\": [[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4], [3, 4, 1, 2]],\n    \"rankMen\": [[1, 2, 3, 4], [2, 1, 3, 4], [1, 4, 3, 2], [4, 3, 1, 2]]\n}\n\n#\n# Data from\n# http://www.comp.rgu.ac.uk/staff/ha/ZCSP/additional_problems/stable_marriage/stable_marriage.pdf\n# page 4\n#\nproblem4 = {\n    \"rankWomen\": [[1, 5, 4, 6, 2, 3], [4, 1, 5, 2, 6, 3], [6, 4, 2, 1, 5, 3],\n                  [1, 5, 2, 4, 3, 6], [4, 2, 1, 5, 6, 3], [2, 6, 3, 5, 1, 4]],\n    \"rankMen\": [[1, 4, 2, 5, 6, 3], [3, 4, 6, 1, 5, 2], [1, 6, 4, 2, 3, 5],\n                [6, 5, 3, 4, 2, 1], [3, 1, 2, 4, 5, 6], [2, 3, 1, 6, 5, 4]]\n}\n\nmain(van_hentenryck, \"Van Hentenryck\")\nmain(mathworld, \"MathWorld\")\nmain(problem3, \"Problem 3\")\nmain(problem4, \"Problem4\")\n```\n\n----------------------------------------\n\nTITLE: Day Schedule Optimization Implementation\nDESCRIPTION: Main implementation of the scheduling problem using OR-Tools. Includes task scheduling with duration constraints, no-overlap constraints, and specific time requirements. The code creates a constraint satisfaction problem to organize tasks like work, mail, shopping, and banking within business hours.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/organize_day.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n#\n# No overlapping of tasks s1 and s2\n#\n\n\ndef no_overlap(solver, s1, d1, s2, d2):\n  b1 = solver.IsLessOrEqualVar(s1 + d1, s2)  # s1 + d1 <= s2\n  b2 = solver.IsLessOrEqualVar(s2 + d2, s1)  # s2 + d2 <= s1\n  solver.Add(b1 + b2 >= 1)\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Organizing a day')\n\n  #\n  # data\n  #\n  n = 4\n\n  tasks = list(range(n))\n  work, mail, shop, bank = tasks\n  durations = [4, 1, 2, 1]\n\n  # task [i,0] must be finished before task [i,1]\n  before_tasks = [[bank, shop], [mail, work]]\n\n  # the valid times of the day\n  begin = 9\n  end = 17\n\n  #\n  # declare variables\n  #\n  begins = [solver.IntVar(begin, end, 'begins[%i]% % i') for i in tasks]\n  ends = [solver.IntVar(begin, end, 'ends[%i]% % i') for i in tasks]\n\n  #\n  # constraints\n  #\n  for i in tasks:\n    solver.Add(ends[i] == begins[i] + durations[i])\n\n  for i in tasks:\n    for j in tasks:\n      if i < j:\n        no_overlap(solver, begins[i], durations[i], begins[j], durations[j])\n\n  # specific constraints\n  for (before, after) in before_tasks:\n    solver.Add(ends[before] <= begins[after])\n\n  solver.Add(begins[work] >= 11)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(begins + ends, solver.INT_VAR_DEFAULT,\n                    solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('begins:', [begins[i].Value() for i in tasks])\n    print('ends:', [ends[i].Value() for i in tasks])\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Furniture Moving Optimization Model\nDESCRIPTION: Complete implementation of the furniture moving scheduling problem using OR-Tools. Includes cumulative constraint decomposition, variable declarations, constraints setup, and optimization solving. The model minimizes either the end time or number of resources needed while scheduling furniture moving tasks.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/furniture_moving.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\ndef my_cumulative(solver, s, d, r, b):\n  tasks = [i for i in range(len(s)) if r[i] > 0 and d[i] > 0]\n  times_min = min([s[i].Min() for i in tasks])\n  times_max = max([s[i].Max() + max(d) for i in tasks])\n  for t in range(times_min, times_max + 1):\n    bb = []\n    for i in tasks:\n      c1 = solver.IsLessOrEqualCstVar(s[i], t)\n      c2 = solver.IsGreaterCstVar(s[i] + d[i], t)\n      bb.append(c1 * c2 * r[i])\n    solver.Add(solver.Sum(bb) <= b)\n  if not isinstance(b, int):\n    solver.Add(b <= sum(r))\n\ndef main():\n  solver = pywrapcp.Solver(\"Furniture moving\")\n  n = 4\n  duration = [30, 10, 15, 15]\n  demand = [3, 1, 3, 2]\n  upper_limit = 160\n  start_times = [\n      solver.IntVar(0, upper_limit, \"start_times[%i]\" % i) for i in range(n)\n  ]\n  end_times = [\n      solver.IntVar(0, upper_limit * 2, \"end_times[%i]\" % i) for i in range(n)\n  ]\n  end_time = solver.IntVar(0, upper_limit * 2, \"end_time\")\n  num_resources = solver.IntVar(0, 10, \"num_resources\")\n  for i in range(n):\n    solver.Add(end_times[i] == start_times[i] + duration[i])\n  solver.Add(end_time == solver.Max(end_times))\n  my_cumulative(solver, start_times, duration, demand, num_resources)\n  objective = solver.Minimize(num_resources, 1)\n  solution = solver.Assignment()\n  solution.Add(start_times)\n  solution.Add(end_times)\n  solution.Add(end_time)\n  solution.Add(num_resources)\n  db = solver.Phase(start_times, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"num_resources:\", num_resources.Value())\n    print(\"start_times  :\", [start_times[i].Value() for i in range(n)])\n    print(\"duration     :\", [duration[i] for i in range(n)])\n    print(\"end_times    :\", [end_times[i].Value() for i in range(n)])\n    print(\"end_time     :\", end_time.Value())\n    print()\n  solver.EndSearch()\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with CP-SAT in Python\nDESCRIPTION: The snippet demonstrates how to set up and solve an assignment problem using Google OR-Tools' CP-SAT solver. It defines variables for workers and tasks, adds constraints to ensure proper assignment, and sets an objective to minimize cost. Dependencies include pandas for data handling and ortools for solver access. The function accepts no direct inputs and outputs the optimal or feasible solution cost and assignment if one exists.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport io\n\nimport pandas as pd\n\nfrom ortools.sat.python import cp_model\n\ndef main() -> None:\n    # Data\n    data_str = \"\"\"\n  worker  task  cost\n      w1    t1    90\n      w1    t2    80\n      w1    t3    75\n      w1    t4    70\n      w2    t1    35\n      w2    t2    85\n      w2    t3    55\n      w2    t4    65\n      w3    t1   125\n      w3    t2    95\n      w3    t3    90\n      w3    t4    95\n      w4    t1    45\n      w4    t2   110\n      w4    t3    95\n      w4    t4   115\n      w5    t1    50\n      w5    t2   110\n      w5    t3    90\n      w5    t4   100\n  \"\"\"\n\n    data = pd.read_table(io.StringIO(data_str), sep=r\"\\s+\")\n\n    # Model\n    model = cp_model.CpModel()\n\n    # Variables\n    x = model.new_bool_var_series(name=\"x\", index=data.index)\n\n    # Constraints\n    # Each worker is assigned to at most one task.\n    for unused_name, tasks in data.groupby(\"worker\"):\n        model.add_at_most_one(x[tasks.index])\n\n    # Each task is assigned to exactly one worker.\n    for unused_name, workers in data.groupby(\"task\"):\n        model.add_exactly_one(x[workers.index])\n\n    # Objective\n    model.minimize(data.cost.dot(x))\n\n    # Solve\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Print solution.\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"Total cost = {solver.objective_value}\\n\")\n        selected = data.loc[solver.boolean_values(x).loc[lambda x: x].index]\n        for unused_index, row in selected.iterrows():\n            print(f\"{row.task} assigned to {row.worker} with a cost of {row.cost}\")\n    elif status == cp_model.INFEASIBLE:\n        print(\"No solution found\")\n    else:\n        print(\"Something is wrong, check the status and the log of the solve\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Job Shop Scheduling with Maintenance Using CP-SAT Solver\nDESCRIPTION: A complete implementation of a job shop scheduling problem solver that includes maintenance constraints. The code creates a CP-SAT model, defines job tasks and their durations, adds maintenance intervals, and optimizes for minimal makespan.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/jobshop_with_maintenance_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self) -> None:\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        \"\"\"Called at each new solution.\"\"\"\n        print(\n            f\"Solution {self.__solution_count}, time = {self.wall_time} s,\"\n            f\" objective = {self.objective_value}\"\n        )\n        self.__solution_count += 1\n\n\ndef jobshop_with_maintenance() -> None:\n    \"\"\"Solves a jobshop with maintenance on one machine.\"\"\"\n    # Create the model.\n    model = cp_model.CpModel()\n\n    jobs_data = [  # task = (machine_id, processing_time).\n        [(0, 3), (1, 2), (2, 2)],  # Job0\n        [(0, 2), (2, 1), (1, 4)],  # Job1\n        [(1, 4), (2, 3)],  # Job2\n    ]\n\n    machines_count = 1 + max(task[0] for job in jobs_data for task in job)\n    all_machines = range(machines_count)\n\n    # Computes horizon dynamically as the sum of all durations.\n    horizon = sum(task[1] for job in jobs_data for task in job)\n\n    # Named tuple to store information about created variables.\n    task_type = collections.namedtuple(\"task_type\", \"start end interval\")\n    # Named tuple to manipulate solution information.\n    assigned_task_type = collections.namedtuple(\n        \"assigned_task_type\", \"start job index duration\"\n    )\n\n    # Creates job intervals and add to the corresponding machine lists.\n    all_tasks = {}\n    machine_to_intervals = collections.defaultdict(list)\n\n    for job_id, job in enumerate(jobs_data):\n        for entry in enumerate(job):\n            task_id, task = entry\n            machine, duration = task\n            suffix = f\"_{job_id}_{task_id}\"\n            start_var = model.new_int_var(0, horizon, \"start\" + suffix)\n            end_var = model.new_int_var(0, horizon, \"end\" + suffix)\n            interval_var = model.new_interval_var(\n                start_var, duration, end_var, \"interval\" + suffix\n            )\n            all_tasks[job_id, task_id] = task_type(\n                start=start_var, end=end_var, interval=interval_var\n            )\n            machine_to_intervals[machine].append(interval_var)\n\n    # Add maintenance interval (machine 0 is not available on time {4, 5, 6, 7}).\n    machine_to_intervals[0].append(model.new_interval_var(4, 4, 8, \"weekend_0\"))\n\n    # Create and add disjunctive constraints.\n    for machine in all_machines:\n        model.add_no_overlap(machine_to_intervals[machine])\n\n    # Precedences inside a job.\n    for job_id, job in enumerate(jobs_data):\n        for task_id in range(len(job) - 1):\n            model.add(\n                all_tasks[job_id, task_id + 1].start >= all_tasks[job_id, task_id].end\n            )\n\n    # Makespan objective.\n    obj_var = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(\n        obj_var,\n        [all_tasks[job_id, len(job) - 1].end for job_id, job in enumerate(jobs_data)],\n    )\n    model.minimize(obj_var)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    solution_printer = SolutionPrinter()\n    status = solver.solve(model, solution_printer)\n\n    # Output solution.\n    if status == cp_model.OPTIMAL:\n        # Create one list of assigned tasks per machine.\n        assigned_jobs = collections.defaultdict(list)\n        for job_id, job in enumerate(jobs_data):\n            for task_id, task in enumerate(job):\n                machine = task[0]\n                assigned_jobs[machine].append(\n                    assigned_task_type(\n                        start=solver.value(all_tasks[job_id, task_id].start),\n                        job=job_id,\n                        index=task_id,\n                        duration=task[1],\n                    )\n                )\n\n        # Create per machine output lines.\n        output = \"\"\n        for machine in all_machines:\n            # Sort by starting time.\n            assigned_jobs[machine].sort()\n            sol_line_tasks = \"Machine \" + str(machine) + \": \"\n            sol_line = \"           \"\n\n            for assigned_task in assigned_jobs[machine]:\n                name = f\"job_{assigned_task.job}_{assigned_task.index}\"\n                # add spaces to output to align columns.\n                sol_line_tasks += f\"{name:>10}\"\n                start = assigned_task.start\n                duration = assigned_task.duration\n\n                sol_tmp = f\"[{start}, {start + duration}]\"\n                # add spaces to output to align columns.\n                sol_line += f\"{sol_tmp:>10}\"\n\n            sol_line += \"\\n\"\n            sol_line_tasks += \"\\n\"\n            output += sol_line_tasks\n            output += sol_line\n\n        # Finally print the solution found.\n        print(f\"Optimal Schedule Length: {solver.objective_value}\")\n        print(output)\n        print(solver.response_stats())\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    jobshop_with_maintenance()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing Problem with Pickup and Delivery using OR-Tools\nDESCRIPTION: Complete implementation of a Pickup Delivery Problem (PDP) using the constraint solver from OR-Tools. The code creates a distance matrix, defines pickup-delivery pairs, sets up vehicle constraints, and solves the routing problem to find optimal routes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_pickup_delivery.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"pickups_deliveries\"] = [\n        [1, 6],\n        [2, 10],\n        [4, 3],\n        [5, 9],\n        [7, 8],\n        [15, 11],\n        [13, 12],\n        [16, 14],\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    total_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        total_distance += route_distance\n    print(f\"Total Distance of all routes: {total_distance}m\")\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Define cost of each arc.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the manhattan distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Define Transportation Requests.\n    for request in data[\"pickups_deliveries\"]:\n        pickup_index = manager.NodeToIndex(request[0])\n        delivery_index = manager.NodeToIndex(request[1])\n        routing.AddPickupAndDelivery(pickup_index, delivery_index)\n        routing.solver().Add(\n            routing.VehicleVar(pickup_index) == routing.VehicleVar(delivery_index)\n        )\n        routing.solver().Add(\n            distance_dimension.CumulVar(pickup_index)\n            <= distance_dimension.CumulVar(delivery_index)\n        )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PARALLEL_CHEAPEST_INSERTION\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Steel Mill Slab Optimization with OR-Tools in Python\nDESCRIPTION: This code implements a solution for the steel mill slab optimization problem using Google OR-Tools. It includes data reading, constraint definition, a custom decision builder, and the main optimization loop. The problem aims to minimize waste when cutting steel slabs while respecting color constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/steel.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nfrom ortools.constraint_solver import pywrapcp\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\n    '--data',\n    default='examples/contrib/steel.txt',\n    help='path to data file')\nparser.add_argument(\n    '--time_limit', default=20000, type=int, help='global time limit')\n\n#----------------helper for binpacking posting----------------\n\n\ndef BinPacking(solver, binvars, weights, loadvars):\n  \"\"\"post the load constraint on bins.\n\n  constraints forall j: loadvars[j] == sum_i (binvars[i] == j) * weights[i])\n  \"\"\"\n  pack = solver.Pack(binvars, len(binvars))\n  pack.AddWeightedSumEqualVarDimension(weights, loadvars)\n  solver.Add(pack)\n  solver.Add(solver.SumEquality(loadvars, sum(weights)))\n\n\n#------------------------------data reading-------------------\n\n\ndef ReadData(filename):\n  \"\"\"Read data from <filename>.\"\"\"\n  f = open(filename)\n  capacity = [int(nb) for nb in f.readline().split()]\n  capacity.pop(0)\n  capacity = [0] + capacity\n  max_capacity = max(capacity)\n  nb_colors = int(f.readline())\n  nb_slabs = int(f.readline())\n  wc = [[int(j) for j in f.readline().split()] for i in range(nb_slabs)]\n  weights = [x[0] for x in wc]\n  colors = [x[1] for x in wc]\n  loss = [\n      min([x for x in capacity if x >= c]) - c for c in range(max_capacity + 1)\n  ]\n  color_orders = [[o\n                   for o in range(nb_slabs)\n                   if colors[o] == c]\n                  for c in range(1, nb_colors + 1)]\n  print('Solving steel mill with', nb_slabs, 'slabs')\n  return (nb_slabs, capacity, max_capacity, weights, colors, loss, color_orders)\n\n\n#------------------dedicated search for this problem-----------\n\n\nclass SteelDecisionBuilder(pywrapcp.PyDecisionBuilder):\n  \"\"\"Dedicated Decision Builder for steel mill slab.\n\n  Search for the steel mill slab problem with Dynamic Symmetry\n  Breaking during search is an adaptation (for binary tree) from the\n  paper of Pascal Van Hentenryck and Laurent Michel CPAIOR-2008.\n\n  The value heuristic comes from the paper\n  Solving Steel Mill Slab Problems with Constraint-Based Techniques:\n    CP, LNS, and CBLS,\n  Schaus et. al. to appear in Constraints 2010\n  \"\"\"\n\n  def __init__(self, x, nb_slabs, weights, losstab, loads):\n    pywrapcp.PyDecisionBuilder.__init__(self)\n    self.__x = x\n    self.__nb_slabs = nb_slabs\n    self.__weights = weights\n    self.__losstab = losstab\n    self.__loads = loads\n    self.__maxcapa = len(losstab) - 1\n\n  def Next(self, solver):\n    var, weight = self.NextVar()\n    if var:\n      v = self.MaxBound()\n      if v + 1 == var.Min():\n        # Symmetry breaking. If you need to assign to a new bin,\n        # select the first one.\n        solver.Add(var == v + 1)\n        return self.Next(solver)\n      else:\n        # value heuristic (important for difficult problem):\n        #   try first to place the order in the slab that will induce\n        #   the least increase of the loss\n        loads = self.getLoads()\n        l, v = min((self.__losstab[loads[i] + weight], i)\n                   for i in range(var.Min(),\n                                  var.Max() + 1)\n                   if var.Contains(i) and loads[i] + weight <= self.__maxcapa)\n        decision = solver.AssignVariableValue(var, v)\n        return decision\n    else:\n      return None\n\n  def getLoads(self):\n    load = [0] * len(self.__loads)\n    for w, x in zip(self.__weights, self.__x):\n      if x.Bound():\n        load[x.Min()] += w\n    return load\n\n  def MaxBound(self):\n    \"\"\" returns the max value bound to a variable, -1 if no variables bound\"\"\"\n    return max([-1] + [\n        self.__x[o].Min()\n        for o in range(self.__nb_slabs)\n        if self.__x[o].Bound()\n    ])\n\n  def NextVar(self):\n    \"\"\" mindom size heuristic with tie break on the weights of orders \"\"\"\n    res = [(self.__x[o].Size(), -self.__weights[o], self.__x[o])\n           for o in range(self.__nb_slabs)\n           if self.__x[o].Size() > 1]\n    if res:\n      res.sort()\n      return res[0][2], -res[0][1]  # returns the order var and its weight\n    else:\n      return None, None\n\n  def DebugString(self):\n    return 'SteelMillDecisionBuilder(' + str(self.__x) + ')'\n\n\ndef main(args):\n  #------------------solver and variable declaration-------------\n  (nb_slabs, capacity, max_capacity, weights, colors, loss, color_orders) =\\\n      ReadData(args.data)\n  nb_colors = len(color_orders)\n  solver = pywrapcp.Solver('Steel Mill Slab')\n  x = [solver.IntVar(0, nb_slabs - 1, 'x' + str(i)) for i in range(nb_slabs)]\n  load_vars = [\n      solver.IntVar(0, max_capacity - 1, 'load_vars' + str(i))\n      for i in range(nb_slabs)\n  ]\n\n  #-------------------post of the constraints--------------\n\n  # Bin Packing.\n  BinPacking(solver, x, weights, load_vars)\n  # At most two colors per slab.\n  for s in range(nb_slabs):\n    solver.Add(\n        solver.SumLessOrEqual([\n            solver.Max([solver.IsEqualCstVar(x[c], s)\n                        for c in o])\n            for o in color_orders\n        ], 2))\n\n  #----------------Objective-------------------------------\n\n  objective_var = \\\n      solver.Sum([load_vars[s].IndexOf(loss) for s in range(nb_slabs)]).Var()\n  objective = solver.Minimize(objective_var, 1)\n\n  #------------start the search and optimization-----------\n\n  db = SteelDecisionBuilder(x, nb_slabs, weights, loss, load_vars)\n  search_log = solver.SearchLog(100000, objective_var)\n  global_limit = solver.TimeLimit(args.time_limit)\n  solver.NewSearch(db, [objective, search_log, global_limit])\n  while solver.NextSolution():\n    print('Objective:', objective_var.Value(),\\\n        'check:', sum(loss[load_vars[s].Min()] for s in range(nb_slabs)))\n  solver.EndSearch()\n\n\nmain(parser.parse_args())\n```\n\n----------------------------------------\n\nTITLE: Implementing Pentominoes Solver using CP-SAT in Python\nDESCRIPTION: Complete implementation of a pentomino paving solver that models the problem as an exact set cover and uses the CP-SAT solver from OR-Tools. The code includes helper functions for piece orientation, constraint modeling, and solution visualization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/pentominoes_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\nfrom typing import Dict, List\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:16,log_search_progress:false,max_time_in_seconds:45\",\n    \"Sat solver parameters.\",\n)\n\n_PIECES = flags.define_string(\n    \"pieces\", \"FILNPTUVWXYZ\", \"The subset of pieces to consider.\"\n)\n\n_HEIGHT = flags.define_integer(\"height\", 5, \"The height of the box.\")\n\n\ndef is_one(mask: List[List[int]], x: int, y: int, orientation: int) -> bool:\n    \"\"\"Returns true if the oriented piece is 1 at position [i][j].\n\n    The 3 bits in orientation respectively mean: transposition, symmetry by\n    x axis, symmetry by y axis.\n\n    Args:\n      mask: The shape of the piece.\n      x: position.\n      y: position.\n      orientation: between 0 and 7.\n    \"\"\"\n    if orientation & 1:\n        tmp: int = x\n        x = y\n        y = tmp\n    if orientation & 2:\n        x = len(mask[0]) - 1 - x\n    if orientation & 4:\n        y = len(mask) - 1 - y\n    return mask[y][x] == 1\n\n\ndef get_height(mask: List[List[int]], orientation: int) -> int:\n    if orientation & 1:\n        return len(mask[0])\n    return len(mask)\n\n\ndef get_width(mask: List[List[int]], orientation: int) -> int:\n    if orientation & 1:\n        return len(mask)\n    return len(mask[0])\n\n\ndef orientation_is_redundant(mask: List[List[int]], orientation: int) -> bool:\n    \"\"\"Checks if the current rotated figure is the same as a previous rotation.\"\"\"\n    size_i: int = get_width(mask, orientation)\n    size_j: int = get_height(mask, orientation)\n    for o in range(orientation):\n        if size_i != get_width(mask, o):\n            continue\n        if size_j != get_height(mask, o):\n            continue\n\n        is_the_same: bool = True\n        for k in range(size_i):\n            if not is_the_same:\n                break\n            for l in range(size_j):\n                if not is_the_same:\n                    break\n                if is_one(mask, k, l, orientation) != is_one(mask, k, l, o):\n                    is_the_same = False\n        if is_the_same:\n            return True\n    return False\n\n\ndef generate_and_solve_problem(pieces: Dict[str, List[List[int]]]) -> None:\n    \"\"\"Solves the pentominoes problem.\"\"\"\n    box_height = _HEIGHT.value\n    box_width = 5 * len(pieces) // box_height\n    print(f\"Box has dimension {box_height} * {box_width}\")\n\n    model = cp_model.CpModel()\n    position_to_variables: List[List[List[cp_model.IntVar]]] = [\n        [[] for _ in range(box_width)] for _ in range(box_height)\n    ]\n\n    for name, mask in pieces.items():\n        all_position_variables = []\n        for orientation in range(8):\n            if orientation_is_redundant(mask, orientation):\n                continue\n            piece_width = get_width(mask, orientation)\n            piece_height = get_height(mask, orientation)\n            for i in range(box_width - piece_width + 1):\n                for j in range(box_height - piece_height + 1):\n                    v = model.new_bool_var(name)\n                    all_position_variables.append(v)\n                    for k in range(piece_width):\n                        for l in range(piece_height):\n                            if is_one(mask, k, l, orientation):\n                                position_to_variables[j + l][i + k].append(v)\n\n        # Only one combination is selected.\n        model.add_exactly_one(all_position_variables)\n\n    for one_column in position_to_variables:\n        for all_pieces_in_one_position in one_column:\n            model.add_exactly_one(all_pieces_in_one_position)\n\n    # Solve the model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n    status = solver.solve(model)\n\n    print(\n        f\"Problem {_PIECES.value} box {box_height}*{box_width} solved in\"\n        f\" {solver.wall_time}s with status {solver.status_name(status)}\"\n    )\n\n    # Print the solution.\n    if status == cp_model.OPTIMAL:\n        for y in range(box_height):\n            line = \"\"\n            for x in range(box_width):\n                for v in position_to_variables[y][x]:\n                    if solver.BooleanValue(v):\n                        line += v.name\n                        break\n            print(line)\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n\n    # Pieces are stored in a matrix. mask[height][width]\n    pieces: Dict[str, List[List[int]]] = {\n        \"F\": [[0, 1, 1], [1, 1, 0], [0, 1, 0]],\n        \"I\": [[1, 1, 1, 1, 1]],\n        \"L\": [[1, 1, 1, 1], [1, 0, 0, 0]],\n        \"N\": [[1, 1, 1, 0], [0, 0, 1, 1]],\n        \"P\": [[1, 1, 1], [1, 1, 0]],\n        \"T\": [[1, 1, 1], [0, 1, 0], [0, 1, 0]],\n        \"U\": [[1, 0, 1], [1, 1, 1]],\n        \"V\": [[1, 0, 0], [1, 0, 0], [1, 1, 1]],\n        \"W\": [[1, 0, 0], [1, 1, 0], [0, 1, 1]],\n        \"X\": [[0, 1, 0], [1, 1, 1], [0, 1, 0]],\n        \"Y\": [[1, 1, 1, 1], [0, 1, 0, 0]],\n        \"Z\": [[1, 1, 0], [0, 1, 0], [0, 1, 1]],\n    }\n    selected_pieces: Dict[str, List[List[int]]] = {}\n    for p in _PIECES.value:\n        if p not in pieces:\n            print(f\"Piece {p} not found in the list of pieces\")\n            return\n        selected_pieces[p] = pieces[p]\n    if (len(selected_pieces) * 5) % _HEIGHT.value != 0:\n        print(\n            f\"The height {_HEIGHT.value} does not divide the total area\"\n            f\" {5 * len(selected_pieces)}\"\n        )\n        return\n    if _HEIGHT.value < 3 or 5 * len(selected_pieces) // _HEIGHT.value < 3:\n        print(f\"The height {_HEIGHT.value} is not compatible with the pieces.\")\n        return\n\n    generate_and_solve_problem(selected_pieces)\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Max Flow with OR-Tools in Python\nDESCRIPTION: This Python code demonstrates how to solve a maximum flow problem using the OR-Tools library. It defines a network with nodes, arcs, and capacities, then uses the SimpleMaxFlow solver to find the maximum flow between a source and sink. The code then prints the optimal flow and flow/capacity for each arc.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/graph/simple_max_flow_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"import numpy as np\\n\\nfrom ortools.graph.python import max_flow\\n\\n\\ndef main():\\n    \\\"\\\"\\\"MaxFlow simple interface example.\\\"\\\"\\\"\\n    # Instantiate a SimpleMaxFlow solver.\\n    smf = max_flow.SimpleMaxFlow()\\n\\n    # Define three parallel arrays: start_nodes, end_nodes, and the capacities\\n    # between each pair. For instance, the arc from node 0 to node 1 has a\\n    # capacity of 20.\\n    start_nodes = np.array([0, 0, 0, 1, 1, 2, 2, 3, 3])\\n    end_nodes = np.array([1, 2, 3, 2, 4, 3, 4, 2, 4])\\n    capacities = np.array([20, 30, 10, 40, 30, 10, 20, 5, 20])\\n\\n    # Add arcs in bulk.\\n    #   note: we could have used add_arc_with_capacity(start, end, capacity)\\n    all_arcs = smf.add_arcs_with_capacity(start_nodes, end_nodes, capacities)\\n\\n    # Find the maximum flow between node 0 and node 4.\\n    status = smf.solve(0, 4)\\n\\n    if status != smf.OPTIMAL:\\n        print(\"There was an issue with the max flow input.\")\\n        print(f\"Status: {status}\")\\n        exit(1)\\n    print(\"Max flow:\", smf.optimal_flow())\\n    print(\"\")\\n    print(\" Arc    Flow / Capacity\")\\n    solution_flows = smf.flows(all_arcs)\\n    for arc, flow, capacity in zip(all_arcs, solution_flows, capacities):\\n        print(f\"{smf.tail(arc)} / {smf.head(arc)}   {flow:3}  / {capacity:3}\")\\n    print(\"Source side min-cut:\", smf.get_source_side_min_cut())\\n    print(\"Sink side min-cut:\", smf.get_sink_side_min_cut())\\n\\n\\nmain()\\n\"\n```\n\n----------------------------------------\n\nTITLE: Regular Constraint Implementation\nDESCRIPTION: Complete implementation of the regular constraint including transition matrix creation and main solver logic. Implements a DFA-based constraint that enforces a sequence pattern matching 0*1{3}0+1{2}0+1{1}0*.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular_table2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef regular(x, Q, S, d, q0, F):\n\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    for j in range(1, S + 1):\n      if i == 0:\n        d2.append((0, j, 0))\n      else:\n        d2.append((i, j, d[i - 1][j - 1]))\n\n  solver.Add(solver.TransitionConstraint(x, d2, q0, F))\n\ndef make_transition_matrix(pattern):\n\n  p_len = len(pattern)\n  print('p_len:', p_len)\n  num_states = p_len + sum(pattern)\n  print('num_states:', num_states)\n  t_matrix = []\n  for i in range(num_states):\n    row = []\n    for j in range(2):\n      row.append(0)\n    t_matrix.append(row)\n\n  tmp = [0 for i in range(num_states)]\n  c = 0\n  tmp[c] = 0\n  for i in range(p_len):\n    for j in range(pattern[i]):\n      c += 1\n      tmp[c] = 1\n    if c < num_states - 1:\n      c += 1\n      tmp[c] = 0\n  print('tmp:', tmp)\n\n  t_matrix[num_states - 1][0] = num_states\n  t_matrix[num_states - 1][1] = 0\n\n  for i in range(num_states):\n    if tmp[i] == 0:\n      t_matrix[i][0] = i + 1\n      t_matrix[i][1] = i + 2\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          t_matrix[i][0] = 0\n          t_matrix[i][1] = i + 2\n        else:\n          t_matrix[i][0] = i + 2\n          t_matrix[i][1] = 0\n\n  print('The states:')\n  for i in range(num_states):\n    for j in range(2):\n      print(t_matrix[i][j], end=' ')\n    print()\n  print()\n\n  return t_matrix\n\ndef main():\n\n  solver = pywrapcp.Solver('Regular test')\n\n  this_len = 10\n  pp = [3, 2, 1]\n\n  transition_fn = make_transition_matrix(pp)\n  n_states = len(transition_fn)\n  input_max = 2\n\n  initial_state = 1\n\n  accepting_states = [n_states]\n\n  reg_input = [\n      solver.IntVar(1, input_max, 'reg_input[%i]' % i) for i in range(this_len)\n  ]\n\n  regular(reg_input, n_states, input_max, transition_fn, initial_state,\n          accepting_states)\n\n  db = solver.Phase(reg_input, solver.CHOOSE_MIN_SIZE_HIGHEST_MAX,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print('reg_input:', [reg_input[i].Value() - 1 for i in range(this_len)])\n    num_solutions += 1\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Bin Packing Problem using MIP Solver\nDESCRIPTION: This snippet sets up and solves the bin packing problem using the OR-Tools MIP solver. Variables for item and bin allocations are defined, constraints are established based on items and bins, and the model aims to minimize the number of bins used. The results are printed if an optimal solution is found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/bin_packing_mb.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    items, bins = create_data_model()\n\n    # Create the model.\n    model = model_builder.Model()\n\n    # Variables\n    # x[i, j] = 1 if item i is packed in bin j.\n    items_x_bins = pd.MultiIndex.from_product(\n        [items.index, bins.index], names=[\"item\", \"bin\"]\n    )\n    x = model.new_bool_var_series(name=\"x\", index=items_x_bins)\n\n    # y[j] = 1 if bin j is used.\n    y = model.new_bool_var_series(name=\"y\", index=bins.index)\n\n    # Constraints\n    # Each item must be in exactly one bin.\n    for unused_name, all_copies in x.groupby(\"item\"):\n        model.add(x[all_copies.index].sum() == 1)\n\n    # The amount packed in each bin cannot exceed its capacity.\n    for selected_bin in bins.index:\n        items_in_bin = x.xs(selected_bin, level=\"bin\")\n        model.add(\n            items_in_bin.dot(items.weight)\n            <= bins.loc[selected_bin].capacity * y[selected_bin]\n        )\n\n    # Objective: minimize the number of bins used.\n    model.minimize(y.sum())\n\n    # Create the solver with the CP-SAT backend, and solve the model.\n    solver = model_builder.Solver(\"sat\")\n    if not solver.solver_is_supported():\n        return\n    status = solver.solve(model)\n\n    if status == model_builder.SolveStatus.OPTIMAL:\n        print(f\"Number of bins used = {solver.objective_value}\")\n\n        x_values = solver.values(x)\n        y_values = solver.values(y)\n        active_bins = y_values.loc[lambda x: x == 1].index\n\n        for b in active_bins:\n            print(f\"Bin {b}\")\n            items_in_bin = x_values.xs(b, level=\"bin\").loc[lambda x: x == 1].index\n            for item in items_in_bin:\n                print(f\"  Item {item} - weight {items.loc[item].weight}\")\n            print(f\"  Packed items weight: {items.loc[items_in_bin].sum().to_string()}\")\n            print()\n\n        print(f\"Total packed weight: {items.weight.sum()}\")\n        print()\n        print(f\"Time = {solver.wall_time} seconds\")\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Circuit Constraint in OR-Tools\nDESCRIPTION: This function implements the circuit constraint using OR-Tools. It creates variables and constraints to ensure the solution forms a valid circuit.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/circuit.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef circuit(solver, x):\n  n = len(x)\n  z = [solver.IntVar(0, n - 1, \"z%i\" % i) for i in range(n)]\n\n  solver.Add(solver.AllDifferent(x))\n  solver.Add(solver.AllDifferent(z))\n\n  # put the orbit of x[0] in in z[0..n-1]\n  solver.Add(z[0] == x[0])\n  for i in range(1, n - 1):\n    # The following constraint give the error\n    # \"TypeError: list indices must be integers, not IntVar\"\n    # solver.Add(z[i] == x[z[i-1]])\n\n    # solution: use Element instead\n    solver.Add(z[i] == solver.Element(x, z[i - 1]))\n\n  #\n  # Note: At least one of the following two constraint must be set.\n  #\n  # may not be 0 for i < n-1\n  for i in range(1, n - 1):\n    solver.Add(z[i] != 0)\n\n  # when i = n-1 it must be 0\n  solver.Add(z[n - 1] == 0)\n```\n\n----------------------------------------\n\nTITLE: Implementing Sudoku Solver with CP-SAT\nDESCRIPTION: Defines a function to solve a Sudoku puzzle using constraint programming. The code creates variables for each cell, adds constraints for rows, columns, and 3x3 subgrids to ensure each contains numbers 1-9 without repetition, and solves with the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/sudoku_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef solve_sudoku() -> None:\n    \"\"\"Solves the sudoku problem with the CP-SAT solver.\"\"\"\n    # Create the model.\n    model = cp_model.CpModel()\n\n    cell_size = 3\n    line_size = cell_size**2\n    line = list(range(0, line_size))\n    cell = list(range(0, cell_size))\n\n    initial_grid = [\n        [0, 6, 0, 0, 5, 0, 0, 2, 0],\n        [0, 0, 0, 3, 0, 0, 0, 9, 0],\n        [7, 0, 0, 6, 0, 0, 0, 1, 0],\n        [0, 0, 6, 0, 3, 0, 4, 0, 0],\n        [0, 0, 4, 0, 7, 0, 1, 0, 0],\n        [0, 0, 5, 0, 9, 0, 8, 0, 0],\n        [0, 4, 0, 0, 0, 1, 0, 0, 6],\n        [0, 3, 0, 0, 0, 8, 0, 0, 0],\n        [0, 2, 0, 0, 4, 0, 0, 5, 0],\n    ]\n\n    grid = {}\n    for i in line:\n        for j in line:\n            grid[(i, j)] = model.new_int_var(1, line_size, \"grid %i %i\" % (i, j))\n\n    # AllDifferent on rows.\n    for i in line:\n        model.add_all_different(grid[(i, j)] for j in line)\n\n    # AllDifferent on columns.\n    for j in line:\n        model.add_all_different(grid[(i, j)] for i in line)\n\n    # AllDifferent on cells.\n    for i in cell:\n        for j in cell:\n            one_cell = []\n            for di in cell:\n                for dj in cell:\n                    one_cell.append(grid[(i * cell_size + di, j * cell_size + dj)])\n\n            model.add_all_different(one_cell)\n\n    # Initial values.\n    for i in line:\n        for j in line:\n            if initial_grid[i][j]:\n                model.add(grid[(i, j)] == initial_grid[i][j])\n\n    # Solves and prints out the solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n    if status == cp_model.OPTIMAL:\n        for i in line:\n            print([int(solver.value(grid[(i, j)])) for j in line])\n\n\nsolve_sudoku()\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing in Python\nDESCRIPTION: Python implementation of a vehicle routing problem using OR-Tools. Shows how to create a routing model, define distance callbacks, and solve a basic routing scenario with configurable parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/ROUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Vehicle Routing example.\"\"\"\n\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    num_locations = 5\n    num_vehicles = 1\n    depot = 0\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(num_locations, num_vehicles, depot)\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the absolute difference between the two nodes.\"\"\"\n        # Convert from routing variable Index to user NodeIndex.\n        from_node = int(manager.IndexToNode(from_index))\n        to_node = int(manager.IndexToNode(to_index))\n        return abs(to_node - from_node)\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )  # pylint: disable=no-member\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    index = routing.Start(0)\n    plan_output = \"Route for vehicle 0:\\n\"\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += f\"{manager.IndexToNode(index)} -> \"\n        previous_index = index\n        index = assignment.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += f\"{manager.IndexToNode(index)}\\n\"\n    plan_output += f\"Distance of the route: {route_distance}m\\n\"\n    print(plan_output)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Reallocating production using CP-SAT with OR-Tools in Python\nDESCRIPTION: This script defines a constraint programming model to reallocate production from different projects across multiple years, aiming to minimize the difference between the yearly production and the average production. It uses the `ortools.sat.python` module to define variables, add constraints, and solve the model. The script takes production data as input and outputs the reallocated production schedule, the total production, average production, the number of projects, and the number of years.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/reallocate_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"import collections\\n\\nfrom ortools.sat.python import cp_model\\n\\n\\ndef main():\\n    # Data\\n    data_0 = [\\n        [107, 107, 107, 0, 0],  # pr1\\n        [0, 47, 47, 47, 0],  # pr2\\n        [10, 10, 10, 0, 0],  # pr3\\n        [0, 55, 55, 55, 55],  # pr4\\n    ]\\n\\n    data_1 = [\\n        [119444030, 0, 0, 0],\\n        [34585586, 38358559, 31860661, 0],\\n        [19654655, 21798799, 18106106, 0],\\n        [298836792, 0, 0, 0],\\n        [3713428, 4118530, 4107277, 3072018],\\n        [6477273, 7183884, 5358471, 0],\\n        [1485371, 1647412, 1642911, 1228807],\\n    ]\\n\\n    data_2 = [\\n        [1194440, 0, 0, 0],\\n        [345855, 383585, 318606, 0],\\n        [196546, 217987, 181061, 0],\\n        [2988367, 0, 0, 0],\\n        [37134, 41185, 41072, 30720],\\n        [64772, 71838, 53584, 0],\\n        [14853, 16474, 16429, 12288],\\n    ]\\n\\n    pr = data_0\\n\\n    num_pr = len(pr)\\n    num_years = len(pr[1])\\n    total = sum(pr[p][y] for p in range(num_pr) for y in range(num_years))\\n    avg = total // num_years\\n\\n    # Model\\n    model = cp_model.CpModel()\\n\\n    # Variables\\n    delta = model.NewIntVar(0, total, \\\"delta\\\")\\n\\n    contributions_per_years = collections.defaultdict(list)\\n    contributions_per_prs = collections.defaultdict(list)\\n    all_contribs = {}\\n\\n    for p, inner_l in enumerate(pr):\\n        for y, item in enumerate(inner_l):\\n            if item != 0:\\n                contrib = model.NewIntVar(0, total, \\\"r%d c%d\\\" % (p, y))\\n                contributions_per_years[y].append(contrib)\\n                contributions_per_prs[p].append(contrib)\\n                all_contribs[p, y] = contrib\\n\\n    year_var = [model.NewIntVar(0, total, \\\"y[%i]\\\" % i) for i in range(num_years)]\\n\\n    # Constraints\\n\\n    # Maintain year_var.\\n    for y in range(num_years):\\n        model.Add(year_var[y] == sum(contributions_per_years[y]))\\n\\n    # Fixed contributions per pr.\\n    for p in range(num_pr):\\n        model.Add(sum(pr[p]) == sum(contributions_per_prs[p]))\\n\\n    # Link delta with variables.\\n    for y in range(num_years):\\n        model.Add(year_var[y] >= avg - delta)\\n\\n    for y in range(num_years):\\n        model.Add(year_var[y] <= avg + delta)\\n\\n    # Solve and output\\n    model.Minimize(delta)\\n\\n    # Solve model.\\n    solver = cp_model.CpSolver()\\n    status = solver.Solve(model)\\n\\n    # Output solution.\\n    if status == cp_model.OPTIMAL:\\n        print(\\\"Data\\\")\\n        print(\\\"  - total = \\\", total)\\n        print(\\\"  - year_average = \\\", avg)\\n        print(\\\"  - number of projects = \\\", num_pr)\\n        print(\\\"  - number of years = \\\", num_years)\\n\\n        print(\\\"  - input production\\\")\\n        for p in range(num_pr):\\n            for y in range(num_years):\\n                if pr[p][y] == 0:\\n                    print(\\\"        \\\", end=\\\"\")\\n                else:\\n                    print(\\\"%10i\\\" % pr[p][y], end=\\\"\")\\n            print()\\n\\n        print(\\\"Solution\\\")\\n        for p in range(num_pr):\\n            for y in range(num_years):\\n                if pr[p][y] == 0:\\n                    print(\\\"        \\\", end=\\\"\")\\n                else:\\n                    print(\\\"%10i\\\" % solver.Value(all_contribs[p, y]), end=\\\"\")\\n            print()\\n\\n        for y in range(num_years):\\n            print(\\\"%10i\\\" % solver.Value(year_var[y]), end=\\\"\")\\n        print()\\n\\n\\nmain()\\n\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Step Function with OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This code snippet defines a step function using the CP-SAT solver. It creates a model with a primary variable 'x' and an expression variable 'expr'. The step function is implemented using boolean variables and linear expressions to define different intervals for the function output.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/step_function_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef step_function_sample_sat():\n    \"\"\"Encode the step function.\"\"\"\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Declare our primary variable.\n    x = model.new_int_var(0, 20, \"x\")\n\n    # Create the expression variable and implement the step function\n    # Note it is not defined for x == 2.\n    #\n    #        -               3\n    # -- --      ---------   2\n    #                        1\n    #      -- ---            0\n    # 0 ================ 20\n    #\n    expr = model.new_int_var(0, 3, \"expr\")\n\n    # expr == 0 on [5, 6] U [8, 10]\n    b0 = model.new_bool_var(\"b0\")\n    model.add_linear_expression_in_domain(\n        x, cp_model.Domain.from_intervals([(5, 6), (8, 10)])\n    ).only_enforce_if(b0)\n    model.add(expr == 0).only_enforce_if(b0)\n\n    # expr == 2 on [0, 1] U [3, 4] U [11, 20]\n    b2 = model.new_bool_var(\"b2\")\n    model.add_linear_expression_in_domain(\n        x, cp_model.Domain.from_intervals([(0, 1), (3, 4), (11, 20)])\n    ).only_enforce_if(b2)\n    model.add(expr == 2).only_enforce_if(b2)\n\n    # expr == 3 when x == 7\n    b3 = model.new_bool_var(\"b3\")\n    model.add(x == 7).only_enforce_if(b3)\n    model.add(expr == 3).only_enforce_if(b3)\n\n    # At least one bi is true. (we could use an exactly one constraint).\n    model.add_bool_or(b0, b2, b3)\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy([x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE)\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([x, expr])\n    solver.solve(model, solution_printer)\n\nstep_function_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple SAT Program with OR-Tools in Python\nDESCRIPTION: This function demonstrates a minimal CP-SAT example using OR-Tools. It creates a model with three integer variables, adds a constraint, and solves the model. The solution, if found, is then printed.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/simple_sat_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef simple_sat_program():\n    \"\"\"Minimal CP-SAT example to showcase calling the solver.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    # Creates a solver and solves the model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"x = {solver.value(x)}\")\n        print(f\"y = {solver.value(y)}\")\n        print(f\"z = {solver.value(z)}\")\n    else:\n        print(\"No solution found.\")\n\n\nsimple_sat_program()\n```\n\n----------------------------------------\n\nTITLE: Solving a Logic Puzzle with OR-Tools Constraint Programming\nDESCRIPTION: Complete implementation that solves 'A Round of Golf' logic puzzle using constraint programming. The code defines variables for names, jobs, and scores, sets up constraints based on given clues, and searches for a solution that satisfies all constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/a_round_of_golf.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"All interval\")\n\n  #\n  # data\n  #\n  n = 4\n  [Jack, Bill, Paul, Frank] = [i for i in range(n)]\n\n  #\n  # declare variables\n  #\n  last_name = [solver.IntVar(0, n - 1, \"last_name[%i]\" % i) for i in range(n)]\n  [Green, Clubb, Sands, Carter] = last_name\n\n  job = [solver.IntVar(0, n - 1, \"job[%i]\" % i) for i in range(n)]\n  [cook, maintenance_man, clerk, caddy] = job\n\n  score = [solver.IntVar(70, 85, \"score[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(last_name))\n  solver.Add(solver.AllDifferent(job))\n  solver.Add(solver.AllDifferent(score))\n\n  # 1. Bill, who is not the maintenance man, plays golf often and had\n  #    the lowest score of the foursome.\n  solver.Add(Bill != maintenance_man)\n  solver.Add(score[Bill] < score[Jack])\n  solver.Add(score[Bill] < score[Paul])\n  solver.Add(score[Bill] < score[Frank])\n\n  # 2. Mr. Clubb, who isn't Paul, hit several balls into the woods and\n  #    scored ten strokes more than the pro-shop clerk.\n  solver.Add(Clubb != Paul)\n  solver.Add(solver.Element(score, Clubb) == solver.Element(score, clerk) + 10)\n\n  # 3. In some order, Frank and the caddy scored four and seven more\n  #    strokes than Mr. Sands.\n  solver.Add(Frank != caddy)\n  solver.Add(Frank != Sands)\n  solver.Add(caddy != Sands)\n\n  b3_a_1 = solver.IsEqualVar(solver.Element(score, Sands) + 4, score[Frank])\n  b3_a_2 = solver.IsEqualVar(\n      solver.Element(score, caddy),\n      solver.Element(score, Sands) + 7)\n\n  b3_b_1 = solver.IsEqualVar(solver.Element(score, Sands) + 7, score[Frank])\n  b3_b_2 = solver.IsEqualVar(\n      solver.Element(score, caddy),\n      solver.Element(score, Sands) + 4)\n\n  solver.Add((b3_a_1 * b3_a_2) + (b3_b_1 * b3_b_2) == 1)\n\n  # 4. Mr. Carter thought his score of 78 was one of his better games,\n  #    even though Frank's score was lower.\n  solver.Add(Frank != Carter)\n  solver.Add(solver.Element(score, Carter) == 78)\n  solver.Add(score[Frank] < solver.Element(score, Carter))\n\n  # 5. None of the four scored exactly 81 strokes.\n  [solver.Add(score[i] != 81) for i in range(n)]\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(last_name)\n  solution.Add(job)\n  solution.Add(score)\n\n  db = solver.Phase(last_name + job + score, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"last_name:\", [last_name[i].Value() for i in range(n)])\n    print(\"job      :\", [job[i].Value() for i in range(n)])\n    print(\"score    :\", [score[i].Value() for i in range(n)])\n    num_solutions += 1\n    print()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Initializing Assignment Problem Model using OR-Tools\nDESCRIPTION: Complete implementation of a mixed integer programming model to solve a worker-task assignment problem with cost minimization. Uses pandas for data handling and model builder for constraint definition.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_mb.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport io\n\nimport pandas as pd\n\nfrom ortools.linear_solver.python import model_builder\n\n\ndef main():\n    # Data\n    data_str = \"\"\"\n  worker  task  cost\n      w1    t1    90\n      w1    t2    80\n      w1    t3    75\n      w1    t4    70\n      w2    t1    35\n      w2    t2    85\n      w2    t3    55\n      w2    t4    65\n      w3    t1   125\n      w3    t2    95\n      w3    t3    90\n      w3    t4    95\n      w4    t1    45\n      w4    t2   110\n      w4    t3    95\n      w4    t4   115\n      w5    t1    50\n      w5    t2   110\n      w5    t3    90\n      w5    t4   100\n  \"\"\"\n\n    data = pd.read_table(io.StringIO(data_str), sep=r\"\\s+\")\n\n    # Create the model.\n    model = model_builder.Model()\n\n    # Variables\n    # x[i, j] is an array of 0-1 variables, which will be 1\n    # if worker i is assigned to task j.\n    x = model.new_bool_var_series(name=\"x\", index=data.index)\n\n    # Constraints\n    # Each worker is assigned to at most 1 task.\n    for unused_name, tasks in data.groupby(\"worker\"):\n        model.add(x[tasks.index].sum() <= 1)\n\n    # Each task is assigned to exactly one worker.\n    for unused_name, workers in data.groupby(\"task\"):\n        model.add(x[workers.index].sum() == 1)\n\n    # Objective\n    model.minimize(data.cost.dot(x))\n\n    # Create the solver with the CP-SAT backend, and solve the model.\n    solver = model_builder.Solver(\"sat\")\n    if not solver.solver_is_supported():\n        return\n    status = solver.solve(model)\n\n    # Print solution.\n    if (\n        status == model_builder.SolveStatus.OPTIMAL\n        or status == model_builder.SolveStatus.FEASIBLE\n    ):\n        print(f\"Total cost = {solver.objective_value}\\n\")\n        selected = data.loc[solver.values(x).loc[lambda x: x == 1].index]\n        for unused_index, row in selected.iterrows():\n            print(f\"{row.task} assigned to {row.worker} with a cost of {row.cost}\")\n    else:\n        print(\"No solution found.\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Detecting Interval Overlap with Boolean Variables in OR-Tools CP-SAT\nDESCRIPTION: This code demonstrates how to detect if two intervals overlap using Boolean variables in OR-Tools CP-SAT solver. It creates three Boolean variables to represent the relative positions of two intervals and defines a third variable that indicates whether they overlap. The example includes a solution printer callback to display all possible states of the intervals.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrates how to detect if two intervals overlap.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef overlapping_interval_sample_sat():\n    \"\"\"Create the overlapping Boolean variables and enumerate all states.\"\"\"\n    model = cp_model.CpModel()\n\n    horizon = 7\n\n    # First interval.\n    start_var_a = model.new_int_var(0, horizon, \"start_a\")\n    duration_a = 3\n    end_var_a = model.new_int_var(0, horizon, \"end_a\")\n    unused_interval_var_a = model.new_interval_var(\n        start_var_a, duration_a, end_var_a, \"interval_a\"\n    )\n\n    # Second interval.\n    start_var_b = model.new_int_var(0, horizon, \"start_b\")\n    duration_b = 2\n    end_var_b = model.new_int_var(0, horizon, \"end_b\")\n    unused_interval_var_b = model.new_interval_var(\n        start_var_b, duration_b, end_var_b, \"interval_b\"\n    )\n\n    # a_after_b Boolean variable.\n    a_after_b = model.new_bool_var(\"a_after_b\")\n    model.add(start_var_a >= end_var_b).only_enforce_if(a_after_b)\n    model.add(start_var_a < end_var_b).only_enforce_if(~a_after_b)\n\n    # b_after_a Boolean variable.\n    b_after_a = model.new_bool_var(\"b_after_a\")\n    model.add(start_var_b >= end_var_a).only_enforce_if(b_after_a)\n    model.add(start_var_b < end_var_a).only_enforce_if(~b_after_a)\n\n    # Result Boolean variable.\n    a_overlaps_b = model.new_bool_var(\"a_overlaps_b\")\n\n    # Option a: using only clauses\n    model.add_bool_or(a_after_b, b_after_a, a_overlaps_b)\n    model.add_implication(a_after_b, ~a_overlaps_b)\n    model.add_implication(b_after_a, ~a_overlaps_b)\n\n    # Option b: using an exactly one constraint.\n    # model.add_exactly_one(a_after_b, b_after_a, a_overlaps_b)\n\n    # Search for start values in increasing order for the two intervals.\n    model.add_decision_strategy(\n        [start_var_a, start_var_b],\n        cp_model.CHOOSE_FIRST,\n        cp_model.SELECT_MIN_VALUE,\n    )\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([start_var_a, start_var_b, a_overlaps_b])\n    solver.solve(model, solution_printer)\n\n\noverlapping_interval_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: VRPTW Solution Implementation\nDESCRIPTION: Main implementation of the VRPTW solver using OR-Tools. Sets up routing model, adds time window constraints, and configures solution parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrptw_store_solution_data.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    data = create_data_model()\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"time_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    \n    def time_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"time_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(time_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    \n    time = \"Time\"\n    routing.AddDimension(\n        transit_callback_index,\n        30,  # allow waiting time\n        30,  # maximum time per vehicle\n        False,\n        time,\n    )\n    # ... continues with constraint setup and solution\n```\n\n----------------------------------------\n\nTITLE: Solving Multiple Knapsack with MIP in Python\nDESCRIPTION: This Python code defines and solves a multiple knapsack problem using the OR-Tools library. It sets up the problem data, creates a MIP solver, defines binary variables representing whether an item is placed in a bin, formulates constraints ensuring each item is assigned to at most one bin and that bin capacities are not exceeded, and sets the objective to maximize the total value of packed items. Finally, it prints the optimal solution or indicates if no solution was found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/multiple_knapsack_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.linear_solver import pywraplp\n\n\ndef main():\n    data = {}\n    data[\"weights\"] = [48, 30, 42, 36, 36, 48, 42, 42, 36, 24, 30, 30, 42, 36, 36]\n    data[\"values\"] = [10, 30, 25, 50, 35, 30, 15, 40, 30, 35, 45, 10, 20, 30, 25]\n    assert len(data[\"weights\"]) == len(data[\"values\"])\n    data[\"num_items\"] = len(data[\"weights\"])\n    data[\"all_items\"] = range(data[\"num_items\"])\n\n    data[\"bin_capacities\"] = [100, 100, 100, 100, 100]\n    data[\"num_bins\"] = len(data[\"bin_capacities\"])\n    data[\"all_bins\"] = range(data[\"num_bins\"])\n\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n    if solver is None:\n        print(\"SCIP solver unavailable.\")\n        return\n\n    # Variables.\n    # x[i, b] = 1 if item i is packed in bin b.\n    x = {}\n    for i in data[\"all_items\"]:\n        for b in data[\"all_bins\"]:\n            x[i, b] = solver.BoolVar(f\"x_{i}_{b}\")\n\n    # Constraints.\n    # Each item is assigned to at most one bin.\n    for i in data[\"all_items\"]:\n        solver.Add(sum(x[i, b] for b in data[\"all_bins\"]) <= 1)\n\n    # The amount packed in each bin cannot exceed its capacity.\n    for b in data[\"all_bins\"]:\n        solver.Add(\n            sum(x[i, b] * data[\"weights\"][i] for i in data[\"all_items\"])\n            <= data[\"bin_capacities\"][b]\n        )\n\n    # Objective.\n    # Maximize total value of packed items.\n    objective = solver.Objective()\n    for i in data[\"all_items\"]:\n        for b in data[\"all_bins\"]:\n            objective.SetCoefficient(x[i, b], data[\"values\"][i])\n    objective.SetMaximization()\n\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    if status == pywraplp.Solver.OPTIMAL:\n        print(f\"Total packed value: {objective.Value()}\")\n        total_weight = 0\n        for b in data[\"all_bins\"]:\n            print(f\"Bin {b}\")\n            bin_weight = 0\n            bin_value = 0\n            for i in data[\"all_items\"]:\n                if x[i, b].solution_value() > 0:\n                    print(\n                        f\"Item {i} weight: {data['weights'][i]} value:\"\n                        f\" {data['values'][i]}\"\n                    )\n                    bin_weight += data[\"weights\"][i]\n                    bin_value += data[\"values\"][i]\n            print(f\"Packed bin weight: {bin_weight}\")\n            print(f\"Packed bin value: {bin_value}\\n\")\n            total_weight += bin_weight\n        print(f\"Total packed weight: {total_weight}\")\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n\nmain()\n\"\n```\n\n----------------------------------------\n\nTITLE: SEND+MORE=MONEY Solver Implementation\nDESCRIPTION: Main implementation of the SEND+MORE=MONEY puzzle solver using OR-Tools. Sets up variables, constraints, and solving parameters. Handles arbitrary number bases and collects all possible solutions. Includes performance metrics output.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/send_more_money_any_base.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(base=10):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Send most money')\n\n  # data\n  print('base:', base)\n\n  # declare variables\n  s = solver.IntVar(0, base - 1, 's')\n  e = solver.IntVar(0, base - 1, 'e')\n  n = solver.IntVar(0, base - 1, 'n')\n  d = solver.IntVar(0, base - 1, 'd')\n  m = solver.IntVar(0, base - 1, 'm')\n  o = solver.IntVar(0, base - 1, 'o')\n  r = solver.IntVar(0, base - 1, 'r')\n  y = solver.IntVar(0, base - 1, 'y')\n\n  x = [s, e, n, d, m, o, r, y]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n  solver.Add(\n      s * base**3 + e * base**2 + n * base + d + m * base**3 + o * base**2 +\n      r * base + e == m * base**4 + o * base**3 + n * base**2 + e * base + y,)\n  solver.Add(s > 0)\n  solver.Add(m > 0)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n\n  collector = solver.AllSolutionCollector(solution)\n\n  solver.Solve(\n      solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MAX_VALUE),\n      [collector])\n\n  num_solutions = collector.SolutionCount()\n  money_val = 0\n  for s in range(num_solutions):\n    print('x:', [collector.Value(s, x[i]) for i in range(len(x))])\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime())\n  print()\n\n\nbase = 10\n# for base in range(10,30):\n#    main(base)\nif len(sys.argv) > 1:\n  base = int(sys.argv[1])\n\nmain(base)\n```\n\n----------------------------------------\n\nTITLE: Solving Cutting Stock Problem with CP-SAT in Python\nDESCRIPTION: Function that implements the cutting stock problem solver using the arc-flow formulation and CP-SAT solver. It creates a constraint model with variables representing transitions between states and optimizes to minimize waste.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef solve_cutting_stock_with_arc_flow_and_sat(output_proto_file: str, params: str):\n    \"\"\"Solve the cutting stock with arc-flow and the CP-SAT solver.\"\"\"\n    items = regroup_and_count(DESIRED_LENGTHS)\n    print(\"Items:\", items)\n    num_items = len(DESIRED_LENGTHS)\n\n    max_capacity = max(POSSIBLE_CAPACITIES)\n    states, transitions = create_state_graph(items, max_capacity)\n\n    print(\n        \"Dynamic programming has generated\",\n        len(states),\n        \"states and\",\n        len(transitions),\n        \"transitions\",\n    )\n\n    incoming_vars = collections.defaultdict(list)\n    outgoing_vars = collections.defaultdict(list)\n    incoming_sink_vars = []\n    item_vars = collections.defaultdict(list)\n    item_coeffs = collections.defaultdict(list)\n    transition_vars = []\n\n    model = cp_model.CpModel()\n\n    objective_vars = []\n    objective_coeffs = []\n\n    for outgoing, incoming, item_index, card in transitions:\n        count = items[item_index][1]\n        max_count = count // card\n        count_var = model.NewIntVar(\n            0, max_count, \"i%i_f%i_t%i_C%s\" % (item_index, incoming, outgoing, card)\n        )\n        incoming_vars[incoming].append(count_var)\n        outgoing_vars[outgoing].append(count_var)\n        item_vars[item_index].append(count_var)\n        item_coeffs[item_index].append(card)\n        transition_vars.append(count_var)\n\n    for state_index, state in enumerate(states):\n        if state_index == 0:\n            continue\n        exit_var = model.NewIntVar(0, num_items, \"e%i\" % state_index)\n        outgoing_vars[state_index].append(exit_var)\n        incoming_sink_vars.append(exit_var)\n        price = price_usage(state, POSSIBLE_CAPACITIES)\n        objective_vars.append(exit_var)\n        objective_coeffs.append(price)\n\n    # Flow conservation\n    for state_index in range(1, len(states)):\n        model.Add(sum(incoming_vars[state_index]) == sum(outgoing_vars[state_index]))\n\n    # Flow going out of the source must go in the sink\n    model.Add(sum(outgoing_vars[0]) == sum(incoming_sink_vars))\n\n    # Items must be placed\n    for item_index, size_and_count in enumerate(items):\n        num_arcs = len(item_vars[item_index])\n        model.Add(\n            sum(\n                item_vars[item_index][i] * item_coeffs[item_index][i]\n                for i in range(num_arcs)\n            )\n            == size_and_count[1]\n        )\n\n    # Objective is the sum of waste\n    model.Minimize(\n        sum(objective_vars[i] * objective_coeffs[i] for i in range(len(objective_vars)))\n    )\n\n    # Output model proto to file.\n    if output_proto_file:\n        model.ExportToFile(output_proto_file)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    if params:\n        text_format.Parse(params, solver.parameters)\n    solver.parameters.log_search_progress = True\n    solver.Solve(model)\n```\n\n----------------------------------------\n\nTITLE: Broken Weights Problem Solution Implementation\nDESCRIPTION: Main implementation of the Broken Weights problem solver using OR-Tools constraint programming. Creates a model that finds four pieces of weights that can measure any integer weight between 1 and 40 pounds using a balance scale. Includes variable creation, constraint definition, and solution search logic.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/broken_weights.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(m=40, n=4):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Broken weights')\n\n  #\n  # data\n  #\n  print('total weight (m):', m)\n  print('number of pieces (n):', n)\n  print()\n\n  #\n  # variables\n  #\n  weights = [solver.IntVar(1, m, 'weights[%i]' % j) for j in range(n)]\n  x = {}\n  for i in range(m):\n    for j in range(n):\n      x[i, j] = solver.IntVar(-1, 1, 'x[%i,%i]' % (i, j))\n  x_flat = [x[i, j] for i in range(m) for j in range(n)]\n\n  #\n  # constraints\n  #\n\n  # symmetry breaking\n  for j in range(1, n):\n    solver.Add(weights[j - 1] < weights[j])\n\n  solver.Add(solver.SumEquality(weights, m))\n\n  # Check that all weights from 1 to 40 can be made.\n  #\n  # Since all weights can be on either side\n  # of the side of the scale we allow either\n  # -1, 0, or 1 or the weights, assuming that\n  # -1 is the weights on the left and 1 is on the right.\n  #\n  for i in range(m):\n    solver.Add(i + 1 == solver.Sum([weights[j] * x[i, j] for j in range(n)]))\n\n  # objective\n  objective = solver.Minimize(weights[n - 1], 1)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(weights + x_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  search_log = solver.SearchLog(1)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('weights:   ', end=' ')\n    for w in [weights[j].Value() for j in range(n)]:\n      print('%3i ' % w, end=' ')\n    print()\n    print('-' * 30)\n    for i in range(m):\n      print('weight  %2i:' % (i + 1), end=' ')\n      for j in range(n):\n        print('%3i ' % x[i, j].Value(), end=' ')\n      print()\n    print()\n  print()\n  solver.EndSearch()\n\n  print('num_solutions:', num_solutions)\n  print('failures :', solver.Failures())\n  print('branches :', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nm = 40\nn = 4\nif len(sys.argv) > 1:\n  m = int(sys.argv[1])\nif len(sys.argv) > 2:\n  n = int(sys.argv[2])\nmain(m, n)\n```\n\n----------------------------------------\n\nTITLE: Solving Knapsack Problem with OR-Tools in Python\nDESCRIPTION: This code demonstrates how to use the KnapsackSolver from OR-Tools to solve a multidimensional knapsack problem. It sets up the problem with predefined values, weights, and capacities, solves it, and then prints the results including total value, weight, packed items, and their weights.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/algorithms/knapsack.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.algorithms.python import knapsack_solver\n\n\ndef main():\n    # Create the solver.\n    solver = knapsack_solver.KnapsackSolver(\n        knapsack_solver.SolverType.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,\n        \"KnapsackExample\",\n    )\n\n    values = [\n        # fmt:off\n      360, 83, 59, 130, 431, 67, 230, 52, 93, 125, 670, 892, 600, 38, 48, 147,\n      78, 256, 63, 17, 120, 164, 432, 35, 92, 110, 22, 42, 50, 323, 514, 28,\n      87, 73, 78, 15, 26, 78, 210, 36, 85, 189, 274, 43, 33, 10, 19, 389, 276,\n      312\n        # fmt:on\n    ]\n    weights = [\n        # fmt: off\n      [7, 0, 30, 22, 80, 94, 11, 81, 70, 64, 59, 18, 0, 36, 3, 8, 15, 42, 9, 0,\n       42, 47, 52, 32, 26, 48, 55, 6, 29, 84, 2, 4, 18, 56, 7, 29, 93, 44, 71,\n       3, 86, 66, 31, 65, 0, 79, 20, 65, 52, 13],\n        # fmt: on\n    ]\n    capacities = [850]\n\n    solver.init(values, weights, capacities)\n    computed_value = solver.solve()\n\n    packed_items = []\n    packed_weights = []\n    total_weight = 0\n    print(\"Total value =\", computed_value)\n    for i in range(len(values)):\n        if solver.best_solution_contains(i):\n            packed_items.append(i)\n            packed_weights.append(weights[0][i])\n            total_weight += weights[0][i]\n    print(\"Total weight:\", total_weight)\n    print(\"Packed items:\", packed_items)\n    print(\"Packed_weights:\", packed_weights)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing CP-SAT Solver in Python\nDESCRIPTION: Demonstrates using CP-SAT solver in Python using CpModel and CpSolver classes. Creates three integer variables with constraints and solves for feasible or optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/README.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Simple solve.\"\"\"\nfrom ortools.sat.python import cp_model\n\n\ndef simple_sat_program():\n    \"\"\"Minimal CP-SAT example to showcase calling the solver.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    # Creates a solver and solves the model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"x = {solver.value(x)}\")\n        print(f\"y = {solver.value(y)}\")\n        print(f\"z = {solver.value(z)}\")\n    else:\n        print(\"No solution found.\")\n\n\nsimple_sat_program()\n```\n\n----------------------------------------\n\nTITLE: Implementing Wedding Chart Solver with CP-SAT\nDESCRIPTION: Full implementation of a wedding seating chart optimizer using Google OR-Tools CP-SAT solver. The code defines a solution printer, builds the data model with guest connections, and creates the constraint optimization model that maximizes relationship strength while ensuring seating constraints are met.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/wedding_optimal_chart_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport time\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\nclass WeddingChartPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, seats, names, num_tables, num_guests):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n        self.__start_time = time.time()\n        self.__seats = seats\n        self.__names = names\n        self.__num_tables = num_tables\n        self.__num_guests = num_guests\n\n    def on_solution_callback(self):\n        current_time = time.time()\n        objective = self.objective_value\n        print(\n            \"Solution %i, time = %f s, objective = %i\"\n            % (self.__solution_count, current_time - self.__start_time, objective)\n        )\n        self.__solution_count += 1\n\n        for t in range(self.__num_tables):\n            print(\"Table %d: \" % t)\n            for g in range(self.__num_guests):\n                if self.value(self.__seats[(t, g)]):\n                    print(\"  \" + self.__names[g])\n\n    def num_solutions(self) -> int:\n        return self.__solution_count\n\n\ndef build_data():\n    \"\"\"Build the data model.\"\"\"\n    # Easy problem (from the paper)\n    # num_tables = 2\n    # table_capacity = 10\n    # min_known_neighbors = 1\n\n    # Slightly harder problem (also from the paper)\n    num_tables = 5\n    table_capacity = 4\n    min_known_neighbors = 1\n\n    # Connection matrix: who knows who, and how strong\n    # is the relation\n    connections = [\n        [1, 50, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [50, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 1, 50, 1, 1, 1, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 50, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1, 50, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 50, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1, 1, 1, 50, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1, 1, 50, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 50, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 1, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n    ]\n\n    # Names of the guests. B: Bride side, G: Groom side\n    names = [\n        \"Deb (B)\",\n        \"John (B)\",\n        \"Martha (B)\",\n        \"Travis (B)\",\n        \"Allan (B)\",\n        \"Lois (B)\",\n        \"Jayne (B)\",\n        \"Brad (B)\",\n        \"Abby (B)\",\n        \"Mary Helen (G)\",\n        \"Lee (G)\",\n        \"Annika (G)\",\n        \"Carl (G)\",\n        \"Colin (G)\",\n        \"Shirley (G)\",\n        \"DeAnn (G)\",\n        \"Lori (G)\",\n    ]\n    return num_tables, table_capacity, min_known_neighbors, connections, names\n\n\ndef solve_with_discrete_model() -> None:\n    \"\"\"Discrete approach.\"\"\"\n    num_tables, table_capacity, min_known_neighbors, connections, names = build_data()\n\n    num_guests = len(connections)\n\n    all_tables = range(num_tables)\n    all_guests = range(num_guests)\n\n    # Create the cp model.\n    model = cp_model.CpModel()\n\n    #\n    # Decision variables\n    #\n    seats = {}\n    for t in all_tables:\n        for g in all_guests:\n            seats[(t, g)] = model.new_bool_var(\"guest %i seats on table %i\" % (g, t))\n\n    colocated = {}\n    for g1 in range(num_guests - 1):\n        for g2 in range(g1 + 1, num_guests):\n            colocated[(g1, g2)] = model.new_bool_var(\n                \"guest %i seats with guest %i\" % (g1, g2)\n            )\n\n    same_table = {}\n    for g1 in range(num_guests - 1):\n        for g2 in range(g1 + 1, num_guests):\n            for t in all_tables:\n                same_table[(g1, g2, t)] = model.new_bool_var(\n                    \"guest %i seats with guest %i on table %i\" % (g1, g2, t)\n                )\n\n    # Objective\n    model.maximize(\n        sum(\n            connections[g1][g2] * colocated[g1, g2]\n            for g1 in range(num_guests - 1)\n            for g2 in range(g1 + 1, num_guests)\n            if connections[g1][g2] > 0\n        )\n    )\n\n    #\n    # Constraints\n    #\n\n    # Everybody seats at one table.\n    for g in all_guests:\n        model.add(sum(seats[(t, g)] for t in all_tables) == 1)\n\n    # Tables have a max capacity.\n    for t in all_tables:\n        model.add(sum(seats[(t, g)] for g in all_guests) <= table_capacity)\n\n    # Link colocated with seats\n    for g1 in range(num_guests - 1):\n        for g2 in range(g1 + 1, num_guests):\n            for t in all_tables:\n                # Link same_table and seats.\n                model.add_bool_or(\n                    [\n                        ~seats[(t, g1)],\n                        ~seats[(t, g2)],\n                        same_table[(g1, g2, t)],\n                    ]\n                )\n                model.add_implication(same_table[(g1, g2, t)], seats[(t, g1)])\n                model.add_implication(same_table[(g1, g2, t)], seats[(t, g2)])\n\n            # Link colocated and same_table.\n            model.add(\n                sum(same_table[(g1, g2, t)] for t in all_tables) == colocated[(g1, g2)]\n            )\n\n    # Min known neighbors rule.\n    for g in all_guests:\n        model.add(\n            sum(\n                same_table[(g, g2, t)]\n                for g2 in range(g + 1, num_guests)\n                for t in all_tables\n                if connections[g][g2] > 0\n            )\n            + sum(\n                same_table[(g1, g, t)]\n                for g1 in range(g)\n                for t in all_tables\n                if connections[g1][g] > 0\n            )\n            >= min_known_neighbors\n        )\n\n    # Symmetry breaking. First guest seats on the first table.\n    model.add(seats[(0, 0)] == 1)\n\n    ### Solve model.\n    solver = cp_model.CpSolver()\n    solution_printer = WeddingChartPrinter(seats, names, num_tables, num_guests)\n    solver.solve(model, solution_printer)\n\n    print(\"Statistics\")\n    print(\"  - conflicts    : %i\" % solver.num_conflicts)\n    print(\"  - branches     : %i\" % solver.num_branches)\n    print(\"  - wall time    : %f s\" % solver.wall_time)\n    print(\"  - num solutions: %i\" % solution_printer.num_solutions())\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    solve_with_discrete_model()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Nurse Scheduling with OR-Tools in Python\nDESCRIPTION: This Python code defines a constraint programming model for a nurse scheduling problem using Google's OR-Tools. It sets up variables for shifts, defines constraints to ensure each shift is covered and each nurse's workloads are balanced, and solves the model to display solutions. The model uses `CpModel` and `CpSolver`. Inputs include the number of nurses, shifts, and days, while outputs consist of potential scheduling solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/nurses_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef main() -> None:\n    # Data.\n    num_nurses = 4\n    num_shifts = 3\n    num_days = 3\n    all_nurses = range(num_nurses)\n    all_shifts = range(num_shifts)\n    all_days = range(num_days)\n\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates shift variables.\n    # shifts[(n, d, s)]: nurse 'n' works shift 's' on day 'd'.\n    shifts = {}\n    for n in all_nurses:\n        for d in all_days:\n            for s in all_shifts:\n                shifts[(n, d, s)] = model.new_bool_var(f\"shift_n{n}_d{d}_s{s}\")\n\n    # Each shift is assigned to exactly one nurse in the schedule period.\n    for d in all_days:\n        for s in all_shifts:\n            model.add_exactly_one(shifts[(n, d, s)] for n in all_nurses)\n\n    # Each nurse works at most one shift per day.\n    for n in all_nurses:\n        for d in all_days:\n            model.add_at_most_one(shifts[(n, d, s)] for s in all_shifts)\n\n    # Try to distribute the shifts evenly, so that each nurse works\n    # min_shifts_per_nurse shifts. If this is not possible, because the total\n    # number of shifts is not divisible by the number of nurses, some nurses will\n    # be assigned one more shift.\n    min_shifts_per_nurse = (num_shifts * num_days) // num_nurses\n    if num_shifts * num_days % num_nurses == 0:\n        max_shifts_per_nurse = min_shifts_per_nurse\n    else:\n        max_shifts_per_nurse = min_shifts_per_nurse + 1\n    for n in all_nurses:\n        shifts_worked = []\n        for d in all_days:\n            for s in all_shifts:\n                shifts_worked.append(shifts[(n, d, s)])\n        model.add(min_shifts_per_nurse <= sum(shifts_worked))\n        model.add(sum(shifts_worked) <= max_shifts_per_nurse)\n\n    # Creates the solver and solve.\n    solver = cp_model.CpSolver()\n    solver.parameters.linearization_level = 0\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    class NursesPartialSolutionPrinter(cp_model.CpSolverSolutionCallback):\n        \"\"\"Print intermediate solutions.\"\"\"\n\n        def __init__(self, shifts, num_nurses, num_days, num_shifts, limit):\n            cp_model.CpSolverSolutionCallback.__init__(self)\n            self._shifts = shifts\n            self._num_nurses = num_nurses\n            self._num_days = num_days\n            self._num_shifts = num_shifts\n            self._solution_count = 0\n            self._solution_limit = limit\n\n        def on_solution_callback(self):\n            self._solution_count += 1\n            print(f\"Solution {self._solution_count}\")\n            for d in range(self._num_days):\n                print(f\"Day {d}\")\n                for n in range(self._num_nurses):\n                    is_working = False\n                    for s in range(self._num_shifts):\n                        if self.value(self._shifts[(n, d, s)]):\n                            is_working = True\n                            print(f\"  Nurse {n} works shift {s}\")\n                    if not is_working:\n                        print(f\"  Nurse {n} does not work\")\n            if self._solution_count >= self._solution_limit:\n                print(f\"Stop search after {self._solution_limit} solutions\")\n                self.stop_search()\n\n        def solutionCount(self):\n            return self._solution_count\n\n    # Display the first five solutions.\n    solution_limit = 5\n    solution_printer = NursesPartialSolutionPrinter(\n        shifts, num_nurses, num_days, num_shifts, solution_limit\n    )\n\n    solver.solve(model, solution_printer)\n\n    # Statistics.\n    print(\"\\nStatistics\")\n    print(f\"  - conflicts      : {solver.num_conflicts}\")\n    print(f\"  - branches       : {solver.num_branches}\")\n    print(f\"  - wall time      : {solver.wall_time} s\")\n    print(f\"  - solutions found: {solution_printer.solutionCount()}\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: TSP Solution Implementation with OR-Tools\nDESCRIPTION: Complete implementation of a Traveling Salesman Problem solver using OR-Tools. Includes data model creation, distance callback implementation, and solution computation. Uses manhattan distance for cost calculation and PATH_CHEAPEST_ARC as the first solution strategy.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    # Locations in block units\n    locations = [\n        # fmt:off\n      (4, 4),  # depot\n      (2, 0), (8, 0),  # locations to visit\n      (0, 1), (1, 1),\n      (5, 2), (7, 2),\n      (3, 3), (6, 3),\n      (5, 5), (8, 5),\n      (1, 6), (2, 6),\n      (3, 7), (6, 7),\n      (0, 8), (7, 8)\n        # fmt:on\n    ]\n    # Convert locations in meters using a city block dimension of 114m x 80m.\n    data[\"locations\"] = [(l[0] * 114, l[1] * 80) for l in locations]\n    data[\"num_vehicles\"] = 1\n    data[\"depot\"] = 0\n    return data\n\n\ndef create_distance_callback(data, manager):\n    \"\"\"Creates callback to return distance between points.\"\"\"\n    distances_ = {}\n    index_manager_ = manager\n    # precompute distance between location to have distance callback in O(1)\n    for from_counter, from_node in enumerate(data[\"locations\"]):\n        distances_[from_counter] = {}\n        for to_counter, to_node in enumerate(data[\"locations\"]):\n            if from_counter == to_counter:\n                distances_[from_counter][to_counter] = 0\n            else:\n                distances_[from_counter][to_counter] = abs(\n                    from_node[0] - to_node[0]\n                ) + abs(from_node[1] - to_node[1])\n\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the manhattan distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = index_manager_.IndexToNode(from_index)\n        to_node = index_manager_.IndexToNode(to_index)\n        return distances_[from_node][to_node]\n\n    return distance_callback\n\n\ndef print_solution(manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    index = routing.Start(0)\n    plan_output = \"Route for vehicle 0:\\n\"\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += f\" {manager.IndexToNode(index)} ->\"\n        previous_index = index\n        index = assignment.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += f\" {manager.IndexToNode(index)}\\n\"\n    plan_output += f\"Distance of the route: {route_distance}m\\n\"\n    print(plan_output)\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"locations\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    distance_callback = create_distance_callback(data, manager)\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(manager, routing, assignment)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing Problem with Pickup and Delivery (FIFO)\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem with Pickup and Delivery constraints using a FIFO policy. The code creates a data model, sets up routing constraints including pickup-delivery pairs, and solves the problem using OR-Tools constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_pickup_delivery_fifo.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"pickups_deliveries\"] = [\n        [1, 6],\n        [2, 10],\n        [4, 3],\n        [5, 9],\n        [7, 8],\n        [15, 11],\n        [13, 12],\n        [16, 14],\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    total_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        total_distance += route_distance\n    print(f\"Total Distance of all routes: {total_distance}m\")\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Define cost of each arc.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the manhattan distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Define Transportation Requests.\n    for request in data[\"pickups_deliveries\"]:\n        pickup_index = manager.NodeToIndex(request[0])\n        delivery_index = manager.NodeToIndex(request[1])\n        routing.AddPickupAndDelivery(pickup_index, delivery_index)\n        routing.solver().Add(\n            routing.VehicleVar(pickup_index) == routing.VehicleVar(delivery_index)\n        )\n        routing.solver().Add(\n            distance_dimension.CumulVar(pickup_index)\n            <= distance_dimension.CumulVar(delivery_index)\n        )\n    routing.SetPickupAndDeliveryPolicyOfAllVehicles(\n        pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_FIFO\n    )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PARALLEL_CHEAPEST_INSERTION\n    )\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(data, manager, routing, assignment)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Traveling Salesperson Problem with OR-Tools\nDESCRIPTION: Complete implementation of a Traveling Salesperson Problem solver using Google OR-Tools. The code creates a distance matrix between cities, configures a routing model with one vehicle, and solves for the optimal route to visit all cities while minimizing total distance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp_cities.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        [0, 2451, 713, 1018, 1631, 1374, 2408, 213, 2571, 875, 1420, 2145, 1972],\n        [2451, 0, 1745, 1524, 831, 1240, 959, 2596, 403, 1589, 1374, 357, 579],\n        [713, 1745, 0, 355, 920, 803, 1737, 851, 1858, 262, 940, 1453, 1260],\n        [1018, 1524, 355, 0, 700, 862, 1395, 1123, 1584, 466, 1056, 1280, 987],\n        [1631, 831, 920, 700, 0, 663, 1021, 1769, 949, 796, 879, 586, 371],\n        [1374, 1240, 803, 862, 663, 0, 1681, 1551, 1765, 547, 225, 887, 999],\n        [2408, 959, 1737, 1395, 1021, 1681, 0, 2493, 678, 1724, 1891, 1114, 701],\n        [213, 2596, 851, 1123, 1769, 1551, 2493, 0, 2699, 1038, 1605, 2300, 2099],\n        [2571, 403, 1858, 1584, 949, 1765, 678, 2699, 0, 1744, 1645, 653, 600],\n        [875, 1589, 262, 466, 796, 547, 1724, 1038, 1744, 0, 679, 1272, 1162],\n        [1420, 1374, 940, 1056, 879, 225, 1891, 1605, 1645, 679, 0, 1017, 1200],\n        [2145, 357, 1453, 1280, 586, 887, 1114, 2300, 653, 1272, 1017, 0, 504],\n        [1972, 579, 1260, 987, 371, 999, 701, 2099, 600, 1162, 1200, 504, 0],\n    ]\n    data[\"num_vehicles\"] = 1\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()} miles\")\n    index = routing.Start(0)\n    plan_output = \"Route for vehicle 0:\\n\"\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += f\" {manager.IndexToNode(index)} ->\"\n        previous_index = index\n        index = solution.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += f\" {manager.IndexToNode(index)}\\n\"\n    plan_output += f\"Route distance: {route_distance}miles\\n\"\n    print(plan_output)\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: VRP Implementation with Break Scheduling\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem solver that includes data model creation, routing manager setup, constraint definitions, break scheduling, and solution output. Uses OR-Tools to optimize routes for 4 vehicles across 17 locations while enforcing 10-minute breaks between hours 50-60 of the route.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_breaks.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    data[\"time_matrix\"] = [\n        [0, 27, 38, 34, 29, 13, 25, 9, 15, 9, 26, 25, 19, 17, 23, 38, 33],\n        [27, 0, 34, 15, 9, 25, 36, 17, 34, 37, 54, 29, 24, 33, 50, 43, 60],\n        [38, 34, 0, 49, 43, 25, 13, 40, 23, 37, 20, 63, 58, 56, 39, 77, 37],\n        [34, 15, 49, 0, 5, 32, 43, 25, 42, 44, 61, 25, 31, 41, 58, 28, 67],\n        [29, 9, 43, 5, 0, 26, 38, 19, 36, 38, 55, 20, 25, 35, 52, 33, 62],\n        [13, 25, 25, 32, 26, 0, 11, 15, 9, 12, 29, 38, 33, 31, 25, 52, 35],\n        [25, 36, 13, 43, 38, 11, 0, 26, 9, 23, 17, 50, 44, 42, 25, 63, 24],\n        [9, 17, 40, 25, 19, 15, 26, 0, 17, 19, 36, 23, 17, 16, 33, 37, 42],\n        [15, 34, 23, 42, 36, 9, 9, 17, 0, 13, 19, 40, 34, 33, 16, 54, 25],\n        [9, 37, 37, 44, 38, 12, 23, 19, 13, 0, 17, 26, 21, 19, 13, 40, 23],\n        [26, 54, 20, 61, 55, 29, 17, 36, 19, 17, 0, 43, 38, 36, 19, 57, 17],\n        [25, 29, 63, 25, 20, 38, 50, 23, 40, 26, 43, 0, 5, 15, 32, 13, 42],\n        [19, 24, 58, 31, 25, 33, 44, 17, 34, 21, 38, 5, 0, 9, 26, 19, 36],\n        [17, 33, 56, 41, 35, 31, 42, 16, 33, 19, 36, 15, 9, 0, 17, 21, 26],\n        [23, 50, 39, 58, 52, 25, 25, 33, 16, 13, 19, 32, 26, 17, 0, 38, 9],\n        [38, 43, 77, 28, 33, 52, 63, 37, 54, 40, 57, 13, 19, 21, 38, 0, 39],\n        [33, 60, 37, 67, 62, 35, 24, 42, 25, 23, 17, 42, 36, 26, 9, 39, 0],\n    ]\n    # 15 min of service time\n    data[\"service_time\"] = [15] * len(data[\"time_matrix\"])\n    data[\"service_time\"][data[\"depot\"]] = 0\n    assert len(data[\"time_matrix\"]) == len(data[\"service_time\"])\n    return data\n\n\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n\n    print(\"Breaks:\")\n    intervals = solution.IntervalVarContainer()\n    for i in range(intervals.Size()):\n        brk = intervals.Element(i)\n        if brk.PerformedValue():\n            print(\n                f\"{brk.Var().Name()}: \"\n                + f\"Start({brk.StartValue()}) Duration({brk.DurationValue()})\"\n            )\n        else:\n            print(f\"{brk.Var().Name()}: Unperformed\")\n\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    total_time = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        while not routing.IsEnd(index):\n            time_var = time_dimension.CumulVar(index)\n            plan_output += f\"{manager.IndexToNode(index)} \"\n            plan_output += f\"Time({solution.Value(time_var)}) -> \"\n            index = solution.Value(routing.NextVar(index))\n        time_var = time_dimension.CumulVar(index)\n        plan_output += f\"{manager.IndexToNode(index)} \"\n        plan_output += f\"Time({solution.Value(time_var)})\\n\"\n        plan_output += f\"Time of the route: {solution.Value(time_var)}min\\n\"\n        print(plan_output)\n        total_time += solution.Value(time_var)\n    print(f\"Total time of all routes: {total_time}min\")\n\n\ndef main():\n    \"\"\"Solve the VRP with time windows.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"time_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def time_callback(from_index, to_index):\n        \"\"\"Returns the travel time + service time between the two nodes.\"\"\"\n        # Convert from routing variable Index to time matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"time_matrix\"][from_node][to_node] + data[\"service_time\"][from_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(time_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Time Windows constraint.\n    time = \"Time\"\n    routing.AddDimension(\n        transit_callback_index,\n        10,  # needed optional waiting time to place break\n        180,  # maximum time per vehicle\n        True,  # Force start cumul to zero.\n        time,\n    )\n    time_dimension = routing.GetDimensionOrDie(time)\n    time_dimension.SetGlobalSpanCostCoefficient(10)\n\n    # Breaks\n    # warning: Need a pre-travel array using the solver's index order.\n    node_visit_transit = [0] * routing.Size()\n    for index in range(routing.Size()):\n        node = manager.IndexToNode(index)\n        node_visit_transit[index] = data[\"service_time\"][node]\n\n    break_intervals = {}\n    for v in range(manager.GetNumberOfVehicles()):\n        break_intervals[v] = [\n            routing.solver().FixedDurationIntervalVar(\n                50,  # start min\n                60,  # start max\n                10,  # duration: 10 min\n                False,  # optional: no\n                f\"Break for vehicle {v}\",\n            )\n        ]\n        time_dimension.SetBreakIntervalsOfVehicle(\n            break_intervals[v], v, node_visit_transit  # breaks  # vehicle index\n        )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    # search_parameters.log_search = True\n    search_parameters.time_limit.FromSeconds(2)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Magic Square Solver Implementation\nDESCRIPTION: Implements a constraint programming solution to find the maximum sum possible in a magic square using playing cards. Uses OR-Tools to define variables, constraints, and optimization objective. Handles variable grid creation, sum constraints, card distribution constraints, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square_and_cards.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=3):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n  # n = 3\n\n  #\n  # declare variables\n  #\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(1, 13, \"x(%i,%i)\" % (i, j))\n  x_flat = [x[(i, j)] for i in range(n) for j in range(n)]\n\n  s = solver.IntVar(1, 13 * 4, \"s\")\n  counts = [solver.IntVar(0, 4, \"counts(%i)\" % i) for i in range(14)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.Distribute(x_flat, list(range(14)), counts))\n\n  # the standard magic square constraints (sans all_different)\n  [solver.Add(solver.Sum([x[(i, j)] for j in range(n)]) == s) for i in range(n)]\n  [solver.Add(solver.Sum([x[(i, j)] for i in range(n)]) == s) for j in range(n)]\n\n  solver.Add(solver.Sum([x[(i, i)] for i in range(n)]) == s)  # diag 1\n  solver.Add(solver.Sum([x[(i, n - i - 1)] for i in range(n)]) == s)  # diag 2\n\n  # redundant constraint\n  solver.Add(solver.Sum(counts) == n * n)\n\n  # objective\n  objective = solver.Maximize(s, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x_flat)\n  solution.Add(s)\n  solution.Add(counts)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MAX_VALUE)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"s:\", s.Value())\n    print(\"counts:\", [counts[i].Value() for i in range(14)])\n    for i in range(n):\n      for j in range(n):\n        print(x[(i, j)].Value(), end=\" \")\n      print()\n\n    print()\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 3\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: TSP Circuit Board Solution Implementation\nDESCRIPTION: Complete implementation of TSP solver for circuit board path optimization. Includes data model creation, distance calculation, routing model setup, and solution output. Uses Euclidean distance for path cost calculation and PATH_CHEAPEST_ARC strategy for initial solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp_circuit_board.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport math\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    # Locations in block units\n    data[\"locations\"] = [\n        # fmt: off\n      (288, 149), (288, 129), (270, 133), (256, 141), (256, 157), (246, 157),\n      (236, 169), (228, 169), (228, 161), (220, 169), (212, 169), (204, 169),\n      (196, 169), (188, 169), (196, 161), (188, 145), (172, 145), (164, 145),\n      (156, 145), (148, 145), (140, 145), (148, 169), (164, 169), (172, 169),\n      (156, 169), (140, 169), (132, 169), (124, 169), (116, 161), (104, 153),\n      (104, 161), (104, 169), (90, 165), (80, 157), (64, 157), (64, 165),\n      (56, 169), (56, 161), (56, 153), (56, 145), (56, 137), (56, 129),\n      (56, 121), (40, 121), (40, 129), (40, 137), (40, 145), (40, 153),\n      (40, 161), (40, 169), (32, 169), (32, 161), (32, 153), (32, 145),\n      (32, 137), (32, 129), (32, 121), (32, 113), (40, 113), (56, 113),\n      (56, 105), (48, 99), (40, 99), (32, 97), (32, 89), (24, 89),\n      (16, 97), (16, 109), (8, 109), (8, 97), (8, 89), (8, 81),\n      (8, 73), (8, 65), (8, 57), (16, 57), (8, 49), (8, 41),\n      (24, 45), (32, 41), (32, 49), (32, 57), (32, 65), (32, 73),\n      (32, 81), (40, 83), (40, 73), (40, 63), (40, 51), (44, 43),\n      (44, 35), (44, 27), (32, 25), (24, 25), (16, 25), (16, 17),\n      (24, 17), (32, 17), (44, 11), (56, 9), (56, 17), (56, 25),\n      (56, 33), (56, 41), (64, 41), (72, 41), (72, 49), (56, 49),\n      (48, 51), (56, 57), (56, 65), (48, 63), (48, 73), (56, 73),\n      (56, 81), (48, 83), (56, 89), (56, 97), (104, 97), (104, 105),\n      (104, 113), (104, 121), (104, 129), (104, 137), (104, 145), (116, 145),\n      (124, 145), (132, 145), (132, 137), (140, 137), (148, 137), (156, 137),\n      (164, 137), (172, 125), (172, 117), (172, 109), (172, 101), (172, 93),\n      (172, 85), (180, 85), (180, 77), (180, 69), (180, 61), (180, 53),\n      (172, 53), (172, 61), (172, 69), (172, 77), (164, 81), (148, 85),\n      (124, 85), (124, 93), (124, 109), (124, 125), (124, 117), (124, 101),\n      (104, 89), (104, 81), (104, 73), (104, 65), (104, 49), (104, 41),\n      (104, 33), (104, 25), (104, 17), (92, 9), (80, 9), (72, 9),\n      (64, 21), (72, 25), (80, 25), (80, 25), (80, 41), (88, 49),\n      (104, 57), (124, 69), (124, 77), (132, 81), (140, 65), (132, 61),\n      (124, 61), (124, 53), (124, 45), (124, 37), (124, 29), (132, 21),\n      (124, 21), (120, 9), (128, 9), (136, 9), (148, 9), (162, 9),\n      (156, 25), (172, 21), (180, 21), (180, 29), (172, 29), (172, 37),\n      (172, 45), (180, 45), (180, 37), (188, 41), (196, 49), (204, 57),\n      (212, 65), (220, 73), (228, 69), (228, 77), (236, 77), (236, 69),\n      (236, 61), (228, 61), (228, 53), (236, 53), (236, 45), (228, 45),\n      (228, 37), (236, 37), (236, 29), (228, 29), (228, 21), (236, 21),\n      (252, 21), (260, 29), (260, 37), (260, 45), (260, 53), (260, 61),\n      (260, 69), (260, 77), (276, 77), (276, 69), (276, 61), (276, 53),\n      (284, 53), (284, 61), (284, 69), (284, 77), (284, 85), (284, 93),\n      (284, 101), (288, 109), (280, 109), (276, 101), (276, 93), (276, 85),\n      (268, 97), (260, 109), (252, 101), (260, 93), (260, 85), (236, 85),\n      (228, 85), (228, 93), (236, 93), (236, 101), (228, 101), (228, 109),\n      (228, 117), (228, 125), (220, 125), (212, 117), (204, 109), (196, 101),\n      (188, 93), (180, 93), (180, 101), (180, 109), (180, 117), (180, 125),\n      (196, 145), (204, 145), (212, 145), (220, 145), (228, 145), (236, 145),\n      (246, 141), (252, 125), (260, 129), (280, 133)\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 1\n    data[\"depot\"] = 0\n    return data\n\n\ndef compute_euclidean_distance_matrix(locations):\n    \"\"\"Creates callback to return distance between points.\"\"\"\n    distances = {}\n    for from_counter, from_node in enumerate(locations):\n        distances[from_counter] = {}\n        for to_counter, to_node in enumerate(locations):\n            if from_counter == to_counter:\n                distances[from_counter][to_counter] = 0\n            else:\n                # Euclidean distance\n                distances[from_counter][to_counter] = int(\n                    math.hypot((from_node[0] - to_node[0]), (from_node[1] - to_node[1]))\n                )\n    return distances\n\n\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    index = routing.Start(0)\n    plan_output = \"Route:\\n\"\n    route_distance = 0\n    while not routing.IsEnd(index):\n        plan_output += f\" {manager.IndexToNode(index)} ->\"\n        previous_index = index\n        index = solution.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n    plan_output += f\" {manager.IndexToNode(index)}\\n\"\n    print(plan_output)\n    plan_output += f\"Objective: {route_distance}m\\n\"\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"locations\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    distance_matrix = compute_euclidean_distance_matrix(data[\"locations\"])\n\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return distance_matrix[from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Capacited Vehicles Routing Problem (CVRP) in Python\nDESCRIPTION: This code snippet demonstrates a complete implementation of the CVRP using Google OR-Tools. It includes data model creation, routing setup, constraint definition, and solution printing.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_capacity.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"demands\"] = [0, 1, 1, 2, 4, 2, 4, 8, 8, 1, 2, 1, 2, 4, 4, 8, 8]\n    data[\"vehicle_capacities\"] = [15, 15, 15, 15]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    total_distance = 0\n    total_load = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        route_load = 0\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index)\n            route_load += data[\"demands\"][node_index]\n            plan_output += f\" {node_index} Load({route_load}) -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\" {manager.IndexToNode(index)} Load({route_load})\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        plan_output += f\"Load of the route: {route_load}\\n\"\n        print(plan_output)\n        total_distance += route_distance\n        total_load += route_load\n    print(f\"Total distance of all routes: {total_distance}m\")\n    print(f\"Total load of all routes: {total_load}\")\n\n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Capacity constraint.\n    def demand_callback(from_index):\n        \"\"\"Returns the demand of the node.\"\"\"\n        # Convert from routing variable Index to demands NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        return data[\"demands\"][from_node]\n\n    demand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)\n    routing.AddDimensionWithVehicleCapacity(\n        demand_callback_index,\n        0,  # null capacity slack\n        data[\"vehicle_capacities\"],  # vehicle maximum capacities\n        True,  # start cumul to zero\n        \"Capacity\",\n    )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(1)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Scheduling Speakers Problem using OR-Tools in Python\nDESCRIPTION: This code defines the main function that sets up and solves the Scheduling Speakers problem. It creates variables for each speaker, defines constraints based on availability, and searches for solutions using the CP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_speakers.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Scheduling speakers')\n\n  #\n  # data\n  #\n  n = 6  # number of speakers\n\n  # slots available to speak\n  available = [\n      # Reasoning:\n      [3, 4, 5, 6],  # 2) the only one with 6 after speaker F -> 1\n      [3, 4],  # 5) 3 or 4\n      [2, 3, 4, 5],  # 3) only with 5 after F -> 1 and A -> 6\n      [2, 3, 4],  # 4) only with 2 after C -> 5 and F -> 1\n      [3, 4],  # 5) 3 or 4\n      [1, 2, 3, 4, 5, 6]  # 1) the only with 1\n  ]\n\n  #\n  # variables\n  #\n  x = [solver.IntVar(1, n, 'x[%i]' % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n\n  for i in range(n):\n    solver.Add(solver.MemberCt(x[i], available[i]))\n\n  #\n  # search and result\n  #\n  db = solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n\n  while solver.NextSolution():\n    num_solutions += 1\n    print('x:', [x[i].Value() for i in range(n)])\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Job Shop Scheduling Model in Python using Google OR-Tools\nDESCRIPTION: This code snippet defines constraints for a job shop scheduling problem, including machine presence, task ordering, rank maintenance, and transition times. It creates a circuit constraint to ensure a valid sequence of tasks on each machine.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nmachine_presences[i].Not())\n\n      for j in all_machine_tasks:\n        if i == j:\n          continue\n\n        lit = model.NewBoolVar('%i follows %i' % (j, i))\n        arcs.append([i + 1, j + 1, lit])\n        model.AddImplication(lit, machine_presences[i])\n        model.AddImplication(lit, machine_presences[j])\n\n        # Maintain rank incrementally.\n        model.Add(machine_ranks[j] == machine_ranks[i] + 1).OnlyEnforceIf(lit)\n\n        # Compute the transition time if task j is the successor of task i.\n        if machine_resources[i] != machine_resources[j]:\n          transition_time = 3\n          switch_literals.append(lit)\n        else:\n          transition_time = 0\n        # We add the reified transition to link the literals with the times\n        # of the tasks.\n        model.Add(machine_starts[j] == machine_ends[i] +\n                  transition_time).OnlyEnforceIf(lit)\n    if arcs:\n        model.AddCircuit(arcs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Rogo Puzzle Solver using OR-Tools in Python\nDESCRIPTION: Defines the main function for solving Rogo puzzles using OR-Tools. It sets up the problem, declares variables, adds constraints, and performs the optimization to find the best path.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/rogo2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport re\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(problem, rows, cols, max_steps):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Rogo grid puzzle\")\n\n  #\n  # data\n  #\n  W = 0\n  B = -1\n  print(\"rows: %i cols: %i max_steps: %i\" % (rows, cols, max_steps))\n\n  problem_flatten = [problem[i][j] for i in range(rows) for j in range(cols)]\n  max_point = max(problem_flatten)\n  print(\"max_point:\", max_point)\n  max_sum = sum(problem_flatten)\n  print(\"max_sum:\", max_sum)\n  print()\n\n  #\n  # declare variables\n  #\n\n  # the coordinates\n  x = [solver.IntVar(0, rows - 1, \"x[%i]\" % i) for i in range(max_steps)]\n  y = [solver.IntVar(0, cols - 1, \"y[%i]\" % i) for i in range(max_steps)]\n\n  # the collected points\n  points = [\n      solver.IntVar(0, max_point, \"points[%i]\" % i) for i in range(max_steps)\n  ]\n\n  # objective: sum of points in the path\n  sum_points = solver.IntVar(0, max_sum)\n\n  #\n  # constraints\n  #\n\n  # all coordinates must be unique\n  for s in range(max_steps):\n    for t in range(s + 1, max_steps):\n      b1 = x[s] != x[t]\n      b2 = y[s] != y[t]\n      solver.Add(b1 + b2 >= 1)\n\n  # calculate the points (to maximize)\n  for s in range(max_steps):\n    solver.Add(points[s] == solver.Element(problem_flatten, x[s] * cols + y[s]))\n\n  solver.Add(sum_points == sum(points))\n\n  # ensure that there are not black cells in\n  # the path\n  for s in range(max_steps):\n    solver.Add(solver.Element(problem_flatten, x[s] * cols + y[s]) != B)\n\n  # get the path\n  for s in range(max_steps - 1):\n    solver.Add(abs(x[s] - x[s + 1]) + abs(y[s] - y[s + 1]) == 1)\n\n  # close the path around the corner\n  solver.Add(abs(x[max_steps - 1] - x[0]) + abs(y[max_steps - 1] - y[0]) == 1)\n\n  # symmetry breaking: the cell with lowest coordinates\n  # should be in the first step.\n  for i in range(1, max_steps):\n    solver.Add(x[0] * cols + y[0] < x[i] * cols + y[i])\n\n  #\n  # objective\n  #\n  objective = solver.Maximize(sum_points, 1)\n\n  #\n  # solution and search\n  #\n  parameters = pywrapcp.DefaultPhaseParameters()\n\n  parameters.heuristic_period = 200000\n  parameters.var_selection_schema = parameters.CHOOSE_MAX_AVERAGE_IMPACT\n  parameters.value_selection_schema = parameters.SELECT_MIN_IMPACT\n\n  db = solver.DefaultPhase(x + y, parameters)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"sum_points:\", sum_points.Value())\n    print(\"adding 1 to coords...\")\n    for s in range(max_steps):\n      print(\"%i %i\" % (x[s].Value() + 1, y[s].Value() + 1))\n    print()\n\n  print(\"\\nnum_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\n# Default problem:\n# Data from\n# Mike Trick: \"Operations Research, Sudoko, Rogo, and Puzzles\"\n# http://mat.tepper.cmu.edu/blog/?p=1302\n#\n# This has 48 solutions with symmetries;\n# 4 when the path symmetry is removed.\n#\nrows = 5\ncols = 9\nmax_steps = 12\nW = 0\nB = -1\nproblem = [[2, W, W, W, W, W, W, W, W], [W, 3, W, W, 1, W, W, 2, W],\n           [W, W, W, W, W, W, B, W, 2], [W, W, 2, B, W, W, W, W, W],\n           [W, W, W, W, 2, W, W, 1, W]]\nif len(sys.argv) > 1:\n  exec(compile(open(sys.argv[1]).read(), sys.argv[1], \"exec\"))\nmain(problem, rows, cols, max_steps)\n```\n\n----------------------------------------\n\nTITLE: Post Office Scheduling Optimization Implementation\nDESCRIPTION: Main implementation of the post office scheduling problem using OR-Tools constraint solver. The code minimizes total staffing costs while ensuring daily worker requirements are met, considering additional costs for weekend work and the constraint that each worker must work 5 consecutive days followed by 2 days off.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/post_office_problem2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Post office problem')\n\n  #\n  # data\n  #\n\n  # days 0..6, monday 0\n  n = 7\n  days = list(range(n))\n  need = [17, 13, 15, 19, 14, 16, 11]\n\n  # Total cost for the 5 day schedule.\n  # Base cost per day is 100.\n  # Working saturday is 100 extra\n  # Working sunday is 200 extra.\n  cost = [500, 600, 800, 800, 800, 800, 700]\n\n  #\n  # variables\n  #\n\n  # No. of workers starting at day i\n  x = [solver.IntVar(0, 100, 'x[%i]' % i) for i in days]\n\n  total_cost = solver.IntVar(0, 20000, 'total_cost')\n  num_workers = solver.IntVar(0, 100, 'num_workers')\n\n  #\n  # constraints\n  #\n  solver.Add(total_cost == solver.ScalProd(x, cost))\n  solver.Add(num_workers == solver.Sum(x))\n\n  for i in days:\n    s = solver.Sum(\n        [x[j] for j in days if j != (i + 5) % n and j != (i + 6) % n])\n    solver.Add(s >= need[i])\n\n  # objective\n  objective = solver.Minimize(total_cost, 1)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(x, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n\n  while solver.NextSolution():\n    num_solutions += 1\n    print('num_workers:', num_workers.Value())\n    print('total_cost:', total_cost.Value())\n    print('x:', [x[i].Value() for i in days])\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Linear Program with GLOP Solver in Python\nDESCRIPTION: This code snippet provides a minimal example of using the GLOP solver from Google OR-Tools to solve a linear programming problem. It involves creating a solver, defining variables and constraints, and maximizing an objective function. Dependencies include the OR-Tools Python package. Inputs are variable constraints, and the output is the optimal solution values for variables x and y. This example requires OR-Tools to be installed.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_lp_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef main():\n    # Create the linear solver with the GLOP backend.\n    solver = pywraplp.Solver.CreateSolver(\"GLOP\")\n    if not solver:\n        return\n\n    infinity = solver.infinity()\n    # Create the variables x and y.\n    x = solver.NumVar(0.0, infinity, \"x\")\n    y = solver.NumVar(0.0, infinity, \"y\")\n\n    print(\"Number of variables =\", solver.NumVariables())\n\n    # x + 7 * y <= 17.5.\n    solver.Add(x + 7 * y <= 17.5)\n\n    # x <= 3.5.\n    solver.Add(x <= 3.5)\n\n    print(\"Number of constraints =\", solver.NumConstraints())\n\n    # Maximize x + 10 * y.\n    solver.Maximize(x + 10 * y)\n\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    if status == pywraplp.Solver.OPTIMAL:\n        print(\"Solution:\")\n        print(\"Objective value =\", solver.Objective().Value())\n        print(\"x =\", x.solution_value())\n        print(\"y =\", y.solution_value())\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n    print(\"\\nAdvanced usage:\")\n    print(f\"Problem solved in {solver.wall_time():d} milliseconds\")\n    print(f\"Problem solved in {solver.iterations():d} iterations\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Random TSP Solver with OR-Tools\nDESCRIPTION: Complete implementation of a TSP solver that generates random problem instances. The code sets up a routing model, applies distance functions, handles optional random forbidden connections, and finds/displays the optimal route using OR-Tools constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/random_tsp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nfrom functools import partial\nimport random\n\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\n    '--tsp_size',\n    default=10,\n    type=int,\n    help='Size of Traveling Salesman Problem instance.')\nparser.add_argument(\n    '--tsp_use_random_matrix',\n    default=True,\n    type=bool,\n    help='Use random cost matrix.')\nparser.add_argument(\n    '--tsp_random_forbidden_connections',\n    default=0,\n    type=int,\n    help='Number of random forbidden connections.')\nparser.add_argument(\n    '--tsp_random_seed', default=0, type=int, help='Random seed.')\n\n# Cost/distance functions.\n\n\ndef Distance(manager, i, j):\n    \"\"\"Sample function.\"\"\"\n    # Put your distance code here.\n    node_i = manager.IndexToNode(i)\n    node_j = manager.IndexToNode(j)\n    return node_i + node_j\n\n\nclass RandomMatrix(object):\n    \"\"\"Random matrix.\"\"\"\n\n    def __init__(self, size, seed):\n        \"\"\"Initialize random matrix.\"\"\"\n\n        rand = random.Random()\n        rand.seed(seed)\n        distance_max = 100\n        self.matrix = {}\n        for from_node in range(size):\n            self.matrix[from_node] = {}\n            for to_node in range(size):\n                if from_node == to_node:\n                    self.matrix[from_node][to_node] = 0\n                else:\n                    self.matrix[from_node][to_node] = rand.randrange(\n                        distance_max)\n\n    def Distance(self, manager, from_index, to_index):\n        return self.matrix[manager.IndexToNode(from_index)][manager.IndexToNode(\n            to_index)]\n\n\ndef main(args):\n    # Create routing model\n    if args.tsp_size > 0:\n        # TSP of size args.tsp_size\n        # Second argument = 1 to build a single tour (it's a TSP).\n        # Nodes are indexed from 0 to args_tsp_size - 1, by default the start of\n        # the route is node 0.\n        manager = pywrapcp.RoutingIndexManager(args.tsp_size, 1, 0)\n        routing = pywrapcp.RoutingModel(manager)\n        search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n        # Setting first solution heuristic (cheapest addition).\n        search_parameters.first_solution_strategy = (\n            routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)\n\n        # Setting the cost function.\n        # Put a callback to the distance accessor here. The callback takes two\n        # arguments (the from and to node indices) and returns the distance between\n        # these indices.\n        cost = 0\n        if args.tsp_use_random_matrix:\n            matrix = RandomMatrix(args.tsp_size, args.tsp_random_seed)\n            cost = routing.RegisterTransitCallback(\n                partial(matrix.Distance, manager))\n        else:\n            cost = routing.RegisterTransitCallback(partial(Distance, manager))\n        routing.SetArcCostEvaluatorOfAllVehicles(cost)\n        # Forbid node connections (randomly).\n        rand = random.Random()\n        rand.seed(args.tsp_random_seed)\n        forbidden_connections = 0\n        while forbidden_connections < args.tsp_random_forbidden_connections:\n            from_node = rand.randrange(args.tsp_size - 1)\n            to_node = rand.randrange(args.tsp_size - 1) + 1\n            if routing.NextVar(from_node).Contains(to_node):\n                print('Forbidding connection ' + str(from_node) + ' -> ' +\n                      str(to_node))\n                routing.NextVar(from_node).RemoveValue(to_node)\n                forbidden_connections += 1\n\n        # Solve, returns a solution if any.\n        assignment = routing.Solve()\n        if assignment:\n            # Solution cost.\n            print(assignment.ObjectiveValue())\n            # Inspect solution.\n            # Only one route here; otherwise iterate from 0 to routing.vehicles() - 1\n            route_number = 0\n            node = routing.Start(route_number)\n            route = ''\n            while not routing.IsEnd(node):\n                route += str(node) + ' -> '\n                node = assignment.Value(routing.NextVar(node))\n            route += '0'\n            print(route)\n        else:\n            print('No solution found.')\n    else:\n        print('Specify an instance greater than 0.')\n\n\nmain(parser.parse_args())\n```\n\n----------------------------------------\n\nTITLE: Task Scheduling with No-Overlap in C# using OR-Tools\nDESCRIPTION: C# implementation of task scheduling that schedules 3 tasks with fixed durations over 3 weeks while avoiding weekends. Uses CP-SAT solver to minimize the makespan and enforces no-overlap constraints between tasks and weekend periods.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class NoOverlapSampleSat\n{\n    static void Main()\n    {\n        CpModel model = new CpModel();\n        int horizon = 21;\n\n        IntVar start_0 = model.NewIntVar(0, horizon, \"start_0\");\n        int duration_0 = 2;\n        IntVar end_0 = model.NewIntVar(0, horizon, \"end_0\");\n        IntervalVar task_0 = model.NewIntervalVar(start_0, duration_0, end_0, \"task_0\");\n\n        IntVar start_1 = model.NewIntVar(0, horizon, \"start_1\");\n        int duration_1 = 4;\n        IntVar end_1 = model.NewIntVar(0, horizon, \"end_1\");\n        IntervalVar task_1 = model.NewIntervalVar(start_1, duration_1, end_1, \"task_1\");\n\n        IntVar start_2 = model.NewIntVar(0, horizon, \"start_2\");\n        int duration_2 = 3;\n        IntVar end_2 = model.NewIntVar(0, horizon, \"end_2\");\n        IntervalVar task_2 = model.NewIntervalVar(start_2, duration_2, end_2, \"task_2\");\n\n        IntervalVar weekend_0 = model.NewIntervalVar(5, 2, 7, \"weekend_0\");\n        IntervalVar weekend_1 = model.NewIntervalVar(12, 2, 14, \"weekend_1\");\n        IntervalVar weekend_2 = model.NewIntervalVar(19, 2, 21, \"weekend_2\");\n\n        model.AddNoOverlap(new IntervalVar[] { task_0, task_1, task_2, weekend_0, weekend_1, weekend_2 });\n\n        IntVar obj = model.NewIntVar(0, horizon, \"makespan\");\n        model.AddMaxEquality(obj, new IntVar[] { end_0, end_1, end_2 });\n        model.Minimize(obj);\n\n        CpSolver solver = new CpSolver();\n        CpSolverStatus status = solver.Solve(model);\n\n        if (status == CpSolverStatus.Optimal)\n        {\n            Console.WriteLine(\"Optimal Schedule Length: \" + solver.ObjectiveValue);\n            Console.WriteLine(\"Task 0 starts at \" + solver.Value(start_0));\n            Console.WriteLine(\"Task 1 starts at \" + solver.Value(start_1));\n            Console.WriteLine(\"Task 2 starts at \" + solver.Value(start_2));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Eq 20 Constraint Problem with OR-Tools in Python\nDESCRIPTION: This code sets up and solves the Eq 20 benchmark problem using Google's OR-Tools constraint programming solver. It defines 7 integer variables and 20 linear equation constraints, then searches for solutions that satisfy all constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/eq20.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Eq 20\")\n\n  #\n  # data\n  #\n  n = 7\n\n  #\n  # variables\n  #\n  X = [solver.IntVar(0, 10, \"X(%i)\" % i) for i in range(n)]\n  X0, X1, X2, X3, X4, X5, X6 = X\n\n  #\n  # constraints\n  #\n  solver.Add(-76706 * X0 + 98205 * X1 + 23445 * X2 + 67921 * X3 + 24111 * X4 +\n             -48614 * X5 + -41906 * X6 == 821228)\n  solver.Add(87059 * X0 + -29101 * X1 + -5513 * X2 + -21219 * X3 + 22128 * X4 +\n             7276 * X5 + 57308 * X6 == 22167)\n  solver.Add(-60113 * X0 + 29475 * X1 + 34421 * X2 + -76870 * X3 + 62646 * X4 +\n             29278 * X5 + -15212 * X6 == 251591)\n  solver.Add(49149 * X0 + 52871 * X1 + -7132 * X2 + 56728 * X3 + -33576 * X4 +\n             -49530 * X5 + -62089 * X6 == 146074)\n  solver.Add(-10343 * X0 + 87758 * X1 + -11782 * X2 + 19346 * X3 + 70072 * X4 +\n             -36991 * X5 + 44529 * X6 == 740061)\n  solver.Add(85176 * X0 + -95332 * X1 + -1268 * X2 + 57898 * X3 + 15883 * X4 +\n             50547 * X5 + 83287 * X6 == 373854)\n  solver.Add(-85698 * X0 + 29958 * X1 + 57308 * X2 + 48789 * X3 + -78219 * X4 +\n             4657 * X5 + 34539 * X6 == 249912)\n  solver.Add(-67456 * X0 + 84750 * X1 + -51553 * X2 + 21239 * X3 + 81675 * X4 +\n             -99395 * X5 + -4254 * X6 == 277271)\n  solver.Add(94016 * X0 + -82071 * X1 + 35961 * X2 + 66597 * X3 + -30705 * X4 +\n             -44404 * X5 + -38304 * X6 == 25334)\n  solver.Add(-60301 * X0 + 31227 * X1 + 93951 * X2 + 73889 * X3 + 81526 * X4 +\n             -72702 * X5 + 68026 * X6 == 1410723)\n  solver.Add(-16835 * X0 + 47385 * X1 + 97715 * X2 + -12640 * X3 + 69028 * X4 +\n             76212 * X5 + -81102 * X6 == 1244857)\n  solver.Add(-43277 * X0 + 43525 * X1 + 92298 * X2 + 58630 * X3 + 92590 * X4 +\n             -9372 * X5 + -60227 * X6 == 1503588)\n  solver.Add(-64919 * X0 + 80460 * X1 + 90840 * X2 + -59624 * X3 + -75542 * X4 +\n             25145 * X5 + -47935 * X6 == 18465)\n  solver.Add(-45086 * X0 + 51830 * X1 + -4578 * X2 + 96120 * X3 + 21231 * X4 +\n             97919 * X5 + 65651 * X6 == 1198280)\n  solver.Add(85268 * X0 + 54180 * X1 + -18810 * X2 + -48219 * X3 + 6013 * X4 +\n             78169 * X5 + -79785 * X6 == 90614)\n  solver.Add(8874 * X0 + -58412 * X1 + 73947 * X2 + 17147 * X3 + 62335 * X4 +\n             16005 * X5 + 8632 * X6 == 752447)\n  solver.Add(71202 * X0 + -11119 * X1 + 73017 * X2 + -38875 * X3 + -14413 * X4 +\n             -29234 * X5 + 72370 * X6 == 129768)\n  solver.Add(1671 * X0 + -34121 * X1 + 10763 * X2 + 80609 * X3 + 42532 * X4 +\n             93520 * X5 + -33488 * X6 == 915683)\n  solver.Add(51637 * X0 + 67761 * X1 + 95951 * X2 + 3834 * X3 + -96722 * X4 +\n             59190 * X5 + 15280 * X6 == 533909)\n  solver.Add(-16105 * X0 + 62397 * X1 + -6704 * X2 + 43340 * X3 + 95100 * X4 +\n             -68610 * X5 + 58301 * X6 == 876370)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(X, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"X:\", [X[i].Value() for i in range(n)])\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Main Function for VRP Solver Setup and Execution\nDESCRIPTION: This function creates a sample VRP instance, sets up the OR-Tools routing model with various constraints (time windows, capacity, etc.), solves the problem, and visualizes the solution. It demonstrates how to configure parameters for the solver and extract the results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    # Create a set of customer, (and depot) stops.\n    customers = Customers(\n        num_stops=50,\n        min_demand=1,\n        max_demand=15,\n        box_size=40,\n        min_tw=3,\n        max_tw=6)\n\n    # Create a list of inhomgenious vehicle capacities as integer units.\n    capacity = [50, 75, 100, 125, 150, 175, 200, 250]\n\n    # Create a list of inhomogeneous fixed vehicle costs.\n    cost = [int(100 + 2 * np.sqrt(c)) for c in capacity]\n\n    # Create a set of vehicles, the number set by the length of capacity.\n    vehicles = Vehicles(capacity=capacity, cost=cost)\n\n    # check to see that the problem is feasible, if we don't have enough\n    # vehicles to cover the demand, there is no point in going further.\n    assert (customers.get_total_demand() < vehicles.get_total_capacity())\n\n    # Set the starting nodes, and create a callback fn for the starting node.\n    start_fn = vehicles.return_starting_callback(\n        customers, sameStartFinish=False)\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        customers.number,  # int number\n        vehicles.number,  # int number\n        vehicles.starts,  # List of int start depot\n        vehicles.ends)  # List of int end depot\n\n    customers.set_manager(manager)\n\n    # Set model parameters\n    model_parameters = pywrapcp.DefaultRoutingModelParameters()\n\n    # The solver parameters can be accessed from the model parameters. For example :\n    #   model_parameters.solver_parameters.CopyFrom(\n    #       pywrapcp.Solver.DefaultSolverParameters())\n    #    model_parameters.solver_parameters.trace_propagation = True\n\n    # Make the routing model instance.\n    routing = pywrapcp.RoutingModel(manager, model_parameters)\n\n    parameters = pywrapcp.DefaultRoutingSearchParameters()\n    # Setting first solution heuristic (cheapest addition).\n    parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)\n    # Routing: forbids use of TSPOpt neighborhood, (this is the default behaviour)\n    parameters.local_search_operators.use_tsp_opt = pywrapcp.BOOL_FALSE\n    # Disabling Large Neighborhood Search, (this is the default behaviour)\n    parameters.local_search_operators.use_path_lns = pywrapcp.BOOL_FALSE\n    parameters.local_search_operators.use_inactive_lns = pywrapcp.BOOL_FALSE\n\n    parameters.time_limit.seconds = 10\n    parameters.use_full_propagation = True\n    #parameters.log_search = True\n\n    # Create callback fns for distances, demands, service and transit-times.\n    dist_fn = customers.return_dist_callback()\n    dist_fn_index = routing.RegisterTransitCallback(dist_fn)\n\n    dem_fn = customers.return_dem_callback()\n    dem_fn_index = routing.RegisterUnaryTransitCallback(dem_fn)\n\n    # Create and register a transit callback.\n    serv_time_fn = customers.make_service_time_call_callback()\n    transit_time_fn = customers.make_transit_time_callback()\n    def tot_time_fn(from_index, to_index):\n        \"\"\"\n        The time function we want is both transit time and service time.\n        \"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return serv_time_fn(from_node, to_node) + transit_time_fn(from_node, to_node)\n\n    tot_time_fn_index = routing.RegisterTransitCallback(tot_time_fn)\n\n    # Set the cost function (distance callback) for each arc, homogeneous for\n    # all vehicles.\n    routing.SetArcCostEvaluatorOfAllVehicles(dist_fn_index)\n\n    # Set vehicle costs for each vehicle, not homogeneous.\n    for veh in vehicles.vehicles:\n        routing.SetFixedCostOfVehicle(veh.cost, int(veh.index))\n\n    # Add a dimension for vehicle capacities\n    null_capacity_slack = 0\n    routing.AddDimensionWithVehicleCapacity(\n        dem_fn_index,  # demand callback\n        null_capacity_slack,\n        capacity,  # capacity array\n        True,\n        'Capacity')\n    # Add a dimension for time and a limit on the total time_horizon\n    routing.AddDimension(\n        tot_time_fn_index,  # total time function callback\n        customers.time_horizon,\n        customers.time_horizon,\n        True,\n        'Time')\n\n    time_dimension = routing.GetDimensionOrDie('Time')\n    for cust in customers.customers:\n        if cust.tw_open is not None:\n            time_dimension.CumulVar(manager.NodeToIndex(cust.index)).SetRange(\n                cust.tw_open.seconds, cust.tw_close.seconds)\n    \"\"\"\n     To allow the dropping of orders, we add disjunctions to all the customer\n    nodes. Each disjunction is a list of 1 index, which allows that customer to\n    be active or not, with a penalty if not. The penalty should be larger\n    than the cost of servicing that customer, or it will always be dropped!\n    \"\"\"\n    # To add disjunctions just to the customers, make a list of non-depots.\n    non_depot = set(range(customers.number))\n    non_depot.difference_update(vehicles.starts)\n    non_depot.difference_update(vehicles.ends)\n    penalty = 400000  # The cost for dropping a node from the plan.\n    nodes = [routing.AddDisjunction([manager.NodeToIndex(c)], penalty) for c in non_depot]\n\n    # This is how you would implement partial routes if you already knew part\n    # of a feasible solution for example:\n    # partial = np.random.choice(list(non_depot), size=(4,5), replace=False)\n\n    # routing.CloseModel()\n    # partial_list = [partial[0,:].tolist(),\n    #                 partial[1,:].tolist(),\n    #                 partial[2,:].tolist(),\n    #                 partial[3,:].tolist(),\n    #                 [],[],[],[]]\n    # print(routing.ApplyLocksToAllVehicles(partial_list, False))\n\n    # Solve the problem !\n    assignment = routing.SolveWithParameters(parameters)\n\n    # The rest is all optional for saving, printing or plotting the solution.\n    if assignment:\n        ## save the assignment, (Google Protobuf format)\n        #save_file_base = os.path.realpath(__file__).split('.')[0]\n        #if routing.WriteAssignment(save_file_base + '_assignment.ass'):\n        #    print('succesfully wrote assignment to file ' + save_file_base +\n        #          '_assignment.ass')\n\n        print('The Objective Value is {0}'.format(assignment.ObjectiveValue()))\n\n        plan_output, dropped = vehicle_output_string(manager, routing, assignment)\n        print(plan_output)\n        print('dropped nodes: ' + ', '.join(dropped))\n\n        # you could print debug information like this:\n        # print(routing.DebugOutputAssignment(assignment, 'Capacity'))\n\n        vehicle_routes = {}\n        for veh in range(vehicles.number):\n            vehicle_routes[veh] = build_vehicle_route(manager, routing, assignment,\n                                                      customers, veh)\n\n        # Plotting of the routes in matplotlib.\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        # Plot all the nodes as black dots.\n        clon, clat = zip(*[(c.lon, c.lat) for c in customers.customers])\n        ax.plot(clon, clat, 'k.')\n        # plot the routes as arrows\n```\n\n----------------------------------------\n\nTITLE: Cloning and Solving a Model with OR-Tools Model Builder\nDESCRIPTION: This Python code demonstrates cloning an OR-Tools model created using the Model Builder, modifying a constraint in the cloned model, and solving it.  It initializes a model, defines variables and constraints, clones the model, modifies a constraint in the cloned model by adding a term, and solves the cloned model using the SCIP solver, printing the solution if it's optimal.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/clone_model_mb.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"import math\\n\\nfrom ortools.linear_solver.python import model_builder\\n\\n\\ndef main():\\n    # Create the model.\\n    model = model_builder.Model()\\n\\n    # x and y are integer non-negative variables.\\n    x = model.new_int_var(0.0, math.inf, \\\"x\\\")\\n    y = model.new_int_var(0.0, math.inf, \\\"y\\\")\\n\\n    # x + 7 * y <= 17.5.\\n    unused_c1 = model.add(x + 7 * y <= 17.5)\\n\\n    # x <= 3.5.\\n    c2 = model.add(x <= 3.5)\\n\\n    # Maximize x + 10 * y.\\n    model.maximize(x + 10 * y)\\n\\n    # [Start clone]\\n    # Clone the model.\\n    print(\\\"Cloning the model.\\\")\\n    model_copy = model.clone()\\n    x_copy = model_copy.var_from_index(x.index)\\n    y_copy = model_copy.var_from_index(y.index)\\n    z_copy = model_copy.new_bool_var(\\\"z\\\")\\n    c2_copy = model_copy.linear_constraint_from_index(c2.index)\\n\\n    # Add new constraint.\\n    model_copy.add(x_copy >= 1)\\n    print(f\\\"Number of constraints in original model ={model.num_constraints}\\\")\\n    print(f\\\"Number of constraints in cloned model = {model_copy.num_constraints}\\\")\\n\\n    # Modify a constraint.\\n    c2_copy.add_term(z_copy, 2.0)\\n\\n    # Create the solver with the SCIP backend, and solve the model.\\n    solver = model_builder.Solver(\\\"scip\\\")\\n    if not solver.solver_is_supported():\\n        return\\n    status = solver.solve(model_copy)\\n\\n    if status == model_builder.SolveStatus.OPTIMAL:\\n        print(\\\"Solution:\\\")\\n        print(f\\\"Objective value = {solver.objective_value}\\\")\\n        print(f\\\"x = {solver.value(x_copy)}\\\")\\n        print(f\\\"y = {solver.value(y_copy)}\\\")\\n        print(f\\\"z = {solver.value(z_copy)}\\\")\\n    else:\\n        print(\\\"The problem does not have an optimal solution.\\\")\\n\\n    print(\\\"\\nAdvanced usage:\\\")\\n    print(f\\\"Problem solved in {solver.wall_time} seconds\\\")\\n\\n\\nmain()\\n\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Min-Cost Flow Solution for Assignment Problem in Python\nDESCRIPTION: This snippet illustrates the complete implementation of the SimpleMinCostFlow algorithm to solve an assignment problem. It sets up the directed graph, adds node supplies, and calculates the minimum cost flow between nodes, finally outputting the assignments and associated costs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/graph/assignment_min_flow.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.graph.python import min_cost_flow\n\ndef main():\n    \"\"\"Solving an Assignment Problem with MinCostFlow.\"\"\"\n    # Instantiate a SimpleMinCostFlow solver.\n    smcf = min_cost_flow.SimpleMinCostFlow()\n\n    # Define the directed graph for the flow.\n    start_nodes = (\n        [0, 0, 0, 0] + [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4] + [5, 6, 7, 8]\n    )\n    end_nodes = (\n        [1, 2, 3, 4] + [5, 6, 7, 8, 5, 6, 7, 8, 5, 6, 7, 8, 5, 6, 7, 8] + [9, 9, 9, 9]\n    )\n    capacities = (\n        [1, 1, 1, 1] + [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] + [1, 1, 1, 1]\n    )\n    costs = (\n        [0, 0, 0, 0]\n        + [90, 76, 75, 70, 35, 85, 55, 65, 125, 95, 90, 105, 45, 110, 95, 115]\n        + [0, 0, 0, 0]\n    )\n\n    source = 0\n    sink = 9\n    tasks = 4\n    supplies = [tasks, 0, 0, 0, 0, 0, 0, 0, 0, -tasks]\n\n    # Add each arc.\n    for start_node, end_node, capacity, cost in zip(\n        start_nodes, end_nodes, capacities, costs\n    ):\n        smcf.add_arc_with_capacity_and_unit_cost(start_node, end_node, capacity, cost)\n    # Add node supplies.\n    for idx, supply in enumerate(supplies):\n        smcf.set_node_supply(idx, supply)\n\n    # Find the minimum cost flow between node 0 and node 10.\n    status = smcf.solve()\n\n    if status == smcf.OPTIMAL:\n        print(f\"Total cost = {smcf.optimal_cost()}\")\n        for arc in range(smcf.num_arcs()):\n            # Can ignore arcs leading out of source or into sink.\n            if smcf.tail(arc) != source and smcf.head(arc) != sink:\n\n                # Arcs in the solution have a flow value of 1. Their start and end nodes\n                # give an assignment of worker to task.\n                if smcf.flow(arc) > 0:\n                    print(\n                        f\"Worker {smcf.tail(arc)} assigned to task {smcf.head(arc)}. \"\n                        f\"Cost = {smcf.unit_cost(arc)}\"\n                    )\n    else:\n        print(\"There was an issue with the min cost flow input.\")\n        print(f\"Status: {status}\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Memory Layout Optimization using OR-Tools CP-SAT Solver\nDESCRIPTION: Complete implementation of memory layout optimization using three different approaches: hard constraints, soft constraints with assumptions, and soft constraints with maximization. The code handles memory allocation demands with specific time intervals, sizes, and capacity constraints while providing infeasibility analysis capabilities.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/memory_layout_and_infeasibility_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\nfrom typing import List\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\n    \"params\", \"num_workers:1,linearization_level:2\", \"Sat solver parameters.\"\n)\n\nDEMANDS = [\n    [1578, 1583, 43008, 1],\n    [1588, 1589, 11264, 1],\n    [1590, 1595, 43008, 1],\n    [1583, 1588, 47872, 1],\n    [1589, 1590, 22848, 1],\n    [1586, 1590, 22848, 1],\n    [1591, 1594, 43008, 1],\n]\nCAPACITY = 98304\n\ndef solve_hard_model(output_proto: str, params: str) -> bool:\n    \"\"\"Solves the hard assignment model.\"\"\"\n    print(\"Solving the hard assignment model\")\n    model = cp_model.CpModel()\n\n    x_intervals: List[cp_model.IntervalVar] = []\n    y_starts: List[cp_model.IntVar] = []\n    y_intervals: List[cp_model.IntervalVar] = []\n\n    for start_time, end_time, demand, _ in DEMANDS:\n        x_interval = model.new_fixed_size_interval_var(\n            start_time, end_time - start_time + 1, \"\"\n        )\n        y_start = model.new_int_var(0, CAPACITY - demand, \"\")\n        y_interval = model.new_fixed_size_interval_var(y_start, demand, \"\")\n\n        x_intervals.append(x_interval)\n        y_starts.append(y_start)\n        y_intervals.append(y_interval)\n\n    model.add_no_overlap_2d(x_intervals, y_intervals)\n\n    if output_proto:\n        model.export_to_file(output_proto)\n\n    solver = cp_model.CpSolver()\n    if params:\n        text_format.Parse(params, solver.parameters)\n    status = solver.solve(model)\n    print(solver.response_stats())\n\n    if status in (cp_model.FEASIBLE, cp_model.OPTIMAL):\n        for index, start_var in enumerate(y_starts):\n            print(f\"task {index} buffer starts at {solver.value(start_var)}\")\n\n    return status != cp_model.INFEASIBLE\n\ndef solve_soft_model_with_assumptions() -> None:\n    \"\"\"Solves the soft model using assumptions.\"\"\"\n    print(\"Solving the soft model using assumptions\")\n\n    model = cp_model.CpModel()\n\n    presences: List[cp_model.IntVar] = []\n    x_intervals: List[cp_model.IntervalVar] = []\n    y_starts: List[cp_model.IntVar] = []\n    y_intervals: List[cp_model.IntervalVar] = []\n\n    for start, end, demand, unused_alignment in DEMANDS:\n        presence = model.new_bool_var(\"\")\n        x_interval = model.new_optional_fixed_size_interval_var(\n            start, end - start + 1, presence, \"\"\n        )\n        y_start = model.new_int_var(0, CAPACITY - demand, \"\")\n        y_interval = model.new_optional_fixed_size_interval_var(\n            y_start, demand, presence, \"\"\n        )\n\n        presences.append(presence)\n        x_intervals.append(x_interval)\n        y_starts.append(y_start)\n        y_intervals.append(y_interval)\n\n    model.add_no_overlap_2d(x_intervals, y_intervals)\n    model.add_assumptions(presences)\n\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n    print(solver.response_stats())\n    if status == cp_model.INFEASIBLE:\n        infeasible_variable_indices = solver.sufficient_assumptions_for_infeasibility()\n        infeasible_variable_indices_set = set(infeasible_variable_indices)\n\n        for index, presence in enumerate(presences):\n            if presence.index in infeasible_variable_indices_set:\n                print(f\"using task {index} is sufficient to explain infeasibility\")\n\ndef solve_soft_model_with_maximization(params: str) -> None:\n    \"\"\"Solves the soft model using maximization.\"\"\"\n    print(\"Solving the soft model using minimization\")\n\n    model = cp_model.CpModel()\n\n    presences: List[cp_model.IntVar] = []\n    x_intervals: List[cp_model.IntervalVar] = []\n    y_starts: List[cp_model.IntVar] = []\n    y_intervals: List[cp_model.IntervalVar] = []\n\n    for start, end, demand, unused_alignment in DEMANDS:\n        presence = model.new_bool_var(\"\")\n        x_interval = model.new_optional_fixed_size_interval_var(\n            start, end - start + 1, presence, \"\"\n        )\n        y_start = model.new_int_var(0, CAPACITY - demand, \"\")\n        y_interval = model.new_optional_fixed_size_interval_var(\n            y_start, demand, presence, \"\"\n        )\n\n        presences.append(presence)\n        x_intervals.append(x_interval)\n        y_starts.append(y_start)\n        y_intervals.append(y_interval)\n\n    model.add_no_overlap_2d(x_intervals, y_intervals)\n\n    model.maximize(sum(presences))\n\n    solver = cp_model.CpSolver()\n    if params:\n        text_format.Parse(params, solver.parameters)\n    status = solver.solve(model)\n    print(solver.response_stats())\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        for index, presence in enumerate(presences):\n            if not solver.boolean_value(presence):\n                print(f\"task {index} does not fit\")\n            else:\n                print(f\"task {index} buffer starts at {solver.value(y_starts[index])}\")\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    if not solve_hard_model(_OUTPUT_PROTO.value, _PARAMS.value):\n        solve_soft_model_with_assumptions()\n        solve_soft_model_with_maximization(_PARAMS.value)\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Linear Programming with OR-Tools Natural Language API\nDESCRIPTION: Demonstrates solving a linear programming problem using OR-Tools' natural language API. The function creates a maximization problem with three variables and three constraints, then solves and displays the results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_programming.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef Announce(solver, api_type):\n    print(\n        \"---- Linear programming example with \" + solver + \" (\" + api_type + \") -----\"\n    )\n\n\ndef RunLinearExampleNaturalLanguageAPI(optimization_problem_type):\n    \"\"\"Example of simple linear program with natural language API.\"\"\"\n    solver = pywraplp.Solver.CreateSolver(optimization_problem_type)\n\n    if not solver:\n        return\n\n    Announce(optimization_problem_type, \"natural language API\")\n\n    infinity = solver.infinity()\n    # x1, x2 and x3 are continuous non-negative variables.\n    x1 = solver.NumVar(0.0, infinity, \"x1\")\n    x2 = solver.NumVar(0.0, infinity, \"x2\")\n    x3 = solver.NumVar(0.0, infinity, \"x3\")\n\n    solver.Maximize(10 * x1 + 6 * x2 + 4 * x3)\n    c0 = solver.Add(10 * x1 + 4 * x2 + 5 * x3 <= 600, \"ConstraintName0\")\n    c1 = solver.Add(2 * x1 + 2 * x2 + 6 * x3 <= 300)\n    sum_of_vars = sum([x1, x2, x3])\n    c2 = solver.Add(sum_of_vars <= 100.0, \"OtherConstraintName\")\n\n    SolveAndPrint(\n        solver, [x1, x2, x3], [c0, c1, c2], optimization_problem_type != \"PDLP\"\n    )\n    # Print a linear expression's solution value.\n    print(\"Sum of vars: %s = %s\" % (sum_of_vars, sum_of_vars.solution_value()))\n```\n\n----------------------------------------\n\nTITLE: Solving Cutting Stock Problem with MIP in Python\nDESCRIPTION: Function that implements the cutting stock problem solver using the arc-flow formulation and a MIP solver (SCIP). Similar to the CP-SAT version, it creates a model with variables for transitions and constraints for flow conservation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef solve_cutting_stock_with_arc_flow_and_mip():\n    \"\"\"Solve the cutting stock with arc-flow and a MIP solver.\"\"\"\n    items = regroup_and_count(DESIRED_LENGTHS)\n    print(\"Items:\", items)\n    num_items = len(DESIRED_LENGTHS)\n    max_capacity = max(POSSIBLE_CAPACITIES)\n    states, transitions = create_state_graph(items, max_capacity)\n\n    print(\n        \"Dynamic programming has generated\",\n        len(states),\n        \"states and\",\n        len(transitions),\n        \"transitions\",\n    )\n\n    incoming_vars = collections.defaultdict(list)\n    outgoing_vars = collections.defaultdict(list)\n    incoming_sink_vars = []\n    item_vars = collections.defaultdict(list)\n    item_coeffs = collections.defaultdict(list)\n\n    start_time = time.time()\n    model = mb.ModelBuilder()\n\n    objective_vars = []\n    objective_coeffs = []\n\n    var_index = 0\n    for outgoing, incoming, item_index, card in transitions:\n        count = items[item_index][1]\n        count_var = model.new_int_var(\n            0,\n            count,\n            \"a%i_i%i_f%i_t%i_c%i\" % (var_index, item_index, incoming, outgoing, card),\n        )\n        var_index += 1\n        incoming_vars[incoming].append(count_var)\n        outgoing_vars[outgoing].append(count_var)\n        item_vars[item_index].append(count_var)\n        item_coeffs[item_index].append(card)\n\n    for state_index, state in enumerate(states):\n        if state_index == 0:\n            continue\n        exit_var = model.new_int_var(0, num_items, \"e%i\" % state_index)\n        outgoing_vars[state_index].append(exit_var)\n        incoming_sink_vars.append(exit_var)\n        price = price_usage(state, POSSIBLE_CAPACITIES)\n        objective_vars.append(exit_var)\n        objective_coeffs.append(price)\n\n    # Flow conservation\n    for state_index in range(1, len(states)):\n        model.add(\n            mb.LinearExpr.sum(incoming_vars[state_index])\n            == mb.LinearExpr.sum(outgoing_vars[state_index])\n        )\n\n    # Flow going out of the source must go in the sink\n    model.add(\n        mb.LinearExpr.sum(outgoing_vars[0]) == mb.LinearExpr.sum(incoming_sink_vars)\n    )\n\n    # Items must be placed\n    for item_index, size_and_count in enumerate(items):\n        num_arcs = len(item_vars[item_index])\n        model.add(\n            mb.LinearExpr.sum(\n                [\n                    item_vars[item_index][i] * item_coeffs[item_index][i]\n                    for i in range(num_arcs)\n                ]\n            )\n            == size_and_count[1]\n        )\n\n    # Objective is the sum of waste\n    model.minimize(np.dot(objective_vars, objective_coeffs))\n\n    solver = mb.ModelSolver(\"scip\")\n    solver.enable_output(True)\n    status = solver.solve(model)\n\n    ### Output the solution.\n    if status == mb.SolveStatus.OPTIMAL or status == mb.SolveStatus.FEASIBLE:\n        print(\n            \"Objective value = %f found in %.2f s\"\n            % (solver.objective_value, time.time() - start_time)\n        )\n    else:\n        print(\"No solution\")\n```\n\n----------------------------------------\n\nTITLE: Gate Scheduling Implementation with CP-SAT Solver\nDESCRIPTION: Main implementation of the gate scheduling problem using OR-Tools CP-SAT solver. Creates a model with interval variables for job scheduling, handles machine assignments, enforces width constraints, and minimizes makespan. Includes visualization for IPython environments.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/gate_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.colab import visualization\nfrom ortools.sat.python import cp_model\n\n\ndef main(_) -> None:\n    \"\"\"Solves the gate scheduling problem.\"\"\"\n    model = cp_model.CpModel()\n\n    jobs = [\n        [3, 3],  # [duration, width]\n        [2, 5],\n        [1, 3],\n        [3, 7],\n        [7, 3],\n        [2, 2],\n        [2, 2],\n        [5, 5],\n        [10, 2],\n        [4, 3],\n        [2, 6],\n        [1, 2],\n        [6, 8],\n        [4, 5],\n        [3, 7],\n    ]\n\n    max_width = 10\n\n    horizon = sum(t[0] for t in jobs)\n    num_jobs = len(jobs)\n    all_jobs = range(num_jobs)\n\n    intervals = []\n    intervals0 = []\n    intervals1 = []\n    performed = []\n    starts = []\n    ends = []\n    demands = []\n\n    for i in all_jobs:\n        # Create main interval.\n        start = model.new_int_var(0, horizon, f\"start_{i}\")\n        duration = jobs[i][0]\n        end = model.new_int_var(0, horizon, f\"end_{i}\")\n        interval = model.new_interval_var(start, duration, end, f\"interval_{i}\")\n        starts.append(start)\n        intervals.append(interval)\n        ends.append(end)\n        demands.append(jobs[i][1])\n\n        # Create an optional copy of interval to be executed on machine 0.\n        performed_on_m0 = model.new_bool_var(f\"perform_{i}_on_m0\")\n        performed.append(performed_on_m0)\n        start0 = model.new_int_var(0, horizon, f\"start_{i}_on_m0\")\n        end0 = model.new_int_var(0, horizon, f\"end_{i}_on_m0\")\n        interval0 = model.new_optional_interval_var(\n            start0, duration, end0, performed_on_m0, f\"interval_{i}_on_m0\"\n        )\n        intervals0.append(interval0)\n\n        # Create an optional copy of interval to be executed on machine 1.\n        start1 = model.new_int_var(0, horizon, f\"start_{i}_on_m1\")\n        end1 = model.new_int_var(0, horizon, f\"end_{i}_on_m1\")\n        interval1 = model.new_optional_interval_var(\n            start1,\n            duration,\n            end1,\n            ~performed_on_m0,\n            f\"interval_{i}_on_m1\",\n        )\n        intervals1.append(interval1)\n\n        # We only propagate the constraint if the tasks is performed on the machine.\n        model.add(start0 == start).only_enforce_if(performed_on_m0)\n        model.add(start1 == start).only_enforce_if(~performed_on_m0)\n\n    # Width constraint (modeled as a cumulative)\n    model.add_cumulative(intervals, demands, max_width)\n\n    # Choose which machine to perform the jobs on.\n    model.add_no_overlap(intervals0)\n    model.add_no_overlap(intervals1)\n\n    # Objective variable.\n    makespan = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(makespan, ends)\n    model.minimize(makespan)\n\n    # Symmetry breaking.\n    model.add(performed[0] == 0)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    solver.solve(model)\n\n    # Output solution.\n    if visualization.RunFromIPython():\n        output = visualization.SvgWrapper(solver.objective_value, max_width, 40.0)\n        output.AddTitle(f\"Makespan = {solver.objective_value}\")\n        color_manager = visualization.ColorManager()\n        color_manager.SeedRandomColor(0)\n\n        for i in all_jobs:\n            performed_machine = 1 - solver.value(performed[i])\n            start_of_task = solver.value(starts[i])\n            d_x = jobs[i][0]\n            d_y = jobs[i][1]\n            s_y = performed_machine * (max_width - d_y)\n            output.AddRectangle(\n                start_of_task,\n                s_y,\n                d_x,\n                d_y,\n                color_manager.RandomColor(),\n                \"black\",\n                f\"j{i}\",\n            )\n\n        output.AddXScale()\n        output.AddYScale()\n        output.Display()\n    else:\n        print(\"Solution\")\n        print(f\"  - makespan = {solver.objective_value}\")\n        for i in all_jobs:\n            performed_machine = 1 - solver.value(performed[i])\n            start_of_task = solver.value(starts[i])\n            print(\n                f\"  - Job {i} starts at {start_of_task} on machine\"\n                f\" {performed_machine}\"\n            )\n        print(solver.response_stats())\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Steel Mill Optimization Implementation\nDESCRIPTION: Complete implementation of steel mill slab optimization including bin packing constraints, color constraints, and LNS optimization. Uses custom decision builder and random LNS operator for solution improvement.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/steel_lns.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#   Copyright 2010 Pierre Schaus pschaus@gmail.com, lperron@google.com\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\nimport argparse\nfrom ortools.constraint_solver import pywrapcp\nimport random\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\n    '--data',\n    default='examples/contrib/steel.txt',\n    help='path to data file')\nparser.add_argument(\n    '--time_limit', default=20000, type=int, help='global time limit')\nparser.add_argument(\n    '--lns_fragment_size',\n    default=10,\n    type=int,\n    help='size of the random lns fragment')\nparser.add_argument(\n    '--lns_random_seed',\n    default=0,\n    type=int,\n    help='seed for the lns random generator')\nparser.add_argument(\n    '--lns_fail_limit',\n    default=30,\n    type=int,\n    help='fail limit when exploring fragments')\n\n# ---------- helper for binpacking posting ----------\n\n\ndef BinPacking(solver, binvars, weights, loadvars):\n  \"\"\"post the load constraint on bins.\n\n  constraints forall j: loadvars[j] == sum_i (binvars[i] == j) * weights[i])\n  \"\"\"\n  pack = solver.Pack(binvars, len(binvars))\n  pack.AddWeightedSumEqualVarDimension(weights, loadvars)\n  solver.Add(pack)\n  solver.Add(solver.SumEquality(loadvars, sum(weights)))\n\n\n# ---------- data reading ----------\n\n\ndef ReadData(filename):\n  \"\"\"Read data from <filename>.\"\"\"\n  f = open(filename)\n  capacity = [int(nb) for nb in f.readline().split()]\n  capacity.pop(0)\n  capacity = [0] + capacity\n  max_capacity = max(capacity)\n  nb_colors = int(f.readline())\n  nb_slabs = int(f.readline())\n  wc = [[int(j) for j in f.readline().split()] for i in range(nb_slabs)]\n  weights = [x[0] for x in wc]\n  colors = [x[1] for x in wc]\n  loss = [\n      min([x for x in capacity if x >= c]) - c for c in range(max_capacity + 1)\n  ]\n  color_orders = [[o\n                   for o in range(nb_slabs)\n                   if colors[o] == c]\n                  for c in range(1, nb_colors + 1)]\n  print('Solving steel mill with', nb_slabs, 'slabs')\n  return (nb_slabs, capacity, max_capacity, weights, colors, loss, color_orders)\n\n\n# ---------- dedicated search for this problem ----------\n\n\nclass SteelDecisionBuilder(pywrapcp.PyDecisionBuilder):\n  \"\"\"Dedicated Decision Builder for steel mill slab.\n\n  Search for the steel mill slab problem with Dynamic Symmetry\n  Breaking during search is an adaptation (for binary tree) from the\n  paper of Pascal Van Hentenryck and Laurent Michel CPAIOR-2008.\n\n  The value heuristic comes from the paper\n  Solving Steel Mill Slab Problems with Constraint-Based Techniques:\n    CP, LNS, and CBLS,\n  Schaus et. al. to appear in Constraints 2010\n  \"\"\"\n\n  def __init__(self, x, nb_slabs, weights, loss_array, loads):\n    pywrapcp.PyDecisionBuilder.__init__(self)\n    self.__x = x\n    self.__nb_slabs = nb_slabs\n    self.__weights = weights\n    self.__loss_array = loss_array\n    self.__loads = loads\n    self.__max_capacity = len(loss_array) - 1\n\n  def Next(self, solver):\n    var, weight = self.NextVar()\n    if var:\n      v = self.MaxBound()\n      if v + 1 == var.Min():\n        # Symmetry breaking. If you need to assign to a new bin,\n        # select the first one.\n        solver.Add(var == v + 1)\n        return self.Next(solver)\n      else:\n        # value heuristic (important for difficult problem):\n        #   try first to place the order in the slab that will induce\n        #   the least increase of the loss\n        loads = self.getLoads()\n        l, v = min(\n            (self.__loss_array[loads[i] + weight], i)\n            for i in range(var.Min(),\n                           var.Max() + 1)\n            if var.Contains(i) and loads[i] + weight <= self.__max_capacity)\n        decision = solver.AssignVariableValue(var, v)\n        return decision\n    else:\n      return None\n\n  def getLoads(self):\n    load = [0] * len(self.__loads)\n    for (w, x) in zip(self.__weights, self.__x):\n      if x.Bound():\n        load[x.Min()] += w\n    return load\n\n  def MaxBound(self):\n    \"\"\" returns the max value bound to a variable, -1 if no variables bound\"\"\"\n    return max([-1] + [\n        self.__x[o].Min()\n        for o in range(self.__nb_slabs)\n        if self.__x[o].Bound()\n    ])\n\n  def NextVar(self):\n    \"\"\" mindom size heuristic with tie break on the weights of orders \"\"\"\n    res = [(self.__x[o].Size(), -self.__weights[o], self.__x[o])\n           for o in range(self.__nb_slabs)\n           if self.__x[o].Size() > 1]\n    if res:\n      res.sort()\n      return (res[0][2], -res[0][1])  # returns the order var and its weight\n    else:\n      return (None, None)\n\n  def DebugString(self):\n    return 'SteelMillDecisionBuilder(' + str(self.__x) + ')'\n\n\n# ----------- LNS Operator ----------\n\n\nclass SteelRandomLns(pywrapcp.BaseLns):\n  \"\"\"Random LNS for Steel.\"\"\"\n\n  def __init__(self, x, rand, lns_size):\n    pywrapcp.BaseLns.__init__(self, x)\n    self.__random = rand\n    self.__lns_size = lns_size\n\n  def InitFragments(self):\n    pass\n\n  def NextFragment(self):\n    while self.FragmentSize() < self.__lns_size:\n      pos = self.__random.randint(0, self.Size() - 1)\n      self.AppendToFragment(pos)\n    return True\n\n\n# ----------- Main Function -----------\n\n\ndef main(args):\n  # ----- solver and variable declaration -----\n  (nb_slabs, capacity, max_capacity, weights, colors, loss, color_orders) =\\\n      ReadData(args.data)\n  nb_colors = len(color_orders)\n  solver = pywrapcp.Solver('Steel Mill Slab')\n  x = [solver.IntVar(0, nb_slabs - 1, 'x' + str(i)) for i in range(nb_slabs)]\n  load_vars = [\n      solver.IntVar(0, max_capacity - 1, 'load_vars' + str(i))\n      for i in range(nb_slabs)\n  ]\n\n  # ----- post of the constraints -----\n\n  # Bin Packing.\n  BinPacking(solver, x, weights, load_vars)\n  # At most two colors per slab.\n  for s in range(nb_slabs):\n    solver.Add(\n        solver.SumLessOrEqual([\n            solver.Max([solver.IsEqualCstVar(x[c], s)\n                        for c in o])\n            for o in color_orders\n        ], 2))\n\n  # ----- Objective -----\n\n  objective_var = \\\n      solver.Sum([load_vars[s].IndexOf(loss) for s in range(nb_slabs)]).Var()\n  objective = solver.Minimize(objective_var, 1)\n\n  # ----- start the search and optimization -----\n\n  assign_db = SteelDecisionBuilder(x, nb_slabs, weights, loss, load_vars)\n  first_solution = solver.Assignment()\n  first_solution.Add(x)\n  first_solution.AddObjective(objective_var)\n  store_db = solver.StoreAssignment(first_solution)\n  first_solution_db = solver.Compose([assign_db, store_db])\n  print('searching for initial solution,', end=' ')\n  solver.Solve(first_solution_db)\n  print('initial cost =', first_solution.ObjectiveValue())\n\n  # To search a fragment, we use a basic randomized decision builder.\n  # We can also use assign_db instead of inner_db.\n  inner_db = solver.Phase(x, solver.CHOOSE_RANDOM, solver.ASSIGN_MIN_VALUE)\n  # The most important aspect is to limit the time exploring each fragment.\n  inner_limit = solver.FailuresLimit(args.lns_fail_limit)\n  continuation_db = solver.SolveOnce(inner_db, [inner_limit])\n\n  # Now, we create the LNS objects.\n  rand = random.Random()\n  rand.seed(args.lns_random_seed)\n  local_search_operator = SteelRandomLns(x, rand, args.lns_fragment_size)\n  # This is in fact equivalent to the following predefined LNS operator:\n  # local_search_operator = solver.RandomLNSOperator(x,\n  #                                                  args.lns_fragment_size,\n  #                                                  args.lns_random_seed)\n  local_search_parameters = solver.LocalSearchPhaseParameters(\n      objective_var, local_search_operator, continuation_db)\n  local_search_db = solver.LocalSearchPhase(first_solution,\n                                            local_search_parameters)\n  global_limit = solver.TimeLimit(args.time_limit)\n\n  print('using LNS to improve the initial solution')\n\n  search_log = solver.SearchLog(100000, objective_var)\n  solver.NewSearch(local_search_db, [objective, search_log, global_limit])\n  while solver.NextSolution():\n    print('Objective:', objective_var.Value(),\\\n        'check:', sum(loss[load_vars[s].Min()] for s in range(nb_slabs)))\n  solver.EndSearch()\n\n\nmain(parser.parse_args())\n```\n\n----------------------------------------\n\nTITLE: Main Prize Collecting TSP Solver Implementation\nDESCRIPTION: Main implementation of the Prize Collecting TSP solver using CP-SAT. Creates the optimization model with circuit constraints, node visit requirements, and distance limitations. Maximizes collected values while minimizing travel distance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef prize_collecting_tsp():\n    \"\"\"Entry point of the program.\"\"\"\n    num_nodes = len(DISTANCE_MATRIX)\n    all_nodes = range(num_nodes)\n    print(f\"Num nodes = {num_nodes}\")\n\n    # Model.\n    model = cp_model.CpModel()\n\n    obj_vars = []\n    obj_coeffs = []\n    visited_nodes = []\n    used_arcs = {}\n\n    # Create the circuit constraint.\n    arcs = []\n    for i in all_nodes:\n        is_visited = model.new_bool_var(f\"{i} is visited\")\n        arcs.append((i, i, ~is_visited))\n\n        obj_vars.append(is_visited)\n        obj_coeffs.append(VISIT_VALUES[i])\n        visited_nodes.append(is_visited)\n\n        for j in all_nodes:\n            if i == j:\n                used_arcs[i, j] = ~is_visited\n                continue\n            arc_is_used = model.new_bool_var(f\"{j} follows {i}\")\n            arcs.append((i, j, arc_is_used))\n\n            obj_vars.append(arc_is_used)\n            obj_coeffs.append(-DISTANCE_MATRIX[i][j])\n            used_arcs[i, j] = arc_is_used\n\n    model.add_circuit(arcs)\n\n    # Node 0 must be visited.\n    model.add(visited_nodes[0] == 1)\n\n    # limit the route distance\n    model.add(\n        sum(\n            used_arcs[i, j] * DISTANCE_MATRIX[i][j]\n            for i in all_nodes\n            for j in all_nodes\n        )\n        <= MAX_DISTANCE\n    )\n\n    # Maximize visited node values minus the travelled distance.\n    model.maximize(sum(obj_vars[i] * obj_coeffs[i] for i in range(len(obj_vars))))\n\n    # Solve and print out the solution.\n    solver = cp_model.CpSolver()\n    # To benefit from the linearization of the circuit constraint.\n    solver.parameters.max_time_in_seconds = 15.0\n    solver.parameters.num_search_workers = 8\n    solver.parameters.log_search_progress = True\n\n    status = solver.solve(model)\n    if status == cp_model.FEASIBLE or status == cp_model.OPTIMAL:\n        print_solution(solver, visited_nodes, used_arcs, num_nodes)\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem Using OR-Tools CP Solver\nDESCRIPTION: Implementation of the assignment problem solver using Google's CP Solver. The code sets up variables, constraints for task assignments, and minimizes the total cost of the assignment. It then finds and displays optimal solutions showing which worker should handle each task.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/assignment.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(cost, rows, cols):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n\n  # declare variables\n  total_cost = solver.IntVar(0, 100, \"total_cost\")\n  x = []\n  for i in range(rows):\n    t = []\n    for j in range(cols):\n      t.append(solver.IntVar(0, 1, \"x[%i,%i]\" % (i, j)))\n    x.append(t)\n  x_flat = [x[i][j] for i in range(rows) for j in range(cols)]\n\n  #\n  # constraints\n  #\n\n  # total_cost\n  solver.Add(total_cost == solver.Sum(\n      [solver.ScalProd(x_row, cost_row) for (x_row, cost_row) in zip(x, cost)]))\n\n  # exacly one assignment per row, all rows must be assigned\n  [\n      solver.Add(solver.Sum([x[row][j]\n                             for j in range(cols)]) == 1)\n      for row in range(rows)\n  ]\n\n  # zero or one assignments per column\n  [\n      solver.Add(solver.Sum([x[i][col]\n                             for i in range(rows)]) <= 1)\n      for col in range(cols)\n  ]\n\n  objective = solver.Minimize(total_cost, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x_flat)\n  solution.Add(total_cost)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x_flat, solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"total_cost:\", total_cost.Value())\n    for i in range(rows):\n      for j in range(cols):\n        print(x[i][j].Value(), end=\" \")\n      print()\n    print()\n\n    for i in range(rows):\n      print(\"Task:\", i, end=\" \")\n      for j in range(cols):\n        if x[i][j].Value() == 1:\n          print(\" is done by \", j)\n    print()\n\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\n# Problem instance\n# hakank: I added the fifth column to make it more\n#         interesting\nrows = 4\ncols = 5\ncost = [[14, 5, 8, 7, 15], [2, 12, 6, 5, 3], [7, 8, 3, 9, 7], [2, 4, 6, 10, 1]]\n\nmain(cost, rows, cols)\n```\n\n----------------------------------------\n\nTITLE: Stable Marriage Problem Solver Implementation\nDESCRIPTION: Complete implementation of the Stable Marriage Problem solver using CP-SAT, including a solution printer class and the main solving logic. The code handles preference rankings for men and women and finds stable matching solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stable_marriage_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n\n  def __init__(self, wife, husband):\n    cp_model.CpSolverSolutionCallback.__init__(self)\n    self.__wife = wife\n    self.__husband = husband\n    self.__solution_count = 0\n    self.__n = len(wife)\n\n  def OnSolutionCallback(self):\n    self.__solution_count += 1\n    print(\"Solution %i\" % self.__solution_count)\n    print(\"wife   : \", [self.Value(self.__wife[i]) for i in range(self.__n)])\n    print(\"husband: \", [self.Value(self.__husband[i]) for i in range(self.__n)])\n    print()\n\n  def SolutionCount(self):\n    return self.__solution_count\n\n\ndef main(ranks, pair_num):\n  mrank = ranks[\"rankMen\"]\n  wrank = ranks[\"rankWomen\"]\n\n  n = pair_num\n\n  model = cp_model.CpModel()\n\n  wife = [model.NewIntVar(0, n - 1, \"wife[%i]\" % i) for i in range(n)]\n  husband = [model.NewIntVar(0, n - 1, \"husband[%i]\" % i) for i in range(n)]\n\n  for m in range(n):\n    model.AddElement(wife[m], husband, m)\n\n  for w in range(n):\n    model.AddElement(husband[w], wife, w)\n\n  #mrank[w][m] < mrank[w][husband[w]] => wrank[m][wife[m]] < wrank[m][w]\n  for w in range(n):\n    for m in range(n):\n      husband_rank = model.NewIntVar(1, n, \"\")\n      model.AddElement(husband[w], mrank[w], husband_rank)\n\n      wife_rank = model.NewIntVar(1, n, \"\")\n      model.AddElement(wife[m], wrank[m], wife_rank)\n\n      husband_dominated = model.NewBoolVar(\"\")\n      model.Add(mrank[w][m] < husband_rank).OnlyEnforceIf(husband_dominated)\n      model.Add(mrank[w][m] >= husband_rank).OnlyEnforceIf(\n          husband_dominated.Not())\n\n      wife_dominates = model.NewBoolVar(\"\")\n      model.Add(wife_rank < wrank[m][w]).OnlyEnforceIf(wife_dominates)\n      model.Add(wife_rank >= wrank[m][w]).OnlyEnforceIf(wife_dominates.Not())\n\n      model.AddImplication(husband_dominated, wife_dominates)\n\n  #wrank[m][w] < wrank[m][wife[m]] => mrank[w][husband[w]] < mrank[w][m]\n  for m in range(n):\n    for w in range(n):\n      wife_rank = model.NewIntVar(1, n, \"\")\n      model.AddElement(wife[m], wrank[m], wife_rank)\n\n      husband_rank = model.NewIntVar(1, n, \"\")\n      model.AddElement(husband[w], mrank[w], husband_rank)\n\n      wife_dominated = model.NewBoolVar(\"\")\n      model.Add(wrank[m][w] < wife_rank).OnlyEnforceIf(wife_dominated)\n      model.Add(wrank[m][w] >= wife_rank).OnlyEnforceIf(wife_dominated.Not())\n\n      husband_dominates = model.NewBoolVar(\"\")\n      model.Add(husband_rank < mrank[w][m]).OnlyEnforceIf(husband_dominates)\n      model.Add(husband_rank >= mrank[w][m]).OnlyEnforceIf(\n          husband_dominates.Not())\n\n      model.AddImplication(wife_dominated, husband_dominates)\n\n  solver = cp_model.CpSolver()\n  solution_printer = SolutionPrinter(wife, husband)\n  solver.parameters.enumerate_all_solutions = True\n  solver.Solve(model, solution_printer)\n\n\nrankings1 = {\n    \"rankMen\": [[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4], [3, 4, 1, 2]],\n    \"rankWomen\": [[1, 2, 3, 4], [2, 1, 3, 4], [1, 4, 3, 2], [4, 3, 1, 2]]\n}\n\nrankings2 = {\n    \"rankMen\": [[1, 5, 4, 6, 2, 3], [4, 1, 5, 2, 6, 3], [6, 4, 2, 1, 5, 3],\n                [1, 5, 2, 4, 3, 6], [4, 2, 1, 5, 6, 3], [2, 6, 3, 5, 1, 4]],\n    \"rankWomen\": [[1, 4, 2, 5, 6, 3], [3, 4, 6, 1, 5, 2], [1, 6, 4, 2, 3, 5],\n                  [6, 5, 3, 4, 2, 1], [3, 1, 2, 4, 5, 6], [2, 3, 1, 6, 5, 4]]\n}\n\nproblem = rankings2\ncouple_count = len(problem[\"rankMen\"])\n\nmain(problem, couple_count)\n```\n\n----------------------------------------\n\nTITLE: Wedding Seating Optimization Implementation\nDESCRIPTION: Complete implementation of the wedding seating chart optimizer using OR-Tools. The program defines guest relationships in a connection matrix, applies constraints for table capacity and minimum known guests per table, and finds an optimal seating arrangement that maximizes social connections.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/wedding_optimal_chart.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\nfrom ortools.constraint_solver import solver_parameters_pb2\n\ndef main():\n  parameters = pywrapcp.Solver.DefaultSolverParameters()\n  solver = pywrapcp.Solver(\"WeddingOptimalChart\", parameters)\n\n  n = 5  # number of tables\n  a = 4  # maximum number of guests a table can seat\n  b = 1  # minimum number of people each guest knows at their table\n\n  C = [[1, 50, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [50, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 1, 50, 1, 1, 1, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 50, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 1, 1, 1, 50, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 1, 1, 50, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 1, 1, 1, 1, 1, 50, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 1, 1, 1, 1, 50, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 50, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\n\n  names = [\n      \"Deb (B)\", \"John (B)\", \"Martha (B)\", \"Travis (B)\", \"Allan (B)\",\n      \"Lois (B)\", \"Jayne (B)\", \"Brad (B)\", \"Abby (B)\", \"Mary Helen (G)\",\n      \"Lee (G)\", \"Annika (G)\", \"Carl (G)\", \"Colin (G)\", \"Shirley (G)\",\n      \"DeAnn (G)\", \"Lori (G)\"\n  ]\n\n  m = len(C)\n  NRANGE = range(n)\n  MRANGE = range(m)\n\n  tables = [solver.IntVar(0, n - 1, \"x[%i]\" % i) for i in MRANGE]\n\n  z = solver.Sum([\n      C[j][k] * (tables[j] == tables[k])\n      for j in MRANGE\n      for k in MRANGE\n      if j < k\n  ])\n\n  for i in NRANGE:\n    minGuests = [(tables[j] == i) * (tables[k] == i)\n                 for j in MRANGE\n                 for k in MRANGE\n                 if j < k and C[j][k] > 0]\n    solver.Add(solver.Sum(minGuests) >= b)\n\n    maxGuests = [tables[j] == i for j in MRANGE]\n    solver.Add(solver.Sum(maxGuests) <= a)\n\n  solver.Add(tables[0] == 0)\n\n  objective = solver.Maximize(z, 1)\n\n  db = solver.Phase(tables, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db, [objective])\n\n  while solver.NextSolution():\n    print(\"z:\", z)\n    print(\"Table: \")\n    for j in MRANGE:\n      print(tables[j].Value(), \" \")\n    print()\n\n    for i in NRANGE:\n      print(\"Table %d: \" % i)\n      for j in MRANGE:\n        if tables[j].Value() == i:\n          print(names[j] + \" \")\n      print()\n\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"Solutions: %d\" % solver.Solutions())\n  print(\"WallTime: %dms\" % solver.WallTime())\n  print(\"Failures: %d\" % solver.Failures())\n  print(\"Branches: %d\" % solver.Branches())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: JobShop FT06 Distance Implementation\nDESCRIPTION: Complete implementation of the FT06 jobshop scheduling problem with distance constraints. Uses CP-SAT solver to minimize makespan while handling job sequencing, machine constraints, and minimum distances between jobs. Includes problem definition, constraint modeling, and solution output.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/jobshop_ft06_distance_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\n\nfrom ortools.sat.python import cp_model\n\n\ndef distance_between_jobs(x: int, y: int) -> int:\n    \"\"\"Returns the distance between tasks of job x and tasks of job y.\"\"\"\n    return abs(x - y)\n\n\ndef jobshop_ft06_distance() -> None:\n    \"\"\"Solves the ft06 jobshop with distances between tasks.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    machines_count = 6\n    jobs_count = 6\n    all_machines = range(0, machines_count)\n    all_jobs = range(0, jobs_count)\n\n    durations = [\n        [1, 3, 6, 7, 3, 6],\n        [8, 5, 10, 10, 10, 4],\n        [5, 4, 8, 9, 1, 7],\n        [5, 5, 5, 3, 8, 9],\n        [9, 3, 5, 4, 3, 1],\n        [3, 3, 9, 10, 4, 1],\n    ]\n\n    machines = [\n        [2, 0, 1, 3, 5, 4],\n        [1, 2, 4, 5, 0, 3],\n        [2, 3, 5, 0, 1, 4],\n        [1, 0, 2, 3, 4, 5],\n        [2, 1, 4, 5, 0, 3],\n        [1, 3, 5, 0, 4, 2],\n    ]\n\n    # Computes horizon statically.\n    horizon = 150\n\n    task_type = collections.namedtuple(\"task_type\", \"start end interval\")\n\n    # Creates jobs.\n    all_tasks = {}\n    for i in all_jobs:\n        for j in all_machines:\n            start_var = model.new_int_var(0, horizon, f\"start_{i}_{j}\")\n            duration = durations[i][j]\n            end_var = model.new_int_var(0, horizon, f\"end_{i}_{j}\")\n            interval_var = model.new_interval_var(\n                start_var, duration, end_var, f\"interval_{i}_{j}\"\n            )\n            all_tasks[(i, j)] = task_type(\n                start=start_var, end=end_var, interval=interval_var\n            )\n\n    # Create disjuctive constraints.\n    for i in all_machines:\n        job_intervals = []\n        job_indices = []\n        job_starts = []\n        job_ends = []\n        for j in all_jobs:\n            for k in all_machines:\n                if machines[j][k] == i:\n                    job_intervals.append(all_tasks[(j, k)].interval)\n                    job_indices.append(j)\n                    job_starts.append(all_tasks[(j, k)].start)\n                    job_ends.append(all_tasks[(j, k)].end)\n        model.add_no_overlap(job_intervals)\n\n        arcs = []\n        for j1 in range(len(job_intervals)):\n            # Initial arc from the dummy node (0) to a task.\n            start_lit = model.new_bool_var(f\"{j1} is first job\")\n            arcs.append((0, j1 + 1, start_lit))\n            # Final arc from an arc to the dummy node.\n            arcs.append((j1 + 1, 0, model.new_bool_var(f\"{j1} is last job\")))\n\n            for j2 in range(len(job_intervals)):\n                if j1 == j2:\n                    continue\n\n                lit = model.new_bool_var(f\"{j2} follows {j1}\")\n                arcs.append((j1 + 1, j2 + 1, lit))\n\n                # We add the reified precedence to link the literal with the\n                # times of the two tasks.\n                min_distance = distance_between_jobs(j1, j2)\n                model.add(\n                    job_starts[j2] >= job_ends[j1] + min_distance\n                ).only_enforce_if(lit)\n\n        model.add_circuit(arcs)\n\n    # Precedences inside a job.\n    for i in all_jobs:\n        for j in range(0, machines_count - 1):\n            model.add(all_tasks[(i, j + 1)].start >= all_tasks[(i, j)].end)\n\n    # Makespan objective.\n    obj_var = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(\n        obj_var, [all_tasks[(i, machines_count - 1)].end for i in all_jobs]\n    )\n    model.minimize(obj_var)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Output solution.\n    if status == cp_model.OPTIMAL:\n        print(f\"Optimal makespan: {solver.objective_value}\")\n    print(solver.response_stats())\n\n\njobshop_ft06_distance()\n```\n\n----------------------------------------\n\nTITLE: Solving Zebra Puzzle using OR-Tools in Python\nDESCRIPTION: This snippet defines the solve_zebra function which creates a constraint satisfaction model using OR-Tools. It sets up integer variables for houses, people, pets, drinks, and cigars, adds all-different constraints, and establishes specific relationships between variables as per the Zebra problem clues. The solver finds and prints the solution, identifying who drinks water and who owns the zebra.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/zebra_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\n# pylint: disable=too-many-statements\ndef solve_zebra():\n    \"\"\"Solves the zebra problem.\"\"\"\n\n    # Create the model.\n    model = cp_model.CpModel()\n\n    red = model.new_int_var(1, 5, \"red\")\n    green = model.new_int_var(1, 5, \"green\")\n    yellow = model.new_int_var(1, 5, \"yellow\")\n    blue = model.new_int_var(1, 5, \"blue\")\n    ivory = model.new_int_var(1, 5, \"ivory\")\n\n    englishman = model.new_int_var(1, 5, \"englishman\")\n    spaniard = model.new_int_var(1, 5, \"spaniard\")\n    japanese = model.new_int_var(1, 5, \"japanese\")\n    ukrainian = model.new_int_var(1, 5, \"ukrainian\")\n    norwegian = model.new_int_var(1, 5, \"norwegian\")\n\n    dog = model.new_int_var(1, 5, \"dog\")\n    snails = model.new_int_var(1, 5, \"snails\")\n    fox = model.new_int_var(1, 5, \"fox\")\n    zebra = model.new_int_var(1, 5, \"zebra\")\n    horse = model.new_int_var(1, 5, \"horse\")\n\n    tea = model.new_int_var(1, 5, \"tea\")\n    coffee = model.new_int_var(1, 5, \"coffee\")\n    water = model.new_int_var(1, 5, \"water\")\n    milk = model.new_int_var(1, 5, \"milk\")\n    fruit_juice = model.new_int_var(1, 5, \"fruit juice\")\n\n    old_gold = model.new_int_var(1, 5, \"old gold\")\n    kools = model.new_int_var(1, 5, \"kools\")\n    chesterfields = model.new_int_var(1, 5, \"chesterfields\")\n    lucky_strike = model.new_int_var(1, 5, \"lucky strike\")\n    parliaments = model.new_int_var(1, 5, \"parliaments\")\n\n    model.add_all_different(red, green, yellow, blue, ivory)\n    model.add_all_different(englishman, spaniard, japanese, ukrainian, norwegian)\n    model.add_all_different(dog, snails, fox, zebra, horse)\n    model.add_all_different(tea, coffee, water, milk, fruit_juice)\n    model.add_all_different(parliaments, kools, chesterfields, lucky_strike, old_gold)\n\n    model.add(englishman == red)\n    model.add(spaniard == dog)\n    model.add(coffee == green)\n    model.add(ukrainian == tea)\n    model.add(green == ivory + 1)\n    model.add(old_gold == snails)\n    model.add(kools == yellow)\n    model.add(milk == 3)\n    model.add(norwegian == 1)\n\n    diff_fox_chesterfields = model.new_int_var(-4, 4, \"diff_fox_chesterfields\")\n    model.add(diff_fox_chesterfields == fox - chesterfields)\n    model.add_abs_equality(1, diff_fox_chesterfields)\n\n    diff_horse_kools = model.new_int_var(-4, 4, \"diff_horse_kools\")\n    model.add(diff_horse_kools == horse - kools)\n    model.add_abs_equality(1, diff_horse_kools)\n\n    model.add(lucky_strike == fruit_juice)\n    model.add(japanese == parliaments)\n\n    diff_norwegian_blue = model.new_int_var(-4, 4, \"diff_norwegian_blue\")\n    model.add(diff_norwegian_blue == norwegian - blue)\n    model.add_abs_equality(1, diff_norwegian_blue)\n\n    # Solve and print out the solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        people = [englishman, spaniard, japanese, ukrainian, norwegian]\n        water_drinker = [p for p in people if solver.value(p) == solver.value(water)][0]\n        zebra_owner = [p for p in people if solver.value(p) == solver.value(zebra)][0]\n        print(\"The\", water_drinker.name, \"drinks water.\")\n        print(\"The\", zebra_owner.name, \"owns the zebra.\")\n    else:\n        print(\"No solutions to the zebra problem, this is unusual!\")\n\n\nsolve_zebra()\n```\n\n----------------------------------------\n\nTITLE: Solving Just Forgotten Puzzle with OR-Tools in Python\nDESCRIPTION: This code snippet implements a solution to the Just Forgotten puzzle using Google OR-Tools. It creates a constraint satisfaction problem, defines variables and constraints based on the puzzle rules, and searches for a solution that satisfies all constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/just_forgotten.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Just forgotten\")\n\n  #\n  # data\n  #\n  rows = 4\n  cols = 10\n  # The four tries\n  a = [[9, 4, 6, 2, 1, 5, 7, 8, 3, 0], [8, 6, 0, 4, 3, 9, 1, 2, 5, 7],\n       [1, 6, 4, 0, 2, 9, 7, 8, 5, 3], [6, 8, 2, 4, 3, 1, 9, 0, 7, 5]]\n\n  #\n  # variables\n  #\n  x = [solver.IntVar(0, 9, \"x[%i]\" % j) for j in range(cols)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n\n  for r in range(rows):\n    b = [solver.IsEqualCstVar(x[c], a[r][c]) for c in range(cols)]\n    solver.Add(solver.Sum(b) == 4)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(x, solver.INT_VAR_SIMPLE, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    xval = [x[j].Value() for j in range(cols)]\n    print(\"Account number:\")\n    for j in range(cols):\n      print(\"%i \" % xval[j], end=\" \")\n    print()\n    print(\"\\nThe four tries, where '!' represents a correct digit:\")\n    for i in range(rows):\n      for j in range(cols):\n        check = \" \"\n        if a[i][j] == xval[j]:\n          check = \"!\"\n        print(\"%i%s\" % (a[i][j], check), end=\" \")\n      print()\n    print()\n  print()\n\n  solver.EndSearch()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Bin-Packing Problem with CP-SAT\nDESCRIPTION: This code defines a function `binpacking_problem_sat` that formulates and solves a bin packing problem using the CP-SAT solver. It defines the problem, creates the CP-SAT model, defines variables representing items in bins and bin loads, adds constraints for item placement and capacity, and maximizes the sum of slacks (unused capacity). The solver finds the optimal solution and prints the solve status, objective value (if optimal), and statistics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/binpacking_problem_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.sat.python import cp_model\n\n\ndef binpacking_problem_sat():\n    \\\"\\\"\\\"Solves a bin-packing problem using the CP-SAT solver.\\\"\\\"\\\"    # Data.\n    bin_capacity = 100\n    slack_capacity = 20\n    num_bins = 5\n    all_bins = range(num_bins)\n\n    items = [(20, 6), (15, 6), (30, 4), (45, 3)]\n    num_items = len(items)\n    all_items = range(num_items)\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Main variables.\n    x = {}\n    for i in all_items:\n        num_copies = items[i][1]\n        for b in all_bins:\n            x[(i, b)] = model.new_int_var(0, num_copies, f\\\"x[{i},{b}]\\\"\n)\n\n    # Load variables.\n    load = [model.new_int_var(0, bin_capacity, f\\\"load[{b}]\\\") for b in all_bins]\n\n    # Slack variables.\n    slacks = [model.new_bool_var(f\\\"slack[{b}]\\\") for b in all_bins]\n\n    # Links load and x.\n    for b in all_bins:\n        model.add(load[b] == sum(x[(i, b)] * items[i][0] for i in all_items))\n\n    # Place all items.\n    for i in all_items:\n        model.add(sum(x[(i, b)] for b in all_bins) == items[i][1])\n\n    # Links load and slack through an equivalence relation.\n    safe_capacity = bin_capacity - slack_capacity\n    for b in all_bins:\n        # slack[b] => load[b] <= safe_capacity.\n        model.add(load[b] <= safe_capacity).only_enforce_if(slacks[b])\n        # not(slack[b]) => load[b] > safe_capacity.\n        model.add(load[b] > safe_capacity).only_enforce_if(~slacks[b])\n\n    # Maximize sum of slacks.\n    model.maximize(sum(slacks))\n\n    # Solves and prints out the solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n    print(f\\\"solve status: {solver.status_name(status)}\\\")\n    if status == cp_model.OPTIMAL:\n        print(f\\\"Optimal objective value: {solver.objective_value}\\\")\n    print(\\\"Statistics\\\")\n    print(f\\\"  - conflicts : {solver.num_conflicts}\\\")\n    print(f\\\"  - branches  : {solver.num_branches}\\\")\n    print(f\\\"  - wall time : {solver.wall_time}s\\\")\n\n\nbinpacking_problem_sat()\"\n```\n\n----------------------------------------\n\nTITLE: Solving Group Balancing Problem with CP-SAT in Python\nDESCRIPTION: This function sets up and solves the group balancing problem using the CP-SAT solver. It defines the problem constraints, creates decision variables, and minimizes the deviation of group sums from the average. The function also handles color constraints and prints the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/balance_group_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    \"\"\"Solves a group balancing problem.\"\"\"\n\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    # Data.\n    num_groups = 10\n    num_items = 100\n    num_colors = 3\n    min_items_of_same_color_per_group = 4\n\n    all_groups = range(num_groups)\n    all_items = range(num_items)\n    all_colors = range(num_colors)\n\n    # values for each items.\n    values = [1 + i + (i * i // 200) for i in all_items]\n    # Color for each item (simple modulo).\n    colors = [i % num_colors for i in all_items]\n\n    sum_of_values = sum(values)\n    average_sum_per_group = sum_of_values // num_groups\n\n    num_items_per_group = num_items // num_groups\n\n    # Collect all items in a given color.\n    items_per_color: Dict[int, list[int]] = {}\n    for color in all_colors:\n        items_per_color[color] = []\n        for i in all_items:\n            if colors[i] == color:\n                items_per_color[color].append(i)\n\n    print(\n        f\"Model has {num_items} items, {num_groups} groups, and\" f\" {num_colors} colors\"\n    )\n    print(f\"  average sum per group = {average_sum_per_group}\")\n\n    # Model.\n\n    model = cp_model.CpModel()\n\n    item_in_group = {}\n    for i in all_items:\n        for g in all_groups:\n            item_in_group[(i, g)] = model.new_bool_var(f\"item {i} in group {g}\")\n\n    # Each group must have the same size.\n    for g in all_groups:\n        model.add(sum(item_in_group[(i, g)] for i in all_items) == num_items_per_group)\n\n    # One item must belong to exactly one group.\n    for i in all_items:\n        model.add(sum(item_in_group[(i, g)] for g in all_groups) == 1)\n\n    # The deviation of the sum of each items in a group against the average.\n    e = model.new_int_var(0, 550, \"epsilon\")\n\n    # Constrain the sum of values in one group around the average sum per group.\n    for g in all_groups:\n        model.add(\n            sum(item_in_group[(i, g)] * values[i] for i in all_items)\n            <= average_sum_per_group + e\n        )\n        model.add(\n            sum(item_in_group[(i, g)] * values[i] for i in all_items)\n            >= average_sum_per_group - e\n        )\n\n    # color_in_group variables.\n    color_in_group = {}\n    for g in all_groups:\n        for c in all_colors:\n            color_in_group[(c, g)] = model.new_bool_var(f\"color {c} is in group {g}\")\n\n    # Item is in a group implies its color is in that group.\n    for i in all_items:\n        for g in all_groups:\n            model.add_implication(item_in_group[(i, g)], color_in_group[(colors[i], g)])\n\n    # If a color is in a group, it must contains at least\n    # min_items_of_same_color_per_group items from that color.\n    for c in all_colors:\n        for g in all_groups:\n            literal = color_in_group[(c, g)]\n            model.add(\n                sum(item_in_group[(i, g)] for i in items_per_color[c])\n                >= min_items_of_same_color_per_group\n            ).only_enforce_if(literal)\n\n    # Compute the maximum number of colors in a group.\n    max_color = num_items_per_group // min_items_of_same_color_per_group\n\n    # Redundant constraint, it helps with solving time.\n    if max_color < num_colors:\n        for g in all_groups:\n            model.add(sum(color_in_group[(c, g)] for c in all_colors) <= max_color)\n\n    # minimize epsilon\n    model.minimize(e)\n\n    solver = cp_model.CpSolver()\n    # solver.parameters.log_search_progress = True\n    solver.parameters.num_workers = 16\n    solution_printer = SolutionPrinter(\n        values, colors, all_groups, all_items, item_in_group\n    )\n    status = solver.solve(model, solution_printer)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"Optimal epsilon: {solver.objective_value}\")\n        print(solver.response_stats())\n    else:\n        print(\"No solution found\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Main Sports Scheduling Function using CP-SAT Solver\nDESCRIPTION: Implements the 'assign_matches' function that sets up and solves the sports scheduling problem using OR-Tools' CP-SAT solver. It creates variables for fixtures and home/away status, adds constraints for matchups and game distribution, and sets up the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef assign_matches(num_teams,\n                   num_matchdays,\n                   num_matches_per_day,\n                   max_home_stand,\n                   time_limit=None,\n                   num_cpus=None,\n                   csv=None,\n                   debug=None):\n    \"\"\"Assign matches between teams in a league.\n\n    Keyword arguments:\n    num_teams -- the number of teams\n    num_matchdays -- the number of match days to play.  Should be greater than one day.  Note that if num_matchdays is exactly some multipe (`n`) of `num_teams - 1` then each team with play every other team exactly `n` times.  If the number of match days is less than or greater than a perfect multiple, then some teams will not play each other `n` times.\n    num_matches_per_day -- how many matches can be played in a day.  The assumption is one match per day, and really this code was not tested with different values.\n    max_home_stand -- how many home games are allowed to be in a row.\n    time_limit -- the time in minutes to allow the solver to work on the problem.\n    num_cpus -- the number of processors to use for the solution\n    csv -- a file name to save the output to a CSV file\n    debug -- boolean value stating whether to ask the solver to show its progress or not\n\n    \"\"\"\n\n    model = cp_model.CpModel()\n\n    print('num_teams', num_teams, 'num_matchdays', num_matchdays,\n          'num_matches_per_day', num_matches_per_day, 'max_home_stand',\n          max_home_stand)\n\n    matchdays = range(num_matchdays)\n    matches = range(num_matches_per_day)\n    teams = range(num_teams)\n    # how many possible unique games?\n    unique_games = (num_teams) * (num_teams - 1) / 2\n\n    # how many games are possible to play\n    total_games = num_matchdays * num_matches_per_day\n\n    # maximum possible games versus an opponent.  example, if 20\n    # possible total games, and 28 unique combinations, then 20 // 28\n    # +1 = 1.  If 90 total games (say 5 per day for 18 match days) and\n    # 10 teams for 45 possible unique combinations of teams, then 90\n    # // 45 + 1 = 3. Hmm.  Should be 2\n    matchups = int((total_games // unique_games) + 1)\n    # print(matchups)\n    # there is a special case, if total games / unique games == total\n    # games // unique games, then the constraint can be ==, not <=\n    matchups_exact = False\n    if (total_games % unique_games == 0):\n        matchups_exact = True\n        matchups = int(total_games // unique_games)\n\n    print('expected matchups per pair', matchups, 'exact?', matchups_exact)\n\n    days_to_play = int(unique_games // num_matches_per_day)\n    print('unique_games', unique_games, '\\nnum matches per day',\n          num_matches_per_day, '\\ndays to play', days_to_play,\n          '\\ntotal games possible', total_games)\n\n    fixtures = [\n    ]  # all possible games, list of lists of lists: fixture[day][iteam][jteam]\n    at_home = [\n    ]  # whether or not a team plays at home on matchday, list of lists\n\n    # Does team i receive team j at home on day d?\n    for d in matchdays:\n        # hackity hack, append a new list for all possible fixtures for a team on day d\n        fixtures.append([])\n        for i in teams:\n            # hackity hack, append a list of possible fixtures for team i\n            fixtures[d].append([])\n            for j in teams:\n                # for each possible away opponent for home team i, add a fixture\n                #\n                # note that the fixture is not only that team i plays\n                # team j, but also that team i is the home team and\n                # team j is the away team.\n                fixtures[d][i].append(\n                    model.NewBoolVar(\n                        'fixture: home team %i, opponent %i, matchday %i' %\n                        (i, j, d)))\n                if i == j:\n                    # It is not possible for team i to play itself,\n                    # but it is cleaner to add the fixture than it is\n                    # to skip it---the list stays the length of the\n                    # number of teams.  The C++ version adds a \"FalseVar\" instead\n                    model.Add(fixtures[d][i][j] == 0)  # forbid playing self\n\n    # Is team t at home on day d?\n    for d in matchdays:\n        # hackity hack, append a new list for whether or not a team is at home on day d\n        at_home.append([])\n        for i in teams:\n            # is team i playing at home on day d?\n            at_home[d].append(\n                model.NewBoolVar('team %i is home on matchday %i' % (i, d)))\n\n    # each day, team t plays either home or away, but only once\n    for d in matchdays:\n        for t in teams:\n            # for each team, each day, list possible opponents\n            possible_opponents = []\n            for opponent in teams:\n                if t == opponent:\n                    continue\n                # t is home possibility\n                possible_opponents.append(fixtures[d][t][opponent])\n                # t is away possibility\n                possible_opponents.append(fixtures[d][opponent][t])\n            model.Add(\n                sum(possible_opponents) == 1)  # can only play one game per day\n\n    # \"Each fixture happens once per season\" is not a valid constraint\n    # in this formulation.  in the C++ program, there are exactly a\n    # certain number of games such that every team plays every other\n    # team once at home, and once away.  In this case, this is not the\n    # case, because there are a variable number of games.  Instead,\n    # the constraint is that each fixture happens Matchups/2 times per\n    # season, where Matchups is the number of times each team plays every\n    # other team.\n    fixture_repeats = int(math.ceil(matchups / 2))\n    print('fixture repeats expected is', fixture_repeats)\n\n    for t in teams:\n        for opponent in teams:\n            if t == opponent:\n                continue\n            possible_days = []\n            for d in matchdays:\n```\n\n----------------------------------------\n\nTITLE: Solving CP-SAT Model with Intermediate Solutions in C++\nDESCRIPTION: This C++ code creates a CP-SAT model with three variables, adds constraints, and solves it while printing intermediate solutions. It uses a callback to capture and display each solution found during the optimization process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid SolveAndPrintIntermediateSolutionsSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  cp_model.AddNotEqual(x, y);\n\n  cp_model.Maximize(x + 2 * y + 3 * z);\n\n  Model model;\n  int num_solutions = 0;\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"Solution \" << num_solutions;\n    LOG(INFO) << \"  objective value = \" << r.objective_value();\n    LOG(INFO) << \"  x = \" << SolutionIntegerValue(r, x);\n    LOG(INFO) << \"  y = \" << SolutionIntegerValue(r, y);\n    LOG(INFO) << \"  z = \" << SolutionIntegerValue(r, z);\n    num_solutions++;\n  }));\n\n  const CpSolverResponse response = SolveCpModel(cp_model.Build(), &model);\n\n  LOG(INFO) << \"Number of solutions found: \" << num_solutions;\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::SolveAndPrintIntermediateSolutionsSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Chemical Balance Optimization Using Linear Programming\nDESCRIPTION: Implements a linear programming solution for chemical balance optimization. Uses OR-Tools to minimize the difference between actual and target quantities while respecting maximum constraints for different chemical components. The model handles multiple chemical sets and their respective composition constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/chemical_balance_lp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n# Data\n\nmax_quantities = [\n    [\"N_Total\", 1944],\n    [\"P2O5\", 1166.4],\n    [\"K2O\", 1822.5],\n    [\"CaO\", 1458],\n    [\"MgO\", 486],\n    [\"Fe\", 9.7],\n    [\"B\", 2.4],\n]\n\nchemical_set = [\n    [\"A\", 0, 0, 510, 540, 0, 0, 0],\n    [\"B\", 110, 0, 0, 0, 160, 0, 0],\n    [\"C\", 61, 149, 384, 0, 30, 1, 0.2],\n    [\"D\", 148, 70, 245, 0, 15, 1, 0.2],\n    [\"E\", 160, 158, 161, 0, 10, 1, 0.2],\n]\n\nNUM_PRODUCTS = len(max_quantities)\nALL_PRODUCTS = range(NUM_PRODUCTS)\n\nNUM_SETS = len(chemical_set)\nALL_SETS = range(NUM_SETS)\n\n# Model\n\nmax_set = [\n    min(max_quantities[q][1] / chemical_set[s][q + 1] for q in ALL_PRODUCTS\n        if chemical_set[s][q + 1] != 0.0) for s in ALL_SETS\n]\n\nsolver = pywraplp.Solver(\"chemical_set_lp\",\n                         pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)\n\nset_vars = [solver.NumVar(0, max_set[s], f\"set_{s}\") for s in ALL_SETS]\n\nepsilon = solver.NumVar(0, 1000, \"epsilon\")\n\nfor p in ALL_PRODUCTS:\n    solver.Add(\n        sum(chemical_set[s][p + 1] * set_vars[s]\n            for s in ALL_SETS) <= max_quantities[p][1])\n    solver.Add(\n        sum(chemical_set[s][p + 1] * set_vars[s]\n            for s in ALL_SETS) >= max_quantities[p][1] - epsilon)\n\nsolver.Minimize(epsilon)\n\nprint(f\"Number of variables = {solver.NumVariables()}\")\nprint(f\"Number of constraints = {solver.NumConstraints()}\")\n\nresult_status = solver.Solve()\n\n# The problem has an optimal solution.\nassert result_status == pywraplp.Solver.OPTIMAL\n\nassert solver.VerifySolution(1e-7, True)\n\nprint(f\"Problem solved in {solver.wall_time()} milliseconds\")\n\n# The objective value of the solution.\nprint(f\"Optimal objective value = {solver.Objective().Value()}\")\n\nfor s in ALL_SETS:\n    print(f\"  {chemical_set[s][0]} = {set_vars[s].solution_value()}\", end=\" \")\n    print()\nfor p in ALL_PRODUCTS:\n    name = max_quantities[p][0]\n    max_quantity = max_quantities[p][1]\n    quantity = sum(set_vars[s].solution_value() * chemical_set[s][p + 1]\n                   for s in ALL_SETS)\n    print(f\"{name}: {quantity} out of {max_quantity}\")\n```\n\n----------------------------------------\n\nTITLE: Solving Earliness and Tardiness Costs with SAT Solver in Python\nDESCRIPTION: Builds and solves a scheduling problem using a convex piecewise linear function to calculate earliness and tardiness costs. The model is created and solved using the OR-Tools CP-SAT solver, exploring all possible solutions. Input includes parameters for earliness and lateness costs, and the output prints all solutions to the console.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/earliness_tardiness_cost_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef earliness_tardiness_cost_sample_sat():\n    \"\"\"Encode the piecewise linear expression.\"\"\"\n\n    earliness_date = 5  # ed.\n    earliness_cost = 8\n    lateness_date = 15  # ld.\n    lateness_cost = 12\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Declare our primary variable.\n    x = model.new_int_var(0, 20, \"x\")\n\n    # Create the expression variable and implement the piecewise linear function.\n    #\n    #  \\        /\n    #   \\______/\n    #   ed    ld\n    #\n    large_constant = 1000\n    expr = model.new_int_var(0, large_constant, \"expr\")\n\n    # First segment.\n    s1 = model.new_int_var(-large_constant, large_constant, \"s1\")\n    model.add(s1 == earliness_cost * (earliness_date - x))\n\n    # Second segment.\n    s2 = 0\n\n    # Third segment.\n    s3 = model.new_int_var(-large_constant, large_constant, \"s3\")\n    model.add(s3 == lateness_cost * (x - lateness_date))\n\n    # Link together expr and x through s1, s2, and s3.\n    model.add_max_equality(expr, [s1, s2, s3])\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy([x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE)\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([x, expr])\n    solver.solve(model, solution_printer)\n\n\nearliness_tardiness_cost_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing MaxFlow and MinCostFlow with OR-Tools Python API\nDESCRIPTION: Complete implementation of two network flow algorithms using OR-Tools. The code includes a MaxFlow example that computes the maximum flow through a simple network with defined capacities, and a MinCostFlow example that solves an assignment problem by finding minimum cost flow through a bipartite graph.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/pyflow_example.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.graph.python import max_flow\nfrom ortools.graph.python import min_cost_flow\n\n\ndef max_flow_api():\n    \"\"\"MaxFlow simple interface example.\"\"\"\n    print(\"MaxFlow on a simple network.\")\n    tails = [0, 0, 0, 0, 1, 2, 3, 3, 4]\n    heads = [1, 2, 3, 4, 3, 4, 4, 5, 5]\n    capacities = [5, 8, 5, 3, 4, 5, 6, 6, 4]\n    expected_total_flow = 10\n    smf = max_flow.SimpleMaxFlow()\n    for i in range(0, len(tails)):\n        smf.add_arc_with_capacity(tails[i], heads[i], capacities[i])\n    if smf.solve(0, 5) == smf.OPTIMAL:\n        print(\"Total flow\", smf.optimal_flow(), \"/\", expected_total_flow)\n        for i in range(smf.num_arcs()):\n            print(\n                \"From source %d to target %d: %d / %d\"\n                % (smf.tail(i), smf.head(i), smf.flow(i), smf.capacity(i))\n            )\n        print(\"Source side min-cut:\", smf.get_source_side_min_cut())\n        print(\"Sink side min-cut:\", smf.get_sink_side_min_cut())\n    else:\n        print(\"There was an issue with the max flow input.\")\n\n\ndef min_cost_flow_api():\n    \"\"\"MinCostFlow simple interface example.\n\n    Note that this example is actually a linear sum assignment example and will\n    be more efficiently solved with the pywrapgraph.LinearSumAssignment class.\n    \"\"\"\n    print(\"MinCostFlow on 4x4 matrix.\")\n    num_sources = 4\n    num_targets = 4\n    costs = [[90, 75, 75, 80], [35, 85, 55, 65], [125, 95, 90, 105], [45, 110, 95, 115]]\n    expected_cost = 275\n    smcf = min_cost_flow.SimpleMinCostFlow()\n    for source in range(0, num_sources):\n        for target in range(0, num_targets):\n            smcf.add_arc_with_capacity_and_unit_cost(\n                source, num_sources + target, 1, costs[source][target]\n            )\n    for node in range(0, num_sources):\n        smcf.set_node_supply(node, 1)\n        smcf.set_node_supply(num_sources + node, -1)\n    status = smcf.solve()\n    if status == smcf.OPTIMAL:\n        print(\"Total flow\", smcf.optimal_cost(), \"/\", expected_cost)\n        for i in range(0, smcf.num_arcs()):\n            if smcf.flow(i) > 0:\n                print(\n                    \"From source %d to target %d: cost %d\"\n                    % (smcf.tail(i), smcf.head(i) - num_sources, smcf.unit_cost(i))\n                )\n    else:\n        print(\"There was an issue with the min cost flow input.\")\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    max_flow_api()\n    min_cost_flow_api()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Bakery Scheduling Problem with CP-SAT Solver in Python\nDESCRIPTION: Implements the constraint programming model to solve the bakery scheduling problem using Google OR-Tools' CP-SAT solver. The function builds constraints for resources, tasks, and orders while minimizing the tardiness of delivery times compared to due dates.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef solve_with_cp_sat(\n    recipes: List[Recipe], resources: List[Resource], orders: List[Order]\n) -> None:\n    \"\"\"Build the optimization model, and solve the problem.\"\"\"\n\n    model = cp_model.CpModel()\n    horizon = 22 * 60  # 10PM.\n    start_work = 4 * 60  # 4am.\n\n    # Parse recipes.\n    recipe_by_name = {}\n    for recipe in recipes:\n        recipe_by_name[recipe.name] = recipe\n\n    # Parse resources.\n    resource_by_name = {}\n    resource_list_by_skill_name = collections.defaultdict(list)\n    for resource in resources:\n        resource_by_name[resource.name] = resource\n        for skill in resource.skills:\n            resource_list_by_skill_name[skill.name].append(resource)\n\n    # Parse orders and create one optional copy per eligible resource and per\n    # task.\n    interval_list_by_resource_name = collections.defaultdict(list)\n    orders_sequence_of_events = collections.defaultdict(list)\n    sorted_orders = []\n    tardiness_vars = []\n    for order in orders:\n        for batch in range(order.quantity):\n            order_id = f\"{order.unique_id}_{batch}\"\n            sorted_orders.append(order_id)\n            previous_end = None\n            due_date = order.due_date\n            recipe = recipe_by_name[order.recipe_name]\n            for task in recipe.tasks:\n                skill_name = task.name\n                suffix = f\"_{order.unique_id}_batch{batch}_{skill_name}\"\n\n                if previous_end is None:\n                    start = model.new_int_var(start_work, horizon, f\"start{suffix}\")\n                    orders_sequence_of_events[order_id].append(\n                        (start, f\"start{suffix}\")\n                    )\n                else:\n                    start = previous_end\n\n                size = model.new_int_var(\n                    task.min_duration, task.max_duration, f\"size{suffix}\"\n                )\n                if task == recipe.tasks[-1]:\n                    # The order must end after the due_date. Ideally, exactly at the\n                    # due_date.\n                    tardiness = model.new_int_var(0, horizon - due_date, f\"end{suffix}\")\n                    end = tardiness + due_date\n\n                    # Store the end_var for the objective.\n                    tardiness_vars.append(tardiness)\n                else:\n                    end = model.new_int_var(start_work, horizon, f\"end{suffix}\")\n                orders_sequence_of_events[order_id].append((end, f\"end{suffix}\"))\n                previous_end = end\n\n                # Per resource copy.\n                presence_literals = []\n                for resource in resource_list_by_skill_name[skill_name]:\n                    presence = model.new_bool_var(f\"presence{suffix}_{resource.name}\")\n                    copy = model.new_optional_interval_var(\n                        start, size, end, presence, f\"interval{suffix}_{resource.name}\"\n                    )\n                    interval_list_by_resource_name[resource.name].append(copy)\n                    presence_literals.append(presence)\n\n                # Only one copy will be performed.\n                model.add_exactly_one(presence_literals)\n\n    # Create resource constraints.\n    for resource in resources:\n        intervals = interval_list_by_resource_name[resource.name]\n        if resource.capacity == 1:\n            model.add_no_overlap(intervals)\n        else:\n            model.add_cumulative(intervals, [1] * len(intervals), resource.capacity)\n\n    # The objective is to minimize the sum of the tardiness values of each jobs.\n    # The tardiness is difference between the end time of an order and its\n    # due date.\n    model.minimize(sum(tardiness_vars))\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n    solver.parameters.log_search_progress = True\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        for order_id in sorted_orders:\n            print(f\"{order_id}:\")\n            for time_expr, event_id in orders_sequence_of_events[order_id]:\n                time = solver.value(time_expr)\n                print(f\"  {event_id} at {time // 60}:{time % 60:02}\")\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with MIP using OR-Tools in Python\nDESCRIPTION: This Python snippet uses OR-Tools to create a mixed integer programming solution for an assignment problem. It assigns tasks to workers while minimizing costs and adhering to task size constraints. Requires the OR-Tools library. Inputs include cost matrix and task sizes, while outputs detail assignments and their costs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_task_sizes_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef main():\n    # Data\n    costs = [\n        [90, 76, 75, 70, 50, 74, 12, 68],\n        [35, 85, 55, 65, 48, 101, 70, 83],\n        [125, 95, 90, 105, 59, 120, 36, 73],\n        [45, 110, 95, 115, 104, 83, 37, 71],\n        [60, 105, 80, 75, 59, 62, 93, 88],\n        [45, 65, 110, 95, 47, 31, 81, 34],\n        [38, 51, 107, 41, 69, 99, 115, 48],\n        [47, 85, 57, 71, 92, 77, 109, 36],\n        [39, 63, 97, 49, 118, 56, 92, 61],\n        [47, 101, 71, 60, 88, 109, 52, 90],\n    ]\n    num_workers = len(costs)\n    num_tasks = len(costs[0])\n\n    task_sizes = [10, 7, 3, 12, 15, 4, 11, 5]\n    # Maximum total of task sizes for any worker\n    total_size_max = 15\n\n    # Solver\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n\n    if not solver:\n        return\n\n    # Variables\n    # x[i, j] is an array of 0-1 variables, which will be 1\n    # if worker i is assigned to task j.\n    x = {}\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            x[worker, task] = solver.BoolVar(f\"x[{worker},{task}]\")\n\n    # Constraints\n    # The total size of the tasks each worker takes on is at most total_size_max.\n    for worker in range(num_workers):\n        solver.Add(\n            solver.Sum(\n                [task_sizes[task] * x[worker, task] for task in range(num_tasks)]\n            )\n            <= total_size_max\n        )\n\n    # Each task is assigned to exactly one worker.\n    for task in range(num_tasks):\n        solver.Add(solver.Sum([x[worker, task] for worker in range(num_workers)]) == 1)\n\n    # Objective\n    objective_terms = []\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            objective_terms.append(costs[worker][task] * x[worker, task])\n    solver.Minimize(solver.Sum(objective_terms))\n\n    # Solve\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    # Print solution.\n    if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n        print(f\"Total cost = {solver.Objective().Value()}\\n\")\n        for worker in range(num_workers):\n            for task in range(num_tasks):\n                if x[worker, task].solution_value() > 0.5:\n                    print(\n                        f\"Worker {worker} assigned to task {task}.\"\n                        + f\" Cost: {costs[worker][task]}\"\n                    )\n    else:\n        print(\"No solution found.\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Golomb Ruler Problem Solver Implementation\nDESCRIPTION: Main implementation of the Golomb ruler problem solver using OR-Tools CP-SAT. The code creates a constraint model that places marks on a ruler such that all differences between marks are unique, while minimizing the ruler's length. Includes symmetry breaking constraints and solution printing.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/golomb_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_ORDER = flags.define_integer(\"order\", 8, \"Order of the ruler.\")\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:16,log_search_progress:true,max_time_in_seconds:45\",\n    \"Sat solver parameters.\",\n)\n\n\ndef solve_golomb_ruler(order: int, params: str) -> None:\n    \"\"\"Solve the Golomb ruler problem.\"\"\"\n    # Create the model.\n    model = cp_model.CpModel()\n\n    var_max = order * order\n    all_vars = list(range(0, order))\n\n    marks = [model.new_int_var(0, var_max, f\"marks_{i}\") for i in all_vars]\n\n    model.add(marks[0] == 0)\n    for i in range(order - 2):\n        model.add(marks[i + 1] > marks[i])\n\n    diffs = []\n    for i in range(order - 1):\n        for j in range(i + 1, order):\n            diff = model.new_int_var(0, var_max, f\"diff [{j},{i}]\")\n            model.add(diff == marks[j] - marks[i])\n            diffs.append(diff)\n    model.add_all_different(diffs)\n\n    # symmetry breaking\n    if order > 2:\n        model.add(marks[order - 1] - marks[order - 2] > marks[1] - marks[0])\n\n    # Objective\n    model.minimize(marks[order - 1])\n\n    # Solve the model.\n    solver = cp_model.CpSolver()\n    if params:\n        text_format.Parse(params, solver.parameters)\n    solution_printer = cp_model.ObjectiveSolutionPrinter()\n    print(f\"Golomb ruler(order={order})\")\n    status = solver.solve(model, solution_printer)\n\n    # Print solution.\n    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n        for idx, var in enumerate(marks):\n            print(f\"mark[{idx}]: {solver.value(var)}\")\n        intervals = [solver.value(diff) for diff in diffs]\n        intervals.sort()\n        print(f\"intervals: {intervals}\")\n    print(solver.response_stats())\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    solve_golomb_ruler(_ORDER.value, _PARAMS.value)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Flexible Job Shop Solver Implementation\nDESCRIPTION: Complete implementation of the flexible job shop scheduling problem solver using CP-SAT. Includes a solution printer callback class and the main solving function that sets up the optimization model with constraints for machine capacity, job precedence, and makespan minimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/flexible_job_shop_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\n\nfrom ortools.sat.python import cp_model\n\n\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self) -> None:\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        \"\"\"Called at each new solution.\"\"\"\n        print(\n            f\"Solution {self.__solution_count}, time = {self.wall_time} s,\"\n            f\" objective = {self.objective_value}\"\n        )\n        self.__solution_count += 1\n\n\ndef flexible_jobshop() -> None:\n    \"\"\"solve a small flexible jobshop problem.\"\"\"\n    # Data part.\n    jobs = [  # task = (processing_time, machine_id)\n        [  # Job 0\n            [(3, 0), (1, 1), (5, 2)],  # task 0 with 3 alternatives\n            [(2, 0), (4, 1), (6, 2)],  # task 1 with 3 alternatives\n            [(2, 0), (3, 1), (1, 2)],  # task 2 with 3 alternatives\n        ],\n        [  # Job 1\n            [(2, 0), (3, 1), (4, 2)],\n            [(1, 0), (5, 1), (4, 2)],\n            [(2, 0), (1, 1), (4, 2)],\n        ],\n        [  # Job 2\n            [(2, 0), (1, 1), (4, 2)],\n            [(2, 0), (3, 1), (4, 2)],\n            [(3, 0), (1, 1), (5, 2)],\n        ],\n    ]\n\n    num_jobs = len(jobs)\n    all_jobs = range(num_jobs)\n\n    num_machines = 3\n    all_machines = range(num_machines)\n\n    # Model the flexible jobshop problem.\n    model = cp_model.CpModel()\n\n    horizon = 0\n    for job in jobs:\n        for task in job:\n            max_task_duration = 0\n            for alternative in task:\n                max_task_duration = max(max_task_duration, alternative[0])\n            horizon += max_task_duration\n\n    print(f\"Horizon = {horizon}\")\n\n    # Global storage of variables.\n    intervals_per_resources = collections.defaultdict(list)\n    starts = {}  # indexed by (job_id, task_id).\n    presences = {}  # indexed by (job_id, task_id, alt_id).\n    job_ends: list[cp_model.IntVar] = []\n\n    # Scan the jobs and create the relevant variables and intervals.\n    for job_id in all_jobs:\n        job = jobs[job_id]\n        num_tasks = len(job)\n        previous_end = None\n        for task_id in range(num_tasks):\n            task = job[task_id]\n\n            min_duration = task[0][0]\n            max_duration = task[0][0]\n\n            num_alternatives = len(task)\n            all_alternatives = range(num_alternatives)\n\n            for alt_id in range(1, num_alternatives):\n                alt_duration = task[alt_id][0]\n                min_duration = min(min_duration, alt_duration)\n                max_duration = max(max_duration, alt_duration)\n\n            # Create main interval for the task.\n            suffix_name = f\"_j{job_id}_t{task_id}\"\n            start = model.new_int_var(0, horizon, \"start\" + suffix_name)\n            duration = model.new_int_var(\n                min_duration, max_duration, \"duration\" + suffix_name\n            )\n            end = model.new_int_var(0, horizon, \"end\" + suffix_name)\n            interval = model.new_interval_var(\n                start, duration, end, \"interval\" + suffix_name\n            )\n\n            # Store the start for the solution.\n            starts[(job_id, task_id)] = start\n\n            # Add precedence with previous task in the same job.\n            if previous_end is not None:\n                model.add(start >= previous_end)\n            previous_end = end\n\n            # Create alternative intervals.\n            if num_alternatives > 1:\n                l_presences = []\n                for alt_id in all_alternatives:\n                    alt_suffix = f\"_j{job_id}_t{task_id}_a{alt_id}\"\n                    l_presence = model.new_bool_var(\"presence\" + alt_suffix)\n                    l_start = model.new_int_var(0, horizon, \"start\" + alt_suffix)\n                    l_duration = task[alt_id][0]\n                    l_end = model.new_int_var(0, horizon, \"end\" + alt_suffix)\n                    l_interval = model.new_optional_interval_var(\n                        l_start, l_duration, l_end, l_presence, \"interval\" + alt_suffix\n                    )\n                    l_presences.append(l_presence)\n\n                    # Link the primary/global variables with the local ones.\n                    model.add(start == l_start).only_enforce_if(l_presence)\n                    model.add(duration == l_duration).only_enforce_if(l_presence)\n                    model.add(end == l_end).only_enforce_if(l_presence)\n\n                    # Add the local interval to the right machine.\n                    intervals_per_resources[task[alt_id][1]].append(l_interval)\n\n                    # Store the presences for the solution.\n                    presences[(job_id, task_id, alt_id)] = l_presence\n\n                # Select exactly one presence variable.\n                model.add_exactly_one(l_presences)\n            else:\n                intervals_per_resources[task[0][1]].append(interval)\n                presences[(job_id, task_id, 0)] = model.new_constant(1)\n\n        if previous_end is not None:\n            job_ends.append(previous_end)\n\n    # Create machines constraints.\n    for machine_id in all_machines:\n        intervals = intervals_per_resources[machine_id]\n        if len(intervals) > 1:\n            model.add_no_overlap(intervals)\n\n    # Makespan objective\n    makespan = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(makespan, job_ends)\n    model.minimize(makespan)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    solution_printer = SolutionPrinter()\n    status = solver.solve(model, solution_printer)\n\n    # Print final solution.\n    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n        print(f\"Optimal objective value: {solver.objective_value}\")\n        for job_id in all_jobs:\n            print(f\"Job {job_id}\")\n            for task_id, task in enumerate(jobs[job_id]):\n                start_value = solver.value(starts[(job_id, task_id)])\n                machine: int = -1\n                task_duration: int = -1\n                selected: int = -1\n                for alt_id, alt in enumerate(task):\n                    if solver.boolean_value(presences[(job_id, task_id, alt_id)]):\n                        task_duration, machine = alt\n                        selected = alt_id\n                print(\n                    f\"  task_{job_id}_{task_id} starts at {start_value} (alt\"\n                    f\" {selected}, machine {machine}, duration {task_duration})\"\n                )\n\n    print(solver.response_stats())\n\n\nflexible_jobshop()\n```\n\n----------------------------------------\n\nTITLE: Product of Boolean and Integer Variables in Python with CP-SAT\nDESCRIPTION: Demonstrates how to implement a helper function that creates a new integer variable constrained to be the product of a Boolean variable and an integer variable. This constraint is useful for modeling conditional behavior where a value is either used (multiplied by 1) or ignored (multiplied by 0).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample that encodes the product of a Boolean and an integer variable.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef build_product_var(\n    model: cp_model.CpModel, b: cp_model.IntVar, x: cp_model.IntVar, name: str\n) -> cp_model.IntVar:\n    \"\"\"Builds the product of a Boolean variable and an integer variable.\"\"\"\n    p = model.new_int_var_from_domain(\n        cp_model.Domain.from_flat_intervals(x.proto.domain).union_with(\n            cp_model.Domain(0, 0)\n        ),\n        name,\n    )\n    model.add(p == x).only_enforce_if(b)\n    model.add(p == 0).only_enforce_if(~b)\n    return p\n\n\ndef bool_and_int_var_product_sample_sat():\n    \"\"\"Encoding of the product of two Boolean variables.\n\n    p == x * y, which is the same as p <=> x and y\n    \"\"\"\n    model = cp_model.CpModel()\n    b = model.new_bool_var(\"b\")\n    x = model.new_int_var_from_domain(\n        cp_model.Domain.from_values([1, 2, 3, 5, 6, 7, 9, 10]), \"x\"\n    )\n    p = build_product_var(model, b, x, \"p\")\n\n    # Search for x and b values in increasing order.\n    model.add_decision_strategy(\n        [b, x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE\n    )\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArraySolutionPrinter([x, b, p])\n    solver.parameters.enumerate_all_solutions = True\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    solver.solve(model, solution_printer)\n\n\nbool_and_int_var_product_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Crew Allocation Solver using OR-Tools in Python\nDESCRIPTION: Defines the main function that sets up and solves the crew allocation problem using the OR-Tools constraint programming solver. It includes data initialization, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/crew.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(sols=1):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Crew\")\n\n  #\n  # data\n  #\n  names = [\n      \"Tom\", \"David\", \"Jeremy\", \"Ron\", \"Joe\", \"Bill\", \"Fred\", \"Bob\", \"Mario\",\n      \"Ed\", \"Carol\", \"Janet\", \"Tracy\", \"Marilyn\", \"Carolyn\", \"Cathy\", \"Inez\",\n      \"Jean\", \"Heather\", \"Juliet\"\n  ]\n\n  num_persons = len(names)  # number of persons\n\n  attributes = [\n      #  steward, hostess, french, spanish, german\n      [1, 0, 0, 0, 1],  # Tom     = 1\n      [1, 0, 0, 0, 0],  # David   = 2\n      [1, 0, 0, 0, 1],  # Jeremy  = 3\n      [1, 0, 0, 0, 0],  # Ron     = 4\n      [1, 0, 0, 1, 0],  # Joe     = 5\n      [1, 0, 1, 1, 0],  # Bill    = 6\n      [1, 0, 0, 1, 0],  # Fred    = 7\n      [1, 0, 0, 0, 0],  # Bob     = 8\n      [1, 0, 0, 1, 1],  # Mario   = 9\n      [1, 0, 0, 0, 0],  # Ed      = 10\n      [0, 1, 0, 0, 0],  # Carol   = 11\n      [0, 1, 0, 0, 0],  # Janet   = 12\n      [0, 1, 0, 0, 0],  # Tracy   = 13\n      [0, 1, 0, 1, 1],  # Marilyn = 14\n      [0, 1, 0, 0, 0],  # Carolyn = 15\n      [0, 1, 0, 0, 0],  # Cathy   = 16\n      [0, 1, 1, 1, 1],  # Inez    = 17\n      [0, 1, 1, 0, 0],  # Jean    = 18\n      [0, 1, 0, 1, 1],  # Heather = 19\n      [0, 1, 1, 0, 0]  # Juliet  = 20\n  ]\n\n  # The columns are in the following order:\n  # staff     : Overall number of cabin crew needed\n  # stewards  : How many stewards are required\n  # hostesses : How many hostesses are required\n  # french    : How many French speaking employees are required\n  # spanish   : How many Spanish speaking employees are required\n  # german    : How many German speaking employees are required\n  required_crew = [\n      [4, 1, 1, 1, 1, 1],  # Flight 1\n      [5, 1, 1, 1, 1, 1],  # Flight 2\n      [5, 1, 1, 1, 1, 1],  # ..\n      [6, 2, 2, 1, 1, 1],\n      [7, 3, 3, 1, 1, 1],\n      [4, 1, 1, 1, 1, 1],\n      [5, 1, 1, 1, 1, 1],\n      [6, 1, 1, 1, 1, 1],\n      [6, 2, 2, 1, 1, 1],  # ...\n      [7, 3, 3, 1, 1, 1]  # Flight 10\n  ]\n\n  num_flights = len(required_crew)  # number of flights\n\n  #\n  # declare variables\n  #\n  crew = {}\n  for i in range(num_flights):\n    for j in range(num_persons):\n      crew[(i, j)] = solver.IntVar(0, 1, \"crew[%i,%i]\" % (i, j))\n  crew_flat = [\n      crew[(i, j)] for i in range(num_flights) for j in range(num_persons)\n  ]\n\n  # number of working persons\n  num_working = solver.IntVar(1, num_persons, \"num_working\")\n\n  #\n  # constraints\n  #\n\n  # number of working persons\n  solver.Add(num_working == solver.Sum([\n      solver.IsGreaterOrEqualCstVar(\n          solver.Sum([crew[(f, p)]\n                      for f in range(num_flights)]), 1)\n      for p in range(num_persons)\n  ]))\n\n  for f in range(num_flights):\n    # size of crew\n    tmp = [crew[(f, i)] for i in range(num_persons)]\n    solver.Add(solver.Sum(tmp) == required_crew[f][0])\n\n    # attributes and requirements\n    for j in range(5):\n      tmp = [attributes[i][j] * crew[(f, i)] for i in range(num_persons)]\n      solver.Add(solver.Sum(tmp) >= required_crew[f][j + 1])\n\n  # after a flight, break for at least two flights\n  for f in range(num_flights - 2):\n    for i in range(num_persons):\n      solver.Add(crew[f, i] + crew[f + 1, i] + crew[f + 2, i] <= 1)\n\n  # extra contraint: all must work at least two of the flights\n  # for i in range(num_persons):\n  #     [solver.Add(solver.Sum([crew[f,i] for f in range(num_flights)]) >= 2) ]\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(crew_flat)\n  solution.Add(num_working)\n\n  db = solver.Phase(crew_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  #\n  # result\n  #\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"Solution #%i\" % num_solutions)\n    print(\"Number working:\", num_working.Value())\n    for i in range(num_flights):\n      for j in range(num_persons):\n        print(crew[i, j].Value(), end=\" \")\n      print()\n    print()\n\n    print(\"Flights:\")\n    for flight in range(num_flights):\n      print(\"Flight\", flight, \"persons:\", end=\" \")\n      for person in range(num_persons):\n        if crew[flight, person].Value() == 1:\n          print(names[person], end=\" \")\n      print()\n    print()\n\n    print(\"Crew:\")\n    for person in range(num_persons):\n      print(\"%-10s flights\" % names[person], end=\" \")\n      for flight in range(num_flights):\n        if crew[flight, person].Value() == 1:\n          print(flight, end=\" \")\n      print()\n    print()\n\n    if num_solutions >= sols:\n      break\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nnum_solutions_to_show = 1\nif (len(sys.argv) > 1):\n  num_solutions_to_show = int(sys.argv[1])\n\nmain(num_solutions_to_show)\n```\n\n----------------------------------------\n\nTITLE: Implementing Blending Problem Solver with OR-Tools\nDESCRIPTION: Defines and solves a blending problem using linear programming. It sets up the problem data, creates variables and constraints, and optimizes the solution using either the CBC or GLPK solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/blending.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n\n  print('Solver: ', sol)\n\n  if sol == 'GLPK':\n    solver = pywraplp.Solver.CreateSolver('GLPK')\n  else:\n    solver = pywraplp.Solver.CreateSolver('CBC')\n  if not solver:\n    return\n\n  #\n  # data\n  #\n  NbMetals = 3\n  NbRaw = 2\n  NbScrap = 2\n  NbIngo = 1\n  Metals = list(range(NbMetals))\n  Raws = list(range(NbRaw))\n  Scraps = list(range(NbScrap))\n  Ingos = list(range(NbIngo))\n\n  CostMetal = [22, 10, 13]\n  CostRaw = [6, 5]\n  CostScrap = [7, 8]\n  CostIngo = [9]\n  Low = [0.05, 0.30, 0.60]\n  Up = [0.10, 0.40, 0.80]\n  PercRaw = [[0.20, 0.01], [0.05, 0], [0.05, 0.30]]\n  PercScrap = [[0, 0.01], [0.60, 0], [0.40, 0.70]]\n  PercIngo = [[0.10], [0.45], [0.45]]\n  Alloy = 71\n\n  #\n  # variables\n  #\n  p = [solver.NumVar(0, solver.Infinity(), 'p[%i]' % i) for i in Metals]\n  r = [solver.NumVar(0, solver.Infinity(), 'r[%i]' % i) for i in Raws]\n  s = [solver.NumVar(0, solver.Infinity(), 's[%i]' % i) for i in Scraps]\n  ii = [solver.IntVar(0, solver.Infinity(), 'ii[%i]' % i) for i in Ingos]\n  metal = [\n      solver.NumVar(Low[j] * Alloy, Up[j] * Alloy, 'metal[%i]' % j)\n      for j in Metals\n  ]\n\n  z = solver.NumVar(0, solver.Infinity(), 'z')\n\n  #\n  # constraints\n  #\n\n  solver.Add(z == solver.Sum([CostMetal[i] * p[i] for i in Metals]) +\n             solver.Sum([CostRaw[i] * r[i] for i in Raws]) +\n             solver.Sum([CostScrap[i] * s[i] for i in Scraps]) +\n             solver.Sum([CostIngo[i] * ii[i] for i in Ingos]))\n\n  for j in Metals:\n    solver.Add(\n        metal[j] == p[j] + solver.Sum([PercRaw[j][k] * r[k] for k in Raws]) +\n        solver.Sum([PercScrap[j][k] * s[k] for k in Scraps]) +\n        solver.Sum([PercIngo[j][k] * ii[k] for k in Ingos]))\n\n  solver.Add(solver.Sum(metal) == Alloy)\n\n  objective = solver.Minimize(z)\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n\n  print('z = ', solver.Objective().Value())\n  print('Metals')\n  for i in Metals:\n    print(p[i].SolutionValue(), end=' ')\n  print()\n\n  print('Raws')\n  for i in Raws:\n    print(r[i].SolutionValue(), end=' ')\n  print()\n\n  print('Scraps')\n  for i in Scraps:\n    print(s[i].SolutionValue(), end=' ')\n  print()\n\n  print('Ingos')\n  for i in Ingos:\n    print(ii[i].SolutionValue(), end=' ')\n  print()\n\n  print('Metals')\n  for i in Metals:\n    print(metal[i].SolutionValue(), end=' ')\n  print()\n\n  print()\n\n  print('walltime  :', solver.WallTime(), 'ms')\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n\n\nsol = 'CBC'\n\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Solving an assignment problem with OR-Tools SAT\nDESCRIPTION: This Python code solves an assignment problem where workers are assigned to tasks to minimize cost, subject to constraints on allowed worker groups. It uses the `cp_model` module from `ortools.sat.python` to define the model, variables, and constraints.  The model is then solved by the CpSolver, and the optimal assignment is printed.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_groups_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.sat.python import cp_model\n\n\ndef main() -> None:\n    # Data\n    costs = [\n        [90, 76, 75, 70, 50, 74],\n        [35, 85, 55, 65, 48, 101],\n        [125, 95, 90, 105, 59, 120],\n        [45, 110, 95, 115, 104, 83],\n        [60, 105, 80, 75, 59, 62],\n        [45, 65, 110, 95, 47, 31],\n        [38, 51, 107, 41, 69, 99],\n        [47, 85, 57, 71, 92, 77],\n        [39, 63, 97, 49, 118, 56],\n        [47, 101, 71, 60, 88, 109],\n        [17, 39, 103, 64, 61, 92],\n        [101, 45, 83, 59, 92, 27],\n    ]\n    num_workers = len(costs)\n    num_tasks = len(costs[0])\n\n    # Allowed groups of workers:\n    group1 = [\n        [0, 0, 1, 1],  # Workers 2, 3\n        [0, 1, 0, 1],  # Workers 1, 3\n        [0, 1, 1, 0],  # Workers 1, 2\n        [1, 1, 0, 0],  # Workers 0, 1\n        [1, 0, 1, 0],  # Workers 0, 2\n    ]\n\n    group2 = [\n        [0, 0, 1, 1],  # Workers 6, 7\n        [0, 1, 0, 1],  # Workers 5, 7\n        [0, 1, 1, 0],  # Workers 5, 6\n        [1, 1, 0, 0],  # Workers 4, 5\n        [1, 0, 0, 1],  # Workers 4, 7\n    ]\n\n    group3 = [\n        [0, 0, 1, 1],  # Workers 10, 11\n        [0, 1, 0, 1],  # Workers 9, 11\n        [0, 1, 1, 0],  # Workers 9, 10\n        [1, 0, 1, 0],  # Workers 8, 10\n        [1, 0, 0, 1],  # Workers 8, 11\n    ]\n\n    # Model\n    model = cp_model.CpModel()\n\n    # Variables\n    x = {}\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            x[worker, task] = model.new_bool_var(f\"x[{worker},{task}]\")\n\n    # Constraints\n    # Each worker is assigned to at most one task.\n    for worker in range(num_workers):\n        model.add_at_most_one(x[worker, task] for task in range(num_tasks))\n\n    # Each task is assigned to exactly one worker.\n    for task in range(num_tasks):\n        model.add_exactly_one(x[worker, task] for worker in range(num_workers))\n\n    # Create variables for each worker, indicating whether they work on some task.\n    work = {}\n    for worker in range(num_workers):\n        work[worker] = model.new_bool_var(f\"work[{worker}]\")\n\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            model.add(work[worker] == sum(x[worker, task] for task in range(num_tasks)))\n\n    # Define the allowed groups of worders\n    model.add_allowed_assignments([work[0], work[1], work[2], work[3]], group1)\n    model.add_allowed_assignments([work[4], work[5], work[6], work[7]], group2)\n    model.add_allowed_assignments([work[8], work[9], work[10], work[11]], group3)\n\n    # Objective\n    objective_terms = []\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            objective_terms.append(costs[worker][task] * x[worker, task])\n    model.minimize(sum(objective_terms))\n\n    # Solve\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Print solution.\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"Total cost = {solver.objective_value}\\n\")\n        for worker in range(num_workers):\n            for task in range(num_tasks):\n                if solver.boolean_value(x[worker, task]):\n                    print(\n                        f\"Worker {worker} assigned to task {task}.\"\n                        + f\" Cost = {costs[worker][task]}\"\n                    )\n    else:\n        print(\"No solution found.\")\n\n\nmain()\n\"\n```\n\n----------------------------------------\n\nTITLE: Solving Knapsack Problem with OR-Tools in Python\nDESCRIPTION: This code demonstrates how to use OR-Tools to solve a knapsack problem. It initializes the solver with predefined weights, capacities, and values, solves the problem, and then outputs the results including packed items, their weights, and the total value.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/algorithms/simple_knapsack_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.algorithms.python import knapsack_solver\n\n\ndef main():\n    # Create the solver.\n    solver = knapsack_solver.KnapsackSolver(\n        knapsack_solver.SolverType.KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER,\n        \"test\",\n    )\n\n    weights = [\n        # fmt:off\n      [565, 406, 194, 130, 435, 367, 230, 315, 393, 125, 670, 892, 600, 293, 712, 147, 421, 255],\n        # fmt:on\n    ]\n    capacities = [850]\n    values = weights[0]\n\n    solver.init(values, weights, capacities)\n    computed_value = solver.solve()\n\n    packed_items = [\n        x for x in range(0, len(weights[0])) if solver.best_solution_contains(x)\n    ]\n    packed_weights = [weights[0][i] for i in packed_items]\n\n    print(\"Packed items: \", packed_items)\n    print(\"Packed weights: \", packed_weights)\n    print(\"Total weight (same as total value): \", computed_value)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing VRP with Pickup and Delivery (LIFO) using OR-Tools\nDESCRIPTION: Complete implementation of a Vehicle Routing Problem with Pickup and Delivery constraints using LIFO (Last-In-First-Out) policy. The code defines the problem data, sets up routing constraints, and solves the optimization problem with OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_pickup_delivery_lifo.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"pickups_deliveries\"] = [\n        [1, 6],\n        [2, 10],\n        [4, 3],\n        [5, 9],\n        [7, 8],\n        [15, 11],\n        [13, 12],\n        [16, 14],\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    total_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        total_distance += route_distance\n    print(f\"Total Distance of all routes: {total_distance}m\")\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Define cost of each arc.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the manhattan distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Define Transportation Requests.\n    for request in data[\"pickups_deliveries\"]:\n        pickup_index = manager.NodeToIndex(request[0])\n        delivery_index = manager.NodeToIndex(request[1])\n        routing.AddPickupAndDelivery(pickup_index, delivery_index)\n        routing.solver().Add(\n            routing.VehicleVar(pickup_index) == routing.VehicleVar(delivery_index)\n        )\n        routing.solver().Add(\n            distance_dimension.CumulVar(pickup_index)\n            <= distance_dimension.CumulVar(delivery_index)\n        )\n    routing.SetPickupAndDeliveryPolicyOfAllVehicles(\n        pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_LIFO\n    )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PARALLEL_CHEAPEST_INSERTION\n    )\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(data, manager, routing, assignment)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Combinatorial Auction Solver Implementation\nDESCRIPTION: Main implementation of the combinatorial auction solver using OR-Tools. It creates a constraint satisfaction problem where bids are placed on combinations of items, with constraints ensuring each item is only sold once. The objective is to maximize the total auction revenue.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/combinatorial_auction2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom collections import *\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Problem\")\n\n  #\n  # data\n  #\n  N = 5\n\n  # the items for each bid\n  items = [\n      [0, 1],  # A,B\n      [0, 2],  # A, C\n      [1, 3],  # B,D\n      [1, 2, 3],  # B,C,D\n      [0]  # A\n  ]\n  # collect the bids for each item\n  items_t = defaultdict(list)\n\n  # [items_t.setdefault(j,[]).append(i) for i in range(N) for j in items[i] ]\n  # nicer:\n  [items_t[j].append(i) for i in range(N) for j in items[i]]\n\n  bid_amount = [10, 20, 30, 40, 14]\n\n  #\n  # declare variables\n  #\n  X = [solver.BoolVar(\"x%i\" % i) for i in range(N)]\n  obj = solver.IntVar(0, 100, \"obj\")\n\n  #\n  # constraints\n  #\n  solver.Add(obj == solver.ScalProd(X, bid_amount))\n  for item in items_t:\n    solver.Add(solver.Sum([X[bid] for bid in items_t[item]]) <= 1)\n\n  # objective\n  objective = solver.Maximize(obj, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(X)\n  solution.Add(obj)\n\n  # db: DecisionBuilder\n  db = solver.Phase(X, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"X:\", [X[i].Value() for i in range(N)])\n    print(\"obj:\", obj.Value())\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: FT06 Job Shop Scheduling Implementation\nDESCRIPTION: Complete implementation of the FT06 job shop scheduling problem using CP-SAT solver. The code creates a model with 6 machines and 6 jobs, defines durations and machine sequences, sets up constraints for machine availability and job precedence, and minimizes the makespan objective.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/jobshop_ft06_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\n\nfrom ortools.sat.colab import visualization\nfrom ortools.sat.python import cp_model\n\n\ndef jobshop_ft06() -> None:\n    \"\"\"Solves the ft06 jobshop.\"\"\"\n    # Creates the solver.\n    model = cp_model.CpModel()\n\n    machines_count = 6\n    jobs_count = 6\n    all_machines = range(0, machines_count)\n    all_jobs = range(0, jobs_count)\n\n    durations = [\n        [1, 3, 6, 7, 3, 6],\n        [8, 5, 10, 10, 10, 4],\n        [5, 4, 8, 9, 1, 7],\n        [5, 5, 5, 3, 8, 9],\n        [9, 3, 5, 4, 3, 1],\n        [3, 3, 9, 10, 4, 1],\n    ]\n\n    machines = [\n        [2, 0, 1, 3, 5, 4],\n        [1, 2, 4, 5, 0, 3],\n        [2, 3, 5, 0, 1, 4],\n        [1, 0, 2, 3, 4, 5],\n        [2, 1, 4, 5, 0, 3],\n        [1, 3, 5, 0, 4, 2],\n    ]\n\n    # Computes horizon dynamically.\n    horizon = sum([sum(durations[i]) for i in all_jobs])\n\n    task_type = collections.namedtuple(\"task_type\", \"start end interval\")\n\n    # Creates jobs.\n    all_tasks = {}\n    for i in all_jobs:\n        for j in all_machines:\n            start_var = model.new_int_var(0, horizon, f\"start_{i}_{j}\")\n            duration = durations[i][j]\n            end_var = model.new_int_var(0, horizon, f\"end_{i}_{j}\")\n            interval_var = model.new_interval_var(\n                start_var, duration, end_var, f\"interval_{i}_{j}\"\n            )\n            all_tasks[(i, j)] = task_type(\n                start=start_var, end=end_var, interval=interval_var\n            )\n\n    # Create disjuctive constraints.\n    machine_to_jobs = {}\n    for i in all_machines:\n        machines_jobs = []\n        for j in all_jobs:\n            for k in all_machines:\n                if machines[j][k] == i:\n                    machines_jobs.append(all_tasks[(j, k)].interval)\n        machine_to_jobs[i] = machines_jobs\n        model.add_no_overlap(machines_jobs)\n\n    # Precedences inside a job.\n    for i in all_jobs:\n        for j in range(0, machines_count - 1):\n            model.add(all_tasks[(i, j + 1)].start >= all_tasks[(i, j)].end)\n\n    # Makespan objective.\n    obj_var = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(\n        obj_var, [all_tasks[(i, machines_count - 1)].end for i in all_jobs]\n    )\n    model.minimize(obj_var)\n\n    # Solve the model.\n    solver = cp_model.CpSolver()\n    solver.parameters.log_search_progress = True\n    status = solver.solve(model)\n\n    # Output the solution.\n    if status == cp_model.OPTIMAL:\n        if visualization.RunFromIPython():\n            starts = [\n                [solver.value(all_tasks[(i, j)][0]) for j in all_machines]\n                for i in all_jobs\n            ]\n            visualization.DisplayJobshop(starts, durations, machines, \"FT06\")\n        else:\n            print(f\"Optimal makespan: {solver.objective_value}\")\n\n\njobshop_ft06()\n```\n\n----------------------------------------\n\nTITLE: Creating and Solving a Mixed Integer Program - Python\nDESCRIPTION: This snippet illustrates the process of creating a mixed integer programming model using the OR-Tools library. It defines integer variables, sets constraints, and uses the SCIP solver to find an optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_mip_program_mb.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport math\n\nfrom ortools.linear_solver.python import model_builder\n\n\ndef main():\n    # Create the model.\n    model = model_builder.Model()\n\n    # x and y are integer non-negative variables.\n    x = model.new_int_var(0.0, math.inf, \"x\")\n    y = model.new_int_var(0.0, math.inf, \"y\")\n\n    print(\"Number of variables =\", model.num_variables)\n\n    # x + 7 * y <= 17.5.\n    model.add(x + 7 * y <= 17.5)\n\n    # x <= 3.5.\n    model.add(x <= 3.5)\n\n    print(\"Number of constraints =\", model.num_constraints)\n\n    # Maximize x + 10 * y.\n    model.maximize(x + 10 * y)\n\n    # Create the solver with the SCIP backend, and solve the model.\n    solver = model_builder.Solver(\"scip\")\n    if not solver.solver_is_supported():\n        return\n    status = solver.solve(model)\n\n    if status == model_builder.SolveStatus.OPTIMAL:\n        print(\"Solution:\")\n        print(\"Objective value =\", solver.objective_value)\n        print(\"x =\", solver.value(x))\n        print(\"y =\", solver.value(y))\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n    print(\"\\nAdvanced usage:\")\n    print(\"Problem solved in %f seconds\" % solver.wall_time)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving N-Queens Problem using OR-Tools SAT\nDESCRIPTION: This function implements the main logic to solve the N-Queens problem using OR-Tools' SAT solver. It creates a CP model, defines variables representing queen positions, adds constraints to ensure no two queens threaten each other, solves the model using the `CpSolver`, and prints statistics about the solving process. It takes the board size as input.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/nqueens_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"python\ndef main(board_size: int) -> None:\n    # Creates the solver.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    # There are `board_size` number of variables, one for a queen in each column\n    # of the board. The value of each variable is the row that the queen is in.\n    queens = [model.new_int_var(0, board_size - 1, f\"x_{i}\") for i in range(board_size)]\n\n    # Creates the constraints.\n    # All rows must be different.\n    model.add_all_different(queens)\n\n    # No two queens can be on the same diagonal.\n    model.add_all_different(queens[i] + i for i in range(board_size))\n    model.add_all_different(queens[i] - i for i in range(board_size))\n\n    # Solve the model.\n    solver = cp_model.CpSolver()\n    solution_printer = NQueenSolutionPrinter(queens)\n    solver.parameters.enumerate_all_solutions = True\n    solver.solve(model, solution_printer)\n\n    # Statistics.\n    print(\"\\nStatistics\")\n    print(f\"  conflicts      : {solver.num_conflicts}\")\n    print(f\"  branches       : {solver.num_branches}\")\n    print(f\"  wall time      : {solver.wall_time} s\")\n    print(f\"  solutions found: {solution_printer.solution_count}\")\n\n\n# By default, solve the 8x8 problem.\nsize = 8\nif len(sys.argv) > 1:\n    size = int(sys.argv[1])\nmain(size)\n\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Solving Labeled Dice Puzzle with OR-Tools CP Solver in Python\nDESCRIPTION: This code implements a solution to the Labeled Dice logic puzzle using Google's OR-Tools Constraint Programming Solver. It defines the problem constraints, creates variables for die assignments, and searches for valid solutions that satisfy all puzzle requirements.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/labeled_dice.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Labeled dice\")\n\n  #\n  # data\n  #\n  n = 4\n  m = 24\n  A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, Y = (\n      list(range(m)))\n  letters = [\n      \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\",\n      \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"Y\"\n  ]\n\n  num_words = 13\n  words = [[B, U, O, Y], [C, A, V, E], [C, E, L, T], [F, L, U, B], [F, O, R, K],\n           [H, E, M, P], [J, U, D, Y], [J, U, N, K], [L, I, M, N], [Q, U, I, P],\n           [S, W, A, G], [V, I, S, A], [W, I, S, H]]\n\n  #\n  # declare variables\n  #\n  dice = [solver.IntVar(0, n - 1, \"dice[%i]\" % i) for i in range(m)]\n\n  #\n  # constraints\n  #\n\n  # the letters in a word must be on a different die\n  for i in range(num_words):\n    solver.Add(solver.AllDifferent([dice[words[i][j]] for j in range(n)]))\n\n  # there must be exactly 6 letters of each die\n  for i in range(n):\n    b = [solver.IsEqualCstVar(dice[j], i) for j in range(m)]\n    solver.Add(solver.Sum(b) == 6)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(dice)\n\n  db = solver.Phase(dice, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  #\n  # result\n  #\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    # print \"dice:\", [(letters[i],dice[i].Value()) for i in range(m)]\n    for d in range(n):\n      print(\"die %i:\" % d, end=\" \")\n      for i in range(m):\n        if dice[i].Value() == d:\n          print(letters[i], end=\" \")\n      print()\n\n    print(\"The words with the cube label:\")\n    for i in range(num_words):\n      for j in range(n):\n        print(\n            \"%s (%i)\" % (letters[words[i][j]], dice[words[i][j]].Value()),\n            end=\" \")\n      print()\n\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Nurse Rostering Main Implementation\nDESCRIPTION: Main implementation of the nurse rostering solution using OR-Tools. Sets up the problem with nurses, days, shifts, and constraints, then solves using CP solver with visualization of results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nurse_rostering.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n  solver = pywrapcp.Solver('Nurse rostering using regular')\n  num_nurses = 7\n  num_days = 14\n  day_shift = 1\n  night_shift = 2\n  off_shift = 3\n  shifts = [day_shift, night_shift, off_shift]\n  n_states = 6\n  input_max = 3\n  initial_state = 1\n  accepting_states = [1, 2, 3, 4, 5, 6]\n  transition_fn = [\n      [2, 3, 1],\n      [4, 4, 1],\n      [4, 5, 1],\n      [6, 6, 1],\n      [6, 0, 1],\n      [0, 0, 1]\n  ]\n  days = ['d', 'n', 'o']\n  x = {}\n  for i in range(num_nurses):\n    for j in range(num_days):\n      x[i, j] = solver.IntVar(shifts, 'x[%i,%i]' % (i, j))\n  x_flat = [x[i, j] for i in range(num_nurses) for j in range(num_days)]\n  nurse_stat = [solver.IntVar(0, num_days, 'nurse_stat[%i]' % i) for i in range(num_nurses)]\n  day_stat = {}\n  for i in range(num_days):\n    for j in shifts:\n      day_stat[i, j] = solver.IntVar(0, num_nurses, 'day_stat[%i,%i]' % (i, j))\n```\n\n----------------------------------------\n\nTITLE: Implementing RCPSP Solver with CP-SAT\nDESCRIPTION: A comprehensive implementation of a Resource-Constrained Project Scheduling Problem solver using Google OR-Tools CP-SAT. The code includes problem analysis, constraint modeling, and graph analysis functions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nimport time\nfrom typing import Optional\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\nfrom ortools.scheduling import rcpsp_pb2\nfrom ortools.scheduling.python import rcpsp\n\n_INPUT = flags.define_string(\"input\", \"\", \"Input file to parse and solve.\")\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\"params\", \"\", \"Sat solver parameters.\")\n_USE_INTERVAL_MAKESPAN = flags.define_bool(\n    \"use_interval_makespan\",\n    True,\n    \"Whether we encode the makespan using an interval or not.\",\n)\n_HORIZON = flags.define_integer(\"horizon\", -1, \"Force horizon.\")\n_ADD_REDUNDANT_ENERGETIC_CONSTRAINTS = flags.define_bool(\n    \"add_redundant_energetic_constraints\",\n    False,\n    \"add redundant energetic constraints on the pairs of tasks extracted from\"\n    + \" precedence graph.\",\n)\n_DELAY_TIME_LIMIT = flags.define_float(\n    \"pairwise_delay_total_time_limit\",\n    120.0,\n    \"Total time limit when computing min delay between tasks.\"\n    + \" A non-positive time limit disable min delays computation.\",\n)\n_PREEMPTIVE_LB_TIME_LIMIT = flags.define_float(\n    \"preemptive_lb_time_limit\",\n    0.0,\n    \"Time limit when computing a preemptive schedule lower bound.\"\n    + \" A non-positive time limit disable this computation.\",\n)\n\n\ndef print_problem_statistics(problem: rcpsp_pb2.RcpspProblem):\n    \"\"\"Display various statistics on the problem.\"\"\"\n\n    # Determine problem type.\n    problem_type = (\n        \"Resource Investment Problem\" if problem.is_resource_investment else \"RCPSP\"\n    )\n\n    num_resources = len(problem.resources)\n    num_tasks = len(problem.tasks) - 2  # 2 sentinels.\n    tasks_with_alternatives = 0\n    variable_duration_tasks = 0\n    tasks_with_delay = 0\n\n    for task in problem.tasks:\n        if len(task.recipes) > 1:\n            tasks_with_alternatives += 1\n            duration_0 = task.recipes[0].duration\n            for recipe in task.recipes:\n                if recipe.duration != duration_0:\n                    variable_duration_tasks += 1\n                    break\n        if task.successor_delays:\n            tasks_with_delay += 1\n\n    if problem.is_rcpsp_max:\n        problem_type += \"/Max delay\"\n    # We print 2 less tasks as these are sentinel tasks that are not counted in\n    # the description of the rcpsp models.\n    if problem.is_consumer_producer:\n        print(f\"Solving {problem_type} with:\")\n        print(f\"  - {num_resources} reservoir resources\")\n        print(f\"  - {num_tasks} tasks\")\n    else:\n        print(f\"Solving {problem_type} with:\")\n        print(f\"  - {num_resources} renewable resources\")\n        print(f\"  - {num_tasks} tasks\")\n        if tasks_with_alternatives:\n            print(f\"    - {tasks_with_alternatives} tasks with alternative resources\")\n        if variable_duration_tasks:\n            print(f\"    - {variable_duration_tasks} tasks with variable durations\")\n        if tasks_with_delay:\n            print(f\"    - {tasks_with_delay} tasks with successor delays\")\n\n\ndef analyse_dependency_graph(\n    problem: rcpsp_pb2.RcpspProblem,\n) -> tuple[list[tuple[int, int, list[int]]], dict[int, list[int]]]:\n    \"\"\"Analyses the dependency graph to improve the model.\n\n    Args:\n      problem: the protobuf of the problem to solve.\n\n    Returns:\n      a list of (task1, task2, in_between_tasks) with task2 and indirect successor\n      of task1, and in_between_tasks being the list of all tasks after task1 and\n      before task2.\n    \"\"\"\n\n    num_nodes = len(problem.tasks)\n    print(f\"Analysing the dependency graph over {num_nodes} nodes\")\n\n    ins = collections.defaultdict(list)\n    outs = collections.defaultdict(list)\n    after = collections.defaultdict(set)\n    before = collections.defaultdict(set)\n\n    # Build the transitive closure of the precedences.\n    # This algorithm has the wrong complexity (n^4), but is OK for the psplib\n    # as the biggest example has 120 nodes.\n    for n in range(num_nodes):\n        for s in problem.tasks[n].successors:\n            ins[s].append(n)\n            outs[n].append(s)\n\n            for a in list(after[s]) + [s]:\n                for b in list(before[n]) + [n]:\n                    after[b].add(a)\n                    before[a].add(b)\n\n    # Search for pair of tasks, containing at least two parallel branch between\n    # them in the precedence graph.\n    num_candidates = 0\n    result: list[tuple[int, int, list[int]]] = []\n    for source, start_outs in outs.items():\n        if len(start_outs) <= 1:\n            # Starting with the unique successor of source will be as good.\n            continue\n        for sink, end_ins in ins.items():\n            if len(end_ins) <= 1:\n                # Ending with the unique predecessor of sink will be as good.\n                continue\n            if sink == source:\n                continue\n            if sink not in after[source]:\n                continue\n\n            num_active_outgoing_branches = 0\n            num_active_incoming_branches = 0\n            for succ in outs[source]:\n                if sink in after[succ]:\n                    num_active_outgoing_branches += 1\n            for pred in ins[sink]:\n                if source in before[pred]:\n                    num_active_incoming_branches += 1\n\n            if num_active_outgoing_branches <= 1 or num_active_incoming_branches <= 1:\n                continue\n\n            common = after[source].intersection(before[sink])\n            if len(common) <= 1:\n                continue\n            num_candidates += 1\n            result.append((source, sink, common))\n\n    # Sort entries lexicographically by (len(common), source, sink)\n    def price(entry):\n        return num_nodes * num_nodes * len(entry[2]) + num_nodes * entry[0] + entry[1]\n\n    result.sort(key=price)\n    print(f\"  - created {len(result)} pairs of nodes to examine\", flush=True)\n    return result, after\n\n\ndef solve_rcpsp(\n    problem: rcpsp_pb2.RcpspProblem,\n    proto_file: str,\n    params: str,\n    active_tasks: set[int],\n    source: int,\n    sink: int,\n    intervals_of_tasks: list[tuple[int, int, list[int]]],\n    delays: dict[tuple[int, int], tuple[int, int]],\n    in_main_solve: bool = False,\n    initial_solution: Optional[rcpsp_pb2.RcpspAssignment] = None,\n    lower_bound: int = 0,\n) -> tuple[int, int, Optional[rcpsp_pb2.RcpspAssignment]]:\n    \"\"\"Parse and solve a given RCPSP problem in proto format.\n\n    The model will only look at the tasks {source} + {sink} + active_tasks, and\n    ignore all others.\n\n    Args:\n      problem: the description of the model to solve in protobuf format\n      proto_file: the name of the file to export the CpModel proto to.\n      params: the string representation of the parameters to pass to the sat\n        solver.\n      active_tasks: the set of active tasks to consider.\n      source: the source task in the graph. Its end will be forced to 0.\n      sink: the sink task of the graph. Its start is the makespan of the problem.\n      intervals_of_tasks: a heuristic lists of (task1, task2, tasks) used to add\n        redundant energetic equations to the model.\n      delays: a list of (task1, task2, min_delays) used to add extended precedence\n        constraints (start(task2) >= end(task1) + min_delay).\n      in_main_solve: indicates if this is the main solve procedure.\n      initial_solution: A valid assignment used to hint the search.\n      lower_bound: A valid lower bound of the makespan objective.\n\n    Returns:\n      (lower_bound of the objective, best solution found, assignment)\n    \"\"\"\n    # Create the model.\n    model = cp_model.CpModel()\n    model.name = problem.name\n\n    num_resources = len(problem.resources)\n\n    all_active_tasks = list(active_tasks)\n    all_active_tasks.sort()\n    all_resources = range(num_resources)\n\n    horizon = problem.deadline if problem.deadline != -1 else problem.horizon\n    if _HORIZON.value > 0:\n        horizon = _HORIZON.value\n    elif delays and in_main_solve and (source, sink) in delays:\n        horizon = delays[(source, sink)][1]\n    elif horizon == -1:  # Naive computation.\n        horizon = sum(max(r.duration for r in t.recipes) for t in problem.tasks)\n        if problem.is_rcpsp_max:\n            for t in problem.tasks:\n                for sd in t.successor_delays:\n                    for rd in sd.recipe_delays:\n                        for d in rd.min_delays:\n                            horizon += abs(d)\n    if in_main_solve:\n        print(f\"Horizon = {horizon}\", flush=True)\n\n    # Containers.\n    task_starts = {}\n    task_ends = {}\n    task_durations = {}\n    task_intervals = {}\n    task_resource_to_energy = {}\n    task_to_resource_demands = collections.defaultdict(list)\n\n    task_to_presence_literals = collections.defaultdict(list)\n    task_to_recipe_durations = collections.defaultdict(list)\n    task_resource_to_fixed_demands = collections.defaultdict(dict)\n    task_resource_to_max_energy = collections.defaultdict(int)\n\n    resource_to_sum_of_demand_max = collections.defaultdict(int)\n```\n\n----------------------------------------\n\nTITLE: Multiple Knapsack Problem Initialization and Solving with CP-SAT\nDESCRIPTION: Python script using CP-SAT solver to solve multiple knapsack problem with item weights, values, and bin capacities. Maximizes total packed value while respecting bin capacity constraints\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/multiple_knapsack_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef main() -> None:\n    data = {}\n    data[\"weights\"] = [48, 30, 42, 36, 36, 48, 42, 42, 36, 24, 30, 30, 42, 36, 36]\n    data[\"values\"] = [10, 30, 25, 50, 35, 30, 15, 40, 30, 35, 45, 10, 20, 30, 25]\n    assert len(data[\"weights\"]) == len(data[\"values\"])\n    num_items = len(data[\"weights\"])\n    all_items = range(num_items)\n\n    data[\"bin_capacities\"] = [100, 100, 100, 100, 100]\n    num_bins = len(data[\"bin_capacities\"])\n    all_bins = range(num_bins)\n\n    model = cp_model.CpModel()\n\n    # Variables.\n    # x[i, b] = 1 if item i is packed in bin b.\n    x = {}\n    for i in all_items:\n        for b in all_bins:\n            x[i, b] = model.new_bool_var(f\"x_{i}_{b}\")\n\n    # Constraints.\n    # Each item is assigned to at most one bin.\n    for i in all_items:\n        model.add_at_most_one(x[i, b] for b in all_bins)\n\n    # The amount packed in each bin cannot exceed its capacity.\n    for b in all_bins:\n        model.add(\n            sum(x[i, b] * data[\"weights\"][i] for i in all_items)\n            <= data[\"bin_capacities\"][b]\n        )\n\n    # Objective.\n    # maximize total value of packed items.\n    objective = []\n    for i in all_items:\n        for b in all_bins:\n            objective.append(cp_model.LinearExpr.term(x[i, b], data[\"values\"][i]))\n    model.maximize(cp_model.LinearExpr.sum(objective))\n\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"Total packed value: {solver.objective_value}\")\n        total_weight = 0\n        for b in all_bins:\n            print(f\"Bin {b}\")\n            bin_weight = 0\n            bin_value = 0\n            for i in all_items:\n                if solver.value(x[i, b]) > 0:\n                    print(\n                        f'Item:{i} weight:{data[\"weights\"][i]} value:{data[\"values\"][i]}'\n                    )\n                    bin_weight += data[\"weights\"][i]\n                    bin_value += data[\"values\"][i]\n            print(f\"Packed bin weight: {bin_weight}\")\n            print(f\"Packed bin value: {bin_value}\\n\")\n            total_weight += bin_weight\n        print(f\"Total packed weight: {total_weight}\")\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Three Jugs Problem Main Solution Logic\nDESCRIPTION: Main function implementing the Three Jugs problem solution using the regular constraint. Sets up the DFA states, transitions, and executes the constraint solver to find valid solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_regular.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(n):\n  solver = pywrapcp.Solver('3 jugs problem using regular constraint')\n  n_states = 14\n  input_max = 15\n  initial_state = 1\n  accepting_states = [15]\n\n  states = [\n      [2, 9], [3], [4, 9], [5], [6, 9], [7], [8, 9], [15],\n      [10], [11], [12], [13], [14], [15]\n  ]\n\n  transition_fn = []\n  for i in range(n_states):\n    row = []\n    for j in range(1, input_max + 1):\n      if j in states[i]:\n        row.append(j)\n      else:\n        row.append(0)\n    transition_fn.append(row)\n\n  x = [solver.IntVar(1, input_max, 'x[%i]' % i) for i in range(n)]\n\n  regular(x, n_states, input_max, transition_fn, initial_state, accepting_states)\n\n  db = solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  x_val = []\n  while solver.NextSolution():\n    num_solutions += 1\n    x_val = [1] + [x[i].Value() for i in range(n)]\n\n  solver.EndSearch()\n  return x_val\n```\n\n----------------------------------------\n\nTITLE: Solving Rabbits and Pheasants Problem in Go using OR-Tools\nDESCRIPTION: Implements a constraint satisfaction problem to determine the number of rabbits and pheasants given total animals (20) and total legs (56). Uses Google OR-Tools CP-SAT solver with linear constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n)\n\nconst numAnimals = 20\n\nfunc rabbitsAndPheasants() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tallAnimals := cpmodel.NewDomain(0, numAnimals)\n\trabbits := model.NewIntVarFromDomain(allAnimals).WithName(\"rabbits\")\n\tpheasants := model.NewIntVarFromDomain(allAnimals).WithName(\"pheasants\")\n\n\tmodel.AddEquality(cpmodel.NewLinearExpr().AddSum(rabbits, pheasants), cpmodel.NewConstant(numAnimals))\n\tmodel.AddEquality(cpmodel.NewLinearExpr().AddTerm(rabbits, 4).AddTerm(pheasants, 2), cpmodel.NewConstant(56))\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tresponse, err := cpmodel.SolveCpModel(m)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tswitch response.GetStatus() {\n\tcase cmpb.CpSolverStatus_OPTIMAL, cmpb.CpSolverStatus_FEASIBLE:\n\t\tfmt.Printf(\"There are %d rabbits and %d pheasants.\\n\",\n\t\t\tcpmodel.SolutionIntegerValue(response, rabbits),\n\t\t\tcpmodel.SolutionIntegerValue(response, pheasants))\n\tdefault:\n\t\tfmt.Println(\"No solution found.\")\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := rabbitsAndPheasants(); err != nil {\n\t\tlog.Exitf(\"rabbitsAndPheasants returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Nonogram Solver Implementation\nDESCRIPTION: Complete implementation of a Nonogram solver using OR-Tools, including regular constraint handling, transition matrix creation, and rule checking. The code supports arbitrary puzzle sizes and includes visualization of solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_regular.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef regular(x, Q, S, d, q0, F):\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    row = []\n    for j in range(S):\n      if i == 0:\n        row.append(0)\n      else:\n        row.append(d[i - 1][j])\n    d2.append(row)\n\n  d2_flatten = [d2[i][j] for i in range(Q + 1) for j in range(S)]\n\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n\n  a = [solver.IntVar(0, Q + 1, 'a[%i]' % i) for i in range(m, n + 1)]\n\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n    solver.Add(\n        a[i + 1] == solver.Element(d2_flatten, ((a[i]) * S) + (x[i] - 1)))\n\n\ndef make_transition_matrix(pattern):\n  p_len = len(pattern)\n  num_states = p_len + sum(pattern)\n\n  if num_states == 0:\n    num_states = 1\n\n  t_matrix = []\n  for i in range(num_states):\n    row = []\n    for j in range(2):\n      row.append(0)\n    t_matrix.append(row)\n\n  tmp = [0 for i in range(num_states)]\n  c = 0\n  tmp[c] = 0\n  for i in range(p_len):\n    for j in range(pattern[i]):\n      c += 1\n      tmp[c] = 1\n    if c < num_states - 1:\n      c += 1\n      tmp[c] = 0\n\n  t_matrix[num_states - 1][0] = num_states\n  t_matrix[num_states - 1][1] = 0\n\n  for i in range(num_states):\n    if tmp[i] == 0:\n      t_matrix[i][0] = i + 1\n      t_matrix[i][1] = i + 2\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          t_matrix[i][0] = 0\n          t_matrix[i][1] = i + 2\n        else:\n          t_matrix[i][0] = i + 2\n          t_matrix[i][1] = 0\n\n  return t_matrix\n\n\ndef check_rule(rules, y):\n  solver = y[0].solver()\n\n  r_len = sum([1 for i in range(len(rules)) if rules[i] > 0])\n  rules_tmp = []\n  for i in range(len(rules)):\n    if rules[i] > 0:\n      rules_tmp.append(rules[i])\n\n  transition_fn = make_transition_matrix(rules_tmp)\n  n_states = len(transition_fn)\n  input_max = 2\n\n  initial_state = 1\n  accepting_states = [n_states]\n\n  regular(y, n_states, input_max, transition_fn, initial_state,\n          accepting_states)\n\n\ndef main(rows, row_rule_len, row_rules, cols, col_rule_len, col_rules):\n  solver = pywrapcp.Solver('Regular test')\n\n  board = {}\n  for i in range(rows):\n    for j in range(cols):\n      board[i, j] = solver.IntVar(1, 2, 'board[%i,%i]' % (i, j))\n  board_flat = [board[i, j] for i in range(rows) for j in range(cols)]\n\n  board_label = []\n  if rows * row_rule_len < cols * col_rule_len:\n    for i in range(rows):\n      for j in range(cols):\n        board_label.append(board[i, j])\n  else:\n    for j in range(cols):\n      for i in range(rows):\n        board_label.append(board[i, j])\n\n  for i in range(rows):\n    check_rule([row_rules[i][j] for j in range(row_rule_len)],\n               [board[i, j] for j in range(cols)])\n\n  for j in range(cols):\n    check_rule([col_rules[j][k] for k in range(col_rule_len)],\n               [board[i, j] for i in range(rows)])\n\n  db = solver.Phase(board_label, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print()\n    num_solutions += 1\n    for i in range(rows):\n      row = [board[i, j].Value() - 1 for j in range(cols)]\n      row_pres = []\n      for j in row:\n        if j == 1:\n          row_pres.append('#')\n        else:\n          row_pres.append(' ')\n      print('  ', ''.join(row_pres))\n\n    print()\n    print('  ', '-' * cols)\n\n    if num_solutions >= 2:\n      print('2 solutions is enough...')\n      break\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n```\n\n----------------------------------------\n\nTITLE: Solving Min Cost Flow with OR-Tools\nDESCRIPTION: This Python code demonstrates how to solve a minimum cost flow problem using the OR-Tools library. It initializes a `SimpleMinCostFlow` solver, defines the network with nodes, arcs, capacities, costs, and supplies, and then uses the solver to find the optimal flow.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/graph/simple_min_cost_flow_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"import numpy as np\n\nfrom ortools.graph.python import min_cost_flow\n\n\ndef main():\n    \"\"\"MinCostFlow simple interface example.\"\"\"\n    # Instantiate a SimpleMinCostFlow solver.\n    smcf = min_cost_flow.SimpleMinCostFlow()\n\n    # Define four parallel arrays: sources, destinations, capacities,\n    # and unit costs between each pair. For instance, the arc from node 0\n    # to node 1 has a capacity of 15.\n    start_nodes = np.array([0, 0, 1, 1, 1, 2, 2, 3, 4])\n    end_nodes = np.array([1, 2, 2, 3, 4, 3, 4, 4, 2])\n    capacities = np.array([15, 8, 20, 4, 10, 15, 4, 20, 5])\n    unit_costs = np.array([4, 4, 2, 2, 6, 1, 3, 2, 3])\n\n    # Define an array of supplies at each node.\n    supplies = [20, 0, 0, -5, -15]\n\n    # Add arcs, capacities and costs in bulk using numpy.\n    all_arcs = smcf.add_arcs_with_capacity_and_unit_cost(\n        start_nodes, end_nodes, capacities, unit_costs\n    )\n\n    # Add supply for each nodes.\n    smcf.set_nodes_supplies(np.arange(0, len(supplies)), supplies)\n\n    # Find the min cost flow.\n    status = smcf.solve()\n\n    if status != smcf.OPTIMAL:\n        print(\"There was an issue with the min cost flow input.\")\n        print(f\"Status: {status}\")\n        exit(1)\n    print(f\"Minimum cost: {smcf.optimal_cost()}\")\n    print(\"\")\n    print(\" Arc    Flow / Capacity Cost\")\n    solution_flows = smcf.flows(all_arcs)\n    costs = solution_flows * unit_costs\n    for arc, flow, cost in zip(all_arcs, solution_flows, costs):\n        print(\n            f\"{smcf.tail(arc):1} -> \"\n            f\"{smcf.head(arc)}  {flow:3}  / {smcf.capacity(arc):3}       {cost}\"\n        )\n\n\nmain()\n\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Grocery Problem Solver using Google CP Solver in Python\nDESCRIPTION: This code implements a solution to the Grocery problem using Google's CP Solver. It defines variables, constraints, and search parameters to find the prices of four items that sum and multiply to $7.11.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/grocery.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\nfrom functools import reduce\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Grocery\")\n\n  #\n  # data\n  #\n  n = 4\n  c = 711\n\n  #\n  # declare variables\n  #\n  item = [solver.IntVar(0, c, \"item[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.Sum(item) == c)\n  solver.Add(reduce(lambda x, y: x * y, item) == c * 100**3)\n\n  # symmetry breaking\n  for i in range(1, n):\n    solver.Add(item[i - 1] < item[i])\n\n  #\n  # search and result\n  #\n  db = solver.Phase(item, solver.INT_VAR_SIMPLE, solver.INT_VALUE_SIMPLE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"item:\", [item[i].Value() for i in range(n)])\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Scheduling with Calendar using CP-SAT in Python\nDESCRIPTION: This snippet defines a function that models and solves a scheduling problem where a 3-hour task needs to be scheduled within a workday (8h-18h) with a lunch break (13h-14h). It uses the CP-SAT solver from Google OR-Tools to find all possible solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/scheduling_with_calendar_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef scheduling_with_calendar_sample_sat():\n    \"\"\"Interval spanning across a lunch break.\"\"\"\n    model = cp_model.CpModel()\n\n    # The data is the following:\n    #   Work starts at 8h, ends at 18h, with a lunch break between 13h and 14h.\n    #   We need to schedule a task that needs 3 hours of processing time.\n    #   Total duration can be 3 or 4 (if it spans the lunch break).\n    #\n    # Because the duration is at least 3 hours, work cannot start after 15h.\n    # Because of the break, work cannot start at 13h.\n\n    start = model.new_int_var_from_domain(\n        cp_model.Domain.from_intervals([(8, 12), (14, 15)]), \"start\"\n    )\n    duration = model.new_int_var(3, 4, \"duration\")\n    end = model.new_int_var(8, 18, \"end\")\n    unused_interval = model.new_interval_var(start, duration, end, \"interval\")\n\n    # We have 2 states (spanning across lunch or not)\n    across = model.new_bool_var(\"across\")\n    non_spanning_hours = cp_model.Domain.from_values([8, 9, 10, 14, 15])\n    model.add_linear_expression_in_domain(start, non_spanning_hours).only_enforce_if(\n        ~across\n    )\n    model.add_linear_constraint(start, 11, 12).only_enforce_if(across)\n    model.add(duration == 3).only_enforce_if(~across)\n    model.add(duration == 4).only_enforce_if(across)\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy(\n        [start], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE\n    )\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print all solutions.\n    solution_printer = VarArraySolutionPrinter([start, duration, across])\n    solver.solve(model, solution_printer)\n\n\nscheduling_with_calendar_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Machine Scheduling in OR-Tools\nDESCRIPTION: This function solves a complex single machine jobshop scheduling problem using CP-SAT. It initializes data like job durations, setup times, due dates, and release dates, then creates a constraint model with interval variables and no-overlap constraints to find an optimal schedule.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/single_machine_scheduling_with_setup_release_due_dates_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef single_machine_scheduling():\n    \"\"\"Solves a complex single machine jobshop scheduling problem.\"\"\"\n\n    parameters = _PARAMS.value\n    output_proto_file = _OUTPUT_PROTO.value\n\n    # ----------------------------------------------------------------------------\n    # Data.\n\n    job_durations = [\n        2546,\n        8589,\n        5953,\n        3710,\n        3630,\n        3016,\n        4148,\n        8706,\n        1604,\n        5502,\n        9983,\n        6209,\n        9920,\n        7860,\n        2176,\n    ]\n\n    setup_times = [\n        [\n            3559,\n            1638,\n            2000,\n            3676,\n            2741,\n            2439,\n            2406,\n            1526,\n            1600,\n            3356,\n            4324,\n            1923,\n            3663,\n            4103,\n            2215,\n        ],\n        [\n            1442,\n            3010,\n            1641,\n            4490,\n            2060,\n            2143,\n            3376,\n            3891,\n            3513,\n            2855,\n            2653,\n            1471,\n            2257,\n            1186,\n            2354,\n        ],\n        [\n            1728,\n            3583,\n            3243,\n            4080,\n            2191,\n            3644,\n            4023,\n            3510,\n            2135,\n            1346,\n            1410,\n            3565,\n            3181,\n            1126,\n            4169,\n        ],\n        [\n            1291,\n            1703,\n            3103,\n            4001,\n            1712,\n            1137,\n            3341,\n            3485,\n            2557,\n            2435,\n            1972,\n            1986,\n            1522,\n            4734,\n            2520,\n        ],\n        [\n            4134,\n            2200,\n            1502,\n            3995,\n            1277,\n            1808,\n            1020,\n            2078,\n            2999,\n            1605,\n            1697,\n            2323,\n            2268,\n            2288,\n            4856,\n        ],\n        [\n            4974,\n            2480,\n            2492,\n            4088,\n            2587,\n            4652,\n            1478,\n            3942,\n            1222,\n            3305,\n            1206,\n            1024,\n            2605,\n            3080,\n            3516,\n        ],\n        [\n            1903,\n            2584,\n            2104,\n            1609,\n            4745,\n            2691,\n            1539,\n            2544,\n            2499,\n            2074,\n            4793,\n            1756,\n            2190,\n            1298,\n            2605,\n        ],\n        [\n            1407,\n            2536,\n            2296,\n            1769,\n            1449,\n            3386,\n            3046,\n            1180,\n            4132,\n            4783,\n            3386,\n            3429,\n            2450,\n            3376,\n            3719,\n        ],\n        [\n            3026,\n            1637,\n            3628,\n            3096,\n            1498,\n            4947,\n            1912,\n            3703,\n            4107,\n            4730,\n            1805,\n            2189,\n            1789,\n            1985,\n            3586,\n        ],\n        [\n            3940,\n            1342,\n            1601,\n            2737,\n            1748,\n            3771,\n            4052,\n            1619,\n            2558,\n            3782,\n            4383,\n            3451,\n            4904,\n            1108,\n            1750,\n        ],\n        [\n            1348,\n            3162,\n            1507,\n            3936,\n            1453,\n            2953,\n            4182,\n            2968,\n            3134,\n            1042,\n            3175,\n            2805,\n            4901,\n            1735,\n            1654,\n        ],\n        [\n            1099,\n            1711,\n            1245,\n            1067,\n            4343,\n            3407,\n            1108,\n            1784,\n            4803,\n            2342,\n            3377,\n            2037,\n            3563,\n            1621,\n            2840,\n        ],\n        [\n            2573,\n            4222,\n            3164,\n            2563,\n            3231,\n            4731,\n            2395,\n            1033,\n            4795,\n            3288,\n            2335,\n            4935,\n            4066,\n            1440,\n            4979,\n        ],\n        [\n            3321,\n            1666,\n            3573,\n            2377,\n            4649,\n            4600,\n            1065,\n            2475,\n            3658,\n            3374,\n            1138,\n            4367,\n            4728,\n            3032,\n            2198,\n        ],\n        [\n            2986,\n            1180,\n            4095,\n            3132,\n            3987,\n            3880,\n            3526,\n            1460,\n            4885,\n            3827,\n            4945,\n            4419,\n            3486,\n            3805,\n            3804,\n        ],\n        [\n            4163,\n            3441,\n            1217,\n            2941,\n            1210,\n            3794,\n            1779,\n            1904,\n            4255,\n            4967,\n            4003,\n            3873,\n            1002,\n            2055,\n            4295,\n        ],\n    ]\n\n    due_dates = [\n        -1,\n        -1,\n        28569,\n        -1,\n        98104,\n        27644,\n        55274,\n        57364,\n        -1,\n        -1,\n        60875,\n        96637,\n        77888,\n        -1,\n        -1,\n    ]\n    release_dates = [0, 0, 0, 0, 19380, 0, 0, 48657, 0, 27932, 0, 0, 24876, 0, 0]\n\n    precedences = [(0, 2), (1, 2)]\n\n    # ----------------------------------------------------------------------------\n    # Helper data.\n    num_jobs = len(job_durations)\n    all_jobs = range(num_jobs)\n\n    # ----------------------------------------------------------------------------\n    # Preprocess.\n    if _PREPROCESS.value:\n        for job_id in all_jobs:\n            min_incoming_setup = min(\n                setup_times[j][job_id] for j in range(num_jobs + 1)\n            )\n            if release_dates[job_id] != 0:\n                min_incoming_setup = min(min_incoming_setup, release_dates[job_id])\n            if min_incoming_setup == 0:\n                continue\n\n            print(f\"job {job_id} has a min incoming setup of {min_incoming_setup}\")\n            # We can transfer some setup times to the duration of the job.\n            job_durations[job_id] += min_incoming_setup\n            # Decrease corresponding incoming setup times.\n            for j in range(num_jobs + 1):\n                setup_times[j][job_id] -= min_incoming_setup\n            # Adjust release dates if needed.\n            if release_dates[job_id] != 0:\n                release_dates[job_id] -= min_incoming_setup\n\n    # ----------------------------------------------------------------------------\n    # Model.\n    model = cp_model.CpModel()\n\n    # ----------------------------------------------------------------------------\n    # Compute a maximum makespan greedily.\n    horizon = sum(job_durations) + sum(\n        max(setup_times[i][j] for i in range(num_jobs + 1)) for j in range(num_jobs)\n    )\n    print(f\"Greedy horizon = {horizon}\")\n\n    # ----------------------------------------------------------------------------\n    # Global storage of variables.\n    intervals = []\n    starts = []\n    ends = []\n\n    # ----------------------------------------------------------------------------\n    # Scan the jobs and create the relevant variables and intervals.\n    for job_id in all_jobs:\n        duration = job_durations[job_id]\n        release_date = release_dates[job_id]\n        due_date = due_dates[job_id] if due_dates[job_id] != -1 else horizon\n        print(\n            f\"job {job_id:2}: start = {release_date:5}, duration = {duration:4},\"\n            f\" end = {due_date:6}\"\n        )\n        name_suffix = f\"_{job_id}\"\n        start = model.new_int_var(release_date, due_date, \"s\" + name_suffix)\n        end = model.new_int_var(release_date, due_date, \"e\" + name_suffix)\n        interval = model.new_interval_var(start, duration, end, \"i\" + name_suffix)\n        starts.append(start)\n        ends.append(end)\n        intervals.append(interval)\n\n    # No overlap constraint.\n    model.add_no_overlap(intervals)\n\n    # ----------------------------------------------------------------------------\n    # Transition times using a circuit constraint.\n    arcs = []\n    for i in all_jobs:\n        # Initial arc from the dummy node (0) to a task.\n        start_lit = model.new_bool_var(\"\")\n        arcs.append((0, i + 1, start_lit))\n        # If this task is the first, set to minimum starting time.\n        min_start_time = max(release_dates[i], setup_times[0][i])\n        model.add(starts[i] == min_start_time).only_enforce_if(start_lit)\n        # Final arc from an arc to the dummy node.\n        arcs.append((i + 1, 0, model.new_bool_var(\"\")))\n\n        for j in all_jobs:\n            if i == j:\n                continue\n\n            lit = model.new_bool_var(f\"{j} follows {i}\")\n            arcs.append((i + 1, j + 1, lit))\n\n            # We add the reified precedence to link the literal with the times of the\n            # two tasks.\n            # If release_dates[j] == 0, we can strenghten this precedence into an\n            # equality as we are minimizing the makespan.\n            if release_dates[j] == 0:\n                model.add(starts[j] == ends[i] + setup_times[i + 1][j]).only_enforce_if(\n                    lit\n                )\n            else:\n```\n\n----------------------------------------\n\nTITLE: Implementing Weighted Latency Problem Solver with CP-SAT\nDESCRIPTION: Complete implementation of a weighted latency problem solver using OR-Tools. It includes problem generation with random nodes on a grid, profit assignment, and solving with the CP-SAT solver to minimize weighted latency.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/weighted_latency_problem_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport random\nfrom typing import Sequence\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_NUM_NODES = flags.define_integer(\"num_nodes\", 12, \"Number of nodes to visit.\")\n_GRID_SIZE = flags.define_integer(\"grid_size\", 20, \"Size of the grid where nodes are.\")\n_PROFIT_RANGE = flags.define_integer(\"profit_range\", 50, \"Range of profit.\")\n_SEED = flags.define_integer(\"seed\", 0, \"Random seed.\")\n_PARAMS = flags.define_string(\n    \"params\", \"num_search_workers:16, max_time_in_seconds:5\", \"Sat solver parameters.\"\n)\n_PROTO_FILE = flags.define_string(\n    \"proto_file\", \"\", \"If not empty, output the proto to this file.\"\n)\n\n\ndef build_model():\n    \"\"\"Create the nodes and the profit.\"\"\"\n    random.seed(_SEED.value)\n    x = []\n    y = []\n    x.append(random.randint(0, _GRID_SIZE.value))\n    y.append(random.randint(0, _GRID_SIZE.value))\n    for _ in range(_NUM_NODES.value):\n        x.append(random.randint(0, _GRID_SIZE.value))\n        y.append(random.randint(0, _GRID_SIZE.value))\n\n    profits = []\n    profits.append(0)\n    for _ in range(_NUM_NODES.value):\n        profits.append(random.randint(1, _PROFIT_RANGE.value))\n    sum_of_profits = sum(profits)\n    profits = [p / sum_of_profits for p in profits]\n\n    return x, y, profits\n\n\ndef solve_with_cp_sat(x, y, profits) -> None:\n    \"\"\"Solves the problem with the CP-SAT solver.\"\"\"\n    model = cp_model.CpModel()\n\n    # because of the manhattan distance, the sum of distances is bounded by this.\n    horizon = _GRID_SIZE.value * 2 * _NUM_NODES.value\n    times = [\n        model.new_int_var(0, horizon, f\"x_{i}\") for i in range(_NUM_NODES.value + 1)\n    ]\n\n    # Node 0 is the start node.\n    model.add(times[0] == 0)\n\n    # Create the circuit constraint.\n    arcs = []\n    for i in range(_NUM_NODES.value + 1):\n        for j in range(_NUM_NODES.value + 1):\n            if i == j:\n                continue\n            # We use a manhattan distance between nodes.\n            distance = abs(x[i] - x[j]) + abs(y[i] - y[j])\n            lit = model.new_bool_var(f\"{i}_to_{j}\")\n            arcs.append((i, j, lit))\n\n            # add transitions between nodes.\n            if i == 0:\n                # Initial transition\n                model.add(times[j] == distance).only_enforce_if(lit)\n            elif j != 0:\n                # We do not care for the last transition.\n                model.add(times[j] == times[i] + distance).only_enforce_if(lit)\n    model.add_circuit(arcs)\n\n    model.minimize(cp_model.LinearExpr.weighted_sum(times, profits))\n\n    if _PROTO_FILE.value:\n        model.export_to_file(_PROTO_FILE.value)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n    solver.parameters.log_search_progress = True\n    solver.solve(model)\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n\n    x, y, profits = build_model()\n    solve_with_cp_sat(x, y, profits)\n    # TODO(user): Implement routing model.\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Traffic Lights Constraint Programming Implementation\nDESCRIPTION: Main implementation of the traffic lights problem using OR-Tools. Models a four-way junction with 8 traffic lights (4 vehicle, 4 pedestrian) using constraint programming to find valid light combinations that ensure safety. Uses AllowedAssignments constraint to define valid state transitions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/traffic_lights.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(base=10, start=1, len1=1, len2=4):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Traffic lights\")\n\n  #\n  # data\n  #\n  n = 4\n  r, ry, g, y = list(range(n))\n  lights = [\"r\", \"ry\", \"g\", \"y\"]\n\n  # The allowed combinations\n  allowed = []\n  allowed.extend([(r, r, g, g), (ry, r, y, r), (g, g, r, r), (y, r, ry, r)])\n\n  #\n  # declare variables\n  #\n  V = [solver.IntVar(0, n - 1, \"V[%i]\" % i) for i in range(n)]\n  P = [solver.IntVar(0, n - 1, \"P[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  for i in range(n):\n    for j in range(n):\n      if j == (1 + i) % n:\n        solver.Add(solver.AllowedAssignments((V[i], P[i], V[j], P[j]), allowed))\n\n  #\n  # Search and result\n  #\n  db = solver.Phase(V + P, solver.INT_VAR_SIMPLE, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    for i in range(n):\n      print(\"%+2s %+2s\" % (lights[V[i].Value()], lights[P[i].Value()]), end=\" \")\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Partition Problem with Google CP Solver in Python\nDESCRIPTION: This code implements the set partition problem using Google's CP Solver. It defines the problem, creates variables and constraints, and searches for solutions. The implementation supports partitioning a set into multiple subsets with equal cardinality, sum, and sum of squares.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_partition.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\n#\n# Partition the sets (binary matrix representation).\n#\ndef partition_sets(x, num_sets, n):\n  solver = list(x.values())[0].solver()\n\n  for i in range(num_sets):\n    for j in range(num_sets):\n      if i != j:\n        b = solver.Sum([x[i, k] * x[j, k] for k in range(n)])\n        solver.Add(b == 0)\n\n  # ensure that all integers is in\n  # (exactly) one partition\n  b = [x[i, j] for i in range(num_sets) for j in range(n)]\n  solver.Add(solver.Sum(b) == n)\n\n\ndef main(n=16, num_sets=2):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set partition\")\n\n  #\n  # data\n  #\n  print(\"n:\", n)\n  print(\"num_sets:\", num_sets)\n  print()\n\n  # Check sizes\n  assert n % num_sets == 0, \"Equal sets is not possible.\"\n\n  #\n  # variables\n  #\n\n  # the set\n  a = {}\n  for i in range(num_sets):\n    for j in range(n):\n      a[i, j] = solver.IntVar(0, 1, \"a[%i,%i]\" % (i, j))\n\n  a_flat = [a[i, j] for i in range(num_sets) for j in range(n)]\n\n  #\n  # constraints\n  #\n\n  # partition set\n  partition_sets(a, num_sets, n)\n\n  for i in range(num_sets):\n    for j in range(i, num_sets):\n\n      # same cardinality\n      solver.Add(\n          solver.Sum([a[i, k] for k in range(n)]) == solver.Sum(\n              [a[j, k] for k in range(n)]))\n\n      # same sum\n      solver.Add(\n          solver.Sum([k * a[i, k] for k in range(n)]) == solver.Sum(\n              [k * a[j, k] for k in range(n)]))\n\n      # same sum squared\n      solver.Add(\n          solver.Sum([(k * a[i, k]) * (k * a[i, k]) for k in range(n)]) ==\n          solver.Sum([(k * a[j, k]) * (k * a[j, k]) for k in range(n)]))\n\n  # symmetry breaking for num_sets == 2\n  if num_sets == 2:\n    solver.Add(a[0, 0] == 1)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(a_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    a_val = {}\n    for i in range(num_sets):\n      for j in range(n):\n        a_val[i, j] = a[i, j].Value()\n\n    sq = sum([(j + 1) * a_val[0, j] for j in range(n)])\n    print(\"sums:\", sq)\n    sq2 = sum([((j + 1) * a_val[0, j])**2 for j in range(n)])\n    print(\"sums squared:\", sq2)\n\n    for i in range(num_sets):\n      if sum([a_val[i, j] for j in range(n)]):\n        print(i + 1, \":\", end=\" \")\n        for j in range(n):\n          if a_val[i, j] == 1:\n            print(j + 1, end=\" \")\n        print()\n\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 16\nnum_sets = 2\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nif len(sys.argv) > 2:\n  num_sets = int(sys.argv[2])\n\nmain(n, num_sets)\n```\n\n----------------------------------------\n\nTITLE: Bus Driver Scheduling Implementation with CP-SAT\nDESCRIPTION: Complete implementation of a bus driver scheduling problem using the CP-SAT solver from OR-Tools. The code includes sample data for shifts, constraint definitions for working time limits, breaks, and preparation/cleaning times.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nimport math\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:16,log_search_progress:true,max_time_in_seconds:30\",\n    \"Sat solver parameters.\",\n)\n_INSTANCE = flags.define_integer(\n    \"instance\", 0, \"Instance to select (0, 1, 2, 3).\", 0, 3\n)\n\nSAMPLE_SHIFTS_TINY = [\n    #\n    # column description:\n    # - shift id\n    # - shift start time as hh:mm string (for logging and readability purposes)\n    # - shift end time as hh:mm string (for logging and readability purposes)\n    # - shift start minute\n    # - shift end minute\n    # - shift duration in minutes\n    #\n    [1, \"08:00\", \"09:05\", 480, 545, 65],\n    [2, \"08:00\", \"08:35\", 480, 515, 35],\n    [3, \"08:11\", \"09:41\", 491, 581, 90],\n    [4, \"08:28\", \"08:50\", 508, 530, 22],\n    [5, \"08:35\", \"08:45\", 515, 525, 10],\n    [6, \"08:40\", \"08:50\", 520, 530, 10],\n    [7, \"09:03\", \"10:28\", 543, 628, 85],\n    [8, \"09:23\", \"09:49\", 563, 589, 26],\n    [9, \"09:30\", \"09:40\", 570, 580, 10],\n    [10, \"09:57\", \"10:20\", 597, 620, 23],\n    [11, \"10:09\", \"11:03\", 609, 663, 54],\n    [12, \"10:20\", \"10:30\", 620, 630, 10],\n    [13, \"11:00\", \"11:10\", 660, 670, 10],\n    [14, \"11:45\", \"12:24\", 705, 744, 39],\n    [15, \"12:18\", \"13:00\", 738, 780, 42],\n    [16, \"13:18\", \"14:44\", 798, 884, 86],\n    [17, \"13:53\", \"14:49\", 833, 889, 56],\n    [18, \"14:03\", \"14:50\", 843, 890, 47],\n    [19, \"14:28\", \"15:15\", 868, 915, 47],\n    [20, \"14:30\", \"15:41\", 870, 941, 71],\n    [21, \"14:48\", \"15:35\", 888, 935, 47],\n    [22, \"15:03\", \"15:50\", 903, 950, 47],\n    [23, \"15:28\", \"16:54\", 928, 1014, 86],\n    [24, \"15:38\", \"16:25\", 938, 985, 47],\n    [25, \"15:40\", \"15:56\", 940, 956, 16],\n    [26, \"15:58\", \"16:45\", 958, 1005, 47],\n    [27, \"16:04\", \"17:30\", 964, 1050, 86],\n]  # yapf:disable\n\nSAMPLE_SHIFTS_SMALL = [\n    #\n    # column description:\n    # - shift id\n    # - shift start time as hh:mm string (for logging and readability purposes)\n    # - shift end time as hh:mm string (for logging and readability purposes)\n    # - shift start minute\n    # - shift end minute\n    # - shift duration in minutes\n    #\n    [0, \"05:18\", \"06:00\", 318, 360, 42],\n    [1, \"05:26\", \"06:08\", 326, 368, 42],\n    [2, \"05:40\", \"05:56\", 340, 356, 16],\n    [3, \"06:06\", \"06:51\", 366, 411, 45],\n    [4, \"06:40\", \"07:52\", 400, 472, 72],\n    [5, \"06:42\", \"07:13\", 402, 433, 31],\n    [6, \"06:48\", \"08:15\", 408, 495, 87],\n    [7, \"06:59\", \"08:07\", 419, 487, 68],\n    [8, \"07:20\", \"07:36\", 440, 456, 16],\n    [9, \"07:35\", \"08:22\", 455, 502, 47],\n    [10, \"07:50\", \"08:55\", 470, 535, 65],\n    [11, \"08:00\", \"09:05\", 480, 545, 65],\n    [12, \"08:00\", \"08:35\", 480, 515, 35],\n    [13, \"08:11\", \"09:41\", 491, 581, 90],\n    [14, \"08:28\", \"08:50\", 508, 530, 22],\n    [15, \"08:35\", \"08:45\", 515, 525, 10],\n    [16, \"08:40\", \"08:50\", 520, 530, 10],\n    [17, \"09:03\", \"10:28\", 543, 628, 85],\n    [18, \"09:23\", \"09:49\", 563, 589, 26],\n    [19, \"09:30\", \"09:40\", 570, 580, 10],\n    [20, \"09:57\", \"10:20\", 597, 620, 23],\n    [21, \"10:09\", \"11:03\", 609, 663, 54],\n    [22, \"10:20\", \"10:30\", 620, 630, 10],\n    [23, \"11:00\", \"11:10\", 660, 670, 10],\n    [24, \"11:45\", \"12:24\", 705, 744, 39],\n    [25, \"12:18\", \"13:00\", 738, 780, 42],\n    [26, \"13:18\", \"14:44\", 798, 884, 86],\n    [27, \"13:53\", \"14:49\", 833, 889, 56],\n    [28, \"14:03\", \"14:50\", 843, 890, 47],\n    [29, \"14:28\", \"15:15\", 868, 915, 47],\n    [30, \"14:30\", \"15:41\", 870, 941, 71],\n    [31, \"14:48\", \"15:35\", 888, 935, 47],\n    [32, \"15:03\", \"15:50\", 903, 950, 47],\n    [33, \"15:28\", \"16:54\", 928, 1014, 86],\n    [34, \"15:38\", \"16:25\", 938, 985, 47],\n    [35, \"15:40\", \"15:56\", 940, 956, 16],\n    [36, \"15:58\", \"16:45\", 958, 1005, 47],\n    [37, \"16:04\", \"17:30\", 964, 1050, 86],\n    [38, \"16:28\", \"17:15\", 988, 1035, 47],\n    [39, \"16:36\", \"17:21\", 996, 1041, 45],\n    [40, \"16:50\", \"17:00\", 1010, 1020, 10],\n    [41, \"16:54\", \"18:20\", 1014, 1100, 86],\n    [42, \"17:01\", \"17:13\", 1021, 1033, 12],\n    [43, \"17:19\", \"18:31\", 1039, 1111, 72],\n    [44, \"17:23\", \"18:10\", 1043, 1090, 47],\n    [45, \"17:34\", \"18:15\", 1054, 1095, 41],\n    [46, \"18:04\", \"19:29\", 1084, 1169, 85],\n    [47, \"18:34\", \"19:58\", 1114, 1198, 84],\n    [48, \"19:56\", \"20:34\", 1196, 1234, 38],\n    [49, \"20:05\", \"20:48\", 1205, 1248, 43],\n]  # yapf:disable\n\nSAMPLE_SHIFTS_MEDIUM = [\n    [0, \"04:30\", \"04:53\", 270, 293, 23],\n    [1, \"04:46\", \"04:56\", 286, 296, 10],\n    [2, \"04:52\", \"05:56\", 292, 356, 64],\n    [3, \"04:53\", \"05:23\", 293, 323, 30],\n    [4, \"05:07\", \"05:44\", 307, 344, 37],\n    [5, \"05:10\", \"06:06\", 310, 366, 56],\n    [6, \"05:18\", \"06:03\", 318, 363, 45],\n    [7, \"05:30\", \"05:40\", 330, 340, 10],\n    [8, \"05:30\", \"05:40\", 330, 340, 10],\n    [9, \"05:33\", \"06:15\", 333, 375, 42],\n    [10, \"05:40\", \"05:50\", 340, 350, 10],\n    [11, \"05:43\", \"06:08\", 343, 368, 25],\n    [12, \"05:54\", \"07:20\", 354, 440, 86],\n    [13, \"06:04\", \"06:37\", 364, 397, 33],\n    [14, \"06:13\", \"06:58\", 373, 418, 45],\n    [15, \"06:14\", \"07:40\", 374, 460, 86],\n    [16, \"06:15\", \"07:15\", 375, 435, 60],\n    [17, \"06:16\", \"06:26\", 376, 386, 10],\n    [18, \"06:17\", \"06:34\", 377, 394, 17],\n    [19, \"06:20\", \"06:36\", 380, 396, 16],\n    [20, \"06:22\", \"07:06\", 382, 426, 44],\n    [21, \"06:24\", \"07:50\", 384, 470, 86],\n    [22, \"06:27\", \"06:44\", 387, 404, 17],\n    [23, \"06:30\", \"06:40\", 390, 400, 10],\n    [24, \"06:31\", \"06:43\", 391, 403, 12],\n    [25, \"06:33\", \"07:53\", 393, 473, 80],\n    [26, \"06:34\", \"07:09\", 394, 429, 35],\n    [27, \"06:40\", \"06:56\", 400, 416, 16],\n    [28, \"06:44\", \"07:17\", 404, 437, 33],\n    [29, \"06:46\", \"06:58\", 406, 418, 12],\n    [30, \"06:49\", \"07:43\", 409, 463, 54],\n    [31, \"06:50\", \"07:05\", 410, 425, 15],\n    [32, \"06:52\", \"07:36\", 412, 456, 44],\n    [33, \"06:54\", \"07:27\", 414, 447, 33],\n    [34, \"06:56\", \"08:23\", 416, 503, 87],\n    [35, \"07:04\", \"07:44\", 424, 464, 40],\n    [36, \"07:11\", \"08:36\", 431, 516, 85],\n    [37, \"07:17\", \"07:35\", 437, 455, 18],\n    [38, \"07:22\", \"08:06\", 442, 486, 44],\n    [39, \"07:27\", \"08:15\", 447, 495, 48],\n    [40, \"07:35\", \"07:45\", 455, 465, 10],\n    [41, \"07:43\", \"08:08\", 463, 488, 25],\n    [42, \"07:50\", \"08:37\", 470, 517, 47],\n    [43, \"07:58\", \"08:45\", 478, 525, 47],\n    [44, \"08:00\", \"08:35\", 480, 515, 35],\n    [45, \"08:06\", \"08:51\", 486, 531, 45],\n    [46, \"08:10\", \"08:45\", 490, 525, 35],\n    [47, \"08:15\", \"08:30\", 495, 510, 15],\n    [48, \"08:16\", \"09:00\", 496, 540, 44],\n    [49, \"08:18\", \"09:16\", 498, 556, 58],\n    [50, \"08:20\", \"08:36\", 500, 516, 16],\n    [51, \"08:27\", \"09:07\", 507, 547, 40],\n    [52, \"08:30\", \"08:45\", 510, 525, 15],\n    [53, \"08:35\", \"09:15\", 515, 555, 40],\n    [54, \"08:46\", \"09:30\", 526, 570, 44],\n    [55, \"08:51\", \"09:17\", 531, 557, 26],\n    [56, \"08:55\", \"09:15\", 535, 555, 20],\n    [57, \"08:58\", \"09:38\", 538, 578, 40],\n    [58, \"09:00\", \"09:35\", 540, 575, 35],\n    [59, \"09:00\", \"09:16\", 540, 556, 16],\n    [60, \"09:20\", \"09:36\", 560, 576, 16],\n    [61, \"09:31\", \"09:43\", 571, 583, 12],\n    [62, \"09:33\", \"10:15\", 573, 615, 42],\n    [63, \"09:54\", \"10:05\", 594, 605, 11],\n    [64, \"10:11\", \"10:38\", 611, 638, 27],\n    [65, \"10:18\", \"11:00\", 618, 660, 42],\n    [66, \"10:21\", \"10:47\", 621, 647, 26],\n    [67, \"10:25\", \"11:04\", 625, 664, 39],\n    [68, \"10:26\", \"11:08\", 626, 668, 42],\n    [69, \"10:44\", \"12:11\", 644, 731, 87],\n    [70, \"11:00\", \"11:16\", 660, 676, 16],\n    [71, \"11:15\", \"11:54\", 675, 714, 39],\n    [72, \"11:16\", \"11:28\", 676, 688, 12],\n    [73, \"11:20\", \"11:30\", 680, 690, 10],\n    [74, \"11:21\", \"11:47\", 681, 707, 26],\n    [75, \"11:25\", \"12:04\", 685, 724, 39],\n    [76, \"11:34\", \"11:45\", 694, 705, 11],\n    [77, \"11:35\", \"12:14\", 695, 734, 39],\n    [78, \"11:41\", \"12:23\", 701, 743, 42],\n    [79, \"11:44\", \"12:35\", 704, 755, 51],\n    [80, \"11:46\", \"11:58\", 706, 718, 12],\n    [81, \"12:00\", \"12:10\", 720, 730, 10],\n    [82, \"12:04\", \"12:15\", 724, 735, 11],\n    [83, \"12:04\", \"13:04\", 724, 784, 60],\n    [84, \"12:11\", \"12:38\", 731, 758, 27],\n    [85, \"12:15\", \"12:54\", 735, 774, 39],\n    [86, \"12:25\", \"13:10\", 745, 790, 45],\n    [87, \"12:30\", \"12:40\", 750, 760, 10],\n    [88, \"12:34\", \"13:58\", 754, 838, 84],\n    [89, \"12:38\", \"13:25\", 758, 805, 47],\n    [90, \"12:48\", \"13:35\", 768, 815, 47],\n    [91, \"13:00\", \"13:16\", 780, 796, 16],\n    [92, \"13:05\", \"13:44\", 785, 824, 39],\n    [93, \"13:08\", \"13:55\", 788, 835, 47],\n    [94, \"13:14\", \"14:38\", 794, 878, 84],\n    [95, \"13:23\", \"13:49\", 803, 829, 26],\n    [96, \"13:25\", \"14:04\", 805, 844, 39],\n    [97, \"13:28\", \"14:54\", 808, 894, 86],\n    [98, \"13:31\", \"13:43\", 811, 823, 12],\n    [99, \"13:34\", \"14:58\", 814, 898, 84],\n    [100, \"13:38\", \"14:25\", 818, 865, 47],\n    [101, \"13:38\", \"15:04\", 818, 904, 86],\n    [102, \"13:39\", \"14:33\", 819, 873, 54],\n    [103, \"13:40\", \"13:50\", 820, 830, 10],\n    [104, \"13:43\", \"14:10\", 823, 850, 27],\n```\n\n----------------------------------------\n\nTITLE: Implementing Hidato Puzzle Solver with Google CP Solver\nDESCRIPTION: Defines the main function that sets up the puzzle, creates variables, adds constraints, and searches for solutions using the CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/hidato.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(r, c):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"hidato\")\n\n  # data\n  # Simple problem\n  if r == 3 and c == 3:\n    puzzle = [[6, 0, 9], [0, 2, 8], [1, 0, 0]]\n\n  if r == 7 and c == 7:\n    puzzle = [[0, 44, 41, 0, 0, 0, 0], [0, 43, 0, 28, 29, 0, 0],\n              [0, 1, 0, 0, 0, 33, 0], [0, 2, 25, 4, 34, 0, 36],\n              [49, 16, 0, 23, 0, 0, 0], [0, 19, 0, 0, 12, 7, 0],\n              [0, 0, 0, 14, 0, 0, 0]]\n\n  # ... [additional puzzle definitions] ...\n\n  print_game(puzzle, r, c)\n\n  # declare variables\n  x = {}\n  for i in range(r):\n    for j in range(c):\n      x[(i, j)] = solver.IntVar(1, r * c, \"dice(%i,%i)\" % (i, j))\n  x_flat = [x[(i, j)] for i in range(r) for j in range(c)]\n\n  # constraints\n  solver.Add(solver.AllDifferent(x_flat))\n\n  # Fill in the clues\n  for i in range(r):\n    for j in range(c):\n      if puzzle[i][j] > 0:\n        solver.Add(x[(i, j)] == puzzle[i][j])\n\n  # ... [additional constraints] ...\n\n  # solution and search\n  solution = solver.Assignment()\n  solution.Add(x_flat)\n\n  db = solver.Phase(\n      x_flat,\n      solver.CHOOSE_FIRST_UNBOUND,\n      solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"\\nSolution:\", num_solutions)\n    print_board(x, r, c)\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Implementing Solution Printer Callback for CP-SAT Solver in Python\nDESCRIPTION: A callback class that prints intermediate solutions during the solving process. It tracks the solution count, execution time, objective value and makespan of each solution found by the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n  \"\"\"Print intermediate solutions.\"\"\"\n\n  def __init__(self, makespan):\n    cp_model.CpSolverSolutionCallback.__init__(self)\n    self.__solution_count = 0\n    self.__makespan = makespan\n\n  def OnSolutionCallback(self):\n    print('Solution %i, time = %f s, objective = %i, makespan = %i' %\n          (self.__solution_count, self.WallTime(), self.ObjectiveValue(),\n           self.Value(self.__makespan)))\n    self.__solution_count += 1\n```\n\n----------------------------------------\n\nTITLE: Solving SEND+MOST=MONEY Puzzle with OR-Tools in Python\nDESCRIPTION: This function sets up and solves the SEND+MOST=MONEY alphametic puzzle using Google OR-Tools. It defines integer variables for each letter, sets constraints for uniqueness and equation correctness, and searches for solutions that maximize MONEY.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/send_most_money.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(MONEY=0):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Send most money')\n\n  # data\n\n  # declare variables\n  s = solver.IntVar(0, 9, 's')\n  e = solver.IntVar(0, 9, 'e')\n  n = solver.IntVar(0, 9, 'n')\n  d = solver.IntVar(0, 9, 'd')\n  m = solver.IntVar(0, 9, 'm')\n  o = solver.IntVar(0, 9, 'o')\n  t = solver.IntVar(0, 9, 't')\n  y = solver.IntVar(0, 9, 'y')\n  money = solver.IntVar(0, 100000, 'money')\n\n  x = [s, e, n, d, m, o, t, y]\n\n  #\n  # constraints\n  #\n  if MONEY > 0:\n    solver.Add(money == MONEY)\n\n  solver.Add(solver.AllDifferent(x))\n  solver.Add(money == m * 10000 + o * 1000 + n * 100 + e * 10 + y)\n  solver.Add(money > 0)\n  solver.Add(1000 * s + 100 * e + 10 * n + d + 1000 * m + 100 * o + 10 * s +\n             t == money)\n  solver.Add(s > 0)\n  solver.Add(m > 0)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(money)\n\n  collector = solver.AllSolutionCollector(solution)\n  objective = solver.Maximize(money, 100)\n  cargs = [collector]\n  if MONEY == 0:\n    objective = solver.Maximize(money, 1)\n    cargs.extend([objective])\n\n  solver.Solve(\n      solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MAX_VALUE),\n      cargs)\n\n  num_solutions = collector.SolutionCount()\n  money_val = 0\n  for s in range(num_solutions):\n    print('x:', [collector.Value(s, x[i]) for i in range(len(x))])\n    money_val = collector.Value(s, money)\n    print('money:', money_val)\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime())\n\n  if MONEY == 0:\n    return money_val\n```\n\n----------------------------------------\n\nTITLE: Creating the Vendor Scheduling Model\nDESCRIPTION: This function constructs a vendor scheduling model using constraint programming. It defines variables, constraints, and solves the model using OR-Tools, while also utilizing the SolutionPrinter to show results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/vendor_scheduling_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef vendor_scheduling_sat() -> None:\n    \"\"\"Create the shift scheduling model and solve it.\"\"\"\n    # Create the model.\n    model = cp_model.CpModel()\n\n    #\n    # data\n    #\n    num_vendors = 9\n    num_hours = 10\n    num_work_types = 1\n\n    traffic = [100, 500, 100, 200, 320, 300, 200, 220, 300, 120]\n    max_traffic_per_vendor = 100\n\n    possible_schedules = [\n        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 8],\n        [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 4],\n        [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 2, 5],\n        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 3, 4],\n        [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 3],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],\n    ]\n\n    selected_schedules = []\n    vendors_stat = []\n    hours_stat = []\n\n    min_vendors = [t // max_traffic_per_vendor for t in traffic]\n    all_vendors = range(num_vendors)\n    all_hours = range(num_hours)\n\n    #\n    # Declare variables\n    #\n    x = {}\n\n    for v in all_vendors:\n        tmp = []\n        for h in all_hours:\n            x[v, h] = model.new_int_var(0, num_work_types, \"x[%i,%i]\" % (v, h))\n            tmp.append(x[v, h])\n        selected_schedule = model.new_int_var(\n            0, num_possible_schedules - 1, \"s[%i]\" % v\n        )\n        hours = model.new_int_var(0, num_hours, \"h[%i]\" % v)\n        selected_schedules.append(selected_schedule)\n        vendors_stat.append(hours)\n        tmp.append(selected_schedule)\n        tmp.append(hours)\n\n        model.add_allowed_assignments(tmp, possible_schedules)\n\n    #\n    # Statistics and constraints for each hour\n    #\n    for h in all_hours:\n        workers = model.new_int_var(0, 1000, \"workers[%i]\" % h)\n        model.add(workers == sum(x[v, h] for v in all_vendors))\n        hours_stat.append(workers)\n        model.add(workers * max_traffic_per_vendor >= traffic[h])\n\n    #\n    # Redundant constraint: sort selected_schedules\n    #\n    for v in range(num_vendors - 1):\n        model.add(selected_schedules[v] <= selected_schedules[v + 1])\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    solver.parameters.enumerate_all_solutions = True\n    solution_printer = SolutionPrinter(\n        num_vendors,\n        num_hours,\n        possible_schedules,\n        selected_schedules,\n        hours_stat,\n        min_vendors,\n    )\n    status = solver.solve(model, solution_printer)\n    print(\"Status = %s\" % solver.status_name(status))\n\n    print(\"Statistics\")\n    print(\"  - conflicts : %i\" % solver.num_conflicts)\n    print(\"  - branches  : %i\" % solver.num_branches)\n    print(\"  - wall time : %f s\" % solver.wall_time)\n    print(\"  - number of solutions found: %i\" % solution_printer.solution_count())\n```\n\n----------------------------------------\n\nTITLE: Minimal Example: Using GLOP Solver in Python\nDESCRIPTION: This code snippet demonstrates how to set up and call the GLOP solver using OR-Tools in Python. It initializes the solver, defines variables and constraints, sets the objective function, and solves the linear program. Dependencies include the ortools package. Key outputs include the solution status and the optimal values of the variables. The input consists of variable bounds and a linear constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/basic_example.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.init.python import init\nfrom ortools.linear_solver import pywraplp\n\n\ndef main():\n    print(\"Google OR-Tools version:\", init.OrToolsVersion.version_string())\n\n    # Create the linear solver with the GLOP backend.\n    solver = pywraplp.Solver.CreateSolver(\"GLOP\")\n    if not solver:\n        print(\"Could not create solver GLOP\")\n        return\n\n    # Create the variables x and y.\n    x_var = solver.NumVar(0, 1, \"x\")\n    y_var = solver.NumVar(0, 2, \"y\")\n\n    print(\"Number of variables =\", solver.NumVariables())\n\n    infinity = solver.infinity()\n    # Create a linear constraint, x + y <= 2.\n    constraint = solver.Constraint(-infinity, 2, \"ct\")\n    constraint.SetCoefficient(x_var, 1)\n    constraint.SetCoefficient(y_var, 1)\n\n    print(\"Number of constraints =\", solver.NumConstraints())\n\n    # Create the objective function, 3 * x + y.\n    objective = solver.Objective()\n    objective.SetCoefficient(x_var, 3)\n    objective.SetCoefficient(y_var, 1)\n    objective.SetMaximization()\n\n    print(f\"Solving with {solver.SolverVersion()}\")\n    result_status = solver.Solve()\n\n    print(f\"Status: {result_status}\")\n    if result_status != pywraplp.Solver.OPTIMAL:\n        print(\"The problem does not have an optimal solution!\")\n        if result_status == pywraplp.Solver.FEASIBLE:\n            print(\"A potentially suboptimal solution was found\")\n        else:\n            print(\"The solver could not solve the problem.\")\n            return\n\n    print(\"Solution:\")\n    print(\"Objective value =\", objective.Value())\n    print(\"x =\", x_var.solution_value())\n    print(\"y =\", y_var.solution_value())\n\n    print(\"Advanced usage:\")\n    print(f\"Problem solved in {solver.wall_time():d} milliseconds\")\n    print(f\"Problem solved in {solver.iterations():d} iterations\")\n\n\ninit.CppBridge.init_logging(\"basic_example.py\")\ncpp_flags = init.CppFlags()\ncpp_flags.stderrthreshold = True\ncpp_flags.log_prefix = False\ninit.CppBridge.set_flags(cpp_flags)\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing KenKen Puzzle Solver with OR-Tools\nDESCRIPTION: Defines the main logic for solving a KenKen puzzle using OR-Tools. It includes functions for calculating segment constraints, setting up the problem, and searching for solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/kenken2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\nfrom functools import reduce\n\ndef calc(cc, x, res):\n  solver = list(x.values())[0].solver()\n\n  if len(cc) == 2:\n    c00, c01 = cc[0]\n    c10, c11 = cc[1]\n    a = x[c00 - 1, c01 - 1]\n    b = x[c10 - 1, c11 - 1]\n\n    r1 = solver.IsEqualCstVar(a + b, res)\n    r2 = solver.IsEqualCstVar(a * b, res)\n    r3 = solver.IsEqualVar(a * res, b)\n    r4 = solver.IsEqualVar(b * res, a)\n    r5 = solver.IsEqualCstVar(a - b, res)\n    r6 = solver.IsEqualCstVar(b - a, res)\n    solver.Add(r1 + r2 + r3 + r4 + r5 + r6 >= 1)\n\n  else:\n    xx = [x[i[0] - 1, i[1] - 1] for i in cc]\n    this_sum = solver.IsEqualCstVar(solver.Sum(xx), res)\n    this_prod = solver.IsEqualCstVar(reduce(lambda a, b: a * b, xx), res)\n    solver.Add(this_sum + this_prod >= 1)\n\ndef main():\n  solver = pywrapcp.Solver(\"KenKen\")\n  n = 6\n  problem = [[11, [[1, 1], [2, 1]]], [2, [[1, 2], [1, 3]]],\n             [20, [[1, 4], [2, 4]]], [6, [[1, 5], [1, 6], [2, 6], [3, 6]]],\n             [3, [[2, 2], [2, 3]]], [3, [[2, 5], [3, 5]]],\n             [240, [[3, 1], [3, 2], [4, 1], [4, 2]]], [6, [[3, 3], [3, 4]]],\n             [6, [[4, 3], [5, 3]]], [7, [[4, 4], [5, 4], [5, 5]]],\n             [30, [[4, 5], [4, 6]]], [6, [[5, 1], [5, 2]]],\n             [9, [[5, 6], [6, 6]]], [8, [[6, 1], [6, 2], [6, 3]]],\n             [2, [[6, 4], [6, 5]]]]\n\n  num_p = len(problem)\n\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[i, j] = solver.IntVar(1, n, \"x[%i,%i]\" % (i, j))\n\n  x_flat = [x[i, j] for i in range(n) for j in range(n)]\n\n  for i in range(n):\n    row = [x[i, j] for j in range(n)]\n    solver.Add(solver.AllDifferent(row))\n\n    col = [x[j, i] for j in range(n)]\n    solver.Add(solver.AllDifferent(col))\n\n  for (res, segment) in problem:\n    calc(segment, x, res)\n\n  db = solver.Phase(x_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    for i in range(n):\n      for j in range(n):\n        print(x[i, j].Value(), end=\" \")\n      print()\n\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing NoOverlap Constraint in Python with OR-Tools\nDESCRIPTION: This example shows how to implement a NoOverlap constraint in Python using OR-Tools CP-SAT solver. It schedules three tasks around fixed weekend periods, minimizing the total makespan. The code creates interval variables for tasks and weekends, adds a NoOverlap constraint, and optimizes for the earliest completion time.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrate how to build a NoOverlap constraint.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef no_overlap_sample_sat():\n    \"\"\"No overlap sample with fixed activities.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 21  # 3 weeks.\n\n    # Task 0, duration 2.\n    start_0 = model.new_int_var(0, horizon, \"start_0\")\n    duration_0 = 2  # Python cp/sat code accepts integer variables or constants.\n    end_0 = model.new_int_var(0, horizon, \"end_0\")\n    task_0 = model.new_interval_var(start_0, duration_0, end_0, \"task_0\")\n    # Task 1, duration 4.\n    start_1 = model.new_int_var(0, horizon, \"start_1\")\n    duration_1 = 4  # Python cp/sat code accepts integer variables or constants.\n    end_1 = model.new_int_var(0, horizon, \"end_1\")\n    task_1 = model.new_interval_var(start_1, duration_1, end_1, \"task_1\")\n\n    # Task 2, duration 3.\n    start_2 = model.new_int_var(0, horizon, \"start_2\")\n    duration_2 = 3  # Python cp/sat code accepts integer variables or constants.\n    end_2 = model.new_int_var(0, horizon, \"end_2\")\n    task_2 = model.new_interval_var(start_2, duration_2, end_2, \"task_2\")\n\n    # Weekends.\n    weekend_0 = model.new_interval_var(5, 2, 7, \"weekend_0\")\n    weekend_1 = model.new_interval_var(12, 2, 14, \"weekend_1\")\n    weekend_2 = model.new_interval_var(19, 2, 21, \"weekend_2\")\n\n    # No Overlap constraint.\n    model.add_no_overlap([task_0, task_1, task_2, weekend_0, weekend_1, weekend_2])\n\n    # Makespan objective.\n    obj = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(obj, [end_0, end_1, end_2])\n    model.minimize(obj)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Print out makespan and the start times for all tasks.\n        print(f\"Optimal Schedule Length: {solver.objective_value}\")\n        print(f\"Task 0 starts at {solver.value(start_0)}\")\n        print(f\"Task 1 starts at {solver.value(start_1)}\")\n        print(f\"Task 2 starts at {solver.value(start_2)}\")\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n\n\nno_overlap_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: BACP Solver Implementation\nDESCRIPTION: Complete implementation of the Balanced Academic Curriculum Problem solver using OR-Tools. Includes data reading, constraint definition, bin packing implementation, and optimization logic to balance course loads across periods while respecting prerequisites.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/bacp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#   Copyright 2010 Pierre Schaus pschaus@gmail.com\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n\nimport argparse\nfrom ortools.constraint_solver import pywrapcp\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\n    '--data', default='examples/contrib/bacp.txt', help='path to data file')\n\n#----------------helper for binpacking posting----------------\n\n\ndef BinPacking(solver, binvars, weights, loadvars):\n  \"\"\"post the load constraint on bins.\n\n  constraints forall j: loadvars[j] == sum_i (binvars[i] == j) * weights[i])\n  \"\"\"\n  pack = solver.Pack(binvars, len(loadvars))\n  pack.AddWeightedSumEqualVarDimension(weights, loadvars)\n  solver.Add(pack)\n  solver.Add(solver.SumEquality(loadvars, sum(weights)))\n\n\n#------------------------------data reading-------------------\n\n\ndef ReadData(filename):\n  \"\"\"Read data from <filename>.\"\"\"\n  f = open(filename)\n  nb_courses, nb_periods, min_credit, max_credit, nb_prereqs =\\\n      [int(nb) for nb in f.readline().split()]\n  credits = [int(nb) for nb in f.readline().split()]\n  prereq = [int(nb) for nb in f.readline().split()]\n  prereq = [(prereq[i * 2], prereq[i * 2 + 1]) for i in range(nb_prereqs)]\n  return (credits, nb_periods, prereq)\n\n\ndef main(args):\n  #------------------solver and variable declaration-------------\n\n  credits, nb_periods, prereq = ReadData(args.data)\n  nb_courses = len(credits)\n\n  solver = pywrapcp.Solver('Balanced Academic Curriculum Problem')\n\n  x = [\n      solver.IntVar(0, nb_periods - 1, 'x' + str(i)) for i in range(nb_courses)\n  ]\n  load_vars = [\n      solver.IntVar(0, sum(credits), 'load_vars' + str(i))\n      for i in range(nb_periods)\n  ]\n\n  #-------------------post of the constraints--------------\n\n  # Bin Packing.\n  BinPacking(solver, x, credits, load_vars)\n  # Add dependencies.\n  for i, j in prereq:\n    solver.Add(x[i] < x[j])\n\n  #----------------Objective-------------------------------\n\n  objective_var = solver.Max(load_vars)\n  objective = solver.Minimize(objective_var, 1)\n\n  #------------start the search and optimization-----------\n\n  db = solver.Phase(x, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.INT_VALUE_DEFAULT)\n\n  search_log = solver.SearchLog(100000, objective_var)\n  solver.Solve(db, [objective, search_log])\n\n\nmain(parser.parse_args())\n\n```\n\n----------------------------------------\n\nTITLE: Killer Sudoku Solver Implementation\nDESCRIPTION: Main implementation of the Killer Sudoku solver using OR-Tools. Includes cage sum calculation, constraint definitions, and solution search. The solver enforces standard Sudoku rules along with additional cage sum constraints specific to Killer Sudoku.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/killer_sudoku.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\ndef calc(cc, x, res):\n  solver = list(x.values())[0].solver()\n  cage = [x[i[0] - 1, i[1] - 1] for i in cc]\n  solver.Add(solver.Sum(cage) == res)\n  solver.Add(solver.AllDifferent(cage))\n\ndef main():\n  solver = pywrapcp.Solver(\"Killer Sudoku\")\n  n = 9\n  problem = [[3, [[1, 1], [1, 2]]], [15, [[1, 3], [1, 4], [1, 5]]],\n             [22, [[1, 6], [2, 5], [2, 6], [3, 5]]], [4, [[1, 7], [2, 7]]],\n             [16, [[1, 8], [2, 8]]], [15, [[1, 9], [2, 9], [3, 9], [4, 9]]],\n             [25, [[2, 1], [2, 2], [3, 1], [3, 2]]], [17, [[2, 3], [2, 4]]],\n             [9, [[3, 3], [3, 4], [4, 4]]], [8, [[3, 6], [4, 6], [5, 6]]],\n             [20, [[3, 7], [3, 8], [4, 7]]], [6, [[4, 1], [5, 1]]],\n             [14, [[4, 2], [4, 3]]], [17, [[4, 5], [5, 5], [6, 5]]],\n             [17, [[4, 8], [5, 7], [5, 8]]], [13, [[5, 2], [5, 3], [6, 2]]],\n             [20, [[5, 4], [6, 4], [7, 4]]], [12, [[5, 9], [6, 9]]],\n             [27, [[6, 1], [7, 1], [8, 1], [9, 1]]],\n             [6, [[6, 3], [7, 2], [7, 3]]], [20, [[6, 6], [7, 6], [7, 7]]],\n             [6, [[6, 7], [6, 8]]], [10, [[7, 5], [8, 4], [8, 5], [9, 4]]],\n             [14, [[7, 8], [7, 9], [8, 8], [8, 9]]], [8, [[8, 2], [9, 2]]],\n             [16, [[8, 3], [9, 3]]], [15, [[8, 6], [8, 7]]],\n             [13, [[9, 5], [9, 6], [9, 7]]], [17, [[9, 8], [9, 9]]]]\n\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[i, j] = solver.IntVar(1, n, \"x[%i,%i]\" % (i, j))\n\n  x_flat = [x[i, j] for i in range(n) for j in range(n)]\n\n  for i in range(n):\n    row = [x[i, j] for j in range(n)]\n    solver.Add(solver.AllDifferent(row))\n    col = [x[j, i] for j in range(n)]\n    solver.Add(solver.AllDifferent(col))\n\n  for i in range(2):\n    for j in range(2):\n      cell = [\n          x[r, c]\n          for r in range(i * 3, i * 3 + 3)\n          for c in range(j * 3, j * 3 + 3)\n      ]\n      solver.Add(solver.AllDifferent(cell))\n\n  for (res, segment) in problem:\n    calc(segment, x, res)\n\n  db = solver.Phase(x_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    for i in range(n):\n      for j in range(n):\n        print(x[i, j].Value(), end=\" \")\n      print()\n\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Local Search Implementation with OR-Tools\nDESCRIPTION: Complete implementation of local search algorithms including Large Neighborhood Search (LNS), basic Local Search, and Local Search with filtering. Includes custom implementations of OneVarLns, MoveOneVar operator, and SumFilter classes for optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/pyls_api.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\nfrom ortools.constraint_solver import pywrapcp\n\nclass OneVarLns(pywrapcp.BaseLns):\n  \"\"\"One Var LNS.\"\"\"\n\n  def __init__(self, vars):\n    pywrapcp.BaseLns.__init__(self, vars)\n    self.__index = 0\n\n  def InitFragments(self):\n    self.__index = 0\n\n  def NextFragment(self):\n    if self.__index < self.Size():\n      self.AppendToFragment(self.__index)\n      self.__index += 1\n      return True\n    else:\n      return False\n\n\nclass MoveOneVar(pywrapcp.IntVarLocalSearchOperator):\n  \"\"\"Move one var up or down.\"\"\"\n\n  def __init__(self, vars):\n    pywrapcp.IntVarLocalSearchOperator.__init__(self, vars)\n    self.__index = 0\n    self.__up = False\n\n  def OneNeighbor(self):\n    current_value = self.OldValue(self.__index)\n    if self.__up:\n      self.SetValue(self.__index, current_value + 1)\n      self.__index = (self.__index + 1) % self.Size()\n    else:\n      self.SetValue(self.__index, current_value - 1)\n    self.__up = not self.__up\n    return True\n\n  def OnStart(self):\n    pass\n\n  def IsIncremental(self):\n    return False\n\n\nclass SumFilter(pywrapcp.IntVarLocalSearchFilter):\n  \"\"\"Filter to speed up LS computation.\"\"\"\n\n  def __init__(self, vars):\n    pywrapcp.IntVarLocalSearchFilter.__init__(self, vars)\n    self.__sum = 0\n\n  def OnSynchronize(self, delta):\n    self.__sum = sum(self.Value(index) for index in range(self.Size()))\n\n  def Accept(self, delta, unused_delta_delta, unused_objective_min,\n             unused_objective_max):\n    solution_delta = delta.IntVarContainer()\n    solution_delta_size = solution_delta.Size()\n    for i in range(solution_delta_size):\n      if not solution_delta.Element(i).Activated():\n        return True\n\n    new_sum = self.__sum\n    for i in range(solution_delta_size):\n      element = solution_delta.Element(i)\n      int_var = element.Var()\n      touched_var_index = self.IndexFromVar(int_var)\n      old_value = self.Value(touched_var_index)\n      new_value = element.Value()\n      new_sum += new_value - old_value\n\n    return new_sum < self.__sum\n\n  def IsIncremental(self):\n    return False\n\n\ndef Solve(type):\n  solver = pywrapcp.Solver('Solve')\n  vars = [solver.IntVar(0, 4) for _ in range(4)]\n  sum_var = solver.Sum(vars).Var()\n  obj = solver.Minimize(sum_var, 1)\n  db = solver.Phase(vars, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MAX_VALUE)\n  ls = None\n\n  if type == 0:  # LNS\n    print('Large Neighborhood Search')\n    one_var_lns = OneVarLns(vars)\n    ls_params = solver.LocalSearchPhaseParameters(sum_var, one_var_lns, db)\n    ls = solver.LocalSearchPhase(vars, db, ls_params)\n  elif type == 1:  # LS\n    print('Local Search')\n    move_one_var = MoveOneVar(vars)\n    ls_params = solver.LocalSearchPhaseParameters(sum_var, move_one_var, db)\n    ls = solver.LocalSearchPhase(vars, db, ls_params)\n  else:\n    print('Local Search with Filter')\n    move_one_var = MoveOneVar(vars)\n    sum_filter = SumFilter(vars)\n    filter_manager = pywrapcp.LocalSearchFilterManager([sum_filter])\n    ls_params = solver.LocalSearchPhaseParameters(sum_var, move_one_var, db, None,\n                                                  filter_manager)\n    ls = solver.LocalSearchPhase(vars, db, ls_params)\n\n  collector = solver.LastSolutionCollector()\n  collector.Add(vars)\n  collector.AddObjective(sum_var)\n  log = solver.SearchLog(1000, obj)\n  solver.Solve(ls, [collector, obj, log])\n  print('Objective value = %d' % collector.ObjectiveValue(0))\n\n\ndef main():\n  Solve(0)\n  Solve(1)\n  Solve(2)\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Bakery Problem Data with Recipes, Resources and Orders in Python\nDESCRIPTION: Creates the problem data for the bakery scheduling problem by defining recipes for various products (croissants, apple pies, etc.), resources (bakers, ovens, etc.), and customer orders with due dates and quantities.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef set_up_data() -> Tuple[List[Recipe], List[Resource], List[Order]]:\n    \"\"\"Set up the bakery problem data.\"\"\"\n\n    # Recipes.\n    croissant_recipe = Recipe(CROISSANT)\n    croissant_recipe.add_task(BAKING, 15, 15)\n    croissant_recipe.add_task(PROOFING, 60, 90)\n    croissant_recipe.add_task(COOKING, 20, 20)\n    croissant_recipe.add_task(DISPLAY, 5, 5 * 60)\n\n    apple_pie_recipe = Recipe(APPLE_PIE)\n    apple_pie_recipe.add_task(BAKING, 25, 25)\n    apple_pie_recipe.add_task(PROOFING, 15, 60)\n    apple_pie_recipe.add_task(COOKING, 30, 30)\n    apple_pie_recipe.add_task(DECORATING, 5, 5)\n    apple_pie_recipe.add_task(DISPLAY, 5, 5 * 60)\n\n    brioche_recipe = Recipe(BRIOCHE)\n    brioche_recipe.add_task(BAKING, 20, 20)\n    brioche_recipe.add_task(PROOFING, 60, 90)\n    brioche_recipe.add_task(COOKING, 30, 30)\n    brioche_recipe.add_task(DISPLAY, 5, 5 * 60)\n\n    chocolate_cake_recipe = Recipe(CHOCOLATE_CAKE)\n    chocolate_cake_recipe.add_task(BAKING, 15, 15)\n    chocolate_cake_recipe.add_task(COOKING, 25, 25)\n    chocolate_cake_recipe.add_task(DECORATING, 15, 15)\n    chocolate_cake_recipe.add_task(DISPLAY, 5, 5 * 60)\n    recipes = [\n        croissant_recipe,\n        apple_pie_recipe,\n        brioche_recipe,\n        chocolate_cake_recipe,\n    ]\n\n    # Resources.\n    baker1 = Resource(\"baker1\", 1).add_skill(BAKING, 1.0)\n    baker2 = Resource(\"baker2\", 1).add_skill(BAKING, 1.0)\n    decorator1 = Resource(\"decorator1\", 1).add_skill(DECORATING, 1.0)\n    waiting_space = Resource(\"waiting_space\", 4).add_skill(PROOFING, 1.0)\n    oven = Resource(\"oven\", 4).add_skill(COOKING, 1.0)\n    display_space = Resource(\"display_space\", 12).add_skill(DISPLAY, 1.0)\n    resources = [baker1, baker2, decorator1, waiting_space, oven, display_space]\n\n    # Orders\n    croissant_7am = Order(\"croissant_7am\", CROISSANT, 7 * 60, 3)\n    croissant_8am = Order(\"croissant_8am\", CROISSANT, 8 * 60, 3)\n    croissant_9am = Order(\"croissant_9am\", CROISSANT, 9 * 60, 2)\n    croissant_10am = Order(\"croissant_10am\", CROISSANT, 10 * 60, 1)\n    croissant_11am = Order(\"croissant_11am\", CROISSANT, 11 * 60, 1)\n    brioche_10am = Order(\"brioche_10am\", BRIOCHE, 10 * 60, 8)\n    brioche_12pm = Order(\"brioche_12pm\", BRIOCHE, 12 * 60, 8)\n    apple_pie_1pm = Order(\"apple_pie_1pm\", APPLE_PIE, 13 * 60, 10)\n    chocolate_4pm = Order(\"chocolate_4pm\", CHOCOLATE_CAKE, 16 * 60, 10)\n    orders = [\n        croissant_7am,\n        croissant_8am,\n        croissant_9am,\n        croissant_10am,\n        croissant_11am,\n        brioche_10am,\n        brioche_12pm,\n        apple_pie_1pm,\n        chocolate_4pm,\n    ]\n\n    return recipes, resources, orders\n```\n\n----------------------------------------\n\nTITLE: Implementing Assignment Problem using MIP in Python\nDESCRIPTION: Defines the main function to solve the assignment problem using Mixed Integer Programming. It sets up the problem data, defines variables and constraints, and solves the optimization problem using either the CBC or GLPK solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/assignment6_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n  print('Solver: ', sol)\n\n  if sol == 'GLPK':\n    solver = pywraplp.Solver.CreateSolver('GLPK')\n  else:\n    solver = pywraplp.Solver.CreateSolver('CBC')\n  if not solver:\n    return\n\n  #\n  # data\n  #\n\n  # number of agents\n  m = 8\n\n  # number of tasks\n  n = 8\n\n  # set of agents\n  I = list(range(m))\n\n  # set of tasks\n  J = list(range(n))\n\n  # cost of allocating task j to agent i\n  # \"\"\"\n  # These data correspond to an example from [Christofides].\n  #\n  # Optimal solution is 76\n  # \"\"\"\n  c = [[13, 21, 20, 12, 8, 26, 22, 11], [12, 36, 25, 41, 40, 11, 4, 8],\n       [35, 32, 13, 36, 26, 21, 13, 37], [34, 54, 7, 8, 12, 22, 11, 40],\n       [21, 6, 45, 18, 24, 34, 12, 48], [42, 19, 39, 15, 14, 16, 28, 46],\n       [16, 34, 38, 3, 34, 40, 22, 24], [26, 20, 5, 17, 45, 31, 37, 43]]\n\n  #\n  # variables\n  #\n\n  # For the output: the assignment as task number.\n  assigned = [solver.IntVar(0, 10000, 'assigned[%i]' % j) for j in J]\n\n  costs = [solver.IntVar(0, 10000, 'costs[%i]' % i) for i in I]\n\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[i, j] = solver.IntVar(0, 1, 'x[%i,%i]' % (i, j))\n\n  # total cost, to be minimized\n  z = solver.Sum([c[i][j] * x[i, j] for i in I for j in J])\n\n  #\n  # constraints\n  #\n  # each agent can perform at most one task\n  for i in I:\n    solver.Add(solver.Sum([x[i, j] for j in J]) <= 1)\n\n  # each task must be assigned exactly to one agent\n  for j in J:\n    solver.Add(solver.Sum([x[i, j] for i in I]) == 1)\n\n  # to which task and what cost is person i assigned (for output in MiniZinc)\n  for i in I:\n    solver.Add(assigned[i] == solver.Sum([j * x[i, j] for j in J]))\n    solver.Add(costs[i] == solver.Sum([c[i][j] * x[i, j] for j in J]))\n\n  # objective\n  objective = solver.Minimize(z)\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n  print('z: ', int(solver.Objective().Value()))\n\n  print('Assigned')\n  for j in J:\n    print(int(assigned[j].SolutionValue()), end=' ')\n  print()\n\n  print('Matrix:')\n  for i in I:\n    for j in J:\n      print(int(x[i, j].SolutionValue()), end=' ')\n    print()\n  print()\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n\n\n\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Integer Programming Implementation with OR-Tools\nDESCRIPTION: Complete implementation of integer programming examples using OR-Tools library. Includes both natural language and C++ style APIs with functions to solve and print results. The code demonstrates optimization problems with different solvers and provides utility functions for solution verification and output formatting.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/integer_programming.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef Announce(solver, api_type):\n    print(\n        \"---- Integer programming example with \" + solver + \" (\" + api_type + \") -----\"\n    )\n\n\ndef RunIntegerExampleNaturalLanguageAPI(optimization_problem_type):\n    \"\"\"Example of simple integer program with natural language API.\"\"\"\n\n    solver = pywraplp.Solver.CreateSolver(optimization_problem_type)\n    if not solver:\n        return\n\n    Announce(optimization_problem_type, \"natural language API\")\n\n    infinity = solver.infinity()\n    # x1 and x2 are integer non-negative variables.\n    x1 = solver.IntVar(0.0, infinity, \"x1\")\n    x2 = solver.IntVar(0.0, infinity, \"x2\")\n\n    solver.Minimize(x1 + 2 * x2)\n    solver.Add(3 * x1 + 2 * x2 >= 17)\n\n    SolveAndPrint(solver, [x1, x2])\n\n\ndef RunIntegerExampleCppStyleAPI(optimization_problem_type):\n    \"\"\"Example of simple integer program with the C++ style API.\"\"\"\n    solver = pywraplp.Solver.CreateSolver(optimization_problem_type)\n    if not solver:\n        return\n\n    Announce(optimization_problem_type, \"C++ style API\")\n\n    infinity = solver.infinity()\n    # x1 and x2 are integer non-negative variables.\n    x1 = solver.IntVar(0.0, infinity, \"x1\")\n    x2 = solver.IntVar(0.0, infinity, \"x2\")\n\n    # Minimize x1 + 2 * x2.\n    objective = solver.Objective()\n    objective.SetCoefficient(x1, 1)\n    objective.SetCoefficient(x2, 2)\n\n    # 2 * x2 + 3 * x1 >= 17.\n    ct = solver.Constraint(17, infinity)\n    ct.SetCoefficient(x1, 3)\n    ct.SetCoefficient(x2, 2)\n\n    SolveAndPrint(solver, [x1, x2])\n\n\ndef SolveAndPrint(solver, variable_list):\n    \"\"\"Solve the problem and print the solution.\"\"\"\n    print(\"Number of variables = %d\" % solver.NumVariables())\n    print(\"Number of constraints = %d\" % solver.NumConstraints())\n\n    result_status = solver.Solve()\n\n    # The problem has an optimal solution.\n    assert result_status == pywraplp.Solver.OPTIMAL\n\n    # The solution looks legit (when using solvers others than\n    # GLOP_LINEAR_PROGRAMMING, verifying the solution is highly recommended!).\n    assert solver.VerifySolution(1e-7, True)\n\n    print(\"Problem solved in %f milliseconds\" % solver.wall_time())\n\n    # The objective value of the solution.\n    print(\"Optimal objective value = %f\" % solver.Objective().Value())\n\n    # The value of each variable in the solution.\n    for variable in variable_list:\n        print(\"%s = %f\" % (variable.name(), variable.solution_value()))\n\n    print(\"Advanced usage:\")\n    print(\"Problem solved in %d branch-and-bound nodes\" % solver.nodes())\n\n\ndef RunAllIntegerExampleNaturalLanguageAPI():\n    RunIntegerExampleNaturalLanguageAPI(\"GLPK\")\n    # Disabling due to ASAN errors with CBC.\n    # RunIntegerExampleNaturalLanguageAPI('CBC')\n    RunIntegerExampleNaturalLanguageAPI(\"SCIP\")\n    RunIntegerExampleNaturalLanguageAPI(\"SAT\")\n    RunIntegerExampleNaturalLanguageAPI(\"XPRESS\")\n\n\ndef RunAllIntegerExampleCppStyleAPI():\n    RunIntegerExampleCppStyleAPI(\"GLPK\")\n    # Disabling due to ASAN errors with CBC.\n    # RunIntegerExampleCppStyleAPI('CBC')\n    RunIntegerExampleCppStyleAPI(\"SCIP\")\n    RunIntegerExampleCppStyleAPI(\"SAT\")\n    RunIntegerExampleCppStyleAPI(\"XPRESS\")\n\n\ndef main():\n    RunAllIntegerExampleNaturalLanguageAPI()\n    RunAllIntegerExampleCppStyleAPI()\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Least Square Optimization Implementation\nDESCRIPTION: Main implementation of least square optimization using OR-Tools solver. The code creates a model to fit a fourth-degree polynomial to temperature-gas percentage data, with constraints ensuring specific boundary conditions and monotonicity. Uses either CBC or GLPK solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/least_square.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  # data\n  # number of points\n  num = 14\n\n  # temperature\n  t = [20, 30, 80, 125, 175, 225, 275, 325, 360, 420, 495, 540, 630, 700]\n\n  # percentage gas\n  F = [\n      0.0, 5.8, 14.7, 31.6, 43.2, 58.3, 78.4, 89.4, 96.4, 99.1, 99.5, 99.9,\n      100.0, 100.0\n  ]\n\n  p = 4\n\n  #\n  # declare variables\n  #\n  a = [solver.NumVar(-100, 100, 'a[%i]' % i) for i in range(p + 1)]\n\n  # to minimize\n  z = solver.Sum([\n      (F[i] - (sum([a[j] * t[i]**j for j in range(p + 1)]))) for i in range(num)\n  ])\n\n  #\n  # constraints\n  #\n  solver.Add(solver.Sum([20**i * a[i] for i in range(p + 1)]) == 0)\n\n  solver.Add((a[0] + sum([700.0**j * a[j] for j in range(1, p + 1)])) == 100.0)\n\n  for i in range(num):\n    solver.Add(\n        solver.Sum([j * a[j] * t[i]**(j - 1) for j in range(p + 1)]) >= 0)\n\n  objective = solver.Minimize(z)\n\n  solver.Solve()\n\n  print()\n  print('z = ', solver.Objective().Value())\n  for i in range(p + 1):\n    print(a[i].SolutionValue(), end=' ')\n  print()\n\n\n\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Setting up and solving 2D bin packing with OR-Tools CP-SAT model\nDESCRIPTION: Creates a constraint programming model for a 2D bin packing problem with rotation capability. The code defines coordinate variables for each rectangle, sets constraints for item placement (including rotation options), avoids overlaps, and maximizes the total value of used items.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n    data_availability = data[\"available\"].to_numpy()\n    data_values = data[\"value\"].to_numpy()\n\n    item_widths = np.repeat(data_widths, data_availability)\n    item_heights = np.repeat(data_heights, data_availability)\n    item_values = np.repeat(data_values, data_availability)\n\n    num_items = len(item_widths)\n\n    # OR-Tools model.\n    model = cp_model.CpModel()\n\n    # Coordinate variables for each rectangle.\n    x_starts = []\n    x_sizes = []\n    x_ends = []\n    y_starts = []\n    y_sizes = []\n    y_ends = []\n    x_intervals = []\n    y_intervals = []\n\n    for i in range(num_items):\n        sizes = [0, int(item_widths[i]), int(item_heights[i])]\n        # X coordinates.\n        x_starts.append(model.new_int_var(0, max_width, f\"x_start{i}\"))\n        x_sizes.append(\n            model.new_int_var_from_domain(\n                cp_model.Domain.FromValues(sizes), f\"x_size{i}\"\n            )\n        )\n        x_ends.append(model.new_int_var(0, max_width, f\"x_end{i}\"))\n\n        # Y coordinates.\n        y_starts.append(model.new_int_var(0, max_height, f\"y_start{i}\"))\n        y_sizes.append(\n            model.new_int_var_from_domain(\n                cp_model.Domain.FromValues(sizes), f\"y_size{i}\"\n            )\n        )\n        y_ends.append(model.new_int_var(0, max_height, f\"y_end{i}\"))\n\n        ## Interval variables\n        x_intervals.append(\n            model.new_interval_var(x_starts[i], x_sizes[i], x_ends[i], f\"x_interval{i}\")\n        )\n        y_intervals.append(\n            model.new_interval_var(y_starts[i], y_sizes[i], y_ends[i], f\"y_interval{i}\")\n        )\n\n    # is_used[i] == True if and only if item i is selected.\n    is_used = []\n\n    # Constraints.\n\n    ## for each item, decide is unselected, no_rotation, rotated.\n    for i in range(num_items):\n        not_selected = model.new_bool_var(f\"not_selected_{i}\")\n        no_rotation = model.new_bool_var(f\"no_rotation_{i}\")\n        rotated = model.new_bool_var(f\"rotated_{i}\")\n\n        ### Exactly one state must be chosen.\n        model.add_exactly_one(not_selected, no_rotation, rotated)\n\n        ### Define height and width according to the state.\n        dim1 = item_widths[i]\n        dim2 = item_heights[i]\n        # Unused boxes are fixed at (0.0).\n        model.add(x_sizes[i] == 0).only_enforce_if(not_selected)\n        model.add(y_sizes[i] == 0).only_enforce_if(not_selected)\n        model.add(x_starts[i] == 0).only_enforce_if(not_selected)\n        model.add(y_starts[i] == 0).only_enforce_if(not_selected)\n        # Sizes are fixed by the rotation.\n        model.add(x_sizes[i] == dim1).only_enforce_if(no_rotation)\n        model.add(y_sizes[i] == dim2).only_enforce_if(no_rotation)\n        model.add(x_sizes[i] == dim2).only_enforce_if(rotated)\n        model.add(y_sizes[i] == dim1).only_enforce_if(rotated)\n\n        is_used.append(~not_selected)\n\n    ## 2D no overlap.\n    model.add_no_overlap_2d(x_intervals, y_intervals)\n\n    # Objective.\n    model.maximize(cp_model.LinearExpr.weighted_sum(is_used, item_values))\n```\n\n----------------------------------------\n\nTITLE: Implementing Knapsack Problem Solver with MIP in Python\nDESCRIPTION: This code implements a knapsack problem solver using Mixed Integer Programming (MIP) in Google OR-Tools. It defines the problem data, sets up variables and constraints, and solves the optimization problem to maximize the total value while respecting capacity constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/knapsack_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n  print('Solver: ', sol)\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  #\n  # data\n  #\n  nb_items = 12\n  nb_resources = 7\n  items = list(range(nb_items))\n  resources = list(range(nb_resources))\n\n  capacity = [18209, 7692, 1333, 924, 26638, 61188, 13360]\n  value = [96, 76, 56, 11, 86, 10, 66, 86, 83, 12, 9, 81]\n  use = [[19, 1, 10, 1, 1, 14, 152, 11, 1, 1, 1, 1],\n         [0, 4, 53, 0, 0, 80, 0, 4, 5, 0, 0, 0],\n         [4, 660, 3, 0, 30, 0, 3, 0, 4, 90, 0, 0],\n         [7, 0, 18, 6, 770, 330, 7, 0, 0, 6, 0, 0],\n         [0, 20, 0, 4, 52, 3, 0, 0, 0, 5, 4, 0],\n         [0, 0, 40, 70, 4, 63, 0, 0, 60, 0, 4, 0],\n         [0, 32, 0, 0, 0, 5, 0, 3, 0, 660, 0, 9]]\n\n  max_value = max(capacity)\n\n  #\n  # variables\n  #\n  take = [solver.IntVar(0, max_value, 'take[%i]' % j) for j in items]\n\n  # total cost, to be maximized\n  z = solver.Sum([value[i] * take[i] for i in items])\n\n  #\n  # constraints\n  #\n  for r in resources:\n    solver.Add(solver.Sum([use[r][i] * take[i] for i in items]) <= capacity[r])\n\n  # objective\n  objective = solver.Maximize(z)\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n  print('z: ', int(solver.Objective().Value()))\n\n  print('take:', end=' ')\n  for i in items:\n    print(int(take[i].SolutionValue()), end=' ')\n  print()\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n\n\n\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Task and Worker Assignment Solver Using CP-SAT\nDESCRIPTION: A complete implementation of a task and worker assignment problem using OR-Tools CP-SAT solver. The code assigns tasks with different costs and workers to groups, with the objective of minimizing the maximum average cost across all groups.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/tasks_and_workers_assignment_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\nclass ObjectivePrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n\n    def on_solution_callback(self):\n        print(\n            \"Solution %i, time = %f s, objective = %i\"\n            % (self.__solution_count, self.wall_time, self.objective_value)\n        )\n        self.__solution_count += 1\n\n\ndef tasks_and_workers_assignment_sat() -> None:\n    \"\"\"solve the assignment problem.\"\"\"\n    model = cp_model.CpModel()\n\n    # CP-SAT solver is integer only.\n    task_cost = [24, 10, 7, 2, 11, 16, 1, 13, 9, 27]\n    num_tasks = len(task_cost)\n    num_workers = 3\n    num_groups = 2\n    all_workers = range(num_workers)\n    all_groups = range(num_groups)\n    all_tasks = range(num_tasks)\n\n    # Variables\n\n    ## x_ij = 1 if worker i is assigned to group j\n    x = {}\n    for i in all_workers:\n        for j in all_groups:\n            x[i, j] = model.new_bool_var(\"x[%i,%i]\" % (i, j))\n\n    ## y_kj is 1 if task k is assigned to group j\n    y = {}\n    for k in all_tasks:\n        for j in all_groups:\n            y[k, j] = model.new_bool_var(\"x[%i,%i]\" % (k, j))\n\n    # Constraints\n\n    # Each task k is assigned to a group and only one.\n    for k in all_tasks:\n        model.add(sum(y[k, j] for j in all_groups) == 1)\n\n    # Each worker i is assigned to a group and only one.\n    for i in all_workers:\n        model.add(sum(x[i, j] for j in all_groups) == 1)\n\n    # Cost per group\n    sum_of_costs = sum(task_cost)\n    averages = []\n    num_workers_in_group = []\n    scaled_sum_of_costs_in_group = []\n    scaling = 1000  # We introduce scaling to deal with floating point average.\n    for j in all_groups:\n        n = model.new_int_var(1, num_workers, \"num_workers_in_group_%i\" % j)\n        model.add(n == sum(x[i, j] for i in all_workers))\n        c = model.new_int_var(0, sum_of_costs * scaling, \"sum_of_costs_of_group_%i\" % j)\n        model.add(c == sum(y[k, j] * task_cost[k] * scaling for k in all_tasks))\n        a = model.new_int_var(0, sum_of_costs * scaling, \"average_cost_of_group_%i\" % j)\n        model.add_division_equality(a, c, n)\n\n        averages.append(a)\n        num_workers_in_group.append(n)\n        scaled_sum_of_costs_in_group.append(c)\n\n    # All workers are assigned.\n    model.add(sum(num_workers_in_group) == num_workers)\n\n    # Objective.\n    obj = model.new_int_var(0, sum_of_costs * scaling, \"obj\")\n    model.add_max_equality(obj, averages)\n    model.minimize(obj)\n\n    # Solve and print out the solution.\n    solver = cp_model.CpSolver()\n    solver.parameters.max_time_in_seconds = 60 * 60 * 2\n    objective_printer = ObjectivePrinter()\n    status = solver.solve(model, objective_printer)\n    print(solver.response_stats())\n\n    if status == cp_model.OPTIMAL:\n        for j in all_groups:\n            print(\"Group %i\" % j)\n            for i in all_workers:\n                if solver.boolean_value(x[i, j]):\n                    print(\"  - worker %i\" % i)\n            for k in all_tasks:\n                if solver.boolean_value(y[k, j]):\n                    print(\"  - task %i with cost %i\" % (k, task_cost[k]))\n            print(\n                \"  - sum_of_costs = %i\"\n                % (solver.value(scaled_sum_of_costs_in_group[j]) // scaling)\n            )\n            print(\"  - average cost = %f\" % (solver.value(averages[j]) * 1.0 / scaling))\n\n\ntasks_and_workers_assignment_sat()\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    tasks_and_workers_assignment_sat()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Bin Packing Problem using OR-Tools CP-SAT Solver in Go\nDESCRIPTION: This code demonstrates how to solve a bin packing problem using Google OR-Tools' CP-SAT solver in Go. It models a scenario where items with different costs and quantities need to be distributed across bins with capacity constraints. The objective is to maximize the number of bins that remain under a safe capacity threshold.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\n// The binpacking_problem_sat command is an example of a bin packing problem that uses channeling\n// constraints.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n)\n\nconst (\n\tbinCapacity   = 100\n\tslackCapacity = 20\n\tsafeCapacity  = binCapacity - slackCapacity\n\tnumBins       = 5\n)\n\ntype item struct {\n\tCost, Copies int64\n}\n\nfunc binpackingProblemSat() error {\n\t// Create the CP-SAT model.\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\titems := []item{{20, 6}, {15, 6}, {30, 4}, {45, 3}}\n\tnumItems := len(items)\n\n\t// Main variables.\n\tx := make([][]cpmodel.IntVar, numItems)\n\tfor i, item := range items {\n\t\tx[i] = make([]cpmodel.IntVar, numBins)\n\t\tfor b := 0; b < numBins; b++ {\n\t\t\tx[i][b] = model.NewIntVar(0, item.Copies)\n\t\t}\n\t}\n\n\t// Load variables.\n\tload := make([]cpmodel.IntVar, numBins)\n\tfor b := 0; b < numBins; b++ {\n\t\tload[b] = model.NewIntVar(0, binCapacity)\n\t}\n\n\t// Slack variables.\n\tslacks := make([]cpmodel.BoolVar, numBins)\n\tfor b := 0; b < numBins; b++ {\n\t\tslacks[b] = model.NewBoolVar()\n\t}\n\n\t// Links load and x.\n\tfor b := 0; b < numBins; b++ {\n\t\texpr := cpmodel.NewLinearExpr()\n\t\tfor i := 0; i < numItems; i++ {\n\t\t\texpr.AddTerm(x[i][b], items[i].Cost)\n\t\t}\n\t\tmodel.AddEquality(expr, load[b])\n\t}\n\n\t// Place all items.\n\tfor i := 0; i < numItems; i++ {\n\t\tcopies := cpmodel.NewLinearExpr()\n\t\tfor _, b := range x[i] {\n\t\t\tcopies.Add(b)\n\t\t}\n\t\tmodel.AddEquality(copies, cpmodel.NewConstant(items[i].Copies))\n\t}\n\n\t// Links load and slack through an equivalence relation.\n\tfor b := 0; b < numBins; b++ {\n\t\t// slacks[b] => load[b] <= safeCapacity.\n\t\tmodel.AddLessOrEqual(load[b], cpmodel.NewConstant(safeCapacity)).OnlyEnforceIf(slacks[b])\n\t\t// slacks[b].Not() => load[b] > safeCapacity.\n\t\tmodel.AddGreaterThan(load[b], cpmodel.NewConstant(safeCapacity)).OnlyEnforceIf(slacks[b].Not())\n\t}\n\n\t// Maximize sum of slacks.\n\tobj := cpmodel.NewLinearExpr()\n\tfor _, s := range slacks {\n\t\tobj.Add(s)\n\t}\n\tmodel.Maximize(obj)\n\n\t// Solve.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tresponse, err := cpmodel.SolveCpModel(m)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Println(\"Status: \", response.GetStatus())\n\tfmt.Println(\"Objective: \", response.GetObjectiveValue())\n\tfmt.Println(\"Statistics: \")\n\tfmt.Println(\"  - conflicts : \", response.GetNumConflicts())\n\tfmt.Println(\"  - branches  : \", response.GetNumBranches())\n\tfmt.Println(\"  - wall time : \", response.GetWallTime())\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := binpackingProblemSat(); err != nil {\n\t\tlog.Exitf(\"binpackingProblemSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Implementation of Transitions in a NoOverlap Constraint with CP-SAT\nDESCRIPTION: This function demonstrates how to use the transition times and costs in a NoOverlap constraint. It creates a scheduling problem with 4 tasks, defines penalties for breaking the natural sequence, and adds delays when switching between odd and even task indices.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ndef transitions_in_no_overlap_sample_sat():\n    \"\"\"Implement transitions in a NoOverlap constraint.\"\"\"\n\n    model = cp_model.CpModel()\n    horizon = 40\n    num_tasks = 4\n\n    # Breaking the natural sequence induces a fixed penalty.\n    penalties = {\n        (1, 0): 10,\n        (2, 0): 10,\n        (3, 0): 10,\n        (2, 1): 10,\n        (3, 1): 10,\n        (3, 2): 10,\n    }\n\n    # Switching from an odd to even or even to odd task indices induces a delay.\n    delays = {\n        (1, 0): 10,\n        (0, 1): 10,\n        (3, 0): 10,\n        (0, 3): 10,\n        (1, 2): 10,\n        (2, 1): 10,\n        (3, 2): 10,\n        (2, 3): 10,\n    }\n\n    all_tasks = range(num_tasks)\n\n    starts = []\n    durations = []\n    intervals = []\n    presences = []\n\n    # Creates intervals, all present. But the cost is robust w.r.t. optional\n    # intervals.\n    for t in all_tasks:\n        start = model.new_int_var(0, horizon, f\"start[{t}]\")\n        duration = 5\n        presence = True\n        interval = model.new_optional_fixed_size_interval_var(\n            start, duration, presence, f\"opt_interval[{t}]\"\n        )\n\n        starts.append(start)\n        durations.append(duration)\n        intervals.append(interval)\n        presences.append(presence)\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds ranking constraint.\n    penalty_terms = transitive_reduction_with_circuit_delays_and_penalties(\n        model, starts, durations, presences, penalties, delays\n    )\n\n    # Minimize the sum of penalties,\n    model.minimize(sum(var * penalty for var, penalty in penalty_terms))\n\n    # In practise, only one penalty can happen. Thus the two even tasks are\n    # together, same for the two odd tasks.\n    # Because of the penalties, the optimal sequence is 0 -> 2 -> 1 -> 3\n    # which induces one penalty and one delay.\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Prints out the makespan and the start times and ranks of all tasks.\n        print(f\"Optimal cost: {solver.objective_value}\")\n        for t in all_tasks:\n            if solver.value(presences[t]):\n                print(f\"Task {t} starts at {solver.value(starts[t])} \")\n            else:\n                print(f\"Task {t} in not performed\")\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n\n\ntransitions_in_no_overlap_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: N-Queens Solution Printer in OR-Tools\nDESCRIPTION: This class defines a solution printer for the N-Queens problem. It inherits from `cp_model.CpSolverSolutionCallback` and overrides the `on_solution_callback` method to print intermediate solutions and track the solution count and elapsed time. The printer also displays the board configuration for each solution found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/nqueens_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"python\nimport sys\nimport time\nfrom ortools.sat.python import cp_model\n\n\nclass NQueenSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, queens: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__queens = queens\n        self.__solution_count = 0\n        self.__start_time = time.time()\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n\n    def on_solution_callback(self):\n        current_time = time.time()\n        print(\n            f\"Solution {self.__solution_count}, \"\n            f\"time = {current_time - self.__start_time} s\"\n        )\n        self.__solution_count += 1\n\n        all_queens = range(len(self.__queens))\n        for i in all_queens:\n            for j in all_queens:\n                if self.value(self.__queens[j]) == i:\n                    # There is a queen in column j, row i.\n                    print(\"Q\", end=\" \")\n                else:\n                    print(\"_\", end=\" \")\n            print()\n        print()\n\n\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Minesweeper Solver Function\nDESCRIPTION: Defines the main function that sets up the constraint solver, declares variables, adds constraints, and finds all solutions for the Minesweeper game.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/minesweeper.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main(game=\"\", r=\"\", c=\"\"):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Minesweeper\")\n\n  # Set default problem if not provided\n  if game == \"\":\n    game = default_game\n    r = default_r\n    c = default_c\n  else:\n    print(\"rows:\", r, \" cols:\", c)\n\n  S = [-1, 0, 1]  # for the neighbors of \"this\" cell\n\n  # Print problem instance\n  print(\"Problem:\")\n  for i in range(r):\n    for j in range(c):\n      if game[i][j] == X:\n        print(\"X\", end=\" \")\n      else:\n        print(game[i][j], end=\" \")\n    print()\n  print()\n\n  # Declare variables\n  mines = {}\n  for i in range(r):\n    for j in range(c):\n      mines[(i, j)] = solver.IntVar(0, 1, \"mines %i %i\" % (i, j))\n\n  # Add constraints\n  for i in range(r):\n    for j in range(c):\n      if game[i][j] >= 0:\n        solver.Add(mines[i, j] == 0)\n        solver.Add(game[i][j] == solver.Sum([\n            mines[i + a, j + b]\n            for a in S\n            for b in S\n            if i + a >= 0 and j + b >= 0 and i + a < r and j + b < c\n        ]))\n      if game[i][j] > X:\n        solver.Add(mines[i, j] == 0)\n\n  # Set up solution and search\n  solution = solver.Assignment()\n  solution.Add([mines[(i, j)] for i in range(r) for j in range(c)])\n\n  collector = solver.AllSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase([mines[(i, j)] for i in range(r) for j in range(c)],\n                   solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE), [collector])\n\n  # Print solutions\n  num_solutions = collector.SolutionCount()\n  print(\"num_solutions: \", num_solutions)\n  if num_solutions > 0:\n    for s in range(num_solutions):\n      minesval = [\n          collector.Value(s, mines[(i, j)]) for i in range(r) for j in range(c)\n      ]\n      for i in range(r):\n        for j in range(c):\n          print(minesval[i * c + j], end=\" \")\n        print()\n      print()\n\n    print()\n    print(\"num_solutions:\", num_solutions)\n    print(\"failures:\", solver.Failures())\n    print(\"branches:\", solver.Branches())\n    print(\"WallTime:\", solver.WallTime())\n\n  else:\n    print(\"No solutions found\")\n```\n\n----------------------------------------\n\nTITLE: Implementing CVRPTW with Breaks using OR-Tools\nDESCRIPTION: Complete implementation of a Capacitated Vehicle Routing Problem with Time Windows (CVRPTW) that includes worker breaks. The code creates a data model, defines distance and time evaluators, adds capacity and time window constraints, and prints the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrptw_break.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport functools\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    # Locations in block unit\n    locations_ = [\n        # fmt: off\n      (4, 4),  # depot\n      (2, 0), (8, 0),  # locations to visit\n      (0, 1), (1, 1),\n      (5, 2), (7, 2),\n      (3, 3), (6, 3),\n      (5, 5), (8, 5),\n      (1, 6), (2, 6),\n      (3, 7), (6, 7),\n      (0, 8), (7, 8),\n        # fmt: on\n    ]\n    # Compute locations in meters using the block dimension defined as follow\n    # Manhattan average block: 750ft x 264ft -> 228m x 80m\n    # here we use: 114m x 80m city block\n    # src: https://nyti.ms/2GDoRIe \"NY Times: Know Your distance\"\n    data[\"locations\"] = [(l[0] * 114, l[1] * 80) for l in locations_]\n    data[\"numlocations_\"] = len(data[\"locations\"])\n    data[\"time_windows\"] = [\n        # fmt: off\n      (0, 0),  # depot\n      (75, 85), (75, 85),  #  1,  2\n      (60, 70), (45, 55),  #  3,  4\n      (0, 8), (50, 60),    #  5,  6\n      (0, 10), (10, 20),   #  7,  8\n      (0, 10), (75, 85),   #  9, 10\n      (85, 95), (5, 15),   # 11, 12\n      (15, 25), (10, 20),  # 13, 14\n      (45, 55), (30, 40),\n        # 15, 16\n        # fmt: on\n    ]\n    data[\"demands\"] = [\n        # fmt: off\n      0,     # depot\n      1, 1,  #  1,  2\n      2, 4,  #  3,  4\n      2, 4,  #  5,  6\n      8, 8,  #  7,  8\n      1, 2,  #  9, 10\n      1, 2,  # 11, 12\n      4, 4,  # 13, 14\n      8, 8,\n        # 15, 16\n        # fmt: on\n    ]\n    data[\"time_per_demand_unit\"] = 5  # 5 minutes/unit\n    data[\"num_vehicles\"] = 4\n    data[\"breaks\"] = [(2, False), (2, False), (2, False), (2, False)]\n    data[\"vehicle_capacity\"] = 15\n    data[\"vehicle_speed\"] = 83  # Travel speed: 5km/h converted in m/min\n    data[\"depot\"] = 0\n    return data\n\n\ndef manhattan_distance(position_1, position_2):\n    \"\"\"Computes the Manhattan distance between two points.\"\"\"\n    return abs(position_1[0] - position_2[0]) + abs(position_1[1] - position_2[1])\n\n\ndef create_distance_evaluator(data):\n    \"\"\"Creates callback to return distance between points.\"\"\"\n    distances_ = {}\n    # precompute distance between location to have distance callback in O(1)\n    for from_node in range(data[\"numlocations_\"]):\n        distances_[from_node] = {}\n        for to_node in range(data[\"numlocations_\"]):\n            if from_node == to_node:\n                distances_[from_node][to_node] = 0\n            else:\n                distances_[from_node][to_node] = manhattan_distance(\n                    data[\"locations\"][from_node], data[\"locations\"][to_node]\n                )\n\n    def distance_evaluator(manager, from_node, to_node):\n        \"\"\"Returns the manhattan distance between the two nodes.\"\"\"\n        return distances_[manager.IndexToNode(from_node)][manager.IndexToNode(to_node)]\n\n    return distance_evaluator\n\n\ndef create_demand_evaluator(data):\n    \"\"\"Creates callback to get demands at each location.\"\"\"\n    demands_ = data[\"demands\"]\n\n    def demand_evaluator(manager, node):\n        \"\"\"Returns the demand of the current node.\"\"\"\n        return demands_[manager.IndexToNode(node)]\n\n    return demand_evaluator\n\n\ndef add_capacity_constraints(routing, data, demand_evaluator_index):\n    \"\"\"Adds capacity constraint.\"\"\"\n    capacity = \"Capacity\"\n    routing.AddDimension(\n        demand_evaluator_index,\n        0,  # null capacity slack\n        data[\"vehicle_capacity\"],\n        True,  # start cumul to zero\n        capacity,\n    )\n\n\ndef create_time_evaluator(data):\n    \"\"\"Creates callback to get total times between locations.\"\"\"\n\n    def service_time(data, node):\n        \"\"\"Gets the service time for the specified location.\"\"\"\n        return data[\"demands\"][node] * data[\"time_per_demand_unit\"]\n\n    def travel_time(data, from_node, to_node):\n        \"\"\"Gets the travel times between two locations.\"\"\"\n        if from_node == to_node:\n            travel_time = 0\n        else:\n            travel_time = (\n                manhattan_distance(\n                    data[\"locations\"][from_node], data[\"locations\"][to_node]\n                )\n                / data[\"vehicle_speed\"]\n            )\n        return travel_time\n\n    total_time_ = {}\n    # precompute total time to have time callback in O(1)\n    for from_node in range(data[\"numlocations_\"]):\n        total_time_[from_node] = {}\n        for to_node in range(data[\"numlocations_\"]):\n            if from_node == to_node:\n                total_time_[from_node][to_node] = 0\n            else:\n                total_time_[from_node][to_node] = int(\n                    service_time(data, from_node)\n                    + travel_time(data, from_node, to_node)\n                )\n\n    def time_evaluator(manager, from_node, to_node):\n        \"\"\"Returns the total time between the two nodes.\"\"\"\n        return total_time_[manager.IndexToNode(from_node)][manager.IndexToNode(to_node)]\n\n    return time_evaluator\n\n\ndef add_time_window_constraints(routing, manager, data, time_evaluator_index):\n    \"\"\"Add Global Span constraint.\"\"\"\n    time = \"Time\"\n    horizon = 120\n    routing.AddDimension(\n        time_evaluator_index,\n        horizon,  # allow waiting time\n        horizon,  # maximum time per vehicle\n        False,  # don't force start cumul to zero\n        time,\n    )\n    time_dimension = routing.GetDimensionOrDie(time)\n    # Add time window constraints for each location except depot\n    # and 'copy' the slack var in the solution object (aka Assignment) to print it\n    for location_idx, time_window in enumerate(data[\"time_windows\"]):\n        if location_idx == data[\"depot\"]:\n            continue\n        index = manager.NodeToIndex(location_idx)\n        time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])\n        routing.AddToAssignment(time_dimension.SlackVar(index))\n    # Add time window constraints for each vehicle start node\n    # and 'copy' the slack var in the solution object (aka Assignment) to print it\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        time_dimension.CumulVar(index).SetRange(\n            data[\"time_windows\"][0][0], data[\"time_windows\"][0][1]\n        )\n        routing.AddToAssignment(time_dimension.SlackVar(index))\n        # The time window at the end node was impliclty set in the time dimension\n        # definition to be [0, horizon].\n        # Warning: Slack var is not defined for vehicle end nodes and should not\n        # be added to the assignment.\n\n\ndef print_solution(\n    data, manager, routing, assignment\n):  # pylint:disable=too-many-locals\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n\n    print(\"Breaks:\")\n    intervals = assignment.IntervalVarContainer()\n    for i in range(intervals.Size()):\n        brk = intervals.Element(i)\n        if brk.PerformedValue() == 1:\n            print(\n                f\"{brk.Var().Name()}:\"\n                f\" Start({brk.StartValue()}) Duration({brk.DurationValue()})\"\n            )\n        else:\n            print(f\"{brk.Var().Name()}: Unperformed\")\n\n    total_distance = 0\n    total_load = 0\n    total_time = 0\n    capacity_dimension = routing.GetDimensionOrDie(\"Capacity\")\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        distance = 0\n        while not routing.IsEnd(index):\n            load_var = capacity_dimension.CumulVar(index)\n            time_var = time_dimension.CumulVar(index)\n            slack_var = time_dimension.SlackVar(index)\n            node = manager.IndexToNode(index)\n            plan_output += (\n                f\" {node}\"\n                f\" Load({assignment.Value(load_var)})\"\n                f\" Time({assignment.Min(time_var)}, {assignment.Max(time_var)})\"\n                f\" Slack({assignment.Min(slack_var)}, {assignment.Max(slack_var)})\"\n                \" ->\"\n            )\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            distance += routing.GetArcCostForVehicle(previous_index, index, vehicle_id)\n        load_var = capacity_dimension.CumulVar(index)\n        time_var = time_dimension.CumulVar(index)\n        node = manager.IndexToNode(index)\n        plan_output += (\n            f\" {node}\"\n            f\" Load({assignment.Value(load_var)})\"\n            f\" Time({assignment.Min(time_var)}, {assignment.Max(time_var)})\\n\"\n        )\n        plan_output += f\"Distance of the route: {distance}m\\n\"\n        plan_output += f\"Load of the route: {assignment.Value(load_var)}\\n\"\n        plan_output += f\"Time of the route: {assignment.Value(time_var)}\\n\"\n        print(plan_output)\n        total_distance += distance\n        total_load += assignment.Value(load_var)\n        total_time += assignment.Value(time_var)\n```\n\n----------------------------------------\n\nTITLE: Coins3 Problem Implementation\nDESCRIPTION: Main implementation of the coin optimization problem that finds the minimum number of coins needed to make any amount from 1 to 99 cents using denominations of 1, 2, 5, 10, 25, and 50 cents. Uses constraint programming to ensure all possible amounts can be made with the selected coin quantities.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins3.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Coins\")\n\n  #\n  # data\n  #\n  n = 6  # number of different coins\n  variables = [1, 2, 5, 10, 25, 50]\n\n  # declare variables\n  x = [solver.IntVar(0, 99, \"x%i\" % i) for i in range(n)]\n  num_coins = solver.IntVar(0, 99, \"num_coins\")\n\n  #\n  # constraints\n  #\n\n  # number of used coins, to be minimized\n  solver.Add(num_coins == solver.Sum(x))\n\n  # Check that all changes from 1 to 99 can be made.\n  for j in range(1, 100):\n    tmp = [solver.IntVar(0, 99, \"b%i\" % i) for i in range(n)]\n    solver.Add(solver.ScalProd(tmp, variables) == j)\n    [solver.Add(tmp[i] <= x[i]) for i in range(n)]\n\n  # objective\n  objective = solver.Minimize(num_coins, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(num_coins)\n  solution.AddObjective(num_coins)\n\n  db = solver.Phase(x, solver.CHOOSE_MIN_SIZE_LOWEST_MAX,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"x: \", [x[i].Value() for i in range(n)])\n    print(\"num_coins:\", num_coins.Value())\n    print()\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Covering Problem with Google CP Solver in Python\nDESCRIPTION: This code snippet sets up and solves a set covering problem using Google's Constraint Programming Solver. It defines the problem data, creates variables, sets constraints, and finds the optimal solution to minimize the number of senators needed to represent all groups.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering3.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main(unused_argv):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set covering\")\n\n  #\n  # data\n  #\n  num_groups = 6\n  num_senators = 10\n\n  # which group does a senator belong to?\n  belongs = [\n      [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],  # 1 southern\n      [0, 0, 0, 0, 0, 1, 1, 1, 1, 1],  # 2 northern\n      [0, 1, 1, 0, 0, 0, 0, 1, 1, 1],  # 3 liberals\n      [1, 0, 0, 0, 1, 1, 1, 0, 0, 0],  # 4 conservative\n      [0, 0, 1, 1, 1, 1, 1, 0, 1, 0],  # 5 democrats\n      [1, 1, 0, 0, 0, 0, 0, 1, 0, 1]  # 6 republicans\n  ]\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 1, \"x[%i]\" % i) for i in range(num_senators)]\n\n  #\n  # constraints\n  #\n\n  # number of assigned senators (to minimize)\n  z = solver.Sum(x)\n\n  # ensure that each group is covered by at least\n  # one senator\n  for i in range(num_groups):\n    solver.Add(\n        solver.SumGreaterOrEqual(\n            [x[j] * belongs[i][j] for j in range(num_senators)], 1))\n\n  objective = solver.Minimize(z, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.AddObjective(z)\n\n  collector = solver.LastSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT),\n      [collector, objective])\n\n  print(\"z:\", collector.ObjectiveValue(0))\n  print(\"x:\", [collector.Value(0, x[i]) for i in range(num_senators)])\n  for j in range(num_senators):\n    if collector.Value(0, x[j]) == 1:\n      print(\"Senator\", j + 1, \"belongs to these groups:\", end=\" \")\n      for i in range(num_groups):\n        if belongs[i][j] == 1:\n          print(i + 1, end=\" \")\n      print()\n\n  print()\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Implementing VRP with Token Constraints using OR-Tools\nDESCRIPTION: This code implements a Vehicle Routing Problem with special locations that need to be visited at the end of routes. It uses a token system where regular nodes consume tokens and special nodes can only be visited when all tokens are used (token count is 0).\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_tokens.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    # Special location don't consume token, while regular one consume one\n    data[\"tokens\"] = [\n        0,  # 0 depot\n        0,  # 1 special node\n        0,  # 2 special node\n        0,  # 3 special node\n        0,  # 4 special node\n        0,  # 5 special node\n        -1,  # 6\n        -1,  # 7\n        -1,  # 8\n        -1,  # 9\n        -1,  # 10\n        -1,  # 11\n        -1,  # 12\n        -1,  # 13\n        -1,  # 14\n        -1,  # 15\n        -1,  # 16\n        -1,  # 17\n        -1,  # 18\n    ]\n    # just need to be big enough, not a limiting factor\n    data[\"vehicle_tokens\"] = [20, 20, 20, 20]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    token_dimension = routing.GetDimensionOrDie(\"Token\")\n    total_distance = 0\n    total_token = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        index = routing.Start(vehicle_id)\n        total_token += solution.Value(token_dimension.CumulVar(index))\n        route_distance = 0\n        route_token = 0\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index)\n            token_var = token_dimension.CumulVar(index)\n            route_token = solution.Value(token_var)\n            plan_output += f\" {node_index} Token({route_token}) -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        node_index = manager.IndexToNode(index)\n        token_var = token_dimension.CumulVar(index)\n        route_token = solution.Value(token_var)\n        plan_output += f\" {node_index} Token({route_token})\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        total_distance += route_distance\n        print(plan_output)\n    print(f\"Total distance of all routes: {total_distance}m\")\n    print(f\"Total token of all routes: {total_token}\")\n\n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"tokens\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        del from_index\n        del to_index\n        return 10\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # null slack\n        3000,  # maximum distance per vehicle\n        True,  # start cumul to zero\n        \"distance\",\n    )\n    distance_dimension = routing.GetDimensionOrDie(\"distance\")\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Token constraint.\n    def token_callback(from_index):\n        \"\"\"Returns the number of token consumed by the node.\"\"\"\n        # Convert from routing variable Index to tokens NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        return data[\"tokens\"][from_node]\n\n    token_callback_index = routing.RegisterUnaryTransitCallback(token_callback)\n    routing.AddDimensionWithVehicleCapacity(\n        token_callback_index,\n        0,  # null capacity slack\n        data[\"vehicle_tokens\"],  # vehicle maximum tokens\n        False,  # start cumul to zero\n        \"Token\",\n    )\n    # Add constraint: special node can only be visited if token remaining is zero\n    token_dimension = routing.GetDimensionOrDie(\"Token\")\n    for node in range(1, 6):\n        index = manager.NodeToIndex(node)\n        routing.solver().Add(token_dimension.CumulVar(index) == 0)\n\n    # Instantiate route start and end times to produce feasible times.\n    for i in range(manager.GetNumberOfVehicles()):\n        routing.AddVariableMinimizedByFinalizer(\n            token_dimension.CumulVar(routing.Start(i))\n        )\n        routing.AddVariableMinimizedByFinalizer(\n            token_dimension.CumulVar(routing.End(i))\n        )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(1)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing AllDifferentExcept0 Constraint in Python with CP-SAT\nDESCRIPTION: This example implements the AllDifferentExcept0 constraint, which enforces that all non-zero values assigned to variables must be different. The implementation scans the domains of variables and creates Boolean literals for each possible assignment, with additional constraints to ensure at most one variable can take any specific non-zero value.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Implements AllDifferentExcept0 using atomic constraints.\"\"\"\n\nimport collections\n\nfrom ortools.sat.python import cp_model\n\n\ndef all_different_except_0():\n    \"\"\"Encode the AllDifferentExcept0 constraint.\"\"\"\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Declare our primary variable.\n    x = [model.new_int_var(0, 10, f\"x{i}\") for i in range(5)]\n\n    # Expand the AllDifferentExcept0 constraint.\n    variables_per_value = collections.defaultdict(list)\n    all_values = set()\n\n    for var in x:\n        all_encoding_literals = []\n        # Domains of variables are represented by flat intervals.\n        for i in range(0, len(var.proto.domain), 2):\n            start = var.proto.domain[i]\n            end = var.proto.domain[i + 1]\n            for value in range(start, end + 1):  # Intervals are inclusive.\n                # Create the literal attached to var == value.\n                bool_var = model.new_bool_var(f\"{var} == {value}\")\n                model.add(var == value).only_enforce_if(bool_var)\n\n                # Collect all encoding literals for a given variable.\n                all_encoding_literals.append(bool_var)\n\n                # Collect all encoding literals for a given value.\n                variables_per_value[value].append(bool_var)\n\n                # Collect all different values.\n                all_values.add(value)\n\n        # One variable must have exactly one value.\n        model.add_exactly_one(all_encoding_literals)\n\n    # Add the all_different constraints.\n    for value, literals in variables_per_value.items():\n        if value == 0:\n            continue\n        model.add_at_most_one(literals)\n\n    model.add(x[0] == 0)\n    model.add(x[1] == 0)\n\n    model.maximize(sum(x))\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Checks and prints the output.\n    if status == cp_model.OPTIMAL:\n        print(f\"Optimal solution: {solver.objective_value}, expected: 27.0\")\n    elif status == cp_model.FEASIBLE:\n        print(f\"Feasible solution: {solver.objective_value}, optimal 27.0\")\n    elif status == cp_model.INFEASIBLE:\n        print(\"The model is infeasible\")\n    else:\n        print(\"Something went wrong. Please check the status and the log\")\n\n\nall_different_except_0()\n```\n\n----------------------------------------\n\nTITLE: Building Temporal Relations Between Intervals in Python with OR-Tools\nDESCRIPTION: This code demonstrates how to create different types of interval variables and establish temporal relations between them using OR-Tools CP-SAT solver. It shows regular intervals, fixed-size intervals, optional intervals, and various constraint relations like precedence and exact delays.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Builds temporal relations between intervals.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef interval_relations_sample_sat():\n    \"\"\"Showcases how to build temporal relations between intervals.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 100\n\n    # An interval can be created from three 1-var affine expressions.\n    start_var = model.new_int_var(0, horizon, \"start\")\n    duration = 10  # Python CP-SAT code accept integer variables or constants.\n    end_var = model.new_int_var(0, horizon, \"end\")\n    interval_var = model.new_interval_var(start_var, duration, end_var, \"interval\")\n\n    # If the size is fixed, a simpler version uses the start expression and the\n    # size.\n    fixed_size_start_var = model.new_int_var(0, horizon, \"fixed_start\")\n    fixed_size_duration = 10\n    fixed_size_interval_var = model.new_fixed_size_interval_var(\n        fixed_size_start_var,\n        fixed_size_duration,\n        \"fixed_size_interval_var\",\n    )\n\n    # An optional interval can be created from three 1-var affine expressions and\n    # a literal.\n    opt_start_var = model.new_int_var(0, horizon, \"opt_start\")\n    opt_duration = model.new_int_var(2, 6, \"opt_size\")\n    opt_end_var = model.new_int_var(0, horizon, \"opt_end\")\n    opt_presence_var = model.new_bool_var(\"opt_presence\")\n    opt_interval_var = model.new_optional_interval_var(\n        opt_start_var, opt_duration, opt_end_var, opt_presence_var, \"opt_interval\"\n    )\n\n    # If the size is fixed, a simpler version uses the start expression, the\n    # size, and the presence literal.\n    opt_fixed_size_start_var = model.new_int_var(0, horizon, \"opt_fixed_start\")\n    opt_fixed_size_duration = 10\n    opt_fixed_size_presence_var = model.new_bool_var(\"opt_fixed_presence\")\n    opt_fixed_size_interval_var = model.new_optional_fixed_size_interval_var(\n        opt_fixed_size_start_var,\n        opt_fixed_size_duration,\n        opt_fixed_size_presence_var,\n        \"opt_fixed_size_interval_var\",\n    )\n\n    # Simple precedence between two non optional intervals.\n    model.add(interval_var.start_expr() >= fixed_size_interval_var.end_expr())\n\n    # Synchronize start between two intervals (one optional, one not)\n    model.add(\n        interval_var.start_expr() == opt_interval_var.start_expr()\n    ).only_enforce_if(opt_presence_var)\n\n    # Exact delay between two optional intervals.\n    exact_delay: int = 5\n    model.add(\n        opt_interval_var.start_expr()\n        == opt_fixed_size_interval_var.end_expr() + exact_delay\n    ).only_enforce_if(opt_presence_var, opt_fixed_size_presence_var)\n\n\ninterval_relations_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Main Function for Two-Phase Bus Driver Scheduling in Python\nDESCRIPTION: Main function that orchestrates the two-phase optimization process: first minimizing the number of drivers, then minimizing the total working time while maintaining the minimal driver count. The function handles different instances of the problem based on command-line arguments.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef main(args):\n    \"\"\"Optimize the bus driver allocation in two passes.\"\"\"\n    print(\"----------- first pass: minimize the number of drivers\")\n    shifts = []\n    if args.instance == 1:\n        shifts = SAMPLE_SHIFTS_SMALL\n    elif args.instance == 2:\n        shifts = SAMPLE_SHIFTS_MEDIUM\n    elif args.instance == 3:\n        shifts = SAMPLE_SHIFTS_LARGE\n    num_drivers = find_minimum_number_of_drivers(shifts, args.params)\n\n    print(\"----------- second pass: minimize the sum of working times\")\n    # bus_driver_scheduling(False, num_drivers)\n\n\nmain(PARSER.parse_args())\n```\n\n----------------------------------------\n\nTITLE: Setting Working Time Constraints and Driver Utilization\nDESCRIPTION: Defines working time constraints for each driver and handles the case where a driver might not be working at all (when minimizing the number of drivers). Includes conditional constraints based on the optimization objective.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nmodel.add(working_times[d] == end_times[d] - start_times[d])\n\nif minimize_drivers:\n    # Driver is not working.\n    working = model.new_bool_var(\"working_%i\" % d)\n    model.add(start_times[d] == min_start_time).only_enforce_if(~working)\n    model.add(end_times[d] == min_start_time).only_enforce_if(~working)\n    model.add(driving_times[d] == 0).only_enforce_if(~working)\n    working_drivers.append(working)\n    outgoing_source_literals.append(~working)\n    incoming_sink_literals.append(~working)\n    # Conditional working time constraints\n    model.add(working_times[d] >= min_working_time).only_enforce_if(working)\n    model.add(working_times[d] == 0).only_enforce_if(~working)\nelse:\n    # Working time constraints\n    model.add(working_times[d] >= min_working_time)\n```\n\n----------------------------------------\n\nTITLE: Solving QUBO with CP-SAT\nDESCRIPTION: Implementation of a solver for Quadratic Unconstrained Binary Optimization (QUBO) problems using the CP-SAT solver from OR-Tools. This snippet includes imports and the beginning of the raw problem data definition.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/qubo_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List, Sequence\nfrom ortools.sat.python import cp_model\n\nRAW_DATA: List[List[float]] = [\n    # fmt:off\n    [\n        0, 0, 49.774821, -59.5968886, -46.0773896, 0, -65.166109, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 47.0957778, 15.259961, -98.7983264, 0, 0, 0, -20.7757184,\n        0, 87.2645672, 0, -22.7888772, 0, 0, 0, -40.4980904, -19.7307486,\n        -23.222078, 0, -77.5263128, 0, 0, 56.6204008, 0, 0, 0, 0, 0, 0, 0,\n        31.378421, 0, 97.3441448, 35.1309806, 0, 0, -40.5727886, -50.7308566, 0,\n        0, -69.9304568, 0, 38.5385914, 0, -22.1243232, 0, 0, 0, 0, -62.5102538,\n        8.0801276, 46.7998066, -2.3292106, 0, 0, 0, 8.774031, 0, 0, -65.6505736\n    ],\n    [\n        -67.2935466, -64.4354852, -96.6712204, 0, 0, -60.7812272, 0, 0, 0, 0, 0,\n        -7.9966864, 0, 0, 0, 0, 0, 0, 0, 89.7672338, 0, 0, 0, 0, 98.9607046, 0,\n        28.6714432, 0, 0, 0, -26.2738856, 0, 0, 68.363956, 0, 0, 0, 0,\n        54.7406868, 0, 0, 0, 0, 94.2320734, 0, 0, 0, 0, 0, 0, 0, 0, -2.9647794,\n        39.7161716, -54.7931288, 0, 0, 0, 0, -47.2284892, 0, 0, 0, -8.6421808,\n        -35.399612, 0, 0, 62.1912668, 0, -6.8930716, 0, 0, -17.0801284, 0, 0,\n        68.6533416\n    ],\n    [\n        0, 0, 0, 81.165396, 83.773254, 0, -25.1603, 0, 0, 50.225725, 0,\n        -3.8242274, 0, 0, 36.2078566, 0, 0, 0, 0, 0, 0, 0, 0, 15.551432, 0, 0,\n        -33.6446236, 0, 0, 0, 36.6171324, 0, 0, 0, 0, 67.9591934, 0, 22.1428016,\n        0, -27.2961928, 0, 0, 0, -97.4961564, 90.4062526, 0, 0, 0, -90.0532814,\n        0, 98.8332924, 0, 0, -13.8994926, 0, 17.1962884, 0, 0, 0, -55.1654678,\n        0, 0, 0, 85.829554, 0, -37.971164, 64.233136, -17.9943296, 0, 0, 0, 0,\n        -67.7509796, 0, 0, 10.0750712\n    ],\n    [\n        0, 37.2783148, 0, 0, 0, 36.4959506, 0, 0, 0, 0, 0, 0, 61.201323, 0,\n        14.4328522, 48.4078064, 0, 0, 0, 0, 0, 0, 0, -47.0969056, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 26.720439, 0, 0, 62.1987576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, -65.2085246, 0, 0, 0, 0, 0, 0, 73.3019432, -14.3431238, 0,\n        0, 0, 0, 0, 0, 0, 0, 2.1565846, 0, 0, 0.7733644, 0, 5.9090456, 0,\n        -39.7724192\n    ],\n    [\n        0, 0, 0, 0, -24.4555532, 0, 0, -5.5484574, 0, 25.4685054, 0.7906104,\n        4.273133, 0, 52.12973, 0, -12.8040828, 0, 0, 81.888381, 64.0713498, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62.9088768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        20.869713, 0, 0, -71.5835872, 0, 0, 80.7237808, 0, 0, 0, 0, -60.1883708,\n        0, 0, 0, 0, 0, 0, 0, 0, 85.0393326, 23.6045316, -18.8849834, 0, 0, 0,\n        -90.8065188, -9.5037982, 14.3196654, 0, -28.9290306, 0, 0, -41.5575766\n    ],\n    [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -8.9478934, 0,\n        -83.6040618, 0, 0, 0, 0, -14.3874822, 77.2528714, 0, 0, 99.2966066, 0,\n        21.7889114, -37.7629282, 0, -11.6026582, 0, 0, 0, 0, 74.422603, 0, 0,\n        -79.239245, -31.9686324, 0, 0, 0, 0, 0, 0, -29.8797178, 0, 0,\n        85.2723062, 0, 0, -8.8031188, 0, 0, -20.043565, 0, 0, -70.733454, 0,\n        -94.7231762, -85.4584516, 0, 0, 0, 0, -27.6068624, 0, -79.787783, 0, 0,\n        -55.1894266\n    ],\n    [\n        1.9374354, 0, 1.4807184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        61.298952, 0, 0, 0, -90.5702054, 0, 67.381115, 0, -68.684637, 0, 0, 0,\n        0, 0, 0, 0, 0, 93.7807934, 0, 8.8213302, -15.9020466, 0, 0, 0, 0,\n        23.8157662, 0, 0, 0, 0, 0, 0, 0, 67.3461972, 0, 0, 0, 0, 0, 43.3263744,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87.7149706, 0, 0, 0, -18.5133574,\n        -30.0338992\n    ],\n    [\n        6.3937798, 78.7697644, 28.4485838, 0, 0, 0.1352466, 0, 0, 74.5767122,\n        -13.8340168, 0, 0, 0, 77.2929426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        17.9243834, 0, 0, 82.2239878, 0, 0, 0, 0, 64.3440016, 90.109577,\n        46.8926522, -2.4494366, 0, 84.7413412, 0, 0, -4.216108, 0, 0,\n        -79.8684776, 0, 0, 74.8706758, -64.4518992, 0, 0, 0, 0, -34.4895004, 0,\n        0, 0, -74.1158858, -37.7803516, 0, 0, 0, 0, 0, 80.0054296, 0, 0, 0, 0,\n        0, 0, 0, 0, -84.5832026, 0, 0, 71.2540694\n    ],\n    [\n        0, 0, 0, 0, -74.9257454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        14.9675444, 0, 0, 0, 0, 0, -27.5236912, 0, 0, -80.4993438, 0,\n        -81.8494538, 0, 0, 0, 0, 0, -18.6802002, 0, 0, 0, 0, 0, 0, 0,\n        61.4131076, 0, 0, -55.1421034, 0, 0, -18.576761, 72.3500914, 0, 0, 0, 0,\n        0, 0, -23.6460116, 43.1258024, 0, 93.701872, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, -86.5772554\n    ],\n    [\n        0, 0, 93.0762916, 0, 0, 0, 0, 0, 0, 0, -37.2663938, 86.8303764, 0, 0, 0,\n        -51.9596226, 0, 35.6722618, -91.438259, 0, 0, -70.6277108, 0,\n        -82.9146992, 58.0327648, 0, 0, 0, 0, 0, 0, 0, 0, 13.3727302, 0, 0, 0,\n        23.5719942, 0, -21.5445476, 74.1541634, 60.6365036, 97.4447708, 0, 0, 0,\n        0, 82.5869498, 0, 85.1132108, 0, 0, 0, 0, 0, 0, 97.4012534, 0, 0, 0, 0,\n        -45.1504048, 1.0619934, 59.7140264, 0, 0, 0, 0, 0, 4.177461, 0, 0, 0,\n        -75.7039276, 0, 0.0421338\n    ],\n    [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -71.171869, 0, 0, 8.685266, 0, 0, 0, 0,\n        33.9089574, 0, -31.6154498, 0, 0, 0, 0, 0, 5.3182746, 0, 0, 0, 0, 0, 0,\n        3.0361166, -10.364305, 0, 0, 0, 0, 0, 0, 0, 0, -83.9738444, 0, 0,\n        -7.9170212, 0, 0, 0, -28.7575682, 0, 0, 0, -29.9216686, 0, 0,\n        83.4050918, -39.5247364, -6.7028846, 0, 0, 0, -23.6080482, 0, 0, 0, 0,\n        0, 0, -18.380154, 46.9252306, 0, 0, 26.1618372, 99.6235254\n    ],\n    [\n        0, 0, 0, 0, 0, 0, 0, 52.008307, 0, 0, 0, 0, 0, 92.4974102, -76.3015714,\n        0, 0, 0, 0, 0, 0, 0, -56.4879132, 0, 0, 0, 50.1473938, 0, 0, 0, 0, 0, 0,\n        0, 0, 40.2219566, 0, 0, 0, 84.5162074, 0, 0, 0, -73.3030606, 0,\n        -10.9258316, 0, 0, 0, 0, 97.5496436, -70.5026182, 0, 62.3611696, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96.4362226, 0, 0, 0, 0, 0, 0, 0,\n        -6.0104764, 15.7466756\n    ],\n    [\n        -38.7678174, 0, 0, 0, 0, 10.5238486, 0, 0, 0, 31.6876676, 79.6111978, 0,\n        0, 0, 0, 45.7314046, 0, 0, 0, -10.0125122, 0, 93.3170242, -96.4566224,\n        -5.853298, 0, -82.2848728, 0, 0, 0, 0, 0, 0, 0, 43.3427638, 24.6186934,\n        0, 44.859548, 0, -63.8196424, 0, 32.6630616, 41.48423, 0, -42.9613722,\n        0, 0, -68.8954844, 0, 0, 0, 0, 0, 0, 0, 0, 27.7424034, -33.4867534,\n        -49.1827758, 0, 18.7014116, 0, 0, 59.049662, 0, 0, 0, 0, 0, 0,\n        -29.6305028, 0, 0, 0, 0, 0, 98.2266078\n    ],\n    [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -14.6583468, 0, -74.4490466, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, -94.9604028, 0, 0, -48.28403, -41.3534342, 0, 0, 0,\n        62.9532972, 0, 0, 4.030284, 0, -60.478996, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, -46.5887848, 39.4565458, 0, 0, 0, 0, 0, 0, 0,\n        -48.5071236, 0, 0, 0, 41.8640204, 0, 0, 0, 74.271524, 0, 15.5769242, 0,\n        -61.4793904, 52.4500934\n    ],\n    [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50.8387116, 0, 46.490051, 0, -54.9751352,\n        0, 43.0696416, 0, 0, 0, 0, 80.5337704, 0, 0, -16.0325234, 0, 0, 0, 0, 0,\n        0, 0, 0, 63.186351, 0, 0, 0, 0, 0, 75.2218604, -27.3783446, 0, 0, 0, 0,\n        -85.021934, 60.9043202, 55.7344594, 0, 41.1687556, 0, 5.574124, 0, 0,\n        -5.0028254, -40.2614834, 0, 0, 0, 0, 0, 0, 22.207679, 0, 0, 0, 0, 0,\n        65.0504204, 0, -61.4580018, -90.137276, 19.2277196, 0, 0, -73.8615034\n    ],\n    [\n        0, 0, 0, 0, 0, -21.3303052, -75.4586018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 84.6730538, -3.4478344, 0, -76.083503,\n        19.9372656, -38.9938322, 0, 0, 36.0135034, 0, -56.8457144, 0, 0,\n        63.4198336, 0, 0, 0, 0, 0, -63.4419798, 28.5629988, 0, 0, 0, 0,\n        38.8001126, 0, 0, 47.2148438, 0, -19.256673, -24.8778354, -47.8193252,\n        0, 0, -38.7279908, 0, 0, 0, -34.5546658, 0, -96.7675822, 0, 0, 0, 0, 0,\n        0, 0, 0, 27.9437518\n    ],\n    [\n        0, -17.8703906, 0, 0, -47.2114204, 0, -73.3595682, 66.668341, 0, 0, 0,\n        0, 30.250278, 0, -40.452007, 0, 0, 0, 0, 0, -37.5013244, 34.3045856, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12.898457,\n        -15.2838318, 0, 0, 0, 0, 0, 16.333021, 0, 72.0452526, 0, 2.285458, 0, 0,\n        0, 0, -17.8073046, 0, 0, 0, 81.7271146, 0, 0, -17.7174538, 0,\n        -62.6694996, 8.7298318, 0, 0, 0, 0, 0, 0, -27.1131974, 0, -68.0964272\n    ],\n    [\n        0, 0, 0, 0, -22.1791216, 16.588597, -19.4545486, 0, -74.8318248,\n        -74.4252462, 0, 0, 0, -46.1656546, 0, 0, -21.1620788, 0, -25.6883764, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 34.5550634, 0, 0, 0, 0, 93.8894398, 0,\n        -30.961635, 0, 0, 0, 0, 0, 78.594791, 0, 0, -63.3427616, 52.6543374, 0,\n        0, 38.4578962, 0, 0, -56.5589394, 0, 0, 0.6873802, 0, -83.496155, 0, 0,\n        0, 13.0737006, 0, -41.7343216, 71.8170636, 69.0276666, 0, 0, 57.722026,\n        0, 0, -93.1746526, 0, 0, 0, 0, -49.9838934\n    ],\n    [\n        0, 4.2310134, -77.9001854, -57.1049418, 0, 53.3411444, 0, 0, 62.3456148,\n        0, 0, 68.2636062, 0, 0, -97.5234598, 0, 87.5610236, 0, 0, 0, 0,\n        -77.3855948, 0, 0, -90.724008, 28.2231562, 0, 53.026918, 0, 0, 0,\n        -76.15995, 0, 0, 0, 15.413813, 0, 0, 0, 0, 0, 0, 0, 0, 13.0272308, 0, 0,\n        -23.9738128, 38.7553414, 0, 30.9290494, -35.5982432, 0, 0, 0,\n        -45.1103148, 0, 0, 0, 70.158022, 0, 0, 0, 0, 0, 54.120183, 0, 0, 0,\n```\n\n----------------------------------------\n\nTITLE: Main Function to Solve MIP Problem\nDESCRIPTION: Implements the main functionality to set up the MIP solver, define variables and constraints, and solve the optimization problem. It also displays the results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/mip_var_array.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    data = create_data_model()\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n    if not solver:\n        return\n\n    infinity = solver.infinity()\n    x = {}\n    for j in range(data[\"num_vars\"]):\n        x[j] = solver.IntVar(0, infinity, \"x[%i]\" % j)\n    print(\"Number of variables =\", solver.NumVariables())\n\n    for i in range(data[\"num_constraints\"]):\n        constraint = solver.RowConstraint(0, data[\"bounds\"][i], \"\")\n        for j in range(data[\"num_vars\"]):\n            constraint.SetCoefficient(x[j], data[\"constraint_coeffs\"][i][j])\n    print(\"Number of constraints =\", solver.NumConstraints())\n\n    objective = solver.Objective()\n    for j in range(data[\"num_vars\"]):\n        objective.SetCoefficient(x[j], data[\"obj_coeffs\"][j])\n    objective.SetMaximization()\n\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    if status == pywraplp.Solver.OPTIMAL:\n        print(\"Objective value =\", solver.Objective().Value())\n        for j in range(data[\"num_vars\"]):\n            print(x[j].name(), \" = \", x[j].solution_value())\n        print()\n        print(f\"Problem solved in {solver.wall_time():d} milliseconds\")\n        print(f\"Problem solved in {solver.iterations():d} iterations\")\n        print(f\"Problem solved in {solver.nodes():d} branch-and-bound nodes\")\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: N-Queens Solver Implementation\nDESCRIPTION: Main implementation of the N-Queens solver using OR-Tools constraint programming. The code creates a solver instance, defines variables and constraints for the N-Queens problem, implements symmetry breaking, and includes search functionality with customizable solution output.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nqueens3.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=8, num_sol=0, print_sol=1):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n  print(\"n:\", n)\n  print(\"num_sol:\", num_sol)\n  print(\"print_sol:\", print_sol)\n\n  # declare variables\n  q = [solver.IntVar(0, n - 1, \"x%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(q))\n  solver.Add(solver.AllDifferent([q[i] + i for i in range(n)]))\n  solver.Add(solver.AllDifferent([q[i] - i for i in range(n)]))\n\n  # symmetry breaking\n  # solver.Add(q[0] == 0)\n\n  #\n  # search\n  #\n\n  db = solver.Phase(q, solver.CHOOSE_MIN_SIZE_LOWEST_MAX,\n                    solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    if print_sol:\n      qval = [q[i].Value() for i in range(n)]\n      print(\"q:\", qval)\n      for i in range(n):\n        for j in range(n):\n          if qval[i] == j:\n            print(\"Q\", end=\" \")\n          else:\n            print(\"_\", end=\" \")\n        print()\n      print()\n    num_solutions += 1\n    if num_sol > 0 and num_solutions >= num_sol:\n      break\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime(), \"ms\")\n\n\nn = 8\nnum_sol = 0\nprint_sol = 1\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nif len(sys.argv) > 2:\n  num_sol = int(sys.argv[2])\nif len(sys.argv) > 3:\n  print_sol = int(sys.argv[3])\n\nmain(n, num_sol, print_sol)\n```\n\n----------------------------------------\n\nTITLE: Implementing NoOverlap Constraint in C++ with OR-Tools\nDESCRIPTION: This C++ implementation demonstrates the NoOverlap constraint using OR-Tools CP-SAT solver. It schedules three tasks with different durations while avoiding fixed weekend periods, optimizing for the earliest completion time (makespan). The code creates interval variables, adds constraints, and reports the optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include <cstdint>\n\n#include \"absl/types/span.h\"\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid NoOverlapSampleSat() {\n  CpModelBuilder cp_model;\n  const int64_t kHorizon = 21;  // 3 weeks.\n\n  const Domain horizon(0, kHorizon);\n  // Task 0, duration 2.\n  const IntVar start_0 = cp_model.NewIntVar(horizon);\n  const int64_t duration_0 = 2;\n  const IntVar end_0 = cp_model.NewIntVar(horizon);\n  const IntervalVar task_0 =\n      cp_model.NewIntervalVar(start_0, duration_0, end_0);\n\n  // Task 1, duration 4.\n  const IntVar start_1 = cp_model.NewIntVar(horizon);\n  const int64_t duration_1 = 4;\n  const IntVar end_1 = cp_model.NewIntVar(horizon);\n  const IntervalVar task_1 =\n      cp_model.NewIntervalVar(start_1, duration_1, end_1);\n\n  // Task 2, duration 3.\n  const IntVar start_2 = cp_model.NewIntVar(horizon);\n  const int64_t duration_2 = 3;\n  const IntVar end_2 = cp_model.NewIntVar(horizon);\n  const IntervalVar task_2 =\n      cp_model.NewIntervalVar(start_2, duration_2, end_2);\n\n  // Week ends.\n  const IntervalVar weekend_0 = cp_model.NewIntervalVar(5, 2, 7);\n  const IntervalVar weekend_1 = cp_model.NewIntervalVar(12, 2, 14);\n  const IntervalVar weekend_2 = cp_model.NewIntervalVar(19, 2, 21);\n\n  // No Overlap constraint.\n  cp_model.AddNoOverlap(\n      {task_0, task_1, task_2, weekend_0, weekend_1, weekend_2});\n\n  // Makespan.\n  IntVar makespan = cp_model.NewIntVar(horizon);\n  cp_model.AddLessOrEqual(end_0, makespan);\n  cp_model.AddLessOrEqual(end_1, makespan);\n  cp_model.AddLessOrEqual(end_2, makespan);\n\n  cp_model.Minimize(makespan);\n\n  // Solving part.\n  Model model;\n  const CpSolverResponse response = SolveCpModel(cp_model.Build(), &model);\n  LOG(INFO) << CpSolverResponseStats(response);\n\n  if (response.status() == CpSolverStatus::OPTIMAL) {\n    LOG(INFO) << \"Optimal Schedule Length: \" << response.objective_value();\n    LOG(INFO) << \"Task 0 starts at \" << SolutionIntegerValue(response, start_0);\n    LOG(INFO) << \"Task 1 starts at \" << SolutionIntegerValue(response, start_1);\n    LOG(INFO) << \"Task 2 starts at \" << SolutionIntegerValue(response, start_2);\n  }\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::NoOverlapSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Main Solver Implementation\nDESCRIPTION: Main function that sets up and solves the divisibility puzzle using CP-SAT solver. Handles variable creation, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/divisible_by_9_through_1.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main(base=10):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Divisible by 9 through 1\")\n\n  # data\n  m = base**(base - 1) - 1\n  n = base - 1\n\n  digits_str = \"_0123456789ABCDEFGH\"\n\n  print(\"base:\", base)\n\n  # declare variables\n\n  # the digits\n  x = [solver.IntVar(1, base - 1, \"x[%i]\" % i) for i in range(n)]\n\n  # the numbers, t[0] contains the answer\n  t = [solver.IntVar(0, m, \"t[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n\n  for i in range(n):\n    mm = base - i - 1\n    toNum(solver, [x[j] for j in range(mm)], t[i], base)\n    my_mod(solver, t[i], mm, 0)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(t)\n\n  db = solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"x: \", [x[i].Value() for i in range(n)])\n    print(\"t: \", [t[i].Value() for i in range(n)])\n    print(\"number base 10: %i base %i: %s\" % (t[0].Value(), base, \"\".join(\n        [digits_str[x[i].Value() + 1] for i in range(n)])))\n    print()\n    num_solutions += 1\n  solver.EndSearch()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Implementing Project Scheduling with OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This code snippet sets up and solves a project scheduling problem using OR-Tools' CP-SAT solver. It defines projects, roles, and resource constraints, then creates decision variables and constraints to find an optimal schedule that minimizes project start times.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/project_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n#project name, duration, starts earliest, ends latest, demand role A, demand role S, demand role J\nprojects = [\n            ['P1',3, 0, 9, 1, 0, 1],\n            ['P2',8, 0, 9, 1, 1, 0],\n            ['P3',3, 0, 9, 1, 0, 2],\n            ['P4',4, 0, 9, 1, 0, 1]\n            ]\n\nnum_projects = len(projects)\n\nroles = ['A','S','J']\n\n#Roles available at each time step\navailable_roles = [\n    [2,2,2,2,2,2,2,2,2,2], #Role A\n    [1,1,1,1,1,1,1,1,1,1], #Role S\n    [1,1,1,1,1,1,1,2,2,2]  #Role J\n]\n\nall_projects = range(num_projects)\nall_roles = range(len(roles))\n\n# Creates the model.\nmodel = cp_model.CpModel()\n\n#Creating decision variables\n\n#starts and ends of the projects\nstarts = [model.NewIntVar(projects[j][2], projects[j][3] + 1 , 'start_%i' % j) for j in all_projects]\nends = [model.NewIntVar(projects[j][2], projects[j][3] + 1, 'end_%i' % j) for j in all_projects]\nintervals = [model.NewIntervalVar(starts[j], projects[j][1], ends[j], 'interval_%i' % j) for j in all_projects]\n\n# Role A has a capacity 2. Every project uses it.\ndemands = [1 for _ in all_projects]\nmodel.AddCumulative(intervals, demands, 2)\n\n# Role S has a capacity of 1\nmodel.AddNoOverlap([intervals[i] for i in all_projects if projects[i][5]])\n\n# Project J has a capacity of 1 or 2.\nused_capacity = model.NewIntervalVar(0, 7, 7, 'unavailable')\nintervals_for_project_j = intervals + [used_capacity]\ndemands_for_project_j = [projects[j][6] for j in all_projects] + [1]\nmodel.AddCumulative(intervals_for_project_j, demands_for_project_j, 2)\n\n#We want the projects to start as early as possible\nmodel.Minimize(sum(starts))\n\n# Solve model.\nsolver = cp_model.CpSolver()\nsolver.parameters.log_search_progress = True\nstatus=solver.Solve(model)\n\nfor it in zip(starts, ends):\n    print(\"[%i, %i]\" % (solver.Value(it[0]), solver.Value(it[1])))\n```\n\n----------------------------------------\n\nTITLE: Optimizing Bus Driver Scheduling in Python with Google OR-Tools\nDESCRIPTION: This function optimizes bus driver scheduling with two possible objectives: minimizing the number of drivers or minimizing total working time across a fixed number of drivers. It handles constraints like maximum driving time, required breaks, and minimum/maximum working times.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef bus_driver_scheduling(minimize_drivers: bool, max_num_drivers: int) -> int:\n    \"\"\"Optimize the bus driver scheduling problem.\n\n    This model has two modes.\n\n    If minimize_drivers == True, the objective will be to find the minimal\n    number of drivers, independently of the working times of each drivers.\n\n    Otherwise, will will create max_num_drivers non optional drivers, and\n    minimize the sum of working times of these drivers.\n\n    Args:\n      minimize_drivers: A Boolean parameter specifying the objective of the\n        problem. If True, it tries to minimize the number of used drivers. If\n        false, it minimizes the sum of working times per workers.\n      max_num_drivers: This number specifies the exact number of non optional\n        drivers to use. This is only used if 'minimize_drivers' is False.\n\n    Returns:\n        The objective value of the model.\n    \"\"\"\n    shifts = None\n    if _INSTANCE.value == 0:\n        shifts = SAMPLE_SHIFTS_TINY\n    elif _INSTANCE.value == 1:\n        shifts = SAMPLE_SHIFTS_SMALL\n    elif _INSTANCE.value == 2:\n        shifts = SAMPLE_SHIFTS_MEDIUM\n    elif _INSTANCE.value == 3:\n        shifts = SAMPLE_SHIFTS_LARGE\n\n    num_shifts = len(shifts)\n\n    # All durations are in minutes.\n    max_driving_time = 540  # 8 hours.\n    max_driving_time_without_pauses = 240  # 4 hours\n    min_pause_after_4h = 30\n    min_delay_between_shifts = 2\n    max_working_time = 720\n    min_working_time = 390  # 6.5 hours\n    setup_time = 10\n    cleanup_time = 15\n\n    # Computed data.\n    total_driving_time = sum(shift[5] for shift in shifts)\n    min_num_drivers = int(math.ceil(total_driving_time * 1.0 / max_driving_time))\n    num_drivers = 2 * min_num_drivers if minimize_drivers else max_num_drivers\n    min_start_time = min(shift[3] for shift in shifts)\n    max_end_time = max(shift[4] for shift in shifts)\n\n    print(\"Bus driver scheduling\")\n    print(\"  num shifts =\", num_shifts)\n    print(\"  total driving time =\", total_driving_time, \"minutes\")\n    print(\"  min num drivers =\", min_num_drivers)\n    print(\"  num drivers =\", num_drivers)\n    print(\"  min start time =\", min_start_time)\n    print(\"  max end time =\", max_end_time)\n\n    model = cp_model.CpModel()\n\n    # For each driver and each shift, we store:\n    #   - the total driving time including this shift\n    #   - the acrued driving time since the last 30 minute break\n    # Special arcs have the following effect:\n    #   - 'from source to shift' sets the starting time and accumulate the first\n    #      shift\n    #   - 'from shift to end' sets the ending time, and fill the driving_times\n    #      variable\n    # Arcs between two shifts have the following impact\n    #   - add the duration of the shift to the total driving time\n    #   - reset the accumulated driving time if the distance between the two\n    #     shifts is more than 30 minutes, add the duration of the shift to the\n    #     accumulated driving time since the last break otherwise\n\n    # Per (driver, node) info (driving time, performed,\n    # driving time since break)\n    total_driving = {}\n    no_break_driving = {}\n    performed = {}\n    starting_shifts = {}\n\n    # Per driver info (start, end, driving times, is working)\n    start_times = []\n    end_times = []\n    driving_times = []\n    working_drivers = []\n    working_times = []\n\n    # Weighted objective\n    delay_literals = []\n    delay_weights = []\n\n    # Used to propagate more between drivers\n    shared_incoming_literals = collections.defaultdict(list)\n    shared_outgoing_literals = collections.defaultdict(list)\n\n    for d in range(num_drivers):\n        start_times.append(\n            model.new_int_var(min_start_time - setup_time, max_end_time, \"start_%i\" % d)\n        )\n        end_times.append(\n            model.new_int_var(min_start_time, max_end_time + cleanup_time, \"end_%i\" % d)\n        )\n        driving_times.append(model.new_int_var(0, max_driving_time, \"driving_%i\" % d))\n        working_times.append(\n            model.new_int_var(0, max_working_time, \"working_times_%i\" % d)\n        )\n\n        incoming_literals = collections.defaultdict(list)\n        outgoing_literals = collections.defaultdict(list)\n        outgoing_source_literals = []\n        incoming_sink_literals = []\n\n        # Create all the shift variables before iterating on the transitions\n        # between these shifts.\n        for s in range(num_shifts):\n            total_driving[d, s] = model.new_int_var(\n                0, max_driving_time, \"dr_%i_%i\" % (d, s)\n            )\n            no_break_driving[d, s] = model.new_int_var(\n                0, max_driving_time_without_pauses, \"mdr_%i_%i\" % (d, s)\n            )\n            performed[d, s] = model.new_bool_var(\"performed_%i_%i\" % (d, s))\n\n        for s in range(num_shifts):\n            shift = shifts[s]\n            duration = shift[5]\n\n            # Arc from source to shift.\n            #    - set the start time of the driver\n            #    - increase driving time and driving time since break\n            source_lit = model.new_bool_var(\"%i from source to %i\" % (d, s))\n            outgoing_source_literals.append(source_lit)\n            incoming_literals[s].append(source_lit)\n            shared_incoming_literals[s].append(source_lit)\n            model.add(start_times[d] == shift[3] - setup_time).only_enforce_if(\n                source_lit\n            )\n            model.add(total_driving[d, s] == duration).only_enforce_if(source_lit)\n            model.add(no_break_driving[d, s] == duration).only_enforce_if(source_lit)\n            starting_shifts[d, s] = source_lit\n\n            # Arc from shift to sink\n            #    - set the end time of the driver\n            #    - set the driving times of the driver\n            sink_lit = model.new_bool_var(\"%i from %i to sink\" % (d, s))\n            outgoing_literals[s].append(sink_lit)\n            shared_outgoing_literals[s].append(sink_lit)\n            incoming_sink_literals.append(sink_lit)\n            model.add(end_times[d] == shift[4] + cleanup_time).only_enforce_if(sink_lit)\n            model.add(driving_times[d] == total_driving[d, s]).only_enforce_if(sink_lit)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Rostering with Travel Optimization\nDESCRIPTION: Main implementation of the rostering optimization problem using CP-SAT solver. The code creates a model with jobs that have duration, start time, end time, and location constraints. It handles machine assignments, travel times between locations, and minimizes total cost while ensuring no scheduling conflicts.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/rostering_with_travel.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef SolveRosteringWithTravel():\n  model = cp_model.CpModel()\n\n  # [duration, start, end, location]\n  jobs = [[3, 0, 6, 1], [5, 0, 6, 0], [1, 3, 7, 1], [1, 3, 5, 0], [3, 0, 3, 0],\n          [3, 0, 8, 0]]\n\n  max_length = 20\n\n  num_machines = 3\n  all_machines = range(num_machines)\n\n  horizon = 20\n  travel_time = 1\n  num_jobs = len(jobs)\n  all_jobs = range(num_jobs)\n\n  intervals = []\n  optional_intervals = []\n  performed = []\n  starts = []\n  ends = []\n  travels = []\n\n  for m in all_machines:\n    optional_intervals.append([])\n\n  for i in all_jobs:\n    # Create main interval.\n    start = model.NewIntVar(jobs[i][1], horizon, 'start_%i' % i)\n    duration = jobs[i][0]\n    end = model.NewIntVar(0, jobs[i][2], 'end_%i' % i)\n    interval = model.NewIntervalVar(start, duration, end, 'interval_%i' % i)\n    starts.append(start)\n    intervals.append(interval)\n    ends.append(end)\n\n    job_performed = []\n    job_travels = []\n    for m in all_machines:\n      performed_on_m = model.NewBoolVar('perform_%i_on_m%i' % (i, m))\n      job_performed.append(performed_on_m)\n\n      # Create an optional copy of interval to be executed on a machine\n      location0 = model.NewIntVar(jobs[i][3], jobs[i][3],\n                                  'location_%i_on_m%i' % (i, m))\n      start0 = model.NewIntVar(jobs[i][1], horizon, 'start_%i_on_m%i' % (i, m))\n      end0 = model.NewIntVar(0, jobs[i][2], 'end_%i_on_m%i' % (i, m))\n      interval0 = model.NewOptionalIntervalVar(\n          start0, duration, end0, performed_on_m, 'interval_%i_on_m%i' % (i, m))\n      optional_intervals[m].append(interval0)\n\n      # We only propagate the constraint if the tasks is performed on the machine.\n      model.Add(start0 == start).OnlyEnforceIf(performed_on_m)\n      # Adding travel constraint\n      travel = model.NewBoolVar('is_travel_%i_on_m%i' % (i, m))\n      startT = model.NewIntVar(0, horizon, 'start_%i_on_m%i' % (i, m))\n      endT = model.NewIntVar(0, horizon, 'end_%i_on_m%i' % (i, m))\n      intervalT = model.NewOptionalIntervalVar(\n          startT, travel_time, endT, travel,\n          'travel_interval_%i_on_m%i' % (i, m))\n      optional_intervals[m].append(intervalT)\n      job_travels.append(travel)\n\n      model.Add(end0 == startT).OnlyEnforceIf(travel)\n\n    performed.append(job_performed)\n    travels.append(job_travels)\n\n    model.Add(sum(job_performed) == 1)\n\n  for m in all_machines:\n    if m == 1:\n      for i in all_jobs:\n        if i == 2:\n          for c in all_jobs:\n            if (i != c) and (jobs[i][3] != jobs[c][3]):\n              is_job_earlier = model.NewBoolVar('is_j%i_earlier_j%i' % (i, c))\n              model.Add(starts[i] < starts[c]).OnlyEnforceIf(is_job_earlier)\n              model.Add(starts[i] >= starts[c]).OnlyEnforceIf(\n                  is_job_earlier.Not())\n\n  # Max Length constraint (modeled as a cumulative)\n  # model.AddCumulative(intervals, demands, max_length)\n\n  # Choose which machine to perform the jobs on.\n  for m in all_machines:\n    model.AddNoOverlap(optional_intervals[m])\n\n  # Objective variable.\n  total_cost = model.NewIntVar(0, 1000, 'cost')\n  model.Add(total_cost == sum(\n      performed[j][m] * (10 * (m + 1)) for j in all_jobs for m in all_machines))\n  model.Minimize(total_cost)\n\n  # Solve model.\n  solver = cp_model.CpSolver()\n  result = solver.Solve(model)\n\n  print()\n  print(result)\n  print('Statistics')\n  print('  - conflicts       : %i' % solver.NumConflicts())\n  print('  - branches        : %i' % solver.NumBranches())\n  print('  - wall time       : %f ms' % solver.WallTime())\n\n\ndef main():\n  SolveRosteringWithTravel()\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Setting Objective and Solving Shift Scheduling Model in Python\nDESCRIPTION: This snippet sets the objective function for the shift scheduling model, solves it using the CP-SAT solver, and prints the solution if one is found. It also includes options for writing the model to a proto file and setting solver parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/shift_scheduling_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n# Objective\nmodel.minimize(\n    sum(obj_bool_vars[i] * obj_bool_coeffs[i] for i in range(len(obj_bool_vars)))\n    + sum(obj_int_vars[i] * obj_int_coeffs[i] for i in range(len(obj_int_vars)))\n)\n\nif output_proto:\n    print(f\"Writing proto to {output_proto}\")\n    with open(output_proto, \"w\") as text_file:\n        text_file.write(str(model))\n\n# Solve the model.\nsolver = cp_model.CpSolver()\nif params:\n    text_format.Parse(params, solver.parameters)\nsolution_printer = cp_model.ObjectiveSolutionPrinter()\nstatus = solver.solve(model, solution_printer)\n\n# Print solution.\nif status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n    print()\n    header = \"          \"\n    for w in range(num_weeks):\n        header += \"M T W T F S S \"\n    print(header)\n    for e in range(num_employees):\n        schedule = \"\"\n        for d in range(num_days):\n            for s in range(num_shifts):\n                if solver.boolean_value(work[e, s, d]):\n                    schedule += shifts[s] + \" \"\n        print(f\"worker {e}: {schedule}\")\n    print()\n    print(\"Penalties:\")\n    for i, var in enumerate(obj_bool_vars):\n        if solver.boolean_value(var):\n            penalty = obj_bool_coeffs[i]\n            if penalty > 0:\n                print(f\"  {var.name} violated, penalty={penalty}\")\n            else:\n                print(f\"  {var.name} fulfilled, gain={-penalty}\")\n\n    for i, var in enumerate(obj_int_vars):\n        if solver.value(var) > 0:\n            print(\n                f\"  {var.name} violated by {solver.value(var)}, linear\"\n                f\" penalty={obj_int_coeffs[i]}\"\n            )\n\nprint()\nprint(solver.response_stats())\n```\n\n----------------------------------------\n\nTITLE: SlitherLink Solver Function Using OR-Tools Constraint Programming\nDESCRIPTION: The main solver function that takes a grid of clue numbers and creates a constraint satisfaction problem to solve a Slither Link puzzle. It defines horizontal and vertical arcs, sets up constraints for clues, enforces the single loop requirement, and configures the search strategy.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef SlitherLink(data):\n  num_rows = len(data)\n  num_columns = len(data[0])\n\n  solver = pywrapcp.Solver('slitherlink')\n  h_arcs = [[\n      solver.BoolVar('h_arcs[%i][%i]' % (i, j)) for j in range(num_columns)\n  ] for i in range(num_rows + 1)]\n\n  v_arcs = [[\n      solver.BoolVar('v_arcs[%i][%i]' % (i, j)) for j in range(num_rows)\n  ] for i in range(num_columns + 1)]\n\n  # Constraint on the sum or arcs\n  for i in range(num_rows):\n    for j in range(num_columns):\n      if data[i][j] != -1:\n        sq = [h_arcs[i][j], h_arcs[i + 1][j], v_arcs[j][i], v_arcs[j + 1][i]]\n        solver.Add(solver.SumEquality(sq, data[i][j]))\n\n  # Single loop: each node has a degree 0 or 2\n  zero_or_two = [0, 2]\n  for i in range(num_rows + 1):\n    for j in range(num_columns + 1):\n      neighbors = NeighboringArcs(i, j, h_arcs, v_arcs)\n      solver.Add(solver.Sum(neighbors).Member(zero_or_two))\n\n  # Single loop: sum or arcs on row or column is even\n  for i in range(num_columns):\n    column = [h_arcs[j][i] for j in range(num_rows + 1)]\n    solver.Add(BooleanSumEven(solver, column))\n\n  for i in range(num_rows):\n    row = [v_arcs[j][i] for j in range(num_columns + 1)]\n    solver.Add(BooleanSumEven(solver, row))\n\n  # Single loop: main constraint\n  solver.Add(GridSinglePath(solver, h_arcs, v_arcs))\n\n  # Special rule on corners: value == 3 implies 2 border arcs used.\n  if data[0][0] == 3:\n    h_arcs[0][0].SetMin(1)\n    v_arcs[0][0].SetMin(1)\n  if data[0][num_columns - 1] == 3:\n    h_arcs[0][num_columns - 1].SetMin(1)\n    v_arcs[num_columns][0].SetMin(1)\n  if data[num_rows - 1][0] == 3:\n    h_arcs[num_rows][0].SetMin(1)\n    v_arcs[0][num_rows - 1].SetMin(1)\n  if data[num_rows - 1][num_columns - 1] == 3:\n    h_arcs[num_rows][num_columns - 1].SetMin(1)\n    v_arcs[num_columns][num_rows - 1].SetMin(1)\n\n  # Search\n  all_vars = []\n  for row in h_arcs:\n    all_vars.extend(row)\n  for column in v_arcs:\n    all_vars.extend(column)\n\n  db = solver.Phase(all_vars, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MAX_VALUE)\n\n  log = solver.SearchLog(1000000)\n\n  solver.NewSearch(db, log)\n  while solver.NextSolution():\n    PrintSolution(data, h_arcs, v_arcs)\n  solver.EndSearch()\n```\n\n----------------------------------------\n\nTITLE: Solving Optimization Problem with Intermediate Solution Printing in CP-SAT\nDESCRIPTION: Implements a function that creates a simple optimization problem, sets up the CP-SAT solver with a custom solution printer, and solves the problem while displaying all intermediate solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solve_and_print_intermediate_solutions_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef solve_and_print_intermediate_solutions_sample_sat():\n    \"\"\"Showcases printing intermediate solutions found during search.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    model.maximize(x + 2 * y + 3 * z)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArrayAndObjectiveSolutionPrinter([x, y, z])\n    status = solver.solve(model, solution_printer)\n\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n\nsolve_and_print_intermediate_solutions_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Hidato Puzzle Solver Implementation\nDESCRIPTION: Complete implementation of the Hidato puzzle solver including helper functions for building pairs, printing solutions, and solving the puzzle using CP-SAT solver. The code handles puzzle generation, constraint definition, and solution visualization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/hidato_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\nfrom ortools.sat.colab import visualization\nfrom ortools.sat.python import cp_model\n\n\ndef build_pairs(rows: int, cols: int) -> list[tuple[int, int]]:\n    \"\"\"Build closeness pairs for consecutive numbers.\n\n    Build set of allowed pairs such that two consecutive numbers touch\n    each other in the grid.\n\n    Returns:\n      A list of pairs for allowed consecutive position of numbers.\n\n    Args:\n      rows: the number of rows in the grid\n      cols: the number of columns in the grid\n    \"\"\"\n    result = []\n    for x in range(rows):\n        for y in range(cols):\n            for dx in (-1, 0, 1):\n                for dy in (-1, 0, 1):\n                    if (\n                        x + dx >= 0\n                        and x + dx < rows\n                        and y + dy >= 0\n                        and y + dy < cols\n                        and (dx != 0 or dy != 0)\n                    ):\n                        result.append((x * cols + y, (x + dx) * cols + (y + dy)))\n    return result\n\n\ndef print_solution(positions: list[int], rows: int, cols: int):\n    \"\"\"Print a current solution.\"\"\"\n    # Create empty board.\n    board = []\n    for _ in range(rows):\n        board.append([0] * cols)\n    # Fill board with solution value.\n    for k in range(rows * cols):\n        position = positions[k]\n        board[position // cols][position % cols] = k + 1\n    # Print the board.\n    print(\"Solution\")\n    print_matrix(board)\n\n\ndef print_matrix(game: list[list[int]]) -> None:\n    \"\"\"Pretty print of a matrix.\"\"\"\n    rows = len(game)\n    cols = len(game[0])\n    for i in range(rows):\n        line = \"\"\n        for j in range(cols):\n            if game[i][j] == 0:\n                line += \"  .\"\n            else:\n                line += f\"{game[i][j]:3}\"\n        print(line)\n\n\ndef build_puzzle(problem: int) -> Union[None, list[list[int]]]:\n    \"\"\"Build the problem from its index.\"\"\"\n    #\n    # models, a 0 indicates an open cell which number is not yet known.\n    #\n    #\n    puzzle = None\n    if problem == 1:\n        # Simple problem\n        puzzle = [[6, 0, 9], [0, 2, 8], [1, 0, 0]]\n\n    elif problem == 2:\n        puzzle = [\n            [0, 44, 41, 0, 0, 0, 0],\n            [0, 43, 0, 28, 29, 0, 0],\n            [0, 1, 0, 0, 0, 33, 0],\n            [0, 2, 25, 4, 34, 0, 36],\n            [49, 16, 0, 23, 0, 0, 0],\n            [0, 19, 0, 0, 12, 7, 0],\n            [0, 0, 0, 14, 0, 0, 0],\n        ]\n\n    elif problem == 3:\n        # Problems from the book:\n        # Gyora Bededek: 'Hidato: 2000 Pure Logic Puzzles'\n        # Problem 1 (Practice)\n        puzzle = [\n            [0, 0, 20, 0, 0],\n            [0, 0, 0, 16, 18],\n            [22, 0, 15, 0, 0],\n            [23, 0, 1, 14, 11],\n            [0, 25, 0, 0, 12],\n        ]\n\n    elif problem == 4:\n        # problem 2 (Practice)\n        puzzle = [\n            [0, 0, 0, 0, 14],\n            [0, 18, 12, 0, 0],\n            [0, 0, 17, 4, 5],\n            [0, 0, 7, 0, 0],\n            [9, 8, 25, 1, 0],\n        ]\n\n    elif problem == 5:\n        # problem 3 (Beginner)\n        puzzle = [\n            [0, 26, 0, 0, 0, 18],\n            [0, 0, 27, 0, 0, 19],\n            [31, 23, 0, 0, 14, 0],\n            [0, 33, 8, 0, 15, 1],\n            [0, 0, 0, 5, 0, 0],\n            [35, 36, 0, 10, 0, 0],\n        ]\n    elif problem == 6:\n        # Problem 15 (Intermediate)\n        puzzle = [\n            [64, 0, 0, 0, 0, 0, 0, 0],\n            [1, 63, 0, 59, 15, 57, 53, 0],\n            [0, 4, 0, 14, 0, 0, 0, 0],\n            [3, 0, 11, 0, 20, 19, 0, 50],\n            [0, 0, 0, 0, 22, 0, 48, 40],\n            [9, 0, 0, 32, 23, 0, 0, 41],\n            [27, 0, 0, 0, 36, 0, 46, 0],\n            [28, 30, 0, 35, 0, 0, 0, 0],\n        ]\n    return puzzle\n\n\ndef solve_hidato(puzzle: list[list[int]], index: int) -> None:\n    \"\"\"solve the given hidato table.\"\"\"\n    # Create the model.\n    model = cp_model.CpModel()\n\n    r = len(puzzle)\n    c = len(puzzle[0])\n    if not visualization.RunFromIPython():\n        print(\"\")\n        print(f\"----- Solving problem {index} -----\")\n        print(\"\")\n        print(f\"Initial game ({r} x {c})\")\n        print_matrix(puzzle)\n\n    #\n    # Declare variables.\n    #\n    positions = [model.new_int_var(0, r * c - 1, f\"p[{i}]\") for i in range(r * c)]\n\n    #\n    # Constraints.\n    #\n    model.add_all_different(positions)\n\n    #\n    # Fill in the clues.\n    #\n    for i in range(r):\n        for j in range(c):\n            if puzzle[i][j] > 0:\n                model.add(positions[puzzle[i][j] - 1] == i * c + j)\n\n    # Consecutive numbers much touch each other in the grid.\n    # We use an allowed assignment constraint to model it.\n    close_tuples = build_pairs(r, c)\n    for k in range(0, r * c - 1):\n        model.add_allowed_assignments([positions[k], positions[k + 1]], close_tuples)\n\n    #\n    # Solution and search.\n    #\n\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        if visualization.RunFromIPython():\n            output = visualization.SvgWrapper(10, r, 40.0)\n            for i, var in enumerate(positions):\n                val = solver.value(var)\n                x = val % c\n                y = val // c\n                color = \"white\" if puzzle[y][x] == 0 else \"lightgreen\"\n                output.AddRectangle(x, r - y - 1, 1, 1, color, \"black\", str(i + 1))\n\n            output.AddTitle(f\"Puzzle {index} solved in {solver.wall_time:.2f} s\")\n            output.Display()\n        else:\n            print_solution(\n                [solver.value(x) for x in positions],\n                r,\n                c,\n            )\n            print(solver.response_stats())\n\n\ndef main(_):\n    for pb in range(1, 7):\n        solve_hidato(build_puzzle(pb), pb)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Defining CVRP Data Model with Reload Capability\nDESCRIPTION: Creates the data model for a Capacitated Vehicle Routing Problem with reload capability. The model includes locations, capacity demands, time windows, vehicle constraints, and special reload depot nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrp_reload.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import partial\n\nfrom ortools.constraint_solver import pywrapcp\nfrom ortools.constraint_solver import routing_enums_pb2\n\n\n###########################\n# Problem Data Definition #\n###########################\ndef create_data_model():\n    \"\"\"Stores the data for the problem\"\"\"\n    data = {}\n    _capacity = 15\n    # Locations in block unit\n    _locations = [\n        (4, 4),  # depot\n        (4, 4),  # unload depot_first\n        (4, 4),  # unload depot_second\n        (4, 4),  # unload depot_third\n        (4, 4),  # unload depot_fourth\n        (4, 4),  # unload depot_fifth\n        (2, 0),\n        (8, 0),  # locations to visit\n        (0, 1),\n        (1, 1),\n        (5, 2),\n        (7, 2),\n        (3, 3),\n        (6, 3),\n        (5, 5),\n        (8, 5),\n        (1, 6),\n        (2, 6),\n        (3, 7),\n        (6, 7),\n        (0, 8),\n        (7, 8),\n    ]\n    # Compute locations in meters using the block dimension defined as follow\n    # Manhattan average block: 750ft x 264ft -> 228m x 80m\n    # here we use: 114m x 80m city block\n    # src: https://nyti.ms/2GDoRIe 'NY Times: Know Your distance'\n    data[\"locations\"] = [(l[0] * 114, l[1] * 80) for l in _locations]\n    data[\"num_locations\"] = len(data[\"locations\"])\n    data[\"demands\"] = [\n        0,  # depot\n        -_capacity,  # unload depot_first\n        -_capacity,  # unload depot_second\n        -_capacity,  # unload depot_third\n        -_capacity,  # unload depot_fourth\n        -_capacity,  # unload depot_fifth\n        3,\n        3,  # 1, 2\n        3,\n        4,  # 3, 4\n        3,\n        4,  # 5, 6\n        8,\n        8,  # 7, 8\n        3,\n        3,  # 9,10\n        3,\n        3,  # 11,12\n        4,\n        4,  # 13, 14\n        8,\n        8,\n    ]  # 15, 16\n    data[\"time_per_demand_unit\"] = 5  # 5 minutes/unit\n    data[\"time_windows\"] = [\n        (0, 0),  # depot\n        (0, 1000),  # unload depot_first\n        (0, 1000),  # unload depot_second\n        (0, 1000),  # unload depot_third\n        (0, 1000),  # unload depot_fourth\n        (0, 1000),  # unload depot_fifth\n        (75, 850),\n        (75, 850),  # 1, 2\n        (60, 700),\n        (45, 550),  # 3, 4\n        (0, 800),\n        (50, 600),  # 5, 6\n        (0, 1000),\n        (10, 200),  # 7, 8\n        (0, 1000),\n        (75, 850),  # 9, 10\n        (85, 950),\n        (5, 150),  # 11, 12\n        (15, 250),\n        (10, 200),  # 13, 14\n        (45, 550),\n        (30, 400),\n    ]  # 15, 16\n    data[\"num_vehicles\"] = 3\n    data[\"vehicle_capacity\"] = _capacity\n    data[\"vehicle_max_distance\"] = 10_000\n    data[\"vehicle_max_time\"] = 1_500\n    data[\"vehicle_speed\"] = 5 * 60 / 3.6  # Travel speed: 5km/h to convert in m/min\n    data[\"depot\"] = 0\n    return data\n\n\n#######################\n```\n\n----------------------------------------\n\nTITLE: Using Sequence Constraints in a No-Overlap Scheduling Example\nDESCRIPTION: This function demonstrates how to use the sequence constraints in a complete scheduling example with 13 tasks of two types (A and B). It creates a CP-SAT model, defines sequence length and cumulative duration constraints, and solves the model to find an optimal schedule.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ndef sequences_in_no_overlap_sample_sat():\n    \"\"\"Implement cumul and length constraints in a NoOverlap constraint.\"\"\"\n\n    # Tasks (duration, type).\n    tasks = [\n        (5, \"A\"),\n        (6, \"A\"),\n        (7, \"A\"),\n        (2, \"A\"),\n        (3, \"A\"),\n        (5, \"B\"),\n        (2, \"B\"),\n        (3, \"B\"),\n        (1, \"B\"),\n        (4, \"B\"),\n        (3, \"B\"),\n        (6, \"B\"),\n        (2, \"B\"),\n    ]\n\n    # Sequence length constraints per task_types: (hard_min, hard_max)\n    #\n    # Note that this constraint is very tight for task type B and will fail with\n    # an odd number of tasks of type B.\n    sequence_length_constraints = {\n        \"A\": (1, 3),\n        \"B\": (2, 2),\n    }\n\n    # Sequence accumulated durations constraints per task_types:\n    #     (soft_max, linear_penalty, hard_max)\n    sequence_cumul_constraints = {\n        \"A\": (6, 1, 10),\n        \"B\": (7, 0, 7),\n    }\n\n    model: cp_model.CpModel = cp_model.CpModel()\n    horizon: int = sum(t[0] for t in tasks)\n\n    num_tasks = len(tasks)\n    all_tasks = range(num_tasks)\n\n    starts = []\n    durations = []\n    intervals = []\n    task_types = []\n\n    # Creates intervals for each task.\n    for duration, task_type in tasks:\n        index = len(starts)\n        start = model.new_int_var(0, horizon - duration, f\"start[{index}]\")\n        interval = model.new_fixed_size_interval_var(\n            start, duration, f\"interval[{index}]\"\n        )\n\n        starts.append(start)\n        durations.append(duration)\n        intervals.append(interval)\n        task_types.append(task_type)\n\n    # Create length variables for each task.\n    lengths = []\n    for i in all_tasks:\n        max_hard_length = sequence_length_constraints[task_types[i]][1]\n        lengths.append(model.new_int_var(1, max_hard_length, f\"length_{i}\"))\n\n    # Create cumul variables for each task.\n    cumuls = []\n    for i in all_tasks:\n        max_hard_cumul = sequence_cumul_constraints[task_types[i]][2]\n        cumuls.append(model.new_int_var(durations[i], max_hard_cumul, f\"cumul_{i}\"))\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds the constraints on the lengths and cumuls of maximal sequences of\n    # tasks of the same type.\n    penalty_terms = sequence_constraints_with_circuit(\n        model,\n        starts,\n        durations,\n        task_types,\n        lengths,\n        cumuls,\n        sequence_length_constraints,\n        sequence_cumul_constraints,\n    )\n\n    # Minimize the sum of penalties,\n    model.minimize(sum(var * penalty for var, penalty in penalty_terms))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        # Prints out the makespan and the start times and lengths, cumuls at each\n        # step.\n        if status == cp_model.OPTIMAL:\n            print(f\"Optimal cost: {solver.objective_value}\")\n        else:\n            print(f\"Feasible cost: {solver.objective_value}\")\n\n        to_sort = []\n        for t in all_tasks:\n            to_sort.append((solver.value(starts[t]), t))\n        to_sort.sort()\n\n        sum_of_penalties = 0\n        for i, (start, t) in enumerate(to_sort):\n            # Check length constraints.\n            length: int = solver.value(lengths[t])\n            hard_min_length, hard_max_length = sequence_length_constraints[\n                task_types[t]\n            ]\n            assert length >= 0\n            assert length <= hard_max_length\n            if (\n                i + 1 == len(to_sort) or task_types[t] != task_types[to_sort[i + 1][1]]\n            ):  # End of sequence.\n                assert length >= hard_min_length\n\n            # Check cumul constraints.\n            cumul: int = solver.value(cumuls[t])\n            soft_max_cumul, penalty, hard_max_cumul = sequence_cumul_constraints[\n                task_types[t]\n            ]\n```\n\n----------------------------------------\n\nTITLE: Nonogram Solver Implementation\nDESCRIPTION: Complete implementation of a Nonogram puzzle solver using constraint programming. Includes pattern transition generation, rule checking, and solution visualization. Uses OR-Tools for constraint solving and implements a custom labeling strategy for efficient search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_default_search.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\n#\n# Make a transition (automaton) list of tuples from a\n# single pattern, e.g. [3,2,1]\n#\ndef make_transition_tuples(pattern):\n  p_len = len(pattern)\n  num_states = p_len + sum(pattern)\n\n  tuples = []\n\n  # this is for handling 0-clues. It generates\n  # just the minimal state\n  if num_states == 0:\n    tuples.append((1, 0, 1))\n    return (tuples, 1)\n\n  # convert pattern to a 0/1 pattern for easy handling of\n  # the states\n  tmp = [0]\n  c = 0\n  for pattern_index in range(p_len):\n    tmp.extend([1] * pattern[pattern_index])\n    tmp.append(0)\n\n  for i in range(num_states):\n    state = i + 1\n    if tmp[i] == 0:\n      tuples.append((state, 0, state))\n      tuples.append((state, 1, state + 1))\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          tuples.append((state, 1, state + 1))\n        else:\n          tuples.append((state, 0, state + 1))\n  tuples.append((num_states, 0, num_states))\n  return (tuples, num_states)\n\n\n#\n# check each rule by creating an automaton and transition constraint.\n#\ndef check_rule(rules, y):\n  cleaned_rule = [rules[i] for i in range(len(rules)) if rules[i] > 0]\n  (transition_tuples, last_state) = make_transition_tuples(cleaned_rule)\n\n  initial_state = 1\n  accepting_states = [last_state]\n\n  solver = y[0].solver()\n  solver.Add(\n      solver.TransitionConstraint(y, transition_tuples, initial_state,\n                                  accepting_states))\n\n\ndef main(rows, row_rule_len, row_rules, cols, col_rule_len, col_rules):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Nonogram')\n\n  #\n  # variables\n  #\n  board = {}\n  for i in range(rows):\n    for j in range(cols):\n      board[i, j] = solver.IntVar(0, 1, 'board[%i, %i]' % (i, j))\n\n  board_flat = [board[i, j] for i in range(rows) for j in range(cols)]\n\n  # Flattened board for labeling.\n  # This labeling was inspired by a suggestion from\n  # Pascal Van Hentenryck about my (hakank's) Comet\n  # nonogram model.\n  board_label = []\n  if rows * row_rule_len < cols * col_rule_len:\n    for i in range(rows):\n      for j in range(cols):\n        board_label.append(board[i, j])\n  else:\n    for j in range(cols):\n      for i in range(rows):\n        board_label.append(board[i, j])\n\n  #\n  # constraints\n  #\n  for i in range(rows):\n    check_rule(row_rules[i], [board[i, j] for j in range(cols)])\n\n  for j in range(cols):\n    check_rule(col_rules[j], [board[i, j] for i in range(rows)])\n\n  #\n  # solution and search\n  #\n  parameters = pywrapcp.DefaultPhaseParameters()\n  parameters.heuristic_period = 200000\n\n  db = solver.DefaultPhase(board_label, parameters)\n\n  print('before solver, wall time = ', solver.WallTime(), 'ms')\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print()\n    num_solutions += 1\n    for i in range(rows):\n      row = [board[i, j].Value() for j in range(cols)]\n      row_pres = []\n      for j in row:\n        if j == 1:\n          row_pres.append('#')\n        else:\n          row_pres.append(' ')\n      print('  ', ''.join(row_pres))\n\n    print()\n    print('  ', '-' * cols)\n\n    if num_solutions >= 2:\n      print('2 solutions is enough...')\n      break\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\n#\n# Default problem\n#\n# From http://twan.home.fmf.nl/blog/haskell/Nonograms.details\n# The lambda picture\n#\nrows = 12\nrow_rule_len = 3\nrow_rules = [[0, 0, 2], [0, 1, 2], [0, 1, 1], [0, 0, 2], [0, 0, 1], [0, 0, 3],\n             [0, 0, 3], [0, 2, 2], [0, 2, 1], [2, 2, 1], [0, 2, 3], [0, 2, 2]]\n\ncols = 10\ncol_rule_len = 2\ncol_rules = [[2, 1], [1, 3], [2, 4], [3, 4], [0, 4], [0, 3], [0, 3], [0, 3],\n             [0, 2], [0, 2]]\n\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  exec(compile(open(file).read(), file, 'exec'))\nmain(rows, row_rule_len, row_rules, cols, col_rule_len, col_rules)\n```\n\n----------------------------------------\n\nTITLE: Solving Constraint Programming Model with Assumptions using OR-Tools in C#\nDESCRIPTION: This code creates a constraint programming model using Google's OR-Tools library. It defines integer and boolean variables, adds constraints with enforcement conditions, sets assumptions, and solves the model. The example demonstrates how to use assumptions in constraint programming and retrieve sufficient assumptions for infeasibility.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/troubleshooting.md#2025-04-17_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class AssumptionsSampleSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n\n        // Creates the variables.\n        IntVar x = model.NewIntVar(0, 10, \"x\");\n        IntVar y = model.NewIntVar(0, 10, \"y\");\n        IntVar z = model.NewIntVar(0, 10, \"z\");\n        ILiteral a = model.NewBoolVar(\"a\");\n        ILiteral b = model.NewBoolVar(\"b\");\n        ILiteral c = model.NewBoolVar(\"c\");\n\n        // Creates the constraints.\n        model.Add(x > y).OnlyEnforceIf(a);\n        model.Add(y > z).OnlyEnforceIf(b);\n        model.Add(z > x).OnlyEnforceIf(c);\n\n        // Add assumptions\n        model.AddAssumptions(new ILiteral[] { a, b, c });\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        CpSolverStatus status = solver.Solve(model);\n        Console.WriteLine(solver.SufficientAssumptionsForInfeasibility());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Covering and Set Partition Algorithms\nDESCRIPTION: This function implements both set covering and set partition algorithms using Google OR-Tools. It takes a parameter to determine which algorithm to use, sets up the problem data, defines constraints, and solves the optimization problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering4.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(set_partition=1):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set partition and set covering\")\n\n  #\n  # data\n  #\n  num_alternatives = 10\n  num_objects = 8\n\n  # costs for the alternatives\n  costs = [19, 16, 18, 13, 15, 19, 15, 17, 16, 15]\n\n  # the alternatives, and their objects\n  a = [\n      # 1 2 3 4 5 6 7 8    the objects\n      [1, 0, 0, 0, 0, 1, 0, 0],  # alternative 1\n      [0, 1, 0, 0, 0, 1, 0, 1],  # alternative 2\n      [1, 0, 0, 1, 0, 0, 1, 0],  # alternative 3\n      [0, 1, 1, 0, 1, 0, 0, 0],  # alternative 4\n      [0, 1, 0, 0, 1, 0, 0, 0],  # alternative 5\n      [0, 1, 1, 0, 0, 0, 0, 0],  # alternative 6\n      [0, 1, 1, 1, 0, 0, 0, 0],  # alternative 7\n      [0, 0, 0, 1, 1, 0, 0, 1],  # alternative 8\n      [0, 0, 1, 0, 0, 1, 0, 1],  # alternative 9\n      [1, 0, 0, 0, 0, 1, 1, 0]  # alternative 10\n  ]\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 1, \"x[%i]\" % i) for i in range(num_alternatives)]\n\n  #\n  # constraints\n  #\n\n  # sum the cost of the choosen alternative,\n  # to be minimized\n  z = solver.ScalProd(x, costs)\n\n  #\n  for j in range(num_objects):\n    if set_partition == 1:\n      solver.Add(\n          solver.SumEquality([x[i] * a[i][j] for i in range(num_alternatives)],\n                             1))\n    else:\n      solver.Add(\n          solver.SumGreaterOrEqual(\n              [x[i] * a[i][j] for i in range(num_alternatives)], 1))\n\n  objective = solver.Minimize(z, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.AddObjective(z)\n\n  collector = solver.LastSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase([x[i] for i in range(num_alternatives)],\n                   solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT),\n      [collector, objective])\n\n  print(\"z:\", collector.ObjectiveValue(0))\n  print(\n      \"selected alternatives:\",\n      [i + 1 for i in range(num_alternatives) if collector.Value(0, x[i]) == 1])\n\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nprint(\"Set partition:\")\nmain(1)\n\nprint(\"\\nSet covering:\")\nmain(0)\n```\n\n----------------------------------------\n\nTITLE: Solving Constraint Satisfaction Problem with Assumptions in Python\nDESCRIPTION: Creates a constraint programming model with integer and boolean variables, establishes constraints with assumptions, and demonstrates how to identify the cause of infeasibility\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assumptions_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef main() -> None:\n    \"\"\"Showcases assumptions.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    x = model.new_int_var(0, 10, \"x\")\n    y = model.new_int_var(0, 10, \"y\")\n    z = model.new_int_var(0, 10, \"z\")\n    a = model.new_bool_var(\"a\")\n    b = model.new_bool_var(\"b\")\n    c = model.new_bool_var(\"c\")\n\n    # Creates the constraints.\n    model.add(x > y).only_enforce_if(a)\n    model.add(y > z).only_enforce_if(b)\n    model.add(z > x).only_enforce_if(c)\n\n    # Add assumptions\n    model.add_assumptions([a, b, c])\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Print solution.\n    print(f\"Status = {solver.status_name(status)}\")\n    if status == cp_model.INFEASIBLE:\n        print(\n            \"sufficient_assumptions_for_infeasibility = \"\n            f\"{solver.sufficient_assumptions_for_infeasibility()}\"\n        )\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Nontransitive Dice Problem with OR-Tools\nDESCRIPTION: Main implementation of the nontransitive dice solver using Google OR-Tools. The code creates a constraint satisfaction problem to find dice values that satisfy nontransitive relationships. It supports configurable number of dice and sides, with options for minimizing maximum values.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nontransitive_dice.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\ndef main(m=3, n=6, minimize_val=0):\n  solver = pywrapcp.Solver(\"Nontransitive dice\")\n  \n  print(\"number of dice:\", m)\n  print(\"number of sides:\", n)\n\n  dice = {}\n  for i in range(m):\n    for j in range(n):\n      dice[(i, j)] = solver.IntVar(1, n * 2, \"dice(%i,%i)\" % (i, j))\n  dice_flat = [dice[(i, j)] for i in range(m) for j in range(n)]\n\n  comp = {}\n  for i in range(m):\n    for j in range(2):\n      comp[(i, j)] = solver.IntVar(0, n * n, \"comp(%i,%i)\" % (i, j))\n  comp_flat = [comp[(i, j)] for i in range(m) for j in range(2)]\n\n  gap = [solver.IntVar(0, n * n, \"gap(%i)\" % i) for i in range(m)]\n  gap_sum = solver.IntVar(0, m * n * n, \"gap_sum\")\n\n  max_val = solver.IntVar(0, n * 2, \"max_val\")\n  max_win = solver.IntVar(0, n * n, \"max_win\")\n\n  counts = [solver.IntVar(0, n * m, \"counts(%i)\" % i) for i in range(n * 2 + 1)]\n\n  solver.Add(solver.Distribute(dice_flat, list(range(n * 2 + 1)), counts))\n\n  solver.Add(max_win == solver.Max(comp_flat))\n  solver.Add(max_val == solver.Max(dice_flat))\n\n  [solver.Add(dice[(i, j)] <= dice[(i, j + 1)]) for i in range(m) for j in range(n - 1)]\n\n  [comp[i, 0] > comp[i, 1] for i in range(m)],\n\n  [solver.Add(gap[i] == comp[i, 0] - comp[i, 1]) for i in range(m)]\n  [solver.Add(gap[i] > 0) for i in range(m)]\n  solver.Add(gap_sum == solver.Sum(gap))\n\n  for d in range(m):\n    b1 = [solver.IsGreaterVar(dice[d % m, r1], dice[(d + 1) % m, r2]) for r1 in range(n) for r2 in range(n)]\n    solver.Add(comp[d % m, 0] == solver.Sum(b1))\n\n    b2 = [solver.IsGreaterVar(dice[(d + 1) % m, r1], dice[d % m, r2]) for r1 in range(n) for r2 in range(n)]\n    solver.Add(comp[d % m, 1] == solver.Sum(b2))\n\n  if minimize_val != 0:\n    print(\"Minimizing max_val\")\n    objective = solver.Minimize(max_val, 1)\n\n  db = solver.Phase(dice_flat + comp_flat, solver.INT_VAR_DEFAULT, solver.ASSIGN_MIN_VALUE)\n\n  if minimize_val:\n    solver.NewSearch(db, [objective])\n  else:\n    solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"gap_sum:\", gap_sum.Value())\n    print(\"gap:\", [gap[i].Value() for i in range(m)])\n    print(\"max_val:\", max_val.Value())\n    print(\"max_win:\", max_win.Value())\n    print(\"dice:\")\n    for i in range(m):\n      for j in range(n):\n        print(dice[(i, j)].Value(), end=\" \")\n      print()\n    print(\"comp:\")\n    for i in range(m):\n      for j in range(2):\n        print(comp[(i, j)].Value(), end=\" \")\n      print()\n    print(\"counts:\", [counts[i].Value() for i in range(n * 2 + 1)])\n    print()\n\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\nm = 3\nn = 6\nminimize_val = 0\nif len(sys.argv) > 1:\n  m = int(sys.argv[1])\nif len(sys.argv) > 2:\n  n = int(sys.argv[2])\nif len(sys.argv) > 3:\n  minimize_val = int(sys.argv[3])\n\nmain(m, n, minimize_val)\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Covering Solver with Google OR-Tools in Python\nDESCRIPTION: This code implements a solver for the set covering problem using Google's OR-Tools. It defines the problem parameters, creates variables and constraints, and solves the optimization problem to minimize the number of firestations while covering all cities within a specified distance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(unused_argv):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set covering\")\n\n  #\n  # data\n  #\n  min_distance = 15\n  num_cities = 6\n\n  distance = [[0, 10, 20, 30, 30, 20], [10, 0, 25, 35, 20, 10],\n              [20, 25, 0, 15, 30, 20], [30, 35, 15, 0, 15, 25],\n              [30, 20, 30, 15, 0, 14], [20, 10, 20, 25, 14, 0]]\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 1, \"x[%i]\" % i) for i in range(num_cities)]\n\n  #\n  # constraints\n  #\n\n  # objective to minimize\n  z = solver.Sum(x)\n\n  # ensure that all cities are covered\n  for i in range(num_cities):\n    b = [x[j] for j in range(num_cities) if distance[i][j] <= min_distance]\n    solver.Add(solver.SumGreaterOrEqual(b, 1))\n\n  objective = solver.Minimize(z, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.AddObjective(z)\n\n  collector = solver.LastSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase(x + [z], solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT),\n      [collector, objective])\n\n  print(\"z:\", collector.ObjectiveValue(0))\n  print(\"x:\", [collector.Value(0, x[i]) for i in range(num_cities)])\n\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Building Interval Variables in CP-SAT Using Python\nDESCRIPTION: The snippet demonstrates how to create interval variables in a constraint programming model using the Python CP-SAT API from Google OR-Tools. The function defines a model, initializes start, end, and interval variables, and outputs their representations. The script also shows how to create fixed-size interval variables. The main prerequisites include the 'ortools' package and a basic understanding of constraint programming concepts.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/interval_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef interval_sample_sat():\n    \"\"\"Showcases how to build interval variables.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 100\n\n    # An interval can be created from three affine expressions.\n    start_var = model.new_int_var(0, horizon, \"start\")\n    duration = 10  # Python cp/sat code accept integer variables or constants.\n    end_var = model.new_int_var(0, horizon, \"end\")\n    interval_var = model.new_interval_var(start_var, duration, end_var + 2, \"interval\")\n\n    print(f\"interval = {repr(interval_var)}\")\n\n    # If the size is fixed, a simpler version uses the start expression and the\n    # size.\n    fixed_size_interval_var = model.new_fixed_size_interval_var(\n        start_var, 10, \"fixed_size_interval_var\"\n    )\n    print(f\"fixed_size_interval_var = {repr(fixed_size_interval_var)}\")\n\n    # A fixed interval can be created using the same API.\n    fixed_interval = model.new_fixed_size_interval_var(5, 10, \"fixed_interval\")\n    print(f\"fixed_interval = {repr(fixed_interval)}\")\n\n\ninterval_sample_sat()\n\n```\n\n----------------------------------------\n\nTITLE: Defining the rank_tasks Function\nDESCRIPTION: This function adds constraints and variables to link tasks and ranks within a CP model. It iterates through tasks, creates precedence variables, handles optional intervals, and links precedences to ranks using boolean logic and implications, it assumes all starts are disjoint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/ranking_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.sat.python import cp_model\n\n\ndef rank_tasks(\n    model: cp_model.CpModel,\n    starts: list[cp_model.IntVar],\n    presences: list[cp_model.BoolVarT],\n    ranks: list[cp_model.IntVar],\n) -> None:\n    \\\"\\\"\\\"This method adds constraints and variables to links tasks and ranks.\n\n    This method assumes that all starts are disjoint, meaning that all tasks have\n    a strictly positive duration, and they appear in the same NoOverlap\n    constraint.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      presences: The array of presence variables or constants of all tasks.\n      ranks: The array of rank variables of all tasks.\n    \\\"\\\"\\\"    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    # Creates precedence variables between pairs of intervals.\n    precedences: dict[tuple[int, int], cp_model.BoolVarT] = {}\n    for i in all_tasks:\n        for j in all_tasks:\n            if i == j:\n                precedences[(i, j)] = presences[i]\n            else:\n                prec = model.new_bool_var(f\\\"{i} before {j}\\\")\n                precedences[(i, j)] = prec\n                model.add(starts[i] < starts[j]).only_enforce_if(prec)\n\n    # Treats optional intervals.\n    for i in range(num_tasks - 1):\n        for j in range(i + 1, num_tasks):\n            tmp_array: list[cp_model.BoolVarT] = [\n                precedences[(i, j)],\n                precedences[(j, i)],\n            ]\n            if not cp_model.object_is_a_true_literal(presences[i]):\n                tmp_array.append(~presences[i])\n                # Makes sure that if i is not performed, all precedences are false.\n                model.add_implication(~presences[i], ~precedences[(i, j)])\n                model.add_implication(~presences[i], ~precedences[(j, i)])\n            if not cp_model.object_is_a_true_literal(presences[j]):\n                tmp_array.append(~presences[j])\n                # Makes sure that if j is not performed, all precedences are false.\n                model.add_implication(~presences[j], ~precedences[(i, j)])\n                model.add_implication(~presences[j], ~precedences[(j, i)])\n            # The following bool_or will enforce that for any two intervals:\n            #    i precedes j or j precedes i or at least one interval is not\n            #        performed.\n            model.add_bool_or(tmp_array)\n            # Redundant constraint: it propagates early that at most one precedence\n            # is true.\n            model.add_implication(precedences[(i, j)], ~precedences[(j, i)])\n            model.add_implication(precedences[(j, i)], ~precedences[(i, j)])\n\n    # Links precedences and ranks.\n    for i in all_tasks:\n        model.add(ranks[i] == sum(precedences[(j, i)] for j in all_tasks) - 1)\n\"\n```\n\n----------------------------------------\n\nTITLE: Prize Collecting VRP Solver Implementation\nDESCRIPTION: Main solver implementation using CP-SAT solver to find optimal routes for vehicles collecting prizes while respecting distance constraints\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef prize_collecting_vrp():\n    \"\"\"Entry point of the program.\"\"\"\n    num_nodes = len(DISTANCE_MATRIX)\n    num_vehicles = 4\n    print(f\"Num nodes = {num_nodes}\")\n\n    # Model.\n    model = cp_model.CpModel()\n\n    obj_vars = []\n    obj_coeffs = []\n    visited_nodes = {}\n    used_arcs = {}\n\n    # Create the circuit constraint.\n    all_nodes = range(num_nodes)\n    for v in range(num_vehicles):\n        visited_nodes[v] = []\n        used_arcs[v] = {}\n        arcs = []\n        for i in all_nodes:\n            is_visited = model.new_bool_var(f\"{i} is visited\")\n            arcs.append((i, i, ~is_visited))\n\n            obj_vars.append(is_visited)\n            obj_coeffs.append(VISIT_VALUES[i])\n            visited_nodes[v].append(is_visited)\n\n            for j in all_nodes:\n                if i == j:\n                    used_arcs[v][i, j] = ~is_visited\n                    continue\n                arc_is_used = model.new_bool_var(f\"{j} follows {i}\")\n                arcs.append((i, j, arc_is_used))\n\n                obj_vars.append(arc_is_used)\n                obj_coeffs.append(-DISTANCE_MATRIX[i][j])\n                used_arcs[v][i, j] = arc_is_used\n\n        model.add_circuit(arcs)\n\n        # Node 0 must be visited.\n        model.add(visited_nodes[v][0] == 1)\n\n        # limit the route distance\n        model.add(\n            sum(\n                used_arcs[v][i, j] * DISTANCE_MATRIX[i][j]\n                for i in all_nodes\n                for j in all_nodes\n            )\n            <= MAX_DISTANCE\n        )\n\n    # Each node is visited at most once\n    for node in range(1, num_nodes):\n        model.add_at_most_one([visited_nodes[v][node] for v in range(num_vehicles)])\n\n    # Maximize visited node values minus the travelled distance.\n    model.maximize(sum(obj_vars[i] * obj_coeffs[i] for i in range(len(obj_vars))))\n\n    # Solve and print out the solution.\n    solver = cp_model.CpSolver()\n    solver.parameters.num_search_workers = 8\n    solver.parameters.max_time_in_seconds = 15.0\n    solver.parameters.log_search_progress = True\n\n    status = solver.solve(model)\n    if status == cp_model.FEASIBLE or status == cp_model.OPTIMAL:\n        print_solution(solver, visited_nodes, used_arcs, num_nodes, num_vehicles)\n```\n\n----------------------------------------\n\nTITLE: Solving Integer Programming with OR-Tools (Python)\nDESCRIPTION: This Python code demonstrates solving an Integer Programming problem using the OR-Tools library. It creates variables with integer constraints, defines linear constraints, sets up an objective function for maximization, and then solves the problem using the SCIP solver. Finally, it prints the solution and some advanced usage statistics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/integer_programming_example.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.linear_solver import pywraplp\n\n\ndef IntegerProgrammingExample():\n    \\\"\\\"\\\"Integer programming sample.\\\"\\\"\\\" # Corrected docstring\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n    if not solver:\n        return\n\n    # x, y, and z are non-negative integer variables.\n    x = solver.IntVar(0.0, solver.infinity(), \"x\")\n    y = solver.IntVar(0.0, solver.infinity(), \"y\")\n    z = solver.IntVar(0.0, solver.infinity(), \"z\")\n\n    print(\"Number of variables =\", solver.NumVariables())\n\n    # 2*x + 7*y + 3*z <= 50\n    constraint0 = solver.Constraint(-solver.infinity(), 50)\n    constraint0.SetCoefficient(x, 2)\n    constraint0.SetCoefficient(y, 7)\n    constraint0.SetCoefficient(z, 3)\n\n    # 3*x - 5*y + 7*z <= 45\n    constraint1 = solver.Constraint(-solver.infinity(), 45)\n    constraint1.SetCoefficient(x, 3)\n    constraint1.SetCoefficient(y, -5)\n    constraint1.SetCoefficient(z, 7)\n\n    # 5*x + 2*y - 6*z <= 37\n    constraint2 = solver.Constraint(-solver.infinity(), 37)\n    constraint2.SetCoefficient(x, 5)\n    constraint2.SetCoefficient(y, 2)\n    constraint2.SetCoefficient(z, -6)\n\n    print(\"Number of constraints =\", solver.NumConstraints())\n\n    # Maximize 2*x + 2*y + 3*z\n    objective = solver.Objective()\n    objective.SetCoefficient(x, 2)\n    objective.SetCoefficient(y, 2)\n    objective.SetCoefficient(z, 3)\n    objective.SetMaximization()\n\n    # Solve the problem.\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    # Print the solution.\n    if status == pywraplp.Solver.OPTIMAL:\n        print(\"Solution:\")\n        print(f\"Objective value = {solver.Objective().Value()}\")\n        # Print the value of each variable in the solution.\n        for variable in [x, y, z]:\n            print(f\"{variable.name()} = {variable.solution_value()}\")\n    else:\n        print(\"The problem does not have an optimal solution.\")\n\n    print(\"\\nAdvanced usage:\")\n    print(f\"Problem solved in {solver.wall_time():d} milliseconds\")\n    print(f\"Problem solved in {solver.iterations():d} iterations\")\n\n\nIntegerProgrammingExample()\n\"\n```\n\n----------------------------------------\n\nTITLE: Plotting Vehicle Routes on Matplotlib Map\nDESCRIPTION: This function visualizes the vehicle routes on a matplotlib axis. It plots the routes with different colors for each vehicle, adds annotations for start and end points, and uses arrows to show the direction of travel.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef plot_vehicle_routes(veh_route, ax1, customers, vehicles):\n    \"\"\"\n    Plot the vehicle routes on matplotlib axis ax1.\n\n    Args: veh_route (dict): a dictionary of routes keyed by vehicle idx.  ax1\n    (matplotlib.axes._subplots.AxesSubplot): Matplotlib axes  customers\n    (Customers): the customers instance.  vehicles (Vehicles): the vehicles\n    instance.\n  \"\"\"\n    veh_used = [v for v in veh_route if veh_route[v] is not None]\n\n    cmap = discrete_cmap(vehicles.number + 2, 'nipy_spectral')\n\n    for veh_number in veh_used:\n\n        lats, lons = zip(*[(c.lat, c.lon) for c in veh_route[veh_number]])\n        lats = np.array(lats)\n        lons = np.array(lons)\n        s_dep = customers.customers[vehicles.starts[veh_number]]\n        s_fin = customers.customers[vehicles.ends[veh_number]]\n        ax1.annotate(\n            'v({veh}) S @ {node}'.format(\n                veh=veh_number, node=vehicles.starts[veh_number]),\n            xy=(s_dep.lon, s_dep.lat),\n            xytext=(10, 10),\n            xycoords='data',\n            textcoords='offset points',\n            arrowprops=dict(\n                arrowstyle='->',\n                connectionstyle='angle3,angleA=90,angleB=0',\n                shrinkA=0.05),\n        )\n        ax1.annotate(\n            'v({veh}) F @ {node}'.format(\n                veh=veh_number, node=vehicles.ends[veh_number]),\n            xy=(s_fin.lon, s_fin.lat),\n            xytext=(10, -20),\n            xycoords='data',\n            textcoords='offset points',\n            arrowprops=dict(\n                arrowstyle='->',\n                connectionstyle='angle3,angleA=-90,angleB=0',\n                shrinkA=0.05),\n        )\n        ax1.plot(lons, lats, 'o', mfc=cmap(veh_number + 1))\n        ax1.quiver(\n            lons[:-1],\n            lats[:-1],\n            lons[1:] - lons[:-1],\n            lats[1:] - lats[:-1],\n            scale_units='xy',\n            angles='xy',\n            scale=1,\n            color=cmap(veh_number + 1))\n```\n\n----------------------------------------\n\nTITLE: Computing Minimum Delays Between Task Nodes in RCPSP\nDESCRIPTION: This function computes the minimum delays between pairs of tasks by solving subproblems. It handles time limits, tracks problem statistics, and returns delay information along with a complete problem assignment if available.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef compute_delays_between_nodes(\n    problem: rcpsp_pb2.RcpspProblem,\n    task_intervals: list[tuple[int, int, list[int]]],\n) -> tuple[\n    dict[tuple[int, int], tuple[int, int]],\n    Optional[rcpsp_pb2.RcpspAssignment],\n    bool,\n]:\n    \"\"\"Computes the min delays between all pairs of tasks in 'task_intervals'.\n\n    Args:\n      problem: The protobuf of the model.\n      task_intervals: The output of the AnalysePrecedenceGraph().\n\n    Returns:\n      a list of (task1, task2, min_delay_between_task1_and_task2)\n    \"\"\"\n    print(\"Computing the minimum delay between pairs of intervals\")\n    delays = {}\n    if (\n        problem.is_resource_investment\n        or problem.is_consumer_producer\n        or problem.is_rcpsp_max\n        or _DELAY_TIME_LIMIT.value <= 0.0\n    ):\n        return delays, None, False\n\n    time_limit = _DELAY_TIME_LIMIT.value\n    complete_problem_assignment = None\n    num_optimal_delays = 0\n    num_delays_not_found = 0\n    optimal_found = True\n    for start_task, end_task, active_tasks in task_intervals:\n        if time_limit <= 0:\n            optimal_found = False\n            print(f\"  - #timeout ({_DELAY_TIME_LIMIT.value}s) reached\", flush=True)\n            break\n\n        start_time = time.time()\n        min_delay, feasible_delay, assignment = solve_rcpsp(\n            problem,\n            \"\",\n            f\"num_search_workers:16,max_time_in_seconds:{time_limit}\",\n            set(active_tasks),\n            start_task,\n            end_task,\n            [],\n            delays,\n        )\n        time_limit -= time.time() - start_time\n\n        if min_delay != -1:\n            delays[(start_task, end_task)] = min_delay, feasible_delay\n            if start_task == 0 and end_task == len(problem.tasks) - 1:\n                complete_problem_assignment = assignment\n            if min_delay == feasible_delay:\n                num_optimal_delays += 1\n            else:\n                optimal_found = False\n        else:\n            num_delays_not_found += 1\n            optimal_found = False\n\n    print(f\"  - #optimal delays = {num_optimal_delays}\", flush=True)\n    if num_delays_not_found:\n        print(f\"  - #not computed delays = {num_delays_not_found}\", flush=True)\n\n    return delays, complete_problem_assignment, optimal_found\n```\n\n----------------------------------------\n\nTITLE: Solution Printer Implementation for Vehicle Routing\nDESCRIPTION: Function to print the routing solution including objective value, dropped nodes, route details, total distance, and collected values. Handles formatting and calculation of route metrics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f'Objective: {assignment.ObjectiveValue()}')\n   # Display dropped nodes.\n    dropped_nodes = 'Dropped nodes:'\n    for index in range(routing.Size()):\n        if routing.IsStart(index) or routing.IsEnd(index):\n            continue\n        if assignment.Value(routing.NextVar(index)) == index:\n            node = manager.IndexToNode(index)\n            dropped_nodes += f' {node}({VISIT_VALUES[node]})'\n    print(dropped_nodes)\n    # Display routes\n    index = routing.Start(0)\n    plan_output = 'Route for vehicle 0:\\n'\n    route_distance = 0\n    value_collected = 0\n    while not routing.IsEnd(index):\n        node = manager.IndexToNode(index)\n        value_collected += VISIT_VALUES[node]\n        plan_output += f' {node} ->'\n        previous_index = index\n        index = assignment.Value(routing.NextVar(index))\n        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)\n\n    plan_output += f' {manager.IndexToNode(index)}\\n'\n    plan_output += f'Distance of the route: {route_distance}m\\n'\n    plan_output += f'Value collected: {value_collected}/{sum(VISIT_VALUES)}\\n'\n    print(plan_output)\n```\n\n----------------------------------------\n\nTITLE: Creating Variables and Constraints for Set Covering Problem\nDESCRIPTION: This snippet defines the decision variables for hiring workers and the total cost, and sets up the constraints to ensure all tasks are covered while minimizing the total cost.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/covering_opl.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n  Hire = [solver.IntVar(0, 1, \"Hire[%i]\" % w) for w in Workers]\n  total_cost = solver.IntVar(0, nb_workers * sum(Cost), \"total_cost\")\n\n  solver.Add(total_cost == solver.ScalProd(Hire, Cost))\n\n  for j in Tasks:\n    # Sum the cost for hiring the qualified workers\n    # (also, make 0-base)\n    b = solver.Sum([Hire[c - 1] for c in Qualified[j]])\n    solver.Add(b >= 1)\n\n  # objective: Minimize total cost\n  objective = solver.Minimize(total_cost, 1)\n```\n\n----------------------------------------\n\nTITLE: Searching for All Solutions Using CP-SAT Solver in Python\nDESCRIPTION: This function demonstrates how to set up a simple constraint satisfaction problem, create a solver, and find all solutions. It creates variables, adds constraints, and uses the custom solution printer to display results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/search_for_all_solutions_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef search_for_all_solutions_sample_sat():\n    \"\"\"Showcases calling the solver to search for all solutions.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Create the constraints.\n    model.add(x != y)\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArraySolutionPrinter([x, y, z])\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    # Solve.\n    status = solver.solve(model, solution_printer)\n\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n\n\nsearch_for_all_solutions_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Solving Vehicle Routing Problem with Initial Routes Using OR-Tools\nDESCRIPTION: Complete implementation for solving a VRP with predefined initial routes. The code creates a distance matrix, defines initial routes for vehicles, sets up the routing model with constraints, and compares the initial solution with the optimized solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_initial_routes.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"initial_routes\"] = [\n        # fmt: off\n      [8, 16, 14, 13, 12, 11],\n      [3, 4, 9, 10],\n      [15, 1],\n      [7, 5, 2, 6],\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\n\n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Close model with the custom search parameters.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(5)\n    # When an initial solution is given for search, the model will be closed with\n    # the default search parameters unless it is explicitly closed with the custom\n    # search parameters.\n    routing.CloseModelWithParameters(search_parameters)\n\n    # Get initial solution from routes after closing the model.\n    initial_solution = routing.ReadAssignmentFromRoutes(data[\"initial_routes\"], True)\n    print(\"Initial solution:\")\n    print_solution(data, manager, routing, initial_solution)\n\n    # Solve the problem.\n    solution = routing.SolveFromAssignmentWithParameters(\n        initial_solution, search_parameters\n    )\n\n    # Print solution on console.\n    if solution:\n        print(\"Solution after search:\")\n        print_solution(data, manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Langford's Number Problem Solver\nDESCRIPTION: Defines the main function to solve Langford's number problem using Google CP Solver. It sets up the constraint satisfaction problem, defines variables and constraints, and searches for solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/langford.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(k=8, num_sol=0):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Langford\")\n\n  #\n  # data\n  #\n  print(\"k:\", k)\n  p = list(range(2 * k))\n\n  #\n  # declare variables\n  #\n  position = [solver.IntVar(0, 2 * k - 1, \"position[%i]\" % i) for i in p]\n  solution = [solver.IntVar(1, k, \"position[%i]\" % i) for i in p]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(position))\n\n  for i in range(1, k + 1):\n    solver.Add(position[i + k - 1] == position[i - 1] + i + 1)\n    solver.Add(solver.Element(solution, position[i - 1]) == i)\n    solver.Add(solver.Element(solution, position[k + i - 1]) == i)\n\n  # symmetry breaking\n  solver.Add(solution[0] < solution[2 * k - 1])\n\n  #\n  # search and result\n  #\n  db = solver.Phase(position, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"solution:\", \",\".join([str(solution[i].Value()) for i in p]))\n    num_solutions += 1\n    if num_sol > 0 and num_solutions >= num_sol:\n      break\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nk = 8\nnum_sol = 0\nif len(sys.argv) > 1:\n  k = int(sys.argv[1])\nif len(sys.argv) > 2:\n  num_sol = int(sys.argv[2])\n\nmain(k, num_sol)\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Covering Deployment Problem with OR-Tools\nDESCRIPTION: Defines and solves the Set Covering Deployment Problem using Google OR-Tools' constraint programming solver. It includes data setup, variable declaration, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering_deployment.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set covering deployment\")\n\n  #\n  # data\n  #\n\n  countries = [\n      \"Alexandria\", \"Asia Minor\", \"Britain\", \"Byzantium\", \"Gaul\", \"Iberia\",\n      \"Rome\", \"Tunis\"\n  ]\n  n = len(countries)\n\n  # the incidence matrix (neighbours)\n  mat = [[0, 1, 0, 1, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0],\n         [0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1],\n         [1, 0, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0]]\n\n  #\n  # declare variables\n  #\n\n  # First army\n  X = [solver.IntVar(0, 1, \"X[%i]\" % i) for i in range(n)]\n\n  # Second (reserv) army\n  Y = [solver.IntVar(0, 1, \"Y[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n\n  # total number of armies\n  num_armies = solver.Sum([X[i] + Y[i] for i in range(n)])\n\n  #\n  #  Constraint 1: There is always an army in a city\n  #                (+ maybe a backup)\n  #                Or rather: Is there a backup, there\n  #                must be an an army\n  #\n  [solver.Add(X[i] >= Y[i]) for i in range(n)]\n\n  #\n  # Constraint 2: There should always be an backup army near every city\n  #\n  for i in range(n):\n    neighbors = solver.Sum([Y[j] for j in range(n) if mat[i][j] == 1])\n    solver.Add(X[i] + neighbors >= 1)\n\n  objective = solver.Minimize(num_armies, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(X)\n  solution.Add(Y)\n  solution.Add(num_armies)\n  solution.AddObjective(num_armies)\n\n  collector = solver.LastSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase(X + Y, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT),\n      [collector, objective])\n\n  print(\"num_armies:\", collector.ObjectiveValue(0))\n  print(\"X:\", [collector.Value(0, X[i]) for i in range(n)])\n  print(\"Y:\", [collector.Value(0, Y[i]) for i in range(n)])\n\n  for i in range(n):\n    if collector.Value(0, X[i]) == 1:\n      print(\"army:\", countries[i], end=\" \")\n    if collector.Value(0, Y[i]) == 1:\n      print(\"reserv army:\", countries[i], \" \")\n  print()\n\n  print()\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools CP-SAT Solver in Python\nDESCRIPTION: Imports the necessary module from OR-Tools to use the CP-SAT solver for constraint programming.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/schedule_requests_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n```\n\n----------------------------------------\n\nTITLE: Implementing Break Constraints and Solver Configuration with Google OR-Tools in Python\nDESCRIPTION: This snippet configures the constraints related to match schedule breaks and sets up the CP-SAT Solver. It calculates the optimal number of breaks allowed and applies it within the model, then configures the solver’s parameters for execution, including time limits and output settings.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\noptimal_value = matchups * (num_teams - 2)\nif not matchups_exact:\n    if num_matchdays % 2:\n        optimal_value = min(num_matchdays + 1, optimal_value)\n    else:\n        optimal_value = min(num_matchdays, optimal_value)\n\nmodel.Add(sum(breaks) >= optimal_value)\nmodel.Minimize(sum(breaks))\nsolver = cp_model.CpSolver()\nsolver.parameters.max_time_in_seconds = time_limit\nsolver.parameters.log_search_progress = debug\nsolver.parameters.num_search_workers = num_cpus\nstatus = solver.Solve(model)\n```\n\n----------------------------------------\n\nTITLE: Main Function for Task Scheduling Problem in Python\nDESCRIPTION: This snippet defines the main function that orchestrates the solving of the task scheduling problem. It reads the problem input, prints statistics, generates a greedy solution, and then solves the problem using either a boolean or scheduling model based on user input.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n\n    problem = read_problem(_INPUT.value)\n    print_stats(problem)\n    greedy_solution = solve_problem_greedily(problem)\n\n    if _MODEL.value == \"boolean\":\n        solve_problem_with_boolean_model(problem, greedy_solution)\n    elif _MODEL.value == \"scheduling\":\n        solve_problem_with_scheduling_model(problem, greedy_solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving XKCD Knapsack Problem with Google CP Solver\nDESCRIPTION: This code implements the solution to the XKCD knapsack problem. It defines the problem data, creates variables and constraints, and uses the CP solver to find all possible solutions that exactly match the target price.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/xkcd.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"xkcd knapsack\")\n\n  #\n  # data\n  #\n  num_prices = 6\n  # for price and total: multiplied by 100 to be able to use integers\n  price = [215, 275, 335, 355, 420, 580]\n  total = 1505\n\n  products = [\n      \"mixed fruit\", \"french fries\", \"side salad\", \"host wings\",\n      \"mozzarella sticks\", \"samples place\"\n  ]\n\n  # declare variables\n\n  # how many items of each dish\n  x = [solver.IntVar(0, 10, \"x%i\" % i) for i in range(num_prices)]\n  z = solver.IntVar(0, 1505, \"z\")\n\n  #\n  # constraints\n  #\n  solver.Add(z == solver.Sum([x[i] * price[i] for i in range(num_prices)]))\n  solver.Add(z == total)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[i] for i in range(num_prices)])\n  solution.Add(z)\n\n  collector = solver.AllSolutionCollector(solution)\n  # collector = solver.FirstSolutionCollector(solution)\n  # search_log = solver.SearchLog(100, x[0])\n  solver.Solve(\n      solver.Phase([x[i] for i in range(num_prices)], solver.INT_VAR_SIMPLE,\n                   solver.ASSIGN_MIN_VALUE), [collector])\n\n  num_solutions = collector.SolutionCount()\n  print(\"num_solutions: \", num_solutions)\n  if num_solutions > 0:\n    for s in range(num_solutions):\n      print(\"z:\", collector.Value(s, z) / 100.0)\n      xval = [collector.Value(s, x[i]) for i in range(num_prices)]\n      print(\"x:\", xval)\n      for i in range(num_prices):\n        if xval[i] > 0:\n          print(xval[i], \"of\", products[i], \":\", price[i] / 100.0)\n      print()\n\n    print()\n    print(\"num_solutions:\", num_solutions)\n    print(\"failures:\", solver.Failures())\n    print(\"branches:\", solver.Branches())\n    print(\"WallTime:\", solver.WallTime())\n\n  else:\n    print(\"No solutions found\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem with OR-Tools in Python\nDESCRIPTION: Defines a main function that sets up and solves an assignment problem using linear optimization. It creates a SCIP-based solver, defines cost data for workers and tasks, imposes constraints, and formulates an objective to minimize assignment costs. It handles logic for group constraints and outputs the results when a feasible solution is found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_groups_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"\\nfrom ortools.linear_solver import pywraplp\\n\\n\\ndef main():\\n    # Data\\n    costs = [\\n        [90, 76, 75, 70, 50, 74],\\n        [35, 85, 55, 65, 48, 101],\\n        [125, 95, 90, 105, 59, 120],\\n        [45, 110, 95, 115, 104, 83],\\n        [60, 105, 80, 75, 59, 62],\\n        [45, 65, 110, 95, 47, 31],\\n        [38, 51, 107, 41, 69, 99],\\n        [47, 85, 57, 71, 92, 77],\\n        [39, 63, 97, 49, 118, 56],\\n        [47, 101, 71, 60, 88, 109],\\n        [17, 39, 103, 64, 61, 92],\\n        [101, 45, 83, 59, 92, 27],\\n    ]\\n    num_workers = len(costs)\\n    num_tasks = len(costs[0])\\n\\n    # Allowed groups of workers:\\n    group1 = [  # Subgroups of workers 0 - 3\\n        [2, 3],\\n        [1, 3],\\n        [1, 2],\\n        [0, 1],\\n        [0, 2],\\n    ]\\n\\n    group2 = [  # Subgroups of workers 4 - 7\\n        [6, 7],\\n        [5, 7],\\n        [5, 6],\\n        [4, 5],\\n        [4, 7],\\n    ]\\n\\n    group3 = [  # Subgroups of workers 8 - 11\\n        [10, 11],\\n        [9, 11],\\n        [9, 10],\\n        [8, 10],\\n        [8, 11],\\n    ]\\n\\n    # Solver.\\n    # Create the mip solver with the SCIP backend.\\n    solver = pywraplp.Solver.CreateSolver(\\\"SCIP\\\")\\n    if not solver:\\n        return\\n\\n    # Variables\\n    # x[worker, task] is an array of 0-1 variables, which will be 1\\n    # if the worker is assigned to the task.\\n    x = {}\\n    for worker in range(num_workers):\\n        for task in range(num_tasks):\\n            x[worker, task] = solver.BoolVar(f\\\"x[{worker},{task}]\\\")\\n\\n    # Constraints\\n    # The total size of the tasks each worker takes on is at most total_size_max.\\n    for worker in range(num_workers):\\n        solver.Add(solver.Sum([x[worker, task] for task in range(num_tasks)]) <= 1)\\n\\n    # Each task is assigned to exactly one worker.\\n    for task in range(num_tasks):\\n        solver.Add(solver.Sum([x[worker, task] for worker in range(num_workers)]) == 1)\\n\\n    # Create variables for each worker, indicating whether they work on some task.\\n    work = {}\\n    for worker in range(num_workers):\\n        work[worker] = solver.BoolVar(f\\\"work[{worker}]\\\")\\n\\n    for worker in range(num_workers):\\n        solver.Add(\\n            work[worker] == solver.Sum([x[worker, task] for task in range(num_tasks)])\\n        )\\n\\n    # Group1\\n    constraint_g1 = solver.Constraint(1, 1)\\n    for index, _ in enumerate(group1):\\n        # a*b can be transformed into 0 <= a + b - 2*p <= 1 with p in [0,1]\\n        # p i...\"\n```\n\n----------------------------------------\n\nTITLE: Game Theory Solver Implementation\nDESCRIPTION: Main implementation of the game theory solver using OR-Tools. Solves a 3x3 zero-sum game by calculating optimal strategies for both row and column players using linear programming. The code handles matrix game calculations and outputs the optimal strategies and game values for both players.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/game_theory_taha.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  # data\n  rows = 3\n  cols = 3\n\n  game = [[3.0, -1.0, -3.0], [-2.0, 4.0, -1.0], [-5.0, -6.0, 2.0]]\n\n  #\n  # declare variables\n  #\n\n  #\n  # row player\n  #\n  x1 = [solver.NumVar(0, 1, 'x1[%i]' % i) for i in range(rows)]\n\n  v = solver.NumVar(-2, 2, 'v')\n\n  for i in range(rows):\n    solver.Add(v - solver.Sum([x1[j] * game[j][i] for j in range(cols)]) <= 0)\n\n  solver.Add(solver.Sum(x1) == 1)\n\n  objective = solver.Maximize(v)\n\n  solver.Solve()\n\n  print()\n  print('row player:')\n  print('v = ', solver.Objective().Value())\n  print('Strategies: ')\n  for i in range(rows):\n    print(x1[i].SolutionValue(), end=' ')\n  print()\n  print()\n\n  #\n  # For column player:\n  #\n  x2 = [solver.NumVar(0, 1, 'x2[%i]' % i) for i in range(cols)]\n\n  v2 = solver.NumVar(-2, 2, 'v2')\n\n  for i in range(cols):\n    solver.Add(v2 - solver.Sum([x2[j] * game[i][j] for j in range(rows)]) >= 0)\n\n  solver.Add(solver.Sum(x2) == 1)\n\n  objective = solver.Minimize(v2)\n\n  solver.Solve()\n\n  print()\n  print('column player:')\n  print('v2 = ', solver.Objective().Value())\n  print('Strategies: ')\n  for i in range(rows):\n    print(x2[i].SolutionValue(), end=' ')\n  print()\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n  print('iterations:', solver.Iterations())\n  print()\n\n\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Defining Task Allocation Problem and Creating CP Model in Python\nDESCRIPTION: This snippet defines the task allocation problem parameters, creates a CP model, and sets up decision variables. It includes the creation of boolean variables for task assignments and slot usage, as well as an integer variable for counting used slots.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/task_allocation_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nntasks = len(available)\nnslots = len(available[0])\n\n# sets\nall_tasks = range(ntasks)\nall_slots = range(nslots)\n\n# max tasks per time slot\ncapacity = 3\n\n# Model\nmodel = cp_model.CpModel()\nassign = {}\nfor task in all_tasks:\n    for slot in all_slots:\n        assign[(task, slot)] = model.new_bool_var(f\"x[{task}][{slot}]\")\ncount = model.new_int_var(0, nslots, \"count\")\nslot_used = [model.new_bool_var(f\"slot_used[{s}]\") for s in all_slots]\n```\n\n----------------------------------------\n\nTITLE: Clustering Implementation using CP-SAT Solver\nDESCRIPTION: Main clustering function that implements graph partitioning using CP-SAT solver. Creates boolean variables for node relationships, adds constraints for group size and transitivity, and minimizes the total distance-based cost.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef clustering_sat() -> None:\n    \"\"\"Entry point of the program.\"\"\"\n    num_nodes = len(distance_matrix)\n    print(\"Num nodes =\", num_nodes)\n\n    # Number of groups to split the nodes, must divide num_nodes.\n    num_groups = 4\n    group_size = num_nodes // num_groups\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Variables.\n    neighbors = {}\n    obj_vars = []\n    obj_coeffs = []\n    for n1 in range(num_nodes - 1):\n        for n2 in range(n1 + 1, num_nodes):\n            same = model.new_bool_var(\"neighbors_%i_%i\" % (n1, n2))\n            neighbors[n1, n2] = same\n            obj_vars.append(same)\n            obj_coeffs.append(distance_matrix[n1][n2] + distance_matrix[n2][n1])\n\n    # Number of neighborss:\n    for n in range(num_nodes):\n        model.add(\n            sum(neighbors[m, n] for m in range(n))\n            + sum(neighbors[n, m] for m in range(n + 1, num_nodes))\n            == group_size - 1\n        )\n\n    # Enforce transivity on all triplets.\n    for n1 in range(num_nodes - 2):\n        for n2 in range(n1 + 1, num_nodes - 1):\n            for n3 in range(n2 + 1, num_nodes):\n                model.add(\n                    neighbors[n1, n3] + neighbors[n2, n3] + neighbors[n1, n2] != 2\n                )\n\n    # Redundant constraints on total sum of neighborss.\n    model.add(sum(obj_vars) == num_groups * group_size * (group_size - 1) // 2)\n\n    # Minimize weighted sum of arcs.\n    model.minimize(sum(obj_vars[i] * obj_coeffs[i] for i in range(len(obj_vars))))\n\n    # Solve and print out the solution.\n    solver = cp_model.CpSolver()\n    solver.parameters.log_search_progress = True\n    solver.parameters.num_search_workers = 8\n\n    status = solver.solve(model)\n    print(solver.response_stats())\n```\n\n----------------------------------------\n\nTITLE: Implementing NoOverlap Constraint in OR-Tools Python\nDESCRIPTION: This snippet illustrates how to define a NoOverlap constraint for scheduling tasks with specified durations in Python using the OR-Tools library. It creates tasks, adds the NoOverlap constraint, and solves the model to find an optimal schedule. Dependencies include the OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/no_overlap_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef no_overlap_sample_sat():\n    \"\"\"No overlap sample with fixed activities.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 21  # 3 weeks.\n\n    # Task 0, duration 2.\n    start_0 = model.new_int_var(0, horizon, \"start_0\")\n    duration_0 = 2  # Python cp/sat code accepts integer variables or constants.\n    end_0 = model.new_int_var(0, horizon, \"end_0\")\n    task_0 = model.new_interval_var(start_0, duration_0, end_0, \"task_0\")\n    # Task 1, duration 4.\n    start_1 = model.new_int_var(0, horizon, \"start_1\")\n    duration_1 = 4  # Python cp/sat code accepts integer variables or constants.\n    end_1 = model.new_int_var(0, horizon, \"end_1\")\n    task_1 = model.new_interval_var(start_1, duration_1, end_1, \"task_1\")\n\n    # Task 2, duration 3.\n    start_2 = model.new_int_var(0, horizon, \"start_2\")\n    duration_2 = 3  # Python cp/sat code accepts integer variables or constants.\n    end_2 = model.new_int_var(0, horizon, \"end_2\")\n    task_2 = model.new_interval_var(start_2, duration_2, end_2, \"task_2\")\n\n    # Weekends.\n    weekend_0 = model.new_interval_var(5, 2, 7, \"weekend_0\")\n    weekend_1 = model.new_interval_var(12, 2, 14, \"weekend_1\")\n    weekend_2 = model.new_interval_var(19, 2, 21, \"weekend_2\")\n\n    # No Overlap constraint.\n    model.add_no_overlap([task_0, task_1, task_2, weekend_0, weekend_1, weekend_2])\n\n    # Makespan objective.\n    obj = model.new_int_var(0, horizon, \"makespan\")\n    model.add_max_equality(obj, [end_0, end_1, end_2])\n    model.minimize(obj)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Print out makespan and the start times for all tasks.\n        print(f\"Optimal Schedule Length: {solver.objective_value}\")\n        print(f\"Task 0 starts at {solver.value(start_0)}\")\n        print(f\"Task 1 starts at {solver.value(start_1)}\")\n        print(f\"Task 2 starts at {solver.value(start_2)}\")\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n\nno_overlap_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Mr Smith Problem Solver using OR-Tools CP Solver\nDESCRIPTION: This code defines and solves the Mr Smith family visit problem using Google's OR-Tools CP Solver. It creates boolean variables for each family member, sets up constraints based on the problem description, and searches for a solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/mr_smith.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Mr Smith problem')\n\n  #\n  # data\n  #\n  n = 5\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 1, 'x[%i]' % i) for i in range(n)]\n  Mr_Smith, Mrs_Smith, Matt, John, Tim = x\n\n  #\n  # constraints\n  #\n\n  #\n  # I've kept the MiniZinc constraints for clarity\n  # and debugging.\n  #\n\n  # If Mr Smith comes then his wife will come too.\n  # (Mr_Smith -> Mrs_Smith)\n  solver.Add(Mr_Smith - Mrs_Smith <= 0)\n\n  # At least one of their two sons Matt and John will come.\n  # (Matt \\/ John)\n  solver.Add(Matt + John >= 1)\n\n  # Either Mrs Smith or Tim will come but not both.\n  # bool2int(Mrs_Smith) + bool2int(Tim) = 1 /\\\n  # (Mrs_Smith xor Tim)\n  solver.Add(Mrs_Smith + Tim == 1)\n\n  # Either Tim and John will come or neither will come.\n  # (Tim = John)\n  solver.Add(Tim == John)\n\n  # If Matt comes /\\ then John and his father will also come.\n  # (Matt -> (John /\\ Mr_Smith))\n  solver.Add(Matt - (John * Mr_Smith) <= 0)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('x:', [x[i].Value() for i in range(n)])\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Ranking Tasks with Circuit Constraint in Python\nDESCRIPTION: This function ranks tasks in a scheduling problem using a circuit constraint from the OR-Tools CP-SAT solver. It assumes that all tasks have non-overlapping start times and involves the creation of a dense graph to manage task rankings and dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/ranking_circuit_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List, Sequence\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef rank_tasks_with_circuit(\n    model: cp_model.CpModel,\n    starts: Sequence[cp_model.IntVar],\n    durations: Sequence[int],\n    presences: Sequence[cp_model.IntVar],\n    ranks: Sequence[cp_model.IntVar],\n) -> None:\n    \"\"\"This method uses a circuit constraint to rank tasks.\n\n    This method assumes that all starts are disjoint, meaning that all tasks have\n    a strictly positive duration, and they appear in the same NoOverlap\n    constraint.\n\n    To implement this ranking, we will create a dense graph with num_tasks + 1\n    nodes.\n    The extra node (with id 0) will be used to decide which task is first with\n    its only outgoing arc, and which task is last with its only incoming arc.\n    Each task i will be associated with id i + 1, and an arc between i + 1 and j +\n    1 indicates that j is the immediate successor of i.\n\n    The circuit constraint ensures there is at most 1 hamiltonian cycle of\n    length > 1. If no such path exists, then no tasks are active.\n    We also need to enforce that any hamiltonian cycle of size > 1 must contain\n    the node 0. And thus, there is a self loop on node 0 iff the circuit is empty.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      durations: the durations of all tasks.\n      presences: The array of presence variables of all tasks.\n      ranks: The array of rank variables of all tasks.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    arcs: List[cp_model.ArcT] = []\n    for i in all_tasks:\n        # if node i is first.\n        start_lit = model.new_bool_var(f\"start_{i}\")\n        arcs.append((0, i + 1, start_lit))\n        model.add(ranks[i] == 0).only_enforce_if(start_lit)\n\n        # As there are no other constraints on the problem, we can add this\n        # redundant constraint.\n        model.add(starts[i] == 0).only_enforce_if(start_lit)\n\n        # if node i is last.\n        end_lit = model.new_bool_var(f\"end_{i}\")\n        arcs.append((i + 1, 0, end_lit))\n\n        for j in all_tasks:\n            if i == j:\n                arcs.append((i + 1, i + 1, ~presences[i]))\n                model.add(ranks[i] == -1).only_enforce_if(~presences[i])\n            else:\n                literal = model.new_bool_var(f\"arc_{i}_to_{j}\")\n                arcs.append((i + 1, j + 1, literal))\n                model.add(ranks[j] == ranks[i] + 1).only_enforce_if(literal)\n\n                # To perform the transitive reduction from precedences to successors,\n                # we need to tie the starts of the tasks with 'literal'.\n                # In a pure problem, the following inequality could be an equality.\n                # It is not true in general.\n                #\n                # Note that we could use this literal to penalize the transition, add an\n                # extra delay to the precedence.\n                model.add(starts[j] >= starts[i] + durations[i]).only_enforce_if(\n                    literal\n                )\n\n    # Manage the empty circuit\n    empty = model.new_bool_var(\"empty\")\n    arcs.append((0, 0, empty))\n\n    for i in all_tasks:\n        model.add_implication(empty, ~presences[i])\n\n    # Add the circuit constraint.\n    model.add_circuit(arcs)\n```\n\n----------------------------------------\n\nTITLE: Solving Volsay Problem using OR-Tools Linear Solver in Python\nDESCRIPTION: This code implements the Volsay problem using Google OR-Tools' linear programming solver. It defines variables for Gas and Chloride production, sets constraints, and maximizes the objective function. The solution is then printed, showing the optimal values and reduced costs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/volsay.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(unused_argv):\n\n  # Create the solver.\n\n  # using GLPK\n  #solver = pywraplp.Solver('CoinsGridGLPK',\n  #                         pywraplp.Solver.GLPK_LINEAR_PROGRAMMING)\n\n  # Using CLP\n  solver = pywraplp.Solver.CreateSolver('CLP')\n  if not solver:\n    return\n\n  # data\n\n  # declare variables\n  Gas = solver.NumVar(0, 100000, 'Gas')\n  Chloride = solver.NumVar(0, 100000, 'Cloride')\n\n  #\n  # constraints\n  #\n  solver.Add(Gas + Chloride <= 50)\n  solver.Add(3 * Gas + 4 * Chloride <= 180)\n\n  # objective\n  objective = solver.Maximize(40 * Gas + 50 * Chloride)\n\n  print('NumConstraints:', solver.NumConstraints())\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n  print('objective = ', solver.Objective().Value())\n  print('Gas = ', Gas.SolutionValue(), 'ReducedCost =', Gas.ReducedCost())\n  print('Chloride:', Chloride.SolutionValue(), 'ReducedCost =',\n        Chloride.ReducedCost())\n\n\nmain('Volsay')\n```\n\n----------------------------------------\n\nTITLE: Building Scheduling Problem Data Frames\nDESCRIPTION: Function to create pandas DataFrames representing tests, operators, and power supplies with their respective characteristics and constraints\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/test_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef build_data() -> tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\n    \"\"\"Build the data frame.\"\"\"\n    tests_str = \"\"\"\n  Name Operator    TestTime    AveragePower\n   T1     O1           300            200\n   T2     O1           150             40\n   T3     O2           100             65\n   T4     O2           250            150\n   T5     O3           210            140\n  \"\"\"\n\n    operators_str = \"\"\"\n  Operator Supply\n      O1      S1\n      O2      S2\n      O3      S2\n  \"\"\"\n\n    supplies_str = \"\"\"\n  Supply  MaxAllowedPower\n   S1        230\n   S2        210\n  \"\"\"\n\n    tests_data = pd.read_table(io.StringIO(tests_str), sep=r\"\\s+\")\n    operators_data = pd.read_table(io.StringIO(operators_str), sep=r\"\\s+\")\n    supplies_data = pd.read_table(io.StringIO(supplies_str), sep=r\"\\s+\")\n\n    return (tests_data, operators_data, supplies_data)\n```\n\n----------------------------------------\n\nTITLE: Pandigital Number Solver Implementation\nDESCRIPTION: Main implementation of the pandigital number solver using OR-Tools constraint programming. Includes helper functions for number conversion and the main solving logic to find valid pandigital number combinations.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/pandigital_numbers.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\ndef toNum(solver, t, s, base):\n  tlen = len(t)\n  solver.Add(\n      s == solver.Sum([(base**(tlen - i - 1)) * t[i] for i in range(tlen)]))\n\ndef main(base=10, start=1, len1=1, len2=4):\n  solver = pywrapcp.Solver(\"Pandigital numbers\")\n  max_d = base - 1\n  x_len = max_d + 1 - start\n  max_num = base**4 - 1\n\n  num1 = solver.IntVar(0, max_num, \"num1\")\n  num2 = solver.IntVar(0, max_num, \"num2\")\n  res = solver.IntVar(0, max_num, \"res\")\n\n  x = [solver.IntVar(start, max_d, \"x[%i]\" % i) for i in range(x_len)]\n\n  solver.Add(solver.AllDifferent(x))\n\n  toNum(solver, [x[i] for i in range(len1)], num1, base)\n  toNum(solver, [x[i] for i in range(len1, len1 + len2)], num2, base)\n  toNum(solver, [x[i] for i in range(len1 + len2, x_len)], res, base)\n\n  solver.Add(num1 * num2 == res)\n  solver.Add(x[0] > 0)\n  solver.Add(x[len1] > 0)\n  solver.Add(x[len1 + len2] > 0)\n  solver.Add(num1 < num2)\n\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(num1)\n  solution.Add(num2)\n  solution.Add(res)\n\n  db = solver.Phase(x, solver.INT_VAR_SIMPLE, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print_solution([x[i].Value() for i in range(x_len)], len1, len2, x_len)\n    num_solutions += 1\n\n  solver.EndSearch()\n\ndef print_solution(x, len1, len2, x_len):\n  print(\"\".join([str(x[i]) for i in range(len1)]), \"*\", end=\" \")\n  print(\"\".join([str(x[i]) for i in range(len1, len1 + len2)]), \"=\", end=\" \")\n  print(\"\".join([str(x[i]) for i in range(len1 + len2, x_len)]))\n\nbase = 10\nstart = 1\nif len(sys.argv) > 1:\n  base = int(sys.argv[1])\nif len(sys.argv) > 2:\n  start = int(sys.argv[2])\n\nx_len = base - 1 + 1 - start\nfor len1 in range(1 + (x_len)):\n  for len2 in range(1 + (x_len)):\n    if x_len > len1 + len2:\n      main(base, start, len1, len2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing with Google OR-Tools in C#\nDESCRIPTION: A complete example showing how to solve a simple vehicle routing problem using Google OR-Tools. The program creates a routing model for a single vehicle visiting 5 locations, calculates distances between nodes, and finds the optimal route using the PathCheapestArc strategy.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/ROUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.ConstraintSolver;\n\n/// <summary>\n///   This is a sample using the routing library .Net wrapper.\n/// </summary>\npublic class SimpleRoutingProgram\n{\n    public static void Main(String[] args)\n    {\n        // Instantiate the data problem.\n        const int numLocation = 5;\n        const int numVehicles = 1;\n        const int depot = 0;\n\n        // Create Routing Index Manager\n        RoutingIndexManager manager = new RoutingIndexManager(numLocation, numVehicles, depot);\n\n        // Create Routing Model.\n        RoutingModel routing = new RoutingModel(manager);\n\n        // Create and register a transit callback.\n        int transitCallbackIndex = routing.RegisterTransitCallback((long fromIndex, long toIndex) =>\n                                                                   {\n                                                                       // Convert from routing variable Index to\n                                                                       // distance matrix NodeIndex.\n                                                                       var fromNode = manager.IndexToNode(fromIndex);\n                                                                       var toNode = manager.IndexToNode(toIndex);\n                                                                       return Math.Abs(toNode - fromNode);\n                                                                   });\n\n        // Define cost of each arc.\n        routing.SetArcCostEvaluatorOfAllVehicles(transitCallbackIndex);\n\n        // Setting first solution heuristic.\n        RoutingSearchParameters searchParameters =\n            operations_research_constraint_solver.DefaultRoutingSearchParameters();\n        searchParameters.FirstSolutionStrategy = FirstSolutionStrategy.Types.Value.PathCheapestArc;\n\n        // Solve the problem.\n        Assignment solution = routing.SolveWithParameters(searchParameters);\n\n        // Print solution on console.\n        Console.WriteLine(\"Objective: {0}\", solution.ObjectiveValue());\n        // Inspect solution.\n        long index = routing.Start(0);\n        Console.WriteLine(\"Route for Vehicle 0:\");\n        long route_distance = 0;\n        while (routing.IsEnd(index) == false)\n        {\n            Console.Write(\"{0} -> \", manager.IndexToNode((int)index));\n            long previousIndex = index;\n            index = solution.Value(routing.NextVar(index));\n            route_distance += routing.GetArcCostForVehicle(previousIndex, index, 0);\n        }\n        Console.WriteLine(\"{0}\", manager.IndexToNode(index));\n        Console.WriteLine(\"Distance of the route: {0}m\", route_distance);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nurse Scheduling Solver Implementation\nDESCRIPTION: Main implementation of the nurse scheduling problem using OR-Tools. The code creates a constraint programming model that assigns 4 nurses to 4 shifts over 7 days while handling various constraints like work days per week, shift continuity, and nurse distribution requirements.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nurses_cp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n  # Creates the solver.\n  solver = pywrapcp.Solver(\"schedule_shifts\")\n\n  num_nurses = 4\n  num_shifts = 4  # Nurse assigned to shift 0 means not working that day.\n  num_days = 7\n  # [START]\n  # Create shift variables.\n  shifts = {}\n\n  for j in range(num_nurses):\n    for i in range(num_days):\n      shifts[(j, i)] = solver.IntVar(0, num_shifts - 1,\n                                     \"shifts(%i,%i)\" % (j, i))\n  shifts_flat = [\n      shifts[(j, i)] for j in range(num_nurses) for i in range(num_days)\n  ]\n\n  # Create nurse variables.\n  nurses = {}\n\n  for j in range(num_shifts):\n    for i in range(num_days):\n      nurses[(j, i)] = solver.IntVar(0, num_nurses - 1,\n                                     \"shift%d day%d\" % (j, i))\n  # Set relationships between shifts and nurses.\n  for day in range(num_days):\n    nurses_for_day = [nurses[(j, day)] for j in range(num_shifts)]\n\n    for j in range(num_nurses):\n      s = shifts[(j, day)]\n      solver.Add(s.IndexOf(nurses_for_day) == j)\n  # Make assignments different on each day\n  for i in range(num_days):\n    solver.Add(solver.AllDifferent([shifts[(j, i)] for j in range(num_nurses)]))\n    solver.Add(solver.AllDifferent([nurses[(j, i)] for j in range(num_shifts)]))\n  # Each nurse works 5 or 6 days in a week.\n  for j in range(num_nurses):\n    solver.Add(solver.Sum([shifts[(j, i)] > 0 for i in range(num_days)]) >= 5)\n    solver.Add(solver.Sum([shifts[(j, i)] > 0 for i in range(num_days)]) <= 6)\n  # Create works_shift variables. works_shift[(i, j)] is True if nurse\n  # i works shift j at least once during the week.\n  works_shift = {}\n\n  for i in range(num_nurses):\n    for j in range(num_shifts):\n      works_shift[(i, j)] = solver.BoolVar(\"nurse%d shift%d\" % (i, j))\n\n  for i in range(num_nurses):\n    for j in range(num_shifts):\n      solver.Add(works_shift[(\n          i, j)] == solver.Max([shifts[(i, k)] == j for k in range(num_days)]))\n\n  # For each shift (other than 0), at most 2 nurses are assigned to that shift\n  # during the week.\n  for j in range(1, num_shifts):\n    solver.Add(\n        solver.Sum([works_shift[(i, j)] for i in range(num_nurses)]) <= 2)\n  # If s nurses works shifts 2 or 3 on, he must also work that shift the previous\n  # day or the following day.\n  solver.Add(\n      solver.Max(nurses[(2,\n                         0)] == nurses[(2,\n                                        1)], nurses[(2,\n                                                     1)] == nurses[(2,\n                                                                    2)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(2,\n                         1)] == nurses[(2,\n                                        2)], nurses[(2,\n                                                     2)] == nurses[(2,\n                                                                    3)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(2,\n                         2)] == nurses[(2,\n                                        3)], nurses[(2,\n                                                     3)] == nurses[(2,\n                                                                    4)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(2,\n                         3)] == nurses[(2,\n                                        4)], nurses[(2,\n                                                     4)] == nurses[(2,\n                                                                    5)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(2,\n                         4)] == nurses[(2,\n                                        5)], nurses[(2,\n                                                     5)] == nurses[(2,\n                                                                    6)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(2,\n                         5)] == nurses[(2,\n                                        6)], nurses[(2,\n                                                     6)] == nurses[(2,\n                                                                    0)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(2,\n                         6)] == nurses[(2,\n                                        0)], nurses[(2,\n                                                     0)] == nurses[(2,\n                                                                    1)]) == 1)\n\n  solver.Add(\n      solver.Max(nurses[(3,\n                         0)] == nurses[(3,\n                                        1)], nurses[(3,\n                                                     1)] == nurses[(3,\n                                                                    2)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(3,\n                         1)] == nurses[(3,\n                                        2)], nurses[(3,\n                                                     2)] == nurses[(3,\n                                                                    3)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(3,\n                         2)] == nurses[(3,\n                                        3)], nurses[(3,\n                                                     3)] == nurses[(3,\n                                                                    4)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(3,\n                         3)] == nurses[(3,\n                                        4)], nurses[(3,\n                                                     4)] == nurses[(3,\n                                                                    5)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(3,\n                         4)] == nurses[(3,\n                                        5)], nurses[(3,\n                                                     5)] == nurses[(3,\n                                                                    6)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(3,\n                         5)] == nurses[(3,\n                                        6)], nurses[(3,\n                                                     6)] == nurses[(3,\n                                                                    0)]) == 1)\n  solver.Add(\n      solver.Max(nurses[(3,\n                         6)] == nurses[(3,\n                                        0)], nurses[(3,\n                                                     0)] == nurses[(3,\n                                                                    1)]) == 1)\n  # Create the decision builder.\n  db = solver.Phase(shifts_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n  # Create the solution collector.\n  solution = solver.Assignment()\n  solution.Add(shifts_flat)\n  collector = solver.AllSolutionCollector(solution)\n\n  solver.Solve(db, [collector])\n  print(\"Solutions found:\", collector.SolutionCount())\n  print(\"Time:\", solver.WallTime(), \"ms\")\n  print()\n  # Display a few solutions picked at random.\n  a_few_solutions = [859, 2034, 5091, 7003]\n\n  for sol in a_few_solutions:\n    print(\"Solution number\", sol, \"\\n\")\n\n    for i in range(num_days):\n      print(\"Day\", i)\n      for j in range(num_nurses):\n        print(\"Nurse\", j, \"assigned to task\",\n              collector.Value(sol, shifts[(j, i)]))\n      print()\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Photo Problem Implementation using OR-Tools Constraint Solver\nDESCRIPTION: Main implementation of the photo alignment optimization problem using OR-Tools' constraint programming solver. The code sets up constraints for positioning people in a row while maximizing preference satisfaction between adjacent people. Includes problem setup, constraint definition, symmetry breaking, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/photo_problem.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(show_all_max=0):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Photo problem\")\n\n  #\n  # data\n  #\n  persons = [\"Betty\", \"Chris\", \"Donald\", \"Fred\", \"Gary\", \"Mary\", \"Paul\"]\n  n = len(persons)\n  preferences = [\n      # 0 1 2 3 4 5 6\n      # B C D F G M P\n      [0, 0, 0, 0, 1, 1, 0],  # Betty  0\n      [1, 0, 0, 0, 1, 0, 0],  # Chris  1\n      [0, 0, 0, 0, 0, 0, 0],  # Donald 2\n      [0, 0, 1, 0, 0, 1, 0],  # Fred   3\n      [0, 0, 0, 0, 0, 0, 0],  # Gary   4\n      [0, 0, 0, 0, 0, 0, 0],  # Mary   5\n      [0, 0, 1, 1, 0, 0, 0]  # Paul   6\n  ]\n\n  print(\"\"\"Preferences:\n     1. Betty wants to stand next to Gary and Mary.\n     2. Chris wants to stand next to Betty and Gary.\n     3. Fred wants to stand next to Mary and Donald.\n     4. Paul wants to stand next to Fred and Donald.\n    \"\"\")\n\n  #\n  # declare variables\n  #\n  positions = [solver.IntVar(0, n - 1, \"positions[%i]\" % i) for i in range(n)]\n\n  # successful preferences\n  z = solver.IntVar(0, n * n, \"z\")\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(positions))\n\n  # calculate all the successful preferences\n  b = [\n      solver.IsEqualCstVar(abs(positions[i] - positions[j]), 1)\n      for i in range(n)\n      for j in range(n)\n      if preferences[i][j] == 1\n  ]\n  solver.Add(z == solver.Sum(b))\n\n  #\n  # Symmetry breaking (from the Oz page):\n  #   Fred is somewhere left of Betty\n  solver.Add(positions[3] < positions[0])\n\n  # objective\n  objective = solver.Maximize(z, 1)\n  if show_all_max != 0:\n    print(\"Showing all maximum solutions (z == 6).\\n\")\n    solver.Add(z == 6)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(positions, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MAX_VALUE)\n\n  if show_all_max == 0:\n    solver.NewSearch(db, [objective])\n  else:\n    solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"z:\", z.Value())\n    p = [positions[i].Value() for i in range(n)]\n\n    print(\" \".join(\n        [persons[j] for i in range(n) for j in range(n) if p[j] == i]))\n    print(\"Successful preferences:\")\n    for i in range(n):\n      for j in range(n):\n        if preferences[i][j] == 1 and abs(p[i] - p[j]) == 1:\n          print(\"\\t\", persons[i], persons[j])\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nshow_all_max = 0  # show all maximal solutions\nif len(sys.argv) > 1:\n  show_all_max = 1\nmain(show_all_max)\n```\n\n----------------------------------------\n\nTITLE: Implementing Discrete Tomography Solver with Google CP Solver\nDESCRIPTION: Defines the main function for solving the discrete tomography problem. It sets up the solver, declares variables, adds constraints, and searches for solutions using the CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/discrete_tomography.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(row_sums=\"\", col_sums=\"\"):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n  if row_sums == \"\":\n    print(\"Using default problem instance\")\n    row_sums = [0, 0, 8, 2, 6, 4, 5, 3, 7, 0, 0]\n    col_sums = [0, 0, 7, 1, 6, 3, 4, 5, 2, 7, 0, 0]\n\n  r = len(row_sums)\n  c = len(col_sums)\n\n  # declare variables\n  x = []\n  for i in range(r):\n    t = []\n    for j in range(c):\n      t.append(solver.IntVar(0, 1, \"x[%i,%i]\" % (i, j)))\n    x.append(t)\n  x_flat = [x[i][j] for i in range(r) for j in range(c)]\n\n  #\n  # constraints\n  #\n  [\n      solver.Add(solver.Sum([x[i][j]\n                             for j in range(c)]) == row_sums[i])\n      for i in range(r)\n  ]\n  [\n      solver.Add(solver.Sum([x[i][j]\n                             for i in range(r)]) == col_sums[j])\n      for j in range(c)\n  ]\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x_flat)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x_flat, solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print_solution(x, r, c, row_sums, col_sums)\n    print()\n\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Solving Pell's Equation with CP-SAT Solver\nDESCRIPTION: Implements a function that solves Pell's equation (x² - coeff * y² = 1) using the CP-SAT solver. It creates variables for x, y and their squares, defines constraints for Pell's equation, and configures the solver with specific parameters for efficient search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/pell_equation_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\n\nfrom ortools.sat.colab import flags\nfrom ortools.sat.python import cp_model\n\n\n_COEFF = flags.define_integer(\"coeff\", 1, \"The Pell equation coefficient.\")\n_MAX_VALUE = flags.define_integer(\"max_value\", 5000_000, \"The maximum value.\")\n\n\ndef solve_pell(coeff: int, max_value: int) -> None:\n    \"\"\"Solves Pell's equation x^2 - coeff * y^2 = 1.\"\"\"\n    model = cp_model.CpModel()\n\n    x = model.new_int_var(1, max_value, \"x\")\n    y = model.new_int_var(1, max_value, \"y\")\n\n    # Pell's equation:\n    x_square = model.new_int_var(1, max_value * max_value, \"x_square\")\n    y_square = model.new_int_var(1, max_value * max_value, \"y_square\")\n    model.add_multiplication_equality(x_square, x, x)\n    model.add_multiplication_equality(y_square, y, y)\n    model.add(x_square - coeff * y_square == 1)\n\n    model.add_decision_strategy(\n        [x, y], cp_model.CHOOSE_MIN_DOMAIN_SIZE, cp_model.SELECT_MIN_VALUE\n    )\n\n    solver = cp_model.CpSolver()\n    solver.parameters.num_workers = 12\n    solver.parameters.log_search_progress = True\n    solver.parameters.cp_model_presolve = True\n    solver.parameters.cp_model_probing_level = 0\n\n    result = solver.solve(model)\n    if result == cp_model.OPTIMAL:\n        print(f\"x={solver.value(x)} y={solver.value(y)} coeff={coeff}\")\n        if solver.value(x) ** 2 - coeff * (solver.value(y) ** 2) != 1:\n            raise ValueError(\"Pell equation not satisfied.\")\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    solve_pell(_COEFF.value, _MAX_VALUE.value)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Custom Boolean Sum Constraint Implementation\nDESCRIPTION: Implementation of a custom constraint class BooleanSumEven that enforces an even sum of boolean variables\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass BooleanSumEven(pywrapcp.PyConstraint):\n\n  def __init__(self, solver, vars):\n    pywrapcp.PyConstraint.__init__(self, solver)\n    self.__vars = vars\n    self.__num_possible_true_vars = pywrapcp.NumericalRevInteger(0)\n    self.__num_always_true_vars = pywrapcp.NumericalRevInteger(0)\n\n  def Post(self):\n    for i in range(len(self.__vars)):\n      v = self.__vars[i]\n      if not v.Bound():\n        demon = self.Demon(BooleanSumEven.Update, i)\n        v.WhenBound(demon)\n\n  def InitialPropagate(self):\n    num_always_true = 0\n    num_possible_true = 0\n    possible_true_index = -1\n    for i in range(len(self.__vars)):\n      var = self.__vars[i]\n      if var.Min() == 1:\n        num_always_true += 1\n        num_possible_true += 1\n      elif var.Max() == 1:\n        num_possible_true += 1\n        possible_true_index = i\n\n    if num_always_true == num_possible_true and num_possible_true % 2 == 1:\n      self.solver().Fail()\n\n    if num_possible_true == num_always_true + 1:\n      self.__vars[possible_true_index].SetValue(num_always_true % 2)\n\n    self.__num_possible_true_vars.SetValue(self.solver(), num_possible_true)\n    self.__num_always_true_vars.SetValue(self.solver(), num_always_true)\n\n  def Update(self, index):\n    solver = self.solver()\n    value = self.__vars[index].Value()\n    if value == 0:\n      self.__num_possible_true_vars.Decr(solver)\n    else:\n      self.__num_always_true_vars.Incr(solver)\n\n    num_possible = self.__num_possible_true_vars.Value()\n    num_always = self.__num_always_true_vars.Value()\n\n    if num_always == num_possible and num_possible % 2 == 1:\n      solver.Fail()\n\n    if num_possible == num_always + 1:\n      possible_true_index = -1\n      for i in range(len(self.__vars)):\n        if not self.__vars[i].Bound():\n          possible_true_index = i\n          break\n\n      if possible_true_index != -1:\n        self.__vars[possible_true_index].SetValue(num_always % 2)\n\n  def DebugString(self):\n    return 'BooleanSumEven'\n```\n\n----------------------------------------\n\nTITLE: Murder Mystery Solver Implementation\nDESCRIPTION: Main implementation of the murder mystery solver using OR-Tools constraint programming. Includes matrix creation helpers, constraint definitions, and solution search logic. The code models relationships between characters using boolean matrices and applies logical constraints to determine who killed Agatha.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/who_killed_agatha.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import defaultdict\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef var_matrix_array(solver, rows, cols, lb, ub, name):\n  x = []\n  for i in range(rows):\n    t = []\n    for j in range(cols):\n      t.append(solver.IntVar(lb, ub, \"%s[%i,%i]\" % (name, i, j)))\n    x.append(t)\n  return x\n\n\ndef flatten_matrix(solver, m, rows, cols):\n  return [m[i][j] for i in range(rows) for j in range(cols)]\n\n\ndef print_flat_matrix(m_flat, rows, cols):\n  for i in range(rows):\n    for j in range(cols):\n      print(m_flat[i * cols + j].Value(), end=\" \")\n    print()\n  print()\n\n\ndef main(the_killers):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Who killed agatha?\")\n\n  #\n  # data\n  #\n  n = 3\n  agatha = 0\n  butler = 1\n  charles = 2\n\n  #\n  # declare variables\n  #\n  the_killer = solver.IntVar(0, 2, \"the_killer\")\n  the_victim = solver.IntVar(0, 2, \"the_victim\")\n\n  hates = var_matrix_array(solver, n, n, 0, 1, \"hates\")\n  richer = var_matrix_array(solver, n, n, 0, 1, \"richer\")\n\n  hates_flat = flatten_matrix(solver, hates, n, n)\n  richer_flat = flatten_matrix(solver, richer, n, n)\n\n  #\n  # constraints\n  #\n\n  # Agatha, the butler, and Charles live in Dreadsbury Mansion, and\n  # are the only ones to live there.\n\n  # A killer always hates, and is no richer than his victim.\n  # solver.Add(hates[the_killer, the_victim] == 1)\n  solver.Add(solver.Element(hates_flat, the_killer * n + the_victim) == 1)\n\n  # solver.Add(richer[the_killer, the_victim] == 0)\n  solver.Add(solver.Element(richer_flat, the_killer * n + the_victim) == 0)\n\n  # define the concept of richer: no one is richer than him-/herself\n  for i in range(n):\n    solver.Add(richer[i][i] == 0)\n\n  # (contd...) if i is richer than j then j is not richer than i\n  #  (i != j) => (richer[i,j] = 1) <=> (richer[j,i] = 0),\n  for i in range(n):\n    for j in range(n):\n      if i != j:\n        solver.Add((richer[i][j] == 1) == (richer[j][i] == 0))\n\n  # Charles hates noone that Agatha hates.\n  # forall i : Range .\n  #  (hates[agatha, i] = 1) => (hates[charles, i] = 0),\n  for i in range(n):\n    solver.Add((hates[agatha][i] == 1) <= (hates[charles][i] == 0))\n\n  # Agatha hates everybody except the butler.\n  solver.Add(hates[agatha][charles] == 1)\n  solver.Add(hates[agatha][agatha] == 1)\n  solver.Add(hates[agatha][butler] == 0)\n\n  # The butler hates everyone not richer than Aunt Agatha.\n  # forall i : Range .\n  #  (richer[i, agatha] = 0) => (hates[butler, i] = 1),\n  for i in range(n):\n    solver.Add((richer[i][agatha] == 0) <= (hates[butler][i] == 1))\n\n  # The butler hates everyone whom Agatha hates.\n  # forall i : Range .\n  #  (hates[agatha, i] = 1) => (hates[butler, i] = 1),\n  for i in range(n):\n    solver.Add((hates[agatha][i] == 1) <= (hates[butler][i] == 1))\n\n  # Noone hates everyone.\n  # forall i : Range .\n  #   (sum j : Range . hates[i,j]) <= 2,\n  for i in range(n):\n    solver.Add(solver.Sum([hates[i][j] for j in range(n)]) <= 2)\n\n  # Who killed Agatha?\n  solver.Add(the_victim == agatha)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(the_killer)\n  solution.Add(the_victim)\n  solution.Add(hates_flat)\n  solution.Add(richer_flat)\n\n  # db: DecisionBuilder\n  db = solver.Phase(hates_flat + richer_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"the_killer:\", the_killer.Value())\n    the_killers[the_killer.Value()] += 1\n    print(\"the_victim:\", the_victim.Value())\n    print(\"hates:\")\n    print_flat_matrix(hates_flat, n, n)\n    print(\"richer:\")\n    print_flat_matrix(richer_flat, n, n)\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nthe_killers = defaultdict(int)\np = [\"agatha\", \"butler\", \"charles\"]\nmain(the_killers)\n\nprint(\"\\n\")\nfor k in the_killers:\n  print(\"the killer %s was choosen in %i solutions\" % (p[k], the_killers[k]))\n```\n\n----------------------------------------\n\nTITLE: Solving School Scheduling Problem with CP-SAT Solver in Python\nDESCRIPTION: The main solve method for the school scheduling solver. It creates a CP-SAT solver instance, solves the model, and prints various schedules (teachers, classes, school) if a feasible or optimal solution is found. Finally, it displays solver statistics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef solve(self):\n    print('Solving')\n    # Create Solver\n    self._solver = cp_model.CpSolver()\n\n    solution_printer = SchoolSchedulingSatSolutionPrinter()\n    status = self._solver.Solve(self._model, solution_printer)\n    print('Status: ', self._solver.StatusName(status))\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print('\\n# Teachers')\n        for teacher_idx in self._all_teachers:\n            self.print_teacher_schedule(teacher_idx)\n\n        print('\\n# Classes')\n        for level_idx in self._all_levels:\n            for section_idx in self._all_sections:\n                self.print_class_schedule(level_idx, section_idx)\n\n        print('\\n# School')\n        self.print_school_schedule()\n\n    print('Branches: ', self._solver.NumBranches())\n    print('Conflicts: ', self._solver.NumConflicts())\n    print('WallTime: ', self._solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools and Defining Main Function for Place Number Puzzle\nDESCRIPTION: This snippet imports the necessary OR-Tools module and defines the main function for solving the place number puzzle. It sets up the solver, defines the puzzle constraints, and implements the solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/place_number_puzzle.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Place number\")\n\n  # data\n  m = 32\n  n = 8\n  # Note: this is 1-based for compatibility (and lazyness)\n  graph = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [2, 6], [3, 2],\n           [3, 4], [3, 6], [3, 7], [4, 1], [4, 3], [4, 6], [4, 7], [5, 2],\n           [5, 3], [5, 6], [5, 8], [6, 2], [6, 3], [6, 4], [6, 5], [6, 7],\n           [6, 8], [7, 3], [7, 4], [7, 6], [7, 8], [8, 5], [8, 6], [8, 7]]\n\n  # declare variables\n  x = [solver.IntVar(1, n, \"x%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n  for i in range(m):\n    # Note: make 0-based\n    solver.Add(abs(x[graph[i][0] - 1] - x[graph[i][1] - 1]) > 1)\n\n  # symmetry breaking\n  solver.Add(x[0] < x[n - 1])\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n\n  collector = solver.AllSolutionCollector(solution)\n\n  solver.Solve(\n      solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE),\n      [collector])\n\n  num_solutions = collector.SolutionCount()\n  for s in range(num_solutions):\n    print(\"x:\", [collector.Value(s, x[i]) for i in range(len(x))])\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Survo Puzzle Solver with OR-Tools\nDESCRIPTION: Defines the main function that sets up and solves the Survo puzzle using OR-Tools. It creates variables, sets constraints, and finds all solutions to the puzzle.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/survo_puzzle.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(r=0, c=0, rowsums=[], colsums=[], game=[]):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Survo puzzle\")\n\n  #\n  # data\n  #\n  if r == 0:\n    r = 3\n    c = 4\n    rowsums = [30, 18, 30]\n    colsums = [27, 16, 10, 25]\n    game = [[0, 6, 0, 0], [8, 0, 0, 0], [0, 0, 3, 0]]\n\n  print(\"r:\", r, \"c:\", c)\n\n  # declare variables\n  x = {}\n  for i in range(r):\n    for j in range(c):\n      x[(i, j)] = solver.IntVar(1, r * c, \"x %i %i\" % (i, j))\n\n  #\n  # constraints\n  #\n\n  #\n  # set the clues\n  #\n  for i in range(r):\n    for j in range(c):\n      if game[i][j] > 0:\n        solver.Add(x[i, j] == game[i][j])\n\n  xflat = [x[(i, j)] for i in range(r) for j in range(c)]\n  solver.Add(solver.AllDifferent(xflat))\n  #\n  # calculate rowsums and colsums\n  #\n  for i in range(r):\n    solver.Add(rowsums[i] == solver.Sum([x[i, j] for j in range(c)]))\n\n  for j in range(c):\n    solver.Add(colsums[j] == solver.Sum([x[i, j] for i in range(r)]))\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[(i, j)] for i in range(r) for j in range(c)])\n\n  collector = solver.AllSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase(xflat, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE),\n      [collector])\n\n  num_solutions = collector.SolutionCount()\n  print(\"\\nnum_solutions: \", num_solutions)\n  if num_solutions > 0:\n    for s in range(num_solutions):\n      xval = [collector.Value(s, x[(i, j)]) for i in range(r) for j in range(c)]\n\n      for i in range(r):\n        for j in range(c):\n          print(\"%2i\" % (xval[i * c + j]), end=\" \")\n        print()\n      print()\n\n    print()\n    print(\"num_solutions:\", num_solutions)\n    print(\"failures:\", solver.Failures())\n    print(\"branches:\", solver.Branches())\n    print(\"WallTime:\", solver.WallTime())\n\n  else:\n    print(\"No solutions found\")\n```\n\n----------------------------------------\n\nTITLE: Setting Up Participant Data and Constraints for Secret Santa Problem\nDESCRIPTION: This snippet sets up the participant data, including names and spouse relationships. It also defines the variables and constraints for the Secret Santa problem, such as preventing self-assignment and spousal gifting.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/secret_santa2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n  if single == 1:\n    n = n_with_single\n    Noah, Ava, Ryan, Mia, Ella, John, Lily, Evan, Single = list(range(n))\n    rounds = rounds_single\n  else:\n    n = n_no_single\n    Noah, Ava, Ryan, Mia, Ella, John, Lily, Evan = list(range(n))\n    rounds = rounds_no_single\n\n  M = n + 1\n\n  persons = [\n      'Noah', 'Ava', 'Ryan', 'Mia', 'Ella', 'John', 'Lily', 'Evan', 'Single'\n  ]\n\n  spouses = [\n      Ava,  # Noah\n      Noah,  # Ava\n      Mia,  # Rya\n      Ryan,  # Mia\n      John,  # Ella\n      Ella,  # John\n      Evan,  # Lily\n      Lily,  # Evan\n      -1  # Single has no spouse\n  ]\n\n  #\n  # declare variables\n  #\n  santas = [solver.IntVar(0, n - 1, 'santas[%i]' % i) for i in range(n)]\n  santa_distance = [\n      solver.IntVar(0, M, 'santa_distance[%i]' % i) for i in range(n)\n  ]\n\n  # total of 'distance', to maximize\n  z = solver.IntVar(0, n * n * n, 'z')\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(santas))\n\n  solver.Add(z == solver.Sum(santa_distance))\n\n  # Can't be one own's Secret Santa\n  # (i.e. ensure that there are no fix-point in the array.)\n  for i in range(n):\n    solver.Add(santas[i] != i)\n\n  # no Santa for a spouses\n  for i in range(n):\n    if spouses[i] > -1:\n      solver.Add(santas[i] != spouses[i])\n\n  # optimize 'distance' to earlier rounds:\n  for i in range(n):\n    solver.Add(santa_distance[i] == solver.Element(rounds[i], santas[i]))\n\n  # cannot be a Secret Santa for the same person\n  # two years in a row.\n  for i in range(n):\n    for j in range(n):\n      if rounds[i][j] == 1:\n        solver.Add(santas[i] != j)\n```\n\n----------------------------------------\n\nTITLE: Computing Preemptive Lower Bound for RCPSP Makespan\nDESCRIPTION: This function calculates a preemptive lower bound for the makespan by breaking tasks into unit intervals and solving a set covering problem with column generation. It builds task combinations that can be scheduled together and solves a CP model to minimize the schedule length.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef compute_preemptive_lower_bound(\n    problem: rcpsp_pb2.RcpspProblem,\n    after: dict[int, list[int]],\n    lower_bound: int,\n) -> int:\n    \"\"\"Computes a preemtive lower bound for the makespan statically.\n\n    For this, it breaks all intervals into a set of intervals of size one.\n    Then it will try to assign all of them in a minimum number of configurations.\n    This is a standard complete set covering using column generation approach\n    where each column is a possible combination of itervals of size one.\n\n    Args:\n      problem: The probuf of the model.\n      after: a task to list of task dict that contains all tasks after a given\n        task.\n      lower_bound: A valid lower bound of the problem. It can be 0.\n\n    Returns:\n      a valid lower bound of the problem.\n    \"\"\"\n    # Check this is a single mode problem.\n    if (\n        problem.is_rcpsp_max\n        or problem.is_resource_investment\n        or problem.is_consumer_producer\n    ):\n        return lower_bound\n\n    demand_map = collections.defaultdict(int)\n    duration_map = {}\n    all_active_tasks = list(range(1, len(problem.tasks) - 1))\n    max_duration = 0\n    sum_of_demands = 0\n\n    for t in all_active_tasks:\n        task = problem.tasks[t]\n        if len(task.recipes) > 1:\n            return 0\n        recipe = task.recipes[0]\n        duration_map[t] = recipe.duration\n        for demand, resource in zip(recipe.demands, recipe.resources):\n            demand_map[(t, resource)] = demand\n            max_duration = max(max_duration, recipe.duration)\n            sum_of_demands += demand\n\n    print(\n        f\"Compute a bin-packing lower bound with {len(all_active_tasks)}\"\n        + \" active tasks\",\n        flush=True,\n    )\n    all_combinations = []\n\n    for t in all_active_tasks:\n        new_combinations = [[t]]\n\n        for c in all_combinations:\n            if accept_new_candidate(problem, after, demand_map, c, t):\n                new_combinations.append(c + [t])\n\n        all_combinations.extend(new_combinations)\n\n    print(f\"  - created {len(all_combinations)} combinations\")\n    if len(all_combinations) > 5000000:\n        return lower_bound  # Abort if too large.\n\n    # solve the selection model.\n\n    # TODO(user): a few possible improvements:\n    # 1/  use \"dominating\" columns, i.e. if you can add a task to a column, then\n    #     do not use that column.\n    # 2/ Merge all task with exactly same demands into one.\n    model = cp_model.CpModel()\n    model.name = f\"lower_bound_{problem.name}\"\n\n    vars_per_task = collections.defaultdict(list)\n    all_vars = []\n    for c in all_combinations:\n        min_duration = max_duration\n        for t in c:\n            min_duration = min(min_duration, duration_map[t])\n        count = model.new_int_var(0, min_duration, f\"count_{c}\")\n        all_vars.append(count)\n        for t in c:\n            vars_per_task[t].append(count)\n\n    # Each task must be performed.\n    for t in all_active_tasks:\n        model.add(sum(vars_per_task[t]) >= duration_map[t])\n\n    # Objective\n    objective_var = model.new_int_var(lower_bound, sum_of_demands, \"objective_var\")\n    model.add(objective_var == sum(all_vars))\n\n    model.minimize(objective_var)\n\n    # solve model.\n    solver = cp_model.CpSolver()\n    solver.parameters.num_search_workers = 16\n    solver.parameters.max_time_in_seconds = _PREEMPTIVE_LB_TIME_LIMIT.value\n    status = solver.solve(model)\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        status_str = \"optimal\" if status == cp_model.OPTIMAL else \"\"\n        lower_bound = max(lower_bound, int(solver.best_objective_bound))\n        print(f\"  - {status_str} static lower bound = {lower_bound}\", flush=True)\n\n    return lower_bound\n```\n\n----------------------------------------\n\nTITLE: Main Function for VRP Solution\nDESCRIPTION: Implements the main function to solve the Vehicle Routing Problem using OR-Tools. It creates the routing model, sets up callbacks, defines search parameters, and solves the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools and Defining Main Function for Cryptarithmetic Puzzle\nDESCRIPTION: This snippet imports the necessary OR-Tools module and defines the main function that sets up and solves the cryptarithmetic puzzle. It creates the solver, defines variables, and sets up constraints based on the puzzle's equation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/crypta.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Crypta\")\n\n  #\n  # data\n  #\n\n  #\n  # variables\n  #\n  LD = [solver.IntVar(0, 9, \"LD[%i]\" % i) for i in range(0, 10)]\n  A, B, C, D, E, F, G, H, I, J = LD\n\n  Sr1 = solver.IntVar(0, 1, \"Sr1\")\n  Sr2 = solver.IntVar(0, 1, \"Sr2\")\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(LD))\n  solver.Add(B >= 1)\n  solver.Add(D >= 1)\n  solver.Add(G >= 1)\n\n  solver.Add(A + 10 * E + 100 * J + 1000 * B + 10000 * B + 100000 * E +\n             1000000 * F + E + 10 * J + 100 * E + 1000 * F + 10000 * G +\n             100000 * A + 1000000 * F == F + 10 * E + 100 * E + 1000 * H +\n             10000 * I + 100000 * F + 1000000 * B + 10000000 * Sr1)\n\n  solver.Add(C + 10 * F + 100 * H + 1000 * A + 10000 * I + 100000 * I +\n             1000000 * J + F + 10 * I + 100 * B + 1000 * D + 10000 * I +\n             100000 * D + 1000000 * C + Sr1 == J + 10 * F + 100 * A + 1000 * F +\n             10000 * H + 100000 * D + 1000000 * D + 10000000 * Sr2)\n\n  solver.Add(A + 10 * J + 100 * J + 1000 * I + 10000 * A + 100000 * B + B +\n             10 * A + 100 * G + 1000 * F + 10000 * H + 100000 * D + Sr2 == C +\n             10 * A + 100 * G + 1000 * E + 10000 * J + 100000 * G)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(LD, solver.INT_VAR_SIMPLE, solver.INT_VALUE_SIMPLE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  str = \"ABCDEFGHIJ\"\n  while solver.NextSolution():\n    num_solutions += 1\n    for (letter, val) in [(str[i], LD[i].Value()) for i in range(len(LD))]:\n      print(\"%s: %i\" % (letter, val))\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Chemical Balance Optimization Implementation\nDESCRIPTION: Complete implementation of chemical balance optimization using CP-SAT solver. The code defines maximum quantities for chemical products, chemical sets with their compositions, and creates a constraint programming model to find optimal quantities while respecting constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/chemical_balance_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport math\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\ndef chemical_balance():\n    \"\"\"Solves the chemical balance problem.\"\"\"\n    # Data\n    max_quantities = [\n        [\"N_Total\", 1944],\n        [\"P2O5\", 1166.4],\n        [\"K2O\", 1822.5],\n        [\"CaO\", 1458],\n        [\"MgO\", 486],\n        [\"Fe\", 9.7],\n        [\"B\", 2.4],\n    ]\n\n    chemical_set = [\n        [\"A\", 0, 0, 510, 540, 0, 0, 0],\n        [\"B\", 110, 0, 0, 0, 160, 0, 0],\n        [\"C\", 61, 149, 384, 0, 30, 1, 0.2],\n        [\"D\", 148, 70, 245, 0, 15, 1, 0.2],\n        [\"E\", 160, 158, 161, 0, 10, 1, 0.2],\n    ]\n\n    num_products = len(max_quantities)\n    all_products = range(num_products)\n\n    num_sets = len(chemical_set)\n    all_sets = range(num_sets)\n\n    # Model\n\n    model = cp_model.CpModel()\n\n    # Scale quantities by 100.\n    max_set = [\n        int(\n            math.ceil(\n                min(\n                    max_quantities[q][1] * 1000 / chemical_set[s][q + 1]\n                    for q in all_products\n                    if chemical_set[s][q + 1] != 0\n                )\n            )\n        )\n        for s in all_sets\n    ]\n\n    set_vars = [model.new_int_var(0, max_set[s], f\"set_{s}\") for s in all_sets]\n\n    epsilon = model.new_int_var(0, 10000000, \"epsilon\")\n\n    for p in all_products:\n        model.add(\n            sum(int(chemical_set[s][p + 1] * 10) * set_vars[s] for s in all_sets)\n            <= int(max_quantities[p][1] * 10000)\n        )\n        model.add(\n            sum(int(chemical_set[s][p + 1] * 10) * set_vars[s] for s in all_sets)\n            >= int(max_quantities[p][1] * 10000) - epsilon\n        )\n\n    model.minimize(epsilon)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n    if status == cp_model.OPTIMAL:\n        # The objective value of the solution.\n        print(f\"Optimal objective value = {solver.objective_value / 10000.0}\")\n\n        for s in all_sets:\n            print(\n                f\"  {chemical_set[s][0]} = {solver.value(set_vars[s]) / 1000.0}\",\n                end=\" \",\n            )\n            print()\n        for p in all_products:\n            name = max_quantities[p][0]\n            max_quantity = max_quantities[p][1]\n            quantity = sum(\n                solver.value(set_vars[s]) / 1000.0 * chemical_set[s][p + 1]\n                for s in all_sets\n            )\n            print(f\"{name}: {quantity:.3f} out of {max_quantity}\")\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    chemical_balance()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Futoshiki Solver using Google OR-Tools\nDESCRIPTION: Defines the main function that sets up and solves the Futoshiki puzzle using Google OR-Tools. It creates variables, sets constraints, and searches for solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/futoshiki.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(values, lt):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Futoshiki problem\")\n\n  #\n  # data\n  #\n  size = len(values)\n  RANGE = list(range(size))\n  NUMQD = list(range(len(lt)))\n\n  #\n  # variables\n  #\n  field = {}\n  for i in RANGE:\n    for j in RANGE:\n      field[i, j] = solver.IntVar(1, size, \"field[%i,%i]\" % (i, j))\n  field_flat = [field[i, j] for i in RANGE for j in RANGE]\n\n  #\n  # constraints\n  #\n  # set initial values\n  for row in RANGE:\n    for col in RANGE:\n      if values[row][col] > 0:\n        solver.Add(field[row, col] == values[row][col])\n\n  # all rows have to be different\n  for row in RANGE:\n    solver.Add(solver.AllDifferent([field[row, col] for col in RANGE]))\n\n  # all columns have to be different\n  for col in RANGE:\n    solver.Add(solver.AllDifferent([field[row, col] for row in RANGE]))\n\n  # all < constraints are satisfied\n  # Also: make 0-based\n  for i in NUMQD:\n    solver.Add(\n        field[lt[i][0] - 1, lt[i][1] - 1] < field[lt[i][2] - 1, lt[i][3] - 1])\n\n  #\n  # search and result\n  #\n  db = solver.Phase(field_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    for i in RANGE:\n      for j in RANGE:\n        print(field[i, j].Value(), end=\" \")\n      print()\n    print()\n\n  solver.EndSearch()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Main Function for De Bruijn Sequence Generation\nDESCRIPTION: Implements the core logic for generating de Bruijn sequences using the OR-Tools constraint solver. It sets up variables, constraints, and handles the solution search process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/debruijn_binary.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main(base=2, n=3, m=8):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"de Bruijn sequences\")\n\n  # ... [rest of the main function code] ...\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Overlapping Intervals Example with OR-Tools SAT\nDESCRIPTION: This code defines a function `overlapping_interval_sample_sat` that creates two intervals with start and end variables, and a boolean variable `a_overlaps_b` to indicate overlap. It then defines constraints using `CpModel` to link the overlap variable to the relative positions of the intervals, and enumerates all possible solutions using a `CpSolver`.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/overlapping_intervals_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \\\"\\\"\\\"Print intermediate solutions.\\\"\\\"\\\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\\\"{v}={self.value(v)}\\\", end=\\\" \\\")\n        print()\n\n\ndef overlapping_interval_sample_sat():\n    \\\"\\\"\\\"Create the overlapping Boolean variables and enumerate all states.\\\"\\\"\\\"\"\n    model = cp_model.CpModel()\n\n    horizon = 7\n\n    # First interval.\n    start_var_a = model.new_int_var(0, horizon, \\\"start_a\\\")\n    duration_a = 3\n    end_var_a = model.new_int_var(0, horizon, \\\"end_a\\\")\n    unused_interval_var_a = model.new_interval_var(\n        start_var_a, duration_a, end_var_a, \\\"interval_a\\\"\n    )\n\n    # Second interval.\n    start_var_b = model.new_int_var(0, horizon, \\\"start_b\\\")\n    duration_b = 2\n    end_var_b = model.new_int_var(0, horizon, \\\"end_b\\\")\n    unused_interval_var_b = model.new_interval_var(\n        start_var_b, duration_b, end_var_b, \\\"interval_b\\\"\n    )\n\n    # a_after_b Boolean variable.\n    a_after_b = model.new_bool_var(\\\"a_after_b\\\")\n    model.add(start_var_a >= end_var_b).only_enforce_if(a_after_b)\n    model.add(start_var_a < end_var_b).only_enforce_if(~a_after_b)\n\n    # b_after_a Boolean variable.\n    b_after_a = model.new_bool_var(\\\"b_after_a\\\")\n    model.add(start_var_b >= end_var_a).only_enforce_if(b_after_a)\n    model.add(start_var_b < end_var_a).only_enforce_if(~b_after_a)\n\n    # Result Boolean variable.\n    a_overlaps_b = model.new_bool_var(\\\"a_overlaps_b\\\")\n\n    # Option a: using only clauses\n    model.add_bool_or(a_after_b, b_after_a, a_overlaps_b)\n    model.add_implication(a_after_b, ~a_overlaps_b)\n    model.add_implication(b_after_a, ~a_overlaps_b)\n\n    # Option b: using an exactly one constraint.\n    # model.add_exactly_one(a_after_b, b_after_a, a_overlaps_b)\n\n    # Search for start values in increasing order for the two intervals.\n    model.add_decision_strategy(\n        [start_var_a, start_var_b],\n        cp_model.CHOOSE_FIRST,\n        cp_model.SELECT_MIN_VALUE,\n    )\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([start_var_a, start_var_b, a_overlaps_b])\n    solver.solve(model, solution_printer)\n\n\noverlapping_interval_sample_sat()\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Volsay2 Linear Programming Problem with OR-Tools\nDESCRIPTION: This code implements the Volsay2 linear programming problem using Google OR-Tools. It sets up the solver, defines variables and constraints, and solves the optimization problem to maximize profit in a production scenario involving Gas and Chloride.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/volsay2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(unused_argv):\n\n  # Create the solver.\n\n  # using GLPK\n  # solver = pywraplp.Solver('CoinsGridGLPK',\n  #                          pywraplp.Solver.GLPK_LINEAR_PROGRAMMING)\n\n  # Using CLP\n  solver = pywraplp.Solver.CreateSolver('CLP')\n  if not solver:\n    return\n\n  # data\n  num_products = 2\n  Gas = 0\n  Chloride = 1\n\n  products = ['Gas', 'Chloride']\n\n  # declare variables\n  production = [\n      solver.NumVar(0, 100000, 'production[%i]' % i)\n      for i in range(num_products)\n  ]\n\n  #\n  # constraints\n  #\n  solver.Add(production[Gas] + production[Chloride] <= 50)\n  solver.Add(3 * production[Gas] + 4 * production[Chloride] <= 180)\n\n  # objective\n  objective = solver.Maximize(40 * production[Gas] + 50 * production[Chloride])\n\n  print('NumConstraints:', solver.NumConstraints())\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n  print('objective = ', solver.Objective().Value())\n  for i in range(num_products):\n    print(products[i], '=', production[i].SolutionValue(), end=' ')\n    print('ReducedCost = ', production[i].ReducedCost())\n\n\nmain('Volsay')\n```\n\n----------------------------------------\n\nTITLE: Solving QUBO Problems with Google OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This function solves a Quadratic Unconstrained Binary Optimization (QUBO) problem using Google's CP-SAT solver. It creates boolean variables, constructs the objective function from the quadratic terms in RAW_DATA, and then minimizes the resulting expression with a time limit of 30 seconds.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/qubo_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef solve_qubo() -> None:\n    \"\"\"solve the Qubo problem.\"\"\"\n\n    # Build the model.\n    model = cp_model.CpModel()\n\n    num_vars = len(RAW_DATA)\n    all_vars = range(num_vars)\n    variables = [model.new_bool_var(\"x_%i\" % i) for i in all_vars]\n\n    obj_vars = []\n    obj_coeffs = []\n\n    for i in range(num_vars - 1):\n        x_i = variables[i]\n        for j in range(i + 1, num_vars):\n            coeff = RAW_DATA[i][j] + RAW_DATA[j][i]\n            if coeff == 0.0:\n                continue\n            x_j = variables[j]\n            var = model.new_bool_var(\"\")\n            model.add_bool_or([~x_i, ~x_j, var])\n            model.add_implication(var, x_i)\n            model.add_implication(var, x_j)\n            obj_vars.append(var)\n            obj_coeffs.append(coeff)\n\n    for i in all_vars:\n        self_coeff = RAW_DATA[i][i] + RAW_DATA[i][-1]\n        if self_coeff != 0.0:\n            obj_vars.append(variables[i])\n            obj_coeffs.append(self_coeff)\n\n    model.minimize(sum(obj_vars[i] * obj_coeffs[i] for i in range(len(obj_vars))))\n\n    ### Solve model.\n    solver = cp_model.CpSolver()\n    solver.parameters.num_search_workers = 16\n    solver.parameters.log_search_progress = True\n    solver.parameters.max_time_in_seconds = 30\n    solver.solve(model)\n```\n\n----------------------------------------\n\nTITLE: Regular Constraint Implementation\nDESCRIPTION: Complete implementation of the regular constraint solver including transition matrix creation, constraint handling, and solution search. Implements a DFA-based constraint system that processes sequences matching specific patterns.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular_table.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef regular(x, Q, S, d, q0, F):\n\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    for j in range(S):\n      if i == 0:\n        d2.append((0, j, 0))\n      else:\n        d2.append((i, j, d[i - 1][j]))\n\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n\n  a = [solver.IntVar(0, Q, 'a[%i]' % i) for i in range(m, n + 1)]\n\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n    solver.Add(solver.AllowedAssignments((a[i], x[i] - 1, a[i + 1]), d2))\n\ndef make_transition_matrix(pattern):\n\n  p_len = len(pattern)\n  print('p_len:', p_len)\n  num_states = p_len + sum(pattern)\n  print('num_states:', num_states)\n  t_matrix = []\n  for i in range(num_states):\n    row = []\n    for j in range(2):\n      row.append(0)\n    t_matrix.append(row)\n\n  tmp = [0 for i in range(num_states)]\n  c = 0\n  tmp[c] = 0\n  for i in range(p_len):\n    for j in range(pattern[i]):\n      c += 1\n      tmp[c] = 1\n    if c < num_states - 1:\n      c += 1\n      tmp[c] = 0\n  print('tmp:', tmp)\n\n  t_matrix[num_states - 1][0] = num_states\n  t_matrix[num_states - 1][1] = 0\n\n  for i in range(num_states):\n    if tmp[i] == 0:\n      t_matrix[i][0] = i + 1\n      t_matrix[i][1] = i + 2\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          t_matrix[i][0] = 0\n          t_matrix[i][1] = i + 2\n        else:\n          t_matrix[i][0] = i + 2\n          t_matrix[i][1] = 0\n\n  print('The states:')\n  for i in range(num_states):\n    for j in range(2):\n      print(t_matrix[i][j], end=' ')\n    print()\n  print()\n\n  return t_matrix\n\ndef main():\n\n  solver = pywrapcp.Solver('Regular test')\n\n  this_len = 10\n  pp = [3, 2, 1]\n\n  transition_fn = make_transition_matrix(pp)\n  n_states = len(transition_fn)\n  input_max = 2\n\n  initial_state = 1\n\n  accepting_states = [n_states]\n\n  reg_input = [\n      solver.IntVar(1, input_max, 'reg_input[%i]' % i) for i in range(this_len)\n  ]\n\n  regular(reg_input, n_states, input_max, transition_fn, initial_state,\n          accepting_states)\n\n  db = solver.Phase(reg_input, solver.CHOOSE_MIN_SIZE_HIGHEST_MAX,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print('reg_input:', [reg_input[i].Value() - 1 for i in range(this_len)])\n    num_solutions += 1\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving a Minimal CP-SAT Example\nDESCRIPTION: This snippet demonstrates a minimal example of setting up a constraint satisfaction problem using the CP-SAT solver from OR-Tools. It creates a model, defines variables and constraints, and outputs the results of the optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cp_sat_example.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef main() -> None:\n    \"\"\"Minimal CP-SAT example to showcase calling the solver.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    var_upper_bound = max(50, 45, 37)\n    x = model.new_int_var(0, var_upper_bound, \"x\")\n    y = model.new_int_var(0, var_upper_bound, \"y\")\n    z = model.new_int_var(0, var_upper_bound, \"z\")\n\n    # Creates the constraints.\n    model.add(2 * x + 7 * y + 3 * z <= 50)\n    model.add(3 * x - 5 * y + 7 * z <= 45)\n    model.add(5 * x + 2 * y - 6 * z <= 37)\n\n    model.maximize(2 * x + 2 * y + 3 * z)\n\n    # Creates a solver and solves the model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"Maximum of objective function: {solver.objective_value}\\n\")\n        print(f\"x = {solver.value(x)}\")\n        print(f\"y = {solver.value(y)}\")\n        print(f\"z = {solver.value(z)}\")\n    else:\n        print(\"No solution found.\")\n\n    # Statistics.\n    print(\"\\nStatistics\")\n    print(f\"  status   : {solver.status_name(status)}\")\n    print(f\"  conflicts: {solver.num_conflicts}\")\n    print(f\"  branches : {solver.num_branches}\")\n    print(f\"  wall time: {solver.wall_time} s\")\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Cloning a Model Sample using OR-Tools SAT\nDESCRIPTION: This function demonstrates the process of creating a constraint programming model, defining variables and constraints, solving it, and then cloning it to create a modified version with additional constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/clone_model_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n\"from ortools.sat.python import cp_model\\n\\ndef clone_model_sample_sat():\\n    \\\"\\\"\\\"Showcases cloning a model.\\\"\\\"\\\"\\n    # Creates the model.\\n    model = cp_model.CpModel()\\n\\n    # Creates the variables.\\n    num_vals = 3\\n    x = model.new_int_var(0, num_vals - 1, \\\"x\\\")\\n    y = model.new_int_var(0, num_vals - 1, \\\"y\\\")\\n    z = model.new_int_var(0, num_vals - 1, \\\"z\\\")\\n\\n    # Creates the constraints.\\n    model.add(x != y)\\n\\n    model.maximize(x + 2 * y + 3 * z)\\n\\n    # Creates a solver and solves.\\n    solver = cp_model.CpSolver()\\n    status = solver.solve(model)\\n\\n    if status == cp_model.OPTIMAL:\\n        print(\\\"Optimal value of the original model: {}\\\".format(solver.objective_value))\\n\\n    # Clones the model.\\n    copy = model.clone()\\n\\n    copy_x = copy.get_int_var_from_proto_index(x.index)\\n    copy_y = copy.get_int_var_from_proto_index(y.index)\\n\\n    copy.add(copy_x + copy_y <= 1)\\n\\n    status = solver.solve(copy)\\n\\n    if status == cp_model.OPTIMAL:\\n        print(\\\"Optimal value of the modified model: {}\\\".format(solver.objective_value))\\n\\nclone_model_sample_sat()\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Ski Assignment Optimization using Google CP Solver\nDESCRIPTION: This code implements the ski assignment problem using Google's CP Solver. It defines the problem data, creates variables and constraints, and solves the optimization problem to minimize the total height difference between skiers and their assigned skis.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/ski_assignment.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Ski assignment')\n\n  #\n  # data\n  #\n  num_skis = 6\n  num_skiers = 5\n  ski_heights = [1, 2, 5, 7, 13, 21]\n  skier_heights = [3, 4, 7, 11, 18]\n\n  #\n  # variables\n  #\n\n  # which ski to choose for each skier\n  x = [solver.IntVar(0, num_skis - 1, 'x[%i]' % i) for i in range(num_skiers)]\n  z = solver.IntVar(0, sum(ski_heights), 'z')\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n\n  z_tmp = [\n      abs(solver.Element(ski_heights, x[i]) - skier_heights[i])\n      for i in range(num_skiers)\n  ]\n  solver.Add(z == sum(z_tmp))\n\n  # objective\n  objective = solver.Minimize(z, 1)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('total differences:', z.Value())\n    for i in range(num_skiers):\n      x_val = x[i].Value()\n      ski_height = ski_heights[x[i].Value()]\n      diff = ski_height - skier_heights[i]\n      print('Skier %i: Ski %i with length %2i (diff: %2i)' %\\\n            (i, x_val, ski_height, diff))\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Eq10 Problem Implementation using OR-Tools\nDESCRIPTION: Main implementation of the Eq10 benchmark problem using OR-Tools constraint solver. Creates variables with domain [0,10], defines system of 10 linear equations as constraints, and searches for solutions using simple integer variable and value selection strategies.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/eq10.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Eq 10\")\n\n  #\n  # data\n  #\n  n = 7\n\n  #\n  # variables\n  #\n  X = [solver.IntVar(0, 10, \"X(%i)\" % i) for i in range(n)]\n  X1, X2, X3, X4, X5, X6, X7 = X\n\n  #\n  # constraints\n  #\n  solver.Add(0 + 98527 * X1 + 34588 * X2 + 5872 * X3 + 59422 * X5 +\n             65159 * X7 == 1547604 + 30704 * X4 + 29649 * X6)\n\n  solver.Add(0 + 98957 * X2 + 83634 * X3 + 69966 * X4 + 62038 * X5 +\n             37164 * X6 + 85413 * X7 == 1823553 + 93989 * X1)\n\n  solver.Add(900032 + 10949 * X1 + 77761 * X2 + 67052 * X5 == 0 + 80197 * X3 +\n             61944 * X4 + 92964 * X6 + 44550 * X7)\n\n  solver.Add(0 + 73947 * X1 + 84391 * X3 + 81310 * X5 == 1164380 + 96253 * X2 +\n             44247 * X4 + 70582 * X6 + 33054 * X7)\n\n  solver.Add(0 + 13057 * X3 + 42253 * X4 + 77527 * X5 + 96552 * X7 == 1185471 +\n             60152 * X1 + 21103 * X2 + 97932 * X6)\n\n  solver.Add(1394152 + 66920 * X1 + 55679 * X4 == 0 + 64234 * X2 + 65337 * X3 +\n             45581 * X5 + 67707 * X6 + 98038 * X7)\n\n  solver.Add(0 + 68550 * X1 + 27886 * X2 + 31716 * X3 + 73597 * X4 +\n             38835 * X7 == 279091 + 88963 * X5 + 76391 * X6)\n\n  solver.Add(0 + 76132 * X2 + 71860 * X3 + 22770 * X4 + 68211 * X5 +\n             78587 * X6 == 480923 + 48224 * X1 + 82817 * X7)\n\n  solver.Add(519878 + 94198 * X2 + 87234 * X3 + 37498 * X4 == 0 + 71583 * X1 +\n             25728 * X5 + 25495 * X6 + 70023 * X7)\n\n  solver.Add(361921 + 78693 * X1 + 38592 * X5 + 38478 * X6 == 0 + 94129 * X2 +\n             43188 * X3 + 82528 * X4 + 69025 * X7)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(X, solver.INT_VAR_SIMPLE, solver.INT_VALUE_SIMPLE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"X:\", [X[i].Value() for i in range(n)])\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Job Shop Scheduling with CP-SAT in Python\nDESCRIPTION: Implementation of a job shop scheduling solver for the ft06 benchmark problem using Google's CP-SAT solver. The model handles machine constraints, precedence constraints within jobs, and minimizes the makespan (total schedule length).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/README.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom google3.util.operations_research.sat.python import cp_model\nfrom google3.util.operations_research.sat.colab import visualization\n\ndef JobshopFT06():\n  \"\"\"Solves the ft06 jobshop from the jssp library.\n\n  (http://people.brunel.ac.uk/~mastjjb/jeb/orlib/jobshopinfo.html).\"\"\"\n\n  # Creates the solver.\n  model = cp_model.CpModel()\n\n  machines_count = 6\n  jobs_count = 6\n  all_machines = range(0, machines_count)\n  all_jobs = range(0, jobs_count)\n\n  durations = [[1, 3, 6, 7, 3, 6],\n               [8, 5, 10, 10, 10, 4],\n               [5, 4, 8, 9, 1, 7],\n               [5, 5, 5, 3, 8, 9],\n               [9, 3, 5, 4, 3, 1],\n               [3, 3, 9, 10, 4, 1]]\n\n  machines = [[2, 0, 1, 3, 5, 4],\n              [1, 2, 4, 5, 0, 3],\n              [2, 3, 5, 0, 1, 4],\n              [1, 0, 2, 3, 4, 5],\n              [2, 1, 4, 5, 0, 3],\n              [1, 3, 5, 0, 4, 2]]\n\n  # Computes horizon dynamically.\n  horizon = sum([sum(durations[i]) for i in all_jobs])\n\n  # Creates jobs.\n  all_tasks = {}\n  for i in all_jobs:\n    for j in all_machines:\n      start = model.NewIntVar(0, horizon, 'start_%i_%i' % (i, j))\n      duration = durations[i][j]\n      end = model.NewIntVar(0, horizon, 'end_%i_%i' % (i, j))\n      interval = model.NewIntervalVar(start, duration, end,\n                                      'interval_%i_%i' % (i, j))\n      all_tasks[(i, j)] = (start, end, interval)\n\n  # Create disjunctive constraints.\n  for i in all_machines:\n    machines_jobs = []\n    for j in all_jobs:\n      for k in all_machines:\n        if machines[j][k] == i:\n          machines_jobs.append(all_tasks[(j, k)][2])\n    model.AddNoOverlap(machines_jobs)\n\n  # Makespan objective: minimize the total length of the schedule.\n  obj_var = model.NewIntVar(0, horizon, 'makespan')\n  model.AddMaxEquality(\n      obj_var, [all_tasks[(i, machines_count - 1)][1] for i in all_jobs])\n  model.Minimize(obj_var)\n\n  # Precedences inside a job.\n  for i in all_jobs:\n    for j in range(0, machines_count - 1):\n      model.Add(all_tasks[(i, j + 1)][0] >= all_tasks[(i, j)][1])\n\n  solver = cp_model.CpSolver()\n  response = solver.Solve(model)\n  starts = [[solver.Value(all_tasks[(i, j)][0]) for j in all_machines]\n            for i in all_jobs]\n  visualization.DisplayJobshop(starts, durations, machines, 'FT06')\n\n\nJobshopFT06()\n```\n\n----------------------------------------\n\nTITLE: Callback Function for Total Travel Time Calculation\nDESCRIPTION: This callback function calculates the total time between two nodes, combining both service time at the origin and transit time between nodes. It's used to set up time constraints in the routing model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef tot_time_fn(from_index, to_index):\n    \"\"\"\n    The time function we want is both transit time and service time.\n    \"\"\"\n    # Convert from routing variable Index to distance matrix NodeIndex.\n    from_node = manager.IndexToNode(from_index)\n    to_node = manager.IndexToNode(to_index)\n    return serv_time_fn(from_node, to_node) + transit_time_fn(from_node, to_node)\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Scheduling Optimization with CP-SAT Solver\nDESCRIPTION: Main function that creates and solves the scheduling optimization model using OR-Tools CP-SAT solver. It defines variables for task starts and durations, adds cumulative constraints for minimum and maximum load profiles, sets the objective to maximize task priority, and processes the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef main(_) -> None:\n    \"\"\"Create the model and solves it.\"\"\"\n    max_load_df, min_load_df, tasks_df = create_data_model()\n\n    # Create the model.\n    model = cp_model.CpModel()\n\n    # Get the max capacity from the capacity dataframe.\n    max_load = max_load_df.max_load.max()\n    print(f\"Max capacity = {max_load}\")\n    print(f\"#tasks = {len(tasks_df)}\")\n\n    minutes_per_hour: int = 60\n    horizon: int = 24 * 60\n\n    # Variables\n    starts = model.new_int_var_series(\n        name=\"starts\",\n        lower_bounds=0,\n        upper_bounds=horizon - tasks_df.duration,\n        index=tasks_df.index,\n    )\n    performed = model.new_bool_var_series(name=\"performed\", index=tasks_df.index)\n\n    intervals = model.new_optional_fixed_size_interval_var_series(\n        name=\"intervals\",\n        index=tasks_df.index,\n        starts=starts,\n        sizes=tasks_df.duration,\n        are_present=performed,\n    )\n\n    # Set up the max profile. We use fixed (intervals, demands) to fill in the\n    # space between the actual max load profile and the max capacity.\n    time_period_max_intervals = model.new_fixed_size_interval_var_series(\n        name=\"time_period_max_intervals\",\n        index=max_load_df.index,\n        starts=max_load_df.start_hour * minutes_per_hour,\n        sizes=minutes_per_hour * 2,\n    )\n    time_period_max_heights = max_load - max_load_df.max_load\n\n    # Cumulative constraint for the max profile.\n    model.add_cumulative(\n        intervals.to_list() + time_period_max_intervals.to_list(),\n        tasks_df.load.to_list() + time_period_max_heights.to_list(),\n        max_load,\n    )\n\n    # Set up complemented intervals (from 0 to start, and from start + size to\n    # horizon).\n    prefix_intervals = model.new_optional_interval_var_series(\n        name=\"prefix_intervals\",\n        index=tasks_df.index,\n        starts=0,\n        sizes=starts,\n        ends=starts,\n        are_present=performed,\n    )\n\n    suffix_intervals = model.new_optional_interval_var_series(\n        name=\"suffix_intervals\",\n        index=tasks_df.index,\n        starts=starts + tasks_df.duration,\n        sizes=horizon - starts - tasks_df.duration,\n        ends=horizon,\n        are_present=performed,\n    )\n\n    # Set up the min profile. We use complemented intervals to maintain the\n    # complement of the work load, and fixed intervals to enforce the min\n    # number of active workers per time period.\n    #\n    # Note that this works only if the max load cumulative is also added to the\n    # model.\n    time_period_min_intervals = model.new_fixed_size_interval_var_series(\n        name=\"time_period_min_intervals\",\n        index=min_load_df.index,\n        starts=min_load_df.start_hour * minutes_per_hour,\n        sizes=minutes_per_hour * 2,\n    )\n    time_period_min_heights = min_load_df.min_load\n\n    # We take into account optional intervals. The actual capacity of the min load\n    # cumulative is the sum of all the active demands.\n    sum_of_demands = sum(tasks_df.load)\n    complement_capacity = model.new_int_var(0, sum_of_demands, \"complement_capacity\")\n    model.add(complement_capacity == performed.dot(tasks_df.load))\n\n    # Cumulative constraint for the min profile.\n    model.add_cumulative(\n        prefix_intervals.to_list()\n        + suffix_intervals.to_list()\n        + time_period_min_intervals.to_list(),\n        tasks_df.load.to_list()\n        + tasks_df.load.to_list()\n        + time_period_min_heights.to_list(),\n        complement_capacity,\n    )\n\n    # Objective: maximize the value of performed intervals.\n    # 1 is the max priority.\n    max_priority = max(tasks_df.priority)\n    model.maximize(sum(performed * (max_priority + 1 - tasks_df.priority)))\n\n    # Create the solver and solve the model.\n    solver = cp_model.CpSolver()\n    # solver.parameters.log_search_progress = True  # Uncomment to see the logs.\n    solver.parameters.num_workers = 16\n    solver.parameters.max_time_in_seconds = 30.0\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        start_values = solver.values(starts)\n        performed_values = solver.boolean_values(performed)\n        tasks: list[tuple[int, int, int]] = []\n        for task in tasks_df.index:\n            if performed_values[task]:\n                print(\n                    f'task {task} duration={tasks_df[\"duration\"][task]} '\n                    f'load={tasks_df[\"load\"][task]} starts at {start_values[task]}'\n                )\n                tasks.append(\n                    (start_values[task], tasks_df.duration[task], tasks_df.load[task])\n                )\n            else:\n                print(f\"task {task} is not performed\")\n        assert check_solution(\n            tasks=tasks,\n            min_load_df=min_load_df,\n            max_load_df=max_load_df,\n            period_length=2 * minutes_per_hour,\n            horizon=horizon,\n        )\n    elif status == cp_model.INFEASIBLE:\n        print(\"No solution found\")\n    else:\n        print(\"Something is wrong, check the status and the log of the solve\")\n```\n\n----------------------------------------\n\nTITLE: Implementing the ranking_sample_sat Function\nDESCRIPTION: This function demonstrates ranking tasks in a NoOverlap constraint using the CP-SAT solver. It sets up a CP model, defines tasks with start, end, and interval variables (some optional), adds a NoOverlap constraint, links tasks and ranks using the `rank_tasks` function, adds constraints on ranks, minimizes makespan while considering performed tasks, and prints the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/ranking_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"def ranking_sample_sat() -> None:\n    \\\"\\\"\\\"Ranks tasks in a NoOverlap constraint.\\\"\\\"\\\"    model = cp_model.CpModel()\n    horizon = 100\n    num_tasks = 4\n    all_tasks = range(num_tasks)\n\n    starts = []\n    ends = []\n    intervals = []\n    presences: list[cp_model.BoolVarT] = []\n    ranks = []\n\n    # Creates intervals, half of them are optional.\n    for t in all_tasks:\n        start = model.new_int_var(0, horizon, f\\\"start[{t}]\\\")\n        duration = t + 1\n        end = model.new_int_var(0, horizon, f\\\"end[{t}]\\\")\n        if t < num_tasks // 2:\n            interval = model.new_interval_var(start, duration, end, f\\\"interval[{t}]\\\")\n            presence = model.new_constant(1)\n        else:\n            presence = model.new_bool_var(f\\\"presence[{t}]\\\")\n            interval = model.new_optional_interval_var(\n                start, duration, end, presence, f\\\"o_interval[{t}]\\\"\n            )\n        starts.append(start)\n        ends.append(end)\n        intervals.append(interval)\n        presences.append(presence)\n\n        # Ranks = -1 if and only if the tasks is not performed.\n        ranks.append(model.new_int_var(-1, num_tasks - 1, f\\\"rank[{t}]\\\"))\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds ranking constraint.\n    rank_tasks(model, starts, presences, ranks)\n\n    # Adds a constraint on ranks.\n    model.add(ranks[0] < ranks[1])\n\n    # Creates makespan variable.\n    makespan = model.new_int_var(0, horizon, \\\"makespan\\\")\n    for t in all_tasks:\n        model.add(ends[t] <= makespan).only_enforce_if(presences[t])\n\n    # Minimizes makespan - fixed gain per tasks performed.\n    # As the fixed cost is less that the duration of the last interval,\n    # the solver will not perform the last interval.\n    model.minimize(2 * makespan - 7 * sum(presences[t] for t in all_tasks))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Prints out the makespan and the start times and ranks of all tasks.\n        print(f\\\"Optimal cost: {solver.objective_value}\\\")\n        print(f\\\"Makespan: {solver.value(makespan)}\\\")\n        for t in all_tasks:\n            if solver.value(presences[t]):\n                print(\n                    f\\\"Task {t} starts at {solver.value(starts[t])} \\\"\\\n                    f\\\"with rank {solver.value(ranks[t])}\\\"\\\n                )\n            else:\n                print(\n                    f\\\"Task {t} in not performed and ranked at {solver.value(ranks[t])}\\\"\\\n                )\n    else:\n        print(f\\\"Solver exited with nonoptimal status: {status}\\\")\n\n\nranking_sample_sat()\n\"\n```\n\n----------------------------------------\n\nTITLE: Initializing CP-SAT Model and Variables for Shift Scheduling in Python\nDESCRIPTION: This snippet initializes the CP-SAT model and creates boolean variables for each employee, shift, and day combination. It also sets up the objective variables for the optimization problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/shift_scheduling_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nnum_days = num_weeks * 7\nnum_shifts = len(shifts)\n\nmodel = cp_model.CpModel()\n\nwork = {}\nfor e in range(num_employees):\n    for s in range(num_shifts):\n        for d in range(num_days):\n            work[e, s, d] = model.new_bool_var(f\"work{e}_{s}_{d}\")\n\n# Linear terms of the objective in a minimization context.\nobj_int_vars: list[cp_model.IntVar] = []\nobj_int_coeffs: list[int] = []\nobj_bool_vars: list[cp_model.BoolVarT] = []\nobj_bool_coeffs: list[int] = []\n```\n\n----------------------------------------\n\nTITLE: Implementing AllDifferentExcept0 constraint with OR-Tools\nDESCRIPTION: This code implements the AllDifferentExcept0 constraint using the OR-Tools SAT solver. It creates integer variables, defines the AllDifferentExcept0 constraint by ensuring that non-zero values are distinct, and maximizes the sum of the variables, while also ensuring variables x[0] and x[1] are set to zero. The CpSolver is then used to solve the model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/all_different_except_zero_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"import collections\\n\\nfrom ortools.sat.python import cp_model\\n\\n\\ndef all_different_except_0():\\n    \\\"\\\"\\\"Encode the AllDifferentExcept0 constraint.\\\"\\\"\\\"\\n\\n    # Model.\\n    model = cp_model.CpModel()\\n\\n    # Declare our primary variable.\\n    x = [model.new_int_var(0, 10, f\\\"x{i}\\\") for i in range(5)]\\n\\n    # Expand the AllDifferentExcept0 constraint.\\n    variables_per_value = collections.defaultdict(list)\\n    all_values = set()\\n\\n    for var in x:\\n        all_encoding_literals = []\\n        # Domains of variables are represented by flat intervals.\\n        for i in range(0, len(var.proto.domain), 2):\\n            start = var.proto.domain[i]\\n            end = var.proto.domain[i + 1]\\n            for value in range(start, end + 1):  # Intervals are inclusive.\\n                # Create the literal attached to var == value.\\n                bool_var = model.new_bool_var(f\\\"{var} == {value}\\\")\\n                model.add(var == value).only_enforce_if(bool_var)\\n\\n                # Collect all encoding literals for a given variable.\\n                all_encoding_literals.append(bool_var)\\n\\n                # Collect all encoding literals for a given value.\\n                variables_per_value[value].append(bool_var)\\n\\n                # Collect all different values.\\n                all_values.add(value)\\n\\n        # One variable must have exactly one value.\\n        model.add_exactly_one(all_encoding_literals)\\n\\n    # Add the all_different constraints.\\n    for value, literals in variables_per_value.items():\\n        if value == 0:\\n            continue\\n        model.add_at_most_one(literals)\\n\\n    model.add(x[0] == 0)\\n    model.add(x[1] == 0)\\n\\n    model.maximize(sum(x))\\n\\n    # Create a solver and solve.\\n    solver = cp_model.CpSolver()\\n    status = solver.solve(model)\\n\\n    # Checks and prints the output.\\n    if status == cp_model.OPTIMAL:\\n        print(f\\\"Optimal solution: {solver.objective_value}, expected: 27.0\\\")\\n    elif status == cp_model.FEASIBLE:\\n        print(f\\\"Feasible solution: {solver.objective_value}, optimal 27.0\\\")\\n    elif status == cp_model.INFEASIBLE:\\n        print(\\\"The model is infeasible\\\")\\n    else:\\n        print(\\\"Something went wrong. Please check the status and the log\\\")\\n\\n\\nall_different_except_0()\\n\"\n```\n\n----------------------------------------\n\nTITLE: Solution Hinting Implementation in Python\nDESCRIPTION: Demonstrates how to implement solution hinting in Python using OR-Tools CP-SAT solver. Creates variables with constraints, adds solution hints, and maximizes an objective function using x, y, and z variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample that solves a model using solution hinting.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef solution_hinting_sample_sat():\n    \"\"\"Showcases solution hinting.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    model.maximize(x + 2 * y + 3 * z)\n\n    # Solution hinting: x <- 1, y <- 2\n    model.add_hint(x, 1)\n    model.add_hint(y, 2)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    solution_printer = cp_model.VarArrayAndObjectiveSolutionPrinter([x, y, z])\n    status = solver.solve(model, solution_printer)\n\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n\n\nsolution_hinting_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Golomb Ruler Problem Solution Implementation\nDESCRIPTION: Main implementation of the Golomb ruler problem solver using OR-Tools. Creates a constraint satisfaction problem with size 8, sets up constraints for unique differences between marks, and finds optimal solutions while minimizing the ruler length. Includes solution collection and performance statistics output.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/golomb8.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n# We disable the following warning because it is a false positive on constraints\n# like: solver.Add(x == 0)\n# pylint: disable=g-explicit-bool-comparison\n\n\ndef main(_) -> None:\n    # Create the solver.\n    solver = pywrapcp.Solver(\"golomb ruler\")\n\n    size = 8\n    var_max = size * size\n    all_vars = list(range(0, size))\n\n    marks = [solver.IntVar(0, var_max, \"marks_%d\" % i) for i in all_vars]\n\n    objective = solver.Minimize(marks[size - 1], 1)\n\n    solver.Add(marks[0] == 0)\n\n    # We expand the creation of the diff array to avoid a pylint warning.\n    diffs = []\n    for i in range(size - 1):\n        for j in range(i + 1, size):\n            diffs.append(marks[j] - marks[i])\n    solver.Add(solver.AllDifferent(diffs))\n\n    solver.Add(marks[size - 1] - marks[size - 2] > marks[1] - marks[0])\n    for i in range(size - 2):\n        solver.Add(marks[i + 1] > marks[i])\n\n    solution = solver.Assignment()\n    solution.Add(marks[size - 1])\n    collector = solver.AllSolutionCollector(solution)\n\n    solver.Solve(\n        solver.Phase(marks, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE),\n        [objective, collector],\n    )\n    for i in range(0, collector.SolutionCount()):\n        obj_value = collector.Value(i, marks[size - 1])\n        time = collector.WallTime(i)\n        branches = collector.Branches(i)\n        failures = collector.Failures(i)\n        print(\n            (\"Solution #%i: value = %i, failures = %i, branches = %i,\" \"time = %i ms\")\n            % (i, obj_value, failures, branches, time)\n        )\n    time = solver.WallTime()\n    branches = solver.Branches()\n    failures = solver.Failures()\n    print(\n        (\n            \"Total run : failures = %i, branches = %i, time = %i ms\"\n            % (failures, branches, time)\n        )\n    )\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solution Callback for School Scheduling with CP-SAT in Python\nDESCRIPTION: A callback class that extends CpSolverSolutionCallback to track and display solutions found during the solving process. It prints each solution's number and objective value when the solver finds a valid solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass SchoolSchedulingSatSolutionPrinter(cp_model.CpSolverSolutionCallback):\n\n    def __init__(self):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n\n    def OnSolutionCallback(self):\n        print(\n            f'Solution #{self.__solution_count}, objective: {self.ObjectiveValue()}'\n        )\n        self.__solution_count += 1\n```\n\n----------------------------------------\n\nTITLE: Main Vehicle Routing Problem Solver\nDESCRIPTION: Main function that sets up and solves the vehicle routing problem using Google OR-Tools. Includes configuration of the routing model, distance constraints, node dropping, and optimization parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    num_nodes = len(DISTANCE_MATRIX)\n    print(f'Num nodes = {num_nodes}')\n    num_vehicles = 1\n    depot = 0\n    all_nodes = range(num_nodes)\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n            num_nodes,\n            num_vehicles,\n            depot)\n\n    # Create routing model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return DISTANCE_MATRIX[from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Limit Vehicle distance.\n    dimension_name = 'Distance'\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        MAX_DISTANCE,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name)\n\n    # Allow to drop nodes.\n    for node in range(1, num_nodes):\n        routing.AddDisjunction(\n                [manager.NodeToIndex(node)],\n                VISIT_VALUES[node])\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH)\n    search_parameters.time_limit.FromSeconds(15)\n\n    # Solve the problem.\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if assignment:\n        print_solution(manager, routing, assignment)\n```\n\n----------------------------------------\n\nTITLE: Solving Nonogram Puzzle with OR-Tools\nDESCRIPTION: Main function to solve the Nonogram puzzle using OR-Tools. It sets up the constraints, applies the rules, and searches for solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main(rows, row_rule_len, row_rules, cols, col_rule_len, col_rules):\n\n  solver = pywrapcp.Solver('Regular test')\n\n  board = {}\n  for i in range(rows):\n    for j in range(cols):\n      board[i, j] = solver.IntVar(1, 2, 'board[%i, %i]' % (i, j))\n  board_flat = [board[i, j] for i in range(rows) for j in range(cols)]\n\n  board_label = []\n  if rows * row_rule_len < cols * col_rule_len:\n    for i in range(rows):\n      for j in range(cols):\n        board_label.append(board[i, j])\n  else:\n    for j in range(cols):\n      for i in range(rows):\n        board_label.append(board[i, j])\n\n  for i in range(rows):\n    check_rule([row_rules[i][j] for j in range(row_rule_len)],\n               [board[i, j] for j in range(cols)])\n\n  for j in range(cols):\n    check_rule([col_rules[j][k] for k in range(col_rule_len)],\n               [board[i, j] for i in range(rows)])\n\n  db = solver.Phase(board_label, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print()\n    num_solutions += 1\n    for i in range(rows):\n      row = [board[i, j].Value() - 1 for j in range(cols)]\n      row_pres = []\n      for j in row:\n        if j == 1:\n          row_pres.append('#')\n        else:\n          row_pres.append(' ')\n      print('  ', ''.join(row_pres))\n\n    print()\n    print('  ', '-' * cols)\n\n    if num_solutions >= 2:\n      print('2 solutions is enough...')\n      break\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n```\n\n----------------------------------------\n\nTITLE: Validating Scheduling Solution Against Min/Max Load Constraints\nDESCRIPTION: Function that checks if a scheduling solution satisfies the minimum and maximum load constraints at each time point. It calculates actual load profiles and compares them against the defined constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef check_solution(\n    tasks: list[tuple[int, int, int]],\n    min_load_df: pd.DataFrame,\n    max_load_df: pd.DataFrame,\n    period_length: int,\n    horizon: int,\n) -> bool:\n    \"\"\"Checks the solution validity against the min and max load constraints.\"\"\"\n    minutes_per_hour = 60\n    actual_load_profile = [0 for _ in range(horizon)]\n    min_load_profile = [0 for _ in range(horizon)]\n    max_load_profile = [0 for _ in range(horizon)]\n\n    # The complexity of the checker is linear in the number of time points, and\n    # should be improved.\n    for task in tasks:\n        for t in range(task[1]):\n            actual_load_profile[task[0] + t] += task[2]\n    for row in max_load_df.itertuples():\n        for t in range(period_length):\n            max_load_profile[row.start_hour * minutes_per_hour + t] = row.max_load\n    for row in min_load_df.itertuples():\n        for t in range(period_length):\n            min_load_profile[row.start_hour * minutes_per_hour + t] = row.min_load\n\n    for time in range(horizon):\n        if actual_load_profile[time] > max_load_profile[time]:\n            print(\n                f\"actual load {actual_load_profile[time]} at time {time} is greater\"\n                f\" than max load {max_load_profile[time]}\"\n            )\n            return False\n        if actual_load_profile[time] < min_load_profile[time]:\n            print(\n                f\"actual load {actual_load_profile[time]} at time {time} is\"\n                f\" less than min load {min_load_profile[time]}\"\n            )\n            return False\n    return True\n```\n\n----------------------------------------\n\nTITLE: Implementing 3 Jugs Problem Solver using MIP in Python\nDESCRIPTION: Defines the main function that sets up and solves the 3 jugs problem using Mixed Integer Programming. It includes data initialization, variable creation, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_mip.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef main(sol='CBC'):\n  # Create the solver.\n  print('Solver: ', sol)\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  #\n  # data\n  #\n  n = 15\n  start = 0  # start node\n  end = 14  # end node\n  M = 999  # a large number\n\n  nodes = [\n      '8,0,0',  # start\n      '5,0,3',\n      '5,3,0',\n      '2,3,3',\n      '2,5,1',\n      '7,0,1',\n      '7,1,0',\n      '4,1,3',\n      '3,5,0',\n      '3,2,3',\n      '6,2,0',\n      '6,0,2',\n      '1,5,2',\n      '1,4,3',\n      '4,4,0'  # goal!\n  ]\n\n  # distance\n  d = [[M, 1, M, M, M, M, M, M, 1, M, M, M, M, M, M],\n       [M, M, 1, M, M, M, M, M, M, M, M, M, M, M, M],\n       [M, M, M, 1, M, M, M, M, 1, M, M, M, M, M, M],\n       [M, M, M, M, 1, M, M, M, M, M, M, M, M, M, M],\n       [M, M, M, M, M, 1, M, M, 1, M, M, M, M, M, M],\n       [M, M, M, M, M, M, 1, M, M, M, M, M, M, M, M],\n       [M, M, M, M, M, M, M, 1, 1, M, M, M, M, M, M],\n       [M, M, M, M, M, M, M, M, M, M, M, M, M, M, 1],\n       [M, M, M, M, M, M, M, M, M, 1, M, M, M, M, M],\n       [M, 1, M, M, M, M, M, M, M, M, 1, M, M, M, M],\n       [M, M, M, M, M, M, M, M, M, M, M, 1, M, M, M],\n       [M, 1, M, M, M, M, M, M, M, M, M, M, 1, M, M],\n       [M, M, M, M, M, M, M, M, M, M, M, M, M, 1, M],\n       [M, 1, M, M, M, M, M, M, M, M, M, M, M, M, 1],\n       [M, M, M, M, M, M, M, M, M, M, M, M, M, M, M]]\n\n  #\n  # variables\n  #\n\n  # requirements (right hand statement)\n  rhs = [solver.IntVar(-1, 1, 'rhs[%i]' % i) for i in range(n)]\n\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[i, j] = solver.IntVar(0, 1, 'x[%i,%i]' % (i, j))\n\n  out_flow = [solver.IntVar(0, 1, 'out_flow[%i]' % i) for i in range(n)]\n  in_flow = [solver.IntVar(0, 1, 'in_flow[%i]' % i) for i in range(n)]\n\n  # length of path, to be minimized\n  z = solver.Sum(\n      [d[i][j] * x[i, j] for i in range(n) for j in range(n) if d[i][j] < M])\n\n  #\n  # constraints\n  #\n\n  for i in range(n):\n    if i == start:\n      solver.Add(rhs[i] == 1)\n    elif i == end:\n      solver.Add(rhs[i] == -1)\n    else:\n      solver.Add(rhs[i] == 0)\n\n  # outflow constraint\n  for i in range(n):\n    solver.Add(\n        out_flow[i] == solver.Sum([x[i, j] for j in range(n) if d[i][j] < M]))\n\n  # inflow constraint\n  for j in range(n):\n    solver.Add(\n        in_flow[j] == solver.Sum([x[i, j] for i in range(n) if d[i][j] < M]))\n\n  # inflow = outflow\n  for i in range(n):\n    solver.Add(out_flow[i] - in_flow[i] == rhs[i])\n\n  # objective\n  objective = solver.Minimize(z)\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n  print('z: ', int(solver.Objective().Value()))\n\n  t = start\n  while t != end:\n    print(nodes[t], '->', end=' ')\n    for j in range(n):\n      if x[t, j].SolutionValue() == 1:\n        print(nodes[j])\n        t = j\n        break\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n```\n\n----------------------------------------\n\nTITLE: Solving Steel Mill Slab Problem with Valid Slabs in Python\nDESCRIPTION: This function solves the Steel Mill Slab Problem using a constraint programming model with pre-generated valid slabs. It includes symmetry breaking constraints and uses the OR-Tools CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef steel_mill_slab_with_valid_slabs(problem_id: int, break_symmetries: bool) -> None:\n    \"\"\"Solves the Steel Mill Slab Problem.\"\"\"\n    ### Load problem.\n    (num_slabs, capacities, num_colors, orders) = build_problem(problem_id)\n\n    num_orders = len(orders)\n    num_capacities = len(capacities)\n    all_slabs = range(num_slabs)\n    all_colors = range(num_colors)\n    all_orders = range(len(orders))\n    print(\n        f\"Solving steel mill with {num_orders} orders, {num_slabs} slabs, and\"\n        f\" {num_capacities - 1} capacities\"\n    )\n\n    # Compute auxiliary data.\n    widths = [x[0] for x in orders]\n    colors = [x[1] for x in orders]\n    max_capacity = max(capacities)\n    loss_array = [\n        min(x for x in capacities if x >= c) - c for c in range(max_capacity + 1)\n    ]\n    max_loss = max(loss_array)\n\n    ### Model problem.\n\n    # Create the model and the decision variables.\n    model = cp_model.CpModel()\n    assign = [\n        [model.new_bool_var(r\"assign_{o}_to_slab_{s}\") for s in all_slabs]\n        for o in all_orders\n    ]\n    loads = [model.new_int_var(0, max_capacity, f\"load_{s}\") for s in all_slabs]\n    losses = [model.new_int_var(0, max_loss, f\"loss_{s}\") for s in all_slabs]\n\n    unsorted_valid_slabs = collect_valid_slabs_dp(\n        capacities, colors, widths, loss_array\n    )\n    # Sort slab by descending load/loss. Remove duplicates.\n    valid_slabs = sorted(unsorted_valid_slabs, key=lambda c: 1000 * c[-1] + c[-2])\n\n    for s in all_slabs:\n        model.add_allowed_assignments(\n            [assign[o][s] for o in all_orders] + [losses[s], loads[s]], valid_slabs\n        )\n\n    # Orders are assigned to one slab.\n    for o in all_orders:\n        model.add_exactly_one(assign[o])\n\n    # Redundant constraint (sum of loads == sum of widths).\n    model.add(sum(loads) == sum(widths))\n\n    # Symmetry breaking.\n    for s in range(num_slabs - 1):\n        model.add(loads[s] >= loads[s + 1])\n\n    # Collect equivalent orders.\n    if break_symmetries:\n        print(\"Breaking symmetries\")\n        width_to_unique_color_order = {}\n        ordered_equivalent_orders = []\n        orders_per_color = [\n            [o for o in all_orders if colors[o] == c + 1] for c in all_colors\n        ]\n        for c in all_colors:\n            colored_orders = orders_per_color[c]\n            if not colored_orders:\n                continue\n            if len(colored_orders) == 1:\n                o = colored_orders[0]\n                w = widths[o]\n                if w not in width_to_unique_color_order:\n                    width_to_unique_color_order[w] = [o]\n                else:\n                    width_to_unique_color_order[w].append(o)\n            else:\n                local_width_to_order = {}\n                for o in colored_orders:\n                    w = widths[o]\n                    if w not in local_width_to_order:\n                        local_width_to_order[w] = []\n                        local_width_to_order[w].append(o)\n                for _, os in local_width_to_order.items():\n                    if len(os) > 1:\n                        for p in range(len(os) - 1):\n                            ordered_equivalent_orders.append((os[p], os[p + 1]))\n        for _, os in width_to_unique_color_order.items():\n            if len(os) > 1:\n                for p in range(len(os) - 1):\n                    ordered_equivalent_orders.append((os[p], os[p + 1]))\n\n        # Create position variables if there are symmetries to be broken.\n        if ordered_equivalent_orders:\n            print(\n                f\"  - creating {len(ordered_equivalent_orders)} symmetry breaking\"\n                \" constraints\"\n            )\n            positions = {}\n            for p in ordered_equivalent_orders:\n                if p[0] not in positions:\n                    positions[p[0]] = model.new_int_var(\n                        0, num_slabs - 1, f\"position_of_slab_{p[0]}\"\n                    )\n                    model.add_map_domain(positions[p[0]], assign[p[0]])\n                if p[1] not in positions:\n                    positions[p[1]] = model.new_int_var(\n                        0, num_slabs - 1, f\"position_of_slab_{p[1]}\"\n                    )\n                    model.add_map_domain(positions[p[1]], assign[p[1]])\n                    # Finally add the symmetry breaking constraint.\n                model.add(positions[p[0]] <= positions[p[1]])\n\n    # Objective.\n    model.minimize(sum(losses))\n\n    print(\"Model created\")\n\n    ### Solve model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n\n    solution_printer = SteelMillSlabSolutionPrinter(orders, assign, loads, losses)\n    status = solver.solve(model, solution_printer)\n\n    ### Output the solution.\n    if status == cp_model.OPTIMAL:\n        print(\n            f\"Loss = {solver.objective_value}, time = {solver.wall_time:2f} s,\"\n            f\" {solver.num_conflicts} conflicts\"\n        )\n    else:\n        print(\"No solution\")\n```\n\n----------------------------------------\n\nTITLE: Olympic Puzzle Solver Implementation\nDESCRIPTION: Main implementation of the Olympic puzzle solver using Google OR-Tools constraint programming solver. The code creates a triangular configuration of 10 variables with constraints on absolute differences between adjacent numbers. It includes variable declaration, constraint definition, and solution search logic.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/olympic.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef minus(solver, x, y, z):\n  solver.Add(z == abs(x - y))\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Olympic')\n\n  #\n  # data\n  #\n  n = 10\n\n  #\n  # declare variables\n  #\n  Vars = [solver.IntVar(1, n, 'Vars[%i]' % i) for i in range(n)]\n  X1, X2, X3, X4, X5, X6, X7, X8, X9, X10 = Vars\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(Vars))\n\n  solver.Add(X1 == 3)\n  minus(solver, X2, X3, X1)\n  minus(solver, X4, X5, X2)\n  minus(solver, X5, X6, X3)\n  minus(solver, X7, X8, X4)\n  minus(solver, X8, X9, X5)\n  minus(solver, X9, X10, X6)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(Vars, solver.INT_VAR_SIMPLE, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('Vars:', [Vars[i].Value() for i in range(n)])\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving VRP with Breaks Using OR-Tools in Python\nDESCRIPTION: Implements the main function to solve the VRP with breaks, including routing model setup, adding time windows and break constraints, and solving the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_breaks_from_start.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Solve the VRP with time windows.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"time_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def time_callback(from_index, to_index):\n        \"\"\"Returns the travel time between the two nodes.\"\"\"\n        # Convert from routing variable Index to time matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"time_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(time_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Time Windows constraint.\n    time = \"Time\"\n    routing.AddDimension(\n        transit_callback_index,\n        10,  # need optional waiting time to place break\n        180,  # maximum time per vehicle\n        False,  # Don't force start cumul to zero.\n        time,\n    )\n    time_dimension = routing.GetDimensionOrDie(time)\n    time_dimension.SetGlobalSpanCostCoefficient(10)\n\n    # Each vehicle start with a 15min delay\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        index = routing.Start(vehicle_id)\n        time_dimension.CumulVar(index).SetValue((vehicle_id + 1) * 15)\n\n    # Add breaks\n    # warning: Need a pre-travel array using the solver's index order.\n    node_visit_transit = [0] * routing.Size()\n    for index in range(routing.Size()):\n        node = manager.IndexToNode(index)\n        node_visit_transit[index] = data[\"service_time\"][node]\n\n    # Add a break lasting 5 minutes, start between 25 and 45 minutes after route start\n    for v in range(manager.GetNumberOfVehicles()):\n        start_var = time_dimension.CumulVar(routing.Start(v))\n        break_start = routing.solver().Sum([routing.solver().IntVar(25, 45), start_var])\n\n        break_intervals = [\n            routing.solver().FixedDurationIntervalVar(\n                break_start, 5, f\"Break for vehicle {v}\"\n            )\n        ]\n        time_dimension.SetBreakIntervalsOfVehicle(\n            break_intervals, v, node_visit_transit\n        )\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    # search_parameters.log_search = True\n    search_parameters.time_limit.FromSeconds(2)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Solution Callback for CP-SAT in Python\nDESCRIPTION: Defines a custom solution callback class that inherits from cp_model.CpSolverSolutionCallback to print intermediate solutions during the optimization process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solve_and_print_intermediate_solutions_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass VarArrayAndObjectiveSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        print(f\"Solution {self.__solution_count}\")\n        print(f\"  objective value = {self.objective_value}\")\n        for v in self.__variables:\n            print(f\"  {v}={self.value(v)}\", end=\" \")\n        print()\n        self.__solution_count += 1\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n```\n\n----------------------------------------\n\nTITLE: Using Assumptions to Explain Infeasibility in Python\nDESCRIPTION: Python code sample demonstrating how to use assumptions to diagnose the root cause of infeasibility in a CP-SAT model. The example creates constraints with enforcement literals and adds them to the set of assumptions to identify which constraints contribute to the infeasibility.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/troubleshooting.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample that solves a model and gets the infeasibility assumptions.\"\"\"\nfrom ortools.sat.python import cp_model\n\n\ndef main() -> None:\n    \"\"\"Showcases assumptions.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    x = model.new_int_var(0, 10, \"x\")\n    y = model.new_int_var(0, 10, \"y\")\n    z = model.new_int_var(0, 10, \"z\")\n    a = model.new_bool_var(\"a\")\n    b = model.new_bool_var(\"b\")\n    c = model.new_bool_var(\"c\")\n\n    # Creates the constraints.\n    model.add(x > y).only_enforce_if(a)\n    model.add(y > z).only_enforce_if(b)\n    model.add(z > x).only_enforce_if(c)\n\n    # Add assumptions\n    model.add_assumptions([a, b, c])\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Print solution.\n    print(f\"Status = {solver.status_name(status)}\")\n    if status == cp_model.INFEASIBLE:\n        print(\n            \"sufficient_assumptions_for_infeasibility = \"\n            f\"{solver.sufficient_assumptions_for_infeasibility()}\"\n        )\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Solving Steel Mill Slab Problem\nDESCRIPTION: The function loads and solves the Steel Mill Slab problem using the CpModel from OR-Tools. It defines constraints and objectives in the solver model to find optimal allocations for minimizing slab losses.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef steel_mill_slab(problem_id: int, break_symmetries: bool) -> None:\n    \"\"\"Solves the Steel Mill Slab Problem.\"\"\"\n    ### Load problem.\n    num_slabs, capacities, num_colors, orders = build_problem(problem_id)\n\n    num_orders = len(orders)\n    num_capacities = len(capacities)\n    all_slabs = range(num_slabs)\n    all_colors = range(num_colors)\n    all_orders = range(len(orders))\n    print(\n        f\"Solving steel mill with {num_orders} orders, {num_slabs} slabs, and\"\n        f\" {num_capacities - 1} capacities\"\n    )\n\n    # Compute auxiliary data.\n    widths = [x[0] for x in orders]\n    colors = [x[1] for x in orders]\n    max_capacity = max(capacities)\n    loss_array = [\n        min(x for x in capacities if x >= c) - c for c in range(max_capacity + 1)\n    ]\n    max_loss = max(loss_array)\n    orders_per_color = [\n        [o for o in all_orders if colors[o] == c + 1] for c in all_colors\n    ]\n    unique_color_orders = [\n        o for o in all_orders if len(orders_per_color[colors[o] - 1]) == 1\n    ]\n\n    ### Model problem.\n\n    # Create the model and the decision variables.\n    model = cp_model.CpModel()\n    assign = [\n        [model.new_bool_var(f\"assign_{o}_to_slab_{s}\") for s in all_slabs]\n        for o in all_orders\n    ]\n    loads = [model.new_int_var(0, max_capacity, f\"load_of_slab_{s}\") for s in all_slabs]\n    color_is_in_slab = [\n        [model.new_bool_var(f\"color_{c + 1}_in_slab_{s}\") for c in all_colors]\n        for s in all_slabs\n    ]\n\n    # Compute load of all slabs.\n    for s in all_slabs:\n        model.add(sum(assign[o][s] * widths[o] for o in all_orders) == loads[s])\n\n    # Orders are assigned to one slab.\n    for o in all_orders:\n        model.add_exactly_one(assign[o])\n\n    # Redundant constraint (sum of loads == sum of widths).\n    model.add(sum(loads) == sum(widths))\n\n    # Link present_colors and assign.\n    for c in all_colors:\n        for s in all_slabs:\n            for o in orders_per_color[c]:\n                model.add_implication(assign[o][s], color_is_in_slab[s][c])\n                model.add_implication(~color_is_in_slab[s][c], ~assign[o][s])\n\n    # At most two colors per slab.\n    for s in all_slabs:\n        model.add(sum(color_is_in_slab[s]) <= 2)\n\n    # Project previous constraint on unique_color_orders\n    for s in all_slabs:\n        model.add(sum(assign[o][s] for o in unique_color_orders) <= 2)\n\n    # Symmetry breaking.\n    for s in range(num_slabs - 1):\n        model.add(loads[s] >= loads[s + 1])\n\n    # Collect equivalent orders.\n    width_to_unique_color_order = {}\n    ordered_equivalent_orders = []\n    for c in all_colors:\n        colored_orders = orders_per_color[c]\n        if not colored_orders:\n            continue\n        if len(colored_orders) == 1:\n            o = colored_orders[0]\n            w = widths[o]\n            if w not in width_to_unique_color_order:\n                width_to_unique_color_order[w] = [o]\n            else:\n                width_to_unique_color_order[w].append(o)\n        else:\n            local_width_to_order = {}\n            for o in colored_orders:\n                w = widths[o]\n                if w not in local_width_to_order:\n                    local_width_to_order[w] = []\n                local_width_to_order[w].append(o)\n            for _, os in local_width_to_order.items():\n                if len(os) > 1:\n                    for p in range(len(os) - 1):\n                        ordered_equivalent_orders.append((os[p], os[p + 1]))\n    for _, os in width_to_unique_color_order.items():\n        if len(os) > 1:\n            for p in range(len(os) - 1):\n                ordered_equivalent_orders.append((os[p], os[p + 1]))\n\n    # Create position variables if there are symmetries to be broken.\n    if break_symmetries and ordered_equivalent_orders:\n        print(\n            f\"  - creating {len(ordered_equivalent_orders)} symmetry breaking\"\n            \" constraints\"\n        )\n        positions = {}\n        for p in ordered_equivalent_orders:\n            if p[0] not in positions:\n                positions[p[0]] = model.new_int_var(\n\n```\n\n----------------------------------------\n\nTITLE: Solving N-Queens Problem with Constraint Programming\nDESCRIPTION: Complete implementation of the N-queens problem solver using OR-Tools. The solver creates variables for each queen's position, adds constraints to ensure no queens threaten each other, and finds all possible solutions. It displays each solution as a board visualization and outputs statistics about the solving process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/nqueens_cp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\n\ndef main(board_size):\n    # Creates the solver.\n    solver = pywrapcp.Solver(\"n-queens\")\n\n    # Creates the variables.\n    # The array index is the column, and the value is the row.\n    queens = [solver.IntVar(0, board_size - 1, f\"x{i}\") for i in range(board_size)]\n\n    # Creates the constraints.\n    # All rows must be different.\n    solver.Add(solver.AllDifferent(queens))\n\n    # No two queens can be on the same diagonal.\n    solver.Add(solver.AllDifferent([queens[i] + i for i in range(board_size)]))\n    solver.Add(solver.AllDifferent([queens[i] - i for i in range(board_size)]))\n\n    db = solver.Phase(queens, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n    # Iterates through the solutions, displaying each.\n    num_solutions = 0\n    solver.NewSearch(db)\n    while solver.NextSolution():\n        # Displays the solution just computed.\n        for i in range(board_size):\n            for j in range(board_size):\n                if queens[j].Value() == i:\n                    # There is a queen in column j, row i.\n                    print(\"Q\", end=\" \")\n                else:\n                    print(\"_\", end=\" \")\n            print()\n        print()\n        num_solutions += 1\n    solver.EndSearch()\n\n    # Statistics.\n    print(\"\\nStatistics\")\n    print(f\"  failures: {solver.Failures()}\")\n    print(f\"  branches: {solver.Branches()}\")\n    print(f\"  wall time: {solver.WallTime()} ms\")\n    print(f\"  Solutions found: {num_solutions}\")\n\n\n# By default, solve the 8x8 problem.\nsize = 8\nif len(sys.argv) > 1:\n    size = int(sys.argv[1])\nmain(size)\n```\n\n----------------------------------------\n\nTITLE: Solving SEND+MORE=MONEY Cryptarithm using CP-SAT\nDESCRIPTION: Implements a constraint programming solution for the SEND+MORE=MONEY cryptarithmetic puzzle. Creates variables for each letter with appropriate domains, defines carry variables, and adds constraints for column-wise addition and all-different values. Uses OR-Tools CP-SAT solver to find the optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cryptarithm_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef send_more_money() -> None:\n    \"\"\"solve the cryptarithmic puzzle SEND+MORE=MONEY.\"\"\"\n    model = cp_model.CpModel()\n\n    # Create variables.\n    # Since s is a leading digit, it can't be 0.\n    s = model.new_int_var(1, 9, \"s\")\n    e = model.new_int_var(0, 9, \"e\")\n    n = model.new_int_var(0, 9, \"n\")\n    d = model.new_int_var(0, 9, \"d\")\n    # Since m is a leading digit, it can't be 0.\n    m = model.new_int_var(1, 9, \"m\")\n    o = model.new_int_var(0, 9, \"o\")\n    r = model.new_int_var(0, 9, \"r\")\n    y = model.new_int_var(0, 9, \"y\")\n\n    # Create carry variables. c0 is true if the first column of addends carries\n    # a 1, c2 is true if the second column carries a 1, and so on.\n    c0 = model.new_bool_var(\"c0\")\n    c1 = model.new_bool_var(\"c1\")\n    c2 = model.new_bool_var(\"c2\")\n    c3 = model.new_bool_var(\"c3\")\n\n    # Force all letters to take on different values.\n    model.add_all_different(s, e, n, d, m, o, r, y)\n\n    # Column 0:\n    model.add(c0 == m)\n\n    # Column 1:\n    model.add(c1 + s + m == o + 10 * c0)\n\n    # Column 2:\n    model.add(c2 + e + o == n + 10 * c1)\n\n    # Column 3:\n    model.add(c3 + n + r == e + 10 * c2)\n\n    # Column 4:\n    model.add(d + e == y + 10 * c3)\n\n    # solve model.\n    solver = cp_model.CpSolver()\n    if solver.solve(model) == cp_model.OPTIMAL:\n        print(\"Optimal solution found!\")\n    print(\"s:\", solver.value(s))\n    print(\"e:\", solver.value(e))\n    print(\"n:\", solver.value(n))\n    print(\"d:\", solver.value(d))\n    print(\"m:\", solver.value(m))\n    print(\"o:\", solver.value(o))\n    print(\"r:\", solver.value(r))\n    print(\"y:\", solver.value(y))\n\n\ndef main(_) -> None:\n    send_more_money()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Solution Hinting in CP-SAT Solver\nDESCRIPTION: This function demonstrates how to use solution hinting in the CP-SAT solver. It creates a model with three variables, adds constraints and an objective function, and then uses solution hinting to guide the solver. Finally, it solves the model and prints the results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solution_hinting_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef solution_hinting_sample_sat():\n    \"\"\"Showcases solution hinting.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    model.maximize(x + 2 * y + 3 * z)\n\n    # Solution hinting: x <- 1, y <- 2\n    model.add_hint(x, 1)\n    model.add_hint(y, 2)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    solution_printer = cp_model.VarArrayAndObjectiveSolutionPrinter([x, y, z])\n    status = solver.solve(model, solution_printer)\n\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n\n\nsolution_hinting_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: N-Queens Problem Solver Implementation\nDESCRIPTION: Main implementation of the N-Queens problem solver using OR-Tools constraint solver. The program creates constraints to ensure queens cannot attack each other horizontally, vertically, or diagonally, then searches for all valid solutions. It includes visualization of the solutions and performance metrics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nqueens2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=8):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n  # n = 8 # size of board (n x n)\n\n  # declare variables\n  q = [solver.IntVar(0, n - 1, \"x%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(q))\n  for i in range(n):\n    for j in range(i):\n      solver.Add(q[i] != q[j])\n      solver.Add(q[i] + i != q[j] + j)\n      solver.Add(q[i] - i != q[j] - j)\n\n  # for i in range(n):\n  #     for j in range(i):\n  #         solver.Add(abs(q[i]-q[j]) != abs(i-j))\n\n  # symmetry breaking\n  # solver.Add(q[0] == 0)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([q[i] for i in range(n)])\n\n  # db: DecisionBuilder\n  db = solver.Phase(\n      [q[i] for i in range(n)],\n      # solver.CHOOSE_FIRST_UNBOUND,\n      solver.CHOOSE_MIN_SIZE_LOWEST_MAX,\n      solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    qval = [q[i].Value() for i in range(n)]\n    print(\"q:\", qval)\n    for i in range(n):\n      for j in range(n):\n        if qval[i] == j:\n          print(\"Q\", end=\" \")\n        else:\n          print(\"_\", end=\" \")\n      print()\n    print()\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 8\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Matchup Constraints with Google OR-Tools in Python\nDESCRIPTION: This snippet configures matchups constraints for a sports league season using the CP-SAT solver from Google OR-Tools. It ensures that matchups comply with specified parameters, managing games played between teams, and applying hard and soft constraints to team pairings based on energy matches per section.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\npossible_days.append(fixtures[d][t][opponent])\nif matchups % 2 == 0 and matchups_exact:\n    model.Add(sum(possible_days) == fixture_repeats)\nelse:\n    model.Add(sum(possible_days) <= fixture_repeats)\n```\n\n----------------------------------------\n\nTITLE: Resource Constraint and Objective Function Setup in OR-Tools for Project Scheduling\nDESCRIPTION: This snippet sets up resource constraints for different types of resources (renewable, non-renewable, consumer-producer) and defines the objective function based on the problem type (resource investment or makespan minimization).\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Containers for resource investment problems.\ncapacities = []  # Capacity variables for all resources.\nmax_cost = 0  # Upper bound on the investment cost.\n\n# Create resources.\nfor res in all_resources:\n    resource = problem.resources[res]\n    c = resource.max_capacity\n    if c == -1:\n        print(f\"No capacity: {resource}\")\n        c = resource_to_sum_of_demand_max[res]\n\n    # RIP problems have only renewable resources, and no makespan.\n    if problem.is_resource_investment or resource.renewable:\n        intervals = [task_intervals[t] for t in all_active_tasks]\n        demands = [task_to_resource_demands[t][res] for t in all_active_tasks]\n\n        if problem.is_resource_investment:\n            capacity = model.new_int_var(0, c, f\"capacity_of_{res}\")\n            model.add_cumulative(intervals, demands, capacity)\n            capacities.append(capacity)\n            max_cost += c * resource.unit_cost\n        else:  # Standard renewable resource.\n            if _USE_INTERVAL_MAKESPAN.value:\n                intervals.append(interval_makespan)\n                demands.append(c)\n\n            model.add_cumulative(intervals, demands, c)\n    else:  # Non empty non renewable resource. (single mode only)\n        if problem.is_consumer_producer:\n            reservoir_starts = []\n            reservoir_demands = []\n            for t in all_active_tasks:\n                if task_resource_to_fixed_demands[(t, res)][0]:\n                    reservoir_starts.append(task_starts[t])\n                    reservoir_demands.append(\n                        task_resource_to_fixed_demands[(t, res)][0]\n                    )\n            model.add_reservoir_constraint(\n                reservoir_starts,\n                reservoir_demands,\n                resource.min_capacity,\n                resource.max_capacity,\n            )\n        else:  # No producer-consumer. We just sum the demands.\n            model.add(\n                cp_model.LinearExpr.sum(\n                    [task_to_resource_demands[t][res] for t in all_active_tasks]\n                )\n                <= c\n            )\n\n# Objective.\nif problem.is_resource_investment:\n    objective = model.new_int_var(0, max_cost, \"capacity_costs\")\n    model.add(\n        objective\n        == sum(\n            problem.resources[i].unit_cost * capacities[i]\n            for i in range(len(capacities))\n        )\n    )\nelse:\n    objective = makespan\n\nmodel.minimize(objective)\n```\n\n----------------------------------------\n\nTITLE: Solving Steel Mill Slab Problem with Column Generation in Python\nDESCRIPTION: This function solves the Steel Mill Slab Problem using a column generation approach. It generates all valid slabs and then uses a constraint programming model to select the optimal combination of slabs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndef steel_mill_slab_with_column_generation(problem_id: int) -> None:\n    \"\"\"Solves the Steel Mill Slab Problem.\"\"\"\n    ### Load problem.\n    (num_slabs, capacities, _, orders) = build_problem(problem_id)\n\n    num_orders = len(orders)\n    num_capacities = len(capacities)\n    all_orders = range(len(orders))\n    print(\n        f\"Solving steel mill with {num_orders} orders, {num_slabs} slabs, and\"\n        f\" {num_capacities - 1} capacities\"\n    )\n\n    # Compute auxiliary data.\n    widths = [x[0] for x in orders]\n    colors = [x[1] for x in orders]\n    max_capacity = max(capacities)\n    loss_array = [\n        min(x for x in capacities if x >= c) - c for c in range(max_capacity + 1)\n    ]\n\n    ### Model problem.\n\n    # Generate all valid slabs (columns)\n    unsorted_valid_slabs = collect_valid_slabs_dp(\n        capacities, colors, widths, loss_array\n    )\n\n    # Sort slab by descending load/loss. Remove duplicates.\n    valid_slabs = sorted(unsorted_valid_slabs, key=lambda c: 1000 * c[-1] + c[-2])\n    all_valid_slabs = range(len(valid_slabs))\n\n    # create model and decision variables.\n    model = cp_model.CpModel()\n    selected = [model.new_bool_var(f\"selected_{i}\") for i in all_valid_slabs]\n\n    for order_id in all_orders:\n        model.add(\n            sum(selected[i] for i, slab in enumerate(valid_slabs) if slab[order_id])\n            == 1\n        )\n\n    # Redundant constraint (sum of loads == sum of widths).\n    model.add(\n        sum(selected[i] * valid_slabs[i][-1] for i in all_valid_slabs) == sum(widths)\n    )\n\n    # Objective.\n    model.minimize(sum(selected[i] * valid_slabs[i][-2] for i in all_valid_slabs))\n\n    print(\"Model created\")\n\n    ### Solve model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n    solution_printer = cp_model.ObjectiveSolutionPrinter()\n    status = solver.solve(model, solution_printer)\n\n    ### Output the solution.\n    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n        print(\n```\n\n----------------------------------------\n\nTITLE: Implementing Quasigroup Completion Solver in Python\nDESCRIPTION: This code implements the main logic for solving the Quasigroup completion problem. It uses the OR-Tools constraint solver to define variables, set constraints, and search for solutions. The solver can handle custom input puzzles or use a default puzzle.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/quasigroup_completion.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\ndefault_n = 5\nX = 0\n# default problem\n# (This is the same as quasigroup1.txt)\ndefault_puzzle = [[1, X, X, X, 4], [X, 5, X, X, X], [4, X, X, 2, X],\n                  [X, 4, X, X, X], [X, X, 5, X, 1]]\n\n\ndef main(puzzle=\"\", n=0):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Quasigroup completion\")\n\n  #\n  # data\n  #\n\n  if puzzle == \"\":\n    puzzle = default_puzzle\n    n = default_n\n\n  print(\"Problem:\")\n  print_game(puzzle, n, n)\n\n  # declare variables\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(1, n, \"x %i %i\" % (i, j))\n\n  xflat = [x[(i, j)] for i in range(n) for j in range(n)]\n\n  #\n  # constraints\n  #\n\n  #\n  # set the clues\n  #\n  for i in range(n):\n    for j in range(n):\n      if puzzle[i][j] > X:\n        solver.Add(x[i, j] == puzzle[i][j])\n\n  #\n  # rows and columns must be different\n  #\n  for i in range(n):\n    solver.Add(solver.AllDifferent([x[i, j] for j in range(n)]))\n    solver.Add(solver.AllDifferent([x[j, i] for j in range(n)]))\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(xflat)\n\n  # This version prints out the solution directly, and\n  # don't collect them as solver.FirstSolutionCollector(solution) do\n  # (db: DecisionBuilder)\n  db = solver.Phase(xflat, solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"Solution %i\" % num_solutions)\n    xval = [x[(i, j)].Value() for i in range(n) for j in range(n)]\n    for i in range(n):\n      for j in range(n):\n        print(xval[i * n + j], end=\" \")\n      print()\n    print()\n  solver.EndSearch()\n\n  if num_solutions == 0:\n    print(\"No solutions found\")\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\n#\n# Read a problem instance from a file\n#\ndef read_problem(file):\n  f = open(file, \"r\")\n  n = int(f.readline())\n  game = []\n  for i in range(n):\n    x = f.readline()\n    row_x = (x.rstrip()).split(\" \")\n    row = [0] * n\n    for j in range(n):\n      if row_x[j] == \".\":\n        tmp = 0\n      else:\n        tmp = int(row_x[j])\n      row[j] = tmp\n    game.append(row)\n  return [game, n]\n\n\ndef print_board(x, rows, cols):\n  for i in range(rows):\n    for j in range(cols):\n      print(\"% 2s\" % x[i, j], end=\" \")\n    print(\"\")\n\n\ndef print_game(game, rows, cols):\n  for i in range(rows):\n    for j in range(cols):\n      print(\"% 2s\" % game[i][j], end=\" \")\n    print(\"\")\n\n\n\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  print(\"Problem instance from\", file)\n  [game, n] = read_problem(file)\n  main(game, n)\nelse:\n  main()\n```\n\n----------------------------------------\n\nTITLE: Task and Resource Variable Creation in OR-Tools for Project Scheduling\nDESCRIPTION: This snippet creates variables and constraints for tasks, including start times, end times, durations, and resource demands. It handles multiple recipes per task and sets up the necessary constraints for each resource type.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfor t in all_active_tasks:\n    task = problem.tasks[t]\n    num_recipes = len(task.recipes)\n    all_recipes = range(num_recipes)\n\n    start_var = model.new_int_var(0, horizon, f\"start_of_task_{t}\")\n    end_var = model.new_int_var(0, horizon, f\"end_of_task_{t}\")\n\n    literals = []\n    if num_recipes > 1:\n        # Create one literal per recipe.\n        literals = [model.new_bool_var(f\"is_present_{t}_{r}\") for r in all_recipes]\n\n        # Exactly one recipe must be performed.\n        model.add_exactly_one(literals)\n\n    else:\n        literals = [1]\n\n    # Temporary data structure to fill in 0 demands.\n    demand_matrix = collections.defaultdict(int)\n\n    # Scan recipes and build the demand matrix and the vector of durations.\n    for recipe_index, recipe in enumerate(task.recipes):\n        task_to_recipe_durations[t].append(recipe.duration)\n        for demand, resource in zip(recipe.demands, recipe.resources):\n            demand_matrix[(resource, recipe_index)] = demand\n\n    # Create the duration variable from the accumulated durations.\n    duration_var = model.new_int_var_from_domain(\n        cp_model.Domain.from_values(task_to_recipe_durations[t]),\n        f\"duration_of_task_{t}\",\n    )\n\n    # Link the recipe literals and the duration_var.\n    for r in range(num_recipes):\n        model.add(duration_var == task_to_recipe_durations[t][r]).only_enforce_if(\n            literals[r]\n        )\n\n    # Create the interval of the task.\n    task_interval = model.new_interval_var(\n        start_var, duration_var, end_var, f\"task_interval_{t}\"\n    )\n\n    # Store task variables.\n    task_starts[t] = start_var\n    task_ends[t] = end_var\n    task_durations[t] = duration_var\n    task_intervals[t] = task_interval\n    task_to_presence_literals[t] = literals\n\n    # Create the demand variable of the task for each resource.\n    for res in all_resources:\n        demands = [demand_matrix[(res, recipe)] for recipe in all_recipes]\n        task_resource_to_fixed_demands[(t, res)] = demands\n        demand_var = model.new_int_var_from_domain(\n            cp_model.Domain.from_values(demands), f\"demand_{t}_{res}\"\n        )\n        task_to_resource_demands[t].append(demand_var)\n\n        # Link the recipe literals and the demand_var.\n        for r in all_recipes:\n            model.add(demand_var == demand_matrix[(res, r)]).only_enforce_if(\n                literals[r]\n            )\n\n        resource_to_sum_of_demand_max[res] += max(demands)\n\n    # Create the energy expression for (task, resource):\n    for res in all_resources:\n        task_resource_to_energy[(t, res)] = sum(\n            literals[r]\n            * task_to_recipe_durations[t][r]\n            * task_resource_to_fixed_demands[(t, res)][r]\n            for r in all_recipes\n        )\n        task_resource_to_max_energy[(t, res)] = max(\n            task_to_recipe_durations[t][r]\n            * task_resource_to_fixed_demands[(t, res)][r]\n            for r in all_recipes\n        )\n```\n\n----------------------------------------\n\nTITLE: Machine Constraints and Transition Setup with Circuit Constraint in Python\nDESCRIPTION: Implements machine constraints to prevent overlapping tasks on the same machine and begins setting up transition times and costs using a circuit constraint approach. Handles task sequencing and machine availability constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n  #----------------------------------------------------------------------------\n  # Create machines constraints nonoverlap process\n  for machine_id in all_machines:\n    intervals = intervals_per_machines[machine_id]\n    if len(intervals) > 1:\n      model.AddNoOverlap(intervals)\n\n  #----------------------------------------------------------------------------\n  # Transition times and transition costs using a circuit constraint.\n  switch_literals = []\n  for machine_id in all_machines:\n    machine_starts = starts_per_machines[machine_id]\n    machine_ends = ends_per_machines[machine_id]\n    machine_presences = presences_per_machines[machine_id]\n    machine_resources = resources_per_machines[machine_id]\n    machine_ranks = ranks_per_machines[machine_id]\n    intervals = intervals_per_machines[machine_id]\n    arcs = []\n    num_machine_tasks = len(machine_starts)\n    all_machine_tasks = range(num_machine_tasks)\n\n    for i in all_machine_tasks:\n      # Initial arc from the dummy node (0) to a task.\n      start_lit = model.NewBoolVar('')\n      arcs.append([0, i + 1, start_lit])\n      # If this task is the first, set both rank and start to 0.\n      model.Add(machine_ranks[i] == 0).OnlyEnforceIf(start_lit)\n      model.Add(machine_starts[i] == 0).OnlyEnforceIf(start_lit)\n      # Final arc from an arc to the dummy node.\n      arcs.append([i + 1, 0, model.NewBoolVar('')])\n      # Self arc if the task is not performed.\n      arcs.append([i + 1, i + 1, machine_presences[i].Not()])\n      model.Add(machine_ranks[i] == -1).OnlyEnforceIf(\n```\n\n----------------------------------------\n\nTITLE: Bin Packing Optimization with OR-Tools in Python\nDESCRIPTION: Implements a bin packing problem using OR-Tools, demonstrating how to maximize the number of bins that can accept emergency loads. Uses channeling constraints to link load and slack variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Solves a binpacking problem using the CP-SAT solver.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef binpacking_problem_sat():\n    \"\"\"Solves a bin-packing problem using the CP-SAT solver.\"\"\"\n    # Data.\n    bin_capacity = 100\n    slack_capacity = 20\n    num_bins = 5\n    all_bins = range(num_bins)\n\n    items = [(20, 6), (15, 6), (30, 4), (45, 3)]\n    num_items = len(items)\n    all_items = range(num_items)\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Main variables.\n    x = {}\n    for i in all_items:\n        num_copies = items[i][1]\n        for b in all_bins:\n            x[(i, b)] = model.new_int_var(0, num_copies, f\"x[{i},{b}]\")\n\n    # Load variables.\n    load = [model.new_int_var(0, bin_capacity, f\"load[{b}]\") for b in all_bins]\n\n    # Slack variables.\n    slacks = [model.new_bool_var(f\"slack[{b}]\") for b in all_bins]\n\n    # Links load and x.\n    for b in all_bins:\n        model.add(load[b] == sum(x[(i, b)] * items[i][0] for i in all_items))\n\n    # Place all items.\n    for i in all_items:\n        model.add(sum(x[(i, b)] for b in all_bins) == items[i][1])\n\n    # Links load and slack through an equivalence relation.\n    safe_capacity = bin_capacity - slack_capacity\n    for b in all_bins:\n        # slack[b] => load[b] <= safe_capacity.\n        model.add(load[b] <= safe_capacity).only_enforce_if(slacks[b])\n        # not(slack[b]) => load[b] > safe_capacity.\n        model.add(load[b] > safe_capacity).only_enforce_if(~slacks[b])\n\n    # Maximize sum of slacks.\n    model.maximize(sum(slacks))\n\n    # Solves and prints out the solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n    print(f\"solve status: {solver.status_name(status)}\")\n    if status == cp_model.OPTIMAL:\n        print(f\"Optimal objective value: {solver.objective_value}\")\n    print(\"Statistics\")\n    print(f\"  - conflicts : {solver.num_conflicts}\")\n    print(f\"  - branches  : {solver.num_branches}\")\n    print(f\"  - wall time : {solver.wall_time}s\")\n\n\nbinpacking_problem_sat()\n```\n\n----------------------------------------\n\nTITLE: Defining Subset Sum Constraints in Python\nDESCRIPTION: Creates a function that sets up the constraints for the subset sum problem using the OR-Tools solver. It defines variables and adds constraints for the sum of selected items and their total value.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/subset_sum.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef subset_sum(solver, values, total):\n  n = len(values)\n  x = [solver.IntVar(0, n) for i in range(n)]\n  ss = solver.IntVar(0, n)\n\n  solver.Add(ss == solver.Sum(x))\n  solver.Add(total == solver.ScalProd(x, values))\n\n  return x, ss\n```\n\n----------------------------------------\n\nTITLE: Checking Scheduling Solution Validity in Python\nDESCRIPTION: This function verifies that the calculated task schedule adheres to the min and max load constraints, outputting True if valid and False otherwise. Inputs include task details and load dataframes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cumulative_variable_profile_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"def check_solution(\\n    tasks: list[tuple[int, int, int]],\\n    min_load_df: pd.DataFrame,\\n    max_load_df: pd.DataFrame,\\n    period_length: int,\\n    horizon: int,\\n) -\\u003e bool:\\n    \\\"\\\"\\\"Checks the solution validity against the min and max load constraints.\\u0022\\u0022\\u0022\\n    minutes_per_hour = 60\\n    actual_load_profile = [0 for _ in range(horizon)]\\n    min_load_profile = [0 for _ in range(horizon)]\\n    max_load_profile = [0 for _ in range(horizon)]\\n\\n    # The complexity of the checker is linear in the number of time points, and\\n    # should be improved.\\n    for task in tasks:\\n        for t in range(task[1]):\\n            actual_load_profile[task[0] + t] += task[2]\\n    for row in max_load_df.itertuples():\\n        for t in range(period_length):\\n            max_load_profile[row.start_hour * minutes_per_hour + t] = row.max_load\\n    for row in min_load_df.itertuples():\\n        for t in range(period_length):\\n            min_load_profile[row.start_hour * minutes_per_hour + t] = row.min_load\\n\\n    for time in range(horizon):\\n        if actual_load_profile[time] \\u003e max_load_profile[time]:\\n            print(\\n                f\\\"actual load {actual_load_profile[time]} at time {time} is greater\\\"\\n                f\\\" than max load {max_load_profile[time]}\\\"\\n            )\\n            return False\\n        if actual_load_profile[time] \\u003c min_load_profile[time]:\\n            print(\\n                f\\\"actual load {actual_load_profile[time]} at time {time} is\\\"\\n                f\\\" less than min load {min_load_profile[time]}\\\"\\n            )\\n            return False\\n    return True\\n\"\n```\n\n----------------------------------------\n\nTITLE: Maximizing Valid Combinations of Boolean Variables using CP-SAT Solver\nDESCRIPTION: Implements a function that creates a CP-SAT model to maximize the number of valid combinations of Boolean variables. The model selects a fixed number of cards from a set to maximize the number of valid card combinations.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/maximize_combinations_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\ndef maximize_combinations_sat() -> None:\n    \"\"\"Maximize the number of valid combinations of Boolean variables.\"\"\"\n    model = cp_model.CpModel()\n    cards: list[cp_model.IntVar] = [\n        model.new_bool_var(\"card1\"),\n        model.new_bool_var(\"card2\"),\n        model.new_bool_var(\"card3\"),\n        model.new_bool_var(\"card4\"),\n    ]\n\n    combos: list[list[cp_model.IntVar]] = [\n        [cards[0], cards[1]],\n        [cards[0], cards[2]],\n        [cards[1], cards[3]],\n        [cards[0], cards[2], cards[3]],\n    ]\n\n    deck_size: int = 3\n    model.add(sum(cards) == deck_size)\n\n    valid_combos: list[cp_model.IntVar] = []\n    for combination in combos:\n        is_valid = model.new_bool_var(\"\")\n\n        # All true implies is_valid.\n        model.add_bool_and(is_valid).only_enforce_if(combination)\n\n        # is_valid implies all true.\n        for literal in combination:\n            model.add_implication(is_valid, literal)\n        valid_combos.append(is_valid)\n\n    model.maximize(sum(valid_combos))\n\n    solver = cp_model.CpSolver()\n    solver.parameters.log_search_progress = True\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(\n            \"chosen cards:\",\n            [card.name for card in cards if solver.boolean_value(card)],\n        )\n\n\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    maximize_combinations_sat()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Main Function for Cutting Stock Problem in Python\nDESCRIPTION: Main function that calls either the CP-SAT or MIP solver based on the provided command-line argument _SOLVER.value. It serves as the entry point for the application.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef main(_):\n    \"\"\"Main function.\"\"\"\n    if _SOLVER.value == \"sat\":\n        solve_cutting_stock_with_arc_flow_and_sat(_OUTPUT_PROTO.value, _PARAMS.value)\n    else:  # 'mip'\n        solve_cutting_stock_with_arc_flow_and_mip()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Channeling Constraints in Go with OR-Tools\nDESCRIPTION: Demonstrates how to implement channeling constraints using OR-Tools in Go. The program creates relationships between variables using boolean constraints and shows how to channel between different variable types.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// The channeling_sample_sat command is a simple example of a channeling constraint.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc channelingSampleSat() error {\n\t// Create the CP-SAT model.\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\t// Declare our two primary variables.\n\tx := model.NewIntVar(0, 10)\n\ty := model.NewIntVar(0, 10)\n\n\t// Declare our intermediate Boolean variable.\n\tb := model.NewBoolVar()\n\n\t// Implement b == (x > 5).\n\tmodel.AddGreaterOrEqual(x, cpmodel.NewConstant(5)).OnlyEnforceIf(b)\n\tmodel.AddLessThan(x, model.NewConstant(5)).OnlyEnforceIf(b.Not())\n\n\t// Create our two half-reified constraints.\n\t// First, b implies (y == 10 - x).\n\tmodel.AddEquality(cpmodel.NewLinearExpr().Add(x).Add(y), cpmodel.NewConstant(10)).OnlyEnforceIf(b)\n\t// Second, b.Not() implies (y == 0).\n\tmodel.AddEquality(y, cpmodel.NewConstant(0)).OnlyEnforceIf(b.Not())\n\n\t// Search for x values in increasing order.\n\tmodel.AddDecisionStrategy([]cpmodel.IntVar{x}, cmpb.DecisionStrategyProto_CHOOSE_FIRST, cmpb.DecisionStrategyProto_SELECT_MIN_VALUE)\n\n\t// Create a solver and solve with a fixed search.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tparams := &sppb.SatParameters{\n\t\tFillAdditionalSolutionsInResponse: proto.Bool(true),\n\t\tEnumerateAllSolutions:             proto.Bool(true),\n\t\tSolutionPoolSize:                  proto.Int32(11),\n\t\tSearchBranching:                   sppb.SatParameters_FIXED_SEARCH.Enum(),\n\t}\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Printf(\"Status: %v\\n\", response.GetStatus())\n\n\tfor _, additionalSolution := range response.GetAdditionalSolutions() {\n\t\tvs := additionalSolution.GetValues()\n\t\tfmt.Printf(\"x: %v y: %v b: %v\\n\", vs[x.Index()], vs[y.Index()], vs[b.Index()])\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := channelingSampleSat(); err != nil {\n\t\tlog.Exitf(\"channelingSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Cryptarithmetic Puzzle with OR-Tools Constraint Solver\nDESCRIPTION: This code sets up and solves the cryptarithmetic puzzle CP + IS + FUN = TRUE using OR-Tools. It defines variables for each letter, sets constraints, and finds all solutions in base 10.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cp_is_fun_cp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n    # Constraint programming engine\n    solver = pywrapcp.Solver(\"CP is fun!\")\n\n    base = 10\n\n    # Decision variables.\n    digits = list(range(0, base))\n    digits_without_zero = list(range(1, base))\n    c = solver.IntVar(digits_without_zero, \"C\")\n    p = solver.IntVar(digits, \"P\")\n    i = solver.IntVar(digits_without_zero, \"I\")\n    s = solver.IntVar(digits, \"S\")\n    f = solver.IntVar(digits_without_zero, \"F\")\n    u = solver.IntVar(digits, \"U\")\n    n = solver.IntVar(digits, \"N\")\n    t = solver.IntVar(digits_without_zero, \"T\")\n    r = solver.IntVar(digits, \"R\")\n    e = solver.IntVar(digits, \"E\")\n\n    # We need to group variables in a list to use the constraint AllDifferent.\n    letters = [c, p, i, s, f, u, n, t, r, e]\n\n    # Verify that we have enough digits.\n    assert base >= len(letters)\n\n    # Define constraints.\n    solver.Add(solver.AllDifferent(letters))\n\n    # CP + IS + FUN = TRUE\n    solver.Add(\n        p + s + n + base * (c + i + u) + base * base * f\n        == e + base * u + base * base * r + base * base * base * t\n    )\n\n    solution_count = 0\n    db = solver.Phase(letters, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n    solver.NewSearch(db)\n    while solver.NextSolution():\n        print(letters)\n        # Is CP + IS + FUN = TRUE?\n        assert (\n            base * c.Value()\n            + p.Value()\n            + base * i.Value()\n            + s.Value()\n            + base * base * f.Value()\n            + base * u.Value()\n            + n.Value()\n            == base * base * base * t.Value()\n            + base * base * r.Value()\n            + base * u.Value()\n            + e.Value()\n        )\n        solution_count += 1\n    solver.EndSearch()\n    print(f\"Number of solutions found: {solution_count}\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Jobshop Scheduling Problem with CP-SAT\nDESCRIPTION: Implementation of a jobshop scheduling solver for the ft06 benchmark problem using CP-SAT. The code defines the job durations and machine sequences, creates interval variables for tasks, adds disjunctive constraints for machines, and minimizes the makespan (total schedule length).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/cp_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef JobshopFT06():\n  \"\"\"Solves the ft06 jobshop from the jssp library.\n  (http://people.brunel.ac.uk/~mastjjb/jeb/orlib/jobshopinfo.html).\"\"\"\n\n  # Creates the solver.\n  model = cp_model.CpModel()\n\n  machines_count = 6\n  jobs_count = 6\n  all_machines = range(0, machines_count)\n  all_jobs = range(0, jobs_count)\n\n  durations = [[1, 3, 6, 7, 3, 6],\n               [8, 5, 10, 10, 10, 4],\n               [5, 4, 8, 9, 1, 7],\n               [5, 5, 5, 3, 8, 9],\n               [9, 3, 5, 4, 3, 1],\n               [3, 3, 9, 10, 4, 1]]\n\n  machines = [[2, 0, 1, 3, 5, 4],\n              [1, 2, 4, 5, 0, 3],\n              [2, 3, 5, 0, 1, 4],\n              [1, 0, 2, 3, 4, 5],\n              [2, 1, 4, 5, 0, 3],\n              [1, 3, 5, 0, 4, 2]]\n\n  # Computes horizon dynamically.\n  horizon = sum([sum(durations[i]) for i in all_jobs])\n\n  # Creates jobs.\n  all_tasks = {}\n  for i in all_jobs:\n    for j in all_machines:\n      start = model.NewIntVar(0, horizon, 'start_%i_%i' % (i, j))\n      duration = durations[i][j]\n      end = model.NewIntVar(0, horizon, 'end_%i_%i' % (i, j))\n      interval = model.NewIntervalVar(start, duration, end,\n                                      'interval_%i_%i' % (i, j))\n      all_tasks[(i, j)] = (start, end, interval)\n\n  # Create disjunctive constraints.\n  for i in all_machines:\n    machines_jobs = []\n    for j in all_jobs:\n      for k in all_machines:\n        if machines[j][k] == i:\n          machines_jobs.append(all_tasks[(j, k)][2])\n    model.AddNoOverlap(machines_jobs)\n\n  # Makespan objective: minimize the total length of the schedule.\n  obj_var = model.NewIntVar(0, horizon, 'makespan')\n  model.AddMaxEquality(\n      obj_var, [all_tasks[(i, machines_count - 1)][1] for i in all_jobs])\n  model.Minimize(obj_var)\n\n  # Precedences inside a job.\n  for i in all_jobs:\n    for j in range(0, machines_count - 1):\n      model.Add(all_tasks[(i, j + 1)][0] >= all_tasks[(i, j)][1])\n\n  solver = cp_model.CpSolver()\n  solver.parameters.log_search_progress = True\n  response = solver.Solve(model)\n  starts = [[solver.Value(all_tasks[(i, j)][0]) for j in all_machines]\n            for i in all_jobs]\n  visualization.DisplayJobshop(starts, durations, machines, 'FT06')\n\n\nJobshopFT06()\n```\n\n----------------------------------------\n\nTITLE: Ensuring Shift Coverage by Drivers\nDESCRIPTION: Adds constraints to ensure each shift is covered by exactly one driver, and globally each node has exactly one incoming and one outgoing literal in the circuit constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Each shift is covered.\nfor s in range(num_shifts):\n    model.add_exactly_one(performed[d, s] for d in range(num_drivers))\n    # Globally, each node has one incoming and one outgoing literal\n    model.add_exactly_one(shared_incoming_literals[s])\n    model.add_exactly_one(shared_outgoing_literals[s])\n```\n\n----------------------------------------\n\nTITLE: Implementing SchoolSchedulingSatSolver Class in Python\nDESCRIPTION: This class creates and solves the school scheduling problem using the CP-SAT solver. It defines variables, constraints, and methods to print the resulting schedules for teachers and classes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass SchoolSchedulingSatSolver():\n    '''Solver instance.'''\n\n    def __init__(self, problem: SchoolSchedulingProblem):\n        # Problem\n        self._problem = problem\n\n        # Utilities\n        num_levels = len(self._problem.levels)\n        self._all_levels = range(num_levels)\n        num_sections = len(self._problem.sections)\n        self._all_sections = range(num_sections)\n        num_subjects = len(self._problem.subjects)\n        self._all_subjects = range(num_subjects)\n        num_teachers = len(self._problem.teachers)\n        self._all_teachers = range(num_teachers)\n        num_slots = len(self._problem.time_slots)\n        self._all_slots = range(num_slots)\n\n        # Create Model\n        self._model = cp_model.CpModel()\n\n        # Create Variables\n        self._assignment = {}\n        for lvl_idx, level in enumerate(self._problem.levels):\n            for sec_idx, section in enumerate(self._problem.sections):\n                for sub_idx, subject in enumerate(self._problem.subjects):\n                    for tch_idx, teacher in enumerate(self._problem.teachers):\n                        for slt_idx, slot in enumerate(self._problem.time_slots):\n                            key = (lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx)\n                            name = f'{level}-{section} S:{subject} T:{teacher} Slot:{slot}'\n                            #print(name)\n                            if teacher in self._problem.specialtie_teachers(subject):\n                                self._assignment[key] = self._model.NewBoolVar(name)\n                            else:\n                                name = 'NO DISP ' + name\n                                self._assignment[key] = self._model.NewIntVar(0, 0, name)\n\n        # Constraints\n        # Each Level-Section must have the quantity of classes per Subject specified in the Curriculum\n        for lvl_idx, level in enumerate(self._problem.levels):\n            for sec_idx in self._all_sections:\n                for sub_idx, subject in enumerate(self._problem.subjects):\n                    required_duration = self._problem.curriculum[level, subject]\n                    #print(f'L:{level} S:{subject} duration:{required_duration}h')\n                    self._model.Add(\n                        sum(self._assignment[lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx] *\n                            int(self._problem.slot_duration(slt_idx) * 10)\n                            for tch_idx in self._all_teachers\n                            for slt_idx in self._all_slots) == int(required_duration * 10))\n\n        # Each Level-Section can do at most one class at a time\n        for lvl_idx in self._all_levels:\n            for sec_idx in self._all_sections:\n                for slt_idx in self._all_slots:\n                    self._model.Add(\n                        sum([\n                            self._assignment[lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx]\n                            for sub_idx in self._all_subjects\n                            for tch_idx in self._all_teachers\n                        ]) <= 1)\n\n        # Teacher can do at most one class at a time\n        for tch_idx in self._all_teachers:\n            for slt_idx in self._all_slots:\n                self._model.Add(\n                    sum([\n                        self._assignment[lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx]\n                        for lvl_idx in self._all_levels\n                        for sec_idx in self._all_sections\n                        for sub_idx in self._all_subjects\n                    ]) <= 1)\n\n        # Maximum work hours for each teacher\n        for tch_idx in self._all_teachers:\n            self._model.Add(\n                sum([\n                    self._assignment[lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx] *\n                    int(self._problem.slot_duration(slt_idx) * 10)\n                    for lvl_idx in self._all_levels\n                    for sec_idx in self._all_sections\n                    for sub_idx in self._all_subjects\n                    for slt_idx in self._all_slots\n                ]) <= int(self._problem.teacher_max_hours(tch_idx) * 10))\n\n        # Teacher makes all the classes of a subject's course\n        teacher_courses = {}\n        for lvl_idx, level in enumerate(self._problem.levels):\n            for sec_idx, section in enumerate(self._problem.sections):\n                for sub_idx, subject in enumerate(self._problem.subjects):\n                    for tch_idx, teacher in enumerate(self._problem.teachers):\n                        name = f'{level}-{section} S:{subject} T:{teacher}'\n                        teacher_courses[lvl_idx, sec_idx, sub_idx, tch_idx] = self._model.NewBoolVar(name)\n                        temp_array = [\n                            self._assignment[lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx]\n                            for slt_idx in self._all_slots\n                        ]\n                        self._model.AddMaxEquality(\n                            teacher_courses[lvl_idx, sec_idx, sub_idx, tch_idx], temp_array)\n                    self._model.Add(\n                        sum([teacher_courses[lvl_idx, sec_idx, sub_idx, tch_idx]\n                             for tch_idx in self._all_teachers\n                        ]) == 1)\n\n\n    def print_teacher_schedule(self, tch_idx):\n        teacher_name = self._problem.teacher_name(tch_idx)\n        print(f'Teacher: {teacher_name}')\n        total_working_hours = 0\n        for slt_idx, slot in enumerate(self._problem.time_slots):\n            for lvl_idx, level in enumerate(self._problem.levels):\n                for sec_idx, section in enumerate(self._problem.sections):\n                    for sub_idx, subject in enumerate(self._problem.subjects):\n                        key = (lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx)\n                        if self._solver.BooleanValue(self._assignment[key]):\n                            total_working_hours += self._problem.slot_duration(slt_idx)\n                            print(f'{slot}: C:{level}-{section} S:{subject}')\n        print(f'Total working hours: {total_working_hours}h')\n\n\n    def print_class_schedule(self, lvl_idx, sec_idx):\n        level = self._problem.levels[lvl_idx]\n        section = self._problem.sections[sec_idx]\n        print(f'Class: {level}-{section}')\n        total_working_hours = {}\n        for sub in self._problem.subjects:\n            total_working_hours[sub] = 0\n        for slt_idx, slot in enumerate(self._problem.time_slots):\n            for tch_idx, teacher in enumerate(self._problem.teachers):\n                for sub_idx, subject in enumerate(self._problem.subjects):\n                    key = (lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx)\n                    if self._solver.BooleanValue(self._assignment[key]):\n                        total_working_hours[subject] += self._problem.slot_duration(slt_idx)\n                        print(f'{slot}: S:{subject} T:{teacher}')\n        for (subject, hours) in total_working_hours.items():\n            print(f'Total working hours for {subject}: {hours}h')\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Performance Constraints in OR-Tools CP-SAT Model\nDESCRIPTION: Sets up constraints for when a node (shift) is not performed by a driver, including setting driving times to 0 and managing incoming/outgoing literals for the circuit constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Node not performed\n#    - set both driving times to 0\n#    - add a looping arc on the node\nmodel.add(total_driving[d, s] == 0).only_enforce_if(~performed[d, s])\nmodel.add(no_break_driving[d, s] == 0).only_enforce_if(~performed[d, s])\nincoming_literals[s].append(~performed[d, s])\noutgoing_literals[s].append(~performed[d, s])\n# negated adding to the shared lists, because, globally, each node will\n# have one incoming literal, and one outgoing literal.\n```\n\n----------------------------------------\n\nTITLE: Reading ALB Problem File\nDESCRIPTION: Function to read and parse a .alb file containing assembly line balancing problem definition. It parses different sections of the file including task times, precedence relations, and cycle time constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef read_problem(filename: str) -> Dict[str, SectionInfo]:\n    \"\"\"Reads a .alb file and returns the problem.\"\"\"\n\n    current_info = SectionInfo()\n\n    problem: Dict[str, SectionInfo] = {}\n    with open(filename, \"r\") as input_file:\n        print(f\"Reading problem from '{filename}'\")\n\n        for line in input_file:\n            stripped_line = line.strip()\n            if not stripped_line:\n                continue\n\n            match_section_def = re.fullmatch(r\"<([\\w\\s]+)>\", stripped_line)\n            if match_section_def:\n                section_name = match_section_def.group(1)\n                if section_name == \"end\":\n                    continue\n\n                current_info = SectionInfo()\n                problem[section_name] = current_info\n                continue\n\n            match_single_number = re.fullmatch(r\"^([0-9]+)$\", stripped_line)\n            if match_single_number:\n                current_info.value = int(match_single_number.group(1))\n                continue\n\n            match_key_value = re.fullmatch(r\"^([0-9]+)\\s+([0-9]+)$\", stripped_line)\n            if match_key_value:\n                key = int(match_key_value.group(1))\n                value = int(match_key_value.group(2))\n                current_info.index_map[key] = value\n                continue\n\n            match_pair = re.fullmatch(r\"^([0-9]+),([0-9]+)$\", stripped_line)\n            if match_pair:\n                left = int(match_pair.group(1))\n                right = int(match_pair.group(2))\n                current_info.set_of_pairs.add((left, right))\n                continue\n\n            print(f\"Unrecognized line '{stripped_line}'\")\n\n    return problem\n\n\ndef print_stats(problem: Dict[str, SectionInfo]) -> None:\n    print(\"Problem Statistics\")\n    for key, value in problem.items():\n        print(f\"  - {key}: {value}\")\n```\n\n----------------------------------------\n\nTITLE: Defining Problem Parameters with OR-Tools\nDESCRIPTION: This function sets up various configurations and parameters to define the steel slab problem such as total number of slabs, colors, available capacities, and order details. It uses flags to define parameters related to problem id, solver type, and additional CP-SAT parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nimport time\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n\n_PROBLEM = flags.define_integer(\"problem\", 2, \"Problem id to solve.\")\n_BREAK_SYMMETRIES = flags.define_boolean(\n    \"break_symmetries\", True, \"Break symmetries between equivalent orders.\"\n)\n_SOLVER = flags.define_string(\n    \"solver\", \"sat_column\", \"Method used to solve: sat, sat_table, sat_column.\"\n)\n_PARAMS = flags.define_string(\n    \"params\",\n    \"max_time_in_seconds:20,num_workers:8,log_search_progress:true\",\n    \"CP-SAT parameters.\",\n)\n\n```\n\n----------------------------------------\n\nTITLE: Main Routing Problem Solver Function in Python\nDESCRIPTION: Main function that sets up and solves a vehicle routing problem using OR-Tools. Includes distance matrix handling, capacity constraints for two dimensions (x and y), and optimization parameters. Uses callbacks for distance and demand calculations.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_items_to_deliver.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]),\n        data[\"num_vehicles\"],\n        data[\"starts\"],\n        data[\"ends\"],\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        2000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    # Minimize the longest road\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n\n    # Add Capacity constraint.\n    def demand_callback_x(from_index):\n        \"\"\"Returns the demand of the node.\"\"\"\n        # Convert from routing variable Index to demands NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        return data[\"providers_x\"][from_node]\n\n    demand_callback_x_index = routing.RegisterUnaryTransitCallback(demand_callback_x)\n    routing.AddDimensionWithVehicleCapacity(\n        demand_callback_x_index,\n        0,  # null capacity slack\n        data[\"vehicle_capacities_x\"],  # vehicle maximum capacities\n        True,  # start cumul to zero\n        \"Load_x\",\n    )\n\n    def demand_callback_y(from_index):\n        \"\"\"Returns the demand of the node.\"\"\"\n        # Convert from routing variable Index to demands NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        return data[\"providers_y\"][from_node]\n\n    demand_callback_y_index = routing.RegisterUnaryTransitCallback(demand_callback_y)\n    routing.AddDimensionWithVehicleCapacity(\n        demand_callback_y_index,\n        0,  # null capacity slack\n        data[\"vehicle_capacities_y\"],  # vehicle maximum capacities\n        True,  # start cumul to zero\n        \"Load_y\",\n    )\n\n    # Add constraint at end\n    solver = routing.solver()\n    load_x_dim = routing.GetDimensionOrDie(\"Load_x\")\n    load_y_dim = routing.GetDimensionOrDie(\"Load_y\")\n    ends = []\n    for v in range(manager.GetNumberOfVehicles()):\n        ends.append(routing.End(v))\n\n    node_end = data[\"ends\"][0]\n    solver.Add(\n        solver.Sum([load_x_dim.CumulVar(l) for l in ends])\n        >= -data[\"providers_x\"][node_end]\n    )\n    solver.Add(\n        solver.Sum([load_y_dim.CumulVar(l) for l in ends])\n        >= -data[\"providers_y\"][node_end]\n    )\n\n    # Allow to freely drop any nodes.\n    penalty = 0\n    for node in range(0, len(data[\"distance_matrix\"])):\n        if node not in data[\"starts\"] and node not in data[\"ends\"]:\n            routing.AddDisjunction([manager.NodeToIndex(node)], penalty)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(1)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"no solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Creating Interval Variables in Python with CP-SAT Solver\nDESCRIPTION: This Python code demonstrates how to create different types of interval variables using the CP-SAT solver. It shows three approaches: creating an interval from start, duration, and end expressions; creating a fixed-size interval from a start expression and size; and creating a completely fixed interval with specific start and size values.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrates how to build an interval.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef interval_sample_sat():\n    \"\"\"Showcases how to build interval variables.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 100\n\n    # An interval can be created from three affine expressions.\n    start_var = model.new_int_var(0, horizon, \"start\")\n    duration = 10  # Python cp/sat code accept integer variables or constants.\n    end_var = model.new_int_var(0, horizon, \"end\")\n    interval_var = model.new_interval_var(start_var, duration, end_var + 2, \"interval\")\n\n    print(f\"interval = {repr(interval_var)}\")\n\n    # If the size is fixed, a simpler version uses the start expression and the\n    # size.\n    fixed_size_interval_var = model.new_fixed_size_interval_var(\n        start_var, 10, \"fixed_size_interval_var\"\n    )\n    print(f\"fixed_size_interval_var = {repr(fixed_size_interval_var)}\")\n\n    # A fixed interval can be created using the same API.\n    fixed_interval = model.new_fixed_size_interval_var(5, 10, \"fixed_interval\")\n    print(f\"fixed_interval = {repr(fixed_interval)}\")\n\n\ninterval_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Building CP-SAT Model for Job Scheduling in Python\nDESCRIPTION: Creates a constraint programming model for job scheduling, calculating horizon limits, defining decision variables, and setting up constraints for task intervals and machine availability.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n  #----------------------------------------------------------------------------\n  # Model.\n  model = cp_model.CpModel()\n\n  #----------------------------------------------------------------------------\n  # Compute a maximum makespan greedily.\n  horizon = 0\n  for job in jobs:\n    for task in job:\n      max_task_duration = 0\n      for alternative in task:\n        max_task_duration = max(max_task_duration, alternative[0])\n      horizon += max_task_duration\n\n  print('Horizon = %i' % horizon)\n\n  #----------------------------------------------------------------------------\n  # Global storage of variables.\n  intervals_per_machines = collections.defaultdict(list)\n  presences_per_machines = collections.defaultdict(list)\n  starts_per_machines = collections.defaultdict(list)\n  ends_per_machines = collections.defaultdict(list)\n  resources_per_machines = collections.defaultdict(list)\n  ranks_per_machines = collections.defaultdict(list)\n\n  job_starts = {}  # indexed by (job_id, task_id).\n  job_presences = {}  # indexed by (job_id, task_id, alt_id).\n  job_ranks = {}  # indexed by (job_id, task_id, alt_id).\n  job_ends = []  # indexed by job_id\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for Bin Packing\nDESCRIPTION: Defines the data model necessary for the bin packing problem, including a list of items and their weights, and bins with their capacities. The function returns these as pandas DataFrames. This data serves as input for the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/bin_packing_mb.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport io\n\nimport pandas as pd\n\nfrom ortools.linear_solver.python import model_builder\n\ndef create_data_model() -> tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Create the data for the example.\"\"\"\n\n    items_str = \"\"\"\n  item  weight\n    i1      48\n    i2      30\n    i3      19\n    i4      36\n    i5      36\n    i6      27\n    i7      42\n    i8      42\n    i9      36\n   i10      24\n   i11      30\n  \"\"\"\n\n    bins_str = \"\"\"\n  bin  capacity\n   b1       100\n   b2       100\n   b3       100\n   b4       100\n   b5       100\n   b6       100\n   b7       100\n  \"\"\"\n\n    items = pd.read_table(io.StringIO(items_str), index_col=0, sep=r\"\\s+\")\n    bins = pd.read_table(io.StringIO(bins_str), index_col=0, sep=r\"\\s+\")\n    return items, bins\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Task Ranking and Scheduling with OR-Tools CP-SAT in C#\nDESCRIPTION: This C# program demonstrates scheduling tasks with precedence relationships using Google OR-Tools' CP-SAT solver. It establishes a ranking system for tasks, handles optional tasks, enforces no-overlap constraints, and optimizes for minimal makespan while maximizing task execution. The code shows advanced constraint modeling techniques including boolean logic and interval variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nusing Google.OrTools.Sat;\n\npublic class RankingSampleSat\n{\n    static void RankTasks(CpModel model, IntVar[] starts, ILiteral[] presences, IntVar[] ranks)\n    {\n        int num_tasks = starts.Length;\n\n        // Creates precedence variables between pairs of intervals.\n        ILiteral[,] precedences = new ILiteral[num_tasks, num_tasks];\n        for (int i = 0; i < num_tasks; ++i)\n        {\n            for (int j = 0; j < num_tasks; ++j)\n            {\n                if (i == j)\n                {\n                    precedences[i, i] = presences[i];\n                }\n                else\n                {\n                    BoolVar prec = model.NewBoolVar(String.Format(\"{0} before {1}\", i, j));\n                    precedences[i, j] = prec;\n                    model.Add(starts[i] < starts[j]).OnlyEnforceIf(prec);\n                }\n            }\n        }\n\n        // Treats optional intervals.\n        for (int i = 0; i < num_tasks - 1; ++i)\n        {\n            for (int j = i + 1; j < num_tasks; ++j)\n            {\n                List<ILiteral> tmp_array = new List<ILiteral>();\n                tmp_array.Add(precedences[i, j]);\n                tmp_array.Add(precedences[j, i]);\n                tmp_array.Add(presences[i].Not());\n                // Makes sure that if i is not performed, all precedences are false.\n                model.AddImplication(presences[i].Not(), precedences[i, j].Not());\n                model.AddImplication(presences[i].Not(), precedences[j, i].Not());\n                tmp_array.Add(presences[j].Not());\n                // Makes sure that if j is not performed, all precedences are false.\n                model.AddImplication(presences[j].Not(), precedences[i, j].Not());\n                model.AddImplication(presences[j].Not(), precedences[j, i].Not());\n                // The following bool_or will enforce that for any two intervals:\n                //    i precedes j or j precedes i or at least one interval is not\n                //        performed.\n                model.AddBoolOr(tmp_array);\n                // Redundant constraint: it propagates early that at most one precedence\n                // is true.\n                model.AddImplication(precedences[i, j], precedences[j, i].Not());\n                model.AddImplication(precedences[j, i], precedences[i, j].Not());\n            }\n        }\n\n        // Links precedences and ranks.\n        for (int i = 0; i < num_tasks; ++i)\n        {\n            List<IntVar> tasks = new List<IntVar>();\n            for (int j = 0; j < num_tasks; ++j)\n            {\n                tasks.Add((IntVar)precedences[j, i]);\n            }\n            model.Add(ranks[i] == LinearExpr.Sum(tasks) - 1);\n        }\n    }\n\n    static void Main()\n    {\n        CpModel model = new CpModel();\n        // Three weeks.\n        int horizon = 100;\n        int num_tasks = 4;\n\n        IntVar[] starts = new IntVar[num_tasks];\n        IntVar[] ends = new IntVar[num_tasks];\n        IntervalVar[] intervals = new IntervalVar[num_tasks];\n        ILiteral[] presences = new ILiteral[num_tasks];\n        IntVar[] ranks = new IntVar[num_tasks];\n\n        ILiteral true_var = model.TrueLiteral();\n\n        // Creates intervals, half of them are optional.\n        for (int t = 0; t < num_tasks; ++t)\n        {\n            starts[t] = model.NewIntVar(0, horizon, String.Format(\"start_{0}\", t));\n            int duration = t + 1;\n            ends[t] = model.NewIntVar(0, horizon, String.Format(\"end_{0}\", t));\n            if (t < num_tasks / 2)\n            {\n                intervals[t] = model.NewIntervalVar(starts[t], duration, ends[t], String.Format(\"interval_{0}\", t));\n                presences[t] = true_var;\n            }\n            else\n            {\n                presences[t] = model.NewBoolVar(String.Format(\"presence_{0}\", t));\n                intervals[t] = model.NewOptionalIntervalVar(starts[t], duration, ends[t], presences[t],\n                                                            String.Format(\"o_interval_{0}\", t));\n            }\n\n            // Ranks = -1 if and only if the tasks is not performed.\n            ranks[t] = model.NewIntVar(-1, num_tasks - 1, String.Format(\"rank_{0}\", t));\n        }\n\n        // Adds NoOverlap constraint.\n        model.AddNoOverlap(intervals);\n\n        // Adds ranking constraint.\n        RankTasks(model, starts, presences, ranks);\n\n        // Adds a constraint on ranks.\n        model.Add(ranks[0] < ranks[1]);\n\n        // Creates makespan variable.\n        IntVar makespan = model.NewIntVar(0, horizon, \"makespan\");\n        for (int t = 0; t < num_tasks; ++t)\n        {\n            model.Add(ends[t] <= makespan).OnlyEnforceIf(presences[t]);\n        }\n        // Minimizes makespan - fixed gain per tasks performed.\n        // As the fixed cost is less that the duration of the last interval,\n        // the solver will not perform the last interval.\n        IntVar[] presences_as_int_vars = new IntVar[num_tasks];\n        for (int t = 0; t < num_tasks; ++t)\n        {\n            presences_as_int_vars[t] = (IntVar)presences[t];\n        }\n        model.Minimize(2 * makespan - 7 * LinearExpr.Sum(presences_as_int_vars));\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        CpSolverStatus status = solver.Solve(model);\n\n        if (status == CpSolverStatus.Optimal)\n        {\n            Console.WriteLine(String.Format(\"Optimal cost: {0}\", solver.ObjectiveValue));\n            Console.WriteLine(String.Format(\"Makespan: {0}\", solver.Value(makespan)));\n            for (int t = 0; t < num_tasks; ++t)\n            {\n                if (solver.BooleanValue(presences[t]))\n                {\n                    Console.WriteLine(String.Format(\"Task {0} starts at {1} with rank {2}\", t, solver.Value(starts[t]),\n                                                    solver.Value(ranks[t])));\n                }\n                else\n                {\n                    Console.WriteLine(\n                        String.Format(\"Task {0} in not performed and ranked at {1}\", t, solver.Value(ranks[t])));\n                }\n            }\n        }\n        else\n        {\n            Console.WriteLine(String.Format(\"Solver exited with nonoptimal status: {0}\", status));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modulo Constraint Implementation\nDESCRIPTION: Custom implementation of a modulo constraint propagator based on ECLiPSE version. Handles modulo operations in the constraint solver context.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/divisible_by_9_through_1.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef my_mod(solver, x, y, r):\n\n  if not isinstance(y, int):\n    solver.Add(y != 0)\n\n  lbx = x.Min()\n  ubx = x.Max()\n  ubx_neg = -ubx\n  lbx_neg = -lbx\n  min_x = min(lbx, ubx_neg)\n  max_x = max(ubx, lbx_neg)\n\n  d = solver.IntVar(max(0, min_x), max_x, \"d\")\n\n  if not isinstance(r, int):\n    solver.Add(r >= 0)\n    solver.Add(x * r >= 0)\n\n  if not isinstance(r, int) and not isinstance(r, int):\n    solver.Add(-abs(y) < r)\n    solver.Add(r < abs(y))\n\n  solver.Add(min_x <= d)\n  solver.Add(d <= max_x)\n  solver.Add(x == y * d + r)\n```\n\n----------------------------------------\n\nTITLE: OR-Tools Cryptarithmetic Puzzle Solution Implementation\nDESCRIPTION: Implements a constraint programming solution for a cryptarithmetic puzzle using Google OR-Tools. The program assigns unique values (1-26) to letters to satisfy multiple musical word equations. Uses AllDifferent constraint and systematic search to find valid solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/crypto.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Crypto problem\")\n\n  #\n  # data\n  #\n  num_letters = 26\n\n  BALLET = 45\n  CELLO = 43\n  CONCERT = 74\n  FLUTE = 30\n  FUGUE = 50\n  GLEE = 66\n  JAZZ = 58\n  LYRE = 47\n  OBOE = 53\n  OPERA = 65\n  POLKA = 59\n  QUARTET = 50\n  SAXOPHONE = 134\n  SCALE = 51\n  SOLO = 37\n  SONG = 61\n  SOPRANO = 82\n  THEME = 72\n  VIOLIN = 100\n  WALTZ = 34\n\n  #\n  # variables\n  #\n  LD = [solver.IntVar(1, num_letters, \"LD[%i]\" % i) for i in range(num_letters)]\n  A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z = LD\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(LD))\n  solver.Add(B + A + L + L + E + T == BALLET)\n  solver.Add(C + E + L + L + O == CELLO)\n  solver.Add(C + O + N + C + E + R + T == CONCERT)\n  solver.Add(F + L + U + T + E == FLUTE)\n  solver.Add(F + U + G + U + E == FUGUE)\n  solver.Add(G + L + E + E == GLEE)\n  solver.Add(J + A + Z + Z == JAZZ)\n  solver.Add(L + Y + R + E == LYRE)\n  solver.Add(O + B + O + E == OBOE)\n  solver.Add(O + P + E + R + A == OPERA)\n  solver.Add(P + O + L + K + A == POLKA)\n  solver.Add(Q + U + A + R + T + E + T == QUARTET)\n  solver.Add(S + A + X + O + P + H + O + N + E == SAXOPHONE)\n  solver.Add(S + C + A + L + E == SCALE)\n  solver.Add(S + O + L + O == SOLO)\n  solver.Add(S + O + N + G == SONG)\n  solver.Add(S + O + P + R + A + N + O == SOPRANO)\n  solver.Add(T + H + E + M + E == THEME)\n  solver.Add(V + I + O + L + I + N == VIOLIN)\n  solver.Add(W + A + L + T + Z == WALTZ)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(LD, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  while solver.NextSolution():\n    num_solutions += 1\n    for (letter, val) in [(str[i], LD[i].Value()) for i in range(num_letters)]:\n      print(\"%s: %i\" % (letter, val))\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Rabbits and Pheasants Constraint Satisfaction Problem\nDESCRIPTION: Uses CP-SAT solver to find the number of rabbits and pheasants that satisfy two constraints: total number of heads and total number of legs\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/rabbits_and_pheasants_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef rabbits_and_pheasants_sat():\n    \"\"\"Solves the rabbits + pheasants problem.\"\"\"\n    model = cp_model.CpModel()\n\n    r = model.new_int_var(0, 100, \"r\")\n    p = model.new_int_var(0, 100, \"p\")\n\n    # 20 heads.\n    model.add(r + p == 20)\n    # 56 legs.\n    model.add(4 * r + 2 * p == 56)\n\n    # Solves and prints out the solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"{solver.value(r)} rabbits and {solver.value(p)} pheasants\")\n\nrabbits_and_pheasants_sat()\n```\n\n----------------------------------------\n\nTITLE: Volsay Production Optimization Model\nDESCRIPTION: Main implementation of the Volsay linear programming model that optimizes production of gas and chloride products subject to component constraints. Uses the CLP solver to maximize profit while respecting resource limitations for nitrogen, hydrogen, and chlorine.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/volsay3.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\ndef main(unused_argv):\n\n  # Create the solver.\n\n  # using GLPK\n  # solver = pywraplp.Solver('CoinsGridGLPK',\n  #                          pywraplp.Solver.GLPK_LINEAR_PROGRAMMING)\n\n  # Using CLP\n  solver = pywraplp.Solver.CreateSolver('CLP')\n  if not solver:\n    return\n\n  # data\n  num_products = 2\n\n  products = ['Gas', 'Chloride']\n  components = ['nitrogen', 'hydrogen', 'chlorine']\n\n  demand = [[1, 3, 0], [1, 4, 1]]\n  profit = [30, 40]\n  stock = [50, 180, 40]\n\n  # declare variables\n  production = [\n      solver.NumVar(0, 100000, 'production[%i]' % i)\n      for i in range(num_products)\n  ]\n\n  #\n  # constraints\n  #\n  for c in range(len(components)):\n    solver.Add(\n        solver.Sum([demand[p][c] * production[p]\n                    for p in range(len(products))]) <= stock[c])\n\n  # objective\n  # Note: there is no support for solver.ScalProd in the LP/IP interface\n  objective = solver.Maximize(\n      solver.Sum([production[p] * profit[p] for p in range(num_products)]))\n\n  print('NumConstraints:', solver.NumConstraints())\n  print('NumVariables:', solver.NumVariables())\n  print()\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n  print('objective = ', solver.Objective().Value())\n  for i in range(num_products):\n    print(products[i], '=', production[i].SolutionValue(), end=' ')\n    print('ReducedCost = ', production[i].ReducedCost())\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n  print('iterations:', solver.Iterations())\n\n\nmain('Volsay')\n```\n\n----------------------------------------\n\nTITLE: Implementing Transition Times and Costs in NoOverlap Constraint with Python and OR-Tools\nDESCRIPTION: This function creates a CP-SAT model to solve a scheduling problem with transition times and costs between tasks. It uses a circuit constraint to rank tasks and applies penalties for breaking task sequences and delays for switching between odd and even task indices.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/transitions_in_no_overlap_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef transitions_in_no_overlap_sample_sat():\n    \"\"\"Implement transitions in a NoOverlap constraint.\"\"\"\n\n    model = cp_model.CpModel()\n    horizon = 40\n    num_tasks = 4\n\n    # Breaking the natural sequence induces a fixed penalty.\n    penalties = {\n        (1, 0): 10,\n        (2, 0): 10,\n        (3, 0): 10,\n        (2, 1): 10,\n        (3, 1): 10,\n        (3, 2): 10,\n    }\n\n    # Switching from an odd to even or even to odd task indices induces a delay.\n    delays = {\n        (1, 0): 10,\n        (0, 1): 10,\n        (3, 0): 10,\n        (0, 3): 10,\n        (1, 2): 10,\n        (2, 1): 10,\n        (3, 2): 10,\n        (2, 3): 10,\n    }\n\n    all_tasks = range(num_tasks)\n\n    starts = []\n    durations = []\n    intervals = []\n    presences = []\n\n    # Creates intervals, all present. But the cost is robust w.r.t. optional\n    # intervals.\n    for t in all_tasks:\n        start = model.new_int_var(0, horizon, f\"start[{t}]\")\n        duration = 5\n        presence = True\n        interval = model.new_optional_fixed_size_interval_var(\n            start, duration, presence, f\"opt_interval[{t}]\"\n        )\n\n        starts.append(start)\n        durations.append(duration)\n        intervals.append(interval)\n        presences.append(presence)\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds ranking constraint.\n    penalty_terms = transitive_reduction_with_circuit_delays_and_penalties(\n        model, starts, durations, presences, penalties, delays\n    )\n\n    # Minimize the sum of penalties,\n    model.minimize(sum(var * penalty for var, penalty in penalty_terms))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Prints out the makespan and the start times and ranks of all tasks.\n        print(f\"Optimal cost: {solver.objective_value}\")\n        for t in all_tasks:\n            if solver.value(presences[t]):\n                print(f\"Task {t} starts at {solver.value(starts[t])} \")\n            else:\n                print(f\"Task {t} in not performed\")\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Mixed Integer Programming Solver in Python\nDESCRIPTION: Creates a solver instance using the CP-SAT backend, demonstrates how to define integer variables with constraints and set optimization objectives\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_mip_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\ndef main():\n    solver = pywraplp.Solver.CreateSolver(\"SAT\")\n    if not solver:\n        return\n\n    infinity = solver.infinity()\n    x = solver.IntVar(0.0, infinity, \"x\")\n    y = solver.IntVar(0.0, infinity, \"y\")\n\n    solver.Add(x + 7 * y <= 17.5)\n    solver.Add(x <= 3.5)\n\n    solver.Maximize(x + 10 * y)\n\n    status = solver.Solve()\n\n    if status == pywraplp.Solver.OPTIMAL:\n        print(\"Solution:\")\n        print(\"Objective value =\", solver.Objective().Value())\n        print(\"x =\", x.solution_value())\n        print(\"y =\", y.solution_value())\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Scheduling with Transitions Problem Solver in Python\nDESCRIPTION: The main function that solves job scheduling problems with transitions. It processes arguments, defines job data structures, and initializes the constraint programming model for solving the scheduling problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main(args):\n  \"\"\"Solves the scheduling with transitions problem.\"\"\"\n\n  instance = args.problem_instance\n  parameters = args.params\n  output_proto = args.output_proto\n\n  #----------------------------------------------------------------------------\n  # Data.\n  small_jobs = [[[(100, 0, 'R6'), (2, 1, 'R6')]],\n                [[(2, 0, 'R3'), (100, 1, 'R3')]],\n                [[(100, 0, 'R1'), (16, 1, 'R1')]],\n                [[(1, 0, 'R1'), (38, 1, 'R1')]], [[(14, 0, 'R1'), (10, 1,\n                                                                   'R1')]],\n                [[(16, 0, 'R3'), (17, 1, 'R3')]],\n                [[(14, 0, 'R3'), (14, 1, 'R3')]],\n                [[(14, 0, 'R3'), (15, 1, 'R3')]],\n                [[(14, 0, 'R3'), (13, 1, 'R3')]],\n                [[(100, 0, 'R1'), (38, 1, 'R1')]]]\n\n  large_jobs = [\n      [[(-1, 0, 'R1'), (10, 1, 'R1')]], [[(9, 0, 'R3'),\n                                          (22, 1, 'R3')]],\n      [[(-1, 0, 'R3'), (13, 1, 'R3')]], [[(-1, 0, 'R3'), (38, 1, 'R3')]],\n      [[(-1, 0, 'R3'), (38, 1, 'R3')]], [[(-1, 0, 'R3'), (16, 1, 'R3')]],\n      [[(-1, 0, 'R3'), (11, 1, 'R3')]], [[(-1, 0, 'R3'), (13, 1, 'R3')]],\n      [[(13, 0, 'R3'), (-1, 1, 'R3')]], [[(13, 0, 'R3'), (-1, 1, 'R3')]],\n      [[(-1, 0, 'R3'), (15, 1, 'R3')]], [[(12, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(14, 0, 'R1'), (-1, 1, 'R1')]], [[(13, 0, 'R3'), (-1, 1, 'R3')]],\n      [[(-1, 0, 'R3'), (15, 1, 'R3')]], [[(14, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(13, 0, 'R3'), (-1, 1, 'R3')]], [[(14, 0, 'R3'), (-1, 1, 'R3')]],\n      [[(13, 0, 'R1'), (-1, 1, 'R1')]], [[(15, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(-1, 0, 'R2'), (16, 1, 'R2')]], [[(-1, 0, 'R2'), (16, 1, 'R2')]],\n      [[(-1, 0, 'R5'), (27, 1, 'R5')]], [[(-1, 0, 'R5'), (13, 1, 'R5')]],\n      [[(-1, 0, 'R5'), (13, 1, 'R5')]], [[(-1, 0, 'R5'), (13, 1, 'R5')]],\n      [[(13, 0, 'R1'), (-1, 1, 'R1')]], [[(-1, 0, 'R1'), (17, 1, 'R1')]],\n      [[(14, 0, 'R4'), (-1, 1, 'R4')]], [[(13, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(16, 0, 'R4'), (-1, 1, 'R4')]], [[(16, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(16, 0, 'R4'), (-1, 1, 'R4')]], [[(16, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(13, 0, 'R1'), (-1, 1, 'R1')]], [[(13, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(14, 0, 'R4'), (-1, 1, 'R4')]], [[(13, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(12, 0, 'R1'), (-1, 1, 'R1')]], [[(14, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(-1, 0, 'R5'), (14, 1, 'R5')]], [[(14, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(14, 0, 'R4'), (-1, 1, 'R4')]], [[(14, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(14, 0, 'R4'), (-1, 1, 'R4')]], [[(-1, 0, 'R1'), (21, 1, 'R1')]],\n      [[(-1, 0, 'R1'), (21, 1, 'R1')]], [[(-1, 0, 'R1'), (21, 1, 'R1')]],\n      [[(13, 0, 'R6'), (-1, 1, 'R6')]], [[(13, 0, 'R2'), (-1, 1, 'R2')]],\n      [[(-1, 0, 'R6'), (12, 1, 'R6')]], [[(13, 0, 'R1'), (-1, 1, 'R1')]],\n      [[(13, 0, 'R1'), (-1, 1, 'R1')]], [[(-1, 0, 'R6'), (14, 1, 'R6')]],\n      [[(-1, 0, 'R5'), (5, 1, 'R5')]], [[(3, 0, 'R2'), (-1, 1, 'R2')]],\n      [[(-1, 0, 'R1'), (21, 1, 'R1')]], [[(-1, 0, 'R1'), (21, 1, 'R1')]],\n      [[(-1, 0, 'R1'), (21, 1, 'R1')]], [[(-1, 0, 'R5'), (1, 1, 'R5')]],\n      [[(1, 0, 'R2'), (-1, 1, 'R2')]], [[(-1, 0, 'R2'), (19, 1, 'R2')]],\n      [[(13, 0, 'R4'), (-1, 1, 'R4')]], [[(12, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(-1, 0, 'R3'), (2, 1, 'R3')]], [[(11, 0, 'R4'), (-1, 1, 'R4')]],\n      [[(6, 0, 'R6'), (-1, 1, 'R6')]], [[(6, 0, 'R6'), (-1, 1, 'R6')]],\n      [[(1, 0, 'R2'), (-1, 1, 'R2')]], [[(12, 0, 'R4'), (-1, 1, 'R4')]]\n  ]\n\n  jobs = small_jobs if instance == 0 else large_jobs\n\n  #----------------------------------------------------------------------------\n  # Helper data.\n  num_jobs = len(jobs)\n  all_jobs = range(num_jobs)\n  num_machines = 2\n  all_machines = range(num_machines)\n```\n\n----------------------------------------\n\nTITLE: Implementing Graph Coloring Problem with OR-Tools MIP Solver\nDESCRIPTION: This code implements the Graph Coloring Problem using Mixed Integer Programming in OR-Tools. It sets up the problem, defines variables and constraints, solves the model, and outputs the results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coloring_ip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n  print('Solver: ', sol)\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  #\n  # data\n  #\n\n  # max number of colors\n  # [we know that 4 suffices for normal maps]\n  nc = 5\n\n  # number of nodes\n  n = 11\n  # set of nodes\n  V = list(range(n))\n\n  num_edges = 20\n\n  #\n  # Neighbours\n  #\n  # This data correspond to the instance myciel3.col from:\n  # http://mat.gsia.cmu.edu/COLOR/instances.html\n  #\n  # Note: 1-based (adjusted below)\n  E = [[1, 2], [1, 4], [1, 7], [1, 9], [2, 3], [2, 6], [2, 8], [3, 5], [3, 7],\n       [3, 10], [4, 5], [4, 6], [4, 10], [5, 8], [5, 9], [6, 11], [7, 11],\n       [8, 11], [9, 11], [10, 11]]\n\n  #\n  # declare variables\n  #\n\n  # x[i,c] = 1 means that node i is assigned color c\n  x = {}\n  for v in V:\n    for j in range(nc):\n      x[v, j] = solver.IntVar(0, 1, 'v[%i,%i]' % (v, j))\n\n  # u[c] = 1 means that color c is used, i.e. assigned to some node\n  u = [solver.IntVar(0, 1, 'u[%i]' % i) for i in range(nc)]\n\n  # number of colors used, to minimize\n  obj = solver.Sum(u)\n\n  #\n  # constraints\n  #\n\n  # each node must be assigned exactly one color\n  for i in V:\n    solver.Add(solver.Sum([x[i, c] for c in range(nc)]) == 1)\n\n  # adjacent nodes cannot be assigned the same color\n  # (and adjust to 0-based)\n  for i in range(num_edges):\n    for c in range(nc):\n      solver.Add(x[E[i][0] - 1, c] + x[E[i][1] - 1, c] <= u[c])\n\n  # objective\n  objective = solver.Minimize(obj)\n\n  #\n  # solution\n  #\n  solver.Solve()\n\n  print()\n  print('number of colors:', int(solver.Objective().Value()))\n  print('colors used:', [int(u[i].SolutionValue()) for i in range(nc)])\n  print()\n\n  for v in V:\n    print('v%i' % v, ' color ', end=' ')\n    for c in range(nc):\n      if int(x[v, c].SolutionValue()) == 1:\n        print(c)\n\n  print()\n  print('WallTime:', solver.WallTime())\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n\n\n\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Solving Circuit Problem with OR-Tools\nDESCRIPTION: This main function sets up the OR-Tools solver, creates variables, applies the circuit constraint, and finds all solutions for a given problem size.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/circuit.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(n=5):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Send most money\")\n\n  # data\n  print(\"n:\", n)\n\n  # declare variables\n  # Note: domain should be 0..n-1\n  x = [solver.IntVar(0, n - 1, \"x%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  circuit(solver, x)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n\n  collector = solver.AllSolutionCollector(solution)\n\n  solver.Solve(\n      solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE),\n      [collector])\n\n  num_solutions = collector.SolutionCount()\n  for s in range(num_solutions):\n    print(\"x:\", [collector.Value(s, x[i]) for i in range(len(x))])\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print()\n\n\nn = 5\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\n\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: P-Median Problem Implementation\nDESCRIPTION: Complete implementation of the P-Median problem using OR-Tools. The code creates a constraint optimization model that minimizes the demand-weighted distance between customers and warehouses. It includes variable declarations, constraints setup, and solution search logic.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/p_median.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('P-median problem')\n\n  #\n  # data\n  #\n  p = 2\n\n  num_customers = 4\n  customers = list(range(num_customers))\n  Albert, Bob, Chris, Daniel = customers\n  num_warehouses = 3\n  warehouses = list(range(num_warehouses))\n  Santa_Clara, San_Jose, Berkeley = warehouses\n\n  demand = [100, 80, 80, 70]\n  distance = [[2, 10, 50], [2, 10, 52], [50, 60, 3], [40, 60, 1]]\n\n  #\n  # declare variables\n  #\n  open = [solver.IntVar(warehouses, 'open[%i]% % i') for w in warehouses]\n  ship = {}\n  for c in customers:\n    for w in warehouses:\n      ship[c, w] = solver.IntVar(0, 1, 'ship[%i,%i]' % (c, w))\n  ship_flat = [ship[c, w] for c in customers for w in warehouses]\n\n  z = solver.IntVar(0, 1000, 'z')\n\n  #\n  # constraints\n  #\n  z_sum = solver.Sum([\n      demand[c] * distance[c][w] * ship[c, w]\n      for c in customers\n      for w in warehouses\n  ])\n  solver.Add(z == z_sum)\n\n  for c in customers:\n    s = solver.Sum([ship[c, w] for w in warehouses])\n    solver.Add(s == 1)\n\n  solver.Add(solver.Sum(open) == p)\n\n  for c in customers:\n    for w in warehouses:\n      solver.Add(ship[c, w] <= open[w])\n\n  # objective\n  objective = solver.Minimize(z, 1)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(open + ship_flat, solver.INT_VAR_DEFAULT,\n                    solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('z:', z.Value())\n    print('open:', [open[w].Value() for w in warehouses])\n    for c in customers:\n      for w in warehouses:\n        print(ship[c, w].Value(), end=' ')\n      print()\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Calculating Haversine Distance Between Geographic Points\nDESCRIPTION: A method that computes the great circle distance between two geographic points specified in decimal degrees of latitude and longitude using the Haversine formula. It converts coordinates to radians and returns the distance in kilometers.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef _haversine(self, lon1, lat1, lon2, lat2):\n    \"\"\"\n    Calculate the great circle distance between two points\n    on the earth specified in decimal degrees of latitude and longitude.\n    https://en.wikipedia.org/wiki/Haversine_formula\n\n    Args:\n        lon1: longitude of pt 1,\n        lat1: latitude of pt 1,\n        lon2: longitude of pt 2,\n        lat2: latitude of pt 2\n\n    Returns:\n        the distace in km between pt1 and pt2\n    \"\"\"\n    # convert decimal degrees to radians\n    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])\n\n    # haversine formula\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = (np.sin(dlat / 2)**2 +\n         np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2)\n    c = 2 * np.arcsin(np.sqrt(a))\n\n    # 6367 km is the radius of the Earth\n    km = 6367 * c\n    return km\n```\n\n----------------------------------------\n\nTITLE: Bin Packing Optimization in C# using OR-Tools CP-SAT\nDESCRIPTION: C# implementation of bin packing problem solver using OR-Tools CP-SAT. Provides detailed solution output and solver statistics. Implements the same optimization model as C++ and Java versions but uses C#-specific syntax and OR-Tools bindings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class BinPackingProblemSat\n{\n    static void Main()\n    {\n        // Data.\n        int bin_capacity = 100;\n        int slack_capacity = 20;\n        int num_bins = 5;\n\n        int[,] items = new int[,] { { 20, 6 }, { 15, 6 }, { 30, 4 }, { 45, 3 } };\n        int num_items = items.GetLength(0);\n\n        // Model.\n        CpModel model = new CpModel();\n\n        // Main variables.\n        IntVar[,] x = new IntVar[num_items, num_bins];\n        for (int i = 0; i < num_items; ++i)\n        {\n            int num_copies = items[i, 1];\n            for (int b = 0; b < num_bins; ++b)\n            {\n                x[i, b] = model.NewIntVar(0, num_copies, String.Format(\"x_{0}_{1}\", i, b));\n            }\n        }\n\n        // Load variables.\n        IntVar[] load = new IntVar[num_bins];\n        for (int b = 0; b < num_bins; ++b)\n        {\n            load[b] = model.NewIntVar(0, bin_capacity, String.Format(\"load_{0}\", b));\n        }\n\n        // Slack variables.\n        BoolVar[] slacks = new BoolVar[num_bins];\n        for (int b = 0; b < num_bins; ++b)\n        {\n            slacks[b] = model.NewBoolVar(String.Format(\"slack_{0}\", b));\n        }\n\n        // Links load and x.\n        int[] sizes = new int[num_items];\n        for (int i = 0; i < num_items; ++i)\n        {\n            sizes[i] = items[i, 0];\n        }\n        for (int b = 0; b < num_bins; ++b)\n        {\n            IntVar[] tmp = new IntVar[num_items];\n            for (int i = 0; i < num_items; ++i)\n            {\n                tmp[i] = x[i, b];\n            }\n            model.Add(load[b] == LinearExpr.WeightedSum(tmp, sizes));\n        }\n\n        // Place all items.\n        for (int i = 0; i < num_items; ++i)\n        {\n            IntVar[] tmp = new IntVar[num_bins];\n            for (int b = 0; b < num_bins; ++b)\n            {\n                tmp[b] = x[i, b];\n            }\n            model.Add(LinearExpr.Sum(tmp) == items[i, 1]);\n        }\n\n        // Links load and slack.\n        int safe_capacity = bin_capacity - slack_capacity;\n        for (int b = 0; b < num_bins; ++b)\n        {\n            //  slack[b] => load[b] <= safe_capacity.\n            model.Add(load[b] <= safe_capacity).OnlyEnforceIf(slacks[b]);\n            // not(slack[b]) => load[b] > safe_capacity.\n            model.Add(load[b] > safe_capacity).OnlyEnforceIf(slacks[b].Not());\n        }\n\n        // Maximize sum of slacks.\n        model.Maximize(LinearExpr.Sum(slacks));\n\n        // Solves and prints out the solution.\n        CpSolver solver = new CpSolver();\n        CpSolverStatus status = solver.Solve(model);\n        Console.WriteLine(String.Format(\"Solve status: {0}\", status));\n        if (status == CpSolverStatus.Optimal)\n        {\n            Console.WriteLine(String.Format(\"Optimal objective value: {0}\", solver.ObjectiveValue));\n            for (int b = 0; b < num_bins; ++b)\n            {\n                Console.WriteLine(String.Format(\"load_{0} = {1}\", b, solver.Value(load[b])));\n                for (int i = 0; i < num_items; ++i)\n                {\n                    Console.WriteLine(string.Format(\"  item_{0}_{1} = {2}\", i, b, solver.Value(x[i, b])));\n                }\n            }\n        }\n        Console.WriteLine(\"Statistics\");\n        Console.WriteLine(String.Format(\"  - conflicts : {0}\", solver.NumConflicts()));\n        Console.WriteLine(String.Format(\"  - branches  : {0}\", solver.NumBranches()));\n        Console.WriteLine(String.Format(\"  - wall time : {0} s\", solver.WallTime()));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Scheduling with No-Overlap in Java using OR-Tools\nDESCRIPTION: Java implementation of task scheduling that schedules 3 tasks with fixed durations over 3 weeks while avoiding weekends. Uses CP-SAT solver to minimize the makespan and enforces no-overlap constraints between tasks and weekend periods.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_13\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.IntervalVar;\nimport com.google.ortools.sat.LinearExpr;\n\npublic class NoOverlapSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n    int horizon = 21;\n\n    IntVar start0 = model.newIntVar(0, horizon, \"start0\");\n    int duration0 = 2;\n    IntervalVar task0 = model.newFixedSizeIntervalVar(start0, duration0, \"task0\");\n\n    IntVar start1 = model.newIntVar(0, horizon, \"start1\");\n    int duration1 = 4;\n    IntervalVar task1 = model.newFixedSizeIntervalVar(start1, duration1, \"task1\");\n\n    IntVar start2 = model.newIntVar(0, horizon, \"start2\");\n    int duration2 = 3;\n    IntervalVar task2 = model.newFixedSizeIntervalVar(start2, duration2, \"task2\");\n\n    IntervalVar weekend0 = model.newFixedInterval(5, 2, \"weekend0\");\n    IntervalVar weekend1 = model.newFixedInterval(12, 2, \"weekend1\");\n    IntervalVar weekend2 = model.newFixedInterval(19, 2, \"weekend2\");\n\n    model.addNoOverlap(new IntervalVar[] {task0, task1, task2, weekend0, weekend1, weekend2});\n\n    IntVar obj = model.newIntVar(0, horizon, \"makespan\");\n    model.addMaxEquality(obj,\n        new LinearExpr[] {LinearExpr.newBuilder().add(start0).add(duration0).build(),\n            LinearExpr.newBuilder().add(start1).add(duration1).build(),\n            LinearExpr.newBuilder().add(start2).add(duration2).build()});\n    model.minimize(obj);\n\n    CpSolver solver = new CpSolver();\n    CpSolverStatus status = solver.solve(model);\n\n    if (status == CpSolverStatus.OPTIMAL) {\n      System.out.println(\"Optimal Schedule Length: \" + solver.objectiveValue());\n      System.out.println(\"Task 0 starts at \" + solver.value(start0));\n      System.out.println(\"Task 1 starts at \" + solver.value(start1));\n      System.out.println(\"Task 2 starts at \" + solver.value(start2));\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Route Data Extraction\nDESCRIPTION: Functions to extract route information and cumulative time data from the OR-Tools solution object. Handles conversion between routing indices and actual node numbers.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrptw_store_solution_data.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef get_routes(solution, routing, manager):\n    routes = []\n    for route_nbr in range(routing.vehicles()):\n        index = routing.Start(route_nbr)\n        route = [manager.IndexToNode(index)]\n        while not routing.IsEnd(index):\n            index = solution.Value(routing.NextVar(index))\n            route.append(manager.IndexToNode(index))\n        routes.append(route)\n    return routes\n\ndef get_cumul_data(solution, routing, dimension):\n    cumul_data = []\n    for route_nbr in range(routing.vehicles()):\n        route_data = []\n        index = routing.Start(route_nbr)\n        dim_var = dimension.CumulVar(index)\n        route_data.append([solution.Min(dim_var), solution.Max(dim_var)])\n        while not routing.IsEnd(index):\n            index = solution.Value(routing.NextVar(index))\n            dim_var = dimension.CumulVar(index)\n            route_data.append([solution.Min(dim_var), solution.Max(dim_var)])\n        cumul_data.append(route_data)\n    return cumul_data\n```\n\n----------------------------------------\n\nTITLE: Solving Global Contiguity Problem using Regular Constraint in Python\nDESCRIPTION: Implements the main function that sets up the global contiguity problem using the regular constraint, and solves it using Google's CP Solver. It defines the DFA for the regular expression 0*1*0* and prints all solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/contiguity_regular.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef main():\n\n  solver = pywrapcp.Solver('Global contiguity using regular')\n\n  n_states = 3\n  input_max = 2\n  initial_state = 1\n\n  accepting_states = [1, 2, 3]\n\n  transition_fn = [\n      [1, 2],\n      [3, 2],\n      [3, 0],\n  ]\n\n  n = 7\n\n  reg_input = [solver.IntVar(1, 2, 'x[%i]' % i) for i in range(n)]\n\n  regular(reg_input, n_states, input_max, transition_fn, initial_state,\n          accepting_states)\n\n  db = solver.Phase(reg_input, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('reg_input:', [int(reg_input[i].Value() - 1) for i in range(n)])\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('wall_time:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing CP Solver with OR-Tools in Python\nDESCRIPTION: This Python script shows how to use the OR-Tools CP solver to create variables, add constraints, solve a simple problem, and print solutions. It also includes advanced usage information such as solving time and memory usage.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/CP.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Simple Constraint optimization example.\"\"\"\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the solver.\n    solver = pywrapcp.Solver(\"CPSimple\")\n\n    # Create the variables.\n    num_vals = 3\n    x = solver.IntVar(0, num_vals - 1, \"x\")\n    y = solver.IntVar(0, num_vals - 1, \"y\")\n    z = solver.IntVar(0, num_vals - 1, \"z\")\n\n    # Constraint 0: x != y.\n    solver.Add(x != y)\n    print(\"Number of constraints: \", solver.Constraints())\n\n    # Solve the problem.\n    decision_builder = solver.Phase(\n        [x, y, z], solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE\n    )\n\n    # Print solution on console.\n    count = 0\n    solver.NewSearch(decision_builder)\n    while solver.NextSolution():\n        count += 1\n        solution = f\"Solution {count}:\\n\"\n        for var in [x, y, z]:\n            solution += f\" {var.Name()} = {var.Value()}\"\n        print(solution)\n    solver.EndSearch()\n    print(f\"Number of solutions found: {count}\")\n\n    print(\"Advanced usage:\")\n    print(f\"Problem solved in {solver.WallTime()}ms\")\n    print(f\"Memory usage: {pywrapcp.Solver.MemoryUsage()}bytes\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Creating Time Evaluator for Routing in Python\nDESCRIPTION: This code defines the calculation of transit times between locations based on demands and distances. It includes functions to evaluate service and travel times, leveraging OR-Tools for efficient transport routing. Dependencies include understanding of callback patterns in OR-Tools and knowledge of Manhattan distance calculation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/transit_time.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"def manhattan_distance(position_1, position_2):\\n    return (\\n        abs(position_1[0] - position_2[0]) + abs(position_1[1] - position_2[1]))\\nclass CreateTimeEvaluator(object):\\n    @staticmethod\\n    def service_time(data, node):\\n        return data.demands[node] * data.time_per_demand_unit\\n    @staticmethod\\n    def travel_time(data, from_node, to_node):\\n        if from_node == to_node:\\n            travel_time = 0\\n        else:\\n            travel_time = manhattan_distance(data.locations[\\n                from_node], data.locations[to_node]) / data.vehicle.speed\\n        return travel_time\\n    def __init__(self, data):\\n        self._total_time = {}\\n        for from_node in range(data.num_locations):\\n            self._total_time[from_node] = {}\\n            for to_node in range(data.num_locations):\\n                if from_node == to_node:\\n                    self._total_time[from_node][to_node] = 0\\n                else:\\n                    self._total_time[from_node][to_node] = int(\\n                        self.service_time(data, from_node) + self.travel_time(\\n                            data, from_node, to_node))\\n    def time_evaluator(self, from_node, to_node):\\n        return self._total_time[from_node][to_node]\"\n```\n\n----------------------------------------\n\nTITLE: Modeling Non-linear SAT Problem with OR-Tools in Python\nDESCRIPTION: This snippet defines a function to solve a non-linear constraint satisfaction problem using OR-Tools. It involves finding the dimensions of a rectangle maximizing its area given a fixed perimeter, using integer programming and multiplication equality constraints. The perimeter is set to 20, and IntVar variables are used for the rectangle's dimensions. The solution prints the optimal dimensions x, y, and the area.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/non_linear_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef non_linear_sat():\n    \"\"\"Non linear sample.\"\"\"\n    perimeter = 20\n\n    model = cp_model.CpModel()\n\n    x = model.new_int_var(0, perimeter, \"x\")\n    y = model.new_int_var(0, perimeter, \"y\")\n    model.add(2 * (x + y) == perimeter)\n\n    area = model.new_int_var(0, perimeter * perimeter, \"s\")\n    model.add_multiplication_equality(area, x, y)\n\n    model.maximize(area)\n\n    solver = cp_model.CpSolver()\n\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"x = {solver.value(x)}\")\n        print(f\"y = {solver.value(y)}\")\n        print(f\"s = {solver.value(area)}\")\n    else:\n        print(\"No solution found.\")\n\n\nnon_linear_sat()\n\n```\n\n----------------------------------------\n\nTITLE: Setting Time Constraints for Performed Shifts in CP-SAT Model\nDESCRIPTION: Adds upper bound on start times and lower bound on end times when a node (shift) is performed by a driver, ensuring proper scheduling within shift boundaries.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Node performed:\n#    - add upper bound on start_time\n#    - add lower bound on end_times\nmodel.add(start_times[d] <= shift[3] - setup_time).only_enforce_if(\n    performed[d, s]\n)\nmodel.add(end_times[d] >= shift[4] + cleanup_time).only_enforce_if(\n    performed[d, s]\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Search and Solving the Puzzle\nDESCRIPTION: Sets up the search parameters, runs the solver, and prints the results including the optimal solution and solver statistics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle2.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n  db = solver.Phase(col_signs + row_signs, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_MAX_VALUE)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"Sum =\", objective.Best())\n    print(\"row_sums:\", [row_sums[i].Value() for i in range(rows)])\n    print(\"col_sums:\", [col_sums[j].Value() for j in range(cols)])\n    for i in range(rows):\n      for j in range(cols):\n        print(\"%3i\" % x[i, j].Value(), end=\" \")\n      print()\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Interval Ranking with OR-Tools CP-SAT in Go\nDESCRIPTION: Demonstrates how to rank intervals in a NoOverlap constraint using OR-Tools CP-SAT solver. The implementation includes handling of optional intervals, precedence relationships between tasks, and makespan optimization. It uses boolean variables to track precedences and links them to rank variables while handling optional task execution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_24\n\nLANGUAGE: go\nCODE:\n```\n// The ranking_sample_sat command is an example of ranking intervals in a NoOverlap constraint.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n)\n\nconst (\n\thorizonLength = 100\n\tnumTasks      = 4\n)\n\n// rankTasks adds constraints and variables to link tasks and ranks. This method\n// assumes that all starts are disjoint, meaning that all tasks have a strictly\n// positive duration, and they appear in the same NoOverlap constraint.\nfunc rankTasks(starts []cpmodel.IntVar, presences []cpmodel.BoolVar, ranks []cpmodel.IntVar, model *cpmodel.Builder) {\n\t// Creates precedence variables between pairs of intervals.\n\tprecedences := make([][]cpmodel.BoolVar, numTasks)\n\tfor i := 0; i < numTasks; i++ {\n\t\tprecedences[i] = make([]cpmodel.BoolVar, numTasks)\n\t\tfor j := 0; j < numTasks; j++ {\n\t\t\tif i == j {\n\t\t\t\tprecedences[i][i] = presences[i]\n\t\t\t} else {\n\t\t\t\tprec := model.NewBoolVar()\n\t\t\t\tprecedences[i][j] = prec\n\t\t\t\tmodel.AddLessOrEqual(starts[i], starts[j]).OnlyEnforceIf(prec)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Treats optional intervals.\n\tfor i := 0; i+1 < numTasks; i++ {\n\t\tfor j := i + 1; j < numTasks; j++ {\n\t\t\t// Make sure that if task i is not performed, all precedences are false.\n\t\t\tmodel.AddImplication(presences[i].Not(), precedences[i][j].Not())\n\t\t\tmodel.AddImplication(presences[i].Not(), precedences[j][i].Not())\n\t\t\t// Make sure that if task j is not performed, all precedences are false.\n\t\t\tmodel.AddImplication(presences[j].Not(), precedences[i][j].Not())\n\t\t\tmodel.AddImplication(presences[j].Not(), precedences[j][i].Not())\n\t\t\t// The following BoolOr will enforce that for any two intervals:\n\t\t\t// \t\ti precedes j or j precedes i or at least one interval is not performed.\n\t\t\tmodel.AddBoolOr(precedences[i][j], precedences[j][i], presences[i].Not(), presences[j].Not())\n\t\t\t// Redundant constraint: it propagates early that at most one precedence\n\t\t\t// is true.\n\t\t\tmodel.AddImplication(precedences[i][j], precedences[j][i].Not())\n\t\t\tmodel.AddImplication(precedences[j][i], precedences[i][j].Not())\n\t\t}\n\t}\n\n\t// Links precedences and ranks.\n\tfor i := 0; i < numTasks; i++ {\n\t\tsumOfPredecessors := cpmodel.NewConstant(-1)\n\t\tfor j := 0; j < numTasks; j++ {\n\t\t\tsumOfPredecessors.Add(precedences[j][i])\n\t\t}\n\t\tmodel.AddEquality(ranks[i], sumOfPredecessors)\n\t}\n}\n\nfunc rankingSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tstarts := make([]cpmodel.IntVar, numTasks)\n\tends := make([]cpmodel.IntVar, numTasks)\n\tintervals := make([]cpmodel.IntervalVar, numTasks)\n\tpresences := make([]cpmodel.BoolVar, numTasks)\n\tranks := make([]cpmodel.IntVar, numTasks)\n\n\thorizon := cpmodel.NewDomain(0, horizonLength)\n\tpossibleRanks := cpmodel.NewDomain(-1, numTasks-1)\n\n\tfor t := 0; t < numTasks; t++ {\n\t\tstart := model.NewIntVarFromDomain(horizon)\n\t\tduration := cpmodel.NewConstant(int64(t + 1))\n\t\tend := model.NewIntVarFromDomain(horizon)\n\t\tvar presence cpmodel.BoolVar\n\t\tif t < numTasks/2 {\n\t\t\tpresence = model.TrueVar()\n\t\t} else {\n\t\t\tpresence = model.NewBoolVar()\n\t\t}\n\t\tinterval := model.NewOptionalIntervalVar(start, duration, end, presence)\n\t\trank := model.NewIntVarFromDomain(possibleRanks)\n\n\t\tstarts[t] = start\n\t\tends[t] = end\n\t\tintervals[t] = interval\n\t\tpresences[t] = presence\n\t\tranks[t] = rank\n\t}\n\n\t// Adds NoOverlap constraint.\n\tmodel.AddNoOverlap(intervals...)\n\n\t// Ranks tasks.\n\trankTasks(starts, presences, ranks, model)\n\n\t// Adds a constraint on ranks.\n\tmodel.AddLessThan(ranks[0], ranks[1])\n\n\t// Creates makespan variables.\n\tmakespan := model.NewIntVarFromDomain(horizon)\n\tfor t := 0; t < numTasks; t++ {\n\t\tmodel.AddLessOrEqual(ends[t], makespan).OnlyEnforceIf(presences[t])\n\t}\n\n\t// Create objective: minimize 2 * makespan - 7 * sum of presences.\n\t// This is you gain 7 by interval performed, but you pay 2 by day of delays.\n\tobjective := cpmodel.NewLinearExpr().AddTerm(makespan, 2)\n\tfor t := 0; t < numTasks; t++ {\n\t\tobjective.AddTerm(presences[t], -7)\n\t}\n\tmodel.Minimize(objective)\n\n\t// Solving part.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tresponse, err := cpmodel.SolveCpModel(m)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tif response.GetStatus() == cmpb.CpSolverStatus_OPTIMAL {\n\t\tfmt.Println(response.GetStatus())\n\t\tfmt.Println(\"Optimal cost: \", response.GetObjectiveValue())\n\t\tfmt.Println(\"Makespan: \", cpmodel.SolutionIntegerValue(response, makespan))\n\t\tfor t := 0; t < numTasks; t++ {\n\t\t\trank := cpmodel.SolutionIntegerValue(response, ranks[t])\n\t\t\tif cpmodel.SolutionBooleanValue(response, presences[t]) {\n\t\t\t\tstart := cpmodel.SolutionIntegerValue(response, starts[t])\n\t\t\t\tfmt.Printf(\"Task %v starts at %v with rank %v\\n\", t, start, rank)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Task %v is not performed and ranked at %v\\n\", t, rank)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := rankingSampleSat(); err != nil {\n\t\tlog.Exitf(\"rankingSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Task Ranking and Scheduling with OR-Tools CP-SAT Solver in C++\nDESCRIPTION: Implements a constraint satisfaction problem that schedules and ranks tasks with optional intervals. The solution uses a custom ranking function to establish precedence relationships between tasks while minimizing makespan and maximizing the number of tasks performed. The model enforces no-overlap constraints and customizes the objective function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <vector>\n\n#include \"absl/types/span.h\"\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid RankingSampleSat() {\n  CpModelBuilder cp_model;\n  const int kHorizon = 100;\n  const int kNumTasks = 4;\n\n  auto add_task_ranking = [&cp_model](absl::Span<const IntVar> starts,\n                                      absl::Span<const BoolVar> presences,\n                                      absl::Span<const IntVar> ranks) {\n    const int num_tasks = starts.size();\n\n    // Creates precedence variables between pairs of intervals.\n    std::vector<std::vector<BoolVar>> precedences(num_tasks);\n    for (int i = 0; i < num_tasks; ++i) {\n      precedences[i].resize(num_tasks);\n      for (int j = 0; j < num_tasks; ++j) {\n        if (i == j) {\n          precedences[i][i] = presences[i];\n        } else {\n          BoolVar prec = cp_model.NewBoolVar();\n          precedences[i][j] = prec;\n          cp_model.AddLessOrEqual(starts[i], starts[j]).OnlyEnforceIf(prec);\n        }\n      }\n    }\n\n    // Treats optional intervals.\n    for (int i = 0; i < num_tasks - 1; ++i) {\n      for (int j = i + 1; j < num_tasks; ++j) {\n        // Makes sure that if i is not performed, all precedences are\n        // false.\n        cp_model.AddImplication(~presences[i], ~precedences[i][j]);\n        cp_model.AddImplication(~presences[i], ~precedences[j][i]);\n        // Makes sure that if j is not performed, all precedences are\n        // false.\n        cp_model.AddImplication(~presences[j], ~precedences[i][j]);\n        cp_model.AddImplication(~presences[j], ~precedences[j][i]);\n        //  The following bool_or will enforce that for any two intervals:\n        //    i precedes j or j precedes i or at least one interval is not\n        //        performed.\n        cp_model.AddBoolOr({precedences[i][j], precedences[j][i], ~presences[i],\n                            ~presences[j]});\n        // Redundant constraint: it propagates early that at most one\n        // precedence is true.\n        cp_model.AddImplication(precedences[i][j], ~precedences[j][i]);\n        cp_model.AddImplication(precedences[j][i], ~precedences[i][j]);\n      }\n    }\n    // Links precedences and ranks.\n    for (int i = 0; i < num_tasks; ++i) {\n      LinearExpr sum_of_predecessors(-1);\n      for (int j = 0; j < num_tasks; ++j) {\n        sum_of_predecessors += precedences[j][i];\n      }\n      cp_model.AddEquality(ranks[i], sum_of_predecessors);\n    }\n  };\n\n  std::vector<IntVar> starts;\n  std::vector<IntVar> ends;\n  std::vector<IntervalVar> intervals;\n  std::vector<BoolVar> presences;\n  std::vector<IntVar> ranks;\n\n  const Domain horizon(0, kHorizon);\n  const Domain possible_ranks(-1, kNumTasks - 1);\n\n  for (int t = 0; t < kNumTasks; ++t) {\n    const IntVar start = cp_model.NewIntVar(horizon);\n    const int64_t duration = t + 1;\n    const IntVar end = cp_model.NewIntVar(horizon);\n    const BoolVar presence =\n        t < kNumTasks / 2 ? cp_model.TrueVar() : cp_model.NewBoolVar();\n    const IntervalVar interval =\n        cp_model.NewOptionalIntervalVar(start, duration, end, presence);\n    const IntVar rank = cp_model.NewIntVar(possible_ranks);\n\n    starts.push_back(start);\n    ends.push_back(end);\n    intervals.push_back(interval);\n    presences.push_back(presence);\n    ranks.push_back(rank);\n  }\n\n  // Adds NoOverlap constraint.\n  cp_model.AddNoOverlap(intervals);\n\n  // Ranks tasks.\n  add_task_ranking(starts, presences, ranks);\n\n  // Adds a constraint on ranks.\n  cp_model.AddLessThan(ranks[0], ranks[1]);\n\n  // Creates makespan variables.\n  const IntVar makespan = cp_model.NewIntVar(horizon);\n  for (int t = 0; t < kNumTasks; ++t) {\n    cp_model.AddLessOrEqual(ends[t], makespan).OnlyEnforceIf(presences[t]);\n  }\n\n  // Create objective: minimize 2 * makespan - 7 * sum of presences.\n  // That is you gain 7 by interval performed, but you pay 2 by day of delays.\n  LinearExpr objective = 2 * makespan;\n  for (int t = 0; t < kNumTasks; ++t) {\n    objective -= 7 * presences[t];\n  }\n  cp_model.Minimize(objective);\n\n  // Solving part.\n  const CpSolverResponse response = Solve(cp_model.Build());\n  LOG(INFO) << CpSolverResponseStats(response);\n\n  if (response.status() == CpSolverStatus::OPTIMAL) {\n    LOG(INFO) << \"Optimal cost: \" << response.objective_value();\n    LOG(INFO) << \"Makespan: \" << SolutionIntegerValue(response, makespan);\n    for (int t = 0; t < kNumTasks; ++t) {\n      if (SolutionBooleanValue(response, presences[t])) {\n        LOG(INFO) << \"task \" << t << \" starts at \"\n                  << SolutionIntegerValue(response, starts[t]) << \" with rank \"\n                  << SolutionIntegerValue(response, ranks[t]);\n      } else {\n        LOG(INFO) << \"task \" << t << \" is not performed and ranked at \"\n                  << SolutionIntegerValue(response, ranks[t]);\n      }\n    }\n  }\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::RankingSampleSat();\n\n  return EXIT_SUCCESS;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Model Cloning in Java\nDESCRIPTION: Demonstrates model cloning functionality in OR-Tools using Java. Shows how to create a base optimization model, solve it, create a deep copy, add new constraints to the copy, and solve the modified version.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\n\n\n/** Minimal CP-SAT example to showcase cloning a model. */\npublic final class CloneModelSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n\n    // Create the constraints.\n    model.addDifferent(x, y);\n\n    model.maximize(LinearExpr.newBuilder().add(x).addTerm(y, 2).addTerm(z, 3).build());\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    CpSolverStatus unusedStatus = solver.solve(model);\n    System.out.printf(\"Optimal value of the original model: %f\\n\", solver.objectiveValue());\n\n    CpModel copy = model.getClone();\n\n    // Add new constraint: copy_of_x + copy_of_y == 1.\n    IntVar copyOfX = copy.getIntVarFromProtoIndex(x.getIndex());\n    IntVar copyOfY = copy.getIntVarFromProtoIndex(y.getIndex());\n\n    copy.addLessOrEqual(LinearExpr.newBuilder().add(copyOfX).add(copyOfY).build(), 1);\n\n    unusedStatus = solver.solve(copy);\n    System.out.printf(\"Optimal value of the cloned model: %f\\n\", solver.objectiveValue());\n  }\n\n  private CloneModelSampleSat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Solving and Printing Linear Programming Results with OR-Tools\nDESCRIPTION: Utility function that solves a linear programming problem and prints detailed results including objective value, variable values, reduced costs, and constraint dual values. It also verifies the solution's accuracy if the solver is precise.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_programming.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef SolveAndPrint(solver, variable_list, constraint_list, is_precise):\n    \"\"\"Solve the problem and print the solution.\"\"\"\n    print(\"Number of variables = %d\" % solver.NumVariables())\n    print(\"Number of constraints = %d\" % solver.NumConstraints())\n\n    result_status = solver.Solve()\n\n    # The problem has an optimal solution.\n    assert result_status == pywraplp.Solver.OPTIMAL\n\n    # The solution looks legit (when using solvers others than\n    # GLOP_LINEAR_PROGRAMMING, verifying the solution is highly recommended!).\n    if is_precise:\n        assert solver.VerifySolution(1e-7, True)\n\n    print(\"Problem solved in %f milliseconds\" % solver.wall_time())\n\n    # The objective value of the solution.\n    print(\"Optimal objective value = %f\" % solver.Objective().Value())\n\n    # The value of each variable in the solution.\n    for variable in variable_list:\n        print(\"%s = %f\" % (variable.name(), variable.solution_value()))\n\n    print(\"Advanced usage:\")\n    print(\"Problem solved in %d iterations\" % solver.iterations())\n    for variable in variable_list:\n        print(\"%s: reduced cost = %f\" % (variable.name(), variable.reduced_cost()))\n    activities = solver.ComputeConstraintActivities()\n    for i, constraint in enumerate(constraint_list):\n        print(\n            (\n                \"constraint %d: dual value = %f\\n               activity = %f\"\n                % (i, constraint.dual_value(), activities[constraint.index()])\n            )\n        )\n```\n\n----------------------------------------\n\nTITLE: Implementing Step Function with OR-Tools in C++\nDESCRIPTION: This code snippet demonstrates how to implement a step function using OR-Tools in C++. It creates a CP-SAT model, defines variables and constraints to represent the step function, and solves the model while printing the solutions. The step function is defined for specific ranges of the primary variable 'x'.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"absl/types/span.h\"\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/sat/sat_parameters.pb.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid StepFunctionSampleSat() {\n  // Create the CP-SAT model.\n  CpModelBuilder cp_model;\n\n  // Declare our primary variable.\n  const IntVar x = cp_model.NewIntVar({0, 20});\n\n  // Create the expression variable and implement the step function\n  // Note it is not defined for var == 2.\n  //\n  //        -               3\n  // -- --      ---------   2\n  //                        1\n  //      -- ---            0\n  // 0 ================ 20\n  //\n  IntVar expr = cp_model.NewIntVar({0, 3});\n\n  // expr == 0 on [5, 6] U [8, 10]\n  BoolVar b0 = cp_model.NewBoolVar();\n  cp_model.AddLinearConstraint(x, Domain::FromValues({5, 6, 8, 9, 10}))\n      .OnlyEnforceIf(b0);\n  cp_model.AddEquality(expr, 0).OnlyEnforceIf(b0);\n\n  // expr == 2 on [0, 1] U [3, 4] U [11, 20]\n  BoolVar b2 = cp_model.NewBoolVar();\n  cp_model\n      .AddLinearConstraint(x, Domain::FromIntervals({{0, 1}, {3, 4}, {11, 20}}))\n      .OnlyEnforceIf(b2);\n  cp_model.AddEquality(expr, 2).OnlyEnforceIf(b2);\n\n  // expr == 3 when x = 7\n  BoolVar b3 = cp_model.NewBoolVar();\n  cp_model.AddEquality(x, 7).OnlyEnforceIf(b3);\n  cp_model.AddEquality(expr, 3).OnlyEnforceIf(b3);\n\n  // At least one bi is true. (we could use an exactly one constraint).\n  cp_model.AddBoolOr({b0, b2, b3});\n\n  // Search for x values in increasing order.\n  cp_model.AddDecisionStrategy({x}, DecisionStrategyProto::CHOOSE_FIRST,\n                               DecisionStrategyProto::SELECT_MIN_VALUE);\n\n  // Create a solver and solve with a fixed search.\n  Model model;\n  SatParameters parameters;\n  parameters.set_search_branching(SatParameters::FIXED_SEARCH);\n  parameters.set_enumerate_all_solutions(true);\n  model.Add(NewSatParameters(parameters));\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"x=\" << SolutionIntegerValue(r, x) << \" expr\"\n              << SolutionIntegerValue(r, expr);\n  }));\n  SolveCpModel(cp_model.Build(), &model);\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::StepFunctionSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Search After N Solutions in C++ with OR-Tools CP-SAT Solver\nDESCRIPTION: This C++ code shows how to stop the search process in OR-Tools CP-SAT solver after finding a specific number of solutions. It uses an atomic boolean and a time limit to control the search process, along with a solution observer to count and print solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include <atomic>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/sat/sat_parameters.pb.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n#include \"ortools/util/time_limit.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid StopAfterNSolutionsSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  Model model;\n\n  // Tell the solver to enumerate all solutions.\n  SatParameters parameters;\n  parameters.set_enumerate_all_solutions(true);\n  model.Add(NewSatParameters(parameters));\n\n  // Create an atomic Boolean that will be periodically checked by the limit.\n  std::atomic<bool> stopped(false);\n  model.GetOrCreate<TimeLimit>()->RegisterExternalBooleanAsLimit(&stopped);\n\n  const int kSolutionLimit = 5;\n  int num_solutions = 0;\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"Solution \" << num_solutions;\n    LOG(INFO) << \"  x = \" << SolutionIntegerValue(r, x);\n    LOG(INFO) << \"  y = \" << SolutionIntegerValue(r, y);\n    LOG(INFO) << \"  z = \" << SolutionIntegerValue(r, z);\n    num_solutions++;\n    if (num_solutions >= kSolutionLimit) {\n      stopped = true;\n      LOG(INFO) << \"Stop search after \" << kSolutionLimit << \" solutions.\";\n    }\n  }));\n  const CpSolverResponse response = SolveCpModel(cp_model.Build(), &model);\n  LOG(INFO) << \"Number of solutions found: \" << num_solutions;\n  CHECK_EQ(num_solutions, kSolutionLimit);\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::StopAfterNSolutionsSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables and Constraints for Max Flow Problem\nDESCRIPTION: This snippet declares the flow variables, sets up constraints for arc capacities, flow conservation, and valid connections. It also defines the objective function to maximize the flow.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/max_flow_winston1.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n  flow = {}\n  for i in nodes:\n    for j in nodes:\n      flow[i, j] = solver.IntVar(0, 200, 'flow %i %i' % (i, j))\n\n  flow_flat = [flow[i, j] for i in nodes for j in nodes]\n\n  z = solver.IntVar(0, 10000, 'z')\n\n  #\n  # constraints\n  #\n  solver.Add(z == flow[n - 1, 0])\n\n  # capacity of arcs\n  for i in range(num_arcs):\n    solver.Add(flow[arcs[i][0], arcs[i][1]] <= cap[i])\n\n  # inflows == outflows\n  for i in nodes:\n    s1 = solver.Sum([\n        flow[arcs[k][0], arcs[k][1]] for k in range(num_arcs) if arcs[k][1] == i\n    ])\n    s2 = solver.Sum([\n        flow[arcs[k][0], arcs[k][1]] for k in range(num_arcs) if arcs[k][0] == i\n    ])\n    solver.Add(s1 == s2)\n\n  # sanity: just arcs with connections can have a flow\n  for i in nodes:\n    for j in nodes:\n      if mat[i, j] == 0:\n        solver.Add(flow[i, j] == 0)\n\n  # objective: maximize z\n  objective = solver.Maximize(z, 1)\n```\n\n----------------------------------------\n\nTITLE: Implementing All Interval Problem using CP Solver\nDESCRIPTION: Main implementation of the All Interval Problem using Google's Constraint Programming Solver. It creates variables for the sequence of integers and their differences, adds constraints to ensure all values and differences are unique, and implements symmetry breaking to reduce redundant solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/all_interval.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=12):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"All interval\")\n\n  #\n  # data\n  #\n  print(\"n:\", n)\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(1, n, \"x[%i]\" % i) for i in range(n)]\n  diffs = [solver.IntVar(1, n - 1, \"diffs[%i]\" % i) for i in range(n - 1)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n  solver.Add(solver.AllDifferent(diffs))\n\n  for k in range(n - 1):\n    solver.Add(diffs[k] == abs(x[k + 1] - x[k]))\n\n  # symmetry breaking\n  solver.Add(x[0] < x[n - 1])\n  solver.Add(diffs[0] < diffs[1])\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(diffs)\n\n  db = solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"x:\", [x[i].Value() for i in range(n)])\n    print(\"diffs:\", [diffs[i].Value() for i in range(n - 1)])\n    num_solutions += 1\n    print()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 12\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: Scheduling Constraint Model Implementation in Python with OR-Tools\nDESCRIPTION: Implements a constraint programming model for job scheduling optimization. The code adds circuit constraints, handles job precedences, defines makespan objective, writes the model to a file, and solves the optimization problem using CP-SAT solver. It outputs the start and end times for each job.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/single_machine_scheduling_with_setup_release_due_dates_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmodel.add(starts[j] >= ends[i] + setup_times[i + 1][j]).only_enforce_if(lit)\n\nmodel.add_circuit(arcs)\n\n# ----------------------------------------------------------------------------\n# Precedences.\nfor before, after in precedences:\n    print(f\"job {after} is after job {before}\")\n    model.add(ends[before] <= starts[after])\n\n# ----------------------------------------------------------------------------\n# Objective.\nmakespan = model.new_int_var(0, horizon, \"makespan\")\nmodel.add_max_equality(makespan, ends)\nmodel.minimize(makespan)\n\n# ----------------------------------------------------------------------------\n# Write problem to file.\nif output_proto_file:\n    print(f\"Writing proto to {output_proto_file}\")\n    with open(output_proto_file, \"w\") as text_file:\n        text_file.write(str(model))\n\n# ----------------------------------------------------------------------------\n# Solve.\nsolver = cp_model.CpSolver()\nif parameters:\n    text_format.Parse(parameters, solver.parameters)\nsolution_printer = SolutionPrinter()\nsolver.best_bound_callback = lambda a: print(f\"New objective lower bound: {a}\")\nsolver.solve(model, solution_printer)\nfor job_id in all_jobs:\n    print(\n        f\"job {job_id} starts at {solver.value(starts[job_id])} end ends at\"\n        f\" {solver.value(ends[job_id])}\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Ranking Intervals with OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This complete sample demonstrates how to rank intervals in a scheduling problem where some tasks are optional. It uses CP-SAT solver from OR-Tools to minimize makespan while maximizing the number of tasks performed. The code creates precedence relationships between intervals and links them to rank variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrates how to rank intervals.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef rank_tasks(\n    model: cp_model.CpModel,\n    starts: list[cp_model.IntVar],\n    presences: list[cp_model.BoolVarT],\n    ranks: list[cp_model.IntVar],\n) -> None:\n    \"\"\"This method adds constraints and variables to links tasks and ranks.\n\n    This method assumes that all starts are disjoint, meaning that all tasks have\n    a strictly positive duration, and they appear in the same NoOverlap\n    constraint.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      presences: The array of presence variables or constants of all tasks.\n      ranks: The array of rank variables of all tasks.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    # Creates precedence variables between pairs of intervals.\n    precedences: dict[tuple[int, int], cp_model.BoolVarT] = {}\n    for i in all_tasks:\n        for j in all_tasks:\n            if i == j:\n                precedences[(i, j)] = presences[i]\n            else:\n                prec = model.new_bool_var(f\"{i} before {j}\")\n                precedences[(i, j)] = prec\n                model.add(starts[i] < starts[j]).only_enforce_if(prec)\n\n    # Treats optional intervals.\n    for i in range(num_tasks - 1):\n        for j in range(i + 1, num_tasks):\n            tmp_array: list[cp_model.BoolVarT] = [\n                precedences[(i, j)],\n                precedences[(j, i)],\n            ]\n            if not cp_model.object_is_a_true_literal(presences[i]):\n                tmp_array.append(~presences[i])\n                # Makes sure that if i is not performed, all precedences are false.\n                model.add_implication(~presences[i], ~precedences[(i, j)])\n                model.add_implication(~presences[i], ~precedences[(j, i)])\n            if not cp_model.object_is_a_true_literal(presences[j]):\n                tmp_array.append(~presences[j])\n                # Makes sure that if j is not performed, all precedences are false.\n                model.add_implication(~presences[j], ~precedences[(i, j)])\n                model.add_implication(~presences[j], ~precedences[(j, i)])\n            # The following bool_or will enforce that for any two intervals:\n            #    i precedes j or j precedes i or at least one interval is not\n            #        performed.\n            model.add_bool_or(tmp_array)\n            # Redundant constraint: it propagates early that at most one precedence\n            # is true.\n            model.add_implication(precedences[(i, j)], ~precedences[(j, i)])\n            model.add_implication(precedences[(j, i)], ~precedences[(i, j)])\n\n    # Links precedences and ranks.\n    for i in all_tasks:\n        model.add(ranks[i] == sum(precedences[(j, i)] for j in all_tasks) - 1)\n\n\ndef ranking_sample_sat() -> None:\n    \"\"\"Ranks tasks in a NoOverlap constraint.\"\"\"\n\n    model = cp_model.CpModel()\n    horizon = 100\n    num_tasks = 4\n    all_tasks = range(num_tasks)\n\n    starts = []\n    ends = []\n    intervals = []\n    presences: list[cp_model.BoolVarT] = []\n    ranks = []\n\n    # Creates intervals, half of them are optional.\n    for t in all_tasks:\n        start = model.new_int_var(0, horizon, f\"start[{t}]\")\n        duration = t + 1\n        end = model.new_int_var(0, horizon, f\"end[{t}]\")\n        if t < num_tasks // 2:\n            interval = model.new_interval_var(start, duration, end, f\"interval[{t}]\")\n            presence = model.new_constant(1)\n        else:\n            presence = model.new_bool_var(f\"presence[{t}]\")\n            interval = model.new_optional_interval_var(\n                start, duration, end, presence, f\"o_interval[{t}]\"\n            )\n        starts.append(start)\n        ends.append(end)\n        intervals.append(interval)\n        presences.append(presence)\n\n        # Ranks = -1 if and only if the tasks is not performed.\n        ranks.append(model.new_int_var(-1, num_tasks - 1, f\"rank[{t}]\"))\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds ranking constraint.\n    rank_tasks(model, starts, presences, ranks)\n\n    # Adds a constraint on ranks.\n    model.add(ranks[0] < ranks[1])\n\n    # Creates makespan variable.\n    makespan = model.new_int_var(0, horizon, \"makespan\")\n    for t in all_tasks:\n        model.add(ends[t] <= makespan).only_enforce_if(presences[t])\n\n    # Minimizes makespan - fixed gain per tasks performed.\n    # As the fixed cost is less that the duration of the last interval,\n    # the solver will not perform the last interval.\n    model.minimize(2 * makespan - 7 * sum(presences[t] for t in all_tasks))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Prints out the makespan and the start times and ranks of all tasks.\n        print(f\"Optimal cost: {solver.objective_value}\")\n        print(f\"Makespan: {solver.value(makespan)}\")\n        for t in all_tasks:\n            if solver.value(presences[t]):\n                print(\n                    f\"Task {t} starts at {solver.value(starts[t])} \"\n                    f\"with rank {solver.value(ranks[t])}\"\n                )\n            else:\n                print(\n                    f\"Task {t} in not performed and ranked at {solver.value(ranks[t])}\"\n                )\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n\n\nranking_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Vendor Scheduling Implementation with OR-Tools\nDESCRIPTION: Main implementation of the vendor scheduling solution using OR-Tools constraint solver. Creates a schedule for 9 vendors across 10 hours while handling traffic constraints. The code includes data setup, variable declaration, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/vendor_scheduling.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n  # Create the solver.\n  solver = pywrapcp.Solver('Vendors scheduling')\n\n  #\n  # data\n  #\n  num_vendors = 9\n  num_hours = 10\n  num_work_types = 1\n\n  trafic = [100, 500, 100, 200, 320, 300, 200, 220, 300, 120]\n  max_trafic_per_vendor = 100\n\n  # Last columns are :\n  #   index_of_the_schedule, sum of worked hours (per work type).\n  # The index is useful for branching.\n  possible_schedules = [[1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 8],\n                        [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 4],\n                        [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 2, 5],\n                        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 3, 4],\n                        [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 3],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0]]\n\n  num_possible_schedules = len(possible_schedules)\n  selected_schedules = []\n  vendors_stat = []\n  hours_stat = []\n\n  #\n  # declare variables\n  #\n  x = {}\n\n  for i in range(num_vendors):\n    tmp = []\n    for j in range(num_hours):\n      x[i, j] = solver.IntVar(0, num_work_types, 'x[%i,%i]' % (i, j))\n      tmp.append(x[i, j])\n    selected_schedule = solver.IntVar(0, num_possible_schedules - 1,\n                                      's[%i]' % i)\n    hours = solver.IntVar(0, num_hours, 'h[%i]' % i)\n    selected_schedules.append(selected_schedule)\n    vendors_stat.append(hours)\n    tmp.append(selected_schedule)\n    tmp.append(hours)\n\n    solver.Add(solver.AllowedAssignments(tmp, possible_schedules))\n\n  #\n  # Statistics and constraints for each hour\n  #\n  for j in range(num_hours):\n    workers = solver.Sum([x[i, j] for i in range(num_vendors)]).Var()\n    hours_stat.append(workers)\n    solver.Add(workers * max_trafic_per_vendor >= trafic[j])\n\n  #\n  # Redundant constraint: sort selected_schedules\n  #\n  for i in range(num_vendors - 1):\n    solver.Add(selected_schedules[i] <= selected_schedules[i + 1])\n\n  #\n  # Search\n  #\n  db = solver.Phase(selected_schedules, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n\n    for i in range(num_vendors):\n      print('Vendor %i: ' % i,\n            possible_schedules[selected_schedules[i].Value()])\n    print()\n\n    print('Statistics per day:')\n    for j in range(num_hours):\n      print('Day%2i: ' % j, end=' ')\n      print(hours_stat[j].Value(), end=' ')\n      print()\n    print()\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Regular Constraint Implementation in Python\nDESCRIPTION: Implementation of a regular constraint function that enforces DFA-based patterns on sequences. Takes transition matrix, states, and acceptance conditions as input to create scheduling constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nurse_rostering.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef regular(x, Q, S, d, q0, F):\n  solver = x[0].solver()\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n  d2 = []\n  for i in range(Q + 1):\n    row = []\n    for j in range(S):\n      if i == 0:\n        row.append(0)\n      else:\n        row.append(d[i - 1][j])\n    d2.append(row)\n  d2_flatten = [d2[i][j] for i in range(Q + 1) for j in range(S)]\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n  a = [solver.IntVar(0, Q + 1, 'a[%i]' % i) for i in range(m, n + 1)]\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n    solver.Add(a[i + 1] == solver.Element(d2_flatten, ((a[i]) * S) + (x[i] - 1)))\n```\n\n----------------------------------------\n\nTITLE: Bus Driver Scheduling Model Setup\nDESCRIPTION: Initial setup code including imports, argument parsing and sample data for small scheduling instance. Defines shift data structure with timing information.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nimport collections\nimport math\n\nfrom ortools.sat.python import cp_model\n\nPARSER = argparse.ArgumentParser()\nPARSER.add_argument(\"--instance\", default=1, type=int, help=\"Instance number (1..3).\")\nPARSER.add_argument(\n    \"--output_proto_file\",\n    default=\"\",\n    help=\"Output file to write the cp_model\" \"proto to.\",\n)\nPARSER.add_argument(\"--params\", default=\"\", help=\"Sat solver parameters.\")\n\nSAMPLE_SHIFTS_SMALL = [\n    #\n    # column description:\n    # - shift id\n    # - shift start time as hh:mm string (for logging and readability purposes)\n    # - shift end time as hh:mm string (for logging and readability purposes)\n    # - shift start minute\n    # - shift end minute\n    # - shift duration in minutes\n    #\n    [0, \"05:18\", \"06:00\", 318, 360, 42],\n    [1, \"05:26\", \"06:08\", 326, 368, 42],\n    [2, \"05:40\", \"05:56\", 340, 356, 16],\n    [3, \"06:06\", \"06:51\", 366, 411, 45],\n    [4, \"06:40\", \"07:52\", 400, 472, 72],\n    [5, \"06:42\", \"07:13\", 402, 433, 31],\n    [6, \"06:48\", \"08:15\", 408, 495, 87],\n    [7, \"06:59\", \"08:07\", 419, 487, 68],\n    [8, \"07:20\", \"07:36\", 440, 456, 16],\n    [9, \"07:35\", \"08:22\", 455, 502, 47],\n    [10, \"07:50\", \"08:55\", 470, 535, 65],\n    [11, \"08:00\", \"09:05\", 480, 545, 65],\n    [12, \"08:00\", \"08:35\", 480, 515, 35],\n    [13, \"08:11\", \"09:41\", 491, 581, 90],\n    [14, \"08:28\", \"08:50\", 508, 530, 22],\n    [15, \"08:35\", \"08:45\", 515, 525, 10],\n    [16, \"08:40\", \"08:50\", 520, 530, 10],\n    [17, \"09:03\", \"10:28\", 543, 628, 85],\n    [18, \"09:23\", \"09:49\", 563, 589, 26],\n    [19, \"09:30\", \"09:40\", 570, 580, 10],\n    [20, \"09:57\", \"10:20\", 597, 620, 23],\n    [21, \"10:09\", \"11:03\", 609, 663, 54],\n    [22, \"10:20\", \"10:30\", 620, 630, 10],\n    [23, \"11:00\", \"11:10\", 660, 670, 10],\n    [24, \"11:45\", \"12:24\", 705, 744, 39],\n    [25, \"12:18\", \"13:00\", 738, 780, 42],\n    [26, \"13:18\", \"14:44\", 798, 884, 86],\n    [27, \"13:53\", \"14:49\", 833, 889, 56],\n    [28, \"14:03\", \"14:50\", 843, 890, 47],\n    [29, \"14:28\", \"15:15\", 868, 915, 47],\n    [30, \"14:30\", \"15:41\", 870, 941, 71],\n    [31, \"14:48\", \"15:35\", 888, 935, 47],\n    [32, \"15:03\", \"15:50\", 903, 950, 47],\n    [33, \"15:28\", \"16:54\", 928, 1014, 86],\n    [34, \"15:38\", \"16:25\", 938, 985, 47],\n    [35, \"15:40\", \"15:56\", 940, 956, 16],\n    [36, \"15:58\", \"16:45\", 958, 1005, 47],\n    [37, \"16:04\", \"17:30\", 964, 1050, 86],\n    [38, \"16:28\", \"17:15\", 988, 1035, 47],\n    [39, \"16:36\", \"17:21\", 996, 1041, 45],\n    [40, \"16:50\", \"17:00\", 1010, 1020, 10],\n    [41, \"16:54\", \"18:20\", 1014, 1100, 86],\n    [42, \"17:01\", \"17:13\", 1021, 1033, 12],\n    [43, \"17:19\", \"18:31\", 1039, 1111, 72],\n    [44, \"17:23\", \"18:10\", 1043, 1090, 47],\n    [45, \"17:34\", \"18:15\", 1054, 1095, 41],\n    [46, \"18:04\", \"19:29\", 1084, 1169, 85],\n    [47, \"18:34\", \"19:58\", 1114, 1198, 84],\n    [48, \"19:56\", \"20:34\", 1196, 1234, 38],\n    [49, \"20:05\", \"20:48\", 1205, 1248, 43],\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Solution Printer for CP-SAT in Python\nDESCRIPTION: Defines a custom solution printer class that inherits from CpSolverSolutionCallback. It prints intermediate solutions and stops the search after a specified number of solutions are found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/stop_after_n_solutions_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass VarArraySolutionPrinterWithLimit(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar], limit: int):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__solution_count = 0\n        self.__solution_limit = limit\n\n    def on_solution_callback(self) -> None:\n        self.__solution_count += 1\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n        if self.__solution_count >= self.__solution_limit:\n            print(f\"Stop search after {self.__solution_limit} solutions\")\n            self.stop_search()\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n```\n\n----------------------------------------\n\nTITLE: Set Cover Problem Implementation\nDESCRIPTION: Implements a set covering problem using OR-Tools. Creates a model with three subsets covering two elements, where the first two subsets have cost 2.0 and cover one element each, while the third subset has cost 1.0 and covers both elements. Uses a greedy heuristic to find an optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/algorithms/set_cover.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.algorithms.python import set_cover\n\n\ndef main():\n    model = set_cover.SetCoverModel()\n    model.add_empty_subset(2.0)\n    model.add_element_to_last_subset(0)\n    model.add_empty_subset(2.0)\n    model.add_element_to_last_subset(1)\n    model.add_empty_subset(1.0)\n    model.add_element_to_last_subset(0)\n    model.add_element_to_last_subset(1)\n\n    inv = set_cover.SetCoverInvariant(model)\n    greedy = set_cover.GreedySolutionGenerator(inv)\n    has_found = greedy.next_solution()\n    if not has_found:\n        print(\"No solution found by the greedy heuristic.\")\n        return\n    solution = inv.export_solution_as_proto()\n\n    print(f\"Total cost: {solution.cost}\")  # == inv.cost()\n    print(f\"Total number of selected subsets: {solution.num_subsets}\")\n    print(\"Chosen subsets:\")\n    for subset in solution.subset:\n        print(f\"  {subset}\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Diet Optimization with Google CP Solver in Python\nDESCRIPTION: This code implements a diet optimization problem using Google CP Solver. It defines food products, their nutritional values, prices, and nutritional requirements. The solver then finds the optimal combination of products to meet the requirements at the lowest cost.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/diet1.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef main(unused_argv):\n  # Create the solver.\n  model = cp_model.CpModel()\n\n  #\n  # data\n  #\n  n = 4\n  price = [50, 20, 30, 80]  # in cents\n  limits = [500, 6, 10, 8]  # requirements for each nutrition type\n\n  # nutritions for each product\n  calories = [400, 200, 150, 500]\n  chocolate = [3, 2, 0, 0]\n  sugar = [2, 2, 4, 4]\n  fat = [2, 4, 1, 5]\n\n  #\n  # declare variables\n  #\n  x = [model.NewIntVar(0, 100, \"x%d\" % i) for i in range(n)]\n  cost = model.NewIntVar(0, 10000, \"cost\")\n\n  #\n  # constraints\n  #\n  model.Add(sum(x[i] * calories[i] for i in range(n)) >= limits[0])\n  model.Add(sum(x[i] * chocolate[i] for i in range(n)) >= limits[1])\n  model.Add(sum(x[i] * sugar[i] for i in range(n)) >= limits[2])\n  model.Add(sum(x[i] * fat[i] for i in range(n)) >= limits[3])\n\n  # objective\n  model.Minimize(cost)\n\n  # Solve model.\n  solver = cp_model.CpSolver()\n  status = solver.Solve(model)\n\n  # Output solution.\n  if status == cp_model.OPTIMAL:\n    print(\"cost:\", solver.ObjectiveValue())\n    print([((\"abcdefghij\")[i], solver.Value(x[i])) for i in range(n)])\n    print()\n    print('  - status          : %s' % solver.StatusName(status))\n    print('  - conflicts       : %i' % solver.NumConflicts())\n    print('  - branches        : %i' % solver.NumBranches())\n    print('  - wall time       : %f ms' % solver.WallTime())\n    print()\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Printing VRP Solution\nDESCRIPTION: Defines a function to print the solution of the Vehicle Routing Problem, including the route for each vehicle and the total distance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    total_distance = 0\n    for vehicle_index in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(solution, vehicle_index):\n            continue\n        index = routing.Start(vehicle_index)\n        plan_output = f\"Route for vehicle {vehicle_index}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} ->\"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_index\n            )\n        plan_output += f\" {manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        total_distance += route_distance\n    print(f\"Total Distance of all routes: {total_distance}m\")\n```\n\n----------------------------------------\n\nTITLE: Computing First True Boolean Index with OR-Tools in Python\nDESCRIPTION: Shows how to find the index of the first boolean variable set to true in a sequence using OR-Tools. Implements a min_equality constraint and demonstrates solution printing through a callback.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Compute the index of the first Boolean variable set to true.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, index: cp_model.IntVar, boolvars: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__index = index\n        self.__boolvars = boolvars\n\n    def on_solution_callback(self) -> None:\n        line = \"\"\n        for v in self.__boolvars:\n            line += f\"{self.value(v)}\"\n        line += f\" -> {self.value(self.__index)}\"\n        print(line)\n\n\ndef index_of_first_bool_at_true_sample_sat():\n    \"\"\"Compute the index of the first Boolean variable set to true.\"\"\"\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Variables\n    num_bool_vars = 5\n    bool_vars = [model.new_bool_var(f\"{i}\") for i in range(num_bool_vars)]\n    index = model.new_int_var(0, num_bool_vars, \"index\")\n\n    # Channeling between the index and the Boolean variables.\n    model.add_min_equality(\n        index,\n        [\n            num_bool_vars - bool_vars[i] * (num_bool_vars - i)\n            for i in range(num_bool_vars)\n        ],\n    )\n\n    # Flip bool_vars in increasing order.\n    model.add_decision_strategy(\n        bool_vars, cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE\n    )\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n\n    # Search and print out all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    solution_printer = VarArraySolutionPrinter(index, bool_vars)\n    solver.solve(model, solution_printer)\n\n\nindex_of_first_bool_at_true_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Transition Matrix from Pattern in Python\nDESCRIPTION: This function generates a transition matrix for a DFA based on a given pattern. It's used to create the transition function required by the regular constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef make_transition_matrix(pattern):\n\n  p_len = len(pattern)\n  print('p_len:', p_len)\n  num_states = p_len + sum(pattern)\n  print('num_states:', num_states)\n  t_matrix = []\n  for i in range(num_states):\n    row = []\n    for j in range(2):\n      row.append(0)\n    t_matrix.append(row)\n\n  tmp = [0 for i in range(num_states)]\n  c = 0\n  tmp[c] = 0\n  for i in range(p_len):\n    for j in range(pattern[i]):\n      c += 1\n      tmp[c] = 1\n    if c < num_states - 1:\n      c += 1\n      tmp[c] = 0\n  print('tmp:', tmp)\n\n  t_matrix[num_states - 1][0] = num_states\n  t_matrix[num_states - 1][1] = 0\n\n  for i in range(num_states):\n    if tmp[i] == 0:\n      t_matrix[i][0] = i + 1\n      t_matrix[i][1] = i + 2\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          t_matrix[i][0] = 0\n          t_matrix[i][1] = i + 2\n        else:\n          t_matrix[i][0] = i + 2\n          t_matrix[i][1] = 0\n\n  print('The states:')\n  for i in range(num_states):\n    for j in range(2):\n      print(t_matrix[i][j], end=' ')\n    print()\n  print()\n\n  return t_matrix\n```\n\n----------------------------------------\n\nTITLE: Solving Curious Set of Integers Problem\nDESCRIPTION: Main implementation using OR-Tools constraint solver to find sets of integers where product of any two numbers is one less than a perfect square. Includes helper function for enforcing decreasing order, variable initialization, constraint setup, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/curious_set_of_integers.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef decreasing(solver, x):\n  for i in range(len(x) - 1):\n    solver.Add(x[i] <= x[i + 1])\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Curious set of integers\")\n\n  #\n  # data\n  #\n  n = 5\n  max_val = 10000\n\n  #\n  # variables\n  #\n  x = [solver.IntVar(0, max_val, \"x[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n  decreasing(solver, x)\n\n  for i in range(n):\n    for j in range(n):\n      if i != j:\n        p = solver.IntVar(0, max_val, \"p[%i,%i]\" % (i, j))\n        solver.Add(p * p - 1 == (x[i] * x[j]))\n\n  # This is the original problem:\n  # Which is the fifth number?\n  v = [1, 3, 8, 120]\n  b = [solver.IsMemberVar(x[i], v) for i in range(n)]\n  solver.Add(solver.Sum(b) == 4)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(x, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"x:\", [int(x[i].Value()) for i in range(n)])\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Set Covering Optimization Implementation\nDESCRIPTION: Main implementation of the set covering problem that minimizes the number of security telephones on street corners. Uses OR-Tools constraint solver to ensure all street corners are covered while minimizing the total number of telephones placed. Includes problem setup, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef main(unused_argv):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set covering\")\n\n  #\n  # data\n  #\n  n = 8  # maximum number of corners\n  num_streets = 11  # number of connected streets\n\n  # corners of each street\n  # Note: 1-based (handled below)\n  corner = [[1, 2], [2, 3], [4, 5], [7, 8], [6, 7], [2, 6], [1, 6], [4, 7],\n            [2, 4], [5, 8], [3, 5]]\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 1, \"x[%i]\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n\n  # number of telephones, to be minimized\n  z = solver.Sum(x)\n\n  # ensure that all corners are covered\n  for i in range(num_streets):\n    # also, convert to 0-based\n    solver.Add(solver.SumGreaterOrEqual([x[j - 1] for j in corner[i]], 1))\n\n  objective = solver.Minimize(z, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.AddObjective(z)\n\n  collector = solver.LastSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT),\n      [collector, objective])\n\n  print(\"z:\", collector.ObjectiveValue(0))\n  print(\"x:\", [collector.Value(0, x[i]) for i in range(n)])\n\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom GridSinglePath Constraint in Python with OR-Tools\nDESCRIPTION: A custom constraint class that enforces a single connected path in the Slither Link grid. It tracks reachability of nodes and prunes unreachable parts of the graph during constraint propagation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass GridSinglePath(pywrapcp.PyConstraint):\n\n  def __init__(self, solver, h_arcs, v_arcs):\n    pywrapcp.PyConstraint.__init__(self, solver)\n    self.__h_arcs = h_arcs\n    self.__v_arcs = v_arcs\n\n  def Post(self):\n    demon = self.DelayedInitialPropagateDemon()\n    for row in self.__h_arcs:\n      for var in row:\n        var.WhenBound(demon)\n\n    for column in self.__v_arcs:\n      for var in column:\n        var.WhenBound(demon)\n\n  # This constraint implements a single propagation.\n  # If one point is on the path, it checks the reachability of all possible\n  # nodes, and zero out the unreachable parts.\n  def InitialPropagate(self):\n    num_rows = len(self.__h_arcs)\n    num_columns = len(self.__v_arcs)\n\n    num_points = num_rows * num_columns\n    root_node = -1\n    possible_points = set()\n    neighbors = [[] for _ in range(num_points)]\n\n    for i in range(num_rows):\n      for j in range(num_columns - 1):\n        h_arc = self.__h_arcs[i][j]\n        if h_arc.Max() == 1:\n          head = i * num_columns + j\n          tail = i * num_columns + j + 1\n          neighbors[head].append(tail)\n          neighbors[tail].append(head)\n          possible_points.add(head)\n          possible_points.add(tail)\n          if root_node == -1 and h_arc.Min() == 1:\n            root_node = head\n\n    for i in range(num_rows - 1):\n      for j in range(num_columns):\n        v_arc = self.__v_arcs[j][i]\n        if v_arc.Max() == 1:\n          head = i * num_columns + j\n          tail = (i + 1) * num_columns + j\n          neighbors[head].append(tail)\n          neighbors[tail].append(head)\n          possible_points.add(head)\n          possible_points.add(tail)\n          if root_node == -1 and v_arc.Min() == 1:\n            root_node = head\n\n    if root_node == -1:\n      return\n\n    visited_points = set()\n    to_process = deque()\n\n    # Compute reachable points\n    to_process.append(root_node)\n    while to_process:\n      candidate = to_process.popleft()\n      visited_points.add(candidate)\n      for neighbor in neighbors[candidate]:\n        if not neighbor in visited_points:\n          to_process.append(neighbor)\n          visited_points.add(neighbor)\n\n    if len(visited_points) < len(possible_points):\n      for point in visited_points:\n        possible_points.remove(point)\n\n      # Loop on unreachable points and zero all neighboring arcs.\n      for point in possible_points:\n        i = point // num_columns\n        j = point % num_columns\n        neighbors = NeighboringArcs(i, j, self.__h_arcs, self.__v_arcs)\n        for var in neighbors:\n          var.SetMax(0)\n```\n\n----------------------------------------\n\nTITLE: Transit Time Display for Vehicle Routes in Python\nDESCRIPTION: This snippet defines how to print the transit time between nodes for vehicle routing. It utilizes the previously created time evaluator to display travel times and uses Python string formatting for output. The function expects a sequence of routes and a time evaluator as inputs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/transit_time.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"def print_transit_time(route, time_evaluator):\\n    total_time = 0\\n    for i, j in route:\\n        total_time += time_evaluator(i, j)\\n        print('{0} -> {1}: {2}min'.format(i, j, time_evaluator(i, j)))\\n    print('Total time: {0}min\\n'.format(total_time))\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Crossword Puzzle Solver with Google CP Solver\nDESCRIPTION: Defines the main function that sets up the crossword puzzle problem, creates constraints, and solves it using Google's CP Solver. It includes data initialization, variable declaration, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/crossword2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Problem\")\n\n  #\n  # data\n  #\n  alpha = \"_abcdefghijklmnopqrstuvwxyz\"\n  a = 1\n  b = 2\n  c = 3\n  d = 4\n  e = 5\n  f = 6\n  g = 7\n  h = 8\n  i = 9\n  j = 10\n  k = 11\n  l = 12\n  m = 13\n  n = 14\n  o = 15\n  p = 16\n  q = 17\n  r = 18\n  s = 19\n  t = 20\n  u = 21\n  v = 22\n  w = 23\n  x = 24\n  y = 25\n  z = 26\n\n  num_words = 15\n  word_len = 5\n  AA = [\n      [h, o, s, e, s],  # HOSES\n      [l, a, s, e, r],  # LASER\n      [s, a, i, l, s],  # SAILS\n      [s, h, e, e, t],  # SHEET\n      [s, t, e, e, r],  # STEER\n      [h, e, e, l, 0],  # HEEL\n      [h, i, k, e, 0],  # HIKE\n      [k, e, e, l, 0],  # KEEL\n      [k, n, o, t, 0],  # KNOT\n      [l, i, n, e, 0],  # LINE\n      [a, f, t, 0, 0],  # AFT\n      [a, l, e, 0, 0],  # ALE\n      [e, e, l, 0, 0],  # EEL\n      [l, e, e, 0, 0],  # LEE\n      [t, i, e, 0, 0]  # TIE\n  ]\n\n  num_overlapping = 12\n  overlapping = [\n      [0, 2, 1, 0],  # s\n      [0, 4, 2, 0],  # s\n      [3, 1, 1, 2],  # i\n      [3, 2, 4, 0],  # k\n      [3, 3, 2, 2],  # e\n      [6, 0, 1, 3],  # l\n      [6, 1, 4, 1],  # e\n      [6, 2, 2, 3],  # e\n      [7, 0, 5, 1],  # l\n      [7, 2, 1, 4],  # s\n      [7, 3, 4, 2],  # e\n      [7, 4, 2, 4]  # r\n  ]\n\n  n = 8\n\n  # declare variables\n  A = {}\n  for I in range(num_words):\n    for J in range(word_len):\n      A[(I, J)] = solver.IntVar(0, 26, \"A(%i,%i)\" % (I, J))\n\n  A_flat = [A[(I, J)] for I in range(num_words) for J in range(word_len)]\n  E = [solver.IntVar(0, num_words, \"E%i\" % I) for I in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(E))\n\n  for I in range(num_words):\n    for J in range(word_len):\n      solver.Add(A[(I, J)] == AA[I][J])\n\n  for I in range(num_overlapping):\n    # This is what I would do:\n    # solver.Add(A[(E[overlapping[I][0]], overlapping[I][1])] ==  A[(E[overlapping[I][2]], overlapping[I][3])])\n\n    # But we must use Element explicitly\n    solver.Add(\n        solver.Element(A_flat, E[overlapping[I][0]] * word_len +\n                       overlapping[I][1]) == solver\n        .Element(A_flat, E[overlapping[I][2]] * word_len + overlapping[I][3]))\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(E)\n\n  # db: DecisionBuilder\n  db = solver.Phase(E + A_flat, solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(E)\n    print_solution(A, E, alpha, n, word_len)\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\ndef print_solution(A, E, alpha, n, word_len):\n  for ee in range(n):\n    print(\"%i: (%2i)\" % (ee, E[ee].Value()), end=\" \")\n    print(\"\".join(\n        [\"%s\" % (alpha[A[ee, ii].Value()]) for ii in range(word_len)]))\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing N-Queens Problem Solver in Python using OR-Tools\nDESCRIPTION: This code defines the main function to solve the N-Queens problem. It sets up the constraint solver, defines variables and constraints, and implements the solution search and result collection.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nqueens.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=8):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n  # n = 8 # size of board (n x n)\n\n  # declare variables\n  q = [solver.IntVar(0, n - 1, \"x%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(q))\n  for i in range(n):\n    for j in range(i):\n      solver.Add(q[i] != q[j])\n      solver.Add(q[i] + i != q[j] + j)\n      solver.Add(q[i] - i != q[j] - j)\n\n  # for i in range(n):\n  #     for j in range(i):\n  #         solver.Add(abs(q[i]-q[j]) != abs(i-j))\n\n  # symmetry breaking\n  # solver.Add(q[0] == 0)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([q[i] for i in range(n)])\n\n  collector = solver.AllSolutionCollector(solution)\n  # collector = solver.FirstSolutionCollector(solution)\n  # search_log = solver.SearchLog(100, x[0])\n  solver.Solve(\n      solver.Phase([q[i] for i in range(n)], solver.INT_VAR_SIMPLE,\n                   solver.ASSIGN_MIN_VALUE), [collector])\n\n  num_solutions = collector.SolutionCount()\n  print(\"num_solutions: \", num_solutions)\n  if num_solutions > 0:\n    for s in range(num_solutions):\n      qval = [collector.Value(s, q[i]) for i in range(n)]\n      print(\"q:\", qval)\n      for i in range(n):\n        for j in range(n):\n          if qval[i] == j:\n            print(\"Q\", end=\" \")\n          else:\n            print(\"_\", end=\" \")\n        print()\n      print()\n\n    print()\n    print(\"num_solutions:\", num_solutions)\n    print(\"failures:\", solver.Failures())\n    print(\"branches:\", solver.Branches())\n    print(\"WallTime:\", solver.WallTime())\n\n  else:\n    print(\"No solutions found\")\n\n\nn = 8\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: Boolean OR Constraint in Java\nDESCRIPTION: Shows how to implement a boolean OR constraint between variables in Java using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_7\n\nLANGUAGE: Java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.BoolVar;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.Literal;\n\n/** Code sample to demonstrates a simple Boolean constraint. */\npublic class BoolOrSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n    BoolVar x = model.newBoolVar(\"x\");\n    BoolVar y = model.newBoolVar(\"y\");\n    model.addBoolOr(new Literal[] {x, y.not()});\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Ranking Intervals Using Circuit Constraint in Python with OR-Tools\nDESCRIPTION: This code demonstrates how to rank intervals using a circuit constraint in CP-SAT solver. It creates a dense graph to represent task relationships and uses a circuit constraint to ensure proper ranking. The code includes methods for setting up the model, adding constraints, and solving the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrates how to rank intervals using a circuit.\"\"\"\n\nfrom typing import List, Sequence\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef rank_tasks_with_circuit(\n    model: cp_model.CpModel,\n    starts: Sequence[cp_model.IntVar],\n    durations: Sequence[int],\n    presences: Sequence[cp_model.IntVar],\n    ranks: Sequence[cp_model.IntVar],\n) -> None:\n    \"\"\"This method uses a circuit constraint to rank tasks.\n\n    This method assumes that all starts are disjoint, meaning that all tasks have\n    a strictly positive duration, and they appear in the same NoOverlap\n    constraint.\n\n    To implement this ranking, we will create a dense graph with num_tasks + 1\n    nodes.\n    The extra node (with id 0) will be used to decide which task is first with\n    its only outgoing arc, and which task is last with its only incoming arc.\n    Each task i will be associated with id i + 1, and an arc between i + 1 and j +\n    1 indicates that j is the immediate successor of i.\n\n    The circuit constraint ensures there is at most 1 hamiltonian cycle of\n    length > 1. If no such path exists, then no tasks are active.\n    We also need to enforce that any hamiltonian cycle of size > 1 must contain\n    the node 0. And thus, there is a self loop on node 0 iff the circuit is empty.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      durations: the durations of all tasks.\n      presences: The array of presence variables of all tasks.\n      ranks: The array of rank variables of all tasks.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    arcs: List[cp_model.ArcT] = []\n    for i in all_tasks:\n        # if node i is first.\n        start_lit = model.new_bool_var(f\"start_{i}\")\n        arcs.append((0, i + 1, start_lit))\n        model.add(ranks[i] == 0).only_enforce_if(start_lit)\n\n        # As there are no other constraints on the problem, we can add this\n        # redundant constraint.\n        model.add(starts[i] == 0).only_enforce_if(start_lit)\n\n        # if node i is last.\n        end_lit = model.new_bool_var(f\"end_{i}\")\n        arcs.append((i + 1, 0, end_lit))\n\n        for j in all_tasks:\n            if i == j:\n                arcs.append((i + 1, i + 1, ~presences[i]))\n                model.add(ranks[i] == -1).only_enforce_if(~presences[i])\n            else:\n                literal = model.new_bool_var(f\"arc_{i}_to_{j}\")\n                arcs.append((i + 1, j + 1, literal))\n                model.add(ranks[j] == ranks[i] + 1).only_enforce_if(literal)\n\n                # To perform the transitive reduction from precedences to successors,\n                # we need to tie the starts of the tasks with 'literal'.\n                # In a pure problem, the following inequality could be an equality.\n                # It is not true in general.\n                #\n                # Note that we could use this literal to penalize the transition, add an\n                # extra delay to the precedence.\n                model.add(starts[j] >= starts[i] + durations[i]).only_enforce_if(\n                    literal\n                )\n\n    # Manage the empty circuit\n    empty = model.new_bool_var(\"empty\")\n    arcs.append((0, 0, empty))\n\n    for i in all_tasks:\n        model.add_implication(empty, ~presences[i])\n\n    # Add the circuit constraint.\n    model.add_circuit(arcs)\n\n\ndef ranking_sample_sat() -> None:\n    \"\"\"Ranks tasks in a NoOverlap constraint.\"\"\"\n\n    model = cp_model.CpModel()\n    horizon = 100\n    num_tasks = 4\n    all_tasks = range(num_tasks)\n\n    starts = []\n    durations = []\n    intervals = []\n    presences = []\n    ranks = []\n\n    # Creates intervals, half of them are optional.\n    for t in all_tasks:\n        start = model.new_int_var(0, horizon, f\"start[{t}]\")\n        duration = t + 1\n        presence = model.new_bool_var(f\"presence[{t}]\")\n        interval = model.new_optional_fixed_size_interval_var(\n            start, duration, presence, f\"opt_interval[{t}]\"\n        )\n        if t < num_tasks // 2:\n            model.add(presence == 1)\n\n        starts.append(start)\n        durations.append(duration)\n        intervals.append(interval)\n        presences.append(presence)\n\n        # Ranks = -1 if and only if the tasks is not performed.\n        ranks.append(model.new_int_var(-1, num_tasks - 1, f\"rank[{t}]\"))\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds ranking constraint.\n    rank_tasks_with_circuit(model, starts, durations, presences, ranks)\n\n    # Adds a constraint on ranks.\n    model.add(ranks[0] < ranks[1])\n\n    # Creates makespan variable.\n    makespan = model.new_int_var(0, horizon, \"makespan\")\n    for t in all_tasks:\n        model.add(starts[t] + durations[t] <= makespan).only_enforce_if(presences[t])\n\n    # Minimizes makespan - fixed gain per tasks performed.\n    # As the fixed cost is less that the duration of the last interval,\n    # the solver will not perform the last interval.\n    model.minimize(2 * makespan - 7 * sum(presences[t] for t in all_tasks))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        # Prints out the makespan and the start times and ranks of all tasks.\n        print(f\"Optimal cost: {solver.objective_value}\")\n        print(f\"Makespan: {solver.value(makespan)}\")\n        for t in all_tasks:\n            if solver.value(presences[t]):\n                print(\n                    f\"Task {t} starts at {solver.value(starts[t])} \"\n                    f\"with rank {solver.value(ranks[t])}\"\n                )\n            else:\n                print(\n                    f\"Task {t} in not performed and ranked at {solver.value(ranks[t])}\"\n                )\n    else:\n        print(f\"Solver exited with nonoptimal status: {status}\")\n\n\nranking_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Adding Redundant Energetic Constraints with Hints to the CP-SAT Model\nDESCRIPTION: This snippet shows the completion of energy constraint generation, adding solution hints based on an initial solution, and setting up the CP-SAT solver with various parameters. It also handles writing the model to a file and solving it, then processing the results into an assignment structure.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nif sum_of_max_energies <= c * min_delay:\n                        ignored_constraits += 1\n                        continue\n                model.add(\n                    c * (task_starts[local_end] - task_ends[local_start])\n                    >= sum(task_resource_to_energy[(t, res)] for t in common)\n                )\n                added_constraints += 1\n        print(\n            f\"Added {added_constraints} redundant energetic constraints, and \"\n            + f\"ignored {ignored_constraits} constraints.\",\n            flush=True,\n        )\n\n    # Add solution hint.\n    if initial_solution:\n        for t in all_active_tasks:\n            model.add_hint(task_starts[t], initial_solution.start_of_task[t])\n            if len(task_to_presence_literals[t]) > 1:\n                selected = initial_solution.selected_recipe_of_task[t]\n                model.add_hint(task_to_presence_literals[t][selected], 1)\n\n    # Write model to file.\n    if proto_file:\n        print(f\"Writing proto to{proto_file}\")\n        model.export_to_file(proto_file)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n\n    # Parse user specified parameters.\n    if params:\n        text_format.Parse(params, solver.parameters)\n\n    # Favor objective_shaving_search over objective_lb_search.\n    if solver.parameters.num_workers >= 16 and solver.parameters.num_workers < 24:\n        solver.parameters.ignore_subsolvers.append(\"objective_lb_search\")\n        solver.parameters.extra_subsolvers.append(\"objective_shaving_search\")\n\n    # Experimental: Specify the fact that the objective is a makespan\n    solver.parameters.push_all_tasks_toward_start = True\n\n    # Enable logging in the main solve.\n\n    if in_main_solve:\n        solver.parameters.log_search_progress = True\n    #\n    status = solver.solve(model)\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        assignment = rcpsp_pb2.RcpspAssignment()\n        for t, _ in enumerate(problem.tasks):\n            if t in task_starts:\n                assignment.start_of_task.append(solver.value(task_starts[t]))\n                for r, recipe_literal in enumerate(task_to_presence_literals[t]):\n                    if solver.boolean_value(recipe_literal):\n                        assignment.selected_recipe_of_task.append(r)\n                        break\n            else:  # t is not an active task.\n                assignment.start_of_task.append(0)\n                assignment.selected_recipe_of_task.append(0)\n        return (\n            int(solver.best_objective_bound),\n            int(solver.objective_value),\n            assignment,\n        )\n    return -1, -1, None\n```\n\n----------------------------------------\n\nTITLE: Checking Task Compatibility for RCPSP Resource Constraints\nDESCRIPTION: This helper function evaluates whether a candidate task can be scheduled together with a set of current tasks based on precedence constraints and resource limitations. It's used in the lower bound computation algorithm.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef accept_new_candidate(\n    problem: rcpsp_pb2.RcpspProblem,\n    after: dict[int, list[int]],\n    demand_map: dict[tuple[int, int], int],\n    current: list[int],\n    candidate: int,\n) -> bool:\n    \"\"\"Check if candidate is compatible with the tasks in current.\"\"\"\n    for c in current:\n        if candidate in after[c] or c in after[candidate]:\n            return False\n\n    all_resources = range(len(problem.resources))\n    for res in all_resources:\n        resource = problem.resources[res]\n        if not resource.renewable:\n            continue\n        if (\n            sum(demand_map[(t, res)] for t in current) + demand_map[(candidate, res)]\n            > resource.max_capacity\n        ):\n            return False\n\n    return True\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Regular Constraint Usage in Google CP Solver\nDESCRIPTION: This main function demonstrates the use of the regular constraint. It creates a solver, sets up the constraint with a specific pattern, and searches for solutions that satisfy the constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n\n  solver = pywrapcp.Solver('Regular test')\n\n  this_len = 10\n  pp = [3, 2, 1]\n\n  transition_fn = make_transition_matrix(pp)\n  n_states = len(transition_fn)\n  input_max = 2\n\n  initial_state = 1\n\n  accepting_states = [n_states]\n\n  reg_input = [\n      solver.IntVar(1, input_max, 'reg_input[%i]' % i) for i in range(this_len)\n  ]\n\n  regular(reg_input, n_states, input_max, transition_fn, initial_state,\n          accepting_states)\n\n  db = solver.Phase(reg_input, solver.CHOOSE_MIN_SIZE_HIGHEST_MAX,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print('reg_input:', [reg_input[i].Value() - 1 for i in range(this_len)])\n    num_solutions += 1\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Calculating Task Penalties in OR-Tools Scheduling\nDESCRIPTION: This code snippet demonstrates how to calculate penalties when scheduled tasks exceed soft cumulative constraints. It iterates through tasks, calculating penalties based on how much they exceed soft_max_cumul while ensuring they remain below hard_max_cumul, and then validates that the solver's objective value matches the calculated sum of penalties.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_32\n\nLANGUAGE: Python\nCODE:\n```\nassert cumul >= 0\nassert cumul <= hard_max_cumul\n\nif cumul > soft_max_cumul:\n    penalty = penalty * (cumul - soft_max_cumul)\n    sum_of_penalties += penalty\n    print(\n        f\"Task {t} of type {task_types[t]} with\"\n        f\" duration={durations[t]} starts at {start}, length={length},\"\n        f\" cumul={cumul} penalty={penalty}\"\n    )\nelse:\n    print(\n        f\"Task {t} of type {task_types[t]} with duration\"\n        f\" {durations[t]} starts at {start}, length =\"\n        f\" {length}, cumul = {cumul} \"\n    )\n\nassert int(solver.objective_value) == sum_of_penalties\nelse:\n    print(f\"Solver exited with the following status: {status}\")\n\n\nsequences_in_no_overlap_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Defining Data Model for VRP with Multiple Item Types\nDESCRIPTION: This function creates and returns a data model for the Vehicle Routing Problem. It defines the number of vehicles, start/end points, item supply locations, vehicle capacities, and a distance matrix between all nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_items_to_deliver.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"num_vehicles\"] = 2\n    data[\"starts\"] = [0] * data[\"num_vehicles\"]\n    data[\"ends\"] = [1] * data[\"num_vehicles\"]\n    assert len(data[\"starts\"]) == data[\"num_vehicles\"]\n    assert len(data[\"ends\"]) == data[\"num_vehicles\"]\n\n    # Need 11 X and 13 Y\n    data[\"providers_x\"] = [\n        0,  # start\n        -11,  # end\n        2,  # X supply 1\n        2,  # X supply 2\n        4,  # X supply 3\n        4,  # X supply 4\n        4,  # X supply 5\n        5,  # X supply 6\n        1,  # X/Y supply 1\n        2,  # X/Y supply 2\n        2,  # X/Y supply 3\n        0,  # Y supply 1\n        0,  # Y supply 2\n        0,  # Y supply 3\n        0,  # Y supply 4\n        0,  # Y supply 5\n        0,  # Y supply 6\n    ]\n    data[\"providers_y\"] = [\n        0,  # start\n        -13,  # ends\n        0,  # X supply 1\n        0,  # X supply 2\n        0,  # X supply 3\n        0,  # X supply 4\n        0,  # X supply 5\n        0,  # X supply 6\n        3,  # X/Y supply 1\n        2,  # X/Y supply 2\n        1,  # X/Y supply 3\n        3,  # Y supply 1\n        3,  # Y supply 2\n        3,  # Y supply 3\n        3,  # Y supply 4\n        3,  # Y supply 5\n        5,  # Y supply 6\n    ]\n    data[\"vehicle_capacities_x\"] = [15] * data[\"num_vehicles\"]\n    data[\"vehicle_capacities_y\"] = [15] * data[\"num_vehicles\"]\n    assert len(data[\"vehicle_capacities_x\"]) == data[\"num_vehicles\"]\n    assert len(data[\"vehicle_capacities_y\"]) == data[\"num_vehicles\"]\n    data[\"distance_matrix\"] = [\n        # ... (distance matrix omitted for brevity)\n    ]\n    assert len(data[\"providers_x\"]) == len(data[\"distance_matrix\"])\n    assert len(data[\"providers_y\"]) == len(data[\"distance_matrix\"])\n    return data\n```\n\n----------------------------------------\n\nTITLE: Coins Grid MIP Solver Implementation\nDESCRIPTION: Main implementation of the Coins Grid puzzle solver using Mixed Integer Programming. Creates a 31x31 grid where exactly 14 coins must be placed in each row and column while minimizing the quadratic horizontal distance from the main diagonal. Uses the CBC solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins_grid_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(unused_argv):\n  # Create the solver.\n\n  # using CBC\n  solver = pywraplp.Solver.CreateSolver('CBC')\n  if not solver:\n    return\n\n  # data\n  n = 31  # the grid size\n  c = 14  # number of coins per row/column\n\n  # declare variables\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(0, 1, 'x[%i,%i]' % (i, j))\n\n  #\n  # constraints\n  #\n\n  # sum rows/columns == c\n  for i in range(n):\n    solver.Add(solver.Sum([x[(i, j)] for j in range(n)]) == c)  # sum rows\n    solver.Add(solver.Sum([x[(j, i)] for j in range(n)]) == c)  # sum cols\n\n  # quadratic horizonal distance var\n  objective_var = solver.Sum(\n      [x[(i, j)] * (i - j) * (i - j) for i in range(n) for j in range(n)])\n\n  # objective\n  objective = solver.Minimize(objective_var)\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  for i in range(n):\n    for j in range(n):\n      # int representation\n      print(int(x[(i, j)].SolutionValue()), end=' ')\n    print()\n  print()\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n\n\nmain('coin grids')\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools Base Library in CMake\nDESCRIPTION: This CMake script configures the build process for the OR-Tools base library. It sets up source files, compiler definitions, include directories, and links required dependencies. The script also configures testing if BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/base/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.\\*_test.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/status_matchers\\\\.h\")\nset(NAME ${PROJECT_NAME}_base)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_compile_definitions(${NAME} PRIVATE\n  -DOR_TOOLS_MAJOR=${PROJECT_VERSION_MAJOR}\n  -DOR_TOOLS_MINOR=${PROJECT_VERSION_MINOR}\n  -DOR_TOOLS_PATCH=${PROJECT_VERSION_PATCH})\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  ZLIB::ZLIB\n  absl::base\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::base ALIAS ${NAME})\n\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        base_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        benchmark::benchmark\n        GTest::gtest\n        GTest::gtest_main\n        GTest::gmock\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Collecting Valid Slabs using Dynamic Programming in Python\nDESCRIPTION: This function collects valid column assignments for one slab using a dynamic programming approach. It generates all possible valid assignments of orders to a slab, considering capacity and color constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef collect_valid_slabs_dp(\n    capacities: list[int],\n    colors: list[int],\n    widths: list[int],\n    loss_array: list[int],\n) -> list[list[int]]:\n    \"\"\"Collect valid columns (assign, loss) for one slab.\"\"\"\n    start_time = time.time()\n\n    max_capacity = max(capacities)\n\n    valid_assignment = collections.namedtuple(\"valid_assignment\", \"orders load colors\")\n    all_valid_assignments = [valid_assignment(orders=[], load=0, colors=[])]\n\n    for order_id, new_color in enumerate(colors):\n        new_width = widths[order_id]\n        new_assignments = []\n        for assignment in all_valid_assignments:\n            if assignment.load + new_width > max_capacity:\n                continue\n            new_colors = list(assignment.colors)\n            if new_color not in new_colors:\n                new_colors.append(new_color)\n            if len(new_colors) > 2:\n                continue\n            new_assignment = valid_assignment(\n                orders=assignment.orders + [order_id],\n                load=assignment.load + new_width,\n                colors=new_colors,\n            )\n            new_assignments.append(new_assignment)\n        all_valid_assignments.extend(new_assignments)\n\n    print(\n        f\"{len(all_valid_assignments)} assignments created in\"\n        f\" {time.time() - start_time:2f} s\"\n    )\n    tuples = []\n    for assignment in all_valid_assignments:\n        solution = [0] * len(colors)\n        for i in assignment.orders:\n            solution[i] = 1\n        solution.append(loss_array[assignment.load])\n        solution.append(assignment.load)\n        tuples.append(solution)\n\n    return tuples\n```\n\n----------------------------------------\n\nTITLE: Solving CP-SAT Model with Limited Solutions in Python\nDESCRIPTION: Implements a function that creates a simple CP-SAT model, sets up the solver with a custom solution printer, and solves the model to find a limited number of solutions. It demonstrates how to use OR-Tools to enumerate solutions and stop after a certain number are found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/stop_after_n_solutions_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef stop_after_n_solutions_sample_sat():\n    \"\"\"Showcases calling the solver to search for small number of solutions.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArraySolutionPrinterWithLimit([x, y, z], 5)\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    # Solve.\n    status = solver.solve(model, solution_printer)\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n    assert solution_printer.solution_count == 5\n\nstop_after_n_solutions_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Max Flow Problem with Google CP Solver\nDESCRIPTION: This code implements a max flow problem using Google's CP Solver. It defines the problem structure, sets up variables and constraints, and solves for the maximum flow. The solution includes total flow, in-flow, out-flow, and flow between nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/max_flow_taha.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Max flow problem, Taha')\n\n  #\n  # data\n  #\n  n = 5\n  start = 0\n  end = n - 1\n\n  nodes = list(range(n))\n\n  # cost matrix\n  c = [[0, 20, 30, 10, 0], [0, 0, 40, 0, 30], [0, 0, 0, 10, 20],\n       [0, 0, 5, 0, 20], [0, 0, 0, 0, 0]]\n\n  #\n  # declare variables\n  #\n  x = {}\n  for i in nodes:\n    for j in nodes:\n      x[i, j] = solver.IntVar(0, c[i][j], 'x[%i,%i]' % (i, j))\n\n  x_flat = [x[i, j] for i in nodes for j in nodes]\n  out_flow = [solver.IntVar(0, 10000, 'out_flow[%i]' % i) for i in nodes]\n  in_flow = [solver.IntVar(0, 10000, 'in_flow[%i]' % i) for i in nodes]\n\n  total = solver.IntVar(0, 10000, 'z')\n\n  #\n  # constraints\n  #\n  cost_sum = solver.Sum([x[start, j] for j in nodes if c[start][j] > 0])\n  solver.Add(total == cost_sum)\n\n  for i in nodes:\n    in_flow_sum = solver.Sum([x[j, i] for j in nodes if c[j][i] > 0])\n    solver.Add(in_flow[i] == in_flow_sum)\n\n    out_flow_sum = solver.Sum([x[i, j] for j in nodes if c[i][j] > 0])\n    solver.Add(out_flow[i] == out_flow_sum)\n\n  # in_flow == out_flow\n  for i in nodes:\n    if i != start and i != end:\n      solver.Add(out_flow[i] - in_flow[i] == 0)\n\n  s1 = [x[i, start] for i in nodes if c[i][start] > 0]\n  if len(s1) > 0:\n    solver.Add(solver.Sum([x[i, start] for i in nodes if c[i][start] > 0] == 0))\n\n  s2 = [x[end, j] for j in nodes if c[end][j] > 0]\n  if len(s2) > 0:\n    solver.Add(solver.Sum([x[end, j] for j in nodes if c[end][j] > 0]) == 0)\n\n  # objective: maximize total cost\n  objective = solver.Maximize(total, 1)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(x_flat, solver.INT_VAR_DEFAULT, solver.ASSIGN_MAX_VALUE)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('total:', total.Value())\n    print('in_flow:', [in_flow[i].Value() for i in nodes])\n    print('out_flow:', [out_flow[i].Value() for i in nodes])\n    for i in nodes:\n      for j in nodes:\n        print('%2i' % x[i, j].Value(), end=' ')\n      print()\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Bin Packing Problem with MIP Solver\nDESCRIPTION: Use Google OR-Tools' SCIP solver to solve the bin packing problem by creating decision variables, adding constraints, and minimizing the number of bins used\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/bin_packing_mip.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    data = create_data_model()\n\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n\n    if not solver:\n        return\n\n    # Variables\n    # x[i, j] = 1 if item i is packed in bin j.\n    x = {}\n    for i in data[\"items\"]:\n        for j in data[\"bins\"]:\n            x[(i, j)] = solver.IntVar(0, 1, \"x_%i_%i\" % (i, j))\n\n    # y[j] = 1 if bin j is used.\n    y = {}\n    for j in data[\"bins\"]:\n        y[j] = solver.IntVar(0, 1, \"y[%i]\" % j)\n\n    # Constraints\n    # Each item must be in exactly one bin.\n    for i in data[\"items\"]:\n        solver.Add(sum(x[i, j] for j in data[\"bins\"]) == 1)\n\n    # The amount packed in each bin cannot exceed its capacity.\n    for j in data[\"bins\"]:\n        solver.Add(\n            sum(x[(i, j)] * data[\"weights\"][i] for i in data[\"items\"])\n            <= y[j] * data[\"bin_capacity\"]\n        )\n\n    # Objective: minimize the number of bins used.\n    solver.Minimize(solver.Sum([y[j] for j in data[\"bins\"]]))\n\n    print(f\"Solving with {solver.SolverVersion()}\")\n    status = solver.Solve()\n\n    if status == pywraplp.Solver.OPTIMAL:\n        num_bins = 0\n        for j in data[\"bins\"]:\n            if y[j].solution_value() == 1:\n                bin_items = []\n                bin_weight = 0\n                for i in data[\"items\"]:\n                    if x[i, j].solution_value() > 0:\n                        bin_items.append(i)\n                        bin_weight += data[\"weights\"][i]\n                if bin_items:\n                    num_bins += 1\n                    print(\"Bin number\", j)\n                    print(\"  Items packed:\", bin_items)\n                    print(\"  Total weight:\", bin_weight)\n                    print()\n        print()\n        print(\"Number of bins used:\", num_bins)\n        print(\"Time = \", solver.WallTime(), \" milliseconds\")\n    else:\n        print(\"The problem does not have an optimal solution.\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Symmetry Breaking Constraints\nDESCRIPTION: Adds symmetry breaking constraints to reduce the search space, including assigning the first three shifts to the first three drivers and organizing non-working drivers at the end when minimizing drivers.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Symmetry breaking\n\n# The first 3 shifts must be performed by 3 different drivers.\n# Let's assign them to the first 3 drivers in sequence\nmodel.add(starting_shifts[0, 0] == 1)\nmodel.add(starting_shifts[1, 1] == 1)\nmodel.add(starting_shifts[2, 2] == 1)\n\nif minimize_drivers:\n    # Push non working drivers to the end\n    for d in range(num_drivers - 1):\n        model.add_implication(~working_drivers[d], ~working_drivers[d + 1])\n```\n\n----------------------------------------\n\nTITLE: Implementing toNum Function for Number to Array Conversion in Google CP Solver\nDESCRIPTION: Defines a function to convert between a number and its array representation in a specific base using constraint programming. The function establishes the mathematical relationship between a decimal value and its digit-by-digit representation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/toNum.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n#\n# converts a number (s) <-> an array of integers (t) in the specific base.\n#\n\n\ndef toNum(solver, t, s, base):\n  tlen = len(t)\n  solver.Add(\n      s == solver.Sum([(base**(tlen - i - 1)) * t[i] for i in range(tlen)]))\n```\n\n----------------------------------------\n\nTITLE: Setting Constraints for Task Allocation Problem in Python\nDESCRIPTION: This snippet adds constraints to the CP model. It ensures each task is assigned once, respects capacity constraints, links slot usage to task assignments, and defines the objective to minimize the number of used slots.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/task_allocation_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfor task in all_tasks:\n    model.add(\n        sum(\n            assign[(task, slot)] for slot in all_slots if available[task][slot] == 1\n        )\n        == 1\n    )\n\nfor slot in all_slots:\n    model.add(\n        sum(\n            assign[(task, slot)] for task in all_tasks if available[task][slot] == 1\n        )\n        <= capacity\n    )\n    model.add_bool_or(\n        [assign[(task, slot)] for task in all_tasks if available[task][slot] == 1]\n    ).only_enforce_if(slot_used[slot])\n    for task in all_tasks:\n        if available[task][slot] == 1:\n            model.add_implication(~slot_used[slot], ~assign[(task, slot)])\n        else:\n            model.add(assign[(task, slot)] == 0)\n\nmodel.add(count == sum(slot_used))\n# Redundant constraint. This instance is easier if we add this constraint.\n# model.add(count >= (nslots + capacity - 1) // capacity)\n\nmodel.minimize(count)\n```\n\n----------------------------------------\n\nTITLE: Implementing Step Function Using CP-SAT in Go\nDESCRIPTION: This example shows how to implement a step function constraint in Go using the CP-SAT solver. It creates an expression variable that takes different values based on the domain of the primary variable, demonstrating domain constraints and decision strategies.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n// The step_function_sample_sat command is an example of an implementation of a step function.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc stepFunctionSampleSat() error {\n\t// Create the CP-SAT model.\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\t// Declare our primary variable.\n\tx := model.NewIntVar(0, 20)\n\n\t// Create the expression variable and implement the step function\n\t// Note it is not defined for var == 2.\n\t//\n\t//        -               3\n\t// -- --      ---------   2\n\t//                        1\n\t//      -- ---            0\n\t//           1         2\n\t// 012345678901234567890\n\t//\n\texpr := model.NewIntVar(0, 3)\n\n\t// expr == 0 on [5, 6] U [8, 10]\n\tb0 := model.NewBoolVar()\n\td0 := cpmodel.FromValues([]int64{5, 6, 8, 9, 10})\n\tmodel.AddLinearConstraintForDomain(x, d0).OnlyEnforceIf(b0)\n\tmodel.AddEquality(expr, cpmodel.NewConstant(0)).OnlyEnforceIf(b0)\n\n\t// expr == 2 on [0, 1] U [3, 4] U [11, 20]\n\tb2 := model.NewBoolVar()\n\td2 := cpmodel.FromIntervals([]cpmodel.ClosedInterval{{Start: 0, End: 1}, {Start: 3, End: 4}, {Start: 11, End: 20}})\n\tmodel.AddLinearConstraintForDomain(x, d2).OnlyEnforceIf(b2)\n\tmodel.AddEquality(expr, cpmodel.NewConstant(2)).OnlyEnforceIf(b2)\n\n\t// expr = 3 when x = 7\n\tb3 := model.NewBoolVar()\n\tmodel.AddEquality(x, cpmodel.NewConstant(7)).OnlyEnforceIf(b3)\n\tmodel.AddEquality(expr, cpmodel.NewConstant(3)).OnlyEnforceIf(b3)\n\n\t// At least one Boolean variable is true.\n\tmodel.AddBoolOr(b0, b2, b3)\n\n\t// Search for x values in increasing order.\n\tmodel.AddDecisionStrategy([]cpmodel.IntVar{x}, cmpb.DecisionStrategyProto_CHOOSE_FIRST, cmpb.DecisionStrategyProto_SELECT_MIN_VALUE)\n\n\t// Create a solver and solve with fixed search.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tparams := &sppb.SatParameters{\n\t\tFillAdditionalSolutionsInResponse: proto.Bool(true),\n\t\tEnumerateAllSolutions:             proto.Bool(true),\n\t\tSolutionPoolSize:                  proto.Int32(21),\n\t\tSearchBranching:                   sppb.SatParameters_FIXED_SEARCH.Enum(),\n\t}\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Printf(\"Status: %v\\n\", response.GetStatus())\n\n\tfor _, additionalSolution := range response.GetAdditionalSolutions() {\n\t\tvs := additionalSolution.GetValues()\n\t\tfmt.Printf(\"x= %v expr= %v\\n\", vs[x.Index()], vs[expr.Index()])\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := stepFunctionSampleSat(); err != nil {\n\t\tlog.Exitf(\"stepFunctionSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Solution Collection Class Implementation\nDESCRIPTION: Defines a class that collects all solutions from the constraint programming solver by implementing a callback mechanism.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/appointments.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.colab import flags\nfrom ortools.linear_solver import pywraplp\nfrom ortools.sat.python import cp_model\n\n_LOAD_MIN = flags.define_integer(\"load_min\", 480, \"Minimum load in minutes.\")\n_LOAD_MAX = flags.define_integer(\"load_max\", 540, \"Maximum load in minutes.\")\n_COMMUTE_TIME = flags.define_integer(\"commute_time\", 30, \"Commute time in minutes.\")\n_NUM_WORKERS = flags.define_integer(\"num_workers\", 98, \"Maximum number of workers.\")\n\nclass AllSolutionCollector(cp_model.CpSolverSolutionCallback):\n    \"\"\"Stores all solutions.\"\"\"\n\n    def __init__(self, variables):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__collect = []\n\n    def on_solution_callback(self) -> None:\n        \"\"\"Collect a new combination.\"\"\"\n        combination = [self.value(v) for v in self.__variables]\n        self.__collect.append(combination)\n\n    def combinations(self) -> list[list[int]]:\n        \"\"\"Returns all collected combinations.\"\"\"\n        return self.__collect\n```\n\n----------------------------------------\n\nTITLE: Duplicate Items Solver Implementation\nDESCRIPTION: Solves the knapsack problem by creating duplicate items for both normal and rotated orientations. Uses CP-SAT solver with interval variables and 2D no-overlap constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef solve_with_duplicate_items(data: pd.Series, max_height: int, max_width: int) -> None:\n    \"\"\"solve the problem by building 2 items (rotated or not) for each item.\"\"\"\n    # ... [full implementation as shown in original code] ...\n    model = cp_model.CpModel()\n    # Create variables and constraints\n    # Solve and report solution\n```\n\n----------------------------------------\n\nTITLE: Solving Task Allocation Problem using CP-SAT Solver in Python\nDESCRIPTION: This snippet creates a CP-SAT solver, configures its parameters, and solves the task allocation problem. It enables search progress logging and uses multiple search workers for parallel solving.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/task_allocation_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# Create a solver and solve the problem.\nsolver = cp_model.CpSolver()\n# Uses the portfolion of heuristics.\nsolver.parameters.log_search_progress = True\nsolver.parameters.num_search_workers = 16\nsolver.solve(model)\n```\n\n----------------------------------------\n\nTITLE: Implementing Seseman Convent Problem Solver\nDESCRIPTION: Main implementation of the Seseman Convent problem solver using OR-Tools. Creates a constraint satisfaction problem where numbers must be placed on the border of an NxN matrix such that various sum constraints are satisfied. The implementation includes variable declaration, constraint setting, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/seseman_b.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(unused_argv):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Seseman Convent problem\")\n\n  # data\n  n = 3\n  border_sum = n * n\n\n  # declare variables\n  total_sum = solver.IntVar(1, n * n * n * n, \"total_sum\")\n  # x[0..n-1,0..n-1]\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(0, n * n, \"x %i %i\" % (i, j))\n\n  #\n  # constraints\n  #\n  # zero all middle cells\n  for i in range(1, n - 1):\n    for j in range(1, n - 1):\n      solver.Add(x[(i, j)] == 0)\n\n  # all borders must be >= 1\n  for i in range(n):\n    for j in range(n):\n      if i == 0 or j == 0 or i == n - 1 or j == n - 1:\n        solver.Add(x[(i, j)] >= 1)\n\n  # sum the borders (border_sum)\n  solver.Add(solver.Sum([x[(i, 0)] for i in range(n)]) == border_sum)\n  solver.Add(solver.Sum([x[(i, n - 1)] for i in range(n)]) == border_sum)\n  solver.Add(solver.Sum([x[(0, i)] for i in range(n)]) == border_sum)\n  solver.Add(solver.Sum([x[(n - 1, i)] for i in range(n)]) == border_sum)\n\n  # total\n  solver.Add(\n      solver.Sum([x[(i, j)] for i in range(n) for j in range(n)]) == total_sum)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[(i, j)] for i in range(n) for j in range(n)])\n  solution.Add(total_sum)\n\n  db = solver.Phase([x[(i, j)] for i in range(n) for j in range(n)],\n                    solver.CHOOSE_PATH, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"total_sum:\", total_sum.Value())\n    for i in range(n):\n      for j in range(n):\n        print(x[(i, j)].Value(), end=\" \")\n      print()\n    print()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package using pip, which is required for the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solve_and_print_intermediate_solutions_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit in C++ CP-SAT Solver\nDESCRIPTION: C++ implementation showing how to set a 10-second time limit for a constraint programming model. The example creates a simple problem with three variables and a not-equal constraint, configuring the solver parameters through the SatParameters protocol buffer.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/sat/sat_parameters.pb.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid SolveWithTimeLimitSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  cp_model.AddNotEqual(x, y);\n\n  // Solving part.\n  Model model;\n\n  // Sets a time limit of 10 seconds.\n  SatParameters parameters;\n  parameters.set_max_time_in_seconds(10.0);\n  model.Add(NewSatParameters(parameters));\n\n  // Solve.\n  const CpSolverResponse response = SolveCpModel(cp_model.Build(), &model);\n  LOG(INFO) << CpSolverResponseStats(response);\n\n  if (response.status() == CpSolverStatus::OPTIMAL) {\n    LOG(INFO) << \"  x = \" << SolutionIntegerValue(response, x);\n    LOG(INFO) << \"  y = \" << SolutionIntegerValue(response, y);\n    LOG(INFO) << \"  z = \" << SolutionIntegerValue(response, z);\n  }\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::SolveWithTimeLimitSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Regular Constraint in Python for CP Solver\nDESCRIPTION: Defines a function 'regular' that implements the regular constraint for use in Google's CP Solver. This constraint ensures that a sequence of variables follows a pattern defined by a deterministic finite automaton (DFA).\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/contiguity_regular.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef regular(x, Q, S, d, q0, F):\n\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    row = []\n    for j in range(S):\n      if i == 0:\n        row.append(0)\n      else:\n        row.append(d[i - 1][j])\n    d2.append(row)\n\n  d2_flatten = [d2[i][j] for i in range(Q + 1) for j in range(S)]\n\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n\n  a = [solver.IntVar(0, Q + 1, 'a[%i]' % i) for i in range(m, n + 1)]\n\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n\n    solver.Add(\n        a[i + 1] == solver.Element(d2_flatten, ((a[i]) * S) + (x[i] - 1)))\n```\n\n----------------------------------------\n\nTITLE: Creating Service Time Callback for OR-Tools Routing\nDESCRIPTION: A method that returns a callback function calculating the service time at each customer node. The service time is proportional to the customer's demand based on a predefined service time per demand unit.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ndef make_service_time_call_callback(self):\n    \"\"\"\n    Return a callback function that provides the time spent servicing the\n    customer.  Here is it proportional to the demand given by\n    self.service_time_per_dem, default 300 seconds per unit demand.\n\n    Returns:\n        function [dem_return(a, b)]: A function that takes the from/a node\n            index and the to/b node index and returns the service time at a\n\n    \"\"\"\n\n    def service_time_return(a, b):\n        return (self.customers[a].demand * self.service_time_per_dem)\n\n    return service_time_return\n```\n\n----------------------------------------\n\nTITLE: Implementing Recipe Class for Bakery Products in Python\nDESCRIPTION: Defines a Recipe class representing a sequence of cooking tasks required to make a bakery product. The class provides a fluent interface for adding tasks with their resource requirements and duration constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Recipe:\n    \"\"\"A recipe is a sequence of cooking tasks.\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.tasks = []\n\n    def add_task(\n        self, resource_name: str, min_duration: int, max_duration: int\n    ) -> \"Recipe\":\n        self.tasks.append(Task(resource_name, min_duration, max_duration))\n        return self\n```\n\n----------------------------------------\n\nTITLE: Defining SchoolSchedulingProblem Class in Python\nDESCRIPTION: This class represents the data for the school scheduling problem, including levels, sections, subjects, curriculum, teachers, specialties, and time slots. It provides methods to access and validate the problem data.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass SchoolSchedulingProblem():\n    '''Data of the problem.'''\n\n    def __init__(self, levels, sections, subjects, curriculum, teachers,\n                 specialties, time_slots):\n        self._levels = levels\n        self._sections = sections\n        self._subjects = subjects\n        self._curriculum = curriculum\n        assert len(self._curriculum) == len(self._levels) * len(\n            self._subjects), 'Some curriculum are missing'\n        for (lvl, sub) in self._curriculum.keys():\n            assert lvl in self._levels, f'{lvl} not in LEVELS'\n            assert sub in self._subjects, f'{sub} not in SUBJECTS'\n\n        self._teachers = teachers\n        self._specialties = specialties\n        assert len(self._specialties) == len(\n            self._subjects), 'Missing some rows'\n        for s, ts in self._specialties.items():\n            assert s in self._subjects, f'{s} is not in SUBJECTS'\n            for t in ts:\n                assert t in self._teachers, f'{t} is not in TEACHERS'\n\n        self._time_slots = time_slots\n\n    @property\n    def levels(self):\n        return self._levels\n\n    @property\n    def sections(self):\n        return self._sections\n\n    @property\n    def subjects(self):\n        return self._subjects\n\n    @property\n    def curriculum(self):\n        return self._curriculum\n\n    @property\n    def teachers(self):\n        return self._teachers\n\n    def teacher_name(self, teacher_idx):\n        assert 0 <= teacher_idx < len(self._teachers)\n        return list(self._teachers.keys())[teacher_idx]\n\n    def teacher_max_hours(self, teacher_idx):\n        assert 0 <= teacher_idx < len(self._teachers)\n        return list(self._teachers.values())[teacher_idx]\n\n    @property\n    def specialties(self):\n        return self._specialties\n\n    def specialtie_teachers(self, subject):\n        assert subject in self._subjects, f'{subject} not in SUBJECTS'\n        return self._specialties[subject]\n\n    @property\n    def time_slots(self):\n        return self._time_slots\n\n    def slot_duration(self, slot_idx):\n        assert 0 <= slot_idx < len(self._time_slots)\n        return list(self._time_slots.values())[slot_idx]\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Intervals in C# using OR-Tools\nDESCRIPTION: C# implementation of optional interval variables using OR-Tools. Demonstrates creation of intervals with both variable and fixed sizes.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class OptionalIntervalSampleSat\n{\n    static void Main()\n    {\n        CpModel model = new CpModel();\n        int horizon = 100;\n        IntVar start_var = model.NewIntVar(0, horizon, \"start\");\n        IntVar end_var = model.NewIntVar(0, horizon, \"end\");\n        BoolVar presence_var = model.NewBoolVar(\"presence\");\n        IntervalVar interval = model.NewOptionalIntervalVar(start_var, 10, end_var + 2, presence_var, \"interval\");\n        IntervalVar fixedSizeIntervalVar =\n            model.NewOptionalFixedSizeIntervalVar(start_var, 10, presence_var, \"fixed_size_interval_var\");\n        IntervalVar fixedInterval = model.NewOptionalFixedSizeIntervalVar(5, 10, presence_var, \"fixed_interval\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Alphametic Puzzle Solver with OR-Tools\nDESCRIPTION: A complete implementation of an alphametic puzzle solver using the OR-Tools constraint programming solver. The solver handles problems where letters represent digits in equations of the form A+B=C, with support for different numerical bases.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/alphametic.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport re\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(problem_str=\"SEND+MORE=MONEY\", base=10):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Send most money\")\n\n  # data\n  print(\"\\nproblem:\", problem_str)\n\n  # convert to array.\n  problem = re.split(\"[\\s+=]\", problem_str)\n\n  p_len = len(problem)\n  print(\"base:\", base)\n\n  # create the lookup table: list of (digit : ix)\n  a = sorted(set(\"\".join(problem)))\n  n = len(a)\n  lookup = dict(list(zip(a, list(range(n)))))\n\n  # length of each number\n  lens = list(map(len, problem))\n\n  #\n  # declare variables\n  #\n\n  # the digits\n  x = [solver.IntVar(0, base - 1, \"x[%i]\" % i) for i in range(n)]\n  # the sums of each number (e.g. the three numbers SEND, MORE, MONEY)\n  sums = [solver.IntVar(1, 10**(lens[i]) - 1) for i in range(p_len)]\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(x))\n\n  ix = 0\n  for prob in problem:\n    this_len = len(prob)\n\n    # sum all the digits with proper exponents to a number\n    solver.Add(\n        sums[ix] == solver.Sum([(base**i) * x[lookup[prob[this_len - i - 1]]]\n                                for i in range(this_len)[::-1]]))\n    # leading digits must be > 0\n    solver.Add(x[lookup[prob[0]]] > 0)\n    ix += 1\n\n  # the last number is the sum of the previous numbers\n  solver.Add(solver.Sum([sums[i] for i in range(p_len - 1)]) == sums[-1])\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(sums)\n\n  db = solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"\\nsolution #%i\" % num_solutions)\n    for i in range(n):\n      print(a[i], \"=\", x[i].Value())\n    print()\n    for prob in problem:\n      for p in prob:\n        print(p, end=\" \")\n      print()\n    print()\n    for prob in problem:\n      for p in prob:\n        print(x[lookup[p]].Value(), end=\" \")\n      print()\n\n    print(\"sums:\", [sums[i].Value() for i in range(p_len)])\n    print()\n\n  print(\"\\nnum_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\ndef test_problems(base=10):\n  problems = [\n      \"SEND+MORE=MONEY\", \"SEND+MOST=MONEY\", \"VINGT+CINQ+CINQ=TRENTE\",\n      \"EIN+EIN+EIN+EIN=VIER\", \"DONALD+GERALD=ROBERT\",\n      \"SATURN+URANUS+NEPTUNE+PLUTO+PLANETS\", \"WRONG+WRONG=RIGHT\"\n  ]\n\n  for p in problems:\n    main(p, base)\n\n\nproblem = \"SEND+MORE=MONEY\"\nbase = 10\nif len(sys.argv) > 1:\n  problem = sys.argv[1]\nif len(sys.argv) > 2:\n  base = int(sys.argv[2])\n\nif problem == \"TEST\" or problem == \"test\":\n  test_problems(base)\nelse:\n  main(problem, base)\n\n```\n\n----------------------------------------\n\nTITLE: Bus Schedule Optimization Implementation\nDESCRIPTION: Main implementation of the bus scheduling problem using OR-Tools constraint solver. The code creates variables for each time slot, sets constraints based on hourly demands, and finds the minimum number of buses needed. It includes both optimization for minimum buses and enumeration of all solutions for a given number of buses.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/bus_schedule.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(num_buses_check=0):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Bus scheduling\")\n\n  # data\n  time_slots = 6\n  demands = [8, 10, 7, 12, 4, 4]\n  max_num = sum(demands)\n\n  # declare variables\n  x = [solver.IntVar(0, max_num, \"x%i\" % i) for i in range(time_slots)]\n  num_buses = solver.IntVar(0, max_num, \"num_buses\")\n\n  #\n  # constraints\n  #\n  solver.Add(num_buses == solver.Sum(x))\n\n  # Meet the demands for this and the next time slot\n  for i in range(time_slots - 1):\n    solver.Add(x[i] + x[i + 1] >= demands[i])\n\n  # The demand \"around the clock\"\n  solver.Add(x[time_slots - 1] + x[0] == demands[time_slots - 1])\n\n  if num_buses_check > 0:\n    solver.Add(num_buses == num_buses_check)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(num_buses)\n\n  collector = solver.AllSolutionCollector(solution)\n  cargs = [collector]\n\n  # objective\n  if num_buses_check == 0:\n    objective = solver.Minimize(num_buses, 1)\n    cargs.extend([objective])\n\n  solver.Solve(\n      solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE),\n      cargs)\n\n  num_solutions = collector.SolutionCount()\n  num_buses_check_value = 0\n  for s in range(num_solutions):\n    print(\"x:\", [collector.Value(s, x[i]) for i in range(len(x))], end=\" \")\n    num_buses_check_value = collector.Value(s, num_buses)\n    print(\" num_buses:\", num_buses_check_value)\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print()\n  if num_buses_check == 0:\n    return num_buses_check_value\n\n\nprint(\"Check for minimun number of buses\")\nnum_buses_check = main()\nprint(\"... got \", num_buses_check, \"buses\")\nprint(\"All solutions:\")\nmain(num_buses_check)\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Subset Sum Solver Function in Python\nDESCRIPTION: Defines the main function that sets up the solver, applies the constraints, and searches for solutions to the subset sum problem. It also handles output formatting and performance metrics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/subset_sum.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(coins, total):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n\n  #\n  # data\n  #\n  print(\"coins:\", coins)\n  print(\"total:\", total)\n  print()\n\n  #\n  # declare variables\n  #\n\n  #\n  # constraints\n  #\n  x, ss = subset_sum(solver, coins, total)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x)\n  solution.Add(ss)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"ss:\", ss.Value())\n    print(\"x: \", [x[i].Value() for i in range(len(x))])\n    print()\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Implementing Dudeney Number Finder using OR-Tools in Python\nDESCRIPTION: This function finds Dudeney numbers of a specified length using constraint programming. It sets up variables for digits, the number itself, and its digit sum, then adds constraints to ensure the Dudeney property. It uses OR-Tools' solver to find all solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/dudeney.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef dudeney(n):\n  solver = pywrapcp.Solver('Dudeney')\n  x = [solver.IntVar(list(range(10)), 'x' + str(i)) for i in range(n)]\n  nb = solver.IntVar(list(range(3, 10**n)), 'nb')\n  s = solver.IntVar(list(range(1, 9 * n + 1)), 's')\n\n  solver.Add(nb == s * s * s)\n  solver.Add(sum([10**(n - i - 1) * x[i] for i in range(n)]) == nb)\n  solver.Add(sum([x[i] for i in range(n)]) == s)\n\n  solution = solver.Assignment()\n  solution.Add(nb)\n  collector = solver.AllSolutionCollector(solution)\n\n  solver.Solve(\n      solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT),\n      [collector])\n\n  for i in range(collector.SolutionCount()):\n    nbsol = collector.Value(i, nb)\n    print(nbsol)\n\n  print('#fails:', solver.Failures())\n  print('time:', solver.WallTime(), 'ms')\n\n\ndudeney(6)\n```\n\n----------------------------------------\n\nTITLE: Implementing Interval Ranking with OR-Tools CP-SAT Solver in Java\nDESCRIPTION: Demonstrates task scheduling and ranking using Google OR-Tools. The code creates interval variables with optional presence, enforces no-overlap constraints, and assigns ranks based on task precedence. It includes objective function optimization balancing task completion gains against makespan costs.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_22\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.BoolVar;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.IntervalVar;\nimport com.google.ortools.sat.LinearExpr;\nimport com.google.ortools.sat.LinearExprBuilder;\nimport com.google.ortools.sat.Literal;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** Code sample to demonstrates how to rank intervals. */\npublic class RankingSampleSat {\n  /**\n   * This code takes a list of interval variables in a noOverlap constraint, and a parallel list of\n   * integer variables and enforces the following constraint\n   *\n   * <ul>\n   *   <li>rank[i] == -1 iff interval[i] is not active.\n   *   <li>rank[i] == number of active intervals that precede interval[i].\n   * </ul>\n   */\n  static void rankTasks(CpModel model, IntVar[] starts, Literal[] presences, IntVar[] ranks) {\n    int numTasks = starts.length;\n\n    // Creates precedence variables between pairs of intervals.\n    Literal[][] precedences = new Literal[numTasks][numTasks];\n    for (int i = 0; i < numTasks; ++i) {\n      for (int j = 0; j < numTasks; ++j) {\n        if (i == j) {\n          precedences[i][i] = presences[i];\n        } else {\n          BoolVar prec = model.newBoolVar(String.format(\"%d before %d\", i, j));\n          precedences[i][j] = prec;\n          // Ensure that task i precedes task j if prec is true.\n          model.addLessThan(starts[i], starts[j]).onlyEnforceIf(prec);\n        }\n      }\n    }\n\n    // Create optional intervals.\n    for (int i = 0; i < numTasks - 1; ++i) {\n      for (int j = i + 1; j < numTasks; ++j) {\n        List<Literal> list = new ArrayList<>();\n        list.add(precedences[i][j]);\n        list.add(precedences[j][i]);\n        list.add(presences[i].not());\n        // Makes sure that if i is not performed, all precedences are false.\n        model.addImplication(presences[i].not(), precedences[i][j].not());\n        model.addImplication(presences[i].not(), precedences[j][i].not());\n        list.add(presences[j].not());\n        // Makes sure that if j is not performed, all precedences are false.\n        model.addImplication(presences[j].not(), precedences[i][j].not());\n        model.addImplication(presences[j].not(), precedences[j][i].not());\n        // The following boolOr will enforce that for any two intervals:\n        //    i precedes j or j precedes i or at least one interval is not\n        //        performed.\n        model.addBoolOr(list);\n        // For efficiency, we add a redundant constraint declaring that only one of i precedes j and\n        // j precedes i are true. This will speed up the solve because the reason of this\n        // propagation is shorter that using interval bounds is true.\n        model.addImplication(precedences[i][j], precedences[j][i].not());\n        model.addImplication(precedences[j][i], precedences[i][j].not());\n      }\n    }\n\n    // Links precedences and ranks.\n    for (int i = 0; i < numTasks; ++i) {\n      // ranks == sum(precedences) - 1;\n      LinearExprBuilder expr = LinearExpr.newBuilder();\n      for (int j = 0; j < numTasks; ++j) {\n        expr.add(precedences[j][i]);\n      }\n      expr.add(-1);\n      model.addEquality(ranks[i], expr);\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n    int horizon = 100;\n    int numTasks = 4;\n\n    IntVar[] starts = new IntVar[numTasks];\n    IntVar[] ends = new IntVar[numTasks];\n    IntervalVar[] intervals = new IntervalVar[numTasks];\n    Literal[] presences = new Literal[numTasks];\n    IntVar[] ranks = new IntVar[numTasks];\n\n    Literal trueLiteral = model.trueLiteral();\n\n    // Creates intervals, half of them are optional.\n    for (int t = 0; t < numTasks; ++t) {\n      starts[t] = model.newIntVar(0, horizon, \"start_\" + t);\n      int duration = t + 1;\n      ends[t] = model.newIntVar(0, horizon, \"end_\" + t);\n      if (t < numTasks / 2) {\n        intervals[t] = model.newIntervalVar(\n            starts[t], LinearExpr.constant(duration), ends[t], \"interval_\" + t);\n        presences[t] = trueLiteral;\n      } else {\n        presences[t] = model.newBoolVar(\"presence_\" + t);\n        intervals[t] = model.newOptionalIntervalVar(\n            starts[t], LinearExpr.constant(duration), ends[t], presences[t], \"o_interval_\" + t);\n      }\n\n      // The rank will be -1 iff the task is not performed.\n      ranks[t] = model.newIntVar(-1, numTasks - 1, \"rank_\" + t);\n    }\n\n    // Adds NoOverlap constraint.\n    model.addNoOverlap(intervals);\n\n    // Adds ranking constraint.\n    rankTasks(model, starts, presences, ranks);\n\n    // Adds a constraint on ranks (ranks[0] < ranks[1]).\n    model.addLessThan(ranks[0], ranks[1]);\n\n    // Creates makespan variable.\n    IntVar makespan = model.newIntVar(0, horizon, \"makespan\");\n    for (int t = 0; t < numTasks; ++t) {\n      model.addLessOrEqual(ends[t], makespan).onlyEnforceIf(presences[t]);\n    }\n    // The objective function is a mix of a fixed gain per task performed, and a fixed cost for each\n    // additional day of activity.\n    // The solver will balance both cost and gain and minimize makespan * per-day-penalty - number\n    // of tasks performed * per-task-gain.\n    //\n    // On this problem, as the fixed cost is less that the duration of the last interval, the solver\n    // will not perform the last interval.\n    LinearExprBuilder obj = LinearExpr.newBuilder();\n    for (int t = 0; t < numTasks; ++t) {\n      obj.addTerm(presences[t], -7);\n    }\n    obj.addTerm(makespan, 2);\n    model.minimize(obj);\n\n    // Creates a solver and solves the model.\n    CpSolver solver = new CpSolver();\n    CpSolverStatus status = solver.solve(model);\n\n    if (status == CpSolverStatus.OPTIMAL) {\n      System.out.println(\"Optimal cost: \" + solver.objectiveValue());\n      System.out.println(\"Makespan: \" + solver.value(makespan));\n      for (int t = 0; t < numTasks; ++t) {\n        if (solver.booleanValue(presences[t])) {\n          System.out.printf(\"Task %d starts at %d with rank %d%n\", t, solver.value(starts[t]),\n              solver.value(ranks[t]));\n        } else {\n          System.out.printf(\n              \"Task %d in not performed and ranked at %d%n\", t, solver.value(ranks[t]));\n        }\n      }\n    } else {\n      System.out.println(\"Solver exited with nonoptimal status: \" + status);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Distance Matrix for TSP Using Python\nDESCRIPTION: The snippet initializes a DISTANCE_MATRIX, which is a critical dataset representing the distances between cities required for solving the travelling salesman problem with OR-Tools. This matrix is used as an input to computational models to determine optimal routes. There are no specific prerequisites beyond having a Python environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/tsp_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\nDISTANCE_MATRIX = [\n    # fmt:off\n    [0, 10938, 4542, 2835, 29441, 2171, 1611, 9208, 9528, 11111, 16120, 22606, 22127, 20627, 21246, 23387, 16697, 33609, 26184, 24772, 22644, 20655, 30492, 23296, 32979, 18141, 19248, 17129, 17192, 15645, 12658, 11210, 12094, 13175, 18162, 4968, 12308, 10084, 13026, 15056],\n    [10938, 0, 6422, 9742, 18988, 12974, 11216, 19715, 19004, 18271, 25070, 31971, 31632, 30571, 31578, 33841, 27315, 43964, 36944, 35689, 33569, 31481, 41360, 33760, 43631, 28730, 29976, 27803, 28076, 26408, 23504, 22025, 22000, 13197, 14936, 15146, 23246, 20956, 23963, 25994],\n    [4542, 6422, 0, 3644, 25173, 6552, 5092, 13584, 13372, 13766, 19805, 26537, 26117, 24804, 25590, 27784, 21148, 37981, 30693, 29315, 27148, 25071, 34943, 27472, 37281, 22389, 23592, 21433, 21655, 20011, 17087, 15612, 15872, 11653, 15666, 8842, 16843, 14618, 17563, 19589],\n    [2835, 9742, 3644, 0, 28681, 3851, 4341, 11660, 12294, 13912, 18893, 25283, 24777, 23173, 23636, 25696, 18950, 35927, 28233, 26543, 24127, 21864, 31765, 24018, 33904, 19005, 20295, 18105, 18551, 16763, 13958, 12459, 12296, 10370, 15331, 5430, 14044, 12135, 14771, 16743],\n    [29441, 18988, 25173, 28681, 0, 31590, 29265, 37173, 35501, 32929, 40239, 47006, 46892, 46542, 48112, 50506, 44539, 60103, 54208, 53557, 51878, 50074, 59849, 52645, 62415, 47544, 48689, 46560, 46567, 45086, 42083, 40648, 40971, 29929, 28493, 34015, 41473, 38935, 42160, 44198],\n    [2171, 12974, 6552, 3851, 31590, 0, 3046, 7856, 8864, 11330, 15411, 21597, 21065, 19382, 19791, 21845, 15099, 32076, 24425, 22848, 20600, 18537, 28396, 21125, 30825, 15975, 17101, 14971, 15104, 13503, 10544, 9080, 9983, 13435, 18755, 2947, 10344, 8306, 11069, 13078],\n    [1611, 11216, 5092, 4341, 29265, 3046, 0, 8526, 8368, 9573, 14904, 21529, 21085, 19719, 20504, 22713, 16118, 32898, 25728, 24541, 22631, 20839, 30584, 23755, 33278, 18557, 19545, 17490, 17309, 15936, 12881, 11498, 12944, 14711, 19589, 5993, 12227, 9793, 12925, 14967],\n    [9208, 19715, 13584, 11660, 37173, 7856, 8526, 0, 3248, 7855, 8245, 13843, 13272, 11526, 12038, 14201, 7599, 24411, 17259, 16387, 15050, 13999, 23134, 17899, 26460, 12894, 13251, 11680, 10455, 9997, 7194, 6574, 10678, 20959, 26458, 8180, 5255, 2615, 5730, 7552],\n    [9528, 19004, 13372, 12294, 35501, 8864, 8368, 3248, 0, 4626, 6598, 13168, 12746, 11567, 12731, 15083, 9120, 25037, 18718, 18433, 17590, 16888, 25630, 20976, 29208, 16055, 16300, 14838, 13422, 13165, 10430, 9813, 13777, 22300, 27564, 10126, 8388, 5850, 8778, 10422],\n    [11111, 18271, 13766, 13912, 32929, 11330, 9573, 7855, 4626, 0, 7318, 14185, 14005, 13655, 15438, 17849, 12839, 27179, 21947, 22230, 21814, 21366, 29754, 25555, 33535, 20674, 20872, 19457, 17961, 17787, 15048, 14372, 18115, 24280, 29101, 13400, 13008, 10467, 13375, 14935],\n    [16120, 25070, 19805, 18893, 40239, 15411, 14904, 8245, 6598, 7318, 0, 6939, 6702, 6498, 8610, 10961, 7744, 19889, 15350, 16403, 16975, 17517, 24357, 22176, 28627, 18093, 17672, 16955, 14735, 15510, 13694, 13768, 18317, 28831, 34148, 16326, 11276, 9918, 11235, 11891],\n    [22606, 31971, 26537, 25283, 47006, 21597, 21529, 13843, 13168, 14185, 6939, 0, 793, 3401, 5562, 6839, 8923, 13433, 11264, 13775, 15853, 17629, 21684, 22315, 26411, 19539, 18517, 18636, 16024, 17632, 16948, 17587, 22131, 34799, 40296, 21953, 14739, 14568, 14366, 14002],\n    [22127, 31632, 26117, 24777, 46892, 21065, 21085, 13272, 12746, 14005, 6702, 793, 0, 2608, 4809, 6215, 8151, 13376, 10702, 13094, 15099, 16845, 21039, 21535, 25744, 18746, 17725, 17845, 15232, 16848, 16197, 16859, 21391, 34211, 39731, 21345, 14006, 13907, 13621, 13225],\n    [20627, 30571, 24804, 23173, 46542, 19382, 19719, 11526, 11567, 13655, 6498, 3401, 2608, 0, 2556, 4611, 5630, 13586, 9157, 11005, 12681, 14285, 19044, 18996, 23644, 16138, 15126, 15240, 12625, 14264, 13736, 14482, 18958, 32292, 37879, 19391, 11621, 11803, 11188, 10671],\n    [21246, 31578, 25590, 23636, 48112, 19791, 20504, 12038, 12731, 15438, 8610, 5562, 4809, 2556, 0, 2411, 4917, 12395, 6757, 8451, 10292, 12158, 16488, 16799, 21097, 14374, 13194, 13590, 10943, 12824, 12815, 13779, 18042, 32259, 37918, 19416, 10975, 11750, 10424, 9475],\n    [23387, 33841, 27784, 25696, 50506, 21845, 22713, 14201, 15083, 17849, 10961, 6839, 6215, 4611, 2411, 0, 6760, 10232, 4567, 7010, 9607, 12003, 14846, 16408, 19592, 14727, 13336, 14109, 11507, 13611, 14104, 15222, 19237, 34013, 39703, 21271, 12528, 13657, 11907, 10633],\n    [16697, 27315, 21148, 18950, 44539, 15099, 16118, 7599, 9120, 12839, 7744, 8923, 8151, 5630, 4917, 6760, 0, 16982, 9699, 9400, 9302, 9823, 16998, 14534, 21042, 10911, 10190, 9900, 7397, 8758, 8119, 8948, 13353, 27354, 33023, 14542, 6106, 6901, 5609, 5084],\n    [33609, 43964, 37981, 35927, 60103, 32076, 32898, 24411, 25037, 27179, 19889, 13433, 13376, 13586, 12395, 10232, 16982, 0, 8843, 12398, 16193, 19383, 16423, 22583, 20997, 22888, 21194, 22640, 20334, 22636, 23801, 25065, 28675, 44048, 49756, 31426, 22528, 23862, 21861, 20315],\n    [26184, 36944, 30693, 28233, 54208, 24425, 25728, 17259, 18718, 21947, 15350, 11264, 10702, 9157, 6757, 4567, 9699, 8843, 0, 3842, 7518, 10616, 10666, 14237, 15515, 14053, 12378, 13798, 11537, 13852, 15276, 16632, 19957, 35660, 41373, 23361, 14333, 16125, 13624, 11866],\n    [24772, 35689, 29315, 26543, 53557, 22848, 24541, 16387, 18433, 22230, 16403, 13775, 13094, 11005, 8451, 7010, 9400, 12398, 3842, 0, 3795, 7014, 8053, 10398, 12657, 10633, 8889, 10569, 8646, 10938, 12906, 14366, 17106, 33171, 38858, 21390, 12507, 14748, 11781, 9802],\n    [22644, 33569, 27148, 24127, 51878, 20600, 22631, 15050, 17590, 21814, 16975, 15853, 15099, 12681, 10292, 9607, 9302, 16193, 7518, 3795, 0, 3250, 8084, 6873, 11763, 6949, 5177, 7050, 5619, 7730, 10187, 11689, 13792, 30012, 35654, 18799, 10406, 12981, 9718, 7682],\n    [20655, 31481, 25071, 21864, 50074, 18537, 20839, 13999, 16888, 21366, 17517, 17629, 16845, 14285, 12158, 12003, 9823, 19383, 10616, 7014, 3250, 0, 9901, 4746, 12531, 3737, 1961, 4036, 3588, 5109, 7996, 9459, 10846, 27094, 32690, 16451, 8887, 11624, 8304, 6471],\n    [30492, 41360, 34943, 31765, 59849, 28396, 30584, 23134, 25630, 29754, 24357, 21684, 21039, 19044, 16488, 14846, 16998, 16423, 10666, 8053, 8084, 9901, 0, 9363, 4870, 13117, 11575, 13793, 13300, 15009, 17856, 19337, 20454, 36551, 42017, 26352, 18403, 21033, 17737, 15720],\n    [23296, 33760, 27472, 24018, 52645, 21125, 23755, 17899, 20976, 25555, 22176, 22315, 21535, 18996, 16799, 16408, 14534, 22583, 14237, 10398, 6873, 4746, 9363, 0, 10020, 5211, 4685, 6348, 7636, 8010, 11074, 12315, 11926, 27537, 32880, 18634, 12644, 15358, 12200, 10674],\n    [32979, 43631, 37281, 33904, 62415, 30825, 33278, 26460, 29208, 33535, 28627, 26411, 25744, 23644, 21097, 19592, 21042, 20997, 15515, 12657, 11763, 12531, 4870, 10020, 0, 14901, 13738, 15855, 16118, 17348, 20397, 21793, 21936, 37429, 42654, 28485, 21414, 24144, 20816, 18908],\n    [18141, 28730, 22389, 19005, 47544, 15975, 18557, 12894, 16055, 20674, 18093, 19539, 18746, 16138, 14374, 14727, 10911, 22888, 14053, 10633, 6949, 3737, 13117, 5211, 14901, 0, 1777, 1217, 3528, 2896, 5892, 7104, 7338, 23517, 29068, 13583, 7667, 10304, 7330, 6204],\n    [19248, 29976, 23592, 20295, 48689, 17101, 19545, 13251, 16300, 20872, 17672, 18517, 17725, 15126, 13194, 13336, 10190, 21194, 12378, 8889, 5177, 1961, 11575, 4685, 13738, 1777, 0, 2217, 2976, 3610, 6675, 8055, 8965, 25197, 30774, 14865, 8007, 10742, 7532, 6000],\n    [17129, 27803, 21433, 18105, 46560, 14971, 17490, 11680, 14838, 19457, 16955, 18636, 17845, 15240, 13590, 14109, 9900, 22640, 13798, 10569, 7050, 4036, 13793, 6348, 15855, 1217, 2217, 0, 2647, 1686, 4726, 6000, 6810, 23060, 28665, 12674, 6450, 9094, 6117, 5066],\n    [17192, 28076, 21655, 18551, 46567, 15104, 17309, 10455, 13422, 17961, 14735, 16024, 15232, 12625, 10943, 11507, 7397, 20334, 11537, 8646, 5619, 3588, 13300, 7636, 16118, 3528, 2976, 2647, 0, 2320, 4593, 6093, 8479, 24542, 30219, 13194, 5301, 8042, 4735, 3039],\n    [15645, 26408, 20011, 16763, 45086, 13503, 15936, 9997, 13165, 17787, 15510, 17632, 16848, 14264, 12824, 13611, 8758, 22636, 13852, 10938, 7730, 5109, 15009, 8010, 17348, 2896, 3610, 1686, 2320, 0, 3086, 4444, 6169, 22301, 27963, 11344, 4780, 7408, 4488, 3721],\n    [12658, 23504, 17087, 13958, 42083, 10544, 12881, 7194, 10430, 15048, 13694, 16948, 16197, 13736, 12815, 14104, 8119, 23801, 15276, 12906, 10187, 7996, 17856, 11074, 20397, 5892, 6675, 4726, 4593, 3086, 0, 1501, 5239, 20390, 26101, 8611, 2418, 4580, 2599, 3496],\n    [11210, 22025, 15612, 12459, 40648, 9080, 11498, 6574, 9813, 14372, 13768, 17587, 16859, 14482, 13779, 15222, 8948, 25065, 16632, 14366, 11689, 9459, 19337, 12315, 21793, 7104, 8055, 6000, 6093, 4444, 1501, 0, 4608, 19032, 24747, 7110, 2860, 4072, 3355, 4772],\n    [12094, 22000, 15872, 12296, 40971, 9983, 12944, 10678, 13777, 18115, 18317, 22131, 21391, 18958, 18042, 19237, 13353, 28675, 19957, 17106, 13792, 10846, 20454, 11926, 21936, 7338, 8965, 6810, 8479, 6169, 5239, 4608, 0, 16249, 21866, 7146, 7403, 8446, 7773, 8614]\n```\n\n----------------------------------------\n\nTITLE: Default Pickup & Delivery Implementation\nDESCRIPTION: Sample implementations for basic Pickup & Delivery routing problems using the default (ANY) policy in the Vehicle Routing solver. Demonstrates standard PDP routing optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/PDP.md#2025-04-17_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvrp_pickup_delivery.cc\n```\n\nLANGUAGE: Python\nCODE:\n```\nvrp_pickup_delivery.py\n```\n\nLANGUAGE: Java\nCODE:\n```\nVrpPickupDelivery.java\n```\n\nLANGUAGE: C#\nCODE:\n```\nVrpPickupDelivery.cs\n```\n\n----------------------------------------\n\nTITLE: Fill-a-Pix Puzzle Solver Implementation\nDESCRIPTION: Main implementation of the Fill-a-Pix puzzle solver using OR-Tools. Includes puzzle definition, constraint setup, and solution search. The code handles both default puzzles and custom input from files. Uses constraint programming to ensure the sum of filled cells around each number matches the clue value.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/fill_a_pix.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n# Puzzle 1 from\n# http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/rules\ndefault_n = 10\nX = -1\ndefault_puzzle = [\n    [X, X, X, X, X, X, X, X, 0, X], [X, 8, 8, X, 2, X, 0, X, X, X],\n    [5, X, 8, X, X, X, X, X, X, X], [X, X, X, X, X, 2, X, X, X, 2],\n    [1, X, X, X, 4, 5, 6, X, X, X], [X, 0, X, X, X, 7, 9, X, X, 6],\n    [X, X, X, 6, X, X, 9, X, X, 6], [X, X, 6, 6, 8, 7, 8, 7, X, 5],\n    [X, 4, X, 6, 6, 6, X, 6, X, 4], [X, X, X, X, X, X, 3, X, X, X]\n]\n\n\ndef main(puzzle='', n=''):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Fill-a-Pix')\n\n  #\n  # data\n  #\n\n  # Set default problem\n  if puzzle == '':\n    puzzle = default_puzzle\n    n = default_n\n  else:\n    print('n:', n)\n\n  # for the neighbors of 'this' cell\n  S = [-1, 0, 1]\n\n  # print problem instance\n  print('Problem:')\n  for i in range(n):\n    for j in range(n):\n      if puzzle[i][j] == X:\n        sys.stdout.write('.')\n      else:\n        sys.stdout.write(str(puzzle[i][j]))\n    print()\n  print()\n\n  #\n  # declare variables\n  #\n  pict = {}\n  for i in range(n):\n    for j in range(n):\n      pict[(i, j)] = solver.IntVar(0, 1, 'pict %i %i' % (i, j))\n\n  pict_flat = [pict[i, j] for i in range(n) for j in range(n)]\n\n  #\n  # constraints\n  #\n  for i in range(n):\n    for j in range(n):\n      if puzzle[i][j] > X:\n        # this cell is the sum of all the surrounding cells\n        solver.Add(puzzle[i][j] == solver.Sum([\n            pict[i + a, j + b]\n            for a in S\n            for b in S\n            if i + a >= 0 and j + b >= 0 and i + a < n and j + b < n\n        ]))\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(pict_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  print('Solution:')\n  while solver.NextSolution():\n    num_solutions += 1\n    for i in range(n):\n      row = [str(pict[i, j].Value()) for j in range(n)]\n      for j in range(n):\n        if row[j] == '0':\n          row[j] = ' '\n        else:\n          row[j] = '#'\n      print(''.join(row))\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\n#\n# Read a problem instance from a file\n#\ndef read_problem(file):\n  f = open(file, 'r')\n  n = int(f.readline())\n  puzzle = []\n  for i in range(n):\n    x = f.readline()\n    row = [0] * n\n    for j in range(n):\n      if x[j] == '.':\n        tmp = -1\n      else:\n        tmp = int(x[j])\n      row[j] = tmp\n    puzzle.append(row)\n  return [puzzle, n]\n\n\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  print('Problem instance from', file)\n  [puzzle, n] = read_problem(file)\n  main(puzzle, n)\nelse:\n  main()\n```\n\n----------------------------------------\n\nTITLE: Displaying Detailed Driver Schedules in the Solution\nDESCRIPTION: Outputs detailed information about each driver's schedule, including driving times, working times, and shift assignments, with detection of breaks between shifts.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfor d in range(num_drivers):\n    print(\"Driver %i: \" % (d + 1))\n    print(\"  total driving time =\", solver.value(driving_times[d]))\n    print(\n        \"  working time =\",\n        solver.value(working_times[d]) + setup_time + cleanup_time,\n    )\n\n    first = True\n    for s in range(num_shifts):\n        shift = shifts[s]\n\n        if not solver.boolean_value(performed[d, s]):\n            continue\n\n        # Hack to detect if the waiting time between the last shift and\n        # this one exceeds 30 minutes. For this, we look at the\n        # no_break_driving which was reinitialized in that case.\n        if solver.value(no_break_driving[d, s]) == shift[5] and not first:\n            print(\"    **break**\")\n        print(\"    shift \", shift[0], \":\", shift[1], \"-\", shift[2])\n        first = False\n\nreturn int(solver.objective_value)\n```\n\n----------------------------------------\n\nTITLE: Minimizing Required Bus Drivers with OR-Tools CP-SAT Solver in Python\nDESCRIPTION: Function that uses constraint programming to find the minimum number of bus drivers needed to cover all shifts while respecting driving time limits, mandatory breaks, and working time constraints. The function creates a network flow model where each node represents a shift and arcs represent valid transitions between shifts for a driver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef find_minimum_number_of_drivers(shifts, params):\n    \"\"\"Minimize the number of needed drivers.\"\"\"\n\n    num_shifts = len(shifts)\n\n    # All durations are in minutes.\n    max_driving_time = 540  # 8 hours.\n    max_driving_time_without_pauses = 240  # 4 hours\n    min_pause_after_4h = 30\n    min_delay_between_shifts = 2\n    max_working_time = 720\n    min_working_time = 390  # 6.5 hours\n    extra_time = 10 + 25\n    max_break = 180\n\n    # Computed data.\n    total_driving_time = sum(shift[5] for shift in shifts)\n    min_num_drivers = int(math.ceil(total_driving_time * 1.0 / max_driving_time))\n    min_start_time = min(shift[3] for shift in shifts)\n    max_end_time = max(shift[4] for shift in shifts)\n\n    print(\"Bus driver scheduling\")\n    print(\"  num shifts =\", num_shifts)\n    print(\"  total driving time =\", total_driving_time, \"minutes\")\n    print(\"  min num drivers =\", min_num_drivers)\n    print(\"  min start time =\", min_start_time)\n    print(\"  max end time =\", max_end_time)\n\n    # We are going to build a flow from a the start of the day to the end\n    # of the day.\n    #\n    # Along the path, we will accumulate driving time, accrued time since the\n    # last break, and total working time.\n\n    model = cp_model.CpModel()\n\n    # Per node info\n    driving_time = {}\n    working_time = {}\n    no_break_driving_time = {}\n\n    incoming_literals = collections.defaultdict(list)\n    outgoing_literals = collections.defaultdict(list)\n    outgoing_source_literals = []\n    incoming_sink_literals = []\n\n    all_literals = []\n\n    # Create all the shift variables before iterating on the transitions\n    # between these shifts.\n    for shift in range(num_shifts):\n        driving_time[shift] = model.NewIntVar(0, max_driving_time, \"dt_%i\" % shift)\n        no_break_driving_time[shift] = model.NewIntVar(\n            0, max_driving_time_without_pauses, \"nbdt_%i\" % shift\n        )\n        working_time[shift] = model.NewIntVar(0, max_working_time, \"wt_%i\" % shift)\n\n    for shift in range(num_shifts):\n        duration = shifts[shift][5]\n\n        # Arc from source to shift.\n        #    - set the working time of the driver\n        #    - increase driving time and driving time since the last break\n        source_lit = model.NewBoolVar(\"from source to %i\" % shift)\n        all_literals.append(source_lit)\n        outgoing_source_literals.append(source_lit)\n        incoming_literals[shift].append(source_lit)\n        model.Add(driving_time[shift] == duration).OnlyEnforceIf(source_lit)\n        model.Add(no_break_driving_time[shift] == duration).OnlyEnforceIf(source_lit)\n        model.Add(working_time[shift] == duration + extra_time).OnlyEnforceIf(\n            source_lit\n        )\n\n        # Arc from shift to sink\n        #     - checks that working time is greater than min_working_time\n        sink_lit = model.NewBoolVar(\"from %i to sink\" % shift)\n        all_literals.append(sink_lit)\n        outgoing_literals[shift].append(sink_lit)\n        incoming_sink_literals.append(sink_lit)\n        model.Add(working_time[shift] >= min_working_time).OnlyEnforceIf(sink_lit)\n\n        for other in range(num_shifts):\n            delay = shifts[other][3] - shifts[shift][4]\n            if delay < min_delay_between_shifts:\n                continue\n            if delay > max_break:\n                break  # Assumes start times are sorted.\n            other_duration = shifts[other][5]\n            lit = model.NewBoolVar(\"from %i to %i\" % (shift, other))\n            all_literals.append(lit)\n\n            # Increase driving time\n            model.Add(\n                driving_time[other] == driving_time[shift] + other_duration\n            ).OnlyEnforceIf(lit)\n\n            # Increase no_break_driving or reset it to 0 depending on the delay\n            if delay >= min_pause_after_4h:\n                model.Add(no_break_driving_time[other] == other_duration).OnlyEnforceIf(\n                    lit\n                )\n            else:\n                model.Add(\n                    no_break_driving_time[other]\n                    == no_break_driving_time[shift] + other_duration\n                ).OnlyEnforceIf(lit)\n\n            # Increase working time\n            model.Add(\n                working_time[other] == working_time[shift] + delay + other_duration\n            ).OnlyEnforceIf(lit)\n\n            # Add arc\n            outgoing_literals[shift].append(lit)\n            incoming_literals[other].append(lit)\n\n    # Create dag constraint.\n    for shift in range(num_shifts):\n        model.Add(sum(outgoing_literals[shift]) == 1)\n        model.Add(sum(incoming_literals[shift]) == 1)\n\n    # Num drivers\n    num_drivers = model.NewIntVar(min_num_drivers, min_num_drivers * 3, \"num_drivers\")\n    model.Add(sum(incoming_sink_literals) == num_drivers)\n    model.Add(sum(outgoing_source_literals) == num_drivers)\n\n    model.Minimize(num_drivers)\n\n    # Solve model.\n    solver = cp_model.CpSolver()\n    solver.parameters.log_search_progress = True\n    # solver.parameters.num_search_workers = 16\n    # solver.parameters.boolean_encoding_level = 0\n    # solver.parameters.lns_focus_on_decision_variables = True\n    status = solver.Solve(model)\n\n    if status != cp_model.OPTIMAL and status != cp_model.FEASIBLE:\n        return -1\n\n    # Display solution\n    optimal_num_drivers = int(solver.ObjectiveValue())\n    print(\"minimal number of drivers =\", optimal_num_drivers)\n    return optimal_num_drivers\n```\n\n----------------------------------------\n\nTITLE: Implementing Magic Square Solver using OR-Tools\nDESCRIPTION: Defines the main function to solve the magic square problem using OR-Tools. It sets up variables, constraints, and searches for solutions. The function takes parameters for square size and solution limit.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n, limit):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"n-queens\")\n  if not solver:\n    return\n\n  #\n  # data\n  #\n\n  #\n  # declare variables\n  #\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(1, n * n, \"x(%i,%i)\" % (i, j))\n  x_flat = [x[(i, j)] for i in range(n) for j in range(n)]\n\n  # the sum\n  # s = ( n * (n*n + 1)) / 2\n  s = solver.IntVar(1, n * n * n, \"s\")\n\n  #\n  # constraints\n  #\n  # solver.Add(s == ( n * (n*n + 1)) / 2)\n\n  solver.Add(solver.AllDifferent(x_flat))\n\n  [solver.Add(solver.Sum([x[(i, j)] for j in range(n)]) == s) for i in range(n)]\n  [solver.Add(solver.Sum([x[(i, j)] for i in range(n)]) == s) for j in range(n)]\n\n  solver.Add(solver.Sum([x[(i, i)] for i in range(n)]) == s)  # diag 1\n  solver.Add(solver.Sum([x[(i, n - i - 1)] for i in range(n)]) == s)  # diag 2\n\n  # symmetry breaking\n  # solver.Add(x[(0,0)] == 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x_flat)\n  solution.Add(s)\n\n  # db: DecisionBuilder\n  db = solver.Phase(\n      x_flat,\n      # solver.INT_VAR_DEFAULT,\n      solver.CHOOSE_FIRST_UNBOUND,\n      # solver.CHOOSE_MIN_SIZE_LOWEST_MAX,\n\n      # solver.ASSIGN_MIN_VALUE\n      solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"s:\", s.Value())\n    for i in range(n):\n      for j in range(n):\n        print(\"%2i\" % x[(i, j)].Value(), end=\" \")\n      print()\n\n    print()\n    num_solutions += 1\n    if num_solutions > limit:\n      break\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 4\nlimit=100\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nif len(sys.argv) > 2:\n  limit = int(sys.argv[2])\n\nmain(n, limit)\n```\n\n----------------------------------------\n\nTITLE: Transitive Reduction with Circuit Delays and Penalties in CP-SAT\nDESCRIPTION: This function implements a transitive reduction using a circuit constraint to rank tasks. It handles transition times and costs between tasks, including penalties for breaking task sequences and delays for task transitions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/transitions_in_no_overlap_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef transitive_reduction_with_circuit_delays_and_penalties(\n    model: cp_model.CpModel,\n    starts: Sequence[cp_model.IntVar],\n    durations: Sequence[int],\n    presences: Sequence[Union[cp_model.IntVar, bool]],\n    penalties: Dict[Tuple[int, int], int],\n    delays: Dict[Tuple[int, int], int],\n) -> Sequence[Tuple[cp_model.IntVar, int]]:\n    \"\"\"This method uses a circuit constraint to rank tasks.\n\n    This method assumes that all starts are disjoint, meaning that all tasks have\n    a strictly positive duration, and they appear in the same NoOverlap\n    constraint.\n\n    The extra node (with id 0) will be used to decide which task is first with\n    its only outgoing arc, and which task is last with its only incoming arc.\n    Each task i will be associated with id i + 1, and an arc between i + 1 and j +\n    1 indicates that j is the immediate successor of i.\n\n    The circuit constraint ensures there is at most 1 hamiltonian cycle of\n    length > 1. If no such path exists, then no tasks are active.\n    We also need to enforce that any hamiltonian cycle of size > 1 must contain\n    the node 0. And thus, there is a self loop on node 0 iff the circuit is empty.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      durations: the durations of all tasks.\n      presences: The array of presence variables of all tasks.\n      penalties: the array of tuple (`tail_index`, `head_index`, `penalty`) that\n        specifies that if task `tail_index` is the successor of the task\n        `head_index`, then `penalty` must be added to the cost.\n      delays: the array of tuple (`tail_index`, `head_index`, `delay`) that\n        specifies that if task `tail_index` is the successor of the task\n        `head_index`, then an extra `delay` must be added between the end of the\n        first task and the start of the second task.\n\n    Returns:\n      The list of pairs (Boolean variables, penalty) to be added to the objective.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    arcs: List[cp_model.ArcT] = []\n    penalty_terms = []\n    for i in all_tasks:\n        # if node i is first.\n        start_lit = model.new_bool_var(f\"start_{i}\")\n        arcs.append((0, i + 1, start_lit))\n\n        # As there are no other constraints on the problem, we can add this\n        # redundant constraint.\n        model.add(starts[i] == 0).only_enforce_if(start_lit)\n\n        # if node i is last.\n        end_lit = model.new_bool_var(f\"end_{i}\")\n        arcs.append((i + 1, 0, end_lit))\n\n        for j in all_tasks:\n            if i == j:\n                arcs.append((i + 1, i + 1, ~presences[i]))\n            else:\n                literal = model.new_bool_var(f\"arc_{i}_to_{j}\")\n                arcs.append((i + 1, j + 1, literal))\n\n                min_delay = 0\n                key = (i, j)\n                if key in delays:\n                    min_delay = delays[key]\n                model.add(\n                    starts[j] >= starts[i] + durations[i] + min_delay\n                ).only_enforce_if(literal)\n\n                # Create the penalties.\n                if key in penalties:\n                    penalty_terms.append((literal, penalties[key]))\n\n    # Manage the empty circuit\n    empty = model.new_bool_var(\"empty\")\n    arcs.append((0, 0, empty))\n\n    for i in all_tasks:\n        model.add_implication(empty, ~presences[i])\n\n    # Add the circuit constraint.\n    model.add_circuit(arcs)\n\n    return penalty_terms\n```\n\n----------------------------------------\n\nTITLE: Solving a Problem Using alldifferent_except_0 Constraint\nDESCRIPTION: Complete example of solving a constraint satisfaction problem using the alldifferent_except_0 constraint. The problem creates 7 variables with domains [0,6], requires exactly 2 variables to be 0, and the rest must be different from each other.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/alldifferent_except_0.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(unused_argv):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Alldifferent except 0\")\n\n  # data\n  n = 7\n\n  # declare variables\n  x = [solver.IntVar(0, n - 1, \"x%i\" % i) for i in range(n)]\n  # Number of zeros.\n  z = solver.Sum([x[i] == 0 for i in range(n)]).VarWithName(\"z\")\n\n  #\n  # constraints\n  #\n  alldifferent_except_0(solver, x)\n\n  # we require 2 0's\n  solver.Add(z == 2)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[i] for i in range(n)])\n  solution.Add(z)\n\n  collector = solver.AllSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase([x[i] for i in range(n)], solver.CHOOSE_FIRST_UNBOUND,\n                   solver.ASSIGN_MIN_VALUE), [collector])\n\n  num_solutions = collector.SolutionCount()\n  for s in range(num_solutions):\n    print(\"x:\", [collector.Value(s, x[i]) for i in range(n)])\n    print(\"z:\", collector.Value(s, z))\n    print()\n\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Main Function for Solving Nonogram Puzzle\nDESCRIPTION: This is the main function that sets up the Nonogram puzzle, applies constraints, and searches for solutions using the OR-Tools solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table2.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main(rows, row_rule_len, row_rules, cols, col_rule_len, col_rules):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Regular test')\n\n  #\n  # variables\n  #\n  board = {}\n  for i in range(rows):\n    for j in range(cols):\n      board[i, j] = solver.IntVar(0, 1, 'board[%i, %i]' % (i, j))\n  board_flat = [board[i, j] for i in range(rows) for j in range(cols)]\n\n  # Flattened board for labeling.\n  # This labeling was inspired by a suggestion from\n  # Pascal Van Hentenryck about my Comet nonogram model.\n  board_label = []\n  if rows * row_rule_len < cols * col_rule_len:\n    for i in range(rows):\n      for j in range(cols):\n        board_label.append(board[i, j])\n  else:\n    for j in range(cols):\n      for i in range(rows):\n        board_label.append(board[i, j])\n\n  #\n  # constraints\n  #\n  for i in range(rows):\n    check_rule(row_rules[i], [board[i, j] for j in range(cols)])\n\n  for j in range(cols):\n    check_rule(col_rules[j], [board[i, j] for i in range(rows)])\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(board_label, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  print('before solver, wall time = ', solver.WallTime(), 'ms')\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    print()\n    num_solutions += 1\n    for i in range(rows):\n      row = [board[i, j].Value() for j in range(cols)]\n      row_pres = []\n      for j in row:\n        if j == 1:\n          row_pres.append('#')\n        else:\n          row_pres.append(' ')\n      print('  ', ''.join(row_pres))\n\n    print()\n    print('  ', '-' * cols)\n\n    if num_solutions >= 2:\n      print('2 solutions is enough...')\n      break\n\n  solver.EndSearch()\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for Scheduling Problem with OR-Tools\nDESCRIPTION: Function that creates three pandas DataFrames containing the maximum load profile, minimum load profile, and task specifications for a scheduling problem. The data is defined as string representations and converted to DataFrames.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model() -> tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\n    \"\"\"Creates the dataframes that describes the model.\"\"\"\n\n    max_load_str: str = \"\"\"\n  start_hour  max_load\n     0            0\n     2            0\n     4            3\n     6            6\n     8            8\n    10           12\n    12            8\n    14           12\n    16           10\n    18            6\n    20            4\n    22            0\n  \"\"\"\n\n    min_load_str: str = \"\"\"\n  start_hour  min_load\n     0            0\n     2            0\n     4            0\n     6            0\n     8            3\n    10            3\n    12            1\n    14            3\n    16            3\n    18            1\n    20            1\n    22            0\n  \"\"\"\n\n    tasks_str: str = \"\"\"\n  name  duration load  priority\n   t1      60      3      2\n   t2     180      2      1\n   t3     240      5      3\n   t4      90      4      2\n   t5     120      3      1\n   t6     300      3      3\n   t7     120      1      2\n   t8     100      5      2\n   t9     110      2      1\n   t10    300      5      3\n   t11     90      4      2\n   t12    120      3      1\n   t13    250      3      3\n   t14    120      1      2\n   t15     40      5      3\n   t16     70      4      2\n   t17     90      8      1\n   t18     40      3      3\n   t19    120      5      2\n   t20     60      3      2\n   t21    180      2      1\n   t22    240      5      3\n   t23     90      4      2\n   t24    120      3      1\n   t25    300      3      3\n   t26    120      1      2\n   t27    100      5      2\n   t28    110      2      1\n   t29    300      5      3\n   t30     90      4      2\n  \"\"\"\n\n    max_load_df = pd.read_table(io.StringIO(max_load_str), sep=r\"\\s+\")\n    min_load_df = pd.read_table(io.StringIO(min_load_str), sep=r\"\\s+\")\n    tasks_df = pd.read_table(io.StringIO(tasks_str), index_col=0, sep=r\"\\s+\")\n    return max_load_df, min_load_df, tasks_df\n```\n\n----------------------------------------\n\nTITLE: Encoding Boolean Product with OR-Tools SAT in Python\nDESCRIPTION: This Python code defines a function `boolean_product_sample_sat` that demonstrates how to encode the product of two Boolean variables using the OR-Tools SAT solver. It creates Boolean variables `x`, `y`, and `p`, and adds constraints to enforce the relationship `p == x * y`. The solver is then used to find all possible solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/boolean_product_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from ortools.sat.python import cp_model\n\n\ndef boolean_product_sample_sat():\n    \\\"\\\"\\\"Encoding of the product of two Boolean variables.\n\n    p == x * y, which is the same as p <=> x and y\n    \\\"\\\"\\\"\n    model = cp_model.CpModel()\n    x = model.new_bool_var(\\\"x\\\")\n    y = model.new_bool_var(\\\"y\\\")\n    p = model.new_bool_var(\\\"p\\\")\n\n    # x and y implies p, rewrite as not(x and y) or p.\n    model.add_bool_or(~x, ~y, p)\n\n    # p implies x and y, expanded into two implications.\n    model.add_implication(p, x)\n    model.add_implication(p, y)\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = cp_model.VarArraySolutionPrinter([x, y, p])\n    solver.parameters.enumerate_all_solutions = True\n    solver.solve(model, solution_printer)\n\n\nboolean_product_sample_sat()\"\n```\n\n----------------------------------------\n\nTITLE: Custom Heuristic Combination for Set Cover Problem in C++\nDESCRIPTION: This snippet implements a custom combination of heuristics for solving the set covering problem. It performs 10,000 iterations of clearing 10% of variables, running a Chvatal greedy descent, and using steepest local search.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/README.md#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nCost best_cost = std::numeric_limits<Cost>::max();\nSubsetBoolVector best_choices = ledger.GetSolution();\nfor (int i = 0; i < 10000; ++i) {\n  ledger.LoadSolution(best_choices);\n  ClearRandomSubsets(0.1 * model.num_subsets().value(), &ledger);\n\n  GreedySolutionGenerator greedy(&ledger);\n  CHECK(greedy.NextSolution());\n\n  SteepestSearch steepest(&ledger);\n  CHECK(steepest.NextSolution(10000));\n\n  EXPECT_TRUE(ledger.CheckSolution());\n  if (ledger.cost() < best_cost) {\n    best_cost = ledger.cost();\n    best_choices = ledger.GetSolution();\n    LOG(INFO) << \"Better cost: \" << best_cost << \" at iteration = \" << i;\n  }\n}\nledger.LoadSolution(best_choices);\nLOG(INFO) << \"Best cost: \" << ledger.cost();\n```\n\n----------------------------------------\n\nTITLE: Search All Solutions in C# using OR-Tools\nDESCRIPTION: Shows how to use OR-Tools CP-SAT solver in C# to enumerate all solutions. Implements a solution callback printer class to display and count solutions as they are found.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class VarArraySolutionPrinter : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinter(IntVar[] variables)\n    {\n        variables_ = variables;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        {\n            Console.WriteLine(String.Format(\"Solution #{0}: time = {1:F2} s\", solution_count_, WallTime()));\n            foreach (IntVar v in variables_)\n            {\n                Console.WriteLine(String.Format(\"  {0} = {1}\", v.ToString(), Value(v)));\n            }\n            solution_count_++;\n        }\n    }\n\n    public int SolutionCount()\n    {\n        return solution_count_;\n    }\n\n    private int solution_count_;\n    private IntVar[] variables_;\n}\n\npublic class SearchForAllSolutionsSampleSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n\n        // Creates the variables.\n        int num_vals = 3;\n\n        IntVar x = model.NewIntVar(0, num_vals - 1, \"x\");\n        IntVar y = model.NewIntVar(0, num_vals - 1, \"y\");\n        IntVar z = model.NewIntVar(0, num_vals - 1, \"z\");\n\n        // Adds a different constraint.\n        model.Add(x != y);\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        VarArraySolutionPrinter cb = new VarArraySolutionPrinter(new IntVar[] { x, y, z });\n        // Search for all solutions.\n        solver.StringParameters = \"enumerate_all_solutions:true\";\n        // And solve.\n        solver.Solve(model, cb);\n\n        Console.WriteLine($\"Number of solutions found: {cb.SolutionCount()}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Step Function in Python\nDESCRIPTION: Python implementation of a step function using OR-Tools CP-SAT solver. Shows how to model discrete steps using boolean variables and domain constraints, with a solution printer callback class.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Implements a step function.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef step_function_sample_sat():\n    \"\"\"Encode the step function.\"\"\"\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Declare our primary variable.\n    x = model.new_int_var(0, 20, \"x\")\n\n    # Create the expression variable and implement the step function\n    # Note it is not defined for x == 2.\n    #\n    #        -               3\n    # -- --      ---------   2\n    #                        1\n    #      -- ---            0\n    # 0 ================ 20\n    #\n    expr = model.new_int_var(0, 3, \"expr\")\n\n    # expr == 0 on [5, 6] U [8, 10]\n    b0 = model.new_bool_var(\"b0\")\n    model.add_linear_expression_in_domain(\n        x, cp_model.Domain.from_intervals([(5, 6), (8, 10)])\n    ).only_enforce_if(b0)\n    model.add(expr == 0).only_enforce_if(b0)\n\n    # expr == 2 on [0, 1] U [3, 4] U [11, 20]\n    b2 = model.new_bool_var(\"b2\")\n    model.add_linear_expression_in_domain(\n        x, cp_model.Domain.from_intervals([(0, 1), (3, 4), (11, 20)])\n    ).only_enforce_if(b2)\n    model.add(expr == 2).only_enforce_if(b2)\n\n    # expr == 3 when x == 7\n    b3 = model.new_bool_var(\"b3\")\n    model.add(x == 7).only_enforce_if(b3)\n    model.add(expr == 3).only_enforce_if(b3)\n\n    # At least one bi is true. (we could use an exactly one constraint).\n    model.add_bool_or(b0, b2, b3)\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy([x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE)\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([x, expr])\n    solver.solve(model, solution_printer)\n\n\nstep_function_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: VRP Node-Index Relationship Demo\nDESCRIPTION: Main implementation showing the relationship between nodes and indices in a VRP problem. Demonstrates how OR-Tools handles start/end nodes, vehicle routing, and index mapping. Includes visualization of node-index relationships through markdown tables.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_nodes_indices.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    locations = 17\n    starts = [5, 5, 7, 8]\n    ends = [1, 2, 4, 4]\n    vehicles = len(starts)\n    assert len(starts) == len(ends)\n\n    manager = pywrapcp.RoutingIndexManager(locations, vehicles, starts, ends)\n    routing = pywrapcp.RoutingModel(manager)\n\n    print(\"Starts/Ends:\")\n    header = \"| |\"\n    separator = \"|---|\"\n    v_starts = \"| start |\"\n    v_ends = \"| end |\"\n    for v in range(manager.GetNumberOfVehicles()):\n        header += f\" vehicle {v} |\"\n        separator += \"---|\"\n        v_starts += f\" {starts[v]} |\"\n        v_ends += f\" {ends[v]} |\"\n    print(header)\n    print(separator)\n    print(v_starts)\n    print(v_ends)\n\n    print(\"\\nNodes:\")\n    print(\n        \"| locations | manager.GetNumberOfNodes | manager.GetNumberOfIndices |\"\n        \" routing.nodes | routing.Size |\"\n    )\n    print(\"|---|---|---|---|---|\")\n    print(\n        f\"| {locations} | {manager.GetNumberOfNodes()} |\"\n        f\" {manager.GetNumberOfIndices()} | {routing.nodes()} |\"\n        f\" {routing.Size()} |\"\n    )\n\n    print(\"\\nLocations:\")\n    print(\"| node | index | routing.IsStart | routing.IsEnd |\")\n    print(\"|---|---|---|---|\")\n    for node in range(manager.GetNumberOfNodes()):\n        if node in starts or node in ends:\n            continue\n        index = manager.NodeToIndex(node)\n        print(\n            f\"| {node} | {index} | {routing.IsStart(index)} |\"\n            f\" {routing.IsEnd(index)} |\"\n        )\n\n    print(\"\\nStart/End:\")\n    print(\"| vehicle | Start/end | node | index | routing.IsStart | routing.IsEnd |\")\n    print(\"|---|---|---|---|---|---|\")\n    for v in range(manager.GetNumberOfVehicles()):\n        start_index = routing.Start(v)\n        start_node = manager.IndexToNode(start_index)\n        print(\n            f\"| {v} | start | {start_node} | {start_index} |\"\n            f\" {routing.IsStart(start_index)} | {routing.IsEnd(start_index)} |\"\n        )\n    for v in range(manager.GetNumberOfVehicles()):\n        end_index = routing.End(v)\n        end_node = manager.IndexToNode(end_index)\n        print(\n            f\"| {v} | end  | {end_node} | {end_index} |\"\n            f\" {routing.IsStart(end_index)} | {routing.IsEnd(end_index)} |\"\n        )\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Solving CP-SAT Model with Intermediate Solutions in Java\nDESCRIPTION: This Java code demonstrates solving a CP-SAT model while capturing intermediate solutions. It defines a custom solution callback to print each solution found during the optimization process. It also includes a best bound callback to track improvements in the objective value.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\nimport java.util.function.Consumer;\n\n/** Solves an optimization problem and displays all intermediate solutions. */\npublic final class SolveAndPrintIntermediateSolutionsSampleSat {\n  static class VarArraySolutionPrinterWithObjective extends CpSolverSolutionCallback {\n    public VarArraySolutionPrinterWithObjective(IntVar[] variables) {\n      variableArray = variables;\n    }\n\n    @Override\n    public void onSolutionCallback() {\n      System.out.printf(\"Solution #%d: time = %.02f s%n\", solutionCount, wallTime());\n      System.out.printf(\"  objective value = %f%n\", objectiveValue());\n      for (IntVar v : variableArray) {\n        System.out.printf(\"  %s = %d%n\", v.getName(), value(v));\n      }\n      solutionCount++;\n    }\n\n    public int getSolutionCount() {\n      return solutionCount;\n    }\n\n    private int solutionCount;\n    private final IntVar[] variableArray;\n  }\n\n  static class BestBoundCallback implements Consumer<Double> {\n    public BestBoundCallback() {\n      bestBound = 0.0;\n      numImprovements = 0;\n    }\n\n    @Override\n    public void accept(Double bound) {\n      bestBound = bound;\n      numImprovements++;\n    }\n\n    public double getBestBound() {\n      return bestBound;\n    }\n\n    double bestBound;\n    int numImprovements;\n  }\n\n\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n\n    // Create the constraint.\n    model.addDifferent(x, y);\n\n    // Maximize a linear combination of variables.\n    model.maximize(LinearExpr.weightedSum(new IntVar[] {x, y, z}, new long[] {1, 2, 3}));\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    VarArraySolutionPrinterWithObjective cb =\n        new VarArraySolutionPrinterWithObjective(new IntVar[] {x, y, z});\n    solver.getParameters().setNumWorkers(1);\n    solver.getParameters().setLinearizationLevel(2);\n    BestBoundCallback bestBoundCallback = new BestBoundCallback();\n\n    solver.setBestBoundCallback(bestBoundCallback);\n    CpSolverStatus unusedStatus = solver.solve(model, cb);\n\n    System.out.println(\"solution count: \" + cb.getSolutionCount());\n    System.out.println(\"best bound count: \" + bestBoundCallback.numImprovements);\n  }\n\n  private SolveAndPrintIntermediateSolutionsSampleSat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing If-Then-Else Channeling Constraints in Python with CP-SAT\nDESCRIPTION: This Python code demonstrates how to implement conditional logic using channeling constraints. It creates an if-then-else relationship where if x is less than 5, y equals 0, otherwise y equals 10-x. The implementation uses intermediate boolean variables and half-reified constraints with the only_enforce_if method.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Link integer constraints together.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef channeling_sample_sat():\n    \"\"\"Demonstrates how to link integer constraints together.\"\"\"\n\n    # Create the CP-SAT model.\n    model = cp_model.CpModel()\n\n    # Declare our two primary variables.\n    x = model.new_int_var(0, 10, \"x\")\n    y = model.new_int_var(0, 10, \"y\")\n\n    # Declare our intermediate boolean variable.\n    b = model.new_bool_var(\"b\")\n\n    # Implement b == (x >= 5).\n    model.add(x >= 5).only_enforce_if(b)\n    model.add(x < 5).only_enforce_if(~b)\n\n    # Create our two half-reified constraints.\n    # First, b implies (y == 10 - x).\n    model.add(y == 10 - x).only_enforce_if(b)\n    # Second, not(b) implies y == 0.\n    model.add(y == 0).only_enforce_if(~b)\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy([x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE)\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([x, y, b])\n    solver.solve(model, solution_printer)\n\n\nchanneling_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Solving and Outputting Results for Secret Santa Problem\nDESCRIPTION: This snippet defines the objective function, sets up the search parameters, and solves the Secret Santa problem. It then outputs the results, including the Santa assignments and the total distance optimized.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/secret_santa2.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n  # objective\n  objective = solver.Maximize(z, 1)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(santas, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('total distances:', z.Value())\n    print('santas:', [santas[i].Value() for i in range(n)])\n    for i in range(n):\n      print('%s\\tis a Santa to %s (distance %i)' % \\\n            (persons[i],\n             persons[santas[i].Value()],\n             santa_distance[i].Value()))\n    # print 'distance:', [santa_distance[i].Value()\n    #                     for i in range(n)]\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nsingle = 0\nprint('Secret Santas without single')\nmain(single)\nprint('\\nSecret Santas with single:')\nsingle = 1\nmain(single)\n```\n\n----------------------------------------\n\nTITLE: Bin Packing Optimization in C++ using OR-Tools CP-SAT\nDESCRIPTION: Implements a bin packing problem solver using OR-Tools CP-SAT in C++. Handles multiple bins with capacity constraints and slack variables to maximize safe loading. Uses constraint programming to optimize item placement across bins while respecting capacity limits.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include <vector>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid BinpackingProblemSat() {\n  // Data.\n  const int kBinCapacity = 100;\n  const int kSlackCapacity = 20;\n  const int kNumBins = 5;\n\n  const std::vector<std::vector<int>> items = {\n      {20, 6}, {15, 6}, {30, 4}, {45, 3}};\n  const int num_items = items.size();\n\n  // Model.\n  CpModelBuilder cp_model;\n\n  // Main variables.\n  std::vector<std::vector<IntVar>> x(num_items);\n  for (int i = 0; i < num_items; ++i) {\n    const int num_copies = items[i][1];\n    for (int b = 0; b < kNumBins; ++b) {\n      x[i].push_back(cp_model.NewIntVar({0, num_copies}));\n    }\n  }\n\n  // Load variables.\n  std::vector<IntVar> load(kNumBins);\n  for (int b = 0; b < kNumBins; ++b) {\n    load[b] = cp_model.NewIntVar({0, kBinCapacity});\n  }\n\n  // Slack variables.\n  std::vector<BoolVar> slacks(kNumBins);\n  for (int b = 0; b < kNumBins; ++b) {\n    slacks[b] = cp_model.NewBoolVar();\n  }\n\n  // Links load and x.\n  for (int b = 0; b < kNumBins; ++b) {\n    LinearExpr expr;\n    for (int i = 0; i < num_items; ++i) {\n      expr += x[i][b] * items[i][0];\n    }\n    cp_model.AddEquality(expr, load[b]);\n  }\n\n  // Place all items.\n  for (int i = 0; i < num_items; ++i) {\n    cp_model.AddEquality(LinearExpr::Sum(x[i]), items[i][1]);\n  }\n\n  // Links load and slack through an equivalence relation.\n  const int safe_capacity = kBinCapacity - kSlackCapacity;\n  for (int b = 0; b < kNumBins; ++b) {\n    // slack[b] => load[b] <= safe_capacity.\n    cp_model.AddLessOrEqual(load[b], safe_capacity).OnlyEnforceIf(slacks[b]);\n    // not(slack[b]) => load[b] > safe_capacity.\n    cp_model.AddGreaterThan(load[b], safe_capacity).OnlyEnforceIf(~slacks[b]);\n  }\n\n  // Maximize sum of slacks.\n  cp_model.Maximize(LinearExpr::Sum(slacks));\n\n  // Solving part.\n  const CpSolverResponse response = Solve(cp_model.Build());\n  LOG(INFO) << CpSolverResponseStats(response);\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::BinpackingProblemSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SolutionPrinter Class\nDESCRIPTION: The SolutionPrinter class extends CpSolverSolutionCallback to provide functionality for printing intermediate solutions during the solving process. It counts solutions and displays vendor assignments.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/vendor_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self,\n        num_vendors,\n        num_hours,\n        possible_schedules,\n        selected_schedules,\n        hours_stat,\n        min_vendors,\n    ):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n        self.__num_vendors = num_vendors\n        self.__num_hours = num_hours\n        self.__possible_schedules = possible_schedules\n        self.__selected_schedules = selected_schedules\n        self.__hours_stat = hours_stat\n        self.__min_vendors = min_vendors\n\n    def on_solution_callback(self):\n        \"\"\"Called at each new solution.\"\"\"\n        self.__solution_count += 1\n        print(\"Solution %i: \", self.__solution_count)\n        print(\"  min vendors:\", self.__min_vendors)\n        for i in range(self.__num_vendors):\n            print(\n                \"  - vendor %i: \" % i,\n                self.__possible_schedules[self.value(self.__selected_schedules[i])],\n            )\n        print()\n\n        for j in range(self.__num_hours):\n            print(\"  - # workers on day%2i: \" % j, end=\" \")\n            print(self.value(self.__hours_stat[j]), end=\" \")\n            print()\n        print()\n\n    def solution_count(self):\n        \"\"\"Returns the number of solution found.\"\"\"\n        return self.__solution_count\n```\n\n----------------------------------------\n\nTITLE: Scheduling Intervals Spanning Breaks in Python with OR-Tools\nDESCRIPTION: This code demonstrates how to handle intervals that can span across breaks in a calendar using CP-SAT solver. It models a task that needs 3 hours of processing time and can potentially span across a lunch break, resulting in a total duration of 3 or 4 hours. The code uses channeling constraints to implement this feature.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrate how an interval can span across a break.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef scheduling_with_calendar_sample_sat():\n    \"\"\"Interval spanning across a lunch break.\"\"\"\n    model = cp_model.CpModel()\n\n    # The data is the following:\n    #   Work starts at 8h, ends at 18h, with a lunch break between 13h and 14h.\n    #   We need to schedule a task that needs 3 hours of processing time.\n    #   Total duration can be 3 or 4 (if it spans the lunch break).\n    #\n    # Because the duration is at least 3 hours, work cannot start after 15h.\n    # Because of the break, work cannot start at 13h.\n\n    start = model.new_int_var_from_domain(\n        cp_model.Domain.from_intervals([(8, 12), (14, 15)]), \"start\"\n    )\n    duration = model.new_int_var(3, 4, \"duration\")\n    end = model.new_int_var(8, 18, \"end\")\n    unused_interval = model.new_interval_var(start, duration, end, \"interval\")\n\n    # We have 2 states (spanning across lunch or not)\n    across = model.new_bool_var(\"across\")\n    non_spanning_hours = cp_model.Domain.from_values([8, 9, 10, 14, 15])\n    model.add_linear_expression_in_domain(start, non_spanning_hours).only_enforce_if(\n        ~across\n    )\n    model.add_linear_constraint(start, 11, 12).only_enforce_if(across)\n    model.add(duration == 3).only_enforce_if(~across)\n    model.add(duration == 4).only_enforce_if(across)\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy(\n        [start], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE\n    )\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print all solutions.\n    solution_printer = VarArraySolutionPrinter([start, duration, across])\n    solver.solve(model, solution_printer)\n\n\nscheduling_with_calendar_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Solving Safe Cracking Puzzle with OR-Tools in Python\nDESCRIPTION: This snippet defines and solves a safe cracking puzzle using Google's OR-Tools constraint programming solver. It sets up the variables, constraints, and search parameters to find valid combinations that satisfy the puzzle requirements.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/safe_cracking.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Safe cracking puzzle')\n\n  #\n  # data\n  #\n  n = 9\n  digits = list(range(1, n + 1))\n\n  #\n  # variables\n  #\n\n  LD = [solver.IntVar(digits, 'LD[%i]' % i) for i in range(n)]\n  C1, C2, C3, C4, C5, C6, C7, C8, C9 = LD\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(LD))\n\n  solver.Add(C4 - C6 == C7)\n  solver.Add(C1 * C2 * C3 == C8 + C9)\n  solver.Add(C2 + C3 + C6 < C8)\n  solver.Add(C9 < C8)\n  for i in range(n):\n    solver.Add(LD[i] != i + 1)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(LD, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n\n  while solver.NextSolution():\n    num_solutions += 1\n    print('LD:', [LD[i].Value() for i in range(n)])\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Earliness-Tardiness Cost Function in C#\nDESCRIPTION: C# implementation of a piecewise linear cost function using OR-Tools CP-SAT solver. Models earliness and tardiness costs with decision variables and constraints, including a solution printer callback class.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\nusing Google.OrTools.Util;\n\npublic class VarArraySolutionPrinter : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinter(IntVar[] variables)\n    {\n        variables_ = variables;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        {\n            foreach (IntVar v in variables_)\n            {\n                Console.Write(String.Format(\"{0}={1} \", v.ToString(), Value(v)));\n            }\n            Console.WriteLine();\n        }\n    }\n\n    private IntVar[] variables_;\n}\n\npublic class EarlinessTardinessCostSampleSat\n{\n    static void Main()\n    {\n        long earliness_date = 5;\n        long earliness_cost = 8;\n        long lateness_date = 15;\n        long lateness_cost = 12;\n\n        // Create the CP-SAT model.\n        CpModel model = new CpModel();\n\n        // Declare our primary variable.\n        IntVar x = model.NewIntVar(0, 20, \"x\");\n\n        // Create the expression variable and implement the piecewise linear\n        // function.\n        //\n        //  \\        /\n        //   \\______/\n        //   ed    ld\n        //\n        long large_constant = 1000;\n        IntVar expr = model.NewIntVar(0, large_constant, \"expr\");\n\n        // Link together expr and x through s1, s2, and s3.\n        model.AddMaxEquality(expr, new LinearExpr[] { earliness_cost * (earliness_date - x), model.NewConstant(0),\n                                                      lateness_cost * (x - lateness_date) });\n\n        // Search for x values in increasing order.\n        model.AddDecisionStrategy(new IntVar[] { x }, DecisionStrategyProto.Types.VariableSelectionStrategy.ChooseFirst,\n                                  DecisionStrategyProto.Types.DomainReductionStrategy.SelectMinValue);\n\n        // Create the solver.\n        CpSolver solver = new CpSolver();\n\n        // Force solver to follow the decision strategy exactly.\n        // Tell the solver to search for all solutions.\n        solver.StringParameters = \"search_branching:FIXED_SEARCH, enumerate_all_solutions:true\";\n\n        VarArraySolutionPrinter cb = new VarArraySolutionPrinter(new IntVar[] { x, expr });\n        solver.Solve(model, cb);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Hidato Logic Puzzle with CP-SAT\nDESCRIPTION: A complete implementation of a Hidato puzzle solver using the CP-SAT constraint programming framework. Hidato is a logic puzzle where consecutive numbers must touch each other in the grid. This code builds the constraint model, defines allowed consecutive number positions, and visualizes the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/cp_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef BuildPairs(rows, cols):\n  \"\"\"Build closeness pairs for consecutive numbers.\n\n  Build set of allowed pairs such that two consecutive numbers touch\n  each other in the grid.\n\n  Returns:\n    A list of pairs for allowed consecutive position of numbers.\n\n  Args:\n    rows: the number of rows in the grid\n    cols: the number of columns in the grid\n  \"\"\"\n  return [(x * cols + y, (x + dx) * cols + (y + dy))\n          for x in range(rows) for y in range(cols)\n          for dx in (-1, 0, 1) for dy in (-1, 0, 1)\n          if (x + dx >= 0 and x + dx < rows and\n              y + dy >= 0 and y + dy < cols and (dx != 0 or dy != 0))]\n\n\ndef BuildPuzzle(problem):\n  #\n  # models, a 0 indicates an open cell which number is not yet known.\n  #\n  #\n  puzzle = None\n  if problem == 1:\n    # Simple problem\n    puzzle = [[6, 0, 9],\n              [0, 2, 8],\n              [1, 0, 0]]\n\n  elif problem == 2:\n    puzzle = [[0, 44, 41, 0, 0, 0, 0],\n              [0, 43, 0, 28, 29, 0, 0],\n              [0, 1, 0, 0, 0, 33, 0],\n              [0, 2, 25, 4, 34, 0, 36],\n              [49, 16, 0, 23, 0, 0, 0],\n              [0, 19, 0, 0, 12, 7, 0],\n              [0, 0, 0, 14, 0, 0, 0]]\n\n  elif problem == 3:\n    # Problems from the book:\n    # Gyora Bededek: \"Hidato: 2000 Pure Logic Puzzles\"\n    # Problem 1 (Practice)\n    puzzle = [[0, 0, 20, 0, 0],\n              [0, 0, 0, 16, 18],\n              [22, 0, 15, 0, 0],\n              [23, 0, 1, 14, 11],\n              [0, 25, 0, 0, 12]]\n\n  elif problem == 4:\n    # problem 2 (Practice)\n    puzzle = [[0, 0, 0, 0, 14],\n              [0, 18, 12, 0, 0],\n              [0, 0, 17, 4, 5],\n              [0, 0, 7, 0, 0],\n              [9, 8, 25, 1, 0]]\n\n  elif problem == 5:\n    # problem 3 (Beginner)\n    puzzle = [[0, 26, 0, 0, 0, 18],\n              [0, 0, 27, 0, 0, 19],\n              [31, 23, 0, 0, 14, 0],\n              [0, 33, 8, 0, 15, 1],\n              [0, 0, 0, 5, 0, 0],\n              [35, 36, 0, 10, 0, 0]]\n  elif problem == 6:\n    # Problem 15 (Intermediate)\n    puzzle = [[64, 0, 0, 0, 0, 0, 0, 0],\n              [1, 63, 0, 59, 15, 57, 53, 0],\n              [0, 4, 0, 14, 0, 0, 0, 0],\n              [3, 0, 11, 0, 20, 19, 0, 50],\n              [0, 0, 0, 0, 22, 0, 48, 40],\n              [9, 0, 0, 32, 23, 0, 0, 41],\n              [27, 0, 0, 0, 36, 0, 46, 0],\n              [28, 30, 0, 35, 0, 0, 0, 0]]\n  return puzzle\n\n\ndef SolveHidato(puzzle, index):\n  \"\"\"Solve the given hidato table.\"\"\"\n  # Create the model.\n  model = cp_model.CpModel()\n\n  r = len(puzzle)\n  c = len(puzzle[0])\n\n  #\n  # declare variables\n  #\n  positions = [model.NewIntVar(0, r * c - 1, 'p[%i]' % i)\n               for i in range(r * c)]\n\n  #\n  # constraints\n  #\n  model.AddAllDifferent(positions)\n\n  #\n  # Fill in the clues\n  #\n  for i in range(r):\n    for j in range(c):\n      if puzzle[i][j] > 0:\n        model.Add(positions[puzzle[i][j] - 1] == i * c + j)\n\n  # Consecutive numbers must touch each other in the grid.\n  # We use an allowed assignment constraint to model it.\n  close_tuples = BuildPairs(r, c)\n  for k in range(0, r * c - 1):\n    model.AddAllowedAssignments([positions[k], positions[k + 1]], close_tuples)\n\n  #\n  # solution and search\n  #\n\n  solver = cp_model.CpSolver()\n  solver.parameters.log_search_progress = True\n  status = solver.Solve(model)\n\n  if status == cp_model.FEASIBLE or status == cp_model.OPTIMAL:\n    output = visualization.SvgWrapper(10, r, 40.0)\n    for i in range(len(positions)):\n      val = solver.Value(positions[i])\n      x = val % c\n      y = val // c\n      color = 'white' if puzzle[y][x] == 0 else 'lightgreen'\n      value = solver.Value(positions[i])\n      output.AddRectangle(x, r - y - 1, 1, 1, color, 'black', str(i + 1))\n\n    output.AddTitle('Puzzle %i solved in %f s' % (index, solver.WallTime()))\n    output.Display()\n\n\nfor i in range(1, 7):\n  SolveHidato(BuildPuzzle(i), i)\n```\n\n----------------------------------------\n\nTITLE: Solving and Displaying Results for Max Flow Problem\nDESCRIPTION: This section sets up the search parameters, solves the max flow problem, and displays the results including the maximum flow value and the flow on each arc.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/max_flow_winston1.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n  db = solver.Phase(flow_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db, [objective])\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('z:', z.Value())\n    for i in nodes:\n      for j in nodes:\n        print(flow[i, j].Value(), end=' ')\n      print()\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing If-Then-Else Channeling Constraints in C# with CP-SAT\nDESCRIPTION: This C# code demonstrates implementing channeling constraints using the CP-SAT solver. It creates a conditional relationship where y equals 10-x when x is greater than or equal to 5, and y equals 0 otherwise, using half-reified constraints via the OnlyEnforceIf method.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\nusing Google.OrTools.Util;\n\npublic class VarArraySolutionPrinter : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinter(IntVar[] variables)\n    {\n        variables_ = variables;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        {\n            foreach (IntVar v in variables_)\n            {\n                Console.Write(String.Format(\"{0}={1} \", v.ToString(), Value(v)));\n            }\n            Console.WriteLine();\n        }\n    }\n\n    private IntVar[] variables_;\n}\n\npublic class ChannelingSampleSat\n{\n    static void Main()\n    {\n        // Create the CP-SAT model.\n        CpModel model = new CpModel();\n\n        // Declare our two primary variables.\n        IntVar x = model.NewIntVar(0, 10, \"x\");\n        IntVar y = model.NewIntVar(0, 10, \"y\");\n\n        // Declare our intermediate boolean variable.\n        BoolVar b = model.NewBoolVar(\"b\");\n\n        // Implement b == (x >= 5).\n        model.Add(x >= 5).OnlyEnforceIf(b);\n        model.Add(x < 5).OnlyEnforceIf(b.Not());\n\n        // Create our two half-reified constraints.\n        // First, b implies (y == 10 - x).\n        model.Add(y == 10 - x).OnlyEnforceIf(b);\n        // Second, not(b) implies y == 0.\n        model.Add(y == 0).OnlyEnforceIf(b.Not());\n\n        // Search for x values in increasing order.\n        model.AddDecisionStrategy(new IntVar[] { x }, DecisionStrategyProto.Types.VariableSelectionStrategy.ChooseFirst,\n                                  DecisionStrategyProto.Types.DomainReductionStrategy.SelectMinValue);\n\n        // Create the solver.\n        CpSolver solver = new CpSolver();\n\n        // Force solver to follow the decision strategy exactly.\n        // Tell the solver to search for all solutions.\n        solver.StringParameters = \"search_branching:FIXED_SEARCH, enumerate_all_solutions:true\";\n\n        VarArraySolutionPrinter cb = new VarArraySolutionPrinter(new IntVar[] { x, y, b });\n        solver.Solve(model, cb);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Regular Constraint in Google CP Solver\nDESCRIPTION: This function implements the regular constraint, which ensures that a sequence of values is accepted by a given Deterministic Finite Automaton (DFA). It takes as input the variables, number of states, input maximum, transition function, initial state, and accepting states.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\ndef regular(x, Q, S, d, q0, F):\n\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    row = []\n    for j in range(S):\n      if i == 0:\n        row.append(0)\n      else:\n        row.append(d[i - 1][j])\n    d2.append(row)\n\n  d2_flatten = [d2[i][j] for i in range(Q + 1) for j in range(S)]\n\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n\n  a = [solver.IntVar(0, Q + 1, 'a[%i]' % i) for i in range(m, n + 1)]\n\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n\n    solver.Add(\n        a[i + 1] == solver.Element(d2_flatten, ((a[i]) * S) + (x[i] - 1)))\n```\n\n----------------------------------------\n\nTITLE: Implementing CP Solver with OR-Tools in C#\nDESCRIPTION: This C# code shows how to use the OR-Tools CP solver to create variables, add constraints, solve a simple problem, and print solutions. It includes advanced usage information such as solving time and memory usage.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/CP.md#2025-04-17_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing System;\nusing Google.OrTools.ConstraintSolver;\n\n/// <summary>\n///   This is a simple CP program.\n/// </summary>\npublic class SimpleCpProgram\n{\n    public static void Main(String[] args)\n    {\n        // Instantiate the solver.\n        Solver solver = new Solver(\"CpSimple\");\n\n        // Create the variables.\n        const long numVals = 3;\n        IntVar x = solver.MakeIntVar(0, numVals - 1, \"x\");\n        IntVar y = solver.MakeIntVar(0, numVals - 1, \"y\");\n        IntVar z = solver.MakeIntVar(0, numVals - 1, \"z\");\n\n        // Constraint 0: x != y..\n        solver.Add(solver.MakeAllDifferent(new IntVar[] { x, y }));\n        Console.WriteLine($\"Number of constraints: {solver.Constraints()}\");\n\n        // Solve the problem.\n        DecisionBuilder db =\n            solver.MakePhase(new IntVar[] { x, y, z }, Solver.CHOOSE_FIRST_UNBOUND, Solver.ASSIGN_MIN_VALUE);\n\n        // Print solution on console.\n        int count = 0;\n        solver.NewSearch(db);\n        while (solver.NextSolution())\n        {\n            ++count;\n            Console.WriteLine($\"Solution: {count}\\n x={x.Value()} y={y.Value()} z={z.Value()}\");\n        }\n        solver.EndSearch();\n        Console.WriteLine($\"Number of solutions found: {solver.Solutions()}\");\n\n        Console.WriteLine(\"Advanced usage:\");\n        Console.WriteLine($\"Problem solved in {solver.WallTime()}ms\");\n        Console.WriteLine($\"Memory usage: {Solver.MemoryUsage()}bytes\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reified Constraints in Java\nDESCRIPTION: Demonstrates three equivalent ways to implement a reified constraint in Java using the CP-SAT solver, including half-reified bool and, implications, and bool or constructs.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_12\n\nLANGUAGE: Java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.BoolVar;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.Literal;\n\n/**\n * Reification is the action of associating a Boolean variable to a constraint. This boolean\n * enforces or prohibits the constraint according to the value the Boolean variable is fixed to.\n *\n * <p>Half-reification is defined as a simple implication: If the Boolean variable is true, then the\n * constraint holds, instead of an complete equivalence.\n *\n * <p>The SAT solver offers half-reification. To implement full reification, two half-reified\n * constraints must be used.\n */\npublic class ReifiedSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n\n    BoolVar x = model.newBoolVar(\"x\");\n    BoolVar y = model.newBoolVar(\"y\");\n    BoolVar b = model.newBoolVar(\"b\");\n\n    // Version 1: a half-reified boolean and.\n    model.addBoolAnd(new Literal[] {x, y.not()}).onlyEnforceIf(b);\n\n    // Version 2: implications.\n    model.addImplication(b, x);\n    model.addImplication(b, y.not());\n\n    // Version 3: boolean or.\n    model.addBoolOr(new Literal[] {b.not(), x});\n    model.addBoolOr(new Literal[] {b.not(), y.not()});\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Search After N Solutions in Python with OR-Tools CP-SAT Solver\nDESCRIPTION: This Python code demonstrates how to stop the search process in OR-Tools CP-SAT solver after finding a specific number of solutions. It uses a custom solution callback class to print intermediate solutions and stop the search when the limit is reached.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample that solves a model and displays a small number of solutions.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinterWithLimit(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar], limit: int):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__solution_count = 0\n        self.__solution_limit = limit\n\n    def on_solution_callback(self) -> None:\n        self.__solution_count += 1\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n        if self.__solution_count >= self.__solution_limit:\n            print(f\"Stop search after {self.__solution_limit} solutions\")\n            self.stop_search()\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n\n\ndef stop_after_n_solutions_sample_sat():\n    \"\"\"Showcases calling the solver to search for small number of solutions.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArraySolutionPrinterWithLimit([x, y, z], 5)\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    # Solve.\n    status = solver.solve(model, solution_printer)\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n    assert solution_printer.solution_count == 5\n\n\nstop_after_n_solutions_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Skill Class for Worker and Machine Capabilities in Python\nDESCRIPTION: Defines a Skill class representing worker skills or machine capabilities with an associated efficiency value. The efficiency parameter allows modeling different performance levels for workers.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Skill:\n    \"\"\"The skill of a worker or the capability of a machine.\"\"\"\n\n    def __init__(self, name, efficiency):\n        self.name = name\n        # Efficiency is currently not used.\n        self.efficiency = efficiency\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Class for Workers and Equipment in Python\nDESCRIPTION: Defines a Resource class representing workers, machines, or spaces in the bakery. Each resource has a capacity and can have multiple skills with different efficiency levels. Workers typically have capacity 1, while machines can process multiple items simultaneously.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Resource:\n    \"\"\"A resource is a worker, a machine, or just some space for cakes to rest.\n\n    - Workers have a capacity of 1 and can have variable efficiency.\n    - Machines and spaces have a capacity greater or equal to one, but the\n      efficiency is fixed to 100.\n\n      For a worker with efficiency k and a task of duration t, the resulting\n      work will have a duration `ceil(t * k)`.\n    \"\"\"\n\n    def __init__(self, name, capacity):\n        self.name = name\n        self.capacity = capacity\n        self.skills = []\n\n    def add_skill(self, skill_name: str, efficiency: float) -> \"Resource\":\n        self.skills.append(Skill(skill_name, efficiency))\n        return self\n```\n\n----------------------------------------\n\nTITLE: Solving LP with PDLP\nDESCRIPTION: This function `main()` configures and runs the PDLP solver on the LP problem defined in `simple_lp()`. It sets solver parameters like optimality criteria, time limit, and verbosity level. It then calls `pdlp.primal_dual_hybrid_gradient` to solve the LP and prints the solution status, primal and dual solutions, reduced costs, and other relevant information about the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/pdlp/simple_pdlp_program.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main() -> None:\n    params = solvers_pb2.PrimalDualHybridGradientParams()\n    # Below are some common parameters to modify. Here, we just re-assign the\n    # defaults.\n    optimality_criteria = params.termination_criteria.simple_optimality_criteria\n    optimality_criteria.eps_optimal_relative = 1.0e-6\n    optimality_criteria.eps_optimal_absolute = 1.0e-6\n    params.termination_criteria.time_sec_limit = np.inf\n    params.num_threads = 1\n    params.verbosity_level = 0\n    params.presolve_options.use_glop = False\n\n    # Call the main solve function.\n    result = pdlp.primal_dual_hybrid_gradient(simple_lp(), params)\n    solve_log = result.solve_log\n\n    if solve_log.termination_reason == solve_log_pb2.TERMINATION_REASON_OPTIMAL:\n        print(\"Solve successful\")\n    else:\n        print(\n            \"Solve not successful. Status:\",\n            solve_log_pb2.TerminationReason.Name(solve_log.termination_reason),\n        )\n\n    # Solutions vectors are always returned. *However*, their interpretation\n    # depends on termination_reason! See primal_dual_hybrid_gradient.h for more\n    # details on what the vectors mean if termination_reason is not\n    # TERMINATION_REASON_OPTIMAL.\n    print(\"Primal solution:\", result.primal_solution)\n    print(\"Dual solution:\", result.dual_solution)\n    print(\"Reduced costs:\", result.reduced_costs)\n\n    solution_type = solve_log.solution_type\n    print(\"Solution type:\", solve_log_pb2.PointType.Name(solution_type))\n    for ci in solve_log.solution_stats.convergence_information:\n        if ci.candidate_type == solution_type:\n            print(\"Primal objective:\", ci.primal_objective)\n            print(\"Dual objective:\", ci.dual_objective)\n\n    print(\"Iterations:\", solve_log.iteration_count)\n    print(\"Solve time (sec):\", solve_log.solve_time_sec)\n```\n\n----------------------------------------\n\nTITLE: Creating State Graph for Cutting Stock Problem in Python\nDESCRIPTION: Function that builds a state graph from a multiset of items and a maximum capacity. It generates states and transitions that represent the possible ways to place items, tracking state indices for efficient lookup.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef create_state_graph(items, max_capacity):\n    \"\"\"Create a state graph from a multiset of items, and a maximum capacity.\"\"\"\n    states = []\n    state_to_index = {}\n    states.append(0)\n    state_to_index[0] = 0\n    transitions = []\n\n    for item_index, size_and_count in enumerate(items):\n        size, count = size_and_count\n        num_states = len(states)\n        for state_index in range(num_states):\n            current_state = states[state_index]\n            current_state_index = state_index\n\n            for card in range(count):\n                new_state = current_state + size * (card + 1)\n                if new_state > max_capacity:\n                    break\n                if new_state in state_to_index:\n                    new_state_index = state_to_index[new_state]\n                else:\n                    new_state_index = len(states)\n                    states.append(new_state)\n                    state_to_index[new_state] = new_state_index\n                # Add the transition\n                transitions.append(\n                    [current_state_index, new_state_index, item_index, card + 1]\n                )\n\n    return states, transitions\n```\n\n----------------------------------------\n\nTITLE: Defining Cost and Nutritional Constraints in Linear Programming\nDESCRIPTION: Establishes solver constraints to minimize total food cost while ensuring nutritional requirements are met for specified nutrients\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stigler_contrib.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsolver.Add(total_cost == days * cost)  # cost per year\n\nfor c in C:\n    solver.Add(x_cost[c] == days * x[c])\n    solver.Add(quant[c] == 100.0 * days * x[c] / data[c][0])\n\n# nutrient balance\nfor n in range(2, num_nutrients + 2):\n    solver.Add(solver.Sum([data[c][n] * x[c] for c in C]) >= allowance[n - 2])\n```\n\n----------------------------------------\n\nTITLE: Implementing Vehicle Routing in Java\nDESCRIPTION: Java implementation of a vehicle routing problem using OR-Tools. Demonstrates setting up a routing model with native library integration, defining distance calculations, and solving a simple routing scenario.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/ROUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.constraintsolver.samples;\nimport static java.lang.Math.abs;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.constraintsolver.Assignment;\nimport com.google.ortools.constraintsolver.FirstSolutionStrategy;\nimport com.google.ortools.constraintsolver.RoutingIndexManager;\nimport com.google.ortools.constraintsolver.RoutingModel;\nimport com.google.ortools.constraintsolver.RoutingSearchParameters;\nimport com.google.ortools.constraintsolver.main;\nimport java.util.logging.Logger;\n\n/** Minimal Routing example to showcase calling the solver.*/\npublic class SimpleRoutingProgram {\n  private static final Logger logger = Logger.getLogger(SimpleRoutingProgram.class.getName());\n\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Instantiate the data problem.\n    final int numLocation = 5;\n    final int numVehicles = 1;\n    final int depot = 0;\n\n    // Create Routing Index Manager\n    RoutingIndexManager manager = new RoutingIndexManager(numLocation, numVehicles, depot);\n\n    // Create Routing Model.\n    RoutingModel routing = new RoutingModel(manager);\n\n    // Create and register a transit callback.\n    final int transitCallbackIndex =\n        routing.registerTransitCallback((long fromIndex, long toIndex) -> {\n          // Convert from routing variable Index to user NodeIndex.\n          int fromNode = manager.indexToNode(fromIndex);\n          int toNode = manager.indexToNode(toIndex);\n          return abs(toNode - fromNode);\n        });\n\n    // Define cost of each arc.\n    routing.setArcCostEvaluatorOfAllVehicles(transitCallbackIndex);\n\n    // Setting first solution heuristic.\n    RoutingSearchParameters searchParameters =\n        main.defaultRoutingSearchParameters()\n            .toBuilder()\n            .setFirstSolutionStrategy(FirstSolutionStrategy.Value.PATH_CHEAPEST_ARC)\n            .build();\n\n    // Solve the problem.\n    Assignment solution = routing.solveWithParameters(searchParameters);\n\n    // Print solution on console.\n    logger.info(\"Objective: \" + solution.objectiveValue());\n    // Inspect solution.\n    long index = routing.start(0);\n    logger.info(\"Route for Vehicle 0:\");\n    long routeDistance = 0;\n    String route = \"\";\n    while (!routing.isEnd(index)) {\n      route += manager.indexToNode(index) + \" -> \";\n      long previousIndex = index;\n      index = solution.value(routing.nextVar(index));\n      routeDistance += routing.getArcCostForVehicle(previousIndex, index, 0);\n    }\n    route += manager.indexToNode(index);\n    logger.info(route);\n    logger.info(\"Distance of the route: \" + routeDistance + \"m\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function for School Scheduling with Problem Data in Python\nDESCRIPTION: The main function that defines the school scheduling problem data such as class levels, sections, subjects, curriculum, teachers, specialties, and time slots. It creates a SchoolSchedulingProblem instance with this data and uses a SchoolSchedulingSatSolver to solve it.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    # DATA\n    ## Classes\n    LEVELS = [\n        '1',\n        '2',\n        '3',\n    ]\n    SECTIONS = [\n        'A',\n        'B',\n    ]\n    SUBJECTS = [\n        'English',\n        'Math',\n        #'Science',\n        'History',\n    ]\n    CURRICULUM = {\n        ('1', 'English'): 3,\n        ('1', 'Math'): 3,\n        ('1', 'History'): 2,\n        ('2', 'English'): 4,\n        ('2', 'Math'): 2,\n        ('2', 'History'): 2,\n        ('3', 'English'): 2,\n        ('3', 'Math'): 4,\n        ('3', 'History'): 2,\n    }\n\n    ## Teachers\n    TEACHERS = { # name, max_work_hours\n        'Mario': 14,\n        'Elvis': 12,\n        'Harry': 12,\n        'Ian': 14,\n    }\n    # Subject -> List of teachers who can teach it\n    SPECIALTIES = {\n        'English': ['Elvis', 'Ian'],\n        'Math': ['Mario', 'Ian'],\n        'History': ['Harry', 'Ian'],\n    }\n\n    ## Schedule\n    TIME_SLOTS = {\n            'Monday:08:00-09:30': 1.5,\n            'Monday:09:45-11:15': 1.5,\n            'Monday:11:30-12:30': 1,\n            'Monday:13:30-15:30': 2,\n            'Monday:15:45-17:15': 1.5,\n            'Tuesday:08:00-09:30': 1.5,\n            'Tuesday:09:45-11:15': 1.5,\n            'Tuesday:11:30-12:30': 1,\n            'Tuesday:13:30-15:30': 2,\n            'Tuesday:15:45-17:15': 1.5,\n            'Wednesday:08:00-09:30': 1.5,\n            'Wednesday:09:45-11:15': 1.5,\n            'Wednesday:11:30-12:30': 1,\n            'Thursday:08:00-09:30': 1.5,\n            'Thursday:09:45-11:15': 1.5,\n            'Thursday:11:30-12:30': 1,\n            'Thursday:13:30-15:30': 2,\n            'Thursday:15:45-17:15': 1.5,\n            'Friday:08:00-09:30': 1.5,\n            'Friday:09:45-11:15': 1.5,\n            'Friday:11:30-12:30': 1,\n            'Friday:13:30-15:30': 2,\n            'Friday:15:45-17:15': 1.5,\n            }\n\n    problem = SchoolSchedulingProblem(LEVELS, SECTIONS, SUBJECTS, CURRICULUM,\n                                      TEACHERS, SPECIALTIES, TIME_SLOTS)\n    solver = SchoolSchedulingSatSolver(problem)\n    solver.solve()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Rabbits and Pheasants Problem in C#\nDESCRIPTION: C# implementation of the Rabbits and Pheasants puzzle using CP-SAT solver. Demonstrates integer variable creation and constraint addition using C# syntax.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class RabbitsAndPheasantsSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n        // Creates the variables.\n        IntVar r = model.NewIntVar(0, 100, \"r\");\n        IntVar p = model.NewIntVar(0, 100, \"p\");\n        // 20 heads.\n        model.Add(r + p == 20);\n        // 56 legs.\n        model.Add(4 * r + 2 * p == 56);\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        CpSolverStatus status = solver.Solve(model);\n\n        if (status == CpSolverStatus.Optimal)\n        {\n            Console.WriteLine(solver.Value(r) + \" rabbits, and \" + solver.Value(p) + \" pheasants\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for VRP\nDESCRIPTION: Defines a function to create a data model containing the distance matrix, number of vehicles, and depot location for the VRP.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n```\n\n----------------------------------------\n\nTITLE: Implementing Earliness-Tardiness Cost Function in Java using OR-Tools\nDESCRIPTION: Java implementation of the earliness-tardiness cost function using OR-Tools CP-SAT solver. Demonstrates piecewise linear optimization for delivery scheduling.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.DecisionStrategyProto;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\nimport com.google.ortools.sat.SatParameters;\n\n/** Encode the piecewise linear expression. */\npublic class EarlinessTardinessCostSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    long earlinessDate = 5;\n    long earlinessCost = 8;\n    long latenessDate = 15;\n    long latenessCost = 12;\n\n    // Create the CP-SAT model.\n    CpModel model = new CpModel();\n\n    // Declare our primary variable.\n    IntVar x = model.newIntVar(0, 20, \"x\");\n\n    // Create the expression variable and implement the piecewise linear function.\n    //\n    //  \\        /\n    //   \\______/\n    //   ed    ld\n    //\n    long largeConstant = 1000;\n    IntVar expr = model.newIntVar(0, largeConstant, \"expr\");\n\n    // Link together expr and the 3 segment.\n    // First segment: y == earlinessCost * (earlinessDate - x).\n    // Second segment: y = 0\n    // Third segment: y == latenessCost * (x - latenessDate).\n    model.addMaxEquality(expr,\n        new LinearExpr[] {LinearExpr.newBuilder()\n                              .addTerm(x, -earlinessCost)\n                              .add(earlinessCost * earlinessDate)\n                              .build(),\n            LinearExpr.constant(0),\n            LinearExpr.newBuilder()\n                .addTerm(x, latenessCost)\n                .add(-latenessCost * latenessDate)\n                .build()});\n\n    // Search for x values in increasing order.\n    model.addDecisionStrategy(new IntVar[] {x},\n        DecisionStrategyProto.VariableSelectionStrategy.CHOOSE_FIRST,\n        DecisionStrategyProto.DomainReductionStrategy.SELECT_MIN_VALUE);\n\n    // Create the solver.\n    CpSolver solver = new CpSolver();\n\n    // Force the solver to follow the decision strategy exactly.\n    solver.getParameters().setSearchBranching(SatParameters.SearchBranching.FIXED_SEARCH);\n    // Tell the solver to enumerate all solutions.\n    solver.getParameters().setEnumerateAllSolutions(true);\n\n    // Solve the problem with the printer callback.\n    CpSolverStatus unusedStatus = solver.solve(model, new CpSolverSolutionCallback() {\n      public CpSolverSolutionCallback init(IntVar[] variables) {\n        variableArray = variables;\n        return this;\n      }\n\n      @Override\n      public void onSolutionCallback() {\n        for (IntVar v : variableArray) {\n          System.out.printf(\"%s=%d \", v.getName(), value(v));\n        }\n        System.out.println();\n      }\n\n      private IntVar[] variableArray;\n    }.init(new IntVar[] {x, expr}));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Problem Data for Stigler's Diet Optimization\nDESCRIPTION: This section defines the core data for the diet problem, including the number of commodities, nutrients, and their respective details. It sets up the problem's parameters essential for the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stigler_contrib.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n  #\n  # data\n  #\n  # commodities\n  num_commodities = 77\n  C = list(range(num_commodities))\n\n  #  days in a year\n  days = 365.25\n\n  # nutrients\n  num_nutrients = 9\n  N = list(range(num_nutrients))\n\n  nutrients = [\n      \"calories\",  # Calories, unit = 1000\n      \"protein\",  # Protein, unit = grams\n      \"calcium\",  # Calcium, unit = grams\n      \"iron\",  # Iron, unit = milligrams\n      \"vitaminA\",  # Vitamin A, unit = 1000 International Units\n      \"thiamine\",  # Thiamine, Vit. B1, unit = milligrams\n      \"riboflavin\",  # Riboflavin, Vit. B2, unit = milligrams\n      \"niacin\",  # Niacin (Nicotinic Acid), unit = milligrams\n      \"ascorbicAcid\"  # Ascorbic Acid, Vit. C, unit = milligrams\n  ]\n\n  commodities = [[\"Wheat Flour (Enriched)\", \"10 lb.\"], [\"Macaroni\", \"1 lb.\"],\n                 [\"Wheat Cereal (Enriched)\",\n                  \"28 oz.\"], [\"Corn Flakes\", \"8 oz.\"], [\"Corn Meal\", \"1 lb.\"],\n                 [\"Hominy Grits\", \"24 oz.\"], [\"Rice\", \"1 lb.\"],\n                 [\"Rolled Oats\", \"1 lb.\"], [\"White Bread (Enriched)\", \"1 lb.\"],\n                 [\"Whole Wheat Bread\", \"1 lb.\"], [\"Rye Bread\", \"1 lb.\"],\n                 [\"Pound Cake\", \"1 lb.\"], [\"Soda Crackers\", \"1 lb.\"],\n                 [\"Milk\", \"1 qt.\"], [\"Evaporated Milk (can)\", \"14.5 oz.\"],\n                 [\"Butter\", \"1 lb.\"], [\"Oleomargarine\", \"1 lb.\"],\n                 [\"Eggs\", \"1 doz.\"], [\"Cheese (Cheddar)\", \"1 lb.\"],\n                 [\"Cream\", \"1/2 pt.\"], [\"Peanut Butter\", \"1 lb.\"],\n                 [\"Mayonnaise\", \"1/2 pt.\"], [\"Crisco\", \"1 lb.\"],\n                 [\"Lard\", \"1 lb.\"], [\"Sirloin Steak\", \"1 lb.\"],\n                 [\"Round Steak\", \"1 lb.\"], [\"Rib Roast\", \"1 lb.\"],\n                 [\"Chuck Roast\", \"1 lb.\"], [\"Plate\", \"1 lb.\"],\n                 [\"Liver (Beef)\", \"1 lb.\"], [\"Leg of Lamb\", \"1 lb.\"],\n                 [\"Lamb Chops (Rib)\", \"1 lb.\"], [\"Pork Chops\", \"1 lb.\"],\n                 [\"Pork Loin Roast\", \"1 lb.\"], [\"Bacon\", \"1 lb.\"],\n                 [\"Ham - smoked\", \"1 lb.\"], [\"Salt Pork\", \"1 lb.\"],\n                 [\"Roasting Chicken\", \"1 lb.\"], [\"Veal Cutlets\", \"1 lb.\"],\n                 [\"Salmon, Pink (can)\", \"16 oz.\"], [\"Apples\", \"1 lb.\"],\n                 [\"Bananas\", \"1 lb.\"], [\"Lemons\", \"1 doz.\"],\n                 [\"Oranges\", \"1 doz.\"], [\"Green Beans\", \"1 lb.\"],\n                 [\"Cabbage\", \"1 lb.\"], [\"Carrots\", \"1 bunch\"],\n                 [\"Celery\", \"1 stalk\"], [\"Lettuce\", \"1 head\"],\n                 [\"Onions\", \"1 lb.\"], [\"Potatoes\", \"15 lb.\"],\n                 [\"Spinach\", \"1 lb.\"], [\"Sweet Potatoes\", \"1 lb.\"],\n                 [\"Peaches (can)\", \"No. 2 1/2\"], [\"Pears (can)\", \"No. 2 1/2,\"],\n                 [\"Pineapple (can)\", \"No. 2 1/2\"], [\"Asparagus (can)\", \"No. 2\"],\n                 [\"Grean Beans (can)\", \"No. 2\"],\n                 [\"Pork and Beans (can)\", \"16 oz.\"], [\"Corn (can)\", \"No. 2\"],\n                 [\"Peas (can)\", \"No. 2\"], [\"Tomatoes (can)\", \"No. 2\"],\n                 [\"Tomato Soup (can)\", \"10 1/2 oz.\"],\n                 [\"Peaches, Dried\", \"1 lb.\"], [\"Prunes, Dried\", \"1 lb.\"],\n                 [\"Raisins, Dried\", \"15 oz.\"], [\"Peas, Dried\", \"1 lb.\"],\n                 [\"Lima Beans, Dried\", \"1 lb.\"], [\"Navy Beans, Dried\", \"1 lb.\"],\n                 [\"Coffee\", \"1 lb.\"], [\"Tea\", \"1/4 lb.\"], [\"Cocoa\", \"8 oz.\"],\n                 [\"Chocolate\", \"8 oz.\"], [\"Sugar\", \"10 lb.\"],\n                 [\"Corn Sirup\", \"24 oz.\"], [\"Molasses\", \"18 oz.\"],\n                 [\"Strawberry Preserve\", \"1 lb.\"]]\n\n  # price and weight are the two first columns\n  data = [\n      [36.0, 12600.0, 44.7, 1411.0, 2.0, 365.0, 0.0, 55.4, 33.3, 441.0, 0.0],\n      [14.1, 3217.0, 11.6, 418.0, 0.7, 54.0, 0.0, 3.2, 1.9, 68.0, 0.0],\n      [24.2, 3280.0, 11.8, 377.0, 14.4, 175.0, 0.0, 14.4, 8.8, 114.0, 0.0],\n      [7.1, 3194.0, 11.4, 252.0, 0.1, 56.0, 0.0, 13.5, 2.3, 68.0, 0.0],\n      [4.6, 9861.0, 36.0, 897.0, 1.7, 99.0, 30.9, 17.4, 7.9, 106.0, 0.0],\n      [8.5, 8005.0, 28.6, 680.0, 0.8, 80.0, 0.0, 10.6, 1.6, 110.0, 0.0],\n      [7.5, 6048.0, 21.2, 460.0, 0.6, 41.0, 0.0, 2.0, 4.8, 60.0, 0.0],\n      [7.1, 6389.0, 25.3, 907.0, 5.1, 341.0, 0.0, 37.1, 8.9, 64.0, 0.0],\n      [7.9, 5742.0, 15.6, 488.0, 2.5, 115.0, 0.0, 13.8, 8.5, 126.0, 0.0],\n      [9.1, 4985.0, 12.2, 484.0, 2.7, 125.0, 0.0, 13.9, 6.4, 160.0, 0.0],\n      [9.2, 4930.0, 12.4, 439.0, 1.1, 82.0, 0.0, 9.9, 3.0, 66.0, 0.0],\n      [24.8, 1829.0, 8.0, 130.0, 0.4, 31.0, 18.9, 2.8, 3.0, 17.0, 0.0]\n```\n\n----------------------------------------\n\nTITLE: Creating Interval Variables in C# with CP-SAT Solver\nDESCRIPTION: This C# code demonstrates how to create different types of interval variables using the CP-SAT solver. It shows creating an interval from start, size, and end expressions; creating a fixed-size interval from a start expression and size; and creating a completely fixed interval with specific start and size values.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class IntervalSampleSat\n{\n    static void Main()\n    {\n        CpModel model = new CpModel();\n        int horizon = 100;\n\n        // C# code supports constant of affine expressions.\n        IntVar start_var = model.NewIntVar(0, horizon, \"start\");\n        IntVar end_var = model.NewIntVar(0, horizon, \"end\");\n        IntervalVar interval = model.NewIntervalVar(start_var, 10, end_var + 2, \"interval\");\n        Console.WriteLine(interval);\n\n        // If the size is fixed, a simpler version uses the start expression, the size and the\n        // literal.\n        IntervalVar fixedSizeIntervalVar = model.NewFixedSizeIntervalVar(start_var, 10, \"fixed_size_interval_var\");\n        Console.WriteLine(fixedSizeIntervalVar);\n\n        // A fixed interval can be created using the same API.\n        IntervalVar fixedInterval = model.NewFixedSizeIntervalVar(5, 10, \"fixed_interval\");\n        Console.WriteLine(fixedInterval);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Marathon Puzzle Solution with Google CP Solver\nDESCRIPTION: Defines the main function that sets up and solves the Marathon puzzle using Google's CP Solver. It includes variable declarations, constraint definitions, and the search for solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/marathon2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Marathon')\n\n  #\n  # data\n  #\n  n = 6\n\n  runners_str = [\n      'Dominique', 'Ignace', 'Naren', 'Olivier', 'Philippe', 'Pascal'\n  ]\n\n  #\n  # declare variables\n  #\n  runners = [solver.IntVar(1, n, 'runners[%i]' % i) for i in range(n)]\n  Dominique, Ignace, Naren, Olivier, Philippe, Pascal = runners\n\n  #\n  # constraints\n  #\n  solver.Add(solver.AllDifferent(runners))\n\n  # a: Olivier not last\n  solver.Add(Olivier != n)\n\n  # b: Dominique, Pascal and Ignace before Naren and Olivier\n  solver.Add(Dominique < Naren)\n  solver.Add(Dominique < Olivier)\n  solver.Add(Pascal < Naren)\n  solver.Add(Pascal < Olivier)\n  solver.Add(Ignace < Naren)\n  solver.Add(Ignace < Olivier)\n\n  # c: Dominique better than third\n  solver.Add(Dominique < 3)\n\n  # d: Philippe is among the first four\n  solver.Add(Philippe <= 4)\n\n  # e: Ignace neither second nor third\n  solver.Add(Ignace != 2)\n  solver.Add(Ignace != 3)\n\n  # f: Pascal three places earlier than Naren\n  solver.Add(Pascal + 3 == Naren)\n\n  # g: Neither Ignace nor Dominique on fourth position\n  solver.Add(Ignace != 4)\n  solver.Add(Dominique != 4)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(runners, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    runners_val = [runners[i].Value() for i in range(n)]\n    print('runners:', runners_val)\n    print('Places:')\n    for i in range(1, n + 1):\n      for j in range(n):\n        if runners_val[j] == i:\n          print('%i: %s' % (i, runners_str[j]))\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Linear Programming with OR-Tools C++ Style API\nDESCRIPTION: Implements the same linear programming problem as in the natural language example, but using OR-Tools' C++ style API. This approach explicitly sets coefficients for constraints and the objective function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_programming.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef RunLinearExampleCppStyleAPI(optimization_problem_type):\n    \"\"\"Example of simple linear program with the C++ style API.\"\"\"\n    solver = pywraplp.Solver.CreateSolver(optimization_problem_type)\n    if not solver:\n        return\n\n    Announce(optimization_problem_type, \"C++ style API\")\n\n    infinity = solver.infinity()\n    # x1, x2 and x3 are continuous non-negative variables.\n    x1 = solver.NumVar(0.0, infinity, \"x1\")\n    x2 = solver.NumVar(0.0, infinity, \"x2\")\n    x3 = solver.NumVar(0.0, infinity, \"x3\")\n\n    # Maximize 10 * x1 + 6 * x2 + 4 * x3.\n    objective = solver.Objective()\n    objective.SetCoefficient(x1, 10)\n    objective.SetCoefficient(x2, 6)\n    objective.SetCoefficient(x3, 4)\n    objective.SetMaximization()\n\n    # x1 + x2 + x3 <= 100.\n    c0 = solver.Constraint(-infinity, 100.0, \"c0\")\n    c0.SetCoefficient(x1, 1)\n    c0.SetCoefficient(x2, 1)\n    c0.SetCoefficient(x3, 1)\n\n    # 10 * x1 + 4 * x2 + 5 * x3 <= 600.\n    c1 = solver.Constraint(-infinity, 600.0, \"c1\")\n    c1.SetCoefficient(x1, 10)\n    c1.SetCoefficient(x2, 4)\n    c1.SetCoefficient(x3, 5)\n\n    # 2 * x1 + 2 * x2 + 6 * x3 <= 300.\n    c2 = solver.Constraint(-infinity, 300.0, \"c2\")\n    c2.SetCoefficient(x1, 2)\n    c2.SetCoefficient(x2, 2)\n    c2.SetCoefficient(x3, 6)\n\n    SolveAndPrint(\n        solver, [x1, x2, x3], [c0, c1, c2], optimization_problem_type != \"PDLP\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Reified Constraints in Python\nDESCRIPTION: Demonstrates three equivalent ways to implement a reified constraint in Python using the CP-SAT solver, including half-reified bool and, implications, and bool or constructs.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Simple model with a reified constraint.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef reified_sample_sat():\n    \"\"\"Showcase creating a reified constraint.\"\"\"\n    model = cp_model.CpModel()\n\n    x = model.new_bool_var(\"x\")\n    y = model.new_bool_var(\"y\")\n    b = model.new_bool_var(\"b\")\n\n    # First version using a half-reified bool and.\n    model.add_bool_and(x, ~y).only_enforce_if(b)\n\n    # Second version using implications.\n    model.add_implication(b, x)\n    model.add_implication(b, ~y)\n\n    # Third version using bool or.\n    model.add_bool_or(~b, x)\n    model.add_bool_or(~b, ~y)\n\n\nreified_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Lectures Problem Solver\nDESCRIPTION: Defines the main function that sets up and solves the Lectures scheduling problem using Google's CP Solver. It creates variables, defines constraints, and searches for an optimal solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/lectures.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Lectures')\n\n  #\n  # data\n  #\n\n  #\n  # The schedule requirements:\n  # lecture a cannot be held at the same time as b\n  # Note: 1-based\n  g = [[1, 2], [1, 4], [3, 5], [2, 6], [4, 5], [5, 6], [1, 6]]\n\n  # number of nodes\n  n = 6\n\n  # number of edges\n  edges = len(g)\n\n  #\n  # declare variables\n  #\n  v = [solver.IntVar(0, n - 1, 'v[%i]' % i) for i in range(n)]\n\n  # maximum color, to minimize\n  # Note: since Python is 0-based, the\n  # number of colors is +1\n  max_c = solver.IntVar(0, n - 1, 'max_c')\n\n  #\n  # constraints\n  #\n  solver.Add(max_c == solver.Max(v))\n\n  # ensure that there are no clashes\n  # also, adjust to 0-base\n  for i in range(edges):\n    solver.Add(v[g[i][0] - 1] != v[g[i][1] - 1])\n\n  # symmetry breaking:\n  # - v0 has the color 0,\n  # - v1 has either color 0 or 1\n  solver.Add(v[0] == 0)\n  solver.Add(v[1] <= 1)\n\n  # objective\n  objective = solver.Minimize(max_c, 1)\n\n  #\n  # solution and search\n  #\n  db = solver.Phase(v, solver.CHOOSE_MIN_SIZE_LOWEST_MIN,\n                    solver.ASSIGN_CENTER_VALUE)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('max_c:', max_c.Value() + 1, 'colors')\n    print('v:', [v[i].Value() for i in range(n)])\n    print()\n\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Defining Main Function for Coins Grid Problem in Python\nDESCRIPTION: Implements the main function that sets up the constraint satisfaction problem, defines the variables and constraints, and solves the problem using the CP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins_grid.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef main(n, c):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Coins grid\")\n  # data\n\n  print(\"n: \", n)\n  print(\"c: \", c)\n\n  # declare variables\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.BoolVar(\"x %i %i\" % (i, j))\n\n  #\n  # constraints\n  #\n\n  # sum rows/columns == c\n  for i in range(n):\n    solver.Add(solver.SumEquality([x[(i, j)] for j in range(n)], c))  # sum rows\n    solver.Add(solver.SumEquality([x[(j, i)] for j in range(n)], c))  # sum cols\n\n  # quadratic horizonal distance var\n  objective_var = solver.Sum(\n      [x[(i, j)] * (i - j) * (i - j) for i in range(n) for j in range(n)])\n\n  # objective\n  objective = solver.Minimize(objective_var, 1)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[(i, j)] for i in range(n) for j in range(n)])\n  solution.AddObjective(objective_var)\n\n  # last solutions\n  collector = solver.LastSolutionCollector(solution)\n  search_log = solver.SearchLog(1000000, objective_var)\n  restart = solver.ConstantRestart(300)\n  solver.Solve(\n      solver.Phase([x[(i, j)] for i in range(n) for j in range(n)],\n                   solver.CHOOSE_RANDOM, solver.ASSIGN_MAX_VALUE),\n      [collector, search_log, objective])\n\n  print(\"objective:\", collector.ObjectiveValue(0))\n  for i in range(n):\n    for j in range(n):\n      print(collector.Value(0, x[(i, j)]), end=\" \")\n    print()\n  print()\n\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n```\n\n----------------------------------------\n\nTITLE: Converting Between Number and Array Representation\nDESCRIPTION: Defines a helper function 'toNum' that converts between a number and its array representation in a specific base, used in the de Bruijn sequence generation process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/debruijn_binary.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef toNum(solver, t, s, base):\n  tlen = len(t)\n  solver.Add(\n      s == solver.Sum([(base**(tlen - i - 1)) * t[i] for i in range(tlen)]))\n```\n\n----------------------------------------\n\nTITLE: Strimko Puzzle Solver Implementation\nDESCRIPTION: Main implementation of the Strimko puzzle solver using OR-Tools. The solver ensures numbers 1 to n appear exactly once in each row, column, and defined stream. Includes problem definition, constraint setup, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/strimko2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(streams='', placed=''):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Strimko')\n\n  #\n  # default problem\n  #\n  if streams == '':\n    streams = [[1, 1, 2, 2, 2, 2, 2], [1, 1, 2, 3, 3, 3, 2],\n               [1, 4, 1, 3, 3, 5, 5], [4, 4, 3, 1, 3, 5, 5],\n               [4, 6, 6, 6, 7, 7, 5], [6, 4, 6, 4, 5, 5, 7],\n               [6, 6, 4, 7, 7, 7, 7]]\n\n    # Note: This is 1-based\n    placed = [[2, 1, 1], [2, 3, 7], [2, 5, 6], [2, 7, 4], [3, 2, 7], [3, 6, 1],\n              [4, 1, 4], [4, 7, 5], [5, 2, 2], [5, 6, 6]]\n\n  n = len(streams)\n  num_placed = len(placed)\n\n  print('n:', n)\n\n  #\n  # variables\n  #\n\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[i, j] = solver.IntVar(1, n, 'x[%i,%i]' % (i, j))\n\n  x_flat = [x[i, j] for i in range(n) for j in range(n)]\n\n  #\n  # constraints\n  #\n\n  # all rows and columns must be unique, i.e. a Latin Square\n  for i in range(n):\n    row = [x[i, j] for j in range(n)]\n    solver.Add(solver.AllDifferent(row))\n\n    col = [x[j, i] for j in range(n)]\n    solver.Add(solver.AllDifferent(col))\n\n  #\n  # streams\n  #\n  for s in range(1, n + 1):\n    tmp = [x[i, j] for i in range(n) for j in range(n) if streams[i][j] == s]\n    solver.Add(solver.AllDifferent(tmp))\n\n  #\n  # placed\n  #\n  for i in range(num_placed):\n    # note: also adjust to 0-based\n    solver.Add(x[placed[i][0] - 1, placed[i][1] - 1] == placed[i][2])\n\n  #\n  # search and solution\n  #\n  db = solver.Phase(x_flat, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db)\n\n  num_solutions = 0\n  while solver.NextSolution():\n    for i in range(n):\n      for j in range(n):\n        print(x[i, j].Value(), end=' ')\n      print()\n\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nif len(sys.argv) > 1:\n  problem_file = sys.argv[1]\n  exec(compile(open(problem_file).read(), problem_file, 'exec'))\n  main(streams, placed)\nelse:\n  main()\n```\n\n----------------------------------------\n\nTITLE: Printing Job Shop Scheduling Solution in Python\nDESCRIPTION: This snippet prints the solution of the job shop scheduling problem if a feasible or optimal solution is found. It outputs the start time, duration, machine assignment, and rank for each task in each job.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n#----------------------------------------------------------------------------\n  # Print solution.\n  if status == cp_model.FEASIBLE or status == cp_model.OPTIMAL:\n    for job_id in all_jobs:\n      for task_id in range(len(jobs[job_id])):\n        start_value = solver.Value(job_starts[(job_id, task_id)])\n        machine = 0\n        duration = 0\n        select = 0\n        rank = -1\n\n        for alt_id in range(len(jobs[job_id][task_id])):\n          if jobs[job_id][task_id][alt_id][0] == -1:\n            continue\n\n          if solver.BooleanValue(job_presences[(job_id, task_id, alt_id)]):\n            duration = jobs[job_id][task_id][alt_id][0]\n            machine = jobs[job_id][task_id][alt_id][1]\n            select = alt_id\n            rank = solver.Value(job_ranks[(job_id, task_id, alt_id)])\n\n        print(\n            '  Job %i starts at %i (alt %i, duration %i) with rank %i on machine %i'\n            % (job_id, start_value, select, duration, rank, machine))\n\n    print('Solve status: %s' % solver.StatusName(status))\n    print('Objective value: %i' % solver.ObjectiveValue())\n    print('Makespan: %i' % solver.Value(makespan))\n\n\nmain(PARSER.parse_args())\n```\n\n----------------------------------------\n\nTITLE: Executing 3 Jugs MIP Solver with Command-line Argument\nDESCRIPTION: Sets up the solver type (CBC or GLPK) based on command-line argument and calls the main function to solve the 3 jugs problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_mip.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints to Shift Scheduling Model in Python\nDESCRIPTION: This snippet adds various constraints to the shift scheduling model, including exactly one shift per day, fixed assignments, employee requests, shift constraints, weekly sum constraints, penalized transitions, and cover constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/shift_scheduling_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Exactly one shift per day.\nfor e in range(num_employees):\n    for d in range(num_days):\n        model.add_exactly_one(work[e, s, d] for s in range(num_shifts))\n\n# Fixed assignments.\nfor e, s, d in fixed_assignments:\n    model.add(work[e, s, d] == 1)\n\n# Employee requests\nfor e, s, d, w in requests:\n    obj_bool_vars.append(work[e, s, d])\n    obj_bool_coeffs.append(w)\n\n# Shift constraints\nfor ct in shift_constraints:\n    shift, hard_min, soft_min, min_cost, soft_max, hard_max, max_cost = ct\n    for e in range(num_employees):\n        works = [work[e, shift, d] for d in range(num_days)]\n        variables, coeffs = add_soft_sequence_constraint(\n            model,\n            works,\n            hard_min,\n            soft_min,\n            min_cost,\n            soft_max,\n            hard_max,\n            max_cost,\n            f\"shift_constraint(employee {e}, shift {shift})\",\n        )\n        obj_bool_vars.extend(variables)\n        obj_bool_coeffs.extend(coeffs)\n\n# Weekly sum constraints\nfor ct in weekly_sum_constraints:\n    shift, hard_min, soft_min, min_cost, soft_max, hard_max, max_cost = ct\n    for e in range(num_employees):\n        for w in range(num_weeks):\n            works = [work[e, shift, d + w * 7] for d in range(7)]\n            variables, coeffs = add_soft_sum_constraint(\n                model,\n                works,\n                hard_min,\n                soft_min,\n                min_cost,\n                soft_max,\n                hard_max,\n                max_cost,\n                f\"weekly_sum_constraint(employee {e}, shift {shift}, week {w})\",\n            )\n            obj_int_vars.extend(variables)\n            obj_int_coeffs.extend(coeffs)\n\n# Penalized transitions\nfor previous_shift, next_shift, cost in penalized_transitions:\n    for e in range(num_employees):\n        for d in range(num_days - 1):\n            transition = [\n                ~work[e, previous_shift, d],\n                ~work[e, next_shift, d + 1],\n            ]\n            if cost == 0:\n                model.add_bool_or(transition)\n            else:\n                trans_var = model.new_bool_var(\n                    f\"transition (employee={e}, day={d})\"\n                )\n                transition.append(trans_var)\n                model.add_bool_or(transition)\n                obj_bool_vars.append(trans_var)\n                obj_bool_coeffs.append(cost)\n\n# Cover constraints\nfor s in range(1, num_shifts):\n    for w in range(num_weeks):\n        for d in range(7):\n            works = [work[e, s, w * 7 + d] for e in range(num_employees)]\n            # Ignore Off shift.\n            min_demand = weekly_cover_demands[d][s - 1]\n            worked = model.new_int_var(min_demand, num_employees, \"\")\n            model.add(worked == sum(works))\n            over_penalty = excess_cover_penalties[s - 1]\n            if over_penalty > 0:\n                name = f\"excess_demand(shift={s}, week={w}, day={d})\"\n                excess = model.new_int_var(0, num_employees - min_demand, name)\n                model.add(excess == worked - min_demand)\n                obj_int_vars.append(excess)\n                obj_int_coeffs.append(over_penalty)\n```\n\n----------------------------------------\n\nTITLE: Main Function for Bakery Scheduling Application in Python\nDESCRIPTION: Main function that sets up the bakery scheduling problem data and calls the CP-SAT solver to find an optimal schedule. It handles command-line arguments and orchestrates the overall execution flow.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n\n    recipes, resources, orders = set_up_data()\n    solve_with_cp_sat(recipes, resources, orders)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for VRP in Python\nDESCRIPTION: Defines a function to create a data model containing distance matrix, number of vehicles, and start/end points for the VRP.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_starts_ends.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"starts\"] = [1, 2, 15, 16]\n    data[\"ends\"] = [0, 0, 0, 0]\n    return data\n```\n\n----------------------------------------\n\nTITLE: Defining Magic Square Solver Function\nDESCRIPTION: Defines the main function to solve the magic square problem using integer programming. It sets up the solver, defines variables and constraints, and solves the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square_mip.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(n=3, sol='CBC', use_output_matrix=0):\n  # Create the solver.\n  print('Solver: ', sol)\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  #\n  # data\n  #\n  print('n = ', n)\n\n  # range_n = range(1, n+1)\n  range_n = list(range(0, n))\n\n  N = n * n\n  range_N = list(range(1, N + 1))\n\n  #\n  # variables\n  #\n\n  # x[i,j,k] = 1 means that cell (i,j) contains integer k\n  x = {}\n  for i in range_n:\n    for j in range_n:\n      for k in range_N:\n        x[i, j, k] = solver.IntVar(0, 1, 'x[%i,%i,%i]' % (i, j, k))\n\n  # For output. Much slower....\n  if use_output_matrix == 1:\n    print('Using an output matrix')\n    square = {}\n    for i in range_n:\n      for j in range_n:\n        square[i, j] = solver.IntVar(1, n * n, 'square[%i,%i]' % (i, j))\n\n  # the magic sum\n  s = solver.IntVar(1, n * n * n, 's')\n\n  #\n  # constraints\n  #\n\n  # each cell must be assigned exactly one integer\n  for i in range_n:\n    for j in range_n:\n      solver.Add(solver.Sum([x[i, j, k] for k in range_N]) == 1)\n\n  # each integer must be assigned exactly to one cell\n  for k in range_N:\n    solver.Add(solver.Sum([x[i, j, k] for i in range_n for j in range_n]) == 1)\n\n  # # the sum in each row must be the magic sum\n  for i in range_n:\n    solver.Add(\n        solver.Sum([k * x[i, j, k] for j in range_n for k in range_N]) == s)\n\n  # # the sum in each column must be the magic sum\n  for j in range_n:\n    solver.Add(\n        solver.Sum([k * x[i, j, k] for i in range_n for k in range_N]) == s)\n\n  # # the sum in the diagonal must be the magic sum\n  solver.Add(\n      solver.Sum([k * x[i, i, k] for i in range_n for k in range_N]) == s)\n\n  # # the sum in the co-diagonal must be the magic sum\n  if range_n[0] == 1:\n    # for range_n = 1..n\n    solver.Add(\n        solver.Sum([k * x[i, n - i + 1, k]\n                    for i in range_n\n                    for k in range_N]) == s)\n  else:\n    # for range_n = 0..n-1\n    solver.Add(\n        solver.Sum([k * x[i, n - i - 1, k]\n                    for i in range_n\n                    for k in range_N]) == s)\n\n  # for output\n  if use_output_matrix == 1:\n    for i in range_n:\n      for j in range_n:\n        solver.Add(\n            square[i, j] == solver.Sum([k * x[i, j, k] for k in range_N]))\n\n  #\n  # solution and search\n  #\n  solver.Solve()\n\n  print()\n\n  print('s: ', int(s.SolutionValue()))\n  if use_output_matrix == 1:\n    for i in range_n:\n      for j in range_n:\n        print(int(square[i, j].SolutionValue()), end=' ')\n      print()\n    print()\n  else:\n    for i in range_n:\n      for j in range_n:\n        print(\n            sum([int(k * x[i, j, k].SolutionValue()) for k in range_N]),\n            ' ',\n            end=' ')\n      print()\n\n  print('\\nx:')\n  for i in range_n:\n    for j in range_n:\n      for k in range_N:\n        print(int(x[i, j, k].SolutionValue()), end=' ')\n      print()\n\n  print()\n  print('walltime  :', solver.WallTime(), 'ms')\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n```\n\n----------------------------------------\n\nTITLE: Defining Solution Printer for CP-SAT Solver in Python\nDESCRIPTION: This code snippet defines a VarArraySolutionPrinter class that inherits from CpSolverSolutionCallback. It is used to print intermediate solutions during the solving process, displaying the values of the specified variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/step_function_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n```\n\n----------------------------------------\n\nTITLE: Calculating Price Usage in Python\nDESCRIPTION: Function that computes the optimal price for a given usage based on available capacities. It finds the minimum difference between any capacity and the usage, where the capacity is greater than or equal to the usage.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef price_usage(usage, capacities):\n    \"\"\"Compute the best price for a given usage and possible capacities.\"\"\"\n    price = max(capacities)\n    for capacity in capacities:\n        if capacity < usage:\n            continue\n        price = min(capacity - usage, price)\n    return price\n```\n\n----------------------------------------\n\nTITLE: Configuring Set Cover Python Module with CMake\nDESCRIPTION: Creates a pybind11 module for the set cover component, setting output name, install paths, and linking against OR-Tools library and pybind11 native proto caster. Includes platform-specific configurations for macOS and Unix systems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(set_cover_pybind11 MODULE set_cover.cc)\nset_target_properties(set_cover_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"set_cover\")\n\n# note: macOS is APPLE and also UNIX !\nif(APPLE)\n  set_target_properties(set_cover_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\"\n    )\nelseif(UNIX)\n  set_target_properties(set_cover_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\"\n    )\nendif()\n\ntarget_link_libraries(set_cover_pybind11 PRIVATE\n  ${PROJECT_NAMESPACE}::ortools\n  pybind11_native_proto_caster\n)\nadd_library(${PROJECT_NAMESPACE}::set_cover_pybind11 ALIAS set_cover_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Seseman Convent Problem Solution Implementation\nDESCRIPTION: Main implementation of the Seseman Convent problem solver using OR-Tools. It creates a constraint satisfaction problem for an NxN matrix where border elements must sum to a specific value and inner elements are zero. The solver finds all possible solutions that satisfy these constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/seseman.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(unused_argv):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Seseman Convent problem\")\n\n  # data\n  n = 3\n  border_sum = n * n\n\n  # declare variables\n  total_sum = solver.IntVar(1, n * n * n * n, \"total_sum\")\n  # x[0..n-1,0..n-1]\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(0, n * n, \"x %i %i\" % (i, j))\n\n  #\n  # constraints\n  #\n  # zero all middle cells\n  for i in range(1, n - 1):\n    for j in range(1, n - 1):\n      solver.Add(x[(i, j)] == 0)\n\n  # all borders must be >= 1\n  for i in range(n):\n    for j in range(n):\n      if i == 0 or j == 0 or i == n - 1 or j == n - 1:\n        solver.Add(x[(i, j)] >= 1)\n\n  # sum the borders (border_sum)\n  solver.Add(solver.Sum([x[(i, 0)] for i in range(n)]) == border_sum)\n  solver.Add(solver.Sum([x[(i, n - 1)] for i in range(n)]) == border_sum)\n  solver.Add(solver.Sum([x[(0, i)] for i in range(n)]) == border_sum)\n  solver.Add(solver.Sum([x[(n - 1, i)] for i in range(n)]) == border_sum)\n\n  # total\n  solver.Add(\n      solver.Sum([x[(i, j)] for i in range(n) for j in range(n)]) == total_sum)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[(i, j)] for i in range(n) for j in range(n)])\n  solution.Add(total_sum)\n\n  # all solutions\n  collector = solver.AllSolutionCollector(solution)\n  # search_log = solver.SearchLog(100, total_sum)\n  solver.Solve(\n      solver.Phase([x[(i, j)] for i in range(n) for j in range(n)],\n                   solver.CHOOSE_PATH, solver.ASSIGN_MIN_VALUE), [collector])\n  #[collector, search_log])\n\n  num_solutions = collector.SolutionCount()\n  # print \"x:\", x\n  print(\"num_solutions:\", num_solutions)\n  print()\n  for s in range(num_solutions):\n    # print [collector.Value(s, x[(i,j)])\n    #        for i in range(n) for j in range(n)]\n    print(\"total_sum:\", collector.Value(s, total_sum))\n    for i in range(n):\n      for j in range(n):\n        print(collector.Value(s, x[(i, j)]), end=\" \")\n      print()\n    print()\n\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print(\"num_solutions:\", num_solutions)\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Printing Solver Results for Steel Mill Slab Problem in Python\nDESCRIPTION: Code fragment that prints the solver results, including the objective value (loss), wall time, and number of conflicts if a solution is found. Otherwise, it prints a message indicating no solution was found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n            f\"Loss = {solver.objective_value}, time = {solver.wall_time:2f} s,\"\n            f\" {solver.num_conflicts} conflicts\"\n        )\n    else:\n        print(\"No solution\")\n```\n\n----------------------------------------\n\nTITLE: Vehicles Class for CVRPTW Implementation\nDESCRIPTION: A class that creates and manages vehicle information for Capacitated Vehicle Routing Problem with Time Windows. It handles vehicle capacities, costs, and fleet composition, supporting both homogeneous and heterogeneous fleets.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nclass Vehicles():\n    \"\"\"\n    A Class to create and hold vehicle information.\n\n    The Vehicles in a CVRPTW problem service the customers and belong to a\n    depot. The class Vehicles creates a list of named tuples describing the\n    Vehicles.  The main characteristics are the vehicle capacity, fixed cost,\n    and cost per km.  The fixed cost of using a certain type of vehicles can be\n    higher or lower than others. If a vehicle is used, i.e. this vehicle serves\n    at least one node, then this cost is added to the objective function.\n\n    Note:\n        If numpy arrays are given for capacity and cost, then they must be of\n        the same length, and the number of vehicles are inferred from them.\n        If scalars are given, the fleet is homogeneous, and the number of\n        vehicles is determined by number.\n\n    Args: capacity (scalar or numpy array): The integer capacity of demand\n    units.  cost (scalar or numpy array): The fixed cost of the vehicle.  number\n    (Optional [int]): The number of vehicles in a homogeneous fleet.\n  \"\"\"\n\n    def __init__(self, capacity=100, cost=100, number=None):\n\n        Vehicle = namedtuple('Vehicle', ['index', 'capacity', 'cost'])\n\n        if number is None:\n            self.number = np.size(capacity)\n        else:\n            self.number = number\n        idxs = np.array(range(0, self.number))\n\n        if np.isscalar(capacity):\n            capacities = capacity * np.ones_like(idxs)\n        elif np.size(capacity) != self.number:\n            print('capacity is neither scalar, nor the same size as num!')\n        else:\n            capacities = capacity\n\n        if np.isscalar(cost):\n            costs = cost * np.ones_like(idxs)\n        elif np.size(cost) != self.number:\n            print(np.size(cost))\n            print('cost is neither scalar, nor the same size as num!')\n        else:\n            costs = cost\n\n        self.vehicles = [\n            Vehicle(idx, capacity, cost)\n            for idx, capacity, cost in zip(idxs, capacities, costs)\n        ]\n```\n\n----------------------------------------\n\nTITLE: Implementing Greedy Heuristic Solver\nDESCRIPTION: Function that implements a greedy heuristic to solve the assembly line balancing problem. It assigns tasks to pods (workstations) based on precedence constraints and remaining capacity, attempting to minimize the number of pods used.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef solve_problem_greedily(problem: Dict[str, SectionInfo]) -> Dict[int, int]:\n    \"\"\"Compute a greedy solution.\"\"\"\n    print(\"Solving using a Greedy heuristics\")\n\n    num_tasks = problem[\"number of tasks\"].value\n    if num_tasks is None:\n        return {}\n    all_tasks = range(1, num_tasks + 1)  # Tasks are 1 based in the data.\n    precedences = problem[\"precedence relations\"].set_of_pairs\n    durations = problem[\"task times\"].index_map\n    cycle_time = problem[\"cycle time\"].value\n\n    weights = collections.defaultdict(int)\n    successors = collections.defaultdict(list)\n\n    candidates = set(all_tasks)\n\n    for before, after in precedences:\n        weights[after] += 1\n        successors[before].append(after)\n        if after in candidates:\n            candidates.remove(after)\n\n    assignment: Dict[int, int] = {}\n    current_pod = 0\n    residual_capacity = cycle_time\n\n    while len(assignment) < num_tasks:\n        if not candidates:\n            print(\"error empty\")\n            break\n\n        best = -1\n        best_slack = cycle_time\n        best_duration = 0\n\n        for c in candidates:\n            duration = durations[c]\n            slack = residual_capacity - duration\n            if slack < best_slack and slack >= 0:\n                best_slack = slack\n                best = c\n                best_duration = duration\n\n        if best == -1:\n            current_pod += 1\n            residual_capacity = cycle_time\n            continue\n\n        candidates.remove(best)\n        assignment[best] = current_pod\n        residual_capacity -= best_duration\n\n        for succ in successors[best]:\n            weights[succ] -= 1\n            if weights[succ] == 0:\n                candidates.add(succ)\n                del weights[succ]\n\n    print(f\"  greedy solution uses {current_pod + 1} pods.\")\n\n    return assignment\n```\n\n----------------------------------------\n\nTITLE: Initializing Bakery Scheduling Components\nDESCRIPTION: Sets up the basic components for the bakery scheduling system including imports, parameter definitions, and recipe constants. Includes configuration for solver workers and time limits.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nfrom typing import List, Sequence, Tuple\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:16, max_time_in_seconds:30\",\n    \"Sat solver parameters.\",\n)\n\n# Recipes\nCROISSANT = \"croissant\"\nAPPLE_PIE = \"apple pie\"\nBRIOCHE = \"brioche\"\nCHOCOLATE_CAKE = \"chocolate cake\"\n```\n\n----------------------------------------\n\nTITLE: Main Function for RCPSP Solving Pipeline\nDESCRIPTION: This main function orchestrates the entire RCPSP solving process. It parses the input problem, analyzes the dependency graph, computes delays between nodes, and calculates lower bounds using various techniques.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef main(_):\n    rcpsp_parser = rcpsp.RcpspParser()\n    rcpsp_parser.parse_file(_INPUT.value)\n\n    problem = rcpsp_parser.problem()\n    print_problem_statistics(problem)\n\n    intervals_of_tasks, after = analyse_dependency_graph(problem)\n    delays, initial_solution, optimal_found = compute_delays_between_nodes(\n        problem, intervals_of_tasks\n    )\n\n    last_task = len(problem.tasks) - 1\n    key = (0, last_task)\n    lower_bound = delays[key][0] if key in delays else 0\n    if not optimal_found and _PREEMPTIVE_LB_TIME_LIMIT.value > 0.0:\n        lower_bound = compute_preemptive_lower_bound(problem, after, lower_bound)\n```\n\n----------------------------------------\n\nTITLE: Bin Packing Optimization in Java using OR-Tools CP-SAT\nDESCRIPTION: Java implementation of bin packing problem solver using OR-Tools CP-SAT. Includes detailed solution output and statistics. Uses the same constraint programming approach as C++ but with Java-specific OR-Tools bindings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_8\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\nimport com.google.ortools.sat.LinearExprBuilder;\nimport com.google.ortools.sat.Literal;\n\n/** Solves a bin packing problem with the CP-SAT solver. */\npublic class BinPackingProblemSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Data.\n    int binCapacity = 100;\n    int slackCapacity = 20;\n    int numBins = 5;\n\n    int[][] items = new int[][] {{20, 6}, {15, 6}, {30, 4}, {45, 3}};\n    int numItems = items.length;\n\n    // Model.\n    CpModel model = new CpModel();\n\n    // Main variables.\n    IntVar[][] x = new IntVar[numItems][numBins];\n    for (int i = 0; i < numItems; ++i) {\n      int numCopies = items[i][1];\n      for (int b = 0; b < numBins; ++b) {\n        x[i][b] = model.newIntVar(0, numCopies, \"x_\" + i + \"_\" + b);\n      }\n    }\n\n    // Load variables.\n    IntVar[] load = new IntVar[numBins];\n    for (int b = 0; b < numBins; ++b) {\n      load[b] = model.newIntVar(0, binCapacity, \"load_\" + b);\n    }\n\n    // Slack variables.\n    Literal[] slacks = new Literal[numBins];\n    for (int b = 0; b < numBins; ++b) {\n      slacks[b] = model.newBoolVar(\"slack_\" + b);\n    }\n\n    // Links load and x.\n    for (int b = 0; b < numBins; ++b) {\n      LinearExprBuilder expr = LinearExpr.newBuilder();\n      for (int i = 0; i < numItems; ++i) {\n        expr.addTerm(x[i][b], items[i][0]);\n      }\n      model.addEquality(expr, load[b]);\n    }\n\n    // Place all items.\n    for (int i = 0; i < numItems; ++i) {\n      LinearExprBuilder expr = LinearExpr.newBuilder();\n      for (int b = 0; b < numBins; ++b) {\n        expr.add(x[i][b]);\n      }\n      model.addEquality(expr, items[i][1]);\n    }\n\n    // Links load and slack.\n    int safeCapacity = binCapacity - slackCapacity;\n    for (int b = 0; b < numBins; ++b) {\n      //  slack[b] => load[b] <= safeCapacity.\n      model.addLessOrEqual(load[b], safeCapacity).onlyEnforceIf(slacks[b]);\n      // not(slack[b]) => load[b] > safeCapacity.\n      model.addGreaterOrEqual(load[b], safeCapacity + 1).onlyEnforceIf(slacks[b].not());\n    }\n\n    // Maximize sum of slacks.\n    model.maximize(LinearExpr.sum(slacks));\n\n    // Solves and prints out the solution.\n    CpSolver solver = new CpSolver();\n    CpSolverStatus status = solver.solve(model);\n    System.out.println(\"Solve status: \" + status);\n    if (status == CpSolverStatus.OPTIMAL) {\n      System.out.printf(\"Optimal objective value: %f%n\", solver.objectiveValue());\n      for (int b = 0; b < numBins; ++b) {\n        System.out.printf(\"load_%d = %d%n\", b, solver.value(load[b]));\n        for (int i = 0; i < numItems; ++i) {\n          System.out.printf(\"  item_%d_%d = %d%n\", i, b, solver.value(x[i][b]));\n        }\n      }\n    }\n    System.out.println(\"Statistics\");\n    System.out.println(\"  - conflicts : \" + solver.numConflicts());\n    System.out.println(\"  - branches  : \" + solver.numBranches());\n    System.out.println(\"  - wall time : \" + solver.wallTime() + \" s\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solution Hinting Implementation in Java\nDESCRIPTION: Implements solution hinting in Java using OR-Tools CP-SAT solver. Creates a model with variables, constraints, and solution hints while maximizing an objective function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\n\n/** Minimal CP-SAT example to showcase calling the solver. */\npublic class SolutionHintingSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n\n    // Create the constraints.\n    model.addDifferent(x, y);\n\n    model.maximize(LinearExpr.weightedSum(new IntVar[] {x, y, z}, new long[] {1, 2, 3}));\n\n    // Solution hinting: x <- 1, y <- 2\n    model.addHint(x, 1);\n    model.addHint(y, 2);\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    VarArraySolutionPrinterWithObjective cb =\n        new VarArraySolutionPrinterWithObjective(new IntVar[] {x, y, z});\n    CpSolverStatus unusedStatus = solver.solve(model, cb);\n  }\n\n  static class VarArraySolutionPrinterWithObjective extends CpSolverSolutionCallback {\n    public VarArraySolutionPrinterWithObjective(IntVar[] variables) {\n      variableArray = variables;\n    }\n\n    @Override\n    public void onSolutionCallback() {\n      System.out.printf(\"Solution #%d: time = %.02f s%n\", solutionCount, wallTime());\n      System.out.printf(\"  objective value = %f%n\", objectiveValue());\n      for (IntVar v : variableArray) {\n        System.out.printf(\"  %s = %d%n\", v.getName(), value(v));\n      }\n      solutionCount++;\n    }\n\n    private int solutionCount;\n    private final IntVar[] variableArray;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Step Function with OR-Tools in C#\nDESCRIPTION: This code snippet demonstrates how to implement a step function using OR-Tools in C#. It creates a CP-SAT model, defines variables and constraints to represent the step function, and solves the model while printing the solutions. The step function is defined for specific ranges of the primary variable 'x'.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\nusing Google.OrTools.Util;\n\npublic class VarArraySolutionPrinter : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinter(IntVar[] variables)\n    {\n        variables_ = variables;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        {\n            foreach (IntVar v in variables_)\n            {\n                Console.Write(String.Format(\"{0}={1} \", v.ToString(), Value(v)));\n            }\n            Console.WriteLine();\n        }\n    }\n\n    private IntVar[] variables_;\n}\n\npublic class StepFunctionSampleSat\n{\n    static void Main()\n    {\n        // Create the CP-SAT model.\n        CpModel model = new CpModel();\n\n        // Declare our primary variable.\n        IntVar x = model.NewIntVar(0, 20, \"x\");\n\n        // Create the expression variable and implement the step function\n        // Note it is not defined for var == 2.\n        //\n        //        -               3\n        // -- --      ---------   2\n        //                        1\n        //      -- ---            0\n        // 0 ================ 20\n        //\n        IntVar expr = model.NewIntVar(0, 3, \"expr\");\n\n        // expr == 0 on [5, 6] U [8, 10]\n        ILiteral b0 = model.NewBoolVar(\"b0\");\n        model.AddLinearExpressionInDomain(x, Domain.FromValues(new long[] { 5, 6, 8, 9, 10 })).OnlyEnforceIf(b0);\n        model.Add(expr == 0).OnlyEnforceIf(b0);\n\n        // expr == 2 on [0, 1] U [3, 4] U [11, 20]\n        ILiteral b2 = model.NewBoolVar(\"b2\");\n        model\n            .AddLinearExpressionInDomain(\n                x,\n                Domain.FromIntervals(new long[][] { new long[] { 0, 1 }, new long[] { 3, 4 }, new long[] { 11, 20 } }))\n            .OnlyEnforceIf(b2);\n        model.Add(expr == 2).OnlyEnforceIf(b2);\n\n        // expr == 3 when x == 7\n        ILiteral b3 = model.NewBoolVar(\"b3\");\n        model.Add(x == 7).OnlyEnforceIf(b3);\n        model.Add(expr == 3).OnlyEnforceIf(b3);\n\n        // At least one bi is true. (we could use a sum == 1).\n        model.AddBoolOr(new ILiteral[] { b0, b2, b3 });\n\n        // Search for x values in increasing order.\n        model.AddDecisionStrategy(new IntVar[] { x }, DecisionStrategyProto.Types.VariableSelectionStrategy.ChooseFirst,\n                                  DecisionStrategyProto.Types.DomainReductionStrategy.SelectMinValue);\n\n        // Create the solver.\n        CpSolver solver = new CpSolver();\n\n        // Force solver to follow the decision strategy exactly.\n        // Tells the solver to enumerate all solutions.\n        solver.StringParameters = \"search_branching:FIXED_SEARCH, enumerate_all_solutions:true\";\n\n        VarArraySolutionPrinter cb = new VarArraySolutionPrinter(new IntVar[] { x, expr });\n        solver.Solve(model, cb);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Decision Variables for Diet Optimization\nDESCRIPTION: Creates numeric variables representing food quantities, costs, and constraints for linear programming diet optimization problem\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stigler_contrib.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nx = [solver.NumVar(0, 1000, \"x[%i]\" % i) for i in C]\nx_cost = [solver.NumVar(0, 1000, \"x_cost[%i]\" % i) for i in C]\nquant = [solver.NumVar(0, 1000, \"quant[%i]\" % i) for i in C]\n```\n\n----------------------------------------\n\nTITLE: Running SEND+MOST=MONEY Solver with Maximization and Solution Checking\nDESCRIPTION: This code snippet runs the main function twice: first to maximize the MONEY value, then to check all solutions for the maximized value. It demonstrates how to use the solver to find the optimal solution and then explore all possible arrangements for that solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/send_most_money.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# First get the maximised MONEY, and then show all solutions for\n# this value\nprint('Minimize money...')\nmoney = main(0)\nprint('\\nCheck all solutions for money=%i' % money)\nmain(money)\n```\n\n----------------------------------------\n\nTITLE: Search All Solutions in Java using OR-Tools\nDESCRIPTION: Implements OR-Tools CP-SAT solver configuration for finding all solutions in Java. Creates a solution callback class to print each solution as it's found and maintains a solution counter.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_12\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\n\n/** Code sample that solves a model and displays all solutions. */\npublic class SearchForAllSolutionsSampleSat {\n  static class VarArraySolutionPrinter extends CpSolverSolutionCallback {\n    public VarArraySolutionPrinter(IntVar[] variables) {\n      variableArray = variables;\n    }\n\n    @Override\n    public void onSolutionCallback() {\n      System.out.printf(\"Solution #%d: time = %.02f s%n\", solutionCount, wallTime());\n      for (IntVar v : variableArray) {\n        System.out.printf(\"  %s = %d%n\", v.getName(), value(v));\n      }\n      solutionCount++;\n    }\n\n    public int getSolutionCount() {\n      return solutionCount;\n    }\n\n    private int solutionCount;\n    private final IntVar[] variableArray;\n  }\n\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n\n    // Create the constraints.\n    model.addDifferent(x, y);\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    VarArraySolutionPrinter cb = new VarArraySolutionPrinter(new IntVar[] {x, y, z});\n    // Tell the solver to enumerate all solutions.\n    solver.getParameters().setEnumerateAllSolutions(true);\n    // And solve.\n    CpSolverStatus unusedStatus = solver.solve(model, cb);\n\n    System.out.println(cb.getSolutionCount() + \" solutions found.\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Intermediate Solutions for Steel Mill Slab\nDESCRIPTION: Defines a callback class for the OR-Tools CpSolver to capture and print each intermediate solution found. It logs the solution count, time taken, and objective value, and prints details of orders assigned to each slab.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass SteelMillSlabSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, orders, assign, load, loss) -> None:\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__orders = orders\n        self.__assign = assign\n        self.__load = load\n        self.__loss = loss\n        self.__solution_count = 0\n        self.__all_orders = range(len(orders))\n        self.__all_slabs = range(len(assign[0]))\n        self.__start_time = time.time()\n\n    def on_solution_callback(self) -> None:\n        \"\"\"Called on each new solution.\"\"\"\n        current_time = time.time()\n        objective = sum(self.value(l) for l in self.__loss)\n        print(\n            f\"Solution {self.__solution_count}, time =\"\n            f\" {current_time - self.__start_time} s, objective = {objective}\"\n        )\n        self.__solution_count += 1\n        orders_in_slab = [\n            [o for o in self.__all_orders if self.value(self.__assign[o][s])]\n            for s in self.__all_slabs\n        ]\n        for s in self.__all_slabs:\n            if orders_in_slab[s]:\n                line = (\n                    f\"  - slab {s}, load = {self.value(self.__load[s])}, loss =\"\n                    f\" {self.value(self.__loss[s])}, orders = [\"\n                )\n                for o in orders_in_slab[s]:\n                    line += f\"#{o}(w{self.__orders[o][0]}, c{self.__orders[o][1]})\"\n                line += \"]\"\n                print(line)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing CP Solver with OR-Tools in C++\nDESCRIPTION: This C++ code demonstrates how to use the OR-Tools CP solver to create variables, add constraints, solve a simple problem, and print solutions. It includes advanced usage information such as solving time and memory usage.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/CP.md#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <ostream>\n#include <string>\n\n#include \"ortools/constraint_solver/constraint_solver.h\"\n\nnamespace operations_research {\n\nvoid SimpleCpProgram() {\n  // Instantiate the solver.\n  Solver solver(\"CpSimple\");\n\n  // Create the variables.\n  const int64_t num_vals = 3;\n  IntVar* const x = solver.MakeIntVar(0, num_vals - 1, \"x\");\n  IntVar* const y = solver.MakeIntVar(0, num_vals - 1, \"y\");\n  IntVar* const z = solver.MakeIntVar(0, num_vals - 1, \"z\");\n\n  // Constraint 0: x != y..\n  solver.AddConstraint(solver.MakeAllDifferent({x, y}));\n  LOG(INFO) << \"Number of constraints: \"\n            << std::to_string(solver.constraints());\n\n  // Solve the problem.\n  DecisionBuilder* const db = solver.MakePhase(\n      {x, y, z}, Solver::CHOOSE_FIRST_UNBOUND, Solver::ASSIGN_MIN_VALUE);\n\n  // Print solution on console.\n  int count = 0;\n  solver.NewSearch(db);\n  while (solver.NextSolution()) {\n    ++count;\n    LOG(INFO) << \"Solution \" << count << \":\" << std::endl\n              << \" x=\" << x->Value() << \" y=\" << y->Value()\n              << \" z=\" << z->Value();\n  }\n  solver.EndSearch();\n  LOG(INFO) << \"Number of solutions found: \" << solver.solutions();\n\n  LOG(INFO) << \"Advanced usage:\" << std::endl\n            << \"Problem solved in \" << std::to_string(solver.wall_time())\n            << \"ms\" << std::endl\n            << \"Memory usage: \" << std::to_string(Solver::MemoryUsage())\n            << \"bytes\";\n}\n\n}  // namespace operations_research\n\nint main(int /*argc*/, char* /*argv*/[]) {\n  operations_research::SimpleCpProgram();\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Product in Go with OR-Tools\nDESCRIPTION: This Go code demonstrates how to encode the product of two Boolean variables using Google's OR-Tools library. It implements the logical relation p <=> x and y using bool_or constraints and implications, and prints all solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_16\n\nLANGUAGE: Go\nCODE:\n```\n// The boolean_product_sample_sat command is a simple example of the product of two literals.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc booleanProductSample() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tx := model.NewBoolVar().WithName(\"x\")\n\ty := model.NewBoolVar().WithName(\"y\")\n\tp := model.NewBoolVar().WithName(\"p\")\n\n\t// x and y implies p, rewrite as not(x and y) or p.\n\tmodel.AddBoolOr(x.Not(), y.Not(), p)\n\n\t// p implies x and y, expanded into two implications.\n\tmodel.AddImplication(p, x)\n\tmodel.AddImplication(p, y)\n\n\t// Solve.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\t// Set `fill_additional_solutions_in_response` and `enumerate_all_solutions` to true so\n\t// the solver returns all solutions found.\n\tparams := &sppb.SatParameters{\n\t\tFillAdditionalSolutionsInResponse: proto.Bool(true),\n\t\tEnumerateAllSolutions:             proto.Bool(true),\n\t\tSolutionPoolSize:                  proto.Int32(4),\n\t}\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Printf(\"Status: %v\\n\", response.GetStatus())\n\n\tfor _, additionalSolution := range response.GetAdditionalSolutions() {\n\t\tfmt.Printf(\"x: %v\", additionalSolution.GetValues()[x.Index()])\n\t\tfmt.Printf(\" y: %v\", additionalSolution.GetValues()[y.Index()])\n\t\tfmt.Printf(\" p: %v\\n\", additionalSolution.GetValues()[p.Index()])\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\terr := booleanProductSample()\n\tif err != nil {\n\t\tlog.Exitf(\"booleanProductSample returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Executing De Bruijn Sequence Generation with Command-line Arguments\nDESCRIPTION: Sets up the execution of the main function with default or command-line provided parameters for base, n, and m values.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/debruijn_binary.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbase = 2\nn = 3\nm = base**n\nif len(sys.argv) > 1:\n  base = int(sys.argv[1])\nif len(sys.argv) > 2:\n  n = int(sys.argv[2])\nif len(sys.argv) > 3:\n  m = int(sys.argv[3])\n\nmain(base, n, m)\n```\n\n----------------------------------------\n\nTITLE: Solving Assignment Problem using OR-Tools\nDESCRIPTION: This snippet implements a function to solve an assignment problem using the OR-Tools. It sets up costs for a number of workers and tasks, constrains the assignment based on task sizes, and minimizes the total assignment cost. The output includes the cost and the assignment of each worker to their respective task if a solution is found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_task_sizes_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef main() -> None:\n    # Data\n    costs = [\n        [90, 76, 75, 70, 50, 74, 12, 68],\n        [35, 85, 55, 65, 48, 101, 70, 83],\n        [125, 95, 90, 105, 59, 120, 36, 73],\n        [45, 110, 95, 115, 104, 83, 37, 71],\n        [60, 105, 80, 75, 59, 62, 93, 88],\n        [45, 65, 110, 95, 47, 31, 81, 34],\n        [38, 51, 107, 41, 69, 99, 115, 48],\n        [47, 85, 57, 71, 92, 77, 109, 36],\n        [39, 63, 97, 49, 118, 56, 92, 61],\n        [47, 101, 71, 60, 88, 109, 52, 90],\n    ]\n    num_workers = len(costs)\n    num_tasks = len(costs[0])\n\n    task_sizes = [10, 7, 3, 12, 15, 4, 11, 5]\n    # Maximum total of task sizes for any worker\n    total_size_max = 15\n\n    # Model\n    model = cp_model.CpModel()\n\n    # Variables\n    x = {}\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            x[worker, task] = model.new_bool_var(f\"x[{worker},{task} than\"])\n\n    # Constraints\n    # Each worker is assigned to at most one task.\n    for worker in range(num_workers):\n        model.add(\n            sum(task_sizes[task] * x[worker, task] for task in range(num_tasks))\n            <= total_size_max\n        )\n\n    # Each task is assigned to exactly one worker.\n    for task in range(num_tasks):\n        model.add_exactly_one(x[worker, task] for worker in range(num_workers))\n\n    # Objective\n    objective_terms = []\n    for worker in range(num_workers):\n        for task in range(num_tasks):\n            objective_terms.append(costs[worker][task] * x[worker, task])\n    model.minimize(sum(objective_terms))\n\n    # Solve\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    # Print solution.\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"Total cost = {solver.objective_value}\\n\")\n        for worker in range(num_workers):\n            for task in range(num_tasks):\n                if solver.boolean_value(x[worker, task]):\n                    print(\n                        f\"Worker {worker} assigned to task {task}.\"\n                        + f\" Cost = {costs[worker][task]}\"\n                    )\n    else:\n        print(\"No solution found.\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package using pip, which is required to run the prize collecting TSP implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit in C# CP-SAT Solver\nDESCRIPTION: C# implementation showing how to specify a 10-second time limit for a CP-SAT solver. This example demonstrates how solver parameters must be passed as string settings in C#, creating a simple constraint problem with three variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class SolveWithTimeLimitSampleSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n        // Creates the variables.\n        int num_vals = 3;\n\n        IntVar x = model.NewIntVar(0, num_vals - 1, \"x\");\n        IntVar y = model.NewIntVar(0, num_vals - 1, \"y\");\n        IntVar z = model.NewIntVar(0, num_vals - 1, \"z\");\n        // Adds a different constraint.\n        model.Add(x != y);\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n\n        // Adds a time limit. Parameters are stored as strings in the solver.\n        solver.StringParameters = \"max_time_in_seconds:10.0\";\n\n        CpSolverStatus status = solver.Solve(model);\n\n        if (status == CpSolverStatus.Optimal)\n        {\n            Console.WriteLine(\"x = \" + solver.Value(x));\n            Console.WriteLine(\"y = \" + solver.Value(y));\n            Console.WriteLine(\"z = \" + solver.Value(z));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Reified Constraints in Python\nDESCRIPTION: This snippet defines a function that creates a model with several reified constraints using the ortools CP-SAT solver. It demonstrates various ways to create such constraints using boolean variables and implications.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/reified_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef reified_sample_sat():\n    \"\"\"Showcase creating a reified constraint.\"\"\"\n    model = cp_model.CpModel()\n\n    x = model.new_bool_var(\"x\")\n    y = model.new_bool_var(\"y\")\n    b = model.new_bool_var(\"b\")\n\n    # First version using a half-reified bool and.\n    model.add_bool_and(x, ~y).only_enforce_if(b)\n\n    # Second version using implications.\n    model.add_implication(b, x)\n    model.add_implication(b, ~y)\n\n    # Third version using bool or.\n    model.add_bool_or(~b, x)\n    model.add_bool_or(~b, ~y)\n\n\nreified_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Validating Sequence Constraints with Penalty Calculation in Python\nDESCRIPTION: This code snippet validates sequence length constraints and cumulative constraints for tasks, calculating penalties when soft constraints are violated. It checks task lengths against hard minimum/maximum bounds and computes penalties when cumulative values exceed soft maximums. The code includes detailed logging of task parameters and constraint violations.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/sequences_in_no_overlap_sample_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlength: int = solver.value(lengths[t])\nhard_min_length, hard_max_length = sequence_length_constraints[\n    task_types[t]\n]\nassert length >= 0\nassert length <= hard_max_length\nif (\n    i + 1 == len(to_sort) or task_types[t] != task_types[to_sort[i + 1][1]]\n):  # End of sequence.\n    assert length >= hard_min_length\n\n# Check cumul constraints.\ncumul: int = solver.value(cumuls[t])\nsoft_max_cumul, penalty, hard_max_cumul = sequence_cumul_constraints[\n    task_types[t]\n]\nassert cumul >= 0\nassert cumul <= hard_max_cumul\n\nif cumul > soft_max_cumul:\n    penalty = penalty * (cumul - soft_max_cumul)\n    sum_of_penalties += penalty\n    print(\n        f\"Task {t} of type {task_types[t]} with\"\n        f\" duration={durations[t]} starts at {start}, length={length},\"\n        f\" cumul={cumul} penalty={penalty}\"\n    )\nelse:\n    print(\n        f\"Task {t} of type {task_types[t]} with duration\"\n        f\" {durations[t]} starts at {start}, length =\"\n        f\" {length}, cumul = {cumul} \"\n    )\n\nassert int(solver.objective_value) == sum_of_penalties\nelse:\n    print(f\"Solver exited with the following status: {status}\")\n\n\nsequences_in_no_overlap_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Transition Matrix for Nonogram Pattern\nDESCRIPTION: Generates a transition matrix for a given Nonogram pattern. This matrix is used to create the automaton for the regular constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef make_transition_matrix(pattern):\n\n  p_len = len(pattern)\n  num_states = p_len + sum(pattern)\n\n  if num_states == 0:\n    num_states = 1\n\n  t_matrix = []\n  for i in range(num_states):\n    row = []\n    for j in range(2):\n      row.append(0)\n    t_matrix.append(row)\n\n  tmp = [0 for i in range(num_states)]\n  c = 0\n  tmp[c] = 0\n  for i in range(p_len):\n    for j in range(pattern[i]):\n      c += 1\n      tmp[c] = 1\n    if c < num_states - 1:\n      c += 1\n      tmp[c] = 0\n\n  t_matrix[num_states - 1][0] = num_states\n  t_matrix[num_states - 1][1] = 0\n\n  for i in range(num_states):\n    if tmp[i] == 0:\n      t_matrix[i][0] = i + 1\n      t_matrix[i][1] = i + 2\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          t_matrix[i][0] = 0\n          t_matrix[i][1] = i + 2\n        else:\n          t_matrix[i][0] = i + 2\n          t_matrix[i][1] = 0\n\n  return t_matrix\n```\n\n----------------------------------------\n\nTITLE: Implementing CP-SAT Solver in C#\nDESCRIPTION: Shows implementation of CP-SAT solver in C# using CpModel and CpSolver classes. Creates variables with domains and constraints to solve a simple constraint satisfaction problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/README.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class SimpleSatProgram\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n\n        // Creates the variables.\n        int num_vals = 3;\n\n        IntVar x = model.NewIntVar(0, num_vals - 1, \"x\");\n        IntVar y = model.NewIntVar(0, num_vals - 1, \"y\");\n        IntVar z = model.NewIntVar(0, num_vals - 1, \"z\");\n\n        // Creates the constraints.\n        model.Add(x != y);\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        CpSolverStatus status = solver.Solve(model);\n\n        if (status == CpSolverStatus.Optimal || status == CpSolverStatus.Feasible)\n        {\n            Console.WriteLine(\"x = \" + solver.Value(x));\n            Console.WriteLine(\"y = \" + solver.Value(y));\n            Console.WriteLine(\"z = \" + solver.Value(z));\n        }\n        else\n        {\n            Console.WriteLine(\"No solution found.\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running Coins Grid Solver in Python\nDESCRIPTION: Defines default values for grid size and number of coins, allows command-line arguments to override these, and calls the main function to solve the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins_grid.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# data\nn = 5  # the grid size\nc = 2  # number of coins per row/column\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nif len(sys.argv) > 2:\n  c = int(sys.argv[2])\n\nmain(n, c)\n```\n\n----------------------------------------\n\nTITLE: Printing VRP Solution with Breaks in Python\nDESCRIPTION: Defines a function to print the solution of the VRP, including breaks, route details, and total time for all routes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_breaks_from_start.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n\n    print(\"Breaks:\")\n    intervals = solution.IntervalVarContainer()\n    for i in range(intervals.Size()):\n        brk = intervals.Element(i)\n        if brk.PerformedValue() == 1:\n            print(\n                f\"{brk.Var().Name()}: \"\n                + f\"Start({brk.StartValue()}) Duration({brk.DurationValue()})\"\n            )\n        else:\n            print(f\"{brk.Var().Name()}: Unperformed\")\n\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    total_time = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        while not routing.IsEnd(index):\n            time_var = time_dimension.CumulVar(index)\n            if routing.IsStart(index):\n                start_time = solution.Value(time_var)\n            plan_output += f\"{manager.IndexToNode(index)} \"\n            plan_output += f\"Time({solution.Value(time_var)}) -> \"\n            index = solution.Value(routing.NextVar(index))\n        time_var = time_dimension.CumulVar(index)\n        plan_output += f\"{manager.IndexToNode(index)} \"\n        plan_output += f\"Time({solution.Value(time_var)})\"\n        print(plan_output)\n        route_time = solution.Value(time_var) - start_time\n        print(f\"Time of the route: {route_time}min\\n\")\n        total_time += route_time\n    print(f\"Total time of all routes: {total_time}min\")\n```\n\n----------------------------------------\n\nTITLE: Creating Distance Callback Function for OR-Tools Routing\nDESCRIPTION: A method that returns a callback function for the distance matrix to be used by OR-Tools routing solver. The callback converts routing indices to node indices and returns the distance between those nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef return_dist_callback(self, **kwargs):\n    \"\"\"\n    Return a callback function for the distance matrix.\n\n    Args: **kwargs: Arbitrary keyword arguments passed on to\n    make_distance_mat()\n\n    Returns:\n        function: dist_return(a,b) A function that takes the 'from' node\n            index and the 'to' node index and returns the distance in km.\n    \"\"\"\n    self.make_distance_mat(**kwargs)\n\n    def dist_return(from_index, to_index):\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = self.manager.IndexToNode(from_index)\n        to_node = self.manager.IndexToNode(to_index)\n        return (self.distmat[from_node][to_node])\n\n    return dist_return\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Sample Builds for Math Optimization in OR-Tools\nDESCRIPTION: This CMake script controls which Python sample files are built in the math optimization module. It skips building samples if BUILD_SAMPLES is not set, filters out samples with special dependencies, and conditionally includes samples based on solver availability (USE_SCIP).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/samples/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BUILD_SAMPLES)\n  return()\nendif()\n\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \"remote_solve.py$\") # need ortools.math_opt.python.ipc\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \"tsp.py$\") # need gurobi\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \"facility_lp_benders.py$\") # too long\n\n  if(NOT USE_SCIP)\n    list(FILTER PYTHON_SRCS EXCLUDE REGEX \"basic_example.py$\")\n    list(FILTER PYTHON_SRCS EXCLUDE REGEX \"integer_programming.py$\")\n    list(FILTER PYTHON_SRCS EXCLUDE REGEX \"time_indexed_scheduling.py$\")\n  endif()\n\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(\n      FILE_NAME ${SAMPLE}\n      COMPONENT_NAME math_opt)\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Implementing Car Sequencing Solver\nDESCRIPTION: Defines the main function that sets up and solves the car sequencing problem using OR-Tools. It includes data initialization, variable declaration, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/car.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(num_sol=3):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Car sequence\")\n\n  #\n  # data\n  #\n  nbCars = 6\n  nbOptions = 5\n  nbSlots = 10\n\n  Cars = list(range(nbCars))\n  Options = list(range(nbOptions))\n  Slots = list(range(nbSlots))\n\n  #    car 0   1  2  3  4  5\n  demand = [1, 1, 2, 2, 2, 2]\n\n  option = [\n      # car 0  1  2  3  4  5\n      [1, 0, 0, 0, 1, 1],  # option 1\n      [0, 0, 1, 1, 0, 1],  # option 2\n      [1, 0, 0, 0, 1, 0],  # option 3\n      [1, 1, 0, 1, 0, 0],  # option 4\n      [0, 0, 1, 0, 0, 0]  # option 5\n  ]\n\n  capacity = [(1, 2), (2, 3), (1, 3), (2, 5), (1, 5)]\n\n  optionDemand = [\n      sum([demand[j] * option[i][j] for j in Cars]) for i in Options\n  ]\n\n  #\n  # declare variables\n  #\n  slot = [solver.IntVar(0, nbCars - 1, \"slot[%i]\" % i) for i in Slots]\n  setup = {}\n  for i in Options:\n    for j in Slots:\n      setup[(i, j)] = solver.IntVar(0, 1, \"setup[%i,%i]\" % (i, j))\n  setup_flat = [setup[i, j] for i in Options for j in Slots]\n\n  #\n  # constraints\n  #\n  for c in Cars:\n    b = [solver.IsEqualCstVar(slot[s], c) for s in Slots]\n    solver.Add(solver.Sum(b) == demand[c])\n\n  for o in Options:\n    for s in range(0, nbSlots - capacity[o][1] + 1):\n      b = [setup[o, j] for j in range(s, s + capacity[o][1] - 1)]\n      solver.Add(solver.Sum(b) <= capacity[o][0])\n\n  for o in Options:\n    for s in Slots:\n      solver.Add(setup[(o, s)] == solver.Element(option[o], slot[s]))\n\n  for o in Options:\n    for i in range(optionDemand[o]):\n      s_range = list(range(0, nbSlots - (i + 1) * capacity[o][1]))\n      ss = [setup[o, s] for s in s_range]\n      cc = optionDemand[o] - (i + 1) * capacity[o][0]\n      if len(ss) > 0 and cc >= 0:\n        solver.Add(solver.Sum(ss) >= cc)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(slot + setup_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"slot:%s\" % \",\".join([str(slot[i].Value()) for i in Slots]))\n    print(\"setup:\")\n    for o in Options:\n      print(\"%i/%i:\" % (capacity[o][0], capacity[o][1]), end=\" \")\n      for s in Slots:\n        print(setup[o, s].Value(), end=\" \")\n      print()\n    print()\n    num_solutions += 1\n\n    if num_solutions >= num_sol:\n      break\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nnum_sol = 3\nif len(sys.argv) > 1:\n  num_sol = int(sys.argv[1])\nmain(num_sol)\n```\n\n----------------------------------------\n\nTITLE: Solving CP-SAT Problem with Time Limit in Python\nDESCRIPTION: This function creates a simple CP-SAT model with three variables and an all-different constraint. It then sets up a solver with a 10-second time limit and solves the model. The solution, if found, is printed.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solve_with_time_limit_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef solve_with_time_limit_sample_sat():\n    \"\"\"Minimal CP-SAT example to showcase calling the solver.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n    # Adds an all-different constraint.\n    model.add(x != y)\n\n    # Creates a solver and solves the model.\n    solver = cp_model.CpSolver()\n\n    # Sets a time limit of 10 seconds.\n    solver.parameters.max_time_in_seconds = 10.0\n\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"x = {solver.value(x)}\")\n        print(f\"y = {solver.value(y)}\")\n        print(f\"z = {solver.value(z)}\")\n\n\nsolve_with_time_limit_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Implementing Young Tableaux with Google CP Solver in Python\nDESCRIPTION: This code defines the main function for generating Young tableaux using Google's CP Solver. It sets up variables, constraints, and a search algorithm to find all valid Young tableaux for a given size n.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/young_tableaux.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=5):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Problem\")\n\n  #\n  # data\n  #\n  print(\"n:\", n)\n\n  #\n  # declare variables\n  #\n  x = {}\n  for i in range(n):\n    for j in range(n):\n      x[(i, j)] = solver.IntVar(1, n + 1, \"x(%i,%i)\" % (i, j))\n\n  x_flat = [x[(i, j)] for i in range(n) for j in range(n)]\n\n  # partition structure\n  p = [solver.IntVar(0, n + 1, \"p%i\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n\n  # 1..n is used exactly once\n  for i in range(1, n + 1):\n    solver.Add(solver.Count(x_flat, i, 1))\n\n  solver.Add(x[(0, 0)] == 1)\n\n  # row wise\n  for i in range(n):\n    for j in range(1, n):\n      solver.Add(x[(i, j)] >= x[(i, j - 1)])\n\n  # column wise\n  for j in range(n):\n    for i in range(1, n):\n      solver.Add(x[(i, j)] >= x[(i - 1, j)])\n\n  # calculate the structure (the partition)\n  for i in range(n):\n    # MiniZinc/Zinc version:\n    # p[i] == sum(j in 1..n) (bool2int(x[i,j] <= n))\n\n    b = [solver.IsLessOrEqualCstVar(x[(i, j)], n) for j in range(n)]\n    solver.Add(p[i] == solver.Sum(b))\n\n  solver.Add(solver.Sum(p) == n)\n\n  for i in range(1, n):\n    solver.Add(p[i - 1] >= p[i])\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x_flat)\n  solution.Add(p)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x_flat + p, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"p:\", [p[i].Value() for i in range(n)])\n    print(\"x:\")\n    for i in range(n):\n      for j in range(n):\n        val = x_flat[i * n + j].Value()\n        if val <= n:\n          print(val, end=\" \")\n      if p[i].Value() > 0:\n        print()\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 5\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\n\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Assembly Line Balancing Solver\nDESCRIPTION: Main implementation of the assembly line balancing solver, including imports, command-line flags, and data structures. This code defines the SectionInfo class used to store problem information from different sections of the input file.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nimport re\nfrom typing import Dict, Sequence\n\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\n\nfrom ortools.sat.python import cp_model\n\n_INPUT = flags.define_string(\"input\", \"\", \"Input file to parse and solve.\")\n_PARAMS = flags.define_string(\"params\", \"\", \"Sat solver parameters.\")\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_MODEL = flags.define_string(\n    \"model\", \"boolean\", \"Model used: boolean, scheduling, greedy\"\n)\n\n\nclass SectionInfo:\n    \"\"\"Store problem information for each section of the input file.\"\"\"\n\n    def __init__(self):\n        self.value = None\n        self.index_map = {}\n        self.set_of_pairs = set()\n\n    def __str__(self):\n        if self.index_map:\n            return f\"SectionInfo(index_map={self.index_map})\"\n        elif self.set_of_pairs:\n            return f\"SectionInfo(set_of_pairs={self.set_of_pairs})\"\n        elif self.value is not None:\n            return f\"SectionInfo(value={self.value})\"\n        else:\n            return \"SectionInfo()\"\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Objectives Based on Problem Phase\nDESCRIPTION: Sets different optimization objectives depending on whether we're minimizing the number of drivers or minimizing the total working time (by minimizing delays between tasks).\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nif minimize_drivers:\n    # minimize the number of working drivers\n    model.minimize(cp_model.LinearExpr.sum(working_drivers))\nelse:\n    # minimize the sum of delays between tasks, which in turns minimize the\n    # sum of working times as the total driving time is fixed\n    model.minimize(cp_model.LinearExpr.weighted_sum(delay_literals, delay_weights))\n```\n\n----------------------------------------\n\nTITLE: Solving Index of First Boolean Variable Using CP-SAT\nDESCRIPTION: Main function to solve the problem of finding the index of the first Boolean variable set to true using constraint programming techniques\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/index_first_boolvar_true_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef index_of_first_bool_at_true_sample_sat():\n    \"\"\"Compute the index of the first Boolean variable set to true.\"\"\"\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Variables\n    num_bool_vars = 5\n    bool_vars = [model.new_bool_var(f\"{i}\") for i in range(num_bool_vars)]\n    index = model.new_int_var(0, num_bool_vars, \"index\")\n\n    # Channeling between the index and the Boolean variables.\n    model.add_min_equality(\n        index,\n        [\n            num_bool_vars - bool_vars[i] * (num_bool_vars - i)\n            for i in range(num_bool_vars)\n        ],\n    )\n\n    # Flip bool_vars in increasing order.\n    model.add_decision_strategy(\n        bool_vars, cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE\n    )\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n\n    # Search and print out all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    solution_printer = VarArraySolutionPrinter(index, bool_vars)\n    solver.solve(model, solution_printer)\n```\n\n----------------------------------------\n\nTITLE: Implementing CP-SAT Solver in Go\nDESCRIPTION: Demonstrates CP-SAT solver implementation in Go using CpModelBuilder. Creates variables with domains and constraints, then solves using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/README.md#2025-04-17_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// The simple_sat_program command is an example of a simple sat program.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n)\n\nfunc simpleSatProgram() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tdomain := cpmodel.NewDomain(0, 2)\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVarFromDomain(domain).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\n\tmodel.AddNotEqual(x, y)\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tresponse, err := cpmodel.SolveCpModel(m)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tswitch response.GetStatus() {\n\tcase cmpb.CpSolverStatus_OPTIMAL, cmpb.CpSolverStatus_FEASIBLE:\n\t\tfmt.Printf(\"x = %d\\n\", cpmodel.SolutionIntegerValue(response, x))\n\t\tfmt.Printf(\"y = %d\\n\", cpmodel.SolutionIntegerValue(response, y))\n\t\tfmt.Printf(\"z = %d\\n\", cpmodel.SolutionIntegerValue(response, z))\n\tdefault:\n\t\tfmt.Println(\"No solution found.\")\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := simpleSatProgram(); err != nil {\n\t\tlog.Exitf(\"simpleSatProgram returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CpSolverSolutionCallback for OR-Tools in Python\nDESCRIPTION: This code defines a SolutionPrinter class that extends the CpSolverSolutionCallback to print intermediate solutions during the solving process. It tracks the solution count and outputs the current solution number, elapsed time, and objective value.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/single_machine_scheduling_with_setup_release_due_dates_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self) -> None:\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        \"\"\"Called at each new solution.\"\"\"\n        print(\n            f\"Solution {self.__solution_count}, time = {self.wall_time} s,\"\n            f\" objective = {self.objective_value}\"\n        )\n```\n\n----------------------------------------\n\nTITLE: Creating Data Models for Scheduling in Python\nDESCRIPTION: This function creates dataframes representing the task scheduling parameters, including max load, min load, and tasks specifications. It outputs the data as three Pandas DataFrames.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cumulative_variable_profile_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"import io\\n\\nimport pandas as pd\\n\\nfrom ortools.sat.python import cp_model\\n\\ndef create_data_model() -\\u003e tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\\n    \\\"\\\"\\\"Creates the dataframes that describes the model.\\u0022\\u0022\\u0022\\n\\n    max_load_str: str = \\\"\\\"\\\"\\n  start_hour  max_load\\n     0            0\\n     2            0\\n     4            3\\n     6            6\\n     8            8\\n    10           12\\n    12            8\\n    14           12\\n    16           10\\n    18            6\\n    20            4\\n    22            0\\n  \\\"\\\"\\\"\\n\\n    min_load_str: str = \\\"\\\"\\\"\\n  start_hour  min_load\\n     0            0\\n     2            0\\n     4            0\\n     6            0\\n     8            3\\n    10            3\\n    12            1\\n    14            3\\n    16            3\\n    18            1\\n    20            1\\n    22            0\\n  \\\"\\\"\\\"\\n\\n    tasks_str: str = \\\"\\\"\\\"\\n  name  duration load  priority\\n   t1      60      3      2\\n   t2     180      2      1\\n   t3     240      5      3\\n   t4      90      4      2\\n   t5     120      3      1\\n   t6     300      3      3\\n   t7     120      1      2\\n   t8     100      5      2\\n   t9     110      2      1\\n   t10    300      5      3\\n   t11     90      4      2\\n   t12    120      3      1\\n   t13    250      3      3\\n   t14    120      1      2\\n   t15     40      5      3\\n   t16     70      4      2\\n   t17     90      8      1\\n   t18     40      3      3\\n   t19    120      5      2\\n   t20     60      3      2\\n   t21    180      2      1\\n   t22    240      5      3\\n   t23     90      4      2\\n   t24    120      3      1\\n   t25    300      3      3\\n   t26    120      1      2\\n   t27    100      5      2\\n   t28    110      2      1\\n   t29    300      5      3\\n   t30     90      4      2\\n  \\\"\\\"\\\"\\n\\n    max_load_df = pd.read_table(io.StringIO(max_load_str), sep=r\\\"\\\\s+\\\")\\n    min_load_df = pd.read_table(io.StringIO(min_load_str), sep=r\\\"\\\\s+\\\")\\n    tasks_df = pd.read_table(io.StringIO(tasks_str), index_col=0, sep=r\\\"\\\\s+\\\")\\n    return max_load_df, min_load_df, tasks_df\\n\"\n```\n\n----------------------------------------\n\nTITLE: Main Function Implementation for Job Scheduling\nDESCRIPTION: Defines the main entry point for the job scheduling program. It includes argument validation and calls the single machine scheduling function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/single_machine_scheduling_with_setup_release_due_dates_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    single_machine_scheduling()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Creating a Set Cover Instance in C++\nDESCRIPTION: This snippet demonstrates how to create an instance of the set covering problem using the SetCoverModel class. It adds subsets with their costs and elements to the model.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/README.md#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// If the elements are integers, a subset can be a std::vector<int> (in a pair\n// along its cost).\nstd::vector<std::pair<std::vector<int>, int>> subsets = ...;\n\nSetCoverModel model;\nfor (const auto [subset, subset_cost] : subsets) {\n  model.AddEmptySubset(subset_cost)\n  for (const int element : subset) {\n    model.AddElementToLastSubset(element);\n  }\n}\nSetCoverLedger ledger(&model);\n```\n\n----------------------------------------\n\nTITLE: Search All Solutions in C++ using OR-Tools\nDESCRIPTION: Shows how to configure the OR-Tools CP-SAT solver in C++ to enumerate all solutions for a constraint problem. Uses a solution observer callback to track and display each solution found.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/sat/sat_parameters.pb.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid SearchAllSolutionsSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  cp_model.AddNotEqual(x, y);\n\n  Model model;\n\n  int num_solutions = 0;\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"Solution \" << num_solutions;\n    LOG(INFO) << \"  x = \" << SolutionIntegerValue(r, x);\n    LOG(INFO) << \"  y = \" << SolutionIntegerValue(r, y);\n    LOG(INFO) << \"  z = \" << SolutionIntegerValue(r, z);\n    num_solutions++;\n  }));\n\n  // Tell the solver to enumerate all solutions.\n  SatParameters parameters;\n  parameters.set_enumerate_all_solutions(true);\n  model.Add(NewSatParameters(parameters));\n  const CpSolverResponse response = SolveCpModel(cp_model.Build(), &model);\n\n  LOG(INFO) << \"Number of solutions found: \" << num_solutions;\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::SearchAllSolutionsSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Circuit Constraints for Driver Scheduling\nDESCRIPTION: Sets up the circuit constraint to ensure that each driver follows a valid sequence of shifts with exactly one incoming and one outgoing literal for each node in the graph.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Create circuit constraint.\nmodel.add_exactly_one(outgoing_source_literals)\nfor s in range(num_shifts):\n    model.add_exactly_one(outgoing_literals[s])\n    model.add_exactly_one(incoming_literals[s])\nmodel.add_exactly_one(incoming_sink_literals)\n```\n\n----------------------------------------\n\nTITLE: Implementing Reified Constraints in C# with OR-Tools\nDESCRIPTION: This snippet demonstrates how to use reified constraints in C# using Google's OR-Tools library. It shows three different ways to implement logical constraints: using a half-reified bool and, using implications, and using bool or.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class ReifiedSampleSat\n{\n    static void Main()\n    {\n        CpModel model = new CpModel();\n\n        BoolVar x = model.NewBoolVar(\"x\");\n        BoolVar y = model.NewBoolVar(\"y\");\n        BoolVar b = model.NewBoolVar(\"b\");\n\n        //  First version using a half-reified bool and.\n        model.AddBoolAnd(new ILiteral[] { x, y.Not() }).OnlyEnforceIf(b);\n\n        // Second version using implications.\n        model.AddImplication(b, x);\n        model.AddImplication(b, y.Not());\n\n        // Third version using bool or.\n        model.AddBoolOr(new ILiteral[] { b.Not(), x });\n        model.AddBoolOr(new ILiteral[] { b.Not(), y.Not() });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating VRPTW Data Model\nDESCRIPTION: Initializes the data structure containing time matrix, time windows, number of vehicles and depot location for the VRPTW problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrptw_store_solution_data.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"time_matrix\"] = [\n        [0, 6, 9, 8, 7, 3, 6, 2, 3, 2, 6, 6, 4, 4, 5, 9, 7],\n        [6, 0, 8, 3, 2, 6, 8, 4, 8, 8, 13, 7, 5, 8, 12, 10, 14],\n        # ... matrix continues\n    ]\n    data[\"time_windows\"] = [\n        (0, 5),  # depot\n        (7, 12),  # 1\n        # ... time windows continue\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Constraint Programming Solution\nDESCRIPTION: Main implementation demonstrating constraint programming with OR-Tools. Creates three variables (x, y, z) with values between 0 and 2, adds a constraint that x != y, and finds all possible solutions using a simple search strategy.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/simple_cp_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the solver.\n    solver = pywrapcp.Solver(\"CPSimple\")\n\n    # Create the variables.\n    num_vals = 3\n    x = solver.IntVar(0, num_vals - 1, \"x\")\n    y = solver.IntVar(0, num_vals - 1, \"y\")\n    z = solver.IntVar(0, num_vals - 1, \"z\")\n\n    # Constraint 0: x != y.\n    solver.Add(x != y)\n    print(\"Number of constraints: \", solver.Constraints())\n\n    # Solve the problem.\n    decision_builder = solver.Phase(\n        [x, y, z], solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE\n    )\n\n    # Print solution on console.\n    count = 0\n    solver.NewSearch(decision_builder)\n    while solver.NextSolution():\n        count += 1\n        solution = f\"Solution {count}:\\n\"\n        for var in [x, y, z]:\n            solution += f\" {var.Name()} = {var.Value()}\"\n        print(solution)\n    solver.EndSearch()\n    print(f\"Number of solutions found: {count}\")\n\n    print(\"Advanced usage:\")\n    print(f\"Problem solved in {solver.WallTime()}ms\")\n    print(f\"Memory usage: {pywrapcp.Solver.MemoryUsage()}bytes\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package required to run subsequent examples of interval variable creation in Google Colab using the Python CP-SAT module. The 'ortools' package is mandatory for accessing constraint programming and optimization functionalities provided by Google OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/interval_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Parsing Arguments and Setting Defaults in Python\nDESCRIPTION: This code snippet parses the command-line arguments using `parser.parse_args()` and assigns the parsed values to the `args` variable. It then sets a default value for `num_matches_per_day` if it's not provided, calculates the number of available CPUs using `os.sched_getaffinity(0)` (if available), and sets a default value for the number of CPU workers (`cpu`) based on the system's capabilities.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nargs = parser.parse_args()\n\n    # set default for num_matchdays\n    num_matches_per_day = args.num_matches_per_day\n    if not num_matches_per_day:\n        num_matches_per_day = args.num_teams // 2\n    ncpu = 8\n    try:\n        ncpu = len(os.sched_getaffinity(0))\n    except AttributeError:\n        pass\n    cpu = args.cpu\n    if not cpu:\n        cpu = min(6, ncpu)\n        print('Setting number of search workers to %i' % cpu)\n\n    if cpu > ncpu:\n        print(\n            'You asked for %i workers to be used, but the os only reports %i CPUs available.  This might slow down processing'\n            % (cpu, ncpu))\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Execution Logic for Minesweeper Solver\nDESCRIPTION: Sets up the main execution logic to either use a provided problem file or run with the default configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/minesweeper.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  print(\"Problem instance from\", file)\n  [game, rows, cols] = read_problem(file)\n  main(game, rows, cols)\nelse:\n  main()\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple LP\nDESCRIPTION: This function defines a small linear programming (LP) problem using the `pdlp.QuadraticProgram` class from the OR-Tools library. It sets the objective function, constraint bounds, variable bounds, and constraint matrix for the LP problem. The constraint matrix is created using `scipy.sparse.csc_matrix` for efficient storage of sparse data.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/pdlp/simple_pdlp_program.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef simple_lp() -> pdlp.QuadraticProgram:\n    \"\"\"Returns a small LP.\n\n    min 5.5 x_0 - 2 x_1 - x_2 +   x_3 - 14 s.t.\n        2 x_0 +     x_1 +   x_2 + 2 x_3  = 12\n          x_0 +             x_2          <=  7\n        4 x_0                            >=  -4\n       -1 <=            1.5 x_2 -   x_3  <= 1\n      -infinity <= x_0 <= infinity\n             -2 <= x_1 <= infinity\n      -infinity <= x_2 <= 6\n            2.5 <= x_3 <= 3.5\n    \"\"\"\n    lp = pdlp.QuadraticProgram()\n    lp.objective_offset = -14\n    lp.objective_vector = [5.5, -2, -1, 1]\n    lp.constraint_lower_bounds = [12, -np.inf, -4, -1]\n    lp.constraint_upper_bounds = [12, 7, np.inf, 1]\n    lp.variable_lower_bounds = [-np.inf, -2, -np.inf, 2.5]\n    lp.variable_upper_bounds = [np.inf, np.inf, 6, 3.5]\n    # Most use cases should initialize the sparse constraint matrix without\n    # constructing a dense matrix first! We use a np.array here for convenience\n    # only.\n    constraint_matrix = np.array(\n        [[2, 1, 1, 2], [1, 0, 1, 0], [4, 0, 0, 0], [0, 0, 1.5, -1]]\n    )\n    lp.constraint_matrix = scipy.sparse.csc_matrix(constraint_matrix)\n    return lp\n```\n\n----------------------------------------\n\nTITLE: Initializing C++ Bridge and Running Main Function\nDESCRIPTION: This section initializes the C++ bridge for OR-Tools, sets logging and flag configurations, and finally calls the `main()` function to execute the LP solving process. The logging configuration helps in debugging and monitoring the execution of the solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/pdlp/simple_pdlp_program.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ninit.CppBridge.init_logging(\"simple_pdlp_program.py\")\ncpp_flags = init.CppFlags()\ncpp_flags.stderrthreshold = 0\ncpp_flags.log_prefix = False\ninit.CppBridge.set_flags(cpp_flags)\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Two Machine Job Scheduling with OR-Tools CP-SAT Solver\nDESCRIPTION: Solves a scheduling optimization problem where jobs with specific durations and widths must be assigned to two parallel machines. The solution ensures no machine overlaps, respects maximum width constraints, and minimizes the maximum completion time (makespan). Uses interval variables and cumulative constraints to model the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/README.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom google3.util.operations_research.sat.python import cp_model\nfrom google3.util.operations_research.sat.colab import visualization\n\n\ndef TwoMachineScheduling():\n  model = cp_model.CpModel()\n\n  jobs = [[3, 3],  # (duration, width)\n          [2, 5],\n          [1, 3],\n          [3, 7],\n          [7, 3],\n          [2, 2],\n          [2, 2],\n          [5, 5],\n          [10, 2],\n          [4, 3],\n          [2, 6],\n          [1, 2],\n          [6, 8],\n          [4, 5],\n          [3, 7]]\n\n  max_width = 10\n\n  horizon = sum(t[0] for t in jobs)\n  num_jobs = len(jobs)\n  all_jobs = range(num_jobs)\n\n  intervals = []\n  intervals0 = []\n  intervals1 = []\n  performed = []\n  starts = []\n  ends = []\n  demands = []\n\n  for i in all_jobs:\n    # Create main interval (to be used in the cumulative constraint).\n    start = model.NewIntVar(0, horizon, 'start_%i' % i)\n    duration = jobs[i][0]\n    end = model.NewIntVar(0, horizon, 'end_%i' % i)\n    interval = model.NewIntervalVar(start, duration, end, 'interval_%i' % i)\n    starts.append(start)\n    intervals.append(interval)\n    ends.append(end)\n    demands.append(jobs[i][1])\n\n    performed_on_m0 = model.NewBoolVar('perform_%i_on_m0' % i)\n    performed.append(performed_on_m0)\n\n    # Create an optional copy of interval to be executed on machine 0.\n    start0 = model.NewIntVar(\n        0, horizon, 'start_%i_on_m0' % i)\n    end0 = model.NewIntVar(\n        0, horizon, 'end_%i_on_m0' % i)\n    interval0 = model.NewOptionalIntervalVar(\n        start0, duration, end0, performed_on_m0, 'interval_%i_on_m0' % i)\n    intervals0.append(interval0)\n\n    # Create an optional copy of interval to be executed on machine 1.\n    start1 = model.NewIntVar(\n        0, horizon, 'start_%i_on_m1' % i)\n    end1 = model.NewIntVar(\n        0, horizon, 'end_%i_on_m1' % i)\n    interval1 = model.NewOptionalIntervalVar(\n        start1, duration, end1, performed_on_m0.Not(), 'interval_%i_on_m1' % i)\n    intervals1.append(interval1)\n\n    # We only propagate the constraint if the task is performed on the machine.\n    model.Add(start0 == start).OnlyEnforceIf(performed_on_m0)\n    model.Add(start1 == start).OnlyEnforceIf(performed_on_m0.Not())\n\n  # Max width constraint (modeled as a cumulative).\n  model.AddCumulative(intervals, demands, max_width)\n\n  # Choose which machine to perform the jobs on.\n  model.AddNoOverlap(intervals0)\n  model.AddNoOverlap(intervals1)\n\n  # Objective variable.\n  makespan = model.NewIntVar(0, horizon, 'makespan')\n  model.AddMaxEquality(makespan, ends)\n  model.Minimize(makespan)\n\n  # Symmetry breaking.\n  model.Add(performed[0] == 0)\n\n  # Solve model.\n  solver = cp_model.CpSolver()\n  solver.Solve(model)\n\n  # Output solution.\n  output = visualization.SvgWrapper(solver.ObjectiveValue(), max_width, 40.0)\n  output.AddTitle('Makespan = %i' % solver.ObjectiveValue())\n  color_manager = visualization.ColorManager()\n  color_manager.SeedRandomColor(0)\n  for i in all_jobs:\n    performed_machine = 1 - solver.Value(performed[i])\n    start = solver.Value(starts[i])\n    dx = jobs[i][0]\n    dy = jobs[i][1]\n    sy = performed_machine * (max_width - dy)\n    output.AddRectangle(start, sy, dx, dy, color_manager.RandomColor(), 'black',\n                        'j%i' % i)\n\n  output.AddXScale()\n  output.AddYScale()\n  output.Display()\n\n\nTwoMachineScheduling()\n```\n\n----------------------------------------\n\nTITLE: Distance Evaluator Generator\nDESCRIPTION: Creates a callback function that returns precomputed distances between locations. Handles special cases for start/end/reload nodes and uses Manhattan distance for regular nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrp_reload.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_distance_evaluator(data):\n    \"\"\"Creates callback to return distance between points.\"\"\"\n    _distances = {}\n    # precompute distance between location to have distance callback in O(1)\n    for from_node in range(data[\"num_locations\"]):\n        _distances[from_node] = {}\n        for to_node in range(data[\"num_locations\"]):\n            if from_node == to_node:\n                _distances[from_node][to_node] = 0\n            # Forbid start/end/reload node to be consecutive.\n            elif from_node in range(6) and to_node in range(6):\n                _distances[from_node][to_node] = data[\"vehicle_max_distance\"]\n            else:\n                _distances[from_node][to_node] = manhattan_distance(\n                    data[\"locations\"][from_node], data[\"locations\"][to_node]\n                )\n\n    def distance_evaluator(manager, from_node, to_node):\n        \"\"\"Returns the manhattan distance between the two nodes\"\"\"\n        return _distances[manager.IndexToNode(from_node)][manager.IndexToNode(to_node)]\n\n    return distance_evaluator\n```\n\n----------------------------------------\n\nTITLE: Creating Interval Variables in Go with CP-SAT Solver\nDESCRIPTION: This Go code demonstrates how to create different types of interval variables using the CP-SAT solver. It shows creating an interval from three expressions, creating a fixed-size interval from a start expression and constant size, and creating a completely fixed interval with specific start and size values.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// The interval_sample_sat_go command is a simple example of the Interval variable.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n)\n\nconst horizon = 100\n\nfunc intervalSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\tdomain := cpmodel.NewDomain(0, horizon)\n\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVar(2, 4).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\n\t// An interval can be created from three affine expressions.\n\tintervalVar := model.NewIntervalVar(x, y, cpmodel.NewConstant(2).Add(z)).WithName(\"interval\")\n\n\t// If the size is fixed, a simpler version uses the start expression and the size.\n\tfixedSizeIntervalVar := model.NewFixedSizeIntervalVar(x, 10).WithName(\"fixedSizeInterval\")\n\n\t// A fixed interval can be created using the same API.\n\tfixedIntervalVar := model.NewFixedSizeIntervalVar(cpmodel.NewConstant(5), 10).WithName(\"fixedInterval\")\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tfmt.Printf(\"%v\\n\", m.GetConstraints()[intervalVar.Index()])\n\tfmt.Printf(\"%v\\n\", m.GetConstraints()[fixedSizeIntervalVar.Index()])\n\tfmt.Printf(\"%v\\n\", m.GetConstraints()[fixedIntervalVar.Index()])\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := intervalSampleSat(); err != nil {\n\t\tlog.Exitf(\"intervalSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Sample Builds for OR-Tools\nDESCRIPTION: This snippet sets up the compilation of C++ samples for OR-Tools. It glob matches all .cc files, excludes specific files related to CVRP and CVRPTW, and adds each remaining sample to the build process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"/cvrp_disjoint_tw\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"/cvrptw\\.cc\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"/cvrptw_\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Costas Array Solver Implementation\nDESCRIPTION: Main implementation of the Costas array solver using OR-Tools constraint solver. Defines variables, constraints, and search strategy to find all valid Costas arrays of a given size. Includes validation of differences triangle and solution visualization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/costas_array.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(n=6):\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Costas array\")\n\n  #\n  # data\n  #\n  print(\"n:\", n)\n\n  #\n  # declare variables\n  #\n  costas = [solver.IntVar(1, n, \"costas[%i]\" % i) for i in range(n)]\n  differences = {}\n  for i in range(n):\n    for j in range(n):\n      differences[(i, j)] = solver.IntVar(-n + 1, n - 1,\n                                          \"differences[%i,%i]\" % (i, j))\n  differences_flat = [differences[i, j] for i in range(n) for j in range(n)]\n\n  #\n  # constraints\n  #\n\n  # Fix the values in the lower triangle in the\n  # difference matrix to -n+1. This removes variants\n  # of the difference matrix for the same Costas array.\n  for i in range(n):\n    for j in range(i + 1):\n      solver.Add(differences[i, j] == -n + 1)\n\n  # hakank: All the following constraints are from\n  # Barry O'Sullivans's original model.\n  #\n  solver.Add(solver.AllDifferent(costas))\n\n  # \"How do the positions in the Costas array relate\n  #  to the elements of the distance triangle.\"\n  for i in range(n):\n    for j in range(n):\n      if i < j:\n        solver.Add(differences[(i, j)] == costas[j] - costas[j - i - 1])\n\n  # \"All entries in a particular row of the difference\n  #  triangle must be distint.\"\n  for i in range(n - 2):\n    solver.Add(\n        solver.AllDifferent([differences[i, j] for j in range(n) if j > i]))\n\n  #\n  # \"All the following are redundant - only here to speed up search.\"\n  #\n\n  # \"We can never place a 'token' in the same row as any other.\"\n  for i in range(n):\n    for j in range(n):\n      if i < j:\n        solver.Add(differences[i, j] != 0)\n\n  for k in range(2, n):\n    for l in range(2, n):\n      if k < l:\n        solver.Add(differences[k - 2, l - 1] + differences[k, l] ==\n                   differences[k - 1, l - 1] + differences[k - 1, l])\n\n  #\n  # search and result\n  #\n  db = solver.Phase(costas + differences_flat, solver.CHOOSE_FIRST_UNBOUND,\n                    solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"costas:\", [costas[i].Value() for i in range(n)])\n    print(\"differences:\")\n    for i in range(n):\n      for j in range(n):\n        v = differences[i, j].Value()\n        if v == -n + 1:\n          print(\"  \", end=\" \")\n        else:\n          print(\"%2d\" % v, end=\" \")\n      print()\n    print()\n    num_solutions += 1\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nn = 6\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\nmain(n)\n```\n\n----------------------------------------\n\nTITLE: Least Difference Problem Implementation\nDESCRIPTION: Main implementation that creates a constraint solver to find the smallest difference between two numbers using digits 0-9. Uses OR-Tools constraint solver to define variables, constraints, and optimization objective. Includes solution collection and performance metrics output.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/least_diff.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(unused_argv):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Least diff\")\n\n  #\n  # declare variables\n  #\n  digits = list(range(0, 10))\n  a = solver.IntVar(digits, \"a\")\n  b = solver.IntVar(digits, \"b\")\n  c = solver.IntVar(digits, \"c\")\n  d = solver.IntVar(digits, \"d\")\n  e = solver.IntVar(digits, \"e\")\n\n  f = solver.IntVar(digits, \"f\")\n  g = solver.IntVar(digits, \"g\")\n  h = solver.IntVar(digits, \"h\")\n  i = solver.IntVar(digits, \"i\")\n  j = solver.IntVar(digits, \"j\")\n\n  letters = [a, b, c, d, e, f, g, h, i, j]\n\n  digit_vector = [10000, 1000, 100, 10, 1]\n  x = solver.ScalProd(letters[0:5], digit_vector)\n  y = solver.ScalProd(letters[5:], digit_vector)\n  diff = x - y\n\n  #\n  # constraints\n  #\n  solver.Add(diff > 0)\n  solver.Add(solver.AllDifferent(letters))\n\n  # objective\n  objective = solver.Minimize(diff, 1)\n\n  #\n  # solution\n  #\n  solution = solver.Assignment()\n  solution.Add(letters)\n  solution.Add(x)\n  solution.Add(y)\n  solution.Add(diff)\n\n  # last solution since it's a minimization problem\n  collector = solver.LastSolutionCollector(solution)\n  search_log = solver.SearchLog(100, diff)\n  # Note: I'm not sure what CHOOSE_PATH do, but it is fast:\n  #       find the solution in just 4 steps\n  solver.Solve(\n      solver.Phase(letters, solver.CHOOSE_PATH, solver.ASSIGN_MIN_VALUE),\n      [objective, search_log, collector])\n\n  # get the first (and only) solution\n\n  xval = collector.Value(0, x)\n  yval = collector.Value(0, y)\n  diffval = collector.Value(0, diff)\n  print(\"x:\", xval)\n  print(\"y:\", yval)\n  print(\"diff:\", diffval)\n  print(xval, \"-\", yval, \"=\", diffval)\n  print([(\"abcdefghij\" [i], collector.Value(0, letters[i])) for i in range(10)])\n  print()\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print()\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Creating Constraints for Transitions Between Shifts\nDESCRIPTION: Implements constraints for transitions between different shifts, handling driving time accumulation, no-break driving rules, and adding arcs to the circuit constraint with appropriate literals for tracking delays.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfor o in range(num_shifts):\n    other = shifts[o]\n    delay = other[3] - shift[4]\n    if delay < min_delay_between_shifts:\n        continue\n    lit = model.new_bool_var(\"%i from %i to %i\" % (d, s, o))\n\n    # Increase driving time\n    model.add(\n        total_driving[d, o] == total_driving[d, s] + other[5]\n    ).only_enforce_if(lit)\n\n    # Increase no_break_driving or reset it to 0 depending on the delay\n    if delay >= min_pause_after_4h:\n        model.add(no_break_driving[d, o] == other[5]).only_enforce_if(lit)\n    else:\n        model.add(\n            no_break_driving[d, o] == no_break_driving[d, s] + other[5]\n        ).only_enforce_if(lit)\n\n    # add arc\n    outgoing_literals[s].append(lit)\n    shared_outgoing_literals[s].append(lit)\n    incoming_literals[o].append(lit)\n    shared_incoming_literals[o].append(lit)\n\n    # Cost part\n    delay_literals.append(lit)\n    delay_weights.append(delay)\n```\n\n----------------------------------------\n\nTITLE: Solving CP-SAT Model with Intermediate Solutions in C#\nDESCRIPTION: This C# code creates a CP-SAT model with three variables, adds constraints, and solves it while printing intermediate solutions. It uses a custom solution callback to capture and display each solution found during the optimization process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class VarArraySolutionPrinterWithObjective : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinterWithObjective(IntVar[] variables)\n    {\n        variables_ = variables;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        Console.WriteLine(String.Format(\"Solution #{0}: time = {1:F2} s\", solution_count_, WallTime()));\n        Console.WriteLine(String.Format(\"  objective value = {0}\", ObjectiveValue()));\n        foreach (IntVar v in variables_)\n        {\n            Console.WriteLine(String.Format(\"  {0} = {1}\", v.ToString(), Value(v)));\n        }\n        solution_count_++;\n    }\n\n    public int SolutionCount()\n    {\n        return solution_count_;\n    }\n\n    private int solution_count_;\n    private IntVar[] variables_;\n}\n\npublic class SolveAndPrintIntermediateSolutionsSampleSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n\n        // Creates the variables.\n        int num_vals = 3;\n\n        IntVar x = model.NewIntVar(0, num_vals - 1, \"x\");\n        IntVar y = model.NewIntVar(0, num_vals - 1, \"y\");\n        IntVar z = model.NewIntVar(0, num_vals - 1, \"z\");\n\n        // Adds a different constraint.\n        model.Add(x != y);\n\n        // Maximizes a linear combination of variables.\n        model.Maximize(x + 2 * y + 3 * z);\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        VarArraySolutionPrinterWithObjective cb = new VarArraySolutionPrinterWithObjective(new IntVar[] { x, y, z });\n        solver.Solve(model, cb);\n\n        Console.WriteLine(String.Format(\"Number of solutions found: {0}\", cb.SolutionCount()));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Processing and Displaying Solution for Driver Minimization\nDESCRIPTION: Handles the case when minimizing the number of drivers by extracting and returning the objective value, which represents the minimal number of drivers needed.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Display solution\nif minimize_drivers:\n    max_num_drivers = int(solver.objective_value)\n    print(\"minimal number of drivers =\", max_num_drivers)\n    return max_num_drivers\n```\n\n----------------------------------------\n\nTITLE: Regular Constraint Implementation for DFA State Transitions\nDESCRIPTION: Implementation of a regular constraint that ensures state transitions follow a valid DFA pattern. The function handles state transitions for the Three Jugs problem using a transition matrix and accepting states.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_regular.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef regular(x, Q, S, d, q0, F):\n\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    row = []\n    for j in range(S):\n      if i == 0:\n        row.append(0)\n      else:\n        row.append(d[i - 1][j])\n    d2.append(row)\n\n  d2_flatten = [d2[i][j] for i in range(Q + 1) for j in range(S)]\n\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n\n  a = [solver.IntVar(0, Q + 1, 'a[%i]' % i) for i in range(m, n + 1)]\n\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n\n    solver.Add(\n        a[i + 1] == solver.Element(d2_flatten, ((a[i]) * S) + (x[i] - 1)))\n```\n\n----------------------------------------\n\nTITLE: Solution Printer Implementation\nDESCRIPTION: Function to print the solution showing dropped nodes, routes for each vehicle, distances traveled and values collected\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(\n    solver: cp_model.CpSolver,\n    visited_nodes: dict[int, list[cp_model.IntVar]],\n    used_arcs: dict[int, dict[tuple[int, int], cp_model.IntVar]],\n    num_nodes: int,\n    num_vehicles: int,\n) -> None:\n    \"\"\"Prints solution on console.\"\"\"\n    # Display dropped nodes.\n    dropped_nodes = \"Dropped nodes:\"\n    for node in range(num_nodes):\n        if node == 0:\n            continue\n        is_visited = sum(\n            [solver.boolean_value(visited_nodes[v][node]) for v in range(num_vehicles)]\n        )\n        if not is_visited:\n            dropped_nodes += f\" {node}({VISIT_VALUES[node]})\"\n    print(dropped_nodes)\n    # Display routes\n    total_distance = 0\n    total_value_collected = 0\n    for v in range(num_vehicles):\n        current_node = 0\n        plan_output = f\"Route for vehicle {v}:\\n\"\n        route_distance = 0\n        value_collected = 0\n        route_is_finished = False\n        while not route_is_finished:\n            value_collected += VISIT_VALUES[current_node]\n            plan_output += f\" {current_node} ->\"\n            # find next node\n            for node in range(num_nodes):\n                if node == current_node:\n                    continue\n                if solver.boolean_value(used_arcs[v][current_node, node]):\n                    route_distance += DISTANCE_MATRIX[current_node][node]\n                    current_node = node\n                    if current_node == 0:\n                        route_is_finished = True\n                    break\n        plan_output += f\" {current_node}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        plan_output += f\"value collected: {value_collected}\\n\"\n        print(plan_output)\n        total_distance += route_distance\n        total_value_collected += value_collected\n    print(f\"Total Distance: {total_distance}m\")\n    print(f\"Total value collected: {total_value_collected}/{sum(VISIT_VALUES)}\")\n```\n\n----------------------------------------\n\nTITLE: Boolean OR Constraint in C++\nDESCRIPTION: Demonstrates how to implement a boolean OR constraint between variables in C++ using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n#include <stdlib.h>\n\n#include \"absl/types/span.h\"\n#include \"ortools/sat/cp_model.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid BoolOrSampleSat() {\n  CpModelBuilder cp_model;\n\n  const BoolVar x = cp_model.NewBoolVar();\n  const BoolVar y = cp_model.NewBoolVar();\n  cp_model.AddBoolOr({x, ~y});\n  // You can also use the ~ operator.\n  cp_model.AddBoolOr({x, ~y});\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::BoolOrSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Main Execution for Solving Match Scheduling in Python\nDESCRIPTION: Defines the entry point of the program used to solve the sports league match scheduling problem. It includes argument parsing for input parameters such as the number of teams and matchdays in the league schedule.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    parser = argparse.ArgumentParser(\n        description='Solve sports league match play assignment problem')\n    parser.add_argument('-t,--teams',\n                        type=int,\n                        dest='num_teams',\n                        default=10,\n                        help='Number of teams in the league')\n\n    parser.add_argument(\n        '-d,--days',\n        type=int,\n```\n\n----------------------------------------\n\nTITLE: Printing VRP Solution in Python\nDESCRIPTION: Defines a function to print the solution of the Vehicle Routing Problem, including route details and distances for each vehicle.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_starts_ends.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(solution, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools and Defining Main Function for Secret Santa Problem\nDESCRIPTION: This snippet imports the necessary OR-Tools module and defines the main function that sets up and solves the Secret Santa problem. It includes data structures for participants, spouses, and previous gift exchanges.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/secret_santa2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main(singe=0):\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Secret Santa problem II')\n\n  #\n  # data\n  #\n\n  #\n  # The matrix version of earlier rounds.\n  # M means that no earlier Santa has been assigned.\n  # Note: Ryan and Mia has the same recipient for years 3 and 4,\n  #       and Ella and John has for year 4.\n  #       This seems to be caused by modification of\n  #       original data.\n  #\n  n_no_single = 8\n  M = n_no_single + 1\n  rounds_no_single = [\n      # N  A  R  M  El J  L  Ev\n      [0, M, 3, M, 1, 4, M, 2],  # Noah\n      [M, 0, 4, 2, M, 3, M, 1],  # Ava\n      [M, 2, 0, M, 1, M, 3, 4],  # Ryan\n      [M, 1, M, 0, 2, M, 3, 4],  # Mia\n      [M, 4, M, 3, 0, M, 1, 2],  # Ella\n      [1, 4, 3, M, M, 0, 2, M],  # John\n      [M, 3, M, 2, 4, 1, 0, M],  # Lily\n      [4, M, 3, 1, M, 2, M, 0]  # Evan\n  ]\n\n  #\n  # Rounds with a single person (fake data)\n  #\n  n_with_single = 9\n  M = n_with_single + 1\n  rounds_single = [\n      # N  A  R  M  El J  L  Ev S\n      [0, M, 3, M, 1, 4, M, 2, 2],  # Noah\n      [M, 0, 4, 2, M, 3, M, 1, 1],  # Ava\n      [M, 2, 0, M, 1, M, 3, 4, 4],  # Ryan\n      [M, 1, M, 0, 2, M, 3, 4, 3],  # Mia\n      [M, 4, M, 3, 0, M, 1, 2, M],  # Ella\n      [1, 4, 3, M, M, 0, 2, M, M],  # John\n      [M, 3, M, 2, 4, 1, 0, M, M],  # Lily\n      [4, M, 3, 1, M, 2, M, 0, M],  # Evan\n      [1, 2, 3, 4, M, 2, M, M, 0]  # Single\n  ]\n```\n\n----------------------------------------\n\nTITLE: LIFO Policy Pickup & Delivery Implementation\nDESCRIPTION: Implementation of Pickup & Delivery routing with Last-In-First-Out (LIFO) policy, ensuring the most recently picked up items are delivered first.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/PDP.md#2025-04-17_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvrp_pickup_delivery_lifo.cc\n```\n\nLANGUAGE: Python\nCODE:\n```\nvrp_pickup_delivery_lifo.py\n```\n\nLANGUAGE: Java\nCODE:\n```\nVrpPickupDeliveryLifo.java\n```\n\nLANGUAGE: C#\nCODE:\n```\nVrpPickupDeliveryLifo.cs\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Covering Problem with Google CP Solver\nDESCRIPTION: Defines the main function that sets up and solves the set covering problem using Google's CP Solver. It includes data initialization, variable creation, constraint definition, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering_skiena.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Set covering Skiena')\n\n  #\n  # data\n  #\n  num_sets = 7\n  num_elements = 12\n  belongs = [\n      # 1 2 3 4 5 6 7 8 9 0 1 2  elements\n      [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # Set 1\n      [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],  # 2\n      [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],  # 3\n      [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0],  # 4\n      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],  # 5\n      [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0],  # 6\n      [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]  # 7\n  ]\n\n  #\n  # variables\n  #\n  x = [solver.IntVar(0, 1, 'x[%i]' % i) for i in range(num_sets)]\n\n  # number of choosen sets\n  z = solver.IntVar(0, num_sets * 2, 'z')\n\n  # total number of elements in the choosen sets\n  tot_elements = solver.IntVar(0, num_sets * num_elements)\n\n  #\n  # constraints\n  #\n  solver.Add(z == solver.Sum(x))\n\n  # all sets must be used\n  for j in range(num_elements):\n    s = solver.Sum([belongs[i][j] * x[i] for i in range(num_sets)])\n    solver.Add(s >= 1)\n\n  # number of used elements\n  solver.Add(tot_elements == solver.Sum([\n      x[i] * belongs[i][j] for i in range(num_sets) for j in range(num_elements)\n  ]))\n\n  # objective\n  objective = solver.Minimize(z, 1)\n\n  #\n  # search and result\n  #\n  db = solver.Phase(x, solver.INT_VAR_DEFAULT, solver.INT_VALUE_DEFAULT)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print('z:', z.Value())\n    print('tot_elements:', tot_elements.Value())\n    print('x:', [x[i].Value() for i in range(num_sets)])\n\n  solver.EndSearch()\n\n  print()\n  print('num_solutions:', num_solutions)\n  print('failures:', solver.Failures())\n  print('branches:', solver.Branches())\n  print('WallTime:', solver.WallTime(), 'ms')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Creating Transit Time Callback for OR-Tools Routing\nDESCRIPTION: A method that returns a callback function calculating transit time between nodes based on distance and average speed. The transit time is computed by dividing the distance by the speed and converting to appropriate time units.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndef make_transit_time_callback(self, speed_kmph=10):\n    \"\"\"\n    Creates a callback function for transit time. Assuming an average\n    speed of speed_kmph\n    Args:\n        speed_kmph: the average speed in km/h\n\n    Returns:\n        function [transit_time_return(a, b)]: A function that takes the\n            from/a node index and the to/b node index and returns the\n            transit time from a to b.\n    \"\"\"\n\n    def transit_time_return(a, b):\n        return (self.distmat[a][b] / (speed_kmph * 1.0 / 60**2))\n\n    return transit_time_return\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for VRP\nDESCRIPTION: Defines a function to create and return a data model containing the distance matrix, number of vehicles, and depot location for the VRP.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_solution_callback.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"distance_matrix\"] = [\n        # fmt: off\n      [0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662],\n      [548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210],\n      [776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754],\n      [696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358],\n      [582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244],\n      [274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708],\n      [502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480],\n      [194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856],\n      [308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514],\n      [194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468],\n      [536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354],\n      [502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844],\n      [388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730],\n      [354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536],\n      [468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194],\n      [776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798],\n      [662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0],\n        # fmt: on\n    ]\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    return data\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools Init Library Build with CMake\nDESCRIPTION: Configures the build settings for the OR-Tools initialization library component. Sets up the library as an object library with position-independent code, configures include directories, and links required dependencies including Abseil and Protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_init)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  LINKER_LANGUAGE CXX\n  POSITION_INDEPENDENT_CODE ON\n  )\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::flags\n  absl::strings\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::init ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Implementing Earliness-Tardiness Cost Function in Python using OR-Tools\nDESCRIPTION: Creates a piecewise linear function for scheduling optimization that penalizes early and late deliveries differently. Uses CP-SAT solver to model the convex function with three segments.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Encodes a convex piecewise linear function.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n\ndef earliness_tardiness_cost_sample_sat():\n    \"\"\"Encode the piecewise linear expression.\"\"\"\n\n    earliness_date = 5  # ed.\n    earliness_cost = 8\n    lateness_date = 15  # ld.\n    lateness_cost = 12\n\n    # Model.\n    model = cp_model.CpModel()\n\n    # Declare our primary variable.\n    x = model.new_int_var(0, 20, \"x\")\n\n    # Create the expression variable and implement the piecewise linear function.\n    #\n    #  \\        /\n    #   \\______/\n    #   ed    ld\n    #\n    large_constant = 1000\n    expr = model.new_int_var(0, large_constant, \"expr\")\n\n    # First segment.\n    s1 = model.new_int_var(-large_constant, large_constant, \"s1\")\n    model.add(s1 == earliness_cost * (earliness_date - x))\n\n    # Second segment.\n    s2 = 0\n\n    # Third segment.\n    s3 = model.new_int_var(-large_constant, large_constant, \"s3\")\n    model.add(s3 == lateness_cost * (x - lateness_date))\n\n    # Link together expr and x through s1, s2, and s3.\n    model.add_max_equality(expr, [s1, s2, s3])\n\n    # Search for x values in increasing order.\n    model.add_decision_strategy([x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE)\n\n    # Create a solver and solve with a fixed search.\n    solver = cp_model.CpSolver()\n\n    # Force the solver to follow the decision strategy exactly.\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n\n    # Search and print out all solutions.\n    solution_printer = VarArraySolutionPrinter([x, expr])\n    solver.solve(model, solution_printer)\n\n\nearlines_tardiness_cost_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: OR-Tools Package Installation\nDESCRIPTION: Installation command for the Google OR-Tools package via pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp_distance_matrix.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Additional Solvers in CMake for OR-Tools\nDESCRIPTION: This snippet sets up CMake options for various solvers including GLOP, GLPK, Gurobi, HiGHS, PDLP, SCIP, CPLEX, and XPRESS. It includes options to use and build these solvers as part of the OR-Tools project.\nSOURCE: https://github.com/google/or-tools/blob/stable/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nCMAKE_DEPENDENT_OPTION(USE_GLOP \"Use the GLOP solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"GLOP support: ${USE_GLOP}\")\n\nCMAKE_DEPENDENT_OPTION(USE_GLPK \"Use the GLPK solver\" OFF \"BUILD_CXX\" OFF)\nmessage(STATUS \"GLPK support: ${USE_GLPK}\")\nif(USE_GLPK)\n  CMAKE_DEPENDENT_OPTION(BUILD_GLPK \"Build the GLPK dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\nelse()\n  set(BUILD_GLPK OFF)\nendif()\nmessage(STATUS \"Build GLPK: ${BUILD_GLPK}\")\n\nCMAKE_DEPENDENT_OPTION(USE_GUROBI \"Use the Gurobi solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"Gurobi support: ${USE_GUROBI}\")\n\nCMAKE_DEPENDENT_OPTION(USE_HIGHS \"Use the HiGHS solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"HiGHS support: ${USE_HIGHS}\")\nif(USE_HIGHS)\n  CMAKE_DEPENDENT_OPTION(BUILD_HIGHS \"Build the HiGHS dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\nelse()\n  set(BUILD_HIGHS OFF)\nendif()\nmessage(STATUS \"Build HiGHS: ${BUILD_HIGHS}\")\n\nCMAKE_DEPENDENT_OPTION(USE_PDLP \"Use the PDLP solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"PDLP support: ${USE_PDLP}\")\nif(USE_PDLP)\n  CMAKE_DEPENDENT_OPTION(BUILD_PDLP \"Build the PDLP dependency Library\" ON\n    \"NOT BUILD_DEPS\" ON)\nelse()\n  set(BUILD_PDLP OFF)\nendif()\nmessage(STATUS \"Build PDLP: ${BUILD_PDLP}\")\n\nCMAKE_DEPENDENT_OPTION(USE_SCIP \"Use the Scip solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"SCIP support: ${USE_SCIP}\")\nif(USE_SCIP)\n  CMAKE_DEPENDENT_OPTION(BUILD_SCIP \"Build the SCIP dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\nelse()\n  set(BUILD_SCIP OFF)\nendif()\nmessage(STATUS \"Build SCIP: ${BUILD_SCIP}\")\n\noption(USE_CPLEX \"Use the CPLEX solver\" OFF)\nmessage(STATUS \"CPLEX support: ${USE_CPLEX}\")\n\nCMAKE_DEPENDENT_OPTION(USE_XPRESS \"Use the Xpress solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"Xpress support: ${USE_XPRESS}\")\n```\n\n----------------------------------------\n\nTITLE: Printing Solution for Vehicle Routing Problem in Python with OR-Tools\nDESCRIPTION: Function that prints the routing solution including objective value, dropped nodes with their values, routes for each vehicle with distances, values collected, and overall totals. This is used to display the results of the OR-Tools vehicle routing solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f'Objective: {assignment.ObjectiveValue()}')\n   # Display dropped nodes.\n    dropped_nodes = 'Dropped nodes:'\n    for index in range(routing.Size()):\n        if routing.IsStart(index) or routing.IsEnd(index):\n            continue\n        if assignment.Value(routing.NextVar(index)) == index:\n            node = manager.IndexToNode(index)\n            dropped_nodes += f' {node}({VISIT_VALUES[node]})'\n    print(dropped_nodes)\n    # Display routes\n    total_distance = 0\n    total_value_collected = 0\n    for v in range(manager.GetNumberOfVehicles()):\n        index = routing.Start(v)\n        plan_output = f'Route for vehicle {v}:\\n'\n        route_distance = 0\n        value_collected = 0\n        while not routing.IsEnd(index):\n            node = manager.IndexToNode(index)\n            value_collected += VISIT_VALUES[node]\n            plan_output += f' {node} ->'\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(previous_index, index, v)\n        plan_output += f' {manager.IndexToNode(index)}\\n'\n        plan_output += f'Distance of the route: {route_distance}m\\n'\n        plan_output += f'Value collected: {value_collected}\\n'\n        print(plan_output)\n        total_distance += route_distance\n        total_value_collected += value_collected\n    print(f'Total Distance: {total_distance}m')\n    print(f'Total Value collected: {total_value_collected}/{sum(VISIT_VALUES)}')\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequence Constraints with Circuit in CP-SAT\nDESCRIPTION: This function enforces constraints on sequences of tasks of the same type using a circuit constraint. It models task sequencing, maintains length and cumulative duration of task sequences, and implements soft and hard constraints with penalty terms.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndef sequence_constraints_with_circuit(\n    model: cp_model.CpModel,\n    starts: Sequence[cp_model.IntVar],\n    durations: Sequence[int],\n    task_types: Sequence[str],\n    lengths: Sequence[cp_model.IntVar],\n    cumuls: Sequence[cp_model.IntVar],\n    sequence_length_constraints: Dict[str, Tuple[int, int]],\n    sequence_cumul_constraints: Dict[str, Tuple[int, int, int]],\n) -> Sequence[Tuple[cp_model.IntVar, int]]:\n    \"\"\"This method enforces constraints on sequences of tasks of the same type.\n\n    This method assumes that all durations are strictly positive.\n\n    The extra node (with id 0) will be used to decide which task is first with\n    its only outgoing arc, and which task is last with its only incoming arc.\n    Each task i will be associated with id i + 1, and an arc between i + 1 and j +\n    1 indicates that j is the immediate successor of i.\n\n    The circuit constraint ensures there is at most 1 hamiltonian cycle of\n    length > 1. If no such path exists, then no tasks are active.\n    In this simplified model, all tasks must be performed.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      durations: the durations of all tasks.\n      task_types: The type of all tasks.\n      lengths: the number of tasks of the same type in the current sequence.\n      cumuls: The computed cumul of the current sequence for each task.\n      sequence_length_constraints: the array of tuple (`task_type`, (`length_min`,\n        `length_max`)) that specifies the minimum and maximum length of the\n        sequence of tasks of type `task_type`.\n      sequence_cumul_constraints: the array of tuple (`task_type`, (`soft_max`,\n        `linear_penalty`, `hard_max`)) that specifies that if the cumul of the\n        sequence of tasks of type `task_type` is greater than `soft_max`, then\n        `linear_penalty * (cumul - soft_max)` is added to the cost\n\n    Returns:\n      The list of pairs (integer variables, penalty) to be added to the objective.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    arcs: List[cp_model.ArcT] = []\n    for i in all_tasks:\n        # if node i is first.\n        start_lit = model.new_bool_var(f\"start_{i}\")\n        arcs.append((0, i + 1, start_lit))\n        model.add(lengths[i] == 1).only_enforce_if(start_lit)\n        model.add(cumuls[i] == durations[i]).only_enforce_if(start_lit)\n\n        # As there are no other constraints on the problem, we can add this\n        # redundant constraint. This is not valid in general.\n        model.add(starts[i] == 0).only_enforce_if(start_lit)\n\n        # if node i is last.\n        end_lit = model.new_bool_var(f\"end_{i}\")\n        arcs.append((i + 1, 0, end_lit))\n\n        # Make sure the previous length is within bounds.\n        type_length_min = sequence_length_constraints[task_types[i]][0]\n        model.add(lengths[i] >= type_length_min).only_enforce_if(end_lit)\n\n        for j in all_tasks:\n            if i == j:\n                continue\n            lit = model.new_bool_var(f\"arc_{i}_to_{j}\")\n            arcs.append((i + 1, j + 1, lit))\n\n            # The circuit constraint is use to enforce the consistency between the\n            # precedences relations and the successor arcs. This is implemented by\n            # adding the constraint that force the implication task j is the next of\n            # task i implies that start(j) is greater or equal than the end(i).\n            #\n            # In the majority of problems, the following equality must be an\n            # inequality. In that particular case, as there are no extra constraints,\n            # we can keep the equality between start(j) and end(i).\n            model.add(starts[j] == starts[i] + durations[i]).only_enforce_if(lit)\n\n            # We add the constraints to incrementally maintain the length and the\n            # cumul variables of the sequence.\n            if task_types[i] == task_types[j]:  # Same task type.\n                # Increase the length of the sequence by 1.\n                model.add(lengths[j] == lengths[i] + 1).only_enforce_if(lit)\n\n                # Increase the cumul of the sequence by the duration of the task.\n                model.add(cumuls[j] == cumuls[i] + durations[j]).only_enforce_if(lit)\n\n            else:\n                # Switching task type. task[i] is the last task of the previous\n                # sequence, task[j] is the first task of the new sequence.\n                #\n                # Reset the length to 1.\n                model.add(lengths[j] == 1).only_enforce_if(lit)\n\n                # Make sure the previous length is within bounds.\n                type_length_min = sequence_length_constraints[task_types[i]][0]\n                model.add(lengths[i] >= type_length_min).only_enforce_if(lit)\n\n                # Reset the cumul to the duration of the task.\n                model.add(cumuls[j] == durations[j]).only_enforce_if(lit)\n\n    # Add the circuit constraint.\n    model.add_circuit(arcs)\n\n    # Create the penalty terms. We can penalize each cumul locally.\n    penalty_terms = []\n    for i in all_tasks:\n        # Penalize the cumul of the last task w.r.t. the soft max\n        soft_max, linear_penalty, hard_max = sequence_cumul_constraints[task_types[i]]\n\n        # To make it separable per task, and avoid double counting, we use the\n        # following trick:\n        #     reduced_excess = min(durations[i], max(0, cumul[i] - soft_max))\n        if soft_max < hard_max:\n            excess = model.new_int_var(0, hard_max - soft_max, f\"excess+_{i}\")\n            model.add_max_equality(excess, [0, cumuls[i] - soft_max])\n            reduced_excess = model.new_int_var(0, durations[i], f\"reduced_excess_{i}\")\n            model.add_min_equality(reduced_excess, [durations[i], excess])\n            penalty_terms.append((reduced_excess, linear_penalty))\n\n    return penalty_terms\n```\n\n----------------------------------------\n\nTITLE: Main Program Entry Point\nDESCRIPTION: Entry point function that handles command line arguments and calls the prize collecting TSP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    prize_collecting_tsp()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Solution Printer for CP-SAT Solver in Python\nDESCRIPTION: This class extends CpSolverSolutionCallback to print intermediate solutions. It keeps track of the number of solutions found and prints the values of the variables for each solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/search_for_all_solutions_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        self.__solution_count += 1\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n```\n\n----------------------------------------\n\nTITLE: Adding Redundant Constraints for Total Driving and Working Times\nDESCRIPTION: Adds redundant constraints to enforce relationships between the sum of driving times and the sum of working times, helping the solver find solutions faster by providing additional global constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Redundant constraints: sum of driving times = sum of shift driving times\nmodel.add(cp_model.LinearExpr.sum(driving_times) == total_driving_time)\nif not minimize_drivers:\n    model.add(\n        cp_model.LinearExpr.sum(working_times)\n        == total_driving_time\n        + num_drivers * (setup_time + cleanup_time)\n        + cp_model.LinearExpr.weighted_sum(delay_literals, delay_weights)\n    )\n```\n\n----------------------------------------\n\nTITLE: Solving Rabbits and Pheasants Problem in Java\nDESCRIPTION: Java implementation of the Rabbits and Pheasants puzzle using CP-SAT solver. Shows how to create integer variables and linear expressions in Java syntax.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\n\n/**\n * In a field of rabbits and pheasants, there are 20 heads and 56 legs. How many rabbits and\n * pheasants are there?\n */\npublic class RabbitsAndPheasantsSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Creates the model.\n    CpModel model = new CpModel();\n    // Creates the variables.\n    IntVar r = model.newIntVar(0, 100, \"r\");\n    IntVar p = model.newIntVar(0, 100, \"p\");\n    // 20 heads.\n    model.addEquality(LinearExpr.newBuilder().add(r).add(p), 20);\n    // 56 legs.\n    model.addEquality(LinearExpr.newBuilder().addTerm(r, 4).addTerm(p, 2), 56);\n\n    // Creates a solver and solves the model.\n    CpSolver solver = new CpSolver();\n    CpSolverStatus status = solver.solve(model);\n\n    if (status == CpSolverStatus.OPTIMAL) {\n      System.out.println(solver.value(r) + \" rabbits, and \" + solver.value(p) + \" pheasants\");\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Print Solution Function for Prize Collecting TSP\nDESCRIPTION: Function to print the solution details including dropped nodes, route path, total distance and collected values. Takes solver instance, visited nodes array, used arcs dictionary and number of nodes as parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(solver: cp_model.CpSolver, visited_nodes: list[cp_model.IntVar], used_arcs: dict[tuple[int, int], cp_model.IntVar], num_nodes: int) -> None:\n    \"\"\"Prints solution on console.\"\"\"\n    # Display dropped nodes.\n    dropped_nodes = \"Dropped nodes:\"\n    for i in range(num_nodes):\n        if i == 0:\n            continue\n        if not solver.boolean_value(visited_nodes[i]):\n            dropped_nodes += f\" {i}({VISIT_VALUES[i]})\"\n    print(dropped_nodes)\n    # Display routes\n    current_node = 0\n    plan_output = \"Route for vehicle 0:\\n\"\n    route_distance = 0\n    value_collected = 0\n    route_is_finished = False\n    while not route_is_finished:\n        value_collected += VISIT_VALUES[current_node]\n        plan_output += f\" {current_node} ->\"\n        # find next node\n        for node in range(num_nodes):\n            if node == current_node:\n                continue\n            if solver.boolean_value(used_arcs[current_node, node]):\n                route_distance += DISTANCE_MATRIX[current_node][node]\n                current_node = node\n                if current_node == 0:\n                    route_is_finished = True\n                break\n    plan_output += f\" {current_node}\\n\"\n    plan_output += f\"Distance of the route: {route_distance}m\\n\"\n    plan_output += f\"value collected: {value_collected}/{sum(VISIT_VALUES)}\\n\"\n    print(plan_output)\n```\n\n----------------------------------------\n\nTITLE: Configuring GLPK Solver Test for OR-Tools\nDESCRIPTION: Sets up a test target for the GLPK (GNU Linear Programming Kit) solver implementation with conditional compilation based on GLPK availability. Links against both LP and MIP test libraries to test the full range of capabilities supported by GLPK.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_GLPK)\n  ortools_cxx_test(\n    NAME\n      math_opt_solvers_glpk_solver_test\n    SOURCES\n      \"glpk_solver_test.cc\"\n    LINK_LIBRARIES\n      GTest::gmock\n      GTest::gmock_main\n      absl::status\n      absl::time\n      ortools::math_opt_matchers\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_invalid_input_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_parameter_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_incomplete_solve_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_parameter_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_mip_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qc_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_second_order_cone_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Interval Relations Using OR-Tools\nDESCRIPTION: This snippet demonstrates how to create and manage interval relations using the CP-SAT solver from the OR-Tools library. Various interval types are created, including 'fixed-size intervals' and 'optional intervals' with dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/interval_relations_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef interval_relations_sample_sat():\n    \"\"\"Showcases how to build temporal relations between intervals.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 100\n\n    # An interval can be created from three 1-var affine expressions.\n    start_var = model.new_int_var(0, horizon, \"start\")\n    duration = 10  # Python CP-SAT code accept integer variables or constants.\n    end_var = model.new_int_var(0, horizon, \"end\")\n    interval_var = model.new_interval_var(start_var, duration, end_var, \"interval\")\n\n    # If the size is fixed, a simpler version uses the start expression and the\n    # size.\n    fixed_size_start_var = model.new_int_var(0, horizon, \"fixed_start\")\n    fixed_size_duration = 10\n    fixed_size_interval_var = model.new_fixed_size_interval_var(\n        fixed_size_start_var,\n        fixed_size_duration,\n        \"fixed_size_interval_var\",\n    )\n\n    # An optional interval can be created from three 1-var affine expressions and\n    # a literal.\n    opt_start_var = model.new_int_var(0, horizon, \"opt_start\")\n    opt_duration = model.new_int_var(2, 6, \"opt_size\")\n    opt_end_var = model.new_int_var(0, horizon, \"opt_end\")\n    opt_presence_var = model.new_bool_var(\"opt_presence\")\n    opt_interval_var = model.new_optional_interval_var(\n        opt_start_var, opt_duration, opt_end_var, opt_presence_var, \"opt_interval\"\n    )\n\n    # If the size is fixed, a simpler version uses the start expression, the\n    # size, and the presence literal.\n    opt_fixed_size_start_var = model.new_int_var(0, horizon, \"opt_fixed_start\")\n    opt_fixed_size_duration = 10\n    opt_fixed_size_presence_var = model.new_bool_var(\"opt_fixed_presence\")\n    opt_fixed_size_interval_var = model.new_optional_fixed_size_interval_var(\n        opt_fixed_size_start_var,\n        opt_fixed_size_duration,\n        opt_fixed_size_presence_var,\n        \"opt_fixed_size_interval_var\",\n    )\n\n    # Simple precedence between two non optional intervals.\n    model.add(interval_var.start_expr() >= fixed_size_interval_var.end_expr())\n\n    # Synchronize start between two intervals (one optional, one not)\n    model.add(\n        interval_var.start_expr() == opt_interval_var.start_expr()\n    ).only_enforce_if(opt_presence_var)\n\n    # Exact delay between two optional intervals.\n    exact_delay: int = 5\n    model.add(\n        opt_interval_var.start_expr()\n        == opt_fixed_size_interval_var.end_expr() + exact_delay\n    ).only_enforce_if(opt_presence_var, opt_fixed_size_presence_var)\n\ninterval_relations_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Variables and Constraints for Scheduling Model in Python\nDESCRIPTION: This snippet creates variables and constraints for the scheduling model using OR-Tools. It defines interval variables for tasks, adds cumulative constraints, and sets up precedence relationships between tasks.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\npods[t] = model.new_int_var(0, num_pods - 1, f\"pod_{t}\")\n\n# Create the variables\nintervals = []\ndemands = []\nfor t in all_tasks:\n    interval = model.new_fixed_size_interval_var(pods[t], 1, \"\")\n    intervals.append(interval)\n    demands.append(durations[t])\n\n# add terminating interval as the objective.\nobj_var = model.new_int_var(1, num_pods, \"obj_var\")\nobj_size = model.new_int_var(1, num_pods, \"obj_duration\")\nobj_interval = model.new_interval_var(\n    obj_var, obj_size, num_pods + 1, \"obj_interval\"\n)\nintervals.append(obj_interval)\ndemands.append(cycle_time)\n\n# Cumulative constraint.\nmodel.add_cumulative(intervals, demands, cycle_time)\n\n# Precedences.\nfor before, after in precedences:\n    model.add(pods[after] >= pods[before])\n\n# Objective.\nmodel.minimize(obj_var)\n\n# add search hinting from the greedy solution.\nfor t in all_tasks:\n    model.add_hint(pods[t], hint[t])\n```\n\n----------------------------------------\n\nTITLE: Implementing Regular Constraint in Python\nDESCRIPTION: Defines a function to implement the regular constraint, which is used to enforce rules in the Nonogram puzzle. It creates a finite automaton to represent the constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef regular(x, Q, S, d, q0, F):\n\n  solver = x[0].solver()\n\n  assert Q > 0, 'regular: \"Q\" must be greater than zero'\n  assert S > 0, 'regular: \"S\" must be greater than zero'\n\n  d2 = []\n  for i in range(Q + 1):\n    for j in range(S):\n      if i == 0:\n        d2.append((0, j, 0))\n      else:\n        d2.append((i, j, d[i - 1][j]))\n\n  x_range = list(range(0, len(x)))\n  m = 0\n  n = len(x)\n\n  a = [solver.IntVar(0, Q + 1, 'a[%i]' % i) for i in range(m, n + 1)]\n\n  solver.Add(solver.MemberCt(a[-1], F))\n  solver.Add(a[m] == q0)\n  for i in x_range:\n    solver.Add(x[i] >= 1)\n    solver.Add(x[i] <= S)\n    solver.Add(solver.AllowedAssignments((a[i], x[i] - 1, a[i + 1]), d2))\n```\n\n----------------------------------------\n\nTITLE: Implementing Transition Times and Costs in a No-Overlap Constraint with CP-SAT\nDESCRIPTION: This function uses a circuit constraint to rank tasks and enforce transition constraints in non-overlapping scheduling problems. It handles task presences, transition penalties, and delays between tasks, returning a list of penalty terms for the objective function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef transitive_reduction_with_circuit_delays_and_penalties(\n    model: cp_model.CpModel,\n    starts: Sequence[cp_model.IntVar],\n    durations: Sequence[int],\n    presences: Sequence[Union[cp_model.IntVar, bool]],\n    penalties: Dict[Tuple[int, int], int],\n    delays: Dict[Tuple[int, int], int],\n) -> Sequence[Tuple[cp_model.IntVar, int]]:\n    \"\"\"This method uses a circuit constraint to rank tasks.\n\n    This method assumes that all starts are disjoint, meaning that all tasks have\n    a strictly positive duration, and they appear in the same NoOverlap\n    constraint.\n\n    The extra node (with id 0) will be used to decide which task is first with\n    its only outgoing arc, and which task is last with its only incoming arc.\n    Each task i will be associated with id i + 1, and an arc between i + 1 and j +\n    1 indicates that j is the immediate successor of i.\n\n    The circuit constraint ensures there is at most 1 hamiltonian cycle of\n    length > 1. If no such path exists, then no tasks are active.\n    We also need to enforce that any hamiltonian cycle of size > 1 must contain\n    the node 0. And thus, there is a self loop on node 0 iff the circuit is empty.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      durations: the durations of all tasks.\n      presences: The array of presence variables of all tasks.\n      penalties: the array of tuple (`tail_index`, `head_index`, `penalty`) that\n        specifies that if task `tail_index` is the successor of the task\n        `head_index`, then `penalty` must be added to the cost.\n      delays: the array of tuple (`tail_index`, `head_index`, `delay`) that\n        specifies that if task `tail_index` is the successor of the task\n        `head_index`, then an extra `delay` must be added between the end of the\n        first task and the start of the second task.\n\n    Returns:\n      The list of pairs (Boolean variables, penalty) to be added to the objective.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    arcs: List[cp_model.ArcT] = []\n    penalty_terms = []\n    for i in all_tasks:\n        # if node i is first.\n        start_lit = model.new_bool_var(f\"start_{i}\")\n        arcs.append((0, i + 1, start_lit))\n\n        # As there are no other constraints on the problem, we can add this\n        # redundant constraint.\n        model.add(starts[i] == 0).only_enforce_if(start_lit)\n\n        # if node i is last.\n        end_lit = model.new_bool_var(f\"end_{i}\")\n        arcs.append((i + 1, 0, end_lit))\n\n        for j in all_tasks:\n            if i == j:\n                arcs.append((i + 1, i + 1, ~presences[i]))\n            else:\n                literal = model.new_bool_var(f\"arc_{i}_to_{j}\")\n                arcs.append((i + 1, j + 1, literal))\n\n                # To perform the transitive reduction from precedences to successors,\n                # we need to tie the starts of the tasks with 'literal'.\n                # In a pure problem, the following inequality could be an equality.\n                # It is not true in general.\n                #\n                # Note that we could use this literal to penalize the transition, add an\n                # extra delay to the precedence.\n                min_delay = 0\n                key = (i, j)\n                if key in delays:\n                    min_delay = delays[key]\n                model.add(\n                    starts[j] >= starts[i] + durations[i] + min_delay\n                ).only_enforce_if(literal)\n\n                # Create the penalties.\n                if key in penalties:\n                    penalty_terms.append((literal, penalties[key]))\n\n    # Manage the empty circuit\n    empty = model.new_bool_var(\"empty\")\n    arcs.append((0, 0, empty))\n\n    for i in all_tasks:\n        model.add_implication(empty, ~presences[i])\n\n    # Add the circuit constraint.\n    model.add_circuit(arcs)\n\n    return penalty_terms\n```\n\n----------------------------------------\n\nTITLE: Solving CP-SAT Model with Intermediate Solutions in Go\nDESCRIPTION: This Go code demonstrates solving a CP-SAT model and retrieving intermediate solutions. Due to limitations in the Go implementation, it doesn't use callbacks but instead retrieves the intermediate solutions from the solver response after solving.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// The solve_and_print_intermediate_solutions_sample_sat command\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc solveAndPrintIntermediateSolutionsSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tdomain := cpmodel.NewDomain(0, 2)\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVarFromDomain(domain).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\n\tmodel.AddNotEqual(x, y)\n\n\tmodel.Maximize(cpmodel.NewLinearExpr().Add(x).AddTerm(y, 2).AddTerm(z, 3))\n\n\t// Create a solver and solve with a fixed search.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\n\t// Currently, the CpModelBuilder does not allow for callbacks, so intermediate solutions\n\t// cannot be printed while solving. However, the CP-SAT solver does allow for returning\n\t// the intermediate solutions found while solving in the response.\n\tparams := &sppb.SatParameters{\n\t\tFillAdditionalSolutionsInResponse: proto.Bool(true),\n\t\tSolutionPoolSize:                  proto.Int32(10),\n\t}\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Println(\"Number of intermediate solutions found: \", len(response.GetAdditionalSolutions()))\n\n\tfmt.Println(\"Optimal solution:\")\n\tfmt.Printf(\"  x = %v\\n\", cpmodel.SolutionIntegerValue(response, x))\n\tfmt.Printf(\"  y = %v\\n\", cpmodel.SolutionIntegerValue(response, y))\n\tfmt.Printf(\"  z = %v\\n\", cpmodel.SolutionIntegerValue(response, z))\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := solveAndPrintIntermediateSolutionsSampleSat(); err != nil {\n\t\tlog.Exitf(\"solveAndPrintIntermediateSolutionsSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Rules in Nonogram Solver using Automaton\nDESCRIPTION: This function checks each rule by creating an automaton and applying a transition constraint in the Nonogram solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table2.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef check_rule(rules, y):\n  cleaned_rule = [rules[i] for i in range(len(rules)) if rules[i] > 0]\n  (transition_tuples, last_state) = make_transition_tuples(cleaned_rule)\n\n  initial_state = 1\n  accepting_states = [last_state]\n\n  solver = y[0].solver()\n  solver.Add(\n      solver.TransitionConstraint(y, transition_tuples, initial_state,\n                                  accepting_states))\n```\n\n----------------------------------------\n\nTITLE: Task Variable and Constraint Creation for CP-SAT Job Scheduling in Python\nDESCRIPTION: Creates decision variables and constraints for each job and task, including start/end times, durations, and machine assignments. Handles precedence constraints between tasks and creates alternative task intervals for different machines.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n  #----------------------------------------------------------------------------\n  # Scan the jobs and create the relevant variables and intervals.\n  for job_id in all_jobs:\n    job = jobs[job_id]\n    num_tasks = len(job)\n    previous_end = None\n    for task_id in range(num_tasks):\n      task = job[task_id]\n\n      min_duration = task[0][0]\n      max_duration = task[0][0]\n\n      num_alternatives = len(task)\n      all_alternatives = range(num_alternatives)\n\n      for alt_id in range(1, num_alternatives):\n        alt_duration = task[alt_id][0]\n        min_duration = min(min_duration, alt_duration)\n        max_duration = max(max_duration, alt_duration)\n\n      # Create main interval for the task.\n      suffix_name = '_j%i_t%i' % (job_id, task_id)\n      start = model.NewIntVar(0, horizon, 'start' + suffix_name)\n      duration = model.NewIntVar(min_duration, max_duration,\n                                 'duration' + suffix_name)\n      end = model.NewIntVar(0, horizon, 'end' + suffix_name)\n\n      # Store the start for the solution.\n      job_starts[(job_id, task_id)] = start\n\n      # Add precedence with previous task in the same job.\n      if previous_end:\n        model.Add(start >= previous_end)\n      previous_end = end\n\n      # Create alternative intervals.\n      l_presences = []\n      for alt_id in all_alternatives:\n        ### add to link interval with eqp constraint.\n        ### process time = -1 cannot be processed at this machine.\n        if jobs[job_id][task_id][alt_id][0] == -1:\n          continue\n        alt_suffix = '_j%i_t%i_a%i' % (job_id, task_id, alt_id)\n        l_presence = model.NewBoolVar('presence' + alt_suffix)\n        l_start = model.NewIntVar(0, horizon, 'start' + alt_suffix)\n        l_duration = task[alt_id][0]\n        l_end = model.NewIntVar(0, horizon, 'end' + alt_suffix)\n        l_interval = model.NewOptionalIntervalVar(\n            l_start, l_duration, l_end, l_presence, 'interval' + alt_suffix)\n        l_rank = model.NewIntVar(-1, num_jobs, 'rank' + alt_suffix)\n        l_presences.append(l_presence)\n        l_machine = task[alt_id][1]\n        l_type = task[alt_id][2]\n\n        # Link the original variables with the local ones.\n        model.Add(start == l_start).OnlyEnforceIf(l_presence)\n        model.Add(duration == l_duration).OnlyEnforceIf(l_presence)\n        model.Add(end == l_end).OnlyEnforceIf(l_presence)\n\n        # Add the local variables to the right machine.\n        intervals_per_machines[l_machine].append(l_interval)\n        starts_per_machines[l_machine].append(l_start)\n        ends_per_machines[l_machine].append(l_end)\n        presences_per_machines[l_machine].append(l_presence)\n        resources_per_machines[l_machine].append(l_type)\n        ranks_per_machines[l_machine].append(l_rank)\n\n        # Store the variables for the solution.\n        job_presences[(job_id, task_id, alt_id)] = l_presence\n        job_ranks[(job_id, task_id, alt_id)] = l_rank\n\n      # Only one machine can process each lot.\n      model.Add(sum(l_presences) == 1)\n\n    job_ends.append(previous_end)\n```\n\n----------------------------------------\n\nTITLE: Using Assumptions to Explain Infeasibility in C++\nDESCRIPTION: C++ code sample demonstrating how to use assumptions for identifying infeasibility causes in CP-SAT. The example creates variables and constraints with enforcement literals, adds them as assumptions, and then reports the indices of sufficient assumptions for infeasibility.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/troubleshooting.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"absl/types/span.h\"\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid AssumptionsSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 10);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n  const BoolVar a = cp_model.NewBoolVar().WithName(\"a\");\n  const BoolVar b = cp_model.NewBoolVar().WithName(\"b\");\n  const BoolVar c = cp_model.NewBoolVar().WithName(\"c\");\n\n  cp_model.AddGreaterThan(x, y).OnlyEnforceIf(a);\n  cp_model.AddGreaterThan(y, z).OnlyEnforceIf(b);\n  cp_model.AddGreaterThan(z, x).OnlyEnforceIf(c);\n\n  // Add assumptions\n  cp_model.AddAssumptions({a, b, c});\n\n  // Solving part.\n  const CpSolverResponse response = Solve(cp_model.Build());\n\n  // Print solution.\n  LOG(INFO) << CpSolverResponseStats(response);\n  if (response.status() == CpSolverStatus::INFEASIBLE) {\n    for (const int index :\n         response.sufficient_assumptions_for_infeasibility()) {\n      LOG(INFO) << index;\n    }\n  }\n}\n}  // namespace sat\n}  // namespace operations_research\n\nint main(int argc, char** argv) {\n  operations_research::sat::AssumptionsSampleSat();\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: CVRPTW Customer Class Implementation\nDESCRIPTION: Implements a Customer class that generates and manages customer information including locations, demands, and time windows. Uses numpy for random distribution of customers within a geographic area and handles time window constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom collections import namedtuple\nfrom ortools.constraint_solver import pywrapcp\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom datetime import datetime, timedelta\n\n\nclass Customers():\n    def __init__(self,\n                 extents=None,\n                 center=(53.381393, -1.474611),\n                 box_size=10,\n                 num_stops=100,\n                 min_demand=0,\n                 max_demand=25,\n                 min_tw=1,\n                 max_tw=5):\n        self.number = num_stops\n        Location = namedtuple('Location', ['lat', 'lon'])\n        if extents is not None:\n            self.extents = extents\n            self.center = Location(\n                extents['urcrnrlat'] - 0.5 *\n                (extents['urcrnrlat'] - extents['llcrnrlat']),\n                extents['urcrnrlon'] - 0.5 *\n                (extents['urcrnrlon'] - extents['llcrnrlon']))\n        else:\n            (clat, clon) = self.center = Location(center[0], center[1])\n            rad_earth = 6367\n            circ_earth = np.pi * rad_earth\n            self.extents = {\n                'llcrnrlon': (clon - 180 * box_size /\n                              (circ_earth * np.cos(np.deg2rad(clat)))),\n                'llcrnrlat':\n                clat - 180 * box_size / circ_earth,\n                'urcrnrlon': (clon + 180 * box_size /\n                              (circ_earth * np.cos(np.deg2rad(clat)))),\n                'urcrnrlat':\n                clat + 180 * box_size / circ_earth\n            }\n        stops = np.array(range(0, num_stops))\n        stdv = 6\n        lats = (self.extents['llcrnrlat'] + np.random.randn(num_stops) *\n                (self.extents['urcrnrlat'] - self.extents['llcrnrlat']) / stdv)\n        lons = (self.extents['llcrnrlon'] + np.random.randn(num_stops) *\n                (self.extents['urcrnrlon'] - self.extents['llcrnrlon']) / stdv)\n        demands = np.random.randint(min_demand, max_demand, num_stops)\n\n        self.time_horizon = 24 * 60**2\n\n        time_windows = np.random.randint(min_tw * 3600, max_tw * 3600,\n                                                 num_stops)\n        latest_time = self.time_horizon - time_windows\n        start_times = [None for o in time_windows]\n        stop_times = [None for o in time_windows]\n        for idx in range(self.number):\n            stime = int(np.random.randint(0, latest_time[idx]))\n            start_times[idx] = timedelta(seconds=stime)\n            stop_times[idx] = (\n                start_times[idx] + timedelta(seconds=int(time_windows[idx])))\n        Customer = namedtuple(\n            'Customer',\n            [\n                'index',\n                'demand',\n                'lat',\n                'lon',\n                'tw_open',\n                'tw_close'\n            ])\n\n        self.customers = [\n            Customer(idx, dem, lat, lon, tw_open, tw_close)\n            for idx, dem, lat, lon, tw_open, tw_close in zip(\n                stops, demands, lats, lons, start_times, stop_times)\n        ]\n\n        self.service_time_per_dem = 300\n\n    def set_manager(self, manager):\n        self.manager = manager\n\n    def central_start_node(self, invert=False):\n        num_nodes = len(self.customers)\n        dist = np.empty((num_nodes, 1))\n        for idx_to in range(num_nodes):\n            dist[idx_to] = self._haversine(self.center.lon, self.center.lat,\n                                           self.customers[idx_to].lon,\n                                           self.customers[idx_to].lat)\n        furthest = np.max(dist)\n\n        if invert:\n            prob = dist * 1.0 / sum(dist)\n        else:\n            prob = (furthest - dist * 1.0) / sum(furthest - dist)\n        indexes = np.array([range(num_nodes)])\n        start_node = np.random.choice(\n            indexes.flatten(), size=1, replace=True, p=prob.flatten())\n        return start_node[0]\n\n    def make_distance_mat(self, method='haversine'):\n        self.distmat = np.zeros((self.number, self.number))\n```\n\n----------------------------------------\n\nTITLE: Executing Subset Sum Solver with Sample Data in Python\nDESCRIPTION: Sets up the input data for the subset sum problem and calls the main function to solve it. Allows for optional command-line argument to specify the total sum.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/subset_sum.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncoins = [16, 17, 23, 24, 39, 40]\ntotal = 100\nif len(sys.argv) > 1:\n  total = int(sys.argv[1])\nmain(coins, total)\n```\n\n----------------------------------------\n\nTITLE: Main Constraint Satisfaction Problem Solver\nDESCRIPTION: Demonstrates creating a CP-SAT model with Boolean and integer variables, constructing a product constraint, and solving with all solutions enumeration\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bool_and_int_var_product_sample_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef bool_and_int_var_product_sample_sat():\n    model = cp_model.CpModel()\n    b = model.new_bool_var(\"b\")\n    x = model.new_int_var_from_domain(\n        cp_model.Domain.from_values([1, 2, 3, 5, 6, 7, 9, 10]), \"x\"\n    )\n    p = build_product_var(model, b, x, \"p\")\n\n    model.add_decision_strategy(\n        [b, x], cp_model.CHOOSE_FIRST, cp_model.SELECT_MIN_VALUE\n    )\n\n    solver = cp_model.CpSolver()\n    solution_printer = VarArraySolutionPrinter([x, b, p])\n    solver.parameters.enumerate_all_solutions = True\n    solver.parameters.search_branching = cp_model.FIXED_SEARCH\n    solver.solve(model, solution_printer)\n\nbool_and_int_var_product_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit in Go CP-SAT Solver\nDESCRIPTION: Go implementation for setting a 10-second time limit on a CP-SAT solver. This example uses protocol buffers to configure the solver parameters and creates a simple constraint programming model with three variables and a not-equal constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// The solve_with_time_limit_sample_sat command is an example of setting a time limit on the model.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc solveWithTimeLimitSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tdomain := cpmodel.NewDomain(0, 2)\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVarFromDomain(domain).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\n\tmodel.AddNotEqual(x, y)\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\n\t// Sets a time limit of 10 seconds.\n\tparams := &sppb.SatParameters{\n\t\tMaxTimeInSeconds: proto.Float64(10.0),\n\t}\n\n\t// Solve.\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Printf(\"Status: %v\\n\", response.GetStatus())\n\n\tif response.GetStatus() == cmpb.CpSolverStatus_OPTIMAL {\n\t\tfmt.Printf(\" x = %v\\n\", cpmodel.SolutionIntegerValue(response, x))\n\t\tfmt.Printf(\" y = %v\\n\", cpmodel.SolutionIntegerValue(response, y))\n\t\tfmt.Printf(\" z = %v\\n\", cpmodel.SolutionIntegerValue(response, z))\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := solveWithTimeLimitSampleSat(); err != nil {\n\t\tlog.Exitf(\"solveWithTimeLimitSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing alldifferent_except_0 Constraint in Google OR-Tools\nDESCRIPTION: Two implementations of the alldifferent_except_0 constraint decomposition that enforces variables to take distinct values except those assigned to 0. The first version uses a standard approach, while the second is a more compact list comprehension version.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/alldifferent_except_0.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n#\n# Decomposition of alldifferent_except_0\n# Thanks to Laurent Perron (Google) for\n# suggestions of improvements.\n#\n\n\ndef alldifferent_except_0(solver, a):\n  n = len(a)\n  for i in range(n):\n    for j in range(i):\n      solver.Add((a[i] != 0) * (a[j] != 0) <= (a[i] != a[j]))\n\n\n# more compact version:\n\n\ndef alldifferent_except_0_b(solver, a):\n  n = len(a)\n  [\n      solver.Add((a[i] != 0) * (a[j] != 0) <= (a[i] != a[j]))\n      for i in range(n)\n      for j in range(i)\n  ]\n```\n\n----------------------------------------\n\nTITLE: Implementing Model Loading and Solving Function with OR-Tools\nDESCRIPTION: Defines a main function that loads an optimization model from an MPS file, configures and creates a solver based on user-specified parameters, and then solves the model. The function supports different solver backends and custom solver parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/proto_solve.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.colab import flags\nfrom ortools.linear_solver.python import model_builder\n\nFLAGS = flags.FLAGS\n\n_INPUT = flags.define_string('input', '', 'Input file to load and solve.')\n_PARAMS = flags.define_string('params', '', 'Solver parameters in string format.')\n_SOLVER = flags.define_string('solver', 'sat', 'Solver type to solve the model with.')\n\n\ndef main(_):\n    model = model_builder.ModelBuilder()\n\n    # Load MPS file.\n    if not model.import_from_mps_file(_INPUT.value):\n        print(f'Cannot import MPS file: \\'{\\_INPUT.value}\\'')  \n        return\n\n    # Create solver.\n    solver = model_builder.ModelSolver(_SOLVER.value)\n    if not solver.solver_is_supported():\n        print(f'Cannot create solver with name \\'{\\_SOLVER.value}\\'')  \n        return\n\n    # Set parameters.\n    if _PARAMS.value:\n        solver.set_solver_specific_parameters(_PARAMS.value)\n\n    # Enable the output of the solver.\n    solver.enable_output(True)\n\n    # And solve.\n    solver.solve(model)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Defining Puzzle Data and Variables\nDESCRIPTION: Sets up the puzzle data as a 2D array and defines the decision variables for the constraint solver, including the matrix values and row/column signs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle2.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n  rows = 27\n  cols = 9\n  data = [[33, 30, 10, -6, 18, -7, -11, 23, -6],\n          # ... (full data matrix omitted for brevity)\n          [-25, 4, -16, 30, 33, 23, -4, -4, 23]]\n\n  x = {}\n  for i in range(rows):\n    for j in range(cols):\n      x[i, j] = solver.IntVar(-100, 100, \"x[%i,%i]\" % (i, j))\n\n  x_flat = [x[i, j] for i in range(rows) for j in range(cols)]\n\n  row_signs = [solver.IntVar([-1, 1], \"row_signs(%i)\" % i) for i in range(rows)]\n  col_signs = [solver.IntVar([-1, 1], \"col_signs(%i)\" % j) for j in range(cols)]\n```\n\n----------------------------------------\n\nTITLE: Task Scheduling with No-Overlap in Go using OR-Tools\nDESCRIPTION: Go implementation of task scheduling that schedules 3 tasks with fixed durations over 3 weeks while avoiding weekends. Uses CP-SAT solver to minimize the makespan and enforces no-overlap constraints between tasks and weekend periods.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_15\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n)\n\nconst horizon = 21\n\nfunc noOverlapSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\tdomain := cpmodel.NewDomain(0, horizon)\n\n\tstart0 := model.NewIntVarFromDomain(domain)\n\tduration0 := cpmodel.NewConstant(2)\n\tend0 := model.NewIntVarFromDomain(domain)\n\ttask0 := model.NewIntervalVar(start0, duration0, end0)\n\n\tstart1 := model.NewIntVarFromDomain(domain)\n\tduration1 := cpmodel.NewConstant(4)\n\tend1 := model.NewIntVarFromDomain(domain)\n\ttask1 := model.NewIntervalVar(start1, duration1, end1)\n\n\tstart2 := model.NewIntVarFromDomain(domain)\n\tduration2 := cpmodel.NewConstant(2)\n\tend2 := model.NewIntVarFromDomain(domain)\n\ttask2 := model.NewIntervalVar(start2, duration2, end2)\n\n\tweekend0 := model.NewFixedSizeIntervalVar(cpmodel.NewConstant(5), 2)\n\tweekend1 := model.NewFixedSizeIntervalVar(cpmodel.NewConstant(12), 2)\n\tweekend2 := model.NewFixedSizeIntervalVar(cpmodel.NewConstant(19), 2)\n\n\tmodel.AddNoOverlap(task0, task1, task2, weekend0, weekend1, weekend2)\n\n\tmakespan := model.NewIntVarFromDomain(domain)\n\tmodel.AddLessOrEqual(end0, makespan)\n\tmodel.AddLessOrEqual(end1, makespan)\n\tmodel.AddLessOrEqual(end2, makespan)\n\n\tmodel.Minimize(makespan)\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tresponse, err := cpmodel.SolveCpModel(m)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tif response.GetStatus() == cmpb.CpSolverStatus_OPTIMAL {\n\t\tfmt.Println(response.GetStatus())\n\t\tfmt.Println(\"Optimal Schedule Length: \", response.GetObjectiveValue())\n\t\tfmt.Println(\"Task 0 starts at \", cpmodel.SolutionIntegerValue(response, start0))\n\t\tfmt.Println(\"Task 1 starts at \", cpmodel.SolutionIntegerValue(response, start1))\n\t\tfmt.Println(\"Task 2 starts at \", cpmodel.SolutionIntegerValue(response, start2))\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := noOverlapSampleSat(); err != nil {\n\t\tlog.Exitf(\"noOverlapSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: GSCIP Library Target Definition in CMake\nDESCRIPTION: Defines the GSCIP library as an object library, sets its properties, and specifies include directories and link libraries. The library is set up to be position-independent and includes various Abseil libraries, protobuf, and conditionally links against SCIP.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/gscip/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_gscip)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  $<$<BOOL:${USE_SCIP}>:libscip>\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::gscip ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Solving Rabbits and Pheasants Problem in Python\nDESCRIPTION: Python implementation of solving a mathematical puzzle using CP-SAT solver to determine the number of rabbits and pheasants given total heads and legs. Uses integer variables and linear constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Rabbits and Pheasants quizz.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef rabbits_and_pheasants_sat():\n    \"\"\"Solves the rabbits + pheasants problem.\"\"\"\n    model = cp_model.CpModel()\n\n    r = model.new_int_var(0, 100, \"r\")\n    p = model.new_int_var(0, 100, \"p\")\n\n    # 20 heads.\n    model.add(r + p == 20)\n    # 56 legs.\n    model.add(4 * r + 2 * p == 56)\n\n    # Solves and prints out the solution.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"{solver.value(r)} rabbits and {solver.value(p)} pheasants\")\n\n\nrabbits_and_pheasants_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Intervals in Java using OR-Tools\nDESCRIPTION: Java implementation of optional interval variables using OR-Tools CP-SAT solver. Shows three different methods for creating intervals with various configurations.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.*;\n\npublic class OptionalIntervalSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n    int horizon = 100;\n    IntVar startVar = model.newIntVar(0, horizon, \"start\");\n    IntVar endVar = model.newIntVar(0, horizon, \"end\");\n    Literal presence = model.newBoolVar(\"presence\");\n    IntervalVar intervalVar = model.newOptionalIntervalVar(startVar, LinearExpr.constant(10),\n        LinearExpr.newBuilder().add(endVar).add(2), presence, \"interval\");\n    IntervalVar fixedSizeIntervalVar =\n        model.newOptionalFixedSizeIntervalVar(startVar, 10, presence, \"fixed_size_interval_var\");\n    IntervalVar fixedInterval = model.newOptionalFixedInterval(5, 10, presence, \"fixed_interval\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Search Limit Parameters Protocol Buffer\nDESCRIPTION: Protocol buffer definition for parameters that control and limit the search space in the CP solver. Critical for managing solver performance and resource utilization.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/README.md#2025-04-17_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nsearch_limit.proto\n```\n\n----------------------------------------\n\nTITLE: Solution Printer for Vehicle Routing\nDESCRIPTION: Prints detailed solution information including routes, distances, loads, and times for each vehicle. Calculates and displays total metrics across all routes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrp_reload.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(data, manager, routing, assignment):\n    \"\"\"Prints assignment on console\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    total_distance = 0\n    total_load = 0\n    total_time = 0\n    capacity_dimension = routing.GetDimensionOrDie(\"Capacity\")\n    time_dimension = routing.GetDimensionOrDie(\"Time\")\n    distance_dimension = routing.GetDimensionOrDie(\"Distance\")\n    dropped = []\n    for order in range(6, routing.nodes()):\n        index = manager.NodeToIndex(order)\n        if assignment.Value(routing.NextVar(index)) == index:\n            dropped.append(order)\n    print(f\"dropped orders: {dropped}\")\n    dropped = []\n    for reload in range(1, 6):\n        index = manager.NodeToIndex(reload)\n        if assignment.Value(routing.NextVar(index)) == index:\n            dropped.append(reload)\n    print(f\"dropped reload stations: {dropped}\")\n\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        load_value = 0\n        distance = 0\n        while not routing.IsEnd(index):\n            time_var = time_dimension.CumulVar(index)\n            plan_output += (\n                f\" {manager.IndexToNode(index)} \"\n                f\"Load({assignment.Min(capacity_dimension.CumulVar(index))}) \"\n                f\"Time({assignment.Min(time_var)},{assignment.Max(time_var)}) ->\"\n            )\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            distance += distance_dimension.GetTransitValue(previous_index, index, vehicle_id)\n            load_value += max(0, capacity_dimension.GetTransitValue(previous_index, index, vehicle_id))\n        time_var = time_dimension.CumulVar(index)\n        plan_output += (\n            f\" {manager.IndexToNode(index)} \"\n            f\"Load({assignment.Min(capacity_dimension.CumulVar(index))}) \"\n            f\"Time({assignment.Min(time_var)},{assignment.Max(time_var)})\\n\"\n        )\n        plan_output += f\"Distance of the route: {distance}m\\n\"\n        plan_output += f\"Load of the route: {load_value}\\n\"\n        plan_output += f\"Time of the route: {assignment.Min(time_var)}min\\n\"\n        print(plan_output)\n        total_distance += distance\n        total_load += load_value\n        total_time += assignment.Min(time_var)\n    print(f\"Total Distance of all routes: {total_distance}m\")\n    print(f\"Total Load of all routes: {total_load}\")\n    print(f\"Total Time of all routes: {total_time}min\")\n```\n\n----------------------------------------\n\nTITLE: Defining Objective Function for Job Shop Scheduling in Python\nDESCRIPTION: This snippet sets up the objective function for the job shop scheduling problem. It minimizes a weighted sum of the makespan and the number of machine switches, balancing completion time and setup costs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n#----------------------------------------------------------------------------\n  # Objective.\n  makespan = model.NewIntVar(0, horizon, 'makespan')\n  model.AddMaxEquality(makespan, job_ends)\n  makespan_weight = 1\n  transition_weight = 5\n  model.Minimize(makespan * makespan_weight +\n                 sum(switch_literals) * transition_weight)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Command Line Arguments for Single Machine Scheduling\nDESCRIPTION: Defines command line arguments for the scheduling solver including output file for the CP model proto, solver parameters, and preprocessing options for setup times and durations.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/single_machine_scheduling_with_setup_release_due_dates_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.colab import flags\nfrom google.protobuf import text_format\nfrom ortools.sat.python import cp_model\n\n# ----------------------------------------------------------------------------\n# Command line arguments.\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:16,log_search_progress:true,max_time_in_seconds:45\",\n    \"Sat solver parameters.\",\n)\n_PREPROCESS = flags.define_bool(\n    \"--preprocess_times\", True, \"Preprocess setup times and durations\"\n)\n\n\n# ----------------------------------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Solution Printer Class Definition\nDESCRIPTION: This code defines a custom class `VarArraySolutionPrinter` that inherits from `cp_model.CpSolverSolutionCallback`. It overrides the `on_solution_callback` method to print the values of the specified variables for each solution found by the solver. This class requires a list of `cp_model.IntVar` as input for initialization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/overlapping_intervals_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"class VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \\\"\\\"\\\"Print intermediate solutions.\\\"\\\"\\\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\\\"{v}={self.value(v)}\\\", end=\\\" \\\")\n        print()\"\n```\n\n----------------------------------------\n\nTITLE: Solution Hinting Implementation in C#\nDESCRIPTION: Demonstrates solution hinting in OR-Tools using C#. Creates a constraint optimization model with three variables, adds constraints, and provides solution hints. Includes a custom solution printer callback.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class VarArraySolutionPrinter : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinter(IntVar[] variables)\n    {\n        variables_ = variables;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        {\n            Console.WriteLine(String.Format(\"Solution #{0}: time = {1:F2} s\", solution_count_, WallTime()));\n            foreach (IntVar v in variables_)\n            {\n                Console.WriteLine(String.Format(\"  {0} = {1}\", v.ToString(), Value(v)));\n            }\n            solution_count_++;\n        }\n    }\n\n    public int SolutionCount()\n    {\n        return solution_count_;\n    }\n\n    private int solution_count_;\n    private IntVar[] variables_;\n}\n\npublic class SolutionHintingSampleSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n\n        // Creates the variables.\n        int num_vals = 3;\n\n        IntVar x = model.NewIntVar(0, num_vals - 1, \"x\");\n        IntVar y = model.NewIntVar(0, num_vals - 1, \"y\");\n        IntVar z = model.NewIntVar(0, num_vals - 1, \"z\");\n\n        // Creates the constraints.\n        model.Add(x != y);\n\n        // Solution hinting: x <- 1, y <- 2\n        model.AddHint(x, 1);\n        model.AddHint(y, 2);\n\n        model.Maximize(LinearExpr.WeightedSum(new IntVar[] { x, y, z }, new int[] { 1, 2, 3 }));\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        VarArraySolutionPrinter cb = new VarArraySolutionPrinter(new IntVar[] { x, y, z });\n        CpSolverStatus status = solver.Solve(model, cb);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Nonogram Solver with Default or Custom Puzzle\nDESCRIPTION: This snippet sets up a default Nonogram puzzle or loads a custom one from a file, then calls the main function to solve it.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table2.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nrows = 12\nrow_rule_len = 3\nrow_rules = [[0, 0, 2], [0, 1, 2], [0, 1, 1], [0, 0, 2], [0, 0, 1], [0, 0, 3],\n             [0, 0, 3], [0, 2, 2], [0, 2, 1], [2, 2, 1], [0, 2, 3], [0, 2, 2]]\n\ncols = 10\ncol_rule_len = 2\ncol_rules = [[2, 1], [1, 3], [2, 4], [3, 4], [0, 4], [0, 3], [0, 3], [0, 3],\n             [0, 2], [0, 2]]\n\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  exec(compile(open(file).read(), file, 'exec'))\nmain(rows, row_rule_len, row_rules, cols, col_rule_len, col_rules)\n```\n\n----------------------------------------\n\nTITLE: Configuring GLOP Solver Test for OR-Tools\nDESCRIPTION: Sets up a test target for the GLOP (Google's Linear Optimization Package) solver implementation in OR-Tools with conditional compilation based on GLOP availability. Links against various linear programming test libraries using WHOLE_ARCHIVE linking.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_GLOP)\n  ortools_cxx_test(\n    NAME\n      math_opt_solvers_glop_solver_test\n    SOURCES\n      \"glop_solver_test.cc\"\n    LINK_LIBRARIES\n      GTest::gmock\n      GTest::gmock_main\n      absl::status\n      ortools::math_opt_matchers\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_invalid_input_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_parameter_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_incomplete_solve_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_initial_basis_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qc_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_second_order_cone_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Optimal Schedule Generation and Main Functions\nDESCRIPTION: Functions to compute optimal schedules based on appointment demands and execute the main program logic.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/appointments.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_optimal_schedule(\n    demand: list[tuple[float, str, int]]\n) -> list[tuple[int, list[tuple[int, str]]]]:\n    \"\"\"Computes the optimal schedule for the installation input.\n\n    Args:\n      demand: a list of \\\"appointment types\\\". Each \\\"appointment type\\\" is a triple\n        (ideal_ratio_pct, name, duration_minutes), where ideal_ratio_pct is the\n        ideal percentage (in [0..100.0]) of that type of appointment among all\n        appointments scheduled.\n\n    Returns:\n      The same output type as EnumerateAllKnapsacksWithRepetition.\n    \"\"\"\n    combinations = enumerate_all_knapsacks_with_repetition(\n        [a[2] + _COMMUTE_TIME.value for a in demand],\n        _LOAD_MIN.value,\n        _LOAD_MAX.value,\n    )\n    print(\n        (\n            \"Found %d possible day schedules \" % len(combinations)\n            + \"(i.e. combination of appointments filling up one worker's day)\"\n        )\n    )\n\n    selection = aggregate_item_collections_optimally(\n        combinations, _NUM_WORKERS.value, [a[0] / 100.0 for a in demand]\n    )\n    output = []\n    for i, s in enumerate(selection):\n        if s != 0:\n            output.append(\n                (\n                    s,\n                    [\n                        (combinations[i][t], d[1])\n                        for t, d in enumerate(demand)\n                        if combinations[i][t] != 0\n                    ],\n                )\n            )\n\n    return output\n\ndef main(_):\n    demand = [(45.0, \"Type1\", 90), (30.0, \"Type2\", 120), (25.0, \"Type3\", 180)]\n    print(\"*** input problem ***\")\n    print(\"Appointments: \")\n    for a in demand:\n        print(\"   %.2f%% of %s : %d min\" % (a[0], a[1], a[2]))\n    print(\"Commute time = %d\" % _COMMUTE_TIME.value)\n    print(\n        \"Acceptable duration of a work day = [%d..%d]\"\n        % (_LOAD_MIN.value, _LOAD_MAX.value)\n    )\n    print(\"%d workers\" % _NUM_WORKERS.value)\n    selection = get_optimal_schedule(demand)\n    print()\n    installed = 0\n    installed_per_type = {}\n    for a in demand:\n        installed_per_type[a[1]] = 0\n\n    print(\"*** output solution ***\")\n    for template in selection:\n        num_instances = template[0]\n        print(\"%d schedules with \" % num_instances)\n        for t in template[1]:\n            mult = t[0]\n            print(\"   %d installation of type %s\" % (mult, t[1]))\n            installed += num_instances * mult\n            installed_per_type[t[1]] += num_instances * mult\n\n    print()\n    print(\"%d installations planned\" % installed)\n    for a in demand:\n        name = a[1]\n        per_type = installed_per_type[name]\n        if installed != 0:\n            print(\n                f\"   {per_type} ({per_type * 100.0 / installed}%) installations of\"\n                f\" type {name} planned\"\n            )\n```\n\n----------------------------------------\n\nTITLE: Implementing Solution Callback for VRP\nDESCRIPTION: Defines a SolutionCallback class to track and print improved solutions during the optimization process. It stores objectives and limits the number of improvements to track.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_solution_callback.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass SolutionCallback:\n    \"\"\"Create a solution callback.\"\"\"\n\n    def __init__(\n        self,\n        manager: pywrapcp.RoutingIndexManager,\n        model: pywrapcp.RoutingModel,\n        limit: int,\n    ):\n        # We need a weak ref on the routing model to avoid a cycle.\n        self._routing_manager_ref = weakref.ref(manager)\n        self._routing_model_ref = weakref.ref(model)\n        self._counter = 0\n        self._counter_limit = limit\n        self.objectives = []\n\n    def __call__(self):\n        objective = int(\n            self._routing_model_ref().CostVar().Value()\n        )  # pytype: disable=attribute-error\n        if not self.objectives or objective < self.objectives[-1]:\n            self.objectives.append(objective)\n            print_solution(self._routing_manager_ref(), self._routing_model_ref())\n            self._counter += 1\n        if self._counter > self._counter_limit:\n            self._routing_model_ref().solver().FinishCurrentSearch()\n```\n\n----------------------------------------\n\nTITLE: Formatting Vehicle Routing Solution Output\nDESCRIPTION: A function that formats the output of a routing solution as a readable string. It extracts information about routes, load, time windows, and identifies dropped orders that couldn't be serviced in the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\ndef vehicle_output_string(manager, routing, plan):\n    \"\"\"\n    Return a string displaying the output of the routing instance and\n    assignment (plan).\n\n    Args: routing (ortools.constraint_solver.pywrapcp.RoutingModel): routing.\n    plan (ortools.constraint_solver.pywrapcp.Assignment): the assignment.\n\n    Returns:\n        (string) plan_output: describing each vehicle's plan.\n\n        (List) dropped: list of dropped orders.\n\n    \"\"\"\n    dropped = []\n    for order in range(routing.Size()):\n        if (plan.Value(routing.NextVar(order)) == order):\n            dropped.append(str(order))\n\n    capacity_dimension = routing.GetDimensionOrDie('Capacity')\n    time_dimension = routing.GetDimensionOrDie('Time')\n    plan_output = ''\n\n    for route_number in range(routing.vehicles()):\n        order = routing.Start(route_number)\n        plan_output += 'Route {0}:'.format(route_number)\n        if routing.IsEnd(plan.Value(routing.NextVar(order))):\n            plan_output += ' Empty \\n'\n        else:\n            while True:\n                load_var = capacity_dimension.CumulVar(order)\n                time_var = time_dimension.CumulVar(order)\n                node = manager.IndexToNode(order)\n                plan_output += \\\n                    ' {node} Load({load}) Time({tmin}, {tmax}) -> '.format(\n                        node=node,\n                        load=plan.Value(load_var),\n                        tmin=str(timedelta(seconds=plan.Min(time_var))),\n                        tmax=str(timedelta(seconds=plan.Max(time_var))))\n\n                if routing.IsEnd(order):\n                    plan_output += ' EndRoute {0}. \\n'.format(route_number)\n                    break\n                order = plan.Value(routing.NextVar(order))\n        plan_output += '\\n'\n\n    return (plan_output, dropped)\n```\n\n----------------------------------------\n\nTITLE: Implementing Earliness-Tardiness Cost Function in Go\nDESCRIPTION: Go implementation of a piecewise linear cost function using OR-Tools CP-SAT solver. Demonstrates how to create and solve optimization models with decision variables and constraints in Go.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nconst (\n\tearlinessDate = 5\n\tearlinesCost = 8\n\tlatenessDate  = 15\n\tlatenessCost  = 12\n\tlargeConstant = 1000\n)\n\nfunc earlinessTardinessCostSampleSat() error {\n\t// Create the CP-SAT model.\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\t// Declare our primary variable.\n\tx := model.NewIntVar(0, 20)\n\n\t// Create the expression variable and implement the piecewise linear function.\n\t//\n\t//  \\        /\n\t//   \\______/\n\t//   ed    ld\n\t//\n\texpr := model.NewIntVar(0, largeConstant)\n\n\t// Link together expr and x through the 3 segments.\n\tfirstSegment := cpmodel.NewConstant(earlinessDate*earlinessCost).AddTerm(x, -earlinessCost)\n\tsecondSegment := cpmodel.NewConstant(0)\n\tthirdSegment := cpmodel.NewConstant(-latenessDate*latenessCost).AddTerm(x, latenessCost)\n\tmodel.AddMaxEquality(expr, firstSegment, secondSegment, thirdSegment)\n\n\t// Search for x values in increasing order.\n\tmodel.AddDecisionStrategy([]cpmodel.IntVar{x}, cmpb.DecisionStrategyProto_CHOOSE_FIRST, cmpb.DecisionStrategyProto_SELECT_MIN_VALUE)\n\n\t// Create a solver and solve with a fixed search.\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tparams := &sppb.SatParameters{\n\t\tFillAdditionalSolutionsInResponse: proto.Bool(true),\n\t\tEnumerateAllSolutions:             proto.Bool(true),\n\t\tSolutionPoolSize:                  proto.Int32(21),\n\t\tSearchBranching:                   sppb.SatParameters_FIXED_SEARCH.Enum(),\n\t}\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Printf(\"Status: %v\\n\", response.GetStatus())\n\n\tfor _, additionalSolution := range response.GetAdditionalSolutions() {\n\t\tvs := additionalSolution.GetValues()\n\t\tfmt.Printf(\"x= %v expr= %v\\n\", vs[x.Index()], vs[expr.Index()])\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := earlinessTardinessCostSampleSat(); err != nil {\n\t\tlog.Exitf(\"earlinessTardinessCostSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Building Product Variable Constraint\nDESCRIPTION: Function to construct a product constraint between a Boolean and integer variable, creating a new variable that represents their product with specific enforcement rules\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bool_and_int_var_product_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef build_product_var(\n    model: cp_model.CpModel, b: cp_model.IntVar, x: cp_model.IntVar, name: str\n) -> cp_model.IntVar:\n    p = model.new_int_var_from_domain(\n        cp_model.Domain.from_flat_intervals(x.proto.domain).union_with(\n            cp_model.Domain(0, 0)\n        ),\n        name,\n    )\n    model.add(p == x).only_enforce_if(b)\n    model.add(p == 0).only_enforce_if(~b)\n    return p\n```\n\n----------------------------------------\n\nTITLE: Implementing If-Then-Else Channeling Constraints in Java with CP-SAT\nDESCRIPTION: This Java example demonstrates how to implement channeling constraints using the CP-SAT solver from Google OR-Tools. It creates conditional logic where a boolean variable b controls whether y equals 10-x or y equals 0 based on the value of x, using half-reified constraints with onlyEnforceIf.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.BoolVar;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.DecisionStrategyProto;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.LinearExpr;\nimport com.google.ortools.sat.SatParameters;\n\n/** Link integer constraints together. */\npublic final class ChannelingSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the CP-SAT model.\n    CpModel model = new CpModel();\n\n    // Declare our two primary variables.\n    IntVar[] vars = new IntVar[] {model.newIntVar(0, 10, \"x\"), model.newIntVar(0, 10, \"y\")};\n\n    // Declare our intermediate boolean variable.\n    BoolVar b = model.newBoolVar(\"b\");\n\n    // Implement b == (x >= 5).\n    model.addGreaterOrEqual(vars[0], 5).onlyEnforceIf(b);\n    model.addLessOrEqual(vars[0], 4).onlyEnforceIf(b.not());\n\n    // Create our two half-reified constraints.\n    // First, b implies (y == 10 - x).\n    model.addEquality(LinearExpr.sum(vars), 10).onlyEnforceIf(b);\n    // Second, not(b) implies y == 0.\n    model.addEquality(vars[1], 0).onlyEnforceIf(b.not());\n\n    // Search for x values in increasing order.\n    model.addDecisionStrategy(new IntVar[] {vars[0]},\n        DecisionStrategyProto.VariableSelectionStrategy.CHOOSE_FIRST,\n        DecisionStrategyProto.DomainReductionStrategy.SELECT_MIN_VALUE);\n\n    // Create the solver.\n    CpSolver solver = new CpSolver();\n\n    // Force the solver to follow the decision strategy exactly.\n    solver.getParameters().setSearchBranching(SatParameters.SearchBranching.FIXED_SEARCH);\n    // Tell the solver to enumerate all solutions.\n    solver.getParameters().setEnumerateAllSolutions(true);\n\n    // Solve the problem with the printer callback.\n    CpSolverStatus unusedStatus = solver.solve(model, new CpSolverSolutionCallback() {\n      public CpSolverSolutionCallback init(IntVar[] variables) {\n        variableArray = variables;\n        return this;\n      }\n\n      @Override\n      public void onSolutionCallback() {\n        for (IntVar v : variableArray) {\n          System.out.printf(\"%s=%d \", v.getName(), value(v));\n        }\n        System.out.println();\n      }\n\n      private IntVar[] variableArray;\n    }.init(new IntVar[] {vars[0], vars[1], b}));\n  }\n\n  private ChannelingSampleSat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Distance Scaling and Optimization Strategy\nDESCRIPTION: Implements a scaled distance calculation approach to maximize minimum pairwise robot distances, using integer variable constraints and multiplication\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/spread_robots_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nscaling = 1000\n    scaled_min_square_distance = model.new_int_var(\n        0, 2 * scaling * room_size**2, \"scaled_min_square_distance\"\n    )\n\n    # Build intermediate variables and get the list of squared distances\n    for i in range(num_robots - 1):\n        for j in range(i + 1, num_robots):\n            x_diff = model.new_int_var(-room_size, room_size, f\"x_diff{i}\")\n            y_diff = model.new_int_var(-room_size, room_size, f\"y_diff{i}\")\n            model.add(x_diff == x[i] - x[j])\n            model.add(y_diff == y[i] - y[j])\n```\n\n----------------------------------------\n\nTITLE: Main Function and Solver Selection for Steel Mill Slab Problem in Python\nDESCRIPTION: The main function that selects and executes the appropriate solver for the steel mill slab problem based on command-line arguments. It supports three different solving approaches: basic SAT solver, SAT with table constraints, and SAT with column generation. The function takes a single underscore parameter typically used in the absl flags framework.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef main(_):\n    if _SOLVER.value == \"sat\":\n        steel_mill_slab(_PROBLEM.value, _BREAK_SYMMETRIES.value)\n    elif _SOLVER.value == \"sat_table\":\n        steel_mill_slab_with_valid_slabs(_PROBLEM.value, _BREAK_SYMMETRIES.value)\n    elif _SOLVER.value == \"sat_column\":\n        steel_mill_slab_with_column_generation(_PROBLEM.value)\n    else:\n        print(f\"Unknown model {_SOLVER.value}\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving the CP-SAT Model and Checking Solution Status\nDESCRIPTION: Creates a CP solver instance, optionally applies parameters from command line, solves the model, and checks whether an optimal or feasible solution was found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Solve model.\nsolver = cp_model.CpSolver()\nif _PARAMS.value:\n    text_format.Parse(_PARAMS.value, solver.parameters)\n\nstatus = solver.solve(model)\n\nif status != cp_model.OPTIMAL and status != cp_model.FEASIBLE:\n    return -1\n```\n\n----------------------------------------\n\nTITLE: Plotting and Displaying Vehicle Routes in Python\nDESCRIPTION: This code snippet plots the vehicle routes using a previously defined function and displays the result using matplotlib. If no assignment is found, it prints a message indicating so.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\nplot_vehicle_routes(vehicle_routes, ax, customers, vehicles)\nplt.show()\n\nelse:\n    print('No assignment')\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Routing Enums Protocol Buffer\nDESCRIPTION: Protocol buffer definition containing enumeration types used in routing parameter configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/README.md#2025-04-17_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nrouting_enums.proto\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit in Python CP-SAT Solver\nDESCRIPTION: Python code example showing how to set a maximum execution time of 10 seconds for a CP-SAT solver. This sample creates a minimal constraint problem with three variables and a not-equal constraint, demonstrating the solver parameters configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Solves a problem with a time limit.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef solve_with_time_limit_sample_sat():\n    \"\"\"Minimal CP-SAT example to showcase calling the solver.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n    # Adds an all-different constraint.\n    model.add(x != y)\n\n    # Creates a solver and solves the model.\n    solver = cp_model.CpSolver()\n\n    # Sets a time limit of 10 seconds.\n    solver.parameters.max_time_in_seconds = 10.0\n\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(f\"x = {solver.value(x)}\")\n        print(f\"y = {solver.value(y)}\")\n        print(f\"z = {solver.value(z)}\")\n\n\nsolve_with_time_limit_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Integrating OR-Tools using CMake FetchContent\nDESCRIPTION: CMake configuration demonstrating how to fetch and link OR-Tools using FetchContent module. Requires CMake 3.18 or higher and creates an executable that links against the OR-Tools library. May require -DBUILD_DEPS=ON option for complete dependency resolution.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.18)\nproject(myproj VERSION 1.0 LANGUAGES CXX)\n\ninclude(FetchContent)\nFetchContent_Declare(\n  or-tools\n  GIT_REPOSITORY https://github.com/google/or-tools.git\n  GIT_TAG        main\n)\n\n# After the following call, the CMake targets defined by OR-Tools\n# will be defined and available to the rest of the build\nFetchContent_MakeAvailable(or-tools)\n\nadd_executable(myapp main.cpp)\ntarget_link_libraries(myapp ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Sicherman Dice Solver Implementation\nDESCRIPTION: Main implementation of the Sicherman dice problem using OR-Tools constraint solver. The code finds pairs of 6-sided dice that have the same probability distribution for sums as normal dice. Includes constraints for probability distribution matching, symmetry breaking, and solution search.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sicherman_dice.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Sicherman dice\")\n\n  #\n  # data\n  #\n  n = 6\n  m = 10\n\n  # standard distribution\n  standard_dist = [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]\n\n  #\n  # declare variables\n  #\n\n  # the two dice\n  x1 = [solver.IntVar(0, m, \"x1(%i)\" % i) for i in range(n)]\n  x2 = [solver.IntVar(0, m, \"x2(%i)\" % i) for i in range(n)]\n\n  #\n  # constraints\n  #\n  # [solver.Add(standard_dist[k] == solver.Sum([x1[i] + x2[j] == k+2 for i in range(n) for j in range(n)]))\n  # for k in range(len(standard_dist))]\n  for k in range(len(standard_dist)):\n    tmp = [solver.BoolVar() for i in range(n) for j in range(n)]\n    for i in range(n):\n      for j in range(n):\n        solver.Add(tmp[i * n + j] == solver.IsEqualCstVar(x1[i] + x2[j], k + 2))\n    solver.Add(standard_dist[k] == solver.Sum(tmp))\n\n  # symmetry breaking\n  [solver.Add(x1[i] <= x1[i + 1]) for i in range(n - 1)],\n  [solver.Add(x2[i] <= x2[i + 1]) for i in range(n - 1)],\n  [solver.Add(x1[i] <= x2[i]) for i in range(n - 1)],\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add(x1)\n  solution.Add(x2)\n\n  # db: DecisionBuilder\n  db = solver.Phase(x1 + x2, solver.INT_VAR_SIMPLE, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db)\n  num_solutions = 0\n  while solver.NextSolution():\n    print(\"x1:\", [x1[i].Value() for i in range(n)])\n    print(\"x2:\", [x2[i].Value() for i in range(n)])\n    print()\n\n    num_solutions += 1\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions, \"solver.solutions:\",\n        solver.Solutions())\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n  print(\"MemoryUsage:\", solver.MemoryUsage())\n  print(\"SearchDepth:\", solver.SearchDepth())\n  print(\"SolveDepth:\", solver.SolveDepth())\n  print(\"stamp:\", solver.Stamp())\n  print(\"solver\", solver)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Solving Set Cover Problem with MIP Solver in C++\nDESCRIPTION: This code shows how to solve the set covering problem using a Mixed Integer Programming (MIP) solver. It sets a time limit and retrieves the best solution found within that time.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/README.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nSetCoverMip mip(&ledger);\nmip.SetTimeLimitInSeconds(10);\nmip.NextSolution();\nSubsetBoolVector best_choices = ledger.GetSolution();\nLOG(INFO) << \"Cost: \" << ledger.cost();\n```\n\n----------------------------------------\n\nTITLE: Makespan and Precedence Constraint Setup in OR-Tools for Project Scheduling\nDESCRIPTION: This snippet creates the makespan variable and sets up precedence constraints between tasks. It handles both standard dependencies and RCPSP/Max problems with complex delay matrices between task starts.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Create makespan variable\nmakespan = model.new_int_var(lower_bound, horizon, \"makespan\")\nmakespan_size = model.new_int_var(1, horizon, \"interval_makespan_size\")\ninterval_makespan = model.new_interval_var(\n    makespan,\n    makespan_size,\n    model.new_constant(horizon + 1),\n    \"interval_makespan\",\n)\n\n# Add precedences.\nif problem.is_rcpsp_max:\n    # In RCPSP/Max problem, precedences are given and max delay (possible\n    # negative) between the starts of two tasks.\n    for task_id in all_active_tasks:\n        task = problem.tasks[task_id]\n        num_modes = len(task.recipes)\n\n        for successor_index, next_id in enumerate(task.successors):\n            delay_matrix = task.successor_delays[successor_index]\n            num_next_modes = len(problem.tasks[next_id].recipes)\n            for m1 in range(num_modes):\n                s1 = task_starts[task_id]\n                p1 = task_to_presence_literals[task_id][m1]\n                if next_id == sink:\n                    delay = delay_matrix.recipe_delays[m1].min_delays[0]\n                    model.add(s1 + delay <= makespan).only_enforce_if(p1)\n                else:\n                    for m2 in range(num_next_modes):\n                        delay = delay_matrix.recipe_delays[m1].min_delays[m2]\n                        s2 = task_starts[next_id]\n                        p2 = task_to_presence_literals[next_id][m2]\n                        model.add(s1 + delay <= s2).only_enforce_if([p1, p2])\nelse:\n    # Normal dependencies (task ends before the start of successors).\n    for t in all_active_tasks:\n        for n in problem.tasks[t].successors:\n            if n == sink:\n                model.add(task_ends[t] <= makespan)\n            elif n in active_tasks:\n                model.add(task_ends[t] <= task_starts[n])\n```\n\n----------------------------------------\n\nTITLE: Configuring BOP Module Build in CMake for Google OR-Tools\nDESCRIPTION: This CMake snippet configures the build for the BOP module of Google OR-Tools. It collects source files, sets up an object library, configures compiler flags, and specifies dependencies. The library is set up with position-independent code and includes necessary headers and libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/bop/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_bop)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::synchronization\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::bop ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Main Function Running All Linear Programming Examples\nDESCRIPTION: Main function that executes all the linear programming examples using different solver types (GLOP, GLPK_LP, CLP, PDLP, XPRESS_LP) with both the natural language API and C++ style API.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_programming.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    RunLinearExampleNaturalLanguageAPI(\"GLOP\")\n    RunLinearExampleNaturalLanguageAPI(\"GLPK_LP\")\n    RunLinearExampleNaturalLanguageAPI(\"CLP\")\n    RunLinearExampleNaturalLanguageAPI(\"PDLP\")\n    RunLinearExampleNaturalLanguageAPI(\"XPRESS_LP\")\n\n    RunLinearExampleCppStyleAPI(\"GLOP\")\n    RunLinearExampleCppStyleAPI(\"GLPK_LP\")\n    RunLinearExampleCppStyleAPI(\"CLP\")\n    RunLinearExampleCppStyleAPI(\"PDLP\")\n    RunLinearExampleCppStyleAPI(\"XPRESS_LP\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package in a Colab environment using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/alldifferent_except_0.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools Utility Library in CMake\nDESCRIPTION: This CMake snippet configures the OR-Tools utility library component. It collects source files, excludes benchmark files, creates an object library that will be merged into the main shared library, and sets up properties, include paths, and dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/rounding_modes_benchmark.cc\")\n\nset(NAME ${PROJECT_NAME}_util)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  ZLIB::ZLIB\n  absl::base\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::util ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Search All Solutions in Python using OR-Tools\nDESCRIPTION: Demonstrates how to use OR-Tools CP-SAT solver to find all solutions for a constraint satisfaction problem with three variables and a not-equal constraint. Uses a custom solution callback printer class to display each solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample that solves a model and displays all solutions.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        self.__solution_count += 1\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n\n\ndef search_for_all_solutions_sample_sat():\n    \"\"\"Showcases calling the solver to search for all solutions.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Create the constraints.\n    model.add(x != y)\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArraySolutionPrinter([x, y, z])\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    # Solve.\n    status = solver.solve(model, solution_printer)\n\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n\n\nsearch_for_all_solutions_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Starting Node Callback for OR-Tools Routing\nDESCRIPTION: A method that establishes starting and ending depots for each vehicle and returns a callback function that provides the starting node for a given vehicle. It supports options for same or different start/end depots.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\ndef return_starting_callback(self, customers, sameStartFinish=False):\n    # create a different starting and finishing depot for each vehicle\n    self.starts = [\n        int(customers.central_start_node()) for o in range(self.number)\n    ]\n    if sameStartFinish:\n        self.ends = self.starts\n    else:\n        self.ends = [\n            int(customers.central_start_node(invert=True))\n            for o in range(self.number)\n        ]\n    # the depots will not have demands, so zero them.\n    for depot in self.starts:\n        customers.zero_depot_demands(depot)\n    for depot in self.ends:\n        customers.zero_depot_demands(depot)\n\n    def start_return(v):\n        return (self.starts[v])\n\n    return start_return\n```\n\n----------------------------------------\n\nTITLE: Boolean OR Constraint in Python\nDESCRIPTION: Shows how to implement a boolean OR constraint between variables in Python using the CP-SAT solver. The example demonstrates two equivalent ways to express this constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrates a simple Boolean constraint.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef bool_or_sample_sat():\n    model = cp_model.CpModel()\n\n    x = model.new_bool_var(\"x\")\n    y = model.new_bool_var(\"y\")\n\n    model.add_bool_or([x, y.negated()])\n    # The [] is not mandatory.\n    # ~y is equivalent to y.negated()\n    model.add_bool_or(x, ~y)\n\n\nbool_or_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for Bin Packing Problem\nDESCRIPTION: Defines items and bin capacities using pandas DataFrames, preparing input data for the optimization problem\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bin_packing_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model() -> tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Create the data for the example.\"\"\"\n\n    items_str = \"\"\"\n  item  weight\n    i1      48\n    i2      30\n    i3      19\n    i4      36\n    i5      36\n    i6      27\n    i7      42\n    i8      42\n    i9      36\n   i10      24\n   i11      30\n  \"\"\"\n\n    bins_str = \"\"\"\n  bin  capacity\n   b1       100\n   b2       100\n   b3       100\n   b4       100\n   b5       100\n   b6       100\n   b7       100\n  \"\"\"\n\n    items = pd.read_table(io.StringIO(items_str), index_col=0, sep=r\"\\s+\")\n    bins = pd.read_table(io.StringIO(bins_str), index_col=0, sep=r\"\\s+\")\n    return items, bins\n```\n\n----------------------------------------\n\nTITLE: Creating Interval Variables in Java with CP-SAT Solver\nDESCRIPTION: This Java code demonstrates how to create different types of interval variables using the CP-SAT solver. It shows creating an interval from affine expressions, creating a fixed-size interval from a start variable and constant size, and creating a completely fixed interval with specific start and size values.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.IntervalVar;\nimport com.google.ortools.sat.LinearExpr;\n\n/** Code sample to demonstrates how to build an interval. */\npublic class IntervalSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n    int horizon = 100;\n\n    // An interval can be created from three affine expressions.\n    IntVar startVar = model.newIntVar(0, horizon, \"start\");\n    IntVar endVar = model.newIntVar(0, horizon, \"end\");\n    IntervalVar intervalVar = model.newIntervalVar(\n        startVar, LinearExpr.constant(10), LinearExpr.newBuilder().add(endVar).add(2), \"interval\");\n    System.out.println(intervalVar);\n\n    // If the size is fixed, a simpler version uses the start expression and the size.\n    IntervalVar fixedSizeIntervalVar =\n        model.newFixedSizeIntervalVar(startVar, 10, \"fixed_size_interval_var\");\n    System.out.println(fixedSizeIntervalVar);\n\n    // A fixed interval can be created using another method.\n    IntervalVar fixedInterval = model.newFixedInterval(5, 10, \"fixed_interval\");\n    System.out.println(fixedInterval);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean OR Constraint in Go\nDESCRIPTION: Shows how to implement a boolean OR constraint between variables in Go using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\n// The bool_or_sample_sat command is simple example of the BoolOr constraint.\npackage main\n\nimport (\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n)\n\nfunc boolOrSampleSat() {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tx := model.NewBoolVar()\n\ty := model.NewBoolVar()\n\n\tmodel.AddBoolOr(x, y.Not())\n}\n\nfunc main() {\n\tboolOrSampleSat()\n}\n```\n\n----------------------------------------\n\nTITLE: Main function for selecting and executing bin packing model\nDESCRIPTION: Main function that orchestrates the bin packing solution process. It builds the data and selects between different solution approaches based on a model parameter: duplicate items, optional items, or items with rotation capability.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef main(_):\n    \"\"\"solve the problem with all models.\"\"\"\n    data, max_height, max_width = build_data()\n    if _MODEL.value == \"duplicate\":\n        solve_with_duplicate_items(data, max_height, max_width)\n    elif _MODEL.value == \"optional\":\n        solve_with_duplicate_optional_items(data, max_height, max_width)\n    else:\n        solve_with_rotations(data, max_height, max_width)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing SolutionPrinter Class for CP-SAT Solver\nDESCRIPTION: This class extends CpSolverSolutionCallback to print intermediate solutions during the solving process. It displays the objective value and the composition of each group, including item values and colors.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/balance_group_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass SolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, values, colors, all_groups, all_items, item_in_group):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__solution_count = 0\n        self.__values = values\n        self.__colors = colors\n        self.__all_groups = all_groups\n        self.__all_items = all_items\n        self.__item_in_group = item_in_group\n\n    def on_solution_callback(self):\n        print(f\"Solution {self.__solution_count}\")\n        self.__solution_count += 1\n\n        print(f\"  objective value = {self.objective_value}\")\n        groups = {}\n        sums = {}\n        for g in self.__all_groups:\n            groups[g] = []\n            sums[g] = 0\n            for item in self.__all_items:\n                if self.boolean_value(self.__item_in_group[(item, g)]):\n                    groups[g].append(item)\n                    sums[g] += self.__values[item]\n\n        for g in self.__all_groups:\n            group = groups[g]\n            print(f\"group {g}: sum = {sums[g]:0.2f} [\", end=\"\")\n            for item in group:\n                value = self.__values[item]\n                color = self.__colors[item]\n                print(f\" ({item}, {value}, {color})\", end=\"\")\n            print(\"]\")\n```\n\n----------------------------------------\n\nTITLE: Creating Demand Callback Function for OR-Tools Routing\nDESCRIPTION: A method that returns a callback function for providing customer demands to the routing solver. It converts routing indices to node indices and returns the demand for that customer node.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef return_dem_callback(self):\n    \"\"\"\n    Return a callback function that gives the demands.\n\n    Returns:\n        function: dem_return(a) A function that takes the 'from' node\n            index and returns the distance in km.\n    \"\"\"\n\n    def dem_return(from_index):\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = self.manager.IndexToNode(from_index)\n        return (self.customers[from_node].demand)\n\n    return dem_return\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Product in Python with OR-Tools\nDESCRIPTION: This Python code demonstrates how to encode the product of two Boolean variables using Google's OR-Tools library. It implements the logical relation p <=> x and y using bool_or constraints and implications.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample that encodes the product of two Boolean variables.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef boolean_product_sample_sat():\n    \"\"\"Encoding of the product of two Boolean variables.\n\n    p == x * y, which is the same as p <=> x and y\n    \"\"\"\n    model = cp_model.CpModel()\n    x = model.new_bool_var(\"x\")\n    y = model.new_bool_var(\"y\")\n    p = model.new_bool_var(\"p\")\n\n    # x and y implies p, rewrite as not(x and y) or p.\n    model.add_bool_or(~x, ~y, p)\n\n    # p implies x and y, expanded into two implications.\n    model.add_implication(p, x)\n    model.add_implication(p, y)\n\n    # Create a solver and solve.\n    solver = cp_model.CpSolver()\n    solution_printer = cp_model.VarArraySolutionPrinter([x, y, p])\n    solver.parameters.enumerate_all_solutions = True\n    solver.solve(model, solution_printer)\n\n\nboolean_product_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Search All Solutions in Go using OR-Tools\nDESCRIPTION: Demonstrates configuration of OR-Tools CP-SAT solver in Go to find all solutions. Uses solver parameters to enable solution enumeration and store solutions in the response.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n// The search_for_all_solutions_sample_sat command is an example for how to search for\n// all solutions.\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tsppb \"github.com/google/or-tools/ortools/sat/proto/satparameters\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc searchForAllSolutionsSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tdomain := cpmodel.NewDomain(0, 2)\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVarFromDomain(domain).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\n\tmodel.AddNotEqual(x, y)\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\t// Currently, the CpModelBuilder does not allow for callbacks, so each feasible solution cannot\n\t// be printed while solving. However, the CP Solver can return all of the enumerated solutions\n\t// in the response by setting the following parameters.\n\tparams := &sppb.SatParameters{\n\t\tEnumerateAllSolutions:             proto.Bool(true),\n\t\tFillAdditionalSolutionsInResponse: proto.Bool(true),\n\t\tSolutionPoolSize:                  proto.Int32(27),\n\t}\n\tresponse, err := cpmodel.SolveCpModelWithParameters(m, params)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfor i, solution := range response.GetAdditionalSolutions() {\n\t\tvs := solution.GetValues()\n\t\tfmt.Printf(\"Solution %v: x = %v, y = %v, z = %v\\n\", i, vs[x.Index()], vs[y.Index()], vs[z.Index()])\n\t}\n\n\tfmt.Println(\"Number of solutions found: \", len(response.GetAdditionalSolutions()))\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := searchForAllSolutionsSampleSat(); err != nil {\n\t\tlog.Exitf(\"searchForAllSolutionsSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Solving RCPSP Problem with OR-Tools in Python\nDESCRIPTION: Function call to solve a Resource-Constrained Project Scheduling Problem using OR-Tools. It passes the problem definition, output file path, solver parameters, task specifications, and boundary constraints to the solver function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsolve_rcpsp(\n    problem=problem,\n    proto_file=_OUTPUT_PROTO.value,\n    params=_PARAMS.value,\n    active_tasks=set(range(1, last_task)),\n    source=0,\n    sink=last_task,\n    intervals_of_tasks=intervals_of_tasks,\n    delays=delays,\n    in_main_solve=True,\n    initial_solution=initial_solution,\n    lower_bound=lower_bound,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Constraint Programming Model for Robot Placement\nDESCRIPTION: Creates a constraint programming model to optimize robot positioning in a square room, maximizing minimum pairwise distance between robots\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/spread_robots_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef spread_robots(num_robots: int, room_size: int, params: str) -> None:\n    \"\"\"Optimize robots placement.\"\"\"\n    model = cp_model.CpModel()\n\n    # Create the list of coordinates (x, y) for each robot.\n    x = [model.new_int_var(1, room_size, f\"x_{i}\") for i in range(num_robots)]\n    y = [model.new_int_var(1, room_size, f\"y_{i}\") for i in range(num_robots)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Scheduling CP-SAT Model Solver\nDESCRIPTION: Beginning of the function that implements a scheduling-based approach using CP-SAT to solve the assembly line balancing problem. It sets up the problem data and begins creating the scheduling model variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef solve_problem_with_scheduling_model(\n    problem: Dict[str, SectionInfo], hint: Dict[int, int]\n) -> None:\n    \"\"\"solve the given problem using a cumulative model.\"\"\"\n\n    print(\"Solving using the scheduling model\")\n    # Problem data\n    num_tasks = problem[\"number of tasks\"].value\n    if num_tasks is None:\n        return\n    all_tasks = range(1, num_tasks + 1)  # Tasks are 1 based in the data.\n    durations = problem[\"task times\"].index_map\n    precedences = problem[\"precedence relations\"].set_of_pairs\n    cycle_time = problem[\"cycle time\"].value\n\n    num_pods = max(p for _, p in hint.items()) + 1 if hint else num_tasks\n\n    model = cp_model.CpModel()\n\n    # pod[t] indicates on which pod the task is performed.\n    pods = {}\n    for t in all_tasks:\n```\n\n----------------------------------------\n\nTITLE: Calculating Total Customer Demand\nDESCRIPTION: A method that returns the sum of demand across all customers in the system. It iterates through a list of customer objects and sums their demand attributes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef get_total_demand(self):\n    \"\"\"\n    Return the total demand of all customers.\n    \"\"\"\n    return (sum([c.demand for c in self.customers]))\n```\n\n----------------------------------------\n\nTITLE: Defining Default Minesweeper Game Configuration\nDESCRIPTION: Sets up default values for the Minesweeper game, including board size and mine positions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/minesweeper.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndefault_r = 8\ndefault_c = 8\nX = -1\ndefault_game = [[2, 3, X, 2, 2, X, 2, 1], [X, X, 4, X, X, 4, X, 2],\n                [X, X, X, X, X, X, 4, X], [X, 5, X, 6, X, X, X, 2],\n                [2, X, X, X, 5, 5, X, 2], [1, 3, 4, X, X, X, 4, X],\n                [0, 1, X, 4, X, X, X, 3], [0, 1, 2, X, 2, 3, X, 2]]\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools Routing Libraries\nDESCRIPTION: Imports the necessary modules from Google's OR-Tools library, specifically the routing enums and constraint solver wrapper for setting up and solving routing problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n\nDISTANCE_MATRIX = [\n    [0, 10938, 4542, 2835, 29441, 2171, 1611, 9208, 9528, 11111, 16120, 22606, 22127, 20627, 21246, 23387, 16697, 33609, 26184, 24772, 22644, 20655, 30492, 23296, 32979, 18141, 19248, 17129, 17192, 15645, 12658, 11210, 12094, 13175, 18162, 4968, 12308, 10084, 13026, 15056],\n    [10938, 0, 6422, 9742, 18988, 12974, 11216, 19715, 19004, 18271, 25070, 31971, 31632, 30571, 31578, 33841, 27315, 43964, 36944, 35689, 33569, 31481, 41360, 33760, 43631, 28730, 29976, 27803, 28076, 26408, 23504, 22025, 22000, 13197, 14936, 15146, 23246, 20956, 23963, 25994],\n    [4542, 6422, 0, 3644, 25173, 6552, 5092, 13584, 13372, 13766, 19805, 26537, 26117, 24804, 25590, 27784, 21148, 37981, 30693, 29315, 27148, 25071, 34943, 27472, 37281, 22389, 23592, 21433, 21655, 20011, 17087, 15612, 15872, 11653, 15666, 8842, 16843, 14618, 17563, 19589],\n    [2835, 9742, 3644, 0, 28681, 3851, 4341, 11660, 12294, 13912, 18893, 25283, 24777, 23173, 23636, 25696, 18950, 35927, 28233, 26543, 24127, 21864, 31765, 24018, 33904, 19005, 20295, 18105, 18551, 16763, 13958, 12459, 12296, 10370, 15331, 5430, 14044, 12135, 14771, 16743],\n    [29441, 18988, 25173, 28681, 0, 31590, 29265, 37173, 35501, 32929, 40239, 47006, 46892, 46542, 48112, 50506, 44539, 60103, 54208, 53557, 51878, 50074, 59849, 52645, 62415, 47544, 48689, 46560, 46567, 45086, 42083, 40648, 40971, 29929, 28493, 34015, 41473, 38935, 42160, 44198],\n    [2171, 12974, 6552, 3851, 31590, 0, 3046, 7856, 8864, 11330, 15411, 21597, 21065, 19382, 19791, 21845, 15099, 32076, 24425, 22848, 20600, 18537, 28396, 21125, 30825, 15975, 17101, 14971, 15104, 13503, 10544, 9080, 9983, 13435, 18755, 2947, 10344, 8306, 11069, 13078],\n    [1611, 11216, 5092, 4341, 29265, 3046, 0, 8526, 8368, 9573, 14904, 21529, 21085, 19719, 20504, 22713, 16118, 32898, 25728, 24541, 22631, 20839, 30584, 23755, 33278, 18557, 19545, 17490, 17309, 15936, 12881, 11498, 12944, 14711, 19589, 5993, 12227, 9793, 12925, 14967],\n    [9208, 19715, 13584, 11660, 37173, 7856, 8526, 0, 3248, 7855, 8245, 13843, 13272, 11526, 12038, 14201, 7599, 24411, 17259, 16387, 15050, 13999, 23134, 17899, 26460, 12894, 13251, 11680, 10455, 9997, 7194, 6574, 10678, 20959, 26458, 8180, 5255, 2615, 5730, 7552],\n    [9528, 19004, 13372, 12294, 35501, 8864, 8368, 3248, 0, 4626, 6598, 13168, 12746, 11567, 12731, 15083, 9120, 25037, 18718, 18433, 17590, 16888, 25630, 20976, 29208, 16055, 16300, 14838, 13422, 13165, 10430, 9813, 13777, 22300, 27564, 10126, 8388, 5850, 8778, 10422],\n    [11111, 18271, 13766, 13912, 32929, 11330, 9573, 7855, 4626, 0, 7318, 14185, 14005, 13655, 15438, 17849, 12839, 27179, 21947, 22230, 21814, 21366, 29754, 25555, 33535, 20674, 20872, 19457, 17961, 17787, 15048, 14372, 18115, 24280, 29101, 13400, 13008, 10467, 13375, 14935],\n    [16120, 25070, 19805, 18893, 40239, 15411, 14904, 8245, 6598, 7318, 0, 6939, 6702, 6498, 8610, 10961, 7744, 19889, 15350, 16403, 16975, 17517, 24357, 22176, 28627, 18093, 17672, 16955, 14735, 15510, 13694, 13768, 18317, 28831, 34148, 16326, 11276, 9918, 11235, 11891],\n    [22606, 31971, 26537, 25283, 47006, 21597, 21529, 13843, 13168, 14185, 6939, 0, 793, 3401, 5562, 6839, 8923, 13433, 11264, 13775, 15853, 17629, 21684, 22315, 26411, 19539, 18517, 18636, 16024, 17632, 16948, 17587, 22131, 34799, 40296, 21953, 14739, 14568, 14366, 14002],\n    [22127, 31632, 26117, 24777, 46892, 21065, 21085, 13272, 12746, 14005, 6702, 793, 0, 2608, 4809, 6215, 8151, 13376, 10702, 13094, 15099, 16845, 21039, 21535, 25744, 18746, 17725, 17845, 15232, 16848, 16197, 16859, 21391, 34211, 39731, 21345, 14006, 13907, 13621, 13225],\n    [20627, 30571, 24804, 23173, 46542, 19382, 19719, 11526, 11567, 13655, 6498, 3401, 2608, 0, 2556, 4611, 5630, 13586, 9157, 11005, 12681, 14285, 19044, 18996, 23644, 16138, 15126, 15240, 12625, 14264, 13736, 14482, 18958, 32292, 37879, 19391, 11621, 11803, 11188, 10671],\n    [21246, 31578, 25590, 23636, 48112, 19791, 20504, 12038, 12731, 15438, 8610, 5562, 4809, 2556, 0, 2411, 4917, 12395, 6757, 8451, 10292, 12158, 16488, 16799, 21097, 14374, 13194, 13590, 10943, 12824, 12815, 13779, 18042, 32259, 37918, 19416, 10975, 11750, 10424, 9475],\n    [23387, 33841, 27784, 25696, 50506, 21845, 22713, 14201, 15083, 17849, 10961, 6839, 6215, 4611, 2411, 0, 6760, 10232, 4567, 7010, 9607, 12003, 14846, 16408, 19592, 14727, 13336, 14109, 11507, 13611, 14104, 15222, 19237, 34013, 39703, 21271, 12528, 13657, 11907, 10633],\n    [16697, 27315, 21148, 18950, 44539, 15099, 16118, 7599, 9120, 12839, 7744, 8923, 8151, 5630, 4917, 6760, 0, 16982, 9699, 9400, 9302, 9823, 16998, 14534, 21042, 10911, 10190, 9900, 7397, 8758, 8119, 8948, 13353, 27354, 33023, 14542, 6106, 6901, 5609, 5084],\n    [33609, 43964, 37981, 35927, 60103, 32076, 32898, 24411, 25037, 27179, 19889, 13433, 13376, 13586, 12395, 10232, 16982, 0, 8843, 12398, 16193, 19383, 16423, 22583, 20997, 22888, 21194, 22640, 20334, 22636, 23801, 25065, 28675, 44048, 49756, 31426, 22528, 23862, 21861, 20315],\n    [26184, 36944, 30693, 28233, 54208, 24425, 25728, 17259, 18718, 21947, 15350, 11264, 10702, 9157, 6757, 4567, 9699, 8843, 0, 3842, 7518, 10616, 10666, 14237, 15515, 14053, 12378, 13798, 11537, 13852, 15276, 16632, 19957, 35660, 41373, 23361, 14333, 16125, 13624, 11866],\n    [24772, 35689, 29315, 26543, 53557, 22848, 24541, 16387, 18433, 22230, 16403, 13775, 13094, 11005, 8451, 7010, 9400, 12398, 3842, 0, 3795, 7014, 8053, 10398, 12657, 10633, 8889, 10569, 8646, 10938, 12906, 14366, 17106, 33171, 38858, 21390, 12507, 14748, 11781, 9802],\n    [22644, 33569, 27148, 24127, 51878, 20600, 22631, 15050, 17590, 21814, 16975, 15853, 15099, 12681, 10292, 9607, 9302, 16193, 7518, 3795, 0, 3250, 8084, 6873, 11763, 6949, 5177, 7050, 5619, 7730, 10187, 11689, 13792, 30012, 35654, 18799, 10406, 12981, 9718, 7682],\n    [20655, 31481, 25071, 21864, 50074, 18537, 20839, 13999, 16888, 21366, 17517, 17629, 16845, 14285, 12158, 12003, 9823, 19383, 10616, 7014, 3250, 0, 9901, 4746, 12531, 3737, 1961, 4036, 3588, 5109, 7996, 9459, 10846, 27094, 32690, 16451, 8887, 11624, 8304, 6471],\n    [30492, 41360, 34943, 31765, 59849, 28396, 30584, 23134, 25630, 29754, 24357, 21684, 21039, 19044, 16488, 14846, 16998, 16423, 10666, 8053, 8084, 9901, 0, 9363, 4870, 13117, 11575, 13793, 13300, 15009, 17856, 19337, 20454, 36551, 42017, 26352, 18403, 21033, 17737, 15720],\n    [23296, 33760, 27472, 24018, 52645, 21125, 23755, 17899, 20976, 25555, 22176, 22315, 21535, 18996, 16799, 16408, 14534, 22583, 14237, 10398, 6873, 4746, 9363, 0, 10020, 5211, 4685, 6348, 7636, 8010, 11074, 12315, 11926, 27537, 32880, 18634, 12644, 15358, 12200, 10674],\n    [32979, 43631, 37281, 33904, 62415, 30825, 33278, 26460, 29208, 33535, 28627, 26411, 25744, 23644, 21097, 19592, 21042, 20997, 15515, 12657, 11763, 12531, 4870, 10020, 0, 14901, 13738, 15855, 16118, 17348, 20397, 21793, 21936, 37429, 42654, 28485, 21414, 24144, 20816, 18908],\n    [18141, 28730, 22389, 19005, 47544, 15975, 18557, 12894, 16055, 20674, 18093, 19539, 18746, 16138, 14374, 14727, 10911, 22888, 14053, 10633, 6949, 3737, 13117, 5211, 14901, 0, 1777, 1217, 3528, 2896, 5892, 7104, 7338, 23517, 29068, 13583, 7667, 10304, 7330, 6204],\n    [19248, 29976, 23592, 20295, 48689, 17101, 19545, 13251, 16300, 20872, 17672, 18517, 17725, 15126, 13194, 13336, 10190, 21194, 12378, 8889, 5177, 1961, 11575, 4685, 13738, 1777, 0, 2217, 2976, 3610, 6675, 8055, 8965, 25197, 30774, 14865, 8007, 10742, 7532, 6000],\n    [17129, 27803, 21433, 18105, 46560, 14971, 17490, 11680, 14838, 19457, 16955, 18636, 17845, 15240, 13590, 14109, 9900, 22640, 13798, 10569, 7050, 4036, 13793, 6348, 15855, 1217, 2217, 0, 2647, 1686, 4726, 6000, 6810, 23060, 28665, 12674, 6450, 9094, 6117, 5066],\n    [17192, 28076, 21655, 18551, 46567, 15104, 17309, 10455, 13422, 17961, 14735, 16024, 15232, 12625, 10943, 11507, 7397, 20334, 11537, 8646, 5619, 3588, 13300, 7636, 16118, 3528, 2976, 2647, 0, 2320, 4593, 6093, 8479, 24542, 30219, 13194, 5301, 8042, 4735, 3039],\n    [15645, 26408, 20011, 16763, 45086, 13503, 15936, 9997, 13165, 17787, 15510, 17632, 16848, 14264, 12824, 13611, 8758, 22636, 13852, 10938, 7730, 5109, 15009, 8010, 17348, 2896, 3610, 1686, 2320, 0, 3086, 4444, 6169, 22301, 27963, 11344, 4780, 7408, 4488, 3721],\n    [12658, 23504, 17087, 13958, 42083, 10544, 12881, 7194, 10430, 15048, 13694, 16948, 16197, 13736, 12815, 14104, 8119, 23801, 15276, 12906, 10187, 7996, 17856, 11074, 20397, 5892, 6675, 4726, 4593, 3086, 0, 1501, 5239, 20390, 26101, 8611, 2418, 4580, 2599, 3496],\n    [11210, 22025, 15612, 12459, 40648, 9080, 11498, 6574, 9813, 14372, 13768, 17587, 16859, 14482, 13779, 15222, 8948, 25065, 16632, 14366, 11689, 9459, 19337, 12315, 21793, 7104, 8055, 6000, 6093, 4444, 1501, 0, 4608, 19032, 24747, 7110, 2860, 4072, 3355, 4772],\n    [12094, 22000, 15872, 12296, 40971, 9983, 12944, 10678, 13777, 18115, 18317, 22131, 21391, 18958, 18042, 19237, 13353, 28675, 19957, 17106, 13792, 10846, 20454, 11926, 21936, 7338, 8965, 6810, 8479, 6169, 5239, 4608, 0, 16249, 21866, 7146, 7403, 8446, 7773, 8614]\n```\n\n----------------------------------------\n\nTITLE: Implementing Solution Printer Callback\nDESCRIPTION: Custom solution callback class for printing intermediate solutions during constraint solving, accepting a list of variables to track and display their values\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bool_and_int_var_product_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n\n    def on_solution_callback(self) -> None:\n        for v in self.__variables:\n            print(f\"{v}={self.value(v)}\", end=\" \")\n        print()\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit in Java CP-SAT Solver\nDESCRIPTION: Java example demonstrating how to set a time limit of 10 seconds on a CP-SAT solver. The code creates a simple constraint satisfaction problem with three variables and uses the solver parameters to set the maximum execution time.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\n\n/** Solves a problem with a time limit. */\npublic final class SolveWithTimeLimitSampleSat {\n  public static void main(String[] args) {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n    // Create the constraint.\n    model.addDifferent(x, y);\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    solver.getParameters().setMaxTimeInSeconds(10.0);\n    CpSolverStatus status = solver.solve(model);\n\n    if (status == CpSolverStatus.OPTIMAL) {\n      System.out.println(\"x = \" + solver.value(x));\n      System.out.println(\"y = \" + solver.value(y));\n      System.out.println(\"z = \" + solver.value(z));\n    }\n  }\n\n  private SolveWithTimeLimitSampleSat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Intervals in Python using OR-Tools\nDESCRIPTION: Demonstrates creation of optional interval variables in Python using OR-Tools CP-SAT solver. Shows three ways to create intervals: with variable duration, with fixed size, and with fixed start and size.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\nfrom ortools.sat.python import cp_model\n\ndef optional_interval_sample_sat():\n    model = cp_model.CpModel()\n    horizon = 100\n    start_var = model.new_int_var(0, horizon, \"start\")\n    duration = 10\n    end_var = model.new_int_var(0, horizon, \"end\")\n    presence_var = model.new_bool_var(\"presence\")\n    interval_var = model.new_optional_interval_var(\n        start_var, duration, end_var + 2, presence_var, \"interval\"\n    )\n    fixed_size_interval_var = model.new_optional_fixed_size_interval_var(\n        start_var, 10, presence_var, \"fixed_size_interval_var\"\n    )\n    fixed_interval = model.new_optional_fixed_size_interval_var(\n        5, 10, presence_var, \"fixed_interval\"\n    )\n\noptional_interval_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Using Assumptions to Explain Infeasibility in Java\nDESCRIPTION: Java code sample demonstrating how to use assumptions to diagnose infeasibility in CP-SAT. The example creates a model with conflicting constraints controlled by boolean literals, designates them as assumptions, and then prints the sufficient assumptions that cause infeasibility.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/troubleshooting.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.Literal;\n\n/** Minimal CP-SAT example to showcase assumptions. */\npublic class AssumptionsSampleSat {\n  public static void main(String[] args) {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n\n    // Create the variables.\n    IntVar x = model.newIntVar(0, 10, \"x\");\n    IntVar y = model.newIntVar(0, 10, \"y\");\n    IntVar z = model.newIntVar(0, 10, \"z\");\n    Literal a = model.newBoolVar(\"a\");\n    Literal b = model.newBoolVar(\"b\");\n    Literal c = model.newBoolVar(\"c\");\n\n    // Creates the constraints.\n    model.addGreaterThan(x, y).onlyEnforceIf(a);\n    model.addGreaterThan(y, z).onlyEnforceIf(b);\n    model.addGreaterThan(z, x).onlyEnforceIf(c);\n\n    // Add assumptions\n    model.addAssumptions(new Literal[] {a, b, c});\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    CpSolverStatus status = solver.solve(model);\n\n    // Print solution.\n    // Check that the problem is infeasible.\n    if (status == CpSolverStatus.INFEASIBLE) {\n      System.out.println(solver.sufficientAssumptionsForInfeasibility());\n    }\n  }\n\n  private AssumptionsSampleSat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Filtering C++ Samples for OR-Tools Math Optimization\nDESCRIPTION: This CMake script filters and compiles C++ sample files for the math optimization component of OR-Tools. It skips compilation if samples aren't enabled, filters out specific files based on whether SCIP is available, and excludes files that would cause naming conflicts.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/samples/cpp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BUILD_SAMPLES)\n  return()\nendif()\n\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"area_socp.cc$\")\n\n  if(NOT USE_SCIP)\n    list(FILTER CXX_SRCS EXCLUDE REGEX \"cocktail_hour.cc$\")\n    list(FILTER CXX_SRCS EXCLUDE REGEX \"lagrangian_relaxation.cc$\")\n    list(FILTER CXX_SRCS EXCLUDE REGEX \"time_indexed_scheduling.cc$\")\n  endif()\n  # conflict name\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"basic_example.cc$\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"tsp.cc$\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"integer_programming.cc$\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"linear_programming.cc$\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"linear_regression.cc$\")\n\n\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(\n      FILE_NAME ${SAMPLE}\n      COMPONENT_NAME math_opt)\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints and Defining Objective\nDESCRIPTION: Adds constraints to the solver, including the relationship between input data and variables, and defines the objective function to minimize the total sum.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle2.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n  for i in range(rows):\n    for j in range(cols):\n      solver.Add(x[i, j] == data[i][j] * row_signs[i] * col_signs[j])\n\n  total_sum = solver.Sum([x[i, j] for i in range(rows) for j in range(cols)])\n\n  row_sums = [\n      solver.Sum([x[i, j] for j in range(cols)]).Var() for i in range(rows)\n  ]\n  for i in range(rows):\n    row_sums[i].SetMin(0)\n\n  col_sums = [\n      solver.Sum([x[i, j] for i in range(rows)]).Var() for j in range(cols)\n  ]\n  for j in range(cols):\n    col_sums[j].SetMin(0)\n\n  objective = solver.Minimize(total_sum, 1)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/hidato_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Adding Math Optimization Subdirectories in CMake\nDESCRIPTION: Adds various subdirectories containing different components of the math optimization module.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(core)\nadd_subdirectory(constraints)\nadd_subdirectory(cpp)\nadd_subdirectory(io)\nadd_subdirectory(labs)\nadd_subdirectory(solver_tests)\nadd_subdirectory(solvers)\nadd_subdirectory(storage)\nadd_subdirectory(validators)\n```\n\n----------------------------------------\n\nTITLE: Solving Rabbits and Pheasants Problem in C++\nDESCRIPTION: C++ implementation of the Rabbits and Pheasants puzzle using CP-SAT solver. Demonstrates integer variable creation with domains and linear constraint addition.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid RabbitsAndPheasantsSat() {\n  CpModelBuilder cp_model;\n\n  const Domain all_animals(0, 20);\n  const IntVar rabbits = cp_model.NewIntVar(all_animals).WithName(\"rabbits\");\n  const IntVar pheasants =\n      cp_model.NewIntVar(all_animals).WithName(\"pheasants\");\n\n  cp_model.AddEquality(rabbits + pheasants, 20);\n  cp_model.AddEquality(4 * rabbits + 2 * pheasants, 56);\n\n  const CpSolverResponse response = Solve(cp_model.Build());\n\n  if (response.status() == CpSolverStatus::OPTIMAL) {\n    // Get the value of x in the solution.\n    LOG(INFO) << SolutionIntegerValue(response, rabbits) << \" rabbits, and \"\n              << SolutionIntegerValue(response, pheasants) << \" pheasants\";\n  }\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::RabbitsAndPheasantsSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Hidato Puzzles with CP-SAT in Python\nDESCRIPTION: Implementation of a Hidato puzzle solver using Google's CP-SAT solver. The code models the constraint that consecutive numbers must touch each other in the grid, defines several puzzle instances, and visualizes the solutions.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/README.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom google3.util.operations_research.sat.python import cp_model\nfrom google3.util.operations_research.sat.colab import visualization\n\n\ndef BuildPairs(rows, cols):\n  \"\"\"Build closeness pairs for consecutive numbers.\n\n  Build set of allowed pairs such that two consecutive numbers touch\n  each other in the grid.\n\n  Returns:\n    A list of pairs for allowed consecutive position of numbers.\n\n  Args:\n    rows: the number of rows in the grid\n    cols: the number of columns in the grid\n  \"\"\"\n  return [(x * cols + y, (x + dx) * cols + (y + dy))\n          for x in range(rows) for y in range(cols)\n          for dx in (-1, 0, 1) for dy in (-1, 0, 1)\n          if (x + dx >= 0 and x + dx < rows and\n              y + dy >= 0 and y + dy < cols and (dx != 0 or dy != 0))]\n\n\ndef BuildPuzzle(problem):\n  #\n  # models, a 0 indicates an open cell which number is not yet known.\n  #\n  #\n  puzzle = None\n  if problem == 1:\n    # Simple problem\n    puzzle = [[6, 0, 9],\n              [0, 2, 8],\n              [1, 0, 0]]\n\n  elif problem == 2:\n    puzzle = [[0, 44, 41, 0, 0, 0, 0],\n              [0, 43, 0, 28, 29, 0, 0],\n              [0, 1, 0, 0, 0, 33, 0],\n              [0, 2, 25, 4, 34, 0, 36],\n              [49, 16, 0, 23, 0, 0, 0],\n              [0, 19, 0, 0, 12, 7, 0],\n              [0, 0, 0, 14, 0, 0, 0]]\n\n  elif problem == 3:\n    # Problems from the book:\n    # Gyora Bededek: \"Hidato: 2000 Pure Logic Puzzles\"\n    # Problem 1 (Practice)\n    puzzle = [[0, 0, 20, 0, 0],\n              [0, 0, 0, 16, 18],\n              [22, 0, 15, 0, 0],\n              [23, 0, 1, 14, 11],\n              [0, 25, 0, 0, 12]]\n\n  elif problem == 4:\n    # problem 2 (Practice)\n    puzzle = [[0, 0, 0, 0, 14],\n              [0, 18, 12, 0, 0],\n              [0, 0, 17, 4, 5],\n              [0, 0, 7, 0, 0],\n              [9, 8, 25, 1, 0]]\n\n  elif problem == 5:\n    # problem 3 (Beginner)\n    puzzle = [[0, 26, 0, 0, 0, 18],\n              [0, 0, 27, 0, 0, 19],\n              [31, 23, 0, 0, 14, 0],\n              [0, 33, 8, 0, 15, 1],\n              [0, 0, 0, 5, 0, 0],\n              [35, 36, 0, 10, 0, 0]]\n  elif problem == 6:\n    # Problem 15 (Intermediate)\n    puzzle = [[64, 0, 0, 0, 0, 0, 0, 0],\n              [1, 63, 0, 59, 15, 57, 53, 0],\n              [0, 4, 0, 14, 0, 0, 0, 0],\n              [3, 0, 11, 0, 20, 19, 0, 50],\n              [0, 0, 0, 0, 22, 0, 48, 40],\n              [9, 0, 0, 32, 23, 0, 0, 41],\n              [27, 0, 0, 0, 36, 0, 46, 0],\n              [28, 30, 0, 35, 0, 0, 0, 0]]\n  return puzzle\n\n\ndef SolveHidato(puzzle, index):\n  \"\"\"Solve the given hidato table.\"\"\"\n  # Create the model.\n  model = cp_model.CpModel()\n\n  r = len(puzzle)\n  c = len(puzzle[0])\n\n  #\n  # declare variables\n  #\n  positions = [model.NewIntVar(0, r * c - 1, 'p[%i]' % i)\n               for i in range(r * c)]\n\n  #\n  # constraints\n  #\n  model.AddAllDifferent(positions)\n\n  #\n  # Fill in the clues\n  #\n  for i in range(r):\n    for j in range(c):\n      if puzzle[i][j] > 0:\n        model.Add(positions[puzzle[i][j] - 1] == i * c + j)\n\n  # Consecutive numbers must touch each other in the grid.\n  # We use an allowed assignment constraint to model it.\n  close_tuples = BuildPairs(r, c)\n  for k in range(0, r * c - 1):\n    model.AddAllowedAssignments([positions[k], positions[k + 1]], close_tuples)\n\n  #\n  # solution and search\n  #\n\n  solver = cp_model.CpSolver()\n  status = solver.Solve(model)\n\n  if status == cp_model.FEASIBLE:\n    output = visualization.SvgWrapper(10, r, 40.0)\n    for i in range(len(positions)):\n      val = solver.Value(positions[i])\n      x = val % c\n      y = val // c\n      color = 'white' if puzzle[y][x] == 0 else 'lightgreen'\n      value = solver.Value(positions[i])\n      output.AddRectangle(x, r - y - 1, 1, 1, color, 'black', str(i + 1))\n\n    output.AddTitle('Puzzle %i solved in %f s' % (index, solver.WallTime()))\n    output.Display()\n\n\nfor i in range(1, 7):\n  SolveHidato(BuildPuzzle(i), i)\n```\n\n----------------------------------------\n\nTITLE: Initializing Scheduling Problem Setup\nDESCRIPTION: Sets up the initial imports and command line argument parsing for the scheduling problem. Includes imports for CP-SAT solver, collections, and argument parsing. Defines parameters for problem instance selection, output proto file, and solver parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nimport collections\n\nfrom ortools.sat.python import cp_model\nfrom google.protobuf import text_format\n\n#----------------------------------------------------------------------------\n# Command line arguments.\nPARSER = argparse.ArgumentParser()\nPARSER.add_argument(\n    '--problem_instance', default=0, type=int, help='Problem instance.')\nPARSER.add_argument(\n    '--output_proto',\n    default='',\n    help='Output file to write the cp_model proto to.')\nPARSER.add_argument('--params', default='', help='Sat solver parameters.')\n```\n\n----------------------------------------\n\nTITLE: Implementing Task Class for Bakery Operations in Python\nDESCRIPTION: Defines a Task class representing bakery operations with minimum and maximum durations. Tasks can be simple operations performed by workers or waiting/cooling/proofing tasks performed by machines or using space resources.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Task:\n    \"\"\"A unit baking task.\n\n    - Simple baking tasks have a fixed duration. They are performed by workers.\n    - Waiting/cooling/proofing tasks have a min and a max duration.\n      They are performed by machine or they use space resources.\n    \"\"\"\n\n    def __init__(self, name, min_duration, max_duration):\n        self.name = name\n        self.min_duration = min_duration\n        self.max_duration = max_duration\n```\n\n----------------------------------------\n\nTITLE: Main Function for QUBO Solver Application in Python\nDESCRIPTION: The main entry point for the QUBO solver application. It handles command-line arguments and calls the solve_qubo function to execute the QUBO optimization process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/qubo_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    solve_qubo()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: FIFO Policy Pickup & Delivery Implementation\nDESCRIPTION: Implementation of Pickup & Delivery routing with First-In-First-Out (FIFO) policy, ensuring deliveries are made in the same order as pickups are performed.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/PDP.md#2025-04-17_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvrp_pickup_delivery_fifo.cc\n```\n\nLANGUAGE: Python\nCODE:\n```\nvrp_pickup_delivery_fifo.py\n```\n\nLANGUAGE: Java\nCODE:\n```\nVrpPickupDeliveryFifo.java\n```\n\nLANGUAGE: C#\nCODE:\n```\nVrpPickupDeliveryFifo.cs\n```\n\n----------------------------------------\n\nTITLE: Building Runtime Package Commands\nDESCRIPTION: Commands to build and pack Google.OrTools runtime packages for specific platform RIDs (Runtime Identifiers).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndotnet build <build_dir>/dotnet/Google.OrTools.runtime.{rid}\ndotnet pack <build_dir>/dotnet/Google.OrTools.runtime.{rid}\n```\n\n----------------------------------------\n\nTITLE: Implementing CP Solver with OR-Tools in Java\nDESCRIPTION: This Java code demonstrates how to use the OR-Tools CP solver to create variables, add constraints, solve a simple problem, and print solutions. It includes advanced usage information such as solving time and memory usage.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/CP.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.constraintsolver.samples;\nimport com.google.ortools.Loader;\nimport com.google.ortools.constraintsolver.DecisionBuilder;\nimport com.google.ortools.constraintsolver.IntVar;\nimport com.google.ortools.constraintsolver.Solver;\nimport java.util.logging.Logger;\n\n/** Simple CP Program.*/\npublic class SimpleCpProgram {\n  private SimpleCpProgram() {}\n\n  private static final Logger logger = Logger.getLogger(SimpleCpProgram.class.getName());\n\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Instantiate the solver.\n    Solver solver = new Solver(\"CpSimple\");\n\n    // Create the variables.\n    final long numVals = 3;\n    final IntVar x = solver.makeIntVar(0, numVals - 1, \"x\");\n    final IntVar y = solver.makeIntVar(0, numVals - 1, \"y\");\n    final IntVar z = solver.makeIntVar(0, numVals - 1, \"z\");\n\n    // Constraint 0: x != y..\n    solver.addConstraint(solver.makeAllDifferent(new IntVar[] {x, y}));\n    logger.info(\"Number of constraints: \" + solver.constraints());\n\n    // Solve the problem.\n    final DecisionBuilder db = solver.makePhase(\n        new IntVar[] {x, y, z}, Solver.CHOOSE_FIRST_UNBOUND, Solver.ASSIGN_MIN_VALUE);\n\n    // Print solution on console.\n    int count = 0;\n    solver.newSearch(db);\n    while (solver.nextSolution()) {\n      ++count;\n      logger.info(\n          String.format(\"Solution: %d\\n x=%d y=%d z=%d\", count, x.value(), y.value(), z.value()));\n    }\n    solver.endSearch();\n    logger.info(\"Number of solutions found: \" + solver.solutions());\n\n    logger.info(String.format(\"Advanced usage:\\nProblem solved in %d ms\\nMemory usage: %d bytes\",\n        solver.wallTime(), Solver.memoryUsage()));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving and Displaying Robot Placement Results\nDESCRIPTION: Configures the SAT solver, solves the constraint optimization problem, and prints the optimal robot positions with their minimum pairwise distance\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/spread_robots_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsolver = cp_model.CpSolver()\n    if params:\n        text_format.Parse(params, solver.parameters)\n    solver.parameters.log_search_progress = True\n    status = solver.solve(model)\n\n    # Prints the solution.\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(\n            f\"Spread {num_robots} with a min pairwise distance of\"\n            f\" {math.sqrt(solver.objective_value / scaling)}\"\n        )\n        for i in range(num_robots):\n            print(f\"robot {i}: x={solver.value(x[i])} y={solver.value(y[i])}\")\n    else:\n        print(\"No solution found.\")\n```\n\n----------------------------------------\n\nTITLE: Optimal Collection Aggregation Function\nDESCRIPTION: Function to optimally select and aggregate item collections while maintaining ideal ratios using MIP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/appointments.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef aggregate_item_collections_optimally(\n    item_collections: list[list[int]],\n    max_num_collections: int,\n    ideal_item_ratios: list[float],\n) -> list[int]:\n    \"\"\"Selects a set (with repetition) of combination of items optimally.\n\n    Given a set of collections of N possible items (in each collection, an item\n    may appear multiple times), a  given \\\"ideal breakdown of items\\\", and a\n    maximum number of collections, this method finds the optimal way to\n    aggregate the collections in order to:\n    - maximize the overall number of items\n    - while keeping the ratio of each item, among the overall selection, as close\n      as possible to a given input ratio (which depends on the item).\n    Each collection may be selected more than one time.\n\n    Args:\n      item_collections: a list of item collections. Each item collection is a list\n        of integers [#item0, ..., #itemN-1], where #itemK is the number of times\n        item #K appears in the collection, and N is the number of distinct items.\n      max_num_collections: an integer, the maximum number of item collections that\n        may be selected (counting repetitions of the same collection).\n      ideal_item_ratios: A list of N float which sums to 1.0: the K-th element is\n        the ideal ratio of item #K in the whole aggregated selection.\n\n    Returns:\n      A pair (objective value, list of pairs (item collection, num_selections)),\n      where:\n        - \\\"objective value\\\" is the value of the internal objective function used\n          by the MIP Solver\n        - Each \\\"item collection\\\" is an element of the input item_collections\n        - and its associated \\\"num_selections\\\" is the number of times it was\n          selected.\n    \"\"\"\n    solver = pywraplp.Solver.CreateSolver(\"SCIP\")\n    if not solver:\n        return []\n    n = len(ideal_item_ratios)\n    num_distinct_collections = len(item_collections)\n    max_num_items_per_collection = 0\n    for template in item_collections:\n        max_num_items_per_collection = max(max_num_items_per_collection, sum(template))\n    upper_bound = max_num_items_per_collection * max_num_collections\n\n    # num_selections_of_collection[i] is an IntVar that represents the number\n    # of times that we will use collection #i in our global selection.\n    num_selections_of_collection = [\n        solver.IntVar(0, max_num_collections, \"s[%d]\" % i)\n        for i in range(num_distinct_collections)\n    ]\n\n    # num_overall_item[i] is an IntVar that represents the total count of item #i,\n    # aggregated over all selected collections. This is enforced with dedicated\n    # constraints that bind them with the num_selections_of_collection vars.\n    num_overall_item = [\n        solver.IntVar(0, upper_bound, \"num_overall_item[%d]\" % i) for i in range(n)\n    ]\n    for i in range(n):\n        ct = solver.Constraint(0.0, 0.0)\n        ct.SetCoefficient(num_overall_item[i], -1)\n        for j in range(num_distinct_collections):\n            ct.SetCoefficient(num_selections_of_collection[j], item_collections[j][i])\n\n    # Maintain the num_all_item variable as the sum of all num_overall_item\n    # variables.\n    num_all_items = solver.IntVar(0, upper_bound, \"num_all_items\")\n    solver.Add(solver.Sum(num_overall_item) == num_all_items)\n\n    # Sets the total number of workers.\n    solver.Add(solver.Sum(num_selections_of_collection) == max_num_collections)\n\n    # Objective variables.\n    deviation_vars = [\n        solver.NumVar(0, upper_bound, \"deviation_vars[%d]\" % i) for i in range(n)\n    ]\n    for i in range(n):\n        deviation = deviation_vars[i]\n        solver.Add(\n            deviation >= num_overall_item[i] - ideal_item_ratios[i] * num_all_items\n        )\n        solver.Add(\n            deviation >= ideal_item_ratios[i] * num_all_items - num_overall_item[i]\n        )\n\n    solver.Maximize(num_all_items - solver.Sum(deviation_vars))\n\n    result_status = solver.Solve()\n\n    if result_status == pywraplp.Solver.OPTIMAL:\n        # The problem has an optimal solution.\n        return [int(v.solution_value()) for v in num_selections_of_collection]\n    return []\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean OR Constraint with OR-Tools in Python\nDESCRIPTION: This code defines a function that creates a CP-SAT model, declares two Boolean variables, and applies a Boolean OR constraint using the OR-Tools library. The function, `bool_or_sample_sat`, adds a constraint using `add_bool_or`. Dependencies include the ortools library, which must be installed beforehand. The function does not take inputs but initializes a simple SAT example for demonstration.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bool_or_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef bool_or_sample_sat():\n    model = cp_model.CpModel()\n\n    x = model.new_bool_var(\"x\")\n    y = model.new_bool_var(\"y\")\n\n    model.add_bool_or([x, y.negated()])\n    # The [] is not mandatory.\n    # ~y is equivalent to y.negated()\n    model.add_bool_or(x, ~y)\n\n\nbool_or_sample_sat()\n\n```\n\n----------------------------------------\n\nTITLE: Stopping Search After N Solutions in Java with OR-Tools CP-SAT Solver\nDESCRIPTION: This Java code illustrates how to stop the search process in OR-Tools CP-SAT solver after finding a specific number of solutions. It implements a custom solution callback class to print intermediate solutions and stop the search when the limit is reached.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_17\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\n\n/** Code sample that solves a model and displays a small number of solutions. */\npublic final class StopAfterNSolutionsSampleSat {\n  static class VarArraySolutionPrinterWithLimit extends CpSolverSolutionCallback {\n    public VarArraySolutionPrinterWithLimit(IntVar[] variables, int limit) {\n      variableArray = variables;\n      solutionLimit = limit;\n    }\n\n    @Override\n    public void onSolutionCallback() {\n      System.out.printf(\"Solution #%d: time = %.02f s%n\", solutionCount, wallTime());\n      for (IntVar v : variableArray) {\n        System.out.printf(\"  %s = %d%n\", v.getName(), value(v));\n      }\n      solutionCount++;\n      if (solutionCount >= solutionLimit) {\n        System.out.printf(\"Stop search after %d solutions%n\", solutionLimit);\n        stopSearch();\n      }\n    }\n\n    public int getSolutionCount() {\n      return solutionCount;\n    }\n\n    private int solutionCount;\n    private final IntVar[] variableArray;\n    private final int solutionLimit;\n  }\n\n  public static void main(String[] args) {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    VarArraySolutionPrinterWithLimit cb =\n        new VarArraySolutionPrinterWithLimit(new IntVar[] {x, y, z}, 5);\n    // Tell the solver to enumerate all solutions.\n    solver.getParameters().setEnumerateAllSolutions(true);\n    // And solve.\n    CpSolverStatus unusedStatus = solver.solve(model, cb);\n\n    System.out.println(cb.getSolutionCount() + \" solutions found.\");\n    if (cb.getSolutionCount() != 5) {\n      throw new RuntimeException(\"Did not stop the search correctly.\");\n    }\n  }\n\n  private StopAfterNSolutionsSampleSat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Earliness-Tardiness Cost Function in C++ using OR-Tools\nDESCRIPTION: C++ implementation of the earliness-tardiness cost function using OR-Tools CP-SAT solver. Models a piecewise linear function with early and late delivery penalties.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include <cstdint>\n\n#include \"absl/types/span.h\"\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/sat/sat_parameters.pb.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid EarlinessTardinessCostSampleSat() {\n  const int64_t kEarlinessDate = 5;\n  const int64_t kEarlinessCost = 8;\n  const int64_t kLatenessDate = 15;\n  const int64_t kLatenessCost = 12;\n\n  // Create the CP-SAT model.\n  CpModelBuilder cp_model;\n\n  // Declare our primary variable.\n  const IntVar x = cp_model.NewIntVar({0, 20});\n\n  // Create the expression variable and implement the piecewise linear function.\n  //\n  //  \\        /\n  //   \\______/\n  //   ed    ld\n  //\n  const int64_t kLargeConstant = 1000;\n  const IntVar expr = cp_model.NewIntVar({0, kLargeConstant});\n\n  // Link together expr and x through the 3 segments.\n  cp_model.AddMaxEquality(expr, {(kEarlinessDate - x) * kEarlinessCost, 0,\n                                 (x - kLatenessDate) * kLatenessCost});\n\n  // Search for x values in increasing order.\n  cp_model.AddDecisionStrategy({x}, DecisionStrategyProto::CHOOSE_FIRST,\n                               DecisionStrategyProto::SELECT_MIN_VALUE);\n\n  // Create a solver and solve with a fixed search.\n  Model model;\n  SatParameters parameters;\n  parameters.set_search_branching(SatParameters::FIXED_SEARCH);\n  parameters.set_enumerate_all_solutions(true);\n  model.Add(NewSatParameters(parameters));\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"x=\" << SolutionIntegerValue(r, x) << \" expr\"\n              << SolutionIntegerValue(r, expr);\n  }));\n  SolveCpModel(cp_model.Build(), &model);\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::EarlinessTardinessCostSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Knapsack Enumeration Function\nDESCRIPTION: Function to enumerate all possible knapsack combinations within given size constraints using constraint programming.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/appointments.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef enumerate_all_knapsacks_with_repetition(\n    item_sizes: list[int], total_size_min: int, total_size_max: int\n) -> list[list[int]]:\n    \"\"\"Enumerate all possible knapsacks with total size in the given range.\n\n    Args:\n      item_sizes: a list of integers. item_sizes[i] is the size of item #i.\n      total_size_min: an integer, the minimum total size.\n      total_size_max: an integer, the maximum total size.\n\n    Returns:\n      The list of all the knapsacks whose total size is in the given inclusive\n      range. Each knapsack is a list [#item0, #item1, ... ], where #itemK is an\n      nonnegative integer: the number of times we put item #K in the knapsack.\n    \"\"\"\n    model = cp_model.CpModel()\n    variables = [\n        model.new_int_var(0, total_size_max // size, \"\") for size in item_sizes\n    ]\n    load = sum(variables[i] * size for i, size in enumerate(item_sizes))\n    model.add_linear_constraint(load, total_size_min, total_size_max)\n\n    solver = cp_model.CpSolver()\n    solution_collector = AllSolutionCollector(variables)\n    # Enumerate all solutions.\n    solver.parameters.enumerate_all_solutions = True\n    # solve\n    solver.solve(model, solution_collector)\n    return solution_collector.combinations()\n```\n\n----------------------------------------\n\nTITLE: Setting Depot Demands to Zero\nDESCRIPTION: A utility method that modifies a customer node to serve as a depot by setting its demand and time windows to zero/None. Depots in vehicle routing problems typically don't have demands or time constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndef zero_depot_demands(self, depot):\n    \"\"\"\n    Zero out the demands and time windows of depot.  The Depots do not have\n    demands or time windows so this function clears them.\n\n    Args:  depot (int): index of the stop to modify into a depot.\n    Examples:  >>> customers.zero_depot_demands(5) >>>\n    customers.customers[5].demand == 0 True\n\"\"\"\n    start_depot = self.customers[depot]\n    self.customers[depot] = start_depot._replace(\n        demand=0, tw_open=None, tw_close=None)\n```\n\n----------------------------------------\n\nTITLE: Setting Up OR-Tools CP-SAT Dependencies\nDESCRIPTION: Imports the necessary OR-Tools libraries for the CP-SAT solver and visualization. This code must be run before any of the example problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/cp_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\nfrom ortools.sat.colab import visualization\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for VRP Solving in Python\nDESCRIPTION: Code to install the Google OR-Tools optimization package using pip in a Colab environment. OR-Tools provides the constraint solver used for Vehicle Routing Problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Gathering and Filtering Python Source Files in CMake\nDESCRIPTION: This section collects all Python files and excludes specific examples that are too long or have special requirements. It uses GLOB to find files and list filtering to exclude certain patterns.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB PYTHON_SRCS \"*.py\")\n# Remove too long examples\nlist(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/line_balancing_sat.py\") # need input file\nlist(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/bus_driver_scheduling_sat.py\") # too long\nlist(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/cvrptw_plot.py\") # depend on numpy\n```\n\n----------------------------------------\n\nTITLE: Implementing Solution Printer Callback for SAT Solver\nDESCRIPTION: Custom solution callback class to print intermediate solutions and track Boolean variable states during constraint solving\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/index_first_boolvar_true_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, index: cp_model.IntVar, boolvars: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__index = index\n        self.__boolvars = boolvars\n\n    def on_solution_callback(self) -> None:\n        line = \"\"\n        for v in self.__boolvars:\n            line += f\"{self.value(v)}\"\n        line += f\" -> {self.value(self.__index)}\"\n        print(line)\n```\n\n----------------------------------------\n\nTITLE: Fetching and Configuring Dependencies\nDESCRIPTION: Configures and fetches multiple external dependencies using FetchContent_Declare and FetchContent_MakeAvailable. Each dependency is configured with specific version tags and build options.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_ZLIB)\n  message(CHECK_START \"Fetching ZLIB\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  set(ZLIB_BUILD_EXAMPLES OFF)\n  FetchContent_Declare(\n    ZLIB\n    GIT_REPOSITORY \"https://github.com/madler/ZLIB.git\"\n    GIT_TAG \"v1.3.1\"\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/ZLIB-v1.3.1.patch\")\n  FetchContent_MakeAvailable(ZLIB)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for MIP Problem\nDESCRIPTION: Defines a function that constructs and returns a data model for a Mixed Integer Programming problem including constraints and objectives.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/mip_var_array.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"constraint_coeffs\"] = [\n        [5, 7, 9, 2, 1],\n        [18, 4, -9, 10, 12],\n        [4, 7, 3, 8, 5],\n        [5, 13, 16, 3, -7],\n    ]\n    data[\"bounds\"] = [250, 285, 211, 315]\n    data[\"obj_coeffs\"] = [7, 8, 2, 9, 6]\n    data[\"num_vars\"] = 5\n    data[\"num_constraints\"] = 4\n    return data\n```\n\n----------------------------------------\n\nTITLE: Implementing CP-SAT Solver in C++\nDESCRIPTION: Shows CP-SAT solver implementation in C++ using CpModelBuilder class. Creates integer variables with domains, adds constraints, and solves using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/README.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid SimpleSatProgram() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  cp_model.AddNotEqual(x, y);\n\n  // Solving part.\n  const CpSolverResponse response = Solve(cp_model.Build());\n\n  if (response.status() == CpSolverStatus::OPTIMAL ||\n      response.status() == CpSolverStatus::FEASIBLE) {\n    // Get the value of x in the solution.\n    LOG(INFO) << \"x = \" << SolutionIntegerValue(response, x);\n    LOG(INFO) << \"y = \" << SolutionIntegerValue(response, y);\n    LOG(INFO) << \"z = \" << SolutionIntegerValue(response, z);\n  } else {\n    LOG(INFO) << \"No solution found.\";\n  }\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::SimpleSatProgram();\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Vehicle Routes from OR-Tools Solution\nDESCRIPTION: This function extracts the route for a specific vehicle from the OR-Tools routing solution. It converts routing indices to customer nodes and builds a list of customer locations visited by the vehicle.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef build_vehicle_route(manager, routing, plan, customers, veh_number):\n    \"\"\"\n    Args: routing (ortools.constraint_solver.pywrapcp.RoutingModel): routing.\n    plan (ortools.constraint_solver.pywrapcp.Assignment): the assignment.\n    customers (Customers): the customers instance.  veh_number (int): index of\n    the vehicle\n\n    Returns:\n        (List) route: indexes of the customers for vehicle veh_number\n    \"\"\"\n    veh_used = routing.IsVehicleUsed(plan, veh_number)\n    print('Vehicle {0} is used {1}'.format(veh_number, veh_used))\n    if veh_used:\n        route = []\n        node = routing.Start(veh_number)  # Get the starting node index\n        route.append(customers.customers[manager.IndexToNode(node)])\n        while not routing.IsEnd(node):\n            route.append(customers.customers[manager.IndexToNode(node)])\n            node = plan.Value(routing.NextVar(node))\n\n        route.append(customers.customers[manager.IndexToNode(node)])\n        return route\n    else:\n        return None\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific RPATH Configuration\nDESCRIPTION: Sets platform-specific RPATH settings for macOS and Unix systems to ensure proper runtime library loading. Handles the special case of macOS which requires a different RPATH format.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(APPLE)\n  set_target_properties(init_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\")\nelseif(UNIX)\n  set_target_properties(init_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running the Magic Square Solver\nDESCRIPTION: Sets default values for the magic square size, solver type, and output matrix usage. Parses command-line arguments to override defaults, then calls the main function to solve and display the magic square.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square_mip.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = 3\nsol = 'CBC'\nuse_output_matrix = 0\nif len(sys.argv) > 1:\n  n = int(sys.argv[1])\n\nif len(sys.argv) > 2:\n  sol = sys.argv[2]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nif len(sys.argv) > 3:\n  use_output_matrix = int(sys.argv[3])\n\nmain(n, sol, use_output_matrix)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package from PyPI.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/map.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Constraints Library in CMake\nDESCRIPTION: Creates and configures a library target that combines all constraint-related object files into a single library. Sets up installation rules for the combined library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_constraints)\nadd_library(${NAME} OBJECT)\ntarget_sources(${NAME} PUBLIC\n  $<TARGET_OBJECTS:${NAME}_indicator>\n  $<TARGET_OBJECTS:${NAME}_quadratic>\n  $<TARGET_OBJECTS:${NAME}_second_order_cone>\n  $<TARGET_OBJECTS:${NAME}_sos>\n  $<TARGET_OBJECTS:${NAME}_util>\n)\ninstall(TARGETS ${NAME} EXPORT ${PROJECT_NAME}Targets)\n```\n\n----------------------------------------\n\nTITLE: Implementing If-Then-Else Channeling Constraints in C++ with CP-SAT\nDESCRIPTION: This C++ implementation shows how to create channeling constraints with the CP-SAT solver. It uses the OnlyEnforceIf method to enforce half-reified constraints that implement conditional logic where y equals 10-x when x is at least 5, and y equals 0 otherwise.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/channeling.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"absl/types/span.h\"\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/sat/sat_parameters.pb.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid ChannelingSampleSat() {\n  // Create the CP-SAT model.\n  CpModelBuilder cp_model;\n\n  // Declare our two primary variables.\n  const IntVar x = cp_model.NewIntVar({0, 10});\n  const IntVar y = cp_model.NewIntVar({0, 10});\n\n  // Declare our intermediate boolean variable.\n  const BoolVar b = cp_model.NewBoolVar();\n\n  // Implement b == (x >= 5).\n  cp_model.AddGreaterOrEqual(x, 5).OnlyEnforceIf(b);\n  cp_model.AddLessThan(x, 5).OnlyEnforceIf(~b);\n\n  // Create our two half-reified constraints.\n  // First, b implies (y == 10 - x).\n  cp_model.AddEquality(x + y, 10).OnlyEnforceIf(b);\n  // Second, not(b) implies y == 0.\n  cp_model.AddEquality(y, 0).OnlyEnforceIf(~b);\n\n  // Search for x values in increasing order.\n  cp_model.AddDecisionStrategy({x}, DecisionStrategyProto::CHOOSE_FIRST,\n                               DecisionStrategyProto::SELECT_MIN_VALUE);\n\n  // Create a solver and solve with a fixed search.\n  Model model;\n  SatParameters parameters;\n  parameters.set_search_branching(SatParameters::FIXED_SEARCH);\n  parameters.set_enumerate_all_solutions(true);\n  model.Add(NewSatParameters(parameters));\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"x=\" << SolutionIntegerValue(r, x)\n              << \" y=\" << SolutionIntegerValue(r, y)\n              << \" b=\" << SolutionBooleanValue(r, b);\n  }));\n  SolveCpModel(cp_model.Build(), &model);\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::ChannelingSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Steel Mill Slab Problem Data\nDESCRIPTION: This function constructs the problem data for different scenarios identified by the problem_id. It defines constraints like orders and capacities, number of slabs, and colors for different test cases.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef build_problem(\n    problem_id: int,\n) -> tuple[int, list[int], int, list[tuple[int, int]]]:\n    \"\"\"Build problem data.\"\"\"\n    if problem_id == 0:\n        capacities = [\n            # fmt:off\n        0, 12, 14, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28, 29, 30, 32, 35, 39, 42, 43, 44,\n            # fmt:on\n        ]\n        num_colors = 88\n        num_slabs = 111\n        orders = [  # (size, color)\n            # fmt:off\n        (4, 1), (22, 2), (9, 3), (5, 4), (8, 5), (3, 6), (3, 4), (4, 7),\n        (7, 4), (7, 8), (3, 6), (2, 6), (2, 4), (8, 9), (5, 10), (7, 11),\n        (4, 7), (7, 11), (5, 10), (7, 11), (8, 9), (3, 1), (25, 12), (14, 13),\n        (3, 6), (22, 14), (19, 15), (19, 15), (22, 16), (22, 17), (22, 18),\n        (20, 19), (22, 20), (5, 21), (4, 22), (10, 23), (26, 24), (17, 25),\n        (20, 26), (16, 27), (10, 28), (19, 29), (10, 30), (10, 31), (23, 32),\n        (22, 33), (26, 34), (27, 35), (22, 36), (27, 37), (22, 38), (22, 39),\n        (13, 40), (14, 41), (16, 27), (26, 34), (26, 42), (27, 35), (22, 36),\n        (20, 43), (26, 24), (22, 44), (13, 45), (19, 46), (20, 47), (16, 48),\n        (15, 49), (17, 50), (10, 28), (20, 51), (5, 52), (26, 24), (19, 53),\n        (15, 54), (10, 55), (10, 56), (13, 57), (13, 58), (13, 59), (12, 60),\n        (12, 61), (18, 62), (10, 63), (18, 64), (16, 65), (20, 66), (12, 67),\n        (6, 68), (6, 68), (15, 69), (15, 70), (15, 70), (21, 71), (30, 72),\n        (30, 73), (30, 74), (30, 75), (23, 76), (15, 77), (15, 78), (27, 79),\n        (27, 80), (27, 81), (27, 82), (27, 83), (27, 84), (27, 79), (27, 85),\n        (27, 86), (10, 87), (3, 88),\n            # fmt:on\n        ]\n    elif problem_id == 1:\n        capacities = [0, 17, 44]\n        num_colors = 23\n        num_slabs = 30\n        orders = [  # (size, color)\n            # fmt:off\n        (4, 1), (22, 2), (9, 3), (5, 4), (8, 5), (3, 6), (3, 4), (4, 7), (7, 4),\n        (7, 8), (3, 6), (2, 6), (2, 4), (8, 9), (5, 10), (7, 11), (4, 7), (7, 11),\n        (5, 10), (7, 11), (8, 9), (3, 1), (25, 12), (14, 13), (3, 6), (22, 14),\n        (19, 15), (19, 15), (22, 16), (22, 17), (22, 18), (20, 19), (22, 20),\n        (5, 21), (4, 22), (10, 23),\n            # fmt:on\n        ]\n    elif problem_id == 2:\n        capacities = [0, 17, 44]\n        num_colors = 15\n        num_slabs = 20\n        orders = [  # (size, color)\n            # fmt:off\n        (4, 1), (22, 2), (9, 3), (5, 4), (8, 5), (3, 6), (3, 4), (4, 7), (7, 4),\n        (7, 8), (3, 6), (2, 6), (2, 4), (8, 9), (5, 10), (7, 11), (4, 7), (7, 11),\n        (5, 10), (7, 11), (8, 9), (3, 1), (25, 12), (14, 13), (3, 6), (22, 14),\n        (19, 15), (19, 15),\n            # fmt:on\n        ]\n\n    else:  # problem_id == 3, default problem.\n        capacities = [0, 17, 44]\n        num_colors = 8\n        num_slabs = 10\n        orders = [  # (size, color)\n            (4, 1),\n            (22, 2),\n            (9, 3),\n            (5, 4),\n            (8, 5),\n            (3, 6),\n            (3, 4),\n            (4, 7),\n            (7, 4),\n            (7, 8),\n            (3, 6),\n        ]\n\n    return (num_slabs, capacities, num_colors, orders)\n\n```\n\n----------------------------------------\n\nTITLE: Time Windows Constraints\nDESCRIPTION: List of time windows for 21 locations. Each line contains two integers representing the earliest and latest allowed visit times for each location.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/n20w20.001.txt#2025-04-17_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n0         408\n62        68\n181       205\n306       324\n214       217\n51        61\n102       129\n175       186\n250       263\n3         23\n21        49\n79        90\n78        96\n140       154\n354       386\n42        63\n2         13\n24        42\n20        33\n9         21\n275       300\n```\n\n----------------------------------------\n\nTITLE: Implementing Order Class for Customer Requests in Python\nDESCRIPTION: Defines an Order class representing a customer request for a specific recipe to be delivered by a certain time. Each order includes a unique identifier, recipe name, due date in minutes, and quantity to produce.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Order:\n    \"\"\"An order is a recipe that should be delivered at a given due date.\"\"\"\n\n    def __init__(self, unique_id, recipe_name, due_date, quantity):\n        \"\"\"Builds an order.\n\n        Args:\n          unique_id: A unique identifier for the order. Used to display the result.\n          recipe_name: The name of the recipe. It must match one of the recipes.\n          due_date: The due date in minutes since midnight.\n          quantity: How many cakes to prepare.\n        \"\"\"\n        self.unique_id = unique_id\n        self.recipe_name = recipe_name\n        self.due_date = due_date\n        self.quantity = quantity\n```\n\n----------------------------------------\n\nTITLE: Solution Hinting Implementation in Go\nDESCRIPTION: Shows how to implement solution hinting in OR-Tools using Go. Creates a constraint optimization model, sets variable domains, and applies solution hints to guide the solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n\tcmpb \"github.com/google/or-tools/ortools/sat/proto/cpmodel\"\n)\n\nfunc solutionHintingSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tdomain := cpmodel.NewDomain(0, 2)\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVarFromDomain(domain).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\n\tmodel.AddNotEqual(x, y)\n\n\tmodel.Maximize(cpmodel.NewLinearExpr().AddWeightedSum([]cpmodel.LinearArgument{x, y, z}, []int64{1, 2, 3}))\n\n\t// Solution hinting: x <- 1, y <- 2\n\thint := &cpmodel.Hint{Ints: map[cpmodel.IntVar]int64{x: 7}}\n\tmodel.SetHint(hint)\n\n\tm, err := model.Model()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to instantiate the CP model: %w\", err)\n\t}\n\tresponse, err := cpmodel.SolveCpModel(m)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to solve the model: %w\", err)\n\t}\n\n\tfmt.Printf(\"Status: %v\\n\", response.GetStatus())\n\n\tif response.GetStatus() == cmpb.CpSolverStatus_OPTIMAL {\n\t\tfmt.Printf(\" x = %v\\n\", cpmodel.SolutionIntegerValue(response, x))\n\t\tfmt.Printf(\" y = %v\\n\", cpmodel.SolutionIntegerValue(response, y))\n\t\tfmt.Printf(\" z = %v\\n\", cpmodel.SolutionIntegerValue(response, z))\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := solutionHintingSampleSat(); err != nil {\n\t\tlog.Exitf(\"solutionHintingSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Solution Output Processing for Clustering Results\nDESCRIPTION: Processes and displays the clustering solution by grouping nodes based on solver results. Iterates through nodes and their neighbors to form and display groups.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n    if status == cp_model.FEASIBLE or status == cp_model.OPTIMAL:\n        visited = set()\n        for g in range(num_groups):\n            for n in range(num_nodes):\n                if n not in visited:\n                    visited.add(n)\n                    output = str(n)\n                    for o in range(n + 1, num_nodes):\n                        if solver.boolean_value(neighbors[n, o]):\n                            visited.add(o)\n                            output += \" \" + str(o)\n                    print(\"Group\", g, \":\", output)\n                    break\n```\n\n----------------------------------------\n\nTITLE: Printing Intermediate Solutions in Python CP-SAT Solver\nDESCRIPTION: Python implementation showing how to display intermediate solutions during optimization in a CP-SAT solver. This example creates a custom callback class that inherits from CpSolverSolutionCallback to track and display all solutions found during the search process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Solves an optimization problem and displays all intermediate solutions.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\n# You need to subclass the cp_model.CpSolverSolutionCallback class.\nclass VarArrayAndObjectiveSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, variables: list[cp_model.IntVar]):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variables = variables\n        self.__solution_count = 0\n\n    def on_solution_callback(self) -> None:\n        print(f\"Solution {self.__solution_count}\")\n        print(f\"  objective value = {self.objective_value}\")\n        for v in self.__variables:\n            print(f\"  {v}={self.value(v)}\", end=\" \")\n        print()\n        self.__solution_count += 1\n\n    @property\n    def solution_count(self) -> int:\n        return self.__solution_count\n\n\ndef solve_and_print_intermediate_solutions_sample_sat():\n    \"\"\"Showcases printing intermediate solutions found during search.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    model.maximize(x + 2 * y + 3 * z)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    solution_printer = VarArrayAndObjectiveSolutionPrinter([x, y, z])\n    status = solver.solve(model, solution_printer)\n\n    print(f\"Status = {solver.status_name(status)}\")\n    print(f\"Number of solutions found: {solution_printer.solution_count}\")\n\n\nsolve_and_print_intermediate_solutions_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Python Package Locally with pip\nDESCRIPTION: Commands to build the OR-Tools wheel package and install it locally using pip. This creates a platform-specific wheel and installs it in the user's Python environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/python/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 setup.py bdist_wheel\npython3 -m pip install --user --find-links=dist ortools\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Defining Main Function for Diet Problem MIP in Python\nDESCRIPTION: This snippet imports the necessary OR-Tools module and defines the main function for solving the diet problem. It sets up the solver, declares variables, defines constraints, and solves the optimization problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/diet1_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol='CBC'):\n\n  # Create the solver.\n\n  print('Solver: ', sol)\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n\n  #\n  # data\n  #\n  n = 4\n  price = [50, 20, 30, 80]  # in cents\n  limits = [500, 6, 10, 8]  # requirements for each nutrition type\n\n  # nutritions for each product\n  calories = [400, 200, 150, 500]\n  chocolate = [3, 2, 0, 0]\n  sugar = [2, 2, 4, 4]\n  fat = [2, 4, 1, 5]\n\n  #\n  # declare variables\n  #\n  x = [solver.IntVar(0, 100, 'x%d' % i) for i in range(n)]\n  cost = solver.Sum([x[i] * price[i] for i in range(n)])\n\n  #\n  # constraints\n  #\n  solver.Add(solver.Sum([x[i] * calories[i] for i in range(n)]) >= limits[0])\n  solver.Add(solver.Sum([x[i] * chocolate[i] for i in range(n)]) >= limits[1])\n  solver.Add(solver.Sum([x[i] * sugar[i] for i in range(n)]) >= limits[2])\n  solver.Add(solver.Sum([x[i] * fat[i] for i in range(n)]) >= limits[3])\n\n  # objective\n  objective = solver.Minimize(cost)\n\n  #\n  # solution\n  #\n  solver.Solve()\n\n  print('Cost:', solver.Objective().Value())\n  print([int(x[i].SolutionValue()) for i in range(n)])\n\n  print()\n  print('WallTime:', solver.WallTime())\n  if sol == 'CBC':\n    print('iterations:', solver.Iterations())\n```\n\n----------------------------------------\n\nTITLE: Model Cloning in C++\nDESCRIPTION: Shows how to implement model cloning in OR-Tools using C++. Creates a base model with constraints and objective function, then creates a deep copy with additional constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid CloneModelSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  cp_model.AddNotEqual(x, y);\n\n  cp_model.Maximize(x + 2 * y + 3 * z);\n\n  const CpSolverResponse initial_response = Solve(cp_model.Build());\n  LOG(INFO) << \"Optimal value of the original model: \"\n            << initial_response.objective_value();\n\n  CpModelBuilder copy = cp_model.Clone();\n\n  // Add new constraint: copy_of_x + copy_of_y == 1.\n  IntVar copy_of_x = copy.GetIntVarFromProtoIndex(x.index());\n  IntVar copy_of_y = copy.GetIntVarFromProtoIndex(y.index());\n\n  copy.AddLessOrEqual(copy_of_x + copy_of_y, 1);\n\n  const CpSolverResponse modified_response = Solve(copy.Build());\n  LOG(INFO) << \"Optimal value of the modified model: \"\n            << modified_response.objective_value();\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::CloneModelSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function for VRP Solver\nDESCRIPTION: Implements the main function to set up and solve the VRP using OR-Tools. It creates the routing model, sets constraints, attaches the solution callback, and solves the problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_solution_callback.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    routing_manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n\n    # Create Routing Model.\n    routing_model = pywrapcp.RoutingModel(routing_manager)\n\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = routing_manager.IndexToNode(from_index)\n        to_node = routing_manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing_model.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing_model.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing_model.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing_model.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Attach a solution callback.\n    solution_callback = SolutionCallback(routing_manager, routing_model, 15)\n    routing_model.AddAtSolutionCallback(solution_callback)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    search_parameters.local_search_metaheuristic = (\n        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n    )\n    search_parameters.time_limit.FromSeconds(5)\n\n    # Solve the problem.\n    solution = routing_model.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print(f\"Best objective: {solution_callback.objectives[-1]}\")\n    else:\n        print(\"No solution found !\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Reified Constraints in C++\nDESCRIPTION: Demonstrates three equivalent ways to implement a reified constraint in C++ using the CP-SAT solver, including half-reified bool and, implications, and bool or constructs.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\n#include <stdlib.h>\n\n#include \"absl/types/span.h\"\n#include \"ortools/sat/cp_model.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid ReifiedSampleSat() {\n  CpModelBuilder cp_model;\n\n  const BoolVar x = cp_model.NewBoolVar();\n  const BoolVar y = cp_model.NewBoolVar();\n  const BoolVar b = cp_model.NewBoolVar();\n\n  // First version using a half-reified bool and.\n  cp_model.AddBoolAnd({x, ~y}).OnlyEnforceIf(b);\n\n  // Second version using implications.\n  cp_model.AddImplication(b, x);\n  cp_model.AddImplication(b, ~y);\n\n  // Third version using bool or.\n  cp_model.AddBoolOr({~b, x});\n  cp_model.AddBoolOr({~b, ~y});\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::ReifiedSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Nonogram Rules with Automaton\nDESCRIPTION: Applies the regular constraint to check each rule in the Nonogram puzzle by creating an automaton for the rule.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef check_rule(rules, y):\n  solver = y[0].solver()\n\n  r_len = sum([1 for i in range(len(rules)) if rules[i] > 0])\n  rules_tmp = []\n  for i in range(len(rules)):\n    if rules[i] > 0:\n      rules_tmp.append(rules[i])\n\n  transition_fn = make_transition_matrix(rules_tmp)\n  n_states = len(transition_fn)\n  input_max = 2\n\n  initial_state = 1\n  accepting_states = [n_states]\n\n  regular(y, n_states, input_max, transition_fn, initial_state,\n          accepting_states)\n```\n\n----------------------------------------\n\nTITLE: Main Execution Block for Hidato Solver\nDESCRIPTION: Sets up the puzzle dimensions and calls the main solver function with command-line arguments.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/hidato.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nr = 3\nc = r\nif len(sys.argv) > 1:\n  r = int(sys.argv[1])\n  c = r\nif len(sys.argv) > 2:\n  c = int(sys.argv[2])\nmain(r, c)\n```\n\n----------------------------------------\n\nTITLE: Shift Data Structure for Bus Driver Scheduling in Python\nDESCRIPTION: Sample data representing bus shifts. Each shift is represented as a list containing shift ID, start time in HH:MM format, end time in HH:MM format, start time in minutes, end time in minutes, and duration in minutes. This structured data is used as input for the bus driver scheduling optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n[1307, \"22:52\", \"23:29\", 1372, 1409, 37],\n[1308, \"22:53\", \"23:15\", 1373, 1395, 22],\n[1309, \"22:55\", \"23:55\", 1375, 1435, 60],\n[1310, \"22:57\", \"23:51\", 1377, 1431, 54],\n[1311, \"22:58\", \"23:38\", 1378, 1418, 40],\n[1312, \"23:02\", \"23:41\", 1382, 1421, 39],\n[1313, \"23:02\", \"23:12\", 1382, 1392, 10],\n[1314, \"23:04\", \"23:31\", 1384, 1411, 27],\n[1315, \"23:05\", \"00:24\", 1385, 1464, 79],\n[1316, \"23:07\", \"23:44\", 1387, 1424, 37],\n[1317, \"23:13\", \"23:53\", 1393, 1433, 40],\n[1318, \"23:13\", \"23:38\", 1393, 1418, 25],\n[1319, \"23:17\", \"00:03\", 1397, 1443, 46],\n[1320, \"23:17\", \"23:27\", 1397, 1407, 10],\n[1321, \"23:19\", \"23:46\", 1399, 1426, 27],\n[1322, \"23:22\", \"23:59\", 1402, 1439, 37],\n[1323, \"23:25\", \"00:25\", 1405, 1465, 60],\n[1324, \"23:27\", \"00:21\", 1407, 1461, 54],\n[1325, \"23:28\", \"00:08\", 1408, 1448, 40],\n[1326, \"23:32\", \"23:42\", 1412, 1422, 10],\n[1327, \"23:34\", \"00:01\", 1414, 1441, 27],\n[1328, \"23:35\", \"01:05\", 1415, 1505, 90],\n[1329, \"23:37\", \"00:09\", 1417, 1449, 32],\n[1330, \"23:43\", \"00:23\", 1423, 1463, 40],\n[1331, \"23:43\", \"00:08\", 1423, 1448, 25],\n[1332, \"23:46\", \"00:01\", 1426, 1441, 15],\n[1333, \"23:47\", \"23:57\", 1427, 1437, 10],\n[1334, \"23:47\", \"00:33\", 1427, 1473, 46],\n[1335, \"23:52\", \"00:24\", 1432, 1464, 32],\n[1336, \"23:55\", \"00:49\", 1435, 1489, 54],\n[1337, \"23:57\", \"00:57\", 1437, 1497, 60],\n[1338, \"23:58\", \"00:38\", 1438, 1478, 40],\n[1339, \"00:02\", \"00:12\", 1442, 1452, 10],\n[1340, \"00:07\", \"00:39\", 1447, 1479, 32],\n[1341, \"00:13\", \"00:38\", 1453, 1478, 25],\n[1342, \"00:13\", \"00:51\", 1453, 1491, 38],\n[1343, \"00:15\", \"01:14\", 1455, 1514, 59],\n[1344, \"00:17\", \"01:23\", 1457, 1523, 66],\n[1345, \"00:23\", \"00:33\", 1463, 1473, 10],\n[1346, \"00:24\", \"00:40\", 1464, 1480, 16],\n[1347, \"00:25\", \"01:12\", 1465, 1512, 47],\n[1348, \"00:28\", \"01:07\", 1468, 1507, 39],\n[1349, \"00:33\", \"01:05\", 1473, 1505, 32],\n[1350, \"00:43\", \"01:21\", 1483, 1521, 38],\n[1351, \"00:44\", \"00:54\", 1484, 1494, 10],\n[1352, \"00:47\", \"01:09\", 1487, 1509, 22],\n[1353, \"00:47\", \"01:26\", 1487, 1526, 39],\n[1354, \"00:54\", \"01:04\", 1494, 1504, 10],\n[1355, \"00:57\", \"01:07\", 1497, 1507, 10],\n]  # yapf:disable\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools SAT Module Source Files in CMake\nDESCRIPTION: Collects and filters source files for the SAT module, excluding test and fuzz files, and specifically removes certain files from the build.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\" \"python/linear_expr.*\" \"c_api/*.h\" \"c_api/*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.+_test\\.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.+_fuzz\\.cc\")\nlist(REMOVE_ITEM _SRCS\n  ${CMAKE_CURRENT_SOURCE_DIR}/opb_reader.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/sat_cnf_reader.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/sat_runner.cc\n)\nset(NAME ${PROJECT_NAME}_sat)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python Environment\nDESCRIPTION: Installs the OR-Tools package in the Python environment. OR-Tools is a powerful suite of optimization tools from Google. The package is required for solving optimization problems such as the bin packing problem in this example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/bin_packing_mb.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Scheduling Problem Entry Point with OR-Tools\nDESCRIPTION: Main entry point for the scheduling optimization script that uses Google OR-Tools. It invokes the main function through ABSL's app runner.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nif __name__ == \"__main__\":\n    app.run(main)\n```\n\n----------------------------------------\n\nTITLE: Resource and Task Scheduling Configuration in Google OR-Tools\nDESCRIPTION: Defines a scheduling problem with 2 resources and 14 tasks. Includes resource capacities, task durations, resource demands, precedence constraints, and lateness costs. The configuration specifies task dependencies using STARTS_AFTER_END relationships.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/testdata/fdh_scheduling_problem.pb.txt#2025-04-17_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nresources {\n  max_capacity: 1\n  release_after_usage: true\n}\nresources {\n  max_capacity: 1\n  release_after_usage: true\n}\ntasks {\n  duration: 5\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n}\ntasks {\n  duration: 2\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n}\ntasks {\n  duration: 1\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n}\ntasks {\n  duration: 2\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n}\ntasks {\n  duration: 0\n  late_due_date: 0\n  lateness_cost_per_time_unit: 7\n}\ntasks {\n  duration: 3\n  recipes {\n    demands {\n      resource_id: 1\n      demand: 1\n    }\n  }\n  late_due_date: 0\n  lateness_cost_per_time_unit: 0\n}\ntasks {\n  duration: 2\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n}\ntasks {\n  duration: 0\n  late_due_date: 0\n  lateness_cost_per_time_unit: 8\n}\ntasks {\n  duration: 3\n  recipes {\n    demands {\n      resource_id: 1\n      demand: 1\n    }\n  }\n  late_due_date: 0\n  lateness_cost_per_time_unit: 0\n}\ntasks {\n  duration: 0\n  late_due_date: 0\n  lateness_cost_per_time_unit: 6\n}\ntasks {\n  duration: 3\n  recipes {\n    demands {\n      resource_id: 1\n      demand: 1\n    }\n  }\n  late_due_date: 0\n  lateness_cost_per_time_unit: 0\n}\ntasks {\n  duration: 2\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n}\ntasks {\n  duration: 0\n  late_due_date: 0\n  lateness_cost_per_time_unit: 3\n}\ntasks {\n  duration: 30\n  recipes {\n    demands {\n      resource_id: 0\n      demand: 1\n    }\n  }\n  late_due_date: 0\n  lateness_cost_per_time_unit: 0\n}\nprecedences {\n  first_task_id: 0\n  second_task_id: 1\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 1\n  second_task_id: 2\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 2\n  second_task_id: 3\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 5\n  second_task_id: 0\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 4\n  second_task_id: 5\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 6\n  second_task_id: 2\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 8\n  second_task_id: 6\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 7\n  second_task_id: 8\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 10\n  second_task_id: 1\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 9\n  second_task_id: 10\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 11\n  second_task_id: 3\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 13\n  second_task_id: 11\n  type: STARTS_AFTER_END\n}\nprecedences {\n  first_task_id: 12\n  second_task_id: 13\n  type: STARTS_AFTER_END\n}\n```\n\n----------------------------------------\n\nTITLE: Building Python Wheel Package for OR-Tools using CMake\nDESCRIPTION: These commands build the Python wheel package for OR-Tools. It uses CMake to configure the build with Python support enabled, then builds the python_package target.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/python.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncmake -S. -Bbuild -DBUILD_PYTHON=ON\ncmake --build build --target python_package -v\n```\n\n----------------------------------------\n\nTITLE: Printing Solution for Discrete Tomography Problem\nDESCRIPTION: Defines a function to print the solution of the discrete tomography problem, showing the reconstructed binary matrix along with row and column sums.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/discrete_tomography.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(x, rows, cols, row_sums, col_sums):\n  print(\"  \", end=\" \")\n  for j in range(cols):\n    print(col_sums[j], end=\" \")\n  print()\n  for i in range(rows):\n    print(row_sums[i], end=\" \")\n    for j in range(cols):\n      if x[i][j].Value() == 1:\n        print(\"#\", end=\" \")\n      else:\n        print(\".\", end=\" \")\n    print(\"\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Magic Sequence Problem with Distribute Constraint\nDESCRIPTION: Complete implementation of the magic sequence problem using OR-Tools' constraint solver. It creates a sequence where the number of occurrences of i equals the value of the ith element, using the distribute() constraint for efficient modeling.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/magic_sequence_distribute.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.colab import flags\nfrom ortools.constraint_solver import pywrapcp\n\nFLAGS = flags.FLAGS\n\n\ndef main(argv):\n    # Create the solver.\n    solver = pywrapcp.Solver(\"magic sequence\")\n\n    # Create an array of IntVars to hold the answers.\n    size = int(argv[1]) if len(argv) > 1 else 100\n    all_values = list(range(0, size))\n    all_vars = [solver.IntVar(0, size, \"vars_%d\" % i) for i in all_values]\n\n    # The number of variables equal to j shall be the value of all_vars[j].\n    solver.Add(solver.Distribute(all_vars, all_values, all_vars))\n\n    # The sum of all the values shall be equal to the size.\n    # (This constraint is redundant, but speeds up the search.)\n    solver.Add(solver.Sum(all_vars) == size)\n\n    solver.NewSearch(\n        solver.Phase(all_vars, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n    )\n    solver.NextSolution()\n    print(all_vars)\n    solver.EndSearch()\n\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Model Cloning in Python\nDESCRIPTION: Demonstrates how to create a deep copy of an OR-Tools model in Python. Shows creating an initial model with constraints and objective, then cloning it to create a modified version with additional constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Showcases deep copying of a model.\"\"\"\n\nfrom ortools.sat.python import cp_model\n\n\ndef clone_model_sample_sat():\n    \"\"\"Showcases cloning a model.\"\"\"\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates the variables.\n    num_vals = 3\n    x = model.new_int_var(0, num_vals - 1, \"x\")\n    y = model.new_int_var(0, num_vals - 1, \"y\")\n    z = model.new_int_var(0, num_vals - 1, \"z\")\n\n    # Creates the constraints.\n    model.add(x != y)\n\n    model.maximize(x + 2 * y + 3 * z)\n\n    # Creates a solver and solves.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(\"Optimal value of the original model: {}\".format(solver.objective_value))\n\n    # Clones the model.\n    copy = model.clone()\n\n    copy_x = copy.get_int_var_from_proto_index(x.index)\n    copy_y = copy.get_int_var_from_proto_index(y.index)\n\n    copy.add(copy_x + copy_y <= 1)\n\n    status = solver.solve(copy)\n\n    if status == cp_model.OPTIMAL:\n        print(\"Optimal value of the modified model: {}\".format(solver.objective_value))\n\n\nclone_model_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools .NET Test Builds\nDESCRIPTION: Sets up test configuration for .NET components, gathering all test files matching the pattern *Tests.cs and adding them to the build system when testing is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/csharp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB DOTNET_SRCS \"*Tests.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Executing SlitherLink Solver on Test Cases\nDESCRIPTION: Code that runs the SlitherLink solver on predefined test puzzles of varying sizes (small, medium, and big).\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nSlitherLink(small)\nSlitherLink(medium)\nSlitherLink(big)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code snippet shows how to install the OR-Tools package using pip in a Jupyter notebook environment. This is a prerequisite for running the SAT program.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/simple_sat_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Object Library for OR-Tools Scheduling\nDESCRIPTION: Creates an object library for the scheduling module with position-independent code and necessary dependencies. The library includes all .h and .cc files in the directory and links against Abseil strings, Protocol Buffers, and OR-Tools proto libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_scheduling)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::scheduling ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Creating Interval Variables in C++ with CP-SAT Solver\nDESCRIPTION: This C++ code demonstrates how to create different types of interval variables using the CP-SAT solver. It showcases creating an interval from three expressions, creating a fixed-size interval from a start expression and size, and creating a completely fixed interval with specific start and size values.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid IntervalSampleSat() {\n  CpModelBuilder cp_model;\n  const int kHorizon = 100;\n  const Domain horizon(0, kHorizon);\n\n  // An interval can be created from three affine expressions.\n  const IntVar x = cp_model.NewIntVar(horizon).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar({2, 4}).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(horizon).WithName(\"z\");\n\n  const IntervalVar interval_var =\n      cp_model.NewIntervalVar(x, y, z + 2).WithName(\"interval\");\n  LOG(INFO) << \"start = \" << interval_var.StartExpr()\n            << \", size = \" << interval_var.SizeExpr()\n            << \", end = \" << interval_var.EndExpr()\n            << \", interval_var = \" << interval_var;\n\n  // If the size is fixed, a simpler version uses the start expression and the\n  // size.\n  const IntervalVar fixed_size_interval_var =\n      cp_model.NewFixedSizeIntervalVar(x, 10).WithName(\n          \"fixed_size_interval_var\");\n  LOG(INFO) << \"start = \" << fixed_size_interval_var.StartExpr()\n            << \", size = \" << fixed_size_interval_var.SizeExpr()\n            << \", end = \" << fixed_size_interval_var.EndExpr()\n            << \", fixed_size_interval_var = \" << fixed_size_interval_var;\n\n  // A fixed interval can be created using the same API.\n  const IntervalVar fixed_interval =\n      cp_model.NewFixedSizeIntervalVar(5, 10).WithName(\"fixed_interval\");\n  LOG(INFO) << \"start = \" << fixed_interval.StartExpr()\n            << \", size = \" << fixed_interval.SizeExpr()\n            << \", end = \" << fixed_interval.EndExpr()\n            << \", fixed_interval = \" << fixed_interval;\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::IntervalSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function for Two-Pass Bus Driver Scheduling Optimization\nDESCRIPTION: Coordinates the two-pass optimization process: first minimizing the number of drivers, then using that number to minimize the total working times in the second pass.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef main(_):\n    \"\"\"Optimize the bus driver allocation in two passes.\"\"\"\n    print(\"----------- first pass: minimize the number of drivers\")\n    num_drivers = bus_driver_scheduling(True, -1)\n    if num_drivers == -1:\n        print(\"no solution found, skipping the final step\")\n    else:\n        print(\"----------- second pass: minimize the sum of working times\")\n        bus_driver_scheduling(False, num_drivers)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Route Statistics Output in Python\nDESCRIPTION: Code snippet that calculates and prints the total distance and load statistics for all routes in the solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_items_to_deliver.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntotal_distance += route_distance\ntotal_load_x += route_load_x\ntotal_load_y += route_load_y\nprint(f\"Total Distance of all routes: {total_distance}m\")\nprint(f\"Total load of all routes: X:{total_load_x}, Y:{total_load_y}\")\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools for VRP in Python\nDESCRIPTION: Code that imports required modules from Google's OR-Tools library for implementing a prize collecting Vehicle Routing Problem. It specifically imports routing enums and the Python wrapper for the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Main Execution for Discrete Tomography Solver\nDESCRIPTION: Handles the main execution flow, allowing the solver to run with either default values or a problem instance from a file specified as a command-line argument.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/discrete_tomography.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  print(\"Problem instance from\", file)\n  [row_sums, col_sums] = read_problem(file)\n  main(row_sums, col_sums)\nelse:\n  main()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: A command to install the OR-Tools optimization package in a Colab environment using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/single_machine_scheduling_with_setup_release_due_dates_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Main Function to Run the Program\nDESCRIPTION: The main function acts as the entry point of the script, validating command-line arguments and invoking the vendor_scheduling_sat function to execute the scheduling model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/vendor_scheduling_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    vendor_scheduling_sat()\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for Bin Packing Problem\nDESCRIPTION: Define the input data for the bin packing problem, including item weights, total items, bins, and bin capacity\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/bin_packing_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Create the data for the example.\"\"\"\n    data = {}\n    weights = [48, 30, 19, 36, 36, 27, 42, 42, 36, 24, 30]\n    data[\"weights\"] = weights\n    data[\"items\"] = list(range(len(weights)))\n    data[\"bins\"] = data[\"items\"]\n    data[\"bin_capacity\"] = 100\n    return data\n```\n\n----------------------------------------\n\nTITLE: Solving Number to Array Conversion Problem with Google CP Solver\nDESCRIPTION: Implements a complete example that uses the toNum function to find all possible arrays of 4 different digits and their corresponding decimal values. The solution demonstrates constraint setup, solving, and solution collection in OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/toNum.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main(unused_argv):\n  # Create the solver.\n  solver = pywrapcp.Solver(\"toNum test\")\n\n  # data\n  n = 4\n  base = 10\n\n  # declare variables\n  x = [solver.IntVar(0, n - 1, \"x%i\" % i) for i in range(n)]\n  y = solver.IntVar(0, 10**n - 1, \"y\")\n\n  #\n  # constraints\n  #\n  # solver.Add(solver.AllDifferent([x[i] for i in range(n)]))\n  solver.Add(solver.AllDifferent(x))\n  # solver.Add(x[0] > 0) # just for fun\n\n  toNum(solver, x, y, base)\n\n  #\n  # solution and search\n  #\n  solution = solver.Assignment()\n  solution.Add([x[i] for i in range(n)])\n  solution.Add(y)\n\n  collector = solver.AllSolutionCollector(solution)\n  solver.Solve(\n      solver.Phase([x[i] for i in range(n)], solver.CHOOSE_FIRST_UNBOUND,\n                   solver.ASSIGN_MIN_VALUE), [collector])\n\n  num_solutions = collector.SolutionCount()\n  for s in range(num_solutions):\n    print(\"x:\", [collector.Value(s, x[i]) for i in range(n)])\n    print(\"y:\", collector.Value(s, y))\n    print()\n\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain(\"cp sample\")\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Variables and Literals in Python\nDESCRIPTION: Demonstrates how to create a boolean variable and its negation (literal) in Python using the CP-SAT solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n#!/usr/bin/env python3\n\"\"\"Code sample to demonstrate Boolean variable and literals.\"\"\"\n\n\nfrom ortools.sat.python import cp_model\n\n\ndef literal_sample_sat():\n    model = cp_model.CpModel()\n    x = model.new_bool_var(\"x\")\n    not_x = ~x\n    print(x)\n    print(not_x)\n\n\nliteral_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating Transition Tuples for Automaton in Nonogram Solver\nDESCRIPTION: This function generates transition tuples for an automaton based on a given pattern, which is used in the Nonogram solver to enforce puzzle rules.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table2.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef make_transition_tuples(pattern):\n  p_len = len(pattern)\n  num_states = p_len + sum(pattern)\n\n  tuples = []\n\n  # this is for handling 0-clues. It generates\n  # just the minimal state\n  if num_states == 0:\n    tuples.append((1, 0, 1))\n    return (tuples, 1)\n\n  # convert pattern to a 0/1 pattern for easy handling of\n  # the states\n  tmp = [0]\n  c = 0\n  for pattern_index in range(p_len):\n    tmp.extend([1] * pattern[pattern_index])\n    tmp.append(0)\n\n  for i in range(num_states):\n    state = i + 1\n    if tmp[i] == 0:\n      tuples.append((state, 0, state))\n      tuples.append((state, 1, state + 1))\n    else:\n      if i < num_states - 1:\n        if tmp[i + 1] == 1:\n          tuples.append((state, 1, state + 1))\n        else:\n          tuples.append((state, 0, state + 1))\n  tuples.append((num_states, 0, num_states))\n  return (tuples, num_states)\n```\n\n----------------------------------------\n\nTITLE: Configuring Xpress Library Build for OR-Tools in CMake\nDESCRIPTION: This CMake script sets up the Xpress solver integration for OR-Tools. It collects source files, configures build properties like C++17 standard support, position independent code, and proper DLL handling for Windows. It also defines the necessary include directories and links required dependencies including Abseil libraries and Protocol Buffers.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/xpress/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_xpress)\n\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  CXX_STANDARD 17\n  CXX_STANDARD_REQUIRED ON\n  CXX_EXTENSIONS OFF\n  POSITION_INDEPENDENT_CODE ON\n  )\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::hash\n  absl::meta\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n```\n\n----------------------------------------\n\nTITLE: Initializing Distance Matrix for TSP Problem\nDESCRIPTION: Definition of a distance matrix that represents the distances between different locations in the TSP problem. This matrix is used as input for the constraint programming model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDISTANCE_MATRIX = [\n    # fmt:off\n    [0, 10938, 4542, 2835, 29441, 2171, 1611, 9208, 9528, 11111, 16120, 22606, 22127, 20627, 21246, 23387, 16697, 33609, 26184, 24772, 22644, 20655, 30492, 23296, 32979, 18141, 19248, 17129, 17192, 15645, 12658, 11210, 12094, 13175, 18162, 4968, 12308, 10084, 13026, 15056],\n    [10938, 0, 6422, 9742, 18988, 12974, 11216, 19715, 19004, 18271, 25070, 31971, 31632, 30571, 31578, 33841, 27315, 43964, 36944, 35689, 33569, 31481, 41360, 33760, 43631, 28730, 29976, 27803, 28076, 26408, 23504, 22025, 22000, 13197, 14936, 15146, 23246, 20956, 23963, 25994],\n    [4542, 6422, 0, 3644, 25173, 6552, 5092, 13584, 13372, 13766, 19805, 26537, 26117, 24804, 25590, 27784, 21148, 37981, 30693, 29315, 27148, 25071, 34943, 27472, 37281, 22389, 23592, 21433, 21655, 20011, 17087, 15612, 15872, 11653, 15666, 8842, 16843, 14618, 17563, 19589],\n    [2835, 9742, 3644, 0, 28681, 3851, 4341, 11660, 12294, 13912, 18893, 25283, 24777, 23173, 23636, 25696, 18950, 35927, 28233, 26543, 24127, 21864, 31765, 24018, 33904, 19005, 20295, 18105, 18551, 16763, 13958, 12459, 12296, 10370, 15331, 5430, 14044, 12135, 14771, 16743],\n    [29441, 18988, 25173, 28681, 0, 31590, 29265, 37173, 35501, 32929, 40239, 47006, 46892, 46542, 48112, 50506, 44539, 60103, 54208, 53557, 51878, 50074, 59849, 52645, 62415, 47544, 48689, 46560, 46567, 45086, 42083, 40648, 40971, 29929, 28493, 34015, 41473, 38935, 42160, 44198],\n    [2171, 12974, 6552, 3851, 31590, 0, 3046, 7856, 8864, 11330, 15411, 21597, 21065, 19382, 19791, 21845, 15099, 32076, 24425, 22848, 20600, 18537, 28396, 21125, 30825, 15975, 17101, 14971, 15104, 13503, 10544, 9080, 9983, 13435, 18755, 2947, 10344, 8306, 11069, 13078],\n    [1611, 11216, 5092, 4341, 29265, 3046, 0, 8526, 8368, 9573, 14904, 21529, 21085, 19719, 20504, 22713, 16118, 32898, 25728, 24541, 22631, 20839, 30584, 23755, 33278, 18557, 19545, 17490, 17309, 15936, 12881, 11498, 12944, 14711, 19589, 5993, 12227, 9793, 12925, 14967],\n    [9208, 19715, 13584, 11660, 37173, 7856, 8526, 0, 3248, 7855, 8245, 13843, 13272, 11526, 12038, 14201, 7599, 24411, 17259, 16387, 15050, 13999, 23134, 17899, 26460, 12894, 13251, 11680, 10455, 9997, 7194, 6574, 10678, 20959, 26458, 8180, 5255, 2615, 5730, 7552],\n    [9528, 19004, 13372, 12294, 35501, 8864, 8368, 3248, 0, 4626, 6598, 13168, 12746, 11567, 12731, 15083, 9120, 25037, 18718, 18433, 17590, 16888, 25630, 20976, 29208, 16055, 16300, 14838, 13422, 13165, 10430, 9813, 13777, 22300, 27564, 10126, 8388, 5850, 8778, 10422],\n    [11111, 18271, 13766, 13912, 32929, 11330, 9573, 7855, 4626, 0, 7318, 14185, 14005, 13655, 15438, 17849, 12839, 27179, 21947, 22230, 21814, 21366, 29754, 25555, 33535, 20674, 20872, 19457, 17961, 17787, 15048, 14372, 18115, 24280, 29101, 13400, 13008, 10467, 13375, 14935],\n    [16120, 25070, 19805, 18893, 40239, 15411, 14904, 8245, 6598, 7318, 0, 6939, 6702, 6498, 8610, 10961, 7744, 19889, 15350, 16403, 16975, 17517, 24357, 22176, 28627, 18093, 17672, 16955, 14735, 15510, 13694, 13768, 18317, 28831, 34148, 16326, 11276, 9918, 11235, 11891],\n    [22606, 31971, 26537, 25283, 47006, 21597, 21529, 13843, 13168, 14185, 6939, 0, 793, 3401, 5562, 6839, 8923, 13433, 11264, 13775, 15853, 17629, 21684, 22315, 26411, 19539, 18517, 18636, 16024, 17632, 16948, 17587, 22131, 34799, 40296, 21953, 14739, 14568, 14366, 14002],\n    [22127, 31632, 26117, 24777, 46892, 21065, 21085, 13272, 12746, 14005, 6702, 793, 0, 2608, 4809, 6215, 8151, 13376, 10702, 13094, 15099, 16845, 21039, 21535, 25744, 18746, 17725, 17845, 15232, 16848, 16197, 16859, 21391, 34211, 39731, 21345, 14006, 13907, 13621, 13225],\n    [20627, 30571, 24804, 23173, 46542, 19382, 19719, 11526, 11567, 13655, 6498, 3401, 2608, 0, 2556, 4611, 5630, 13586, 9157, 11005, 12681, 14285, 19044, 18996, 23644, 16138, 15126, 15240, 12625, 14264, 13736, 14482, 18958, 32292, 37879, 19391, 11621, 11803, 11188, 10671],\n    [21246, 31578, 25590, 23636, 48112, 19791, 20504, 12038, 12731, 15438, 8610, 5562, 4809, 2556, 0, 2411, 4917, 12395, 6757, 8451, 10292, 12158, 16488, 16799, 21097, 14374, 13194, 13590, 10943, 12824, 12815, 13779, 18042, 32259, 37918, 19416, 10975, 11750, 10424, 9475],\n    [23387, 33841, 27784, 25696, 50506, 21845, 22713, 14201, 15083, 17849, 10961, 6839, 6215, 4611, 2411, 0, 6760, 10232, 4567, 7010, 9607, 12003, 14846, 16408, 19592, 14727, 13336, 14109, 11507, 13611, 14104, 15222, 19237, 34013, 39703, 21271, 12528, 13657, 11907, 10633],\n    [16697, 27315, 21148, 18950, 44539, 15099, 16118, 7599, 9120, 12839, 7744, 8923, 8151, 5630, 4917, 6760, 0, 16982, 9699, 9400, 9302, 9823, 16998, 14534, 21042, 10911, 10190, 9900, 7397, 8758, 8119, 8948, 13353, 27354, 33023, 14542, 6106, 6901, 5609, 5084],\n    [33609, 43964, 37981, 35927, 60103, 32076, 32898, 24411, 25037, 27179, 19889, 13433, 13376, 13586, 12395, 10232, 16982, 0, 8843, 12398, 16193, 19383, 16423, 22583, 20997, 22888, 21194, 22640, 20334, 22636, 23801, 25065, 28675, 44048, 49756, 31426, 22528, 23862, 21861, 20315],\n    [26184, 36944, 30693, 28233, 54208, 24425, 25728, 17259, 18718, 21947, 15350, 11264, 10702, 9157, 6757, 4567, 9699, 8843, 0, 3842, 7518, 10616, 10666, 14237, 15515, 14053, 12378, 13798, 11537, 13852, 15276, 16632, 19957, 35660, 41373, 23361, 14333, 16125, 13624, 11866],\n    [24772, 35689, 29315, 26543, 53557, 22848, 24541, 16387, 18433, 22230, 16403, 13775, 13094, 11005, 8451, 7010, 9400, 12398, 3842, 0, 3795, 7014, 8053, 10398, 12657, 10633, 8889, 10569, 8646, 10938, 12906, 14366, 17106, 33171, 38858, 21390, 12507, 14748, 11781, 9802],\n    [22644, 33569, 27148, 24127, 51878, 20600, 22631, 15050, 17590, 21814, 16975, 15853, 15099, 12681, 10292, 9607, 9302, 16193, 7518, 3795, 0, 3250, 8084, 6873, 11763, 6949, 5177, 7050, 5619, 7730, 10187, 11689, 13792, 30012, 35654, 18799, 10406, 12981, 9718, 7682],\n    [20655, 31481, 25071, 21864, 50074, 18537, 20839, 13999, 16888, 21366, 17517, 17629, 16845, 14285, 12158, 12003, 9823, 19383, 10616, 7014, 3250, 0, 9901, 4746, 12531, 3737, 1961, 4036, 3588, 5109, 7996, 9459, 10846, 27094, 32690, 16451, 8887, 11624, 8304, 6471],\n    [30492, 41360, 34943, 31765, 59849, 28396, 30584, 23134, 25630, 29754, 24357, 21684, 21039, 19044, 16488, 14846, 16998, 16423, 10666, 8053, 8084, 9901, 0, 9363, 4870, 13117, 11575, 13793, 13300, 15009, 17856, 19337, 20454, 36551, 42017, 26352, 18403, 21033, 17737, 15720],\n    [23296, 33760, 27472, 24018, 52645, 21125, 23755, 17899, 20976, 25555, 22176, 22315, 21535, 18996, 16799, 16408, 14534, 22583, 14237, 10398, 6873, 4746, 9363, 0, 10020, 5211, 4685, 6348, 7636, 8010, 11074, 12315, 11926, 27537, 32880, 18634, 12644, 15358, 12200, 10674],\n    [32979, 43631, 37281, 33904, 62415, 30825, 33278, 26460, 29208, 33535, 28627, 26411, 25744, 23644, 21097, 19592, 21042, 20997, 15515, 12657, 11763, 12531, 4870, 10020, 0, 14901, 13738, 15855, 16118, 17348, 20397, 21793, 21936, 37429, 42654, 28485, 21414, 24144, 20816, 18908],\n    [18141, 28730, 22389, 19005, 47544, 15975, 18557, 12894, 16055, 20674, 18093, 19539, 18746, 16138, 14374, 14727, 10911, 22888, 14053, 10633, 6949, 3737, 13117, 5211, 14901, 0, 1777, 1217, 3528, 2896, 5892, 7104, 7338, 23517, 29068, 13583, 7667, 10304, 7330, 6204],\n    [19248, 29976, 23592, 20295, 48689, 17101, 19545, 13251, 16300, 20872, 17672, 18517, 17725, 15126, 13194, 13336, 10190, 21194, 12378, 8889, 5177, 1961, 11575, 4685, 13738, 1777, 0, 2217, 2976, 3610, 6675, 8055, 8965, 25197, 30774, 14865, 8007, 10742, 7532, 6000],\n    [17129, 27803, 21433, 18105, 46560, 14971, 17490, 11680, 14838, 19457, 16955, 18636, 17845, 15240, 13590, 14109, 9900, 22640, 13798, 10569, 7050, 4036, 13793, 6348, 15855, 1217, 2217, 0, 2647, 1686, 4726, 6000, 6810, 23060, 28665, 12674, 6450, 9094, 6117, 5066],\n    [17192, 28076, 21655, 18551, 46567, 15104, 17309, 10455, 13422, 17961, 14735, 16024, 15232, 12625, 10943, 11507, 7397, 20334, 11537, 8646, 5619, 3588, 13300, 7636, 16118, 3528, 2976, 2647, 0, 2320, 4593, 6093, 8479, 24542, 30219, 13194, 5301, 8042, 4735, 3039],\n    [15645, 26408, 20011, 16763, 45086, 13503, 15936, 9997, 13165, 17787, 15510, 17632, 16848, 14264, 12824, 13611, 8758, 22636, 13852, 10938, 7730, 5109, 15009, 8010, 17348, 2896, 3610, 1686, 2320, 0, 3086, 4444, 6169, 22301, 27963, 11344, 4780, 7408, 4488, 3721],\n    [12658, 23504, 17087, 13958, 42083, 10544, 12881, 7194, 10430, 15048, 13694, 16948, 16197, 13736, 12815, 14104, 8119, 23801, 15276, 12906, 10187, 7996, 17856, 11074, 20397, 5892, 6675, 4726, 4593, 3086, 0, 1501, 5239, 20390, 26101, 8611, 2418, 4580, 2599, 3496],\n    [11210, 22025, 15612, 12459, 40648, 9080, 11498, 6574, 9813, 14372, 13768, 17587, 16859, 14482, 13779, 15222, 8948, 25065, 16632, 14366, 11689, 9459, 19337, 12315, 21793, 7104, 8055, 6000, 6093, 4444, 1501, 0, 4608, 19032, 24747, 7110, 2860, 4072, 3355, 4772],\n    [12094, 22000, 15872, 12296, 40971, 9983, 12944, 10678, 13777, 18115, 18317, 22131, 21391, 18958, 18042, 19237, 13353, 28675, 19957, 17106, 13792, 10846, 20454, 11926, 21936, 7338, 8965, 6810, 8479, 6169, 5239, 4608, 0, 16249, 21866, 7146, 7403, 8446, 7773, 8614]\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Core Library Build in CMake\nDESCRIPTION: Sets up the build configuration for the math optimization core library. Includes source files, configures platform-specific settings for MSVC, sets up include directories, and links required dependencies like Abseil strings and math optimization protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/core/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(c_api)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\n#list(APPEND _SRCS \"${CMAKE_CURRENT_SOURCE_DIR}/c_api/solver.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/[^/]*_test\\.cc$\")\n\nset(NAME ${PROJECT_NAME}_math_opt_core)\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package with pip\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Python environment, which is required for solving optimization problems\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Library Build for OR-Tools Math Optimization Constraints\nDESCRIPTION: Sets up a CMake library build configuration for math optimization constraints with SOS functionality. Configures library sources, include directories, and dependencies. Includes test configuration when BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/sos/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_constraints_sos)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*_test.cc\")\n\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        math_opt_constraints_sos_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        #benchmark::benchmark\n        GTest::gmock\n        GTest::gtest_main\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Initializing Solver for Max Flow Problem\nDESCRIPTION: This snippet imports the necessary module from Google OR-Tools and initializes the CP solver for the max flow problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/max_flow_winston1.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver('Max flow problem, Winston')\n```\n\n----------------------------------------\n\nTITLE: Compiling OR-Tools Examples on Unix with CMake\nDESCRIPTION: Shows how to manually compile OR-Tools examples on Unix systems using CMake. This approach navigates to the example directory, configures the build with the correct prefix path, and builds the project.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.cpp.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd examples/basic_example\ncmake -S . -B build -DCMAKE_PREFIX_PATH=../..\ncmake --build build -v \n```\n\n----------------------------------------\n\nTITLE: Defining Problem Data for Worker-Task Assignment\nDESCRIPTION: This section defines the problem data, including the number of workers and tasks, worker qualifications for each task, and the cost of hiring each worker.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/covering_opl.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n  nb_workers = 32\n  Workers = list(range(nb_workers))\n  num_tasks = 15\n  Tasks = list(range(num_tasks))\n\n  # Which worker is qualified for each task.\n  # Note: This is 1-based and will be made 0-base below.\n  Qualified = [[1, 9, 19, 22, 25, 28, 31],\n               [2, 12, 15, 19, 21, 23, 27, 29, 30, 31, 32],\n               [3, 10, 19, 24, 26, 30, 32], [4, 21, 25, 28, 32],\n               [5, 11, 16, 22, 23, 27, 31], [6, 20, 24, 26, 30, 32],\n               [7, 12, 17, 25, 30, 31], [8, 17, 20, 22, 23],\n               [9, 13, 14, 26, 29, 30, 31], [10, 21, 25, 31, 32],\n               [14, 15, 18, 23, 24, 27, 30, 32], [18, 19, 22, 24, 26, 29, 31],\n               [11, 20, 25, 28, 30, 32], [16, 19, 23, 31],\n               [9, 18, 26, 28, 31, 32]]\n\n  Cost = [\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n      5, 6, 6, 6, 7, 8, 9\n  ]\n```\n\n----------------------------------------\n\nTITLE: Cutting Stock Problem Setup and Imports\nDESCRIPTION: Imports required libraries and defines problem parameters including desired lengths and possible capacities for the cutting stock optimization\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nimport time\n\nfrom ortools.sat.colab import flags\nimport numpy as np\n\nfrom google.protobuf import text_format\nfrom ortools.linear_solver.python import model_builder as mb\nfrom ortools.sat.python import cp_model\n\n\n_OUTPUT_PROTO = flags.define_string(\n    \"output_proto\", \"\", \"Output file to write the cp_model proto to.\"\n)\n_PARAMS = flags.define_string(\n    \"params\",\n    \"num_search_workers:8,log_search_progress:true,max_time_in_seconds:10\",\n    \"Sat solver parameters.\",\n)\n_SOLVER = flags.define_string(\"solver\", \"sat\", \"Method used to solve: sat, mip.\")\n\n\nDESIRED_LENGTHS = [\n    2490, 3980, 2490, 3980, 2391, 2391, 2391, 596, 596, 596, 2456, 2456,\n    3018, 938, 3018, 938, 943, 3018, 943, 3018, 2490, 3980, 2490, 3980,\n    2391, 2391, 2391, 596, 596, 596, 2456, 2456, 3018, 938, 3018, 938,\n    943, 3018, 943, 3018, 2890, 3980, 2890, 3980, 2391, 2391, 2391, 596,\n    596, 596, 2856, 2856, 3018, 938, 3018, 938, 943, 3018, 943, 3018,\n    3290, 3980, 3290, 3980, 2391, 2391, 2391, 596, 596, 596, 3256, 3256,\n    3018, 938, 3018, 938, 943, 3018, 943, 3018, 3690, 3980, 3690, 3980,\n    2391, 2391, 2391, 596, 596, 596, 3656, 3656, 3018, 938, 3018, 938,\n    943, 3018, 943, 3018, 2790, 3980, 2790, 3980, 2391, 2391, 2391, 596,\n    596, 596, 2756, 2756, 3018, 938, 3018, 938, 943, 3018, 943, 3018,\n    2790, 3980, 2790, 3980, 2391, 2391, 2391, 596, 596, 596, 2756, 2756,\n    3018, 938, 3018, 938, 943\n]\nPOSSIBLE_CAPACITIES = [4000, 5000, 6000, 7000, 8000]\n```\n\n----------------------------------------\n\nTITLE: Solving and Exporting Scheduling Model in Python\nDESCRIPTION: This snippet handles the solving of the scheduling model and optionally exports the model to a proto file. It sets up the CP-SAT solver, applies parameters, and initiates the solving process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nif _OUTPUT_PROTO.value:\n    print(f\"Writing proto to{_OUTPUT_PROTO.value}\")\n    model.export_to_file(_OUTPUT_PROTO.value)\n\n# solve model.\nsolver = cp_model.CpSolver()\nif _PARAMS.value:\n    text_format.Parse(_PARAMS.value, solver.parameters)\nsolver.parameters.log_search_progress = True\nsolver.solve(model)\n```\n\n----------------------------------------\n\nTITLE: Adding Java Tests in CMake for OR-Tools Graph Module\nDESCRIPTION: Conditionally adds Java tests by globbing *Test.java files if BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/java/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB JAVA_SRCS \"*Test.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Main Execution Logic\nDESCRIPTION: Implements the main execution logic for the Survo puzzle solver. It checks for command-line arguments to read a puzzle from a file, otherwise runs with default values.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/survo_puzzle.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nif len(sys.argv) > 1:\n  file = sys.argv[1]\n  [r, c, rowsums, colsums, game] = read_problem(file)\n  main(r, c, rowsums, colsums, game)\nelse:\n  main()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Library in Python\nDESCRIPTION: This code snippet shows how to install the OR-Tools library using pip. OR-Tools is required to run the Python script for solving linear programming problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_lp_program_mb.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Conditional Build Configuration for C++ Examples in CMake\nDESCRIPTION: Checks if BUILD_CXX_EXAMPLES is enabled and early returns if not. This conditional control ensures examples are only built when explicitly requested.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/cpp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BUILD_CXX_EXAMPLES)\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Network Structure and Capacities for Max Flow Problem\nDESCRIPTION: This section defines the network structure, including nodes, arcs, and capacities for the max flow problem. It also converts 1-based indexing to 0-based for compatibility.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/max_flow_winston1.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n  n = 5\n  nodes = list(range(n))\n\n  # the arcs\n  # Note:\n  # This is 1-based to be compatible with other\n  # implementations.\n  arcs1 = [[1, 2], [1, 3], [2, 3], [2, 4], [3, 5], [4, 5], [5, 1]]\n\n  # convert arcs to 0-based\n  arcs = []\n  for (a_from, a_to) in arcs1:\n    a_from -= 1\n    a_to -= 1\n    arcs.append([a_from, a_to])\n\n  num_arcs = len(arcs)\n\n  # capacities\n  cap = [2, 3, 3, 4, 2, 1, 100]\n\n  # convert arcs to matrix\n  # for sanity checking below\n  mat = {}\n  for i in nodes:\n    for j in nodes:\n      c = 0\n      for k in range(num_arcs):\n        if arcs[k][0] == i and arcs[k][1] == j:\n          c = 1\n      mat[i, j] = c\n```\n\n----------------------------------------\n\nTITLE: Printing VRP Solution\nDESCRIPTION: Defines a function to print the solution of the VRP, including the route for each vehicle and the total distance traveled.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_solution_callback.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(\n    routing_manager: pywrapcp.RoutingIndexManager, routing_model: pywrapcp.RoutingModel\n):\n    \"\"\"Prints solution on console.\"\"\"\n    print(\"################\")\n    print(f\"Solution objective: {routing_model.CostVar().Value()}\")\n    total_distance = 0\n    for vehicle_id in range(routing_manager.GetNumberOfVehicles()):\n        index = routing_model.Start(vehicle_id)\n        if routing_model.IsEnd(routing_model.NextVar(index).Value()):\n            continue\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        while not routing_model.IsEnd(index):\n            plan_output += f\" {routing_manager.IndexToNode(index)} ->\"\n            previous_index = index\n            index = routing_model.NextVar(index).Value()\n            route_distance += routing_model.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\" {routing_manager.IndexToNode(index)}\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        print(plan_output)\n        total_distance += route_distance\n    print(f\"Total Distance of all routes: {total_distance}m\")\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the OR-Tools package using pip, a package installer for Python. OR-Tools is a suite of tools for optimization, including constraint programming and linear programming solvers. This installation is necessary to run the subsequent code that utilizes OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_groups_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for Printing Hidato Puzzles\nDESCRIPTION: Defines helper functions to print the Hidato puzzle board and game state.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/hidato.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef print_board(x, rows, cols):\n  for i in range(rows):\n    for j in range(cols):\n      print(\"% 2s\" % x[i, j].Value(), end=\" \")\n    print(\"\")\n\ndef print_game(game, rows, cols):\n  for i in range(rows):\n    for j in range(cols):\n      print(\"% 2s\" % game[i][j], end=\" \")\n    print(\"\")\n```\n\n----------------------------------------\n\nTITLE: Network Graph Node and Arc Definitions in Protobuf\nDESCRIPTION: Defines a network graph structure with 363 nodes (0-362) and their connecting arcs. The network has a single source (node 361) and sink (node 362) with specific supply values, and arcs between nodes have defined capacities. This represents a flow network configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nnodes {\n  id: 361\n  supply: 1\n}\nnodes {\n  id: 362\n  supply: -1\n}\narcs {\n  tail: 361\n  head: 132\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 132\n  head: 362\n  capacity: 0\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ortools\nDESCRIPTION: This code installs the ortools package using pip. This is a prerequisite for running the bin packing problem solver, as it provides the CP-SAT solver and related functionalities.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/binpacking_problem_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Main Execution of Routing Transit Time Calculation in Python\nDESCRIPTION: The main function acts as the entry point for calculating and printing transit routes using the created data and evaluator classes. It sets up the problem and prints travel times for various predefined routes. No specific parameters are required, but the OR-Tools package must be installed and properly imported.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/transit_time.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"def main():\\n    data = DataProblem()\\n    time_evaluator = CreateTimeEvaluator(data).time_evaluator\\n    print('Route 0:')\\n    print_transit_time([[0, 5], [5, 8], [8, 6], [6, 2], [2, 0]], time_evaluator)\\n    print('Route 1:')\\n    print_transit_time([[0, 9], [9, 14], [14, 16], [16, 10], [10, 0]],\\n                       time_evaluator)\\n    print('Route 2:')\\n    print_transit_time([[0, 12], [12, 13], [13, 15], [15, 11], [11, 0]],\\n                       time_evaluator)\\n    print('Route 3:')\\n    print_transit_time([[0, 7], [7, 4], [4, 3], [3, 1], [1, 0]], time_evaluator)\\nmain()\"\n```\n\n----------------------------------------\n\nTITLE: Time and Duration Data Array in JavaScript/JSON\nDESCRIPTION: A multi-dimensional array containing time and duration information. Each row contains 6 elements: ID number, start time (HH:MM format), end time (HH:MM format), start time in minutes, end time in minutes, and duration in minutes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n    [368, \"08:48\", \"10:11\", 528, 611, 83],\n    [369, \"08:48\", \"10:13\", 528, 613, 85],\n    [370, \"08:49\", \"09:43\", 529, 583, 54],\n    [371, \"08:50\", \"09:30\", 530, 570, 40],\n    [372, \"08:50\", \"10:00\", 530, 600, 70],\n    [373, \"08:50\", \"09:00\", 530, 540, 10],\n    [374, \"08:51\", \"09:17\", 531, 557, 26],\n    [375, \"08:53\", \"09:20\", 533, 560, 27],\n    [376, \"08:53\", \"09:35\", 533, 575, 42],\n    [377, \"08:55\", \"09:34\", 535, 574, 39],\n    [378, \"08:55\", \"09:15\", 535, 555, 20],\n    [379, \"08:58\", \"09:38\", 538, 578, 40],\n    [380, \"08:58\", \"10:26\", 538, 626, 88],\n    [381, \"08:59\", \"09:53\", 539, 593, 54],\n    [382, \"08:59\", \"09:50\", 539, 590, 51],\n    [383, \"09:00\", \"09:35\", 540, 575, 35],\n    [384, \"09:00\", \"09:16\", 540, 556, 16],\n    [385, \"09:00\", \"09:10\", 540, 550, 10],\n    [386, \"09:00\", \"09:16\", 540, 556, 16],\n    [387, \"09:01\", \"09:13\", 541, 553, 12],\n    [388, \"09:03\", \"09:45\", 543, 585, 42],\n    [389, \"09:03\", \"10:28\", 543, 628, 85],\n    [390, \"09:05\", \"09:44\", 545, 584, 39],\n    [391, \"09:05\", \"09:25\", 545, 565, 20],\n    [392, \"09:08\", \"09:53\", 548, 593, 45],\n    [393, \"09:08\", \"10:04\", 548, 604, 56],\n    [394, \"09:09\", \"10:03\", 549, 603, 54],\n    [395, \"09:10\", \"10:15\", 550, 615, 65],\n    [396, \"09:10\", \"09:20\", 550, 560, 10],\n    [397, \"09:11\", \"09:38\", 551, 578, 27],\n    [398, \"09:13\", \"10:00\", 553, 600, 47],\n    [399, \"09:14\", \"09:39\", 554, 579, 25],\n    [400, \"09:14\", \"10:05\", 554, 605, 51],\n    [401, \"09:15\", \"09:54\", 555, 594, 39],\n    [402, \"09:16\", \"09:28\", 556, 568, 12],\n    [403, \"09:18\", \"10:43\", 558, 643, 85],\n    [404, \"09:18\", \"10:41\", 558, 641, 83],\n    [405, \"09:18\", \"09:58\", 558, 598, 40],\n    [406, \"09:19\", \"10:13\", 559, 613, 54],\n    [407, \"09:20\", \"09:30\", 560, 570, 10],\n    [408, \"09:20\", \"09:36\", 560, 576, 16],\n    [409, \"09:21\", \"09:47\", 561, 587, 26],\n    [410, \"09:23\", \"10:30\", 563, 630, 67],\n    [411, \"09:23\", \"10:05\", 563, 605, 42],\n    [412, \"09:23\", \"09:49\", 563, 589, 26],\n    [413, \"09:24\", \"09:35\", 564, 575, 11],\n    [414, \"09:25\", \"09:35\", 565, 575, 10],\n    [415, \"09:25\", \"10:04\", 565, 604, 39],\n    [416, \"09:28\", \"10:08\", 568, 608, 40],\n    [417, \"09:29\", \"09:45\", 569, 585, 16],\n    [418, \"09:29\", \"10:20\", 569, 620, 51],\n    [419, \"09:29\", \"10:56\", 569, 656, 87],\n    [420, \"09:29\", \"10:23\", 569, 623, 54],\n    [421, \"09:30\", \"09:40\", 570, 580, 10],\n    [422, \"09:31\", \"09:43\", 571, 583, 12],\n    [423, \"09:33\", \"10:58\", 573, 658, 85],\n    [424, \"09:33\", \"10:15\", 573, 615, 42],\n    [425, \"09:34\", \"09:45\", 574, 585, 11],\n    [426, \"09:35\", \"10:14\", 575, 614, 39],\n    [427, \"09:38\", \"10:45\", 578, 645, 67],\n    [428, \"09:39\", \"10:33\", 579, 633, 54],\n    [429, \"09:40\", \"09:56\", 580, 596, 16],\n    [430, \"09:40\", \"09:50\", 580, 590, 10],\n    [431, \"09:41\", \"10:08\", 581, 608, 27],\n    [432, \"09:41\", \"10:23\", 581, 623, 42],\n    [433, \"09:44\", \"10:35\", 584, 635, 51],\n    [434, \"09:44\", \"11:11\", 584, 671, 87],\n    [435, \"09:44\", \"09:55\", 584, 595, 11],\n    [436, \"09:45\", \"10:24\", 585, 624, 39],\n    [437, \"09:46\", \"09:58\", 586, 598, 12],\n    [438, \"09:48\", \"10:30\", 588, 630, 42],\n    [439, \"09:48\", \"11:13\", 588, 673, 85],\n    [440, \"09:48\", \"10:04\", 588, 604, 16],\n    [441, \"09:49\", \"10:43\", 589, 643, 54],\n    [442, \"09:50\", \"10:00\", 590, 600, 10],\n    [443, \"09:51\", \"10:17\", 591, 617, 26],\n    [444, \"09:53\", \"10:49\", 593, 649, 56],\n    [445, \"09:53\", \"11:00\", 593, 660, 67],\n    [446, \"09:54\", \"10:05\", 594, 605, 11],\n    [447, \"09:55\", \"10:34\", 595, 634, 39],\n    [448, \"09:56\", \"10:38\", 596, 638, 42],\n    [449, \"09:57\", \"10:20\", 597, 620, 23],\n    [450, \"09:59\", \"11:26\", 599, 686, 87],\n    [451, \"09:59\", \"10:50\", 599, 650, 51],\n    [452, \"09:59\", \"10:53\", 599, 653, 54],\n    [453, \"10:00\", \"10:16\", 600, 616, 16],\n    [454, \"10:00\", \"10:10\", 600, 610, 10],\n    [455, \"10:01\", \"10:13\", 601, 613, 12],\n    [456, \"10:03\", \"11:28\", 603, 688, 85],\n    [457, \"10:03\", \"10:45\", 603, 645, 42],\n    [458, \"10:04\", \"10:15\", 604, 615, 11],\n    [459, \"10:05\", \"10:44\", 605, 644, 39],\n    [460, \"10:08\", \"11:15\", 608, 675, 67],\n    [461, \"10:09\", \"11:03\", 609, 663, 54],\n    [462, \"10:10\", \"10:20\", 610, 620, 10],\n    [463, \"10:11\", \"10:38\", 611, 638, 27],\n    [464, \"10:11\", \"10:53\", 611, 653, 42],\n    [465, \"10:14\", \"11:05\", 614, 665, 51],\n    [466, \"10:14\", \"11:41\", 614, 701, 87],\n    [467, \"10:14\", \"10:25\", 614, 625, 11],\n    [468, \"10:15\", \"10:54\", 615, 654, 39],\n    [469, \"10:16\", \"10:28\", 616, 628, 12],\n    [470, \"10:18\", \"11:43\", 618, 703, 85],\n    [471, \"10:18\", \"11:00\", 618, 660, 42],\n    [472, \"10:19\", \"11:13\", 619, 673, 54],\n    [473, \"10:20\", \"10:30\", 620, 630, 10],\n    [474, \"10:20\", \"10:36\", 620, 636, 16],\n    [475, \"10:21\", \"10:47\", 621, 647, 26],\n    [476, \"10:23\", \"11:30\", 623, 690, 67],\n    [477, \"10:23\", \"10:45\", 623, 645, 22],\n    [478, \"10:24\", \"10:35\", 624, 635, 11],\n    [479, \"10:25\", \"11:04\", 625, 664, 39],\n    [480, \"10:26\", \"11:08\", 626, 668, 42],\n    [481, \"10:29\", \"11:20\", 629, 680, 51],\n    [482, \"10:29\", \"11:23\", 629, 683, 54],\n    [483, \"10:29\", \"11:56\", 629, 716, 87],\n    [484, \"10:30\", \"10:40\", 630, 640, 10],\n    [485, \"10:31\", \"10:43\", 631, 643, 12],\n    [486, \"10:33\", \"11:15\", 633, 675, 42],\n    [487, \"10:33\", \"11:58\", 633, 718, 85],\n    [488, \"10:34\", \"10:45\", 634, 645, 11],\n    [489, \"10:35\", \"11:14\", 635, 674, 39],\n    [490, \"10:38\", \"11:45\", 638, 705, 67],\n    [491, \"10:39\", \"11:33\", 639, 693, 54],\n    [492, \"10:40\", \"10:50\", 640, 650, 10],\n    [493, \"10:40\", \"10:56\", 640, 656, 16],\n    [494, \"10:41\", \"11:23\", 641, 683, 42],\n    [495, \"10:41\", \"11:08\", 641, 668, 27],\n    [496, \"10:44\", \"12:11\", 644, 731, 87],\n    [497, \"10:44\", \"11:35\", 644, 695, 51],\n    [498, \"10:44\", \"10:55\", 644, 655, 11],\n    [499, \"10:45\", \"11:24\", 645, 684, 39],\n    [500, \"10:46\", \"10:58\", 646, 658, 12],\n    [501, \"10:48\", \"12:13\", 648, 733, 85],\n    [502, \"10:48\", \"11:30\", 648, 690, 42],\n    [503, \"10:49\", \"11:43\", 649, 703, 54],\n    [504, \"10:50\", \"11:00\", 650, 660, 10],\n    [505, \"10:51\", \"11:17\", 651, 677, 26],\n    [506, \"10:53\", \"12:00\", 653, 720, 67],\n    [507, \"10:53\", \"11:20\", 653, 680, 27],\n    [508, \"10:54\", \"11:05\", 654, 665, 11],\n    [509, \"10:55\", \"11:34\", 655, 694, 39],\n    [510, \"10:56\", \"11:38\", 656, 698, 42],\n    [511, \"10:59\", \"11:14\", 659, 674, 15],\n    [512, \"10:59\", \"12:26\", 659, 746, 87],\n    [513, \"10:59\", \"11:53\", 659, 713, 54],\n    [514, \"10:59\", \"11:50\", 659, 710, 51],\n    [515, \"11:00\", \"11:16\", 660, 676, 16],\n    [516, \"11:00\", \"11:10\", 660, 670, 10],\n    [517, \"11:01\", \"11:13\", 661, 673, 12],\n    [518, \"11:03\", \"11:45\", 663, 705, 42],\n    [519, \"11:03\", \"12:28\", 663, 748, 85],\n    [520, \"11:04\", \"11:15\", 664, 675, 11],\n    [521, \"11:05\", \"11:44\", 665, 704, 39],\n    [522, \"11:08\", \"12:15\", 668, 735, 67],\n    [523, \"11:09\", \"12:03\", 669, 723, 54],\n    [524, \"11:10\", \"11:20\", 670, 680, 10],\n    [525, \"11:11\", \"11:38\", 671, 698, 27],\n    [526, \"11:11\", \"11:53\", 671, 713, 42],\n    [527, \"11:14\", \"11:25\", 674, 685, 11],\n    [528, \"11:14\", \"12:05\", 674, 725, 51],\n    [529, \"11:14\", \"12:38\", 674, 758, 84],\n    [530, \"11:14\", \"12:41\", 674, 761, 87],\n    [531, \"11:15\", \"11:54\", 675, 714, 39],\n    [532, \"11:16\", \"11:28\", 676, 688, 12],\n    [533, \"11:18\", \"12:00\", 678, 720, 42],\n    [534, \"11:19\", \"12:13\", 679, 733, 54],\n    [535, \"11:20\", \"11:30\", 680, 690, 10],\n    [536, \"11:20\", \"11:36\", 680, 696, 16],\n    [537, \"11:21\", \"11:47\", 681, 707, 26],\n    [538, \"11:23\", \"12:30\", 683, 750, 67],\n    [539, \"11:23\", \"11:49\", 683, 709, 26],\n    [540, \"11:24\", \"12:48\", 684, 768, 84],\n    [541, \"11:24\", \"11:35\", 684, 695, 11],\n    [542, \"11:25\", \"12:04\", 685, 724, 39],\n    [543, \"11:26\", \"12:08\", 686, 728, 42],\n    [544, \"11:29\", \"11:44\", 689, 704, 15],\n    [545, \"11:29\", \"12:23\", 689, 743, 54],\n    [546, \"11:29\", \"12:20\", 689, 740, 51],\n    [547, \"11:29\", \"12:54\", 689, 774, 85],\n    [548, \"11:30\", \"11:40\", 690, 700, 10],\n    [549, \"11:31\", \"11:43\", 691, 703, 12],\n    [550, \"11:33\", \"12:15\", 693, 735, 42],\n    [551, \"11:34\", \"12:58\", 694, 778, 84],\n    [552, \"11:34\", \"11:45\", 694, 705, 11],\n    [553, \"11:35\", \"12:14\", 695, 734, 39],\n    [554, \"11:38\", \"12:45\", 698, 765, 67],\n    [555, \"11:39\", \"12:33\", 699, 753, 54],\n    [556, \"11:40\", \"11:56\", 700, 716, 16],\n    [557, \"11:40\", \"11:50\", 700, 710, 10],\n    [558, \"11:41\", \"12:08\", 701, 728, 27],\n    [559, \"11:41\", \"12:23\", 701, 743, 42],\n    [560, \"11:44\", \"11:55\", 704, 715, 11],\n    [561, \"11:44\", \"13:14\", 704, 794, 90],\n    [562, \"11:44\", \"13:08\", 704, 788, 84],\n    [563, \"11:44\", \"12:35\", 704, 755, 51],\n    [564, \"11:45\", \"12:24\", 705, 744, 39],\n    [565, \"11:46\", \"11:58\", 706, 718, 12],\n    [566, \"11:48\", \"12:30\", 708, 750, 42],\n    [567, \"11:49\", \"12:43\", 709, 763, 54],\n    [568, \"11:50\", \"12:00\", 710, 720, 10],\n    [569, \"11:51\", \"12:17\", 711, 737, 26],\n    [570, \"11:53\", \"12:49\", 713, 769, 56],\n    [571, \"11:53\", \"13:00\", 713, 780, 67],\n    [572, \"11:54\", \"13:18\", 714, 798, 84],\n    [573, \"11:54\", \"12:05\", 714, 725, 11],\n    [574, \"11:55\", \"12:40\", 715, 760, 45],\n    [575, \"11:55\", \"12:34\", 715, 754, 39],\n    [576, \"11:56\", \"12:35\", 716, 755, 39],\n    [577, \"11:57\", \"12:20\", 717, 740, 23],\n    [578, \"11:58\", \"12:29\", 718, 749, 31],\n    [579, \"11:59\", \"12:50\", 719, 770, 51],\n    [580, \"11:59\", \"12:53\", 719, 773, 54],\n    [581, \"11:59\", \"13:24\", 719, 804, 85],\n    [582, \"11:59\", \"12:14\", 719, 734, 15],\n    [583, \"12:00\", \"12:16\", 720, 736, 16],\n    [584, \"12:00\", \"12:10\", 720, 730, 10],\n    [585, \"12:01\", \"12:45\", 721, 765, 44],\n    [586, \"12:01\", \"12:13\", 721, 733, 12],\n    [587, \"12:03\", \"12:50\", 723, 770, 47],\n    [588, \"12:04\", \"12:15\", 724, 735, 11],\n    [589, \"12:04\", \"13:04\", 724, 784, 60],\n    [590, \"12:04\", \"13:28\", 724, 808, 84],\n    [591, \"12:05\", \"12:44\", 725, 764, 39],\n    [592, \"12:08\", \"13:11\", 728, 791, 63],\n    [593, \"12:08\", \"12:39\", 728, 759, 31],\n    [594, \"12:09\", \"13:03\", 729, 783, 54],\n    [595, \"12:10\", \"12:20\", 730, 740, 10],\n    [596, \"12:11\", \"12:55\", 731, 775, 44],\n    [597, \"12:11\", \"12:38\", 731, 758, 27],\n    [598, \"12:14\", \"13:05\", 734, 785, 51],\n    [599, \"12:14\", \"12:25\", 734, 745, 11]\n```\n\n----------------------------------------\n\nTITLE: Creating Discrete Color Map for Visualization\nDESCRIPTION: A utility function that creates a discrete colormap with N colors based on an input colormap. This is useful for visualizing different routes in the vehicle routing solution with distinct colors.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\ndef discrete_cmap(N, base_cmap=None):\n    \"\"\"\n    Create an N-bin discrete colormap from the specified input map\n    \"\"\"\n    # Note that if base_cmap is a string or None, you can simply do\n    #    return plt.cm.get_cmap(base_cmap, N)\n    # The following works for string, None, or a colormap instance:\n\n    base = plt.cm.get_cmap(base_cmap)\n    color_list = base(np.linspace(0, 1, N))\n    cmap_name = base.name + str(N)\n    return base.from_list(cmap_name, color_list, N)\n```\n\n----------------------------------------\n\nTITLE: Maintaining Fixture Consistency and Balancing Home/Away Games with Google OR-Tools in Python\nDESCRIPTION: This snippet maintains consistency of fixtures and balances home and away games through specific logic that prohibits sequences of home or away games longer than 'max_home_stand'. It also uses implication constraints to enforce home/away conditions in the model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nmodel.AddImplication(fixtures[d][t][opponent], at_home[d][t])\nmodel.AddImplication(fixtures[d][t][opponent], at_home[d][opponent].Not())\n\nmodel.AddBoolOr([\n  at_home[d + offset][t] for offset in range(max_home_stand + 1)\n])\nmodel.AddBoolOr([\n  at_home[d + offset][t].Not() for offset in range(max_home_stand + 1)\n])\n```\n\n----------------------------------------\n\nTITLE: Routing Parameters Protocol Buffer\nDESCRIPTION: Protocol buffer definition containing parameters specific to the Vehicle Routing solver configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/README.md#2025-04-17_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nrouting_parameters.proto\n```\n\n----------------------------------------\n\nTITLE: CP Solver Parameters Protocol Buffer\nDESCRIPTION: Protocol buffer definition file that contains all configurable parameters for the CP solver. Used to configure solver behavior and performance characteristics.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/README.md#2025-04-17_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsolver_parameters.proto\n```\n\n----------------------------------------\n\nTITLE: Distance Matrix Import Setup\nDESCRIPTION: Sets up imports and initializes a distance matrix for 40 cities\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n\n\ndistance_matrix = [\n    # fmt:off\n    [0, 10938, 4542, 2835, 29441, 2171, 1611, 9208, 9528, 11111, 16120, 22606, 22127, 20627, 21246, 23387, 16697, 33609, 26184, 24772, 22644, 20655, 30492, 23296, 32979, 18141, 19248, 17129, 17192, 15645, 12658, 11210, 12094, 13175, 18162, 4968, 12308, 10084, 13026, 15056],\n    [10938, 0, 6422, 9742, 18988, 12974, 11216, 19715, 19004, 18271, 25070, 31971, 31632, 30571, 31578, 33841, 27315, 43964, 36944, 35689, 33569, 31481, 41360, 33760, 43631, 28730, 29976, 27803, 28076, 26408, 23504, 22025, 22000, 13197, 14936, 15146, 23246, 20956, 23963, 25994],\n    [4542, 6422, 0, 3644, 25173, 6552, 5092, 13584, 13372, 13766, 19805, 26537, 26117, 24804, 25590, 27784, 21148, 37981, 30693, 29315, 27148, 25071, 34943, 27472, 37281, 22389, 23592, 21433, 21655, 20011, 17087, 15612, 15872, 11653, 15666, 8842, 16843, 14618, 17563, 19589],\n    [2835, 9742, 3644, 0, 28681, 3851, 4341, 11660, 12294, 13912, 18893, 25283, 24777, 23173, 23636, 25696, 18950, 35927, 28233, 26543, 24127, 21864, 31765, 24018, 33904, 19005, 20295, 18105, 18551, 16763, 13958, 12459, 12296, 10370, 15331, 5430, 14044, 12135, 14771, 16743],\n    [29441, 18988, 25173, 28681, 0, 31590, 29265, 37173, 35501, 32929, 40239, 47006, 46892, 46542, 48112, 50506, 44539, 60103, 54208, 53557, 51878, 50074, 59849, 52645, 62415, 47544, 48689, 46560, 46567, 45086, 42083, 40648, 40971, 29929, 28493, 34015, 41473, 38935, 42160, 44198],\n    [2171, 12974, 6552, 3851, 31590, 0, 3046, 7856, 8864, 11330, 15411, 21597, 21065, 19382, 19791, 21845, 15099, 32076, 24425, 22848, 20600, 18537, 28396, 21125, 30825, 15975, 17101, 14971, 15104, 13503, 10544, 9080, 9983, 13435, 18755, 2947, 10344, 8306, 11069, 13078],\n    [1611, 11216, 5092, 4341, 29265, 3046, 0, 8526, 8368, 9573, 14904, 21529, 21085, 19719, 20504, 22713, 16118, 32898, 25728, 24541, 22631, 20839, 30584, 23755, 33278, 18557, 19545, 17490, 17309, 15936, 12881, 11498, 12944, 14711, 19589, 5993, 12227, 9793, 12925, 14967],\n    [9208, 19715, 13584, 11660, 37173, 7856, 8526, 0, 3248, 7855, 8245, 13843, 13272, 11526, 12038, 14201, 7599, 24411, 17259, 16387, 15050, 13999, 23134, 17899, 26460, 12894, 13251, 11680, 10455, 9997, 7194, 6574, 10678, 20959, 26458, 8180, 5255, 2615, 5730, 7552],\n    [9528, 19004, 13372, 12294, 35501, 8864, 8368, 3248, 0, 4626, 6598, 13168, 12746, 11567, 12731, 15083, 9120, 25037, 18718, 18433, 17590, 16888, 25630, 20976, 29208, 16055, 16300, 14838, 13422, 13165, 10430, 9813, 13777, 22300, 27564, 10126, 8388, 5850, 8778, 10422],\n    [11111, 18271, 13766, 13912, 32929, 11330, 9573, 7855, 4626, 0, 7318, 14185, 14005, 13655, 15438, 17849, 12839, 27179, 21947, 22230, 21814, 21366, 29754, 25555, 33535, 20674, 20872, 19457, 17961, 17787, 15048, 14372, 18115, 24280, 29101, 13400, 13008, 10467, 13375, 14935],\n    [16120, 25070, 19805, 18893, 40239, 15411, 14904, 8245, 6598, 7318, 0, 6939, 6702, 6498, 8610, 10961, 7744, 19889, 15350, 16403, 16975, 17517, 24357, 22176, 28627, 18093, 17672, 16955, 14735, 15510, 13694, 13768, 18317, 28831, 34148, 16326, 11276, 9918, 11235, 11891],\n    [22606, 31971, 26537, 25283, 47006, 21597, 21529, 13843, 13168, 14185, 6939, 0, 793, 3401, 5562, 6839, 8923, 13433, 11264, 13775, 15853, 17629, 21684, 22315, 26411, 19539, 18517, 18636, 16024, 17632, 16948, 17587, 22131, 34799, 40296, 21953, 14739, 14568, 14366, 14002],\n    [22127, 31632, 26117, 24777, 46892, 21065, 21085, 13272, 12746, 14005, 6702, 793, 0, 2608, 4809, 6215, 8151, 13376, 10702, 13094, 15099, 16845, 21039, 21535, 25744, 18746, 17725, 17845, 15232, 16848, 16197, 16859, 21391, 34211, 39731, 21345, 14006, 13907, 13621, 13225],\n    [20627, 30571, 24804, 23173, 46542, 19382, 19719, 11526, 11567, 13655, 6498, 3401, 2608, 0, 2556, 4611, 5630, 13586, 9157, 11005, 12681, 14285, 19044, 18996, 23644, 16138, 15126, 15240, 12625, 14264, 13736, 14482, 18958, 32292, 37879, 19391, 11621, 11803, 11188, 10671],\n    [21246, 31578, 25590, 23636, 48112, 19791, 20504, 12038, 12731, 15438, 8610, 5562, 4809, 2556, 0, 2411, 4917, 12395, 6757, 8451, 10292, 12158, 16488, 16799, 21097, 14374, 13194, 13590, 10943, 12824, 12815, 13779, 18042, 32259, 37918, 19416, 10975, 11750, 10424, 9475],\n    [23387, 33841, 27784, 25696, 50506, 21845, 22713, 14201, 15083, 17849, 10961, 6839, 6215, 4611, 2411, 0, 6760, 10232, 4567, 7010, 9607, 12003, 14846, 16408, 19592, 14727, 13336, 14109, 11507, 13611, 14104, 15222, 19237, 34013, 39703, 21271, 12528, 13657, 11907, 10633],\n    [16697, 27315, 21148, 18950, 44539, 15099, 16118, 7599, 9120, 12839, 7744, 8923, 8151, 5630, 4917, 6760, 0, 16982, 9699, 9400, 9302, 9823, 16998, 14534, 21042, 10911, 10190, 9900, 7397, 8758, 8119, 8948, 13353, 27354, 33023, 14542, 6106, 6901, 5609, 5084],\n    [33609, 43964, 37981, 35927, 60103, 32076, 32898, 24411, 25037, 27179, 19889, 13433, 13376, 13586, 12395, 10232, 16982, 0, 8843, 12398, 16193, 19383, 16423, 22583, 20997, 22888, 21194, 22640, 20334, 22636, 23801, 25065, 28675, 44048, 49756, 31426, 22528, 23862, 21861, 20315],\n    [26184, 36944, 30693, 28233, 54208, 24425, 25728, 17259, 18718, 21947, 15350, 11264, 10702, 9157, 6757, 4567, 9699, 8843, 0, 3842, 7518, 10616, 10666, 14237, 15515, 14053, 12378, 13798, 11537, 13852, 15276, 16632, 19957, 35660, 41373, 23361, 14333, 16125, 13624, 11866],\n    [24772, 35689, 29315, 26543, 53557, 22848, 24541, 16387, 18433, 22230, 16403, 13775, 13094, 11005, 8451, 7010, 9400, 12398, 3842, 0, 3795, 7014, 8053, 10398, 12657, 10633, 8889, 10569, 8646, 10938, 12906, 14366, 17106, 33171, 38858, 21390, 12507, 14748, 11781, 9802],\n    [22644, 33569, 27148, 24127, 51878, 20600, 22631, 15050, 17590, 21814, 16975, 15853, 15099, 12681, 10292, 9607, 9302, 16193, 7518, 3795, 0, 3250, 8084, 6873, 11763, 6949, 5177, 7050, 5619, 7730, 10187, 11689, 13792, 30012, 35654, 18799, 10406, 12981, 9718, 7682],\n    [20655, 31481, 25071, 21864, 50074, 18537, 20839, 13999, 16888, 21366, 17517, 17629, 16845, 14285, 12158, 12003, 9823, 19383, 10616, 7014, 3250, 0, 9901, 4746, 12531, 3737, 1961, 4036, 3588, 5109, 7996, 9459, 10846, 27094, 32690, 16451, 8887, 11624, 8304, 6471],\n    [30492, 41360, 34943, 31765, 59849, 28396, 30584, 23134, 25630, 29754, 24357, 21684, 21039, 19044, 16488, 14846, 16998, 16423, 10666, 8053, 8084, 9901, 0, 9363, 4870, 13117, 11575, 13793, 13300, 15009, 17856, 19337, 20454, 36551, 42017, 26352, 18403, 21033, 17737, 15720],\n    [23296, 33760, 27472, 24018, 52645, 21125, 23755, 17899, 20976, 25555, 22176, 22315, 21535, 18996, 16799, 16408, 14534, 22583, 14237, 10398, 6873, 4746, 9363, 0, 10020, 5211, 4685, 6348, 7636, 8010, 11074, 12315, 11926, 27537, 32880, 18634, 12644, 15358, 12200, 10674],\n    [32979, 43631, 37281, 33904, 62415, 30825, 33278, 26460, 29208, 33535, 28627, 26411, 25744, 23644, 21097, 19592, 21042, 20997, 15515, 12657, 11763, 12531, 4870, 10020, 0, 14901, 13738, 15855, 16118, 17348, 20397, 21793, 21936, 37429, 42654, 28485, 21414, 24144, 20816, 18908],\n    [18141, 28730, 22389, 19005, 47544, 15975, 18557, 12894, 16055, 20674, 18093, 19539, 18746, 16138, 14374, 14727, 10911, 22888, 14053, 10633, 6949, 3737, 13117, 5211, 14901, 0, 1777, 1217, 3528, 2896, 5892, 7104, 7338, 23517, 29068, 13583, 7667, 10304, 7330, 6204],\n    [19248, 29976, 23592, 20295, 48689, 17101, 19545, 13251, 16300, 20872, 17672, 18517, 17725, 15126, 13194, 13336, 10190, 21194, 12378, 8889, 5177, 1961, 11575, 4685, 13738, 1777, 0, 2217, 2976, 3610, 6675, 8055, 8965, 25197, 30774, 14865, 8007, 10742, 7532, 6000],\n    [17129, 27803, 21433, 18105, 46560, 14971, 17490, 11680, 14838, 19457, 16955, 18636, 17845, 15240, 13590, 14109, 9900, 22640, 13798, 10569, 7050, 4036, 13793, 6348, 15855, 1217, 2217, 0, 2647, 1686, 4726, 6000, 6810, 23060, 28665, 12674, 6450, 9094, 6117, 5066],\n    [17192, 28076, 21655, 18551, 46567, 15104, 17309, 10455, 13422, 17961, 14735, 16024, 15232, 12625, 10943, 11507, 7397, 20334, 11537, 8646, 5619, 3588, 13300, 7636, 16118, 3528, 2976, 2647, 0, 2320, 4593, 6093, 8479, 24542, 30219, 13194, 5301, 8042, 4735, 3039],\n    [15645, 26408, 20011, 16763, 45086, 13503, 15936, 9997, 13165, 17787, 15510, 17632, 16848, 14264, 12824, 13611, 8758, 22636, 13852, 10938, 7730, 5109, 15009, 8010, 17348, 2896, 3610, 1686, 2320, 0, 3086, 4444, 6169, 22301, 27963, 11344, 4780, 7408, 4488, 3721],\n    [12658, 23504, 17087, 13958, 42083, 10544, 12881, 7194, 10430, 15048, 13694, 16948, 16197, 13736, 12815, 14104, 8119, 23801, 15276, 12906, 10187, 7996, 17856, 11074, 20397, 5892, 6675, 4726, 4593, 3086, 0, 1501, 5239, 20390, 26101, 8611, 2418, 4580, 2599, 3496],\n    [11210, 22025, 15612, 12459, 40648, 9080, 11498, 6574, 9813, 14372, 13768, 17587, 16859, 14482, 13779, 15222, 8948, 25065, 16632, 14366, 11689, 9459, 19337, 12315, 21793, 7104, 8055, 6000, 6093, 4444, 1501, 0, 4608, 19032, 24747, 7110, 2860, 4072, 3355, 4772],\n    [12094, 22000, 15872, 12296, 40971, 9983, 12944, 10678, 13777, 18115, 18317, 22131, 21391, 18958, 18042, 19237, 13353, 28675, 19957, 17106, 13792, 10846, 20454, 11926, 21936, 7338, 8965, 6810, 8479, 6169, 5239, 4608, 0, 16249, 21866, 7146, 7403, 8446, 7773, 8614]\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG for Windows Builds\nDESCRIPTION: Configures and builds SWIG for Windows platforms when Python, Java, or .NET builds are enabled. Downloads and compiles SWIG from source.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(WIN32\n   AND (BUILD_PYTHON\n        OR BUILD_JAVA\n        OR BUILD_DOTNET))\n  message(CHECK_START \"Fetching SWIG\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/SWIG.CMakeLists.txt.in\n                 ${CMAKE_CURRENT_BINARY_DIR}/SWIG/CMakeLists.txt @ONLY)\n\n  execute_process(\n    COMMAND ${CMAKE_COMMAND} -H. -Bproject_build -G \"${CMAKE_GENERATOR}\"\n    RESULT_VARIABLE result\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/SWIG)\n  if(result)\n    message(FATAL_ERROR \"CMake step for SWIG failed: ${result}\")\n  endif()\n\n  execute_process(\n    COMMAND ${CMAKE_COMMAND} --build project_build --config Release\n    RESULT_VARIABLE result\n    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/SWIG)\n  if(result)\n    message(FATAL_ERROR \"Build step for SWIG failed: ${result}\")\n  endif()\n\n  set(SWIG_EXECUTABLE\n      ${CMAKE_CURRENT_BINARY_DIR}/SWIG/source/swig.exe\n      CACHE INTERNAL \"swig.exe location\" FORCE)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Library for Python\nDESCRIPTION: Pip command to install the Google OR-Tools package, which provides the constraint programming solver used in this implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/pentominoes_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Solver Wrappers Library Build in CMake\nDESCRIPTION: Configures compilation of linear solver wrapper library for OR-Tools. Sets up source files glob pattern, creates an object library with position independent code, and configures include directories and dependencies including optional SCIP integration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/wrappers/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_linear_solver_wrappers)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::status\n  $<$<BOOL:${USE_SCIP}>:libscip>\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::linear_solver_wrappers ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Solvers Library in CMake\nDESCRIPTION: Sets up a CMake library target for the mathematical optimization solvers component of OR-Tools. It includes source files conditionally based on which solver libraries are available in the build environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_solvers)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB_RECURSE _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.+_test.cc\")\n\nif(NOT USE_GLPK)\n  list(FILTER _SRCS EXCLUDE REGEX \"/glpk/\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/glpk_.+.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/glpk_.+.cc$\")\nendif()\nif(NOT USE_GUROBI)\n  list(FILTER _SRCS EXCLUDE REGEX \"/gurobi/\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/gurobi_.+.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/gurobi_.+.cc$\")\nendif()\nif(NOT USE_HIGHS)\n  list(FILTER _SRCS EXCLUDE REGEX \"/highs_.+.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/highs_.+.cc$\")\nendif()\nif(NOT USE_PDLP)\n  list(FILTER _SRCS EXCLUDE REGEX \"/pdlp_.+.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/pdlp_.+.cc$\")\nendif()\nif(NOT USE_SCIP)\n  list(FILTER _SRCS EXCLUDE REGEX \"/gscip/\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/gscip_.+.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/gscip_.+.cc$\")\nendif()\nif(NOT USE_XPRESS)\n  list(FILTER _SRCS EXCLUDE REGEX \"/xpress/\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/xpress_.+.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/xpress_.+.cc$\")\nendif()\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  $<$<BOOL:${USE_GLPK}>:GLPK::GLPK>\n  $<$<BOOL:${USE_HIGHS}>:highs::highs>\n  $<$<BOOL:${USE_PDLP}>:Eigen3::Eigen>\n  $<$<BOOL:${USE_SCIP}>:libscip>\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Implementing Problem Reading Function for Minesweeper\nDESCRIPTION: Defines a function to read a Minesweeper problem instance from a file, parsing the board size and mine positions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/minesweeper.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef read_problem(file):\n  f = open(file, \"r\")\n  rows = int(f.readline())\n  cols = int(f.readline())\n  game = []\n  for i in range(rows):\n    x = f.readline()\n    row = [0] * cols\n    for j in range(cols):\n      if x[j] == \".\":\n        tmp = -1\n      else:\n        tmp = int(x[j])\n      row[j] = tmp\n    game.append(row)\n  return [game, rows, cols]\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Solver Proto Library in CMake\nDESCRIPTION: Setting up the linear solver proto solver library as an object library with position independent code, including directory configurations and linking dependencies with various solver libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/proto_solver/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_linear_solver_proto_solver)\n\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::strings\n  absl::status\n  absl::str_format\n  $<$<BOOL:${USE_PDLP}>:Eigen3::Eigen>\n  $<$<BOOL:${USE_SCIP}>:libscip>\n  $<$<BOOL:${USE_HIGHS}>:highs::highs>\n  ${PROJECT_NAMESPACE}::ortools_proto)\n```\n\n----------------------------------------\n\nTITLE: Printing VRP Solution\nDESCRIPTION: This function prints the solution to the Vehicle Routing Problem. It displays the objective value, dropped nodes, and detailed routes for each vehicle, including distance traveled and items picked up at each stop.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_items_to_deliver.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_solution(data, manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    print(f\"Objective: {assignment.ObjectiveValue()}\")\n    # Display dropped nodes.\n    dropped_nodes = \"Dropped nodes:\"\n    for node in range(routing.Size()):\n        if routing.IsStart(node) or routing.IsEnd(node):\n            continue\n        if assignment.Value(routing.NextVar(node)) == node:\n            dropped_nodes += f\" {manager.IndexToNode(node)}\"\n    print(dropped_nodes)\n    # Display routes\n    total_distance = 0\n    total_load_x = 0\n    total_load_y = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        if not routing.IsVehicleUsed(assignment, vehicle_id):\n            continue\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\\n\"\n        route_distance = 0\n        route_load_x = 0\n        route_load_y = 0\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index)\n            route_load_x += data[\"providers_x\"][node_index]\n            route_load_y += data[\"providers_y\"][node_index]\n            plan_output += f\" {node_index} Load(X:{route_load_x}, Y:{route_load_y}) -> \"\n            previous_index = index\n            previous_node_index = node_index\n            index = assignment.Value(routing.NextVar(index))\n            node_index = manager.IndexToNode(index)\n            route_distance += data[\"distance_matrix\"][previous_node_index][node_index]\n        node_index = manager.IndexToNode(index)\n        plan_output += f\" {node_index} Load({route_load_x}, {route_load_y})\\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\\n\"\n        plan_output += f\"Load of the route: X:{route_load_x}, Y:{route_load_y}\\n\"\n        print(plan_output)\n```\n\n----------------------------------------\n\nTITLE: Implementing fetch_git_dependency Function in CMake\nDESCRIPTION: A custom CMake function that downloads, builds and installs a git dependency at configure time. It accepts parameters for the dependency name, repository URL, tag, patch command, source subdirectory, and specific CMake arguments to add.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/host.CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(fetch_git_dependency)\n  set(options \"\")\n  set(oneValueArgs NAME REPOSITORY TAG PATCH_COMMAND SOURCE_SUBDIR)\n  set(multiValueArgs CMAKE_ARGS)\n  cmake_parse_arguments(GIT_DEP\n    \"${options}\"\n    \"${oneValueArgs}\"\n    \"${multiValueArgs}\"\n    ${ARGN}\n  )\n  message(STATUS \"Building ${GIT_DEP_NAME}: ...\")\n  string(TOLOWER ${GIT_DEP_NAME} NAME_LOWER)\n\n  if(GIT_DEP_PATCH_COMMAND)\n    set(PATCH_CMD \"${GIT_DEP_PATCH_COMMAND}\")\n  else()\n    set(PATCH_CMD \"\")\n  endif()\n  configure_file(\n    ${CMAKE_CURRENT_LIST_DIR}/CMakeLists.txt.in\n    ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-subbuild/CMakeLists.txt @ONLY)\n\n  execute_process(\n    COMMAND ${CMAKE_COMMAND} -S. -Bproject_build -G \"${CMAKE_GENERATOR}\"\n    RESULT_VARIABLE result\n    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-subbuild)\n  if(result)\n    message(FATAL_ERROR \"CMake step for ${GIT_DEP_NAME} failed: ${result}\")\n  endif()\n\n  execute_process(\n    COMMAND ${CMAKE_COMMAND} --build project_build --config ${CMAKE_BUILD_TYPE}\n    RESULT_VARIABLE result\n    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-subbuild)\n  if(result)\n    message(FATAL_ERROR \"Build step for ${GIT_DEP_NAME} failed: ${result}\")\n  endif()\n\n  if(GIT_DEP_SOURCE_SUBDIR)\n    add_subdirectory(\n      ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-src/${GIT_DEP_SOURCE_SUBDIR}\n      ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-build)\n  else()\n    add_subdirectory(\n      ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-src\n      ${CMAKE_BINARY_DIR}/_deps/${NAME_LOWER}-build)\n  endif()\n\n  message(STATUS \"Building ${GIT_DEP_NAME}: ...DONE\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Samples Build for OR-Tools\nDESCRIPTION: This snippet configures the build process for C++ samples. It uses a glob pattern to find all .cc files and adds them as samples using the add_cxx_sample function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Network Flow Graph Structure in Protocol Buffers\nDESCRIPTION: This snippet defines the structure of a network flow graph using Protocol Buffers. It specifies arcs with tail (source), head (destination), and capacity attributes. The problem type is set to MAX_FLOW, indicating a maximum flow optimization problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\narcs {\n  tail: 328\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 347\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 347\n  head: 362\n  capacity: 0\n}\n// ... (more arc definitions) ...\narcs {\n  tail: 84\n  head: 83\n  capacity: 394486\n}\nproblem_type: MAX_FLOW\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools and Defining Main Function\nDESCRIPTION: Imports the necessary OR-Tools module and defines the main function that will contain the puzzle-solving logic.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Einav puzzle\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Example Builds in CMake for OR-Tools\nDESCRIPTION: Collects all Python source files and filters out examples that are too long, require input, or have dependencies on system resources. The remaining examples are added to the build using the add_python_example function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/contrib/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_PYTHON_EXAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  # Remove too long examples, or not working\n  # ISSUE: Seems to works using Makefile based build\n  # ???: not tested even in Makefile based build (i.e. unmaintained)\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/bacp.py\") # need input\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/nontransitive_dice.py\") # too long\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/secret_santa.py\") # too long\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/steel.py\") # need input\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/steel_lns.py\") # need input\n  # Not working everywhere since it rely on /usr/share/dict/words\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/word_square.py\")\n\n  #list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/project_scheduling_sat.py\") # ISSUE\n  #list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/sports_schedule_sat.py\") # ISSUE\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Variables and Literals in C#\nDESCRIPTION: Shows how to create a boolean variable and its negation (literal) in C# using the CP-SAT solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class LiteralSampleSat\n{\n    static void Main()\n    {\n        CpModel model = new CpModel();\n        BoolVar x = model.NewBoolVar(\"x\");\n        ILiteral not_x = x.Not();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Sequence Constraints in No-Overlap Sample\nDESCRIPTION: Implements a sample problem with sequence constraints in a no-overlap scheduling scenario, using the CP-SAT solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/sequences_in_no_overlap_sample_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef sequences_in_no_overlap_sample_sat():\n    \"\"\"Implement cumul and length constraints in a NoOverlap constraint.\"\"\"\n\n    # Tasks (duration, type).\n    tasks = [\n        (5, \"A\"),\n        (6, \"A\"),\n        (7, \"A\"),\n        (2, \"A\"),\n        (3, \"A\"),\n        (5, \"B\"),\n        (2, \"B\"),\n        (3, \"B\"),\n        (1, \"B\"),\n        (4, \"B\"),\n        (3, \"B\"),\n        (6, \"B\"),\n        (2, \"B\"),\n    ]\n\n    # Sequence length constraints per task_types: (hard_min, hard_max)\n    #\n    # Note that this constraint is very tight for task type B and will fail with\n    # an odd number of tasks of type B.\n    sequence_length_constraints = {\n        \"A\": (1, 3),\n        \"B\": (2, 2),\n    }\n\n    # Sequence accumulated durations constraints per task_types:\n    #     (soft_max, linear_penalty, hard_max)\n    sequence_cumul_constraints = {\n        \"A\": (6, 1, 10),\n        \"B\": (7, 0, 7),\n    }\n\n    model: cp_model.CpModel = cp_model.CpModel()\n    horizon: int = sum(t[0] for t in tasks)\n\n    num_tasks = len(tasks)\n    all_tasks = range(num_tasks)\n\n    starts = []\n    durations = []\n    intervals = []\n    task_types = []\n\n    # Creates intervals for each task.\n    for duration, task_type in tasks:\n        index = len(starts)\n        start = model.new_int_var(0, horizon - duration, f\"start[{index}]\")\n        interval = model.new_fixed_size_interval_var(\n            start, duration, f\"interval[{index}]\"\n        )\n\n        starts.append(start)\n        durations.append(duration)\n        intervals.append(interval)\n        task_types.append(task_type)\n\n    # Create length variables for each task.\n    lengths = []\n    for i in all_tasks:\n        max_hard_length = sequence_length_constraints[task_types[i]][1]\n        lengths.append(model.new_int_var(1, max_hard_length, f\"length_{i}\"))\n\n    # Create cumul variables for each task.\n    cumuls = []\n    for i in all_tasks:\n        max_hard_cumul = sequence_cumul_constraints[task_types[i]][2]\n        cumuls.append(model.new_int_var(durations[i], max_hard_cumul, f\"cumul_{i}\"))\n\n    # Adds NoOverlap constraint.\n    model.add_no_overlap(intervals)\n\n    # Adds the constraints on the lengths and cumuls of maximal sequences of\n    # tasks of the same type.\n    penalty_terms = sequence_constraints_with_circuit(\n        model,\n        starts,\n        durations,\n        task_types,\n        lengths,\n        cumuls,\n        sequence_length_constraints,\n        sequence_cumul_constraints,\n    )\n\n    # Minimize the sum of penalties,\n    model.minimize(sum(var * penalty for var, penalty in penalty_terms))\n\n    # Solves the model model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        # Prints out the makespan and the start times and lengths, cumuls at each\n        # step.\n        if status == cp_model.OPTIMAL:\n            print(f\"Optimal cost: {solver.objective_value}\")\n        else:\n            print(f\"Feasible cost: {solver.objective_value}\")\n\n        to_sort = []\n        for t in all_tasks:\n            to_sort.append((solver.value(starts[t]), t))\n        to_sort.sort()\n\n        sum_of_penalties = 0\n        for i, (start, t) in enumerate(to_sort):\n            # Check length constraints.\n```\n\n----------------------------------------\n\nTITLE: Solution Assignment Protocol Buffer\nDESCRIPTION: Protocol buffer definition for storing CP problem solutions, used by both CP and Routing solvers to represent final results.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/README.md#2025-04-17_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nassignment.proto\n```\n\n----------------------------------------\n\nTITLE: Printing School Schedule with OR-Tools in Python\nDESCRIPTION: A method that prints the complete school schedule by iterating through time slots, levels, sections, subjects, and teachers. For each valid assignment in the solution, it displays the corresponding schedule entry.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef print_school_schedule(self):\n    print('School:')\n    for slt_idx, slot in enumerate(self._problem.time_slots):\n        tmp = f'{slot}:'\n        for lvl_idx, level in enumerate(self._problem.levels):\n            for sec_idx, section in enumerate(self._problem.sections):\n                for sub_idx, subject in enumerate(self._problem.subjects):\n                    for tch_idx, teacher in enumerate(self._problem.teachers):\n                        key = (lvl_idx, sec_idx, sub_idx, tch_idx, slt_idx)\n                        if self._solver.BooleanValue(self._assignment[key]):\n                            tmp += f' {level}-{section}:({subject},{teacher})'\n        print(tmp)\n```\n\n----------------------------------------\n\nTITLE: Structured Numerical Data for Operations Research Problem\nDESCRIPTION: This data file contains a problem specification with 20 items and 5 attributes, followed by 5 square matrices (M0-M4) of size 20x20. The format suggests this is input data for an optimization algorithm, possibly for assignment, scheduling, or routing problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/testdata/SDST10_ta001.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n20 5\n  0 54  1 79  2 16  3 66  4 58\n  0 83  1  3  2 89  3 58  4 56\n  0 15  1 11  2 49  3 31  4 20\n  0 71  1 99  2 15  3 68  4 85\n  0 77  1 56  2 89  3 78  4 53\n  0 36  1 70  2 45  3 91  4 35\n  0 53  1 99  2 60  3 13  4 53\n  0 38  1 60  2 23  3 59  4 41\n  0 27  1  5  2 57  3 49  4 69\n  0 87  1 56  2 64  3 85  4 13\n  0 76  1  3  2  7  3 85  4 86\n  0 91  1 61  2  1  3  9  4 72\n  0 14  1 73  2 63  3 39  4  8\n  0 29  1 75  2 41  3 41  4 49\n  0 12  1 47  2 63  3 56  4 47\n  0 77  1 14  2 47  3 40  4 87\n  0 32  1 21  2 26  3 54  4 58\n  0 87  1 86  2 75  3 77  4 18\n  0 68  1  5  2 77  3 51  4 68\n  0 94  1 77  2 40  3 31  4 28\nSSD\nM0\n  0  5  8  2  7  7  4  5  4  3  8  7  9  2  3  2  7  3  8  7\n  9  0  8  1  1  9  6  7  9  6  1  6  1  6  7  7  5  2  2  8\n  1  7  0  2  9  5  2  9  5  6  3  6  6  1  1  6  4  6  5  3\n  7  7  4  0  6  6  3  7  8  9  2  6  5  8  8  1  4  4  6  4\n  5  7  5  3  0  6  6  2  8  5  4  5  4  7  2  8  7  1  5  5\n  8  6  2  7  3  0  2  1  7  3  8  4  4  1  6  1  5  1  9  4\n  8  7  5  9  1  8  0  7  4  1  2  9  5  5  3  3  4  9  4  4\n  6  4  4  4  1  8  1  0  1  1  5  6  6  3  9  8  3  1  1  5\n  7  4  2  6  4  3  6  6  0  3  7  6  8  9  4  2  2  7  4  3\n  7  8  6  6  6  8  9  6  6  0  4  1  1  4  6  4  5  6  1  4\n  5  9  8  5  3  3  7  1  9  1  0  9  7  6  3  9  1  4  5  8\n  9  7  4  2  2  7  5  5  4  8  2  0  5  7  4  3  8  9  6  4\n  1  9  7  2  4  4  7  9  9  4  1  5  0  3  9  3  1  7  9  1\n  9  2  5  4  1  2  2  2  6  8  8  1  6  0  1  2  2  6  1  2\n  5  8  8  1  3  8  7  7  4  9  3  9  9  4  0  4  3  3  1  8\n  7  6  9  5  6  2  9  6  7  1  3  5  3  6  6  0  5  9  9  6\n  2  5  3  7  7  2  1  5  3  1  7  9  4  5  2  9  0  8  8  7\n  8  4  3  8  4  7  3  7  6  4  9  6  3  6  3  6  9  0  7  7\n  9  4  4  7  2  4  1  7  7  3  8  7  7  3  1  5  6  6  0  7\n  5  5  7  4  9  3  6  9  4  2  9  5  8  7  7  5  5  1  7  0\nM1\n  0  2  8  9  5  6  2  9  6  6  8  8  6  3  4  1  5  5  2  4\n  7  0  5  3  7  9  1  8  6  5  9  3  8  7  3  2  8  8  1  2\n  4  2  0  2  7  3  9  1  6  5  9  5  7  6  7  3  8  2  6  9\n  9  7  2  0  6  4  1  4  1  4  2  7  4  6  3  5  4  1  4  8\n  8  3  5  2  0  4  5  4  3  4  3  2  7  9  2  4  8  4  5  3\n  3  7  5  6  9  0  7  8  9  1  2  1  1  4  5  3  4  6  1  3\n  6  8  4  4  1  2  0  3  4  3  8  9  5  5  6  3  5  8  4  4\n  4  4  5  4  6  4  5  0  6  6  4  1  3  6  5  7  5  1  3  3\n  9  1  2  9  7  8  9  4  0  8  9  6  5  5  2  6  9  4  5  7\n  5  8  2  4  4  5  2  1  1  0  8  5  5  8  8  1  3  1  9  6\n  6  7  5  3  8  3  1  3  2  9  0  7  3  6  4  5  9  9  3  7\n  3  5  7  8  1  8  5  7  6  8  7  0  3  2  6  4  7  6  7  2\n  3  8  4  9  2  2  2  6  2  1  5  9  0  6  1  9  4  7  1  2\n  7  7  5  5  9  7  9  8  3  3  8  6  9  0  2  9  8  6  3  9\n  8  8  2  7  6  9  8  8  3  7  9  5  7  9  0  1  5  6  3  4\n  9  4  3  6  9  3  4  3  8  7  1  4  1  1  6  0  6  8  4  3\n  5  6  1  8  2  9  1  6  6  3  7  1  9  6  7  4  0  5  8  8\n  9  2  7  5  7  9  5  5  1  8  7  4  1  5  6  5  8  0  3  9\n  8  1  8  3  5  9  7  8  2  6  4  9  4  7  5  8  9  5  0  4\n  7  6  9  6  8  7  2  5  9  9  1  3  6  2  5  2  5  2  6  0\nM2\n  0  6  8  2  5  3  7  1  4  3  5  8  8  6  1  3  2  8  6  3\n  6  0  8  2  7  3  6  2  8  3  6  6  1  8  1  3  1  1  2  9\n  5  7  0  6  2  9  5  8  4  3  7  7  5  8  3  4  9  9  4  9\n  3  3  6  0  8  4  2  9  9  5  5  2  2  2  4  1  9  2  6  3\n  3  4  5  3  0  4  9  4  5  3  8  5  5  6  8  5  2  3  8  6\n  6  1  6  1  1  0  4  1  7  6  4  7  5  5  8  8  4  1  3  3\n  3  6  3  9  3  1  0  2  1  3  1  9  3  2  1  8  6  8  1  2\n  7  1  1  9  7  5  8  0  8  4  5  2  1  9  9  3  6  4  1  1\n  1  1  8  9  1  6  6  5  0  9  5  5  4  4  1  8  2  5  1  9\n  1  8  1  1  1  3  4  9  1  0  9  7  1  6  7  5  7  8  1  4\n  1  3  8  5  9  1  9  5  8  1  0  9  5  2  8  9  3  6  8  4\n  2  5  5  3  5  6  6  3  9  8  4  0  8  3  4  3  1  3  7  4\n  2  6  2  3  1  3  7  6  8  1  5  3  0  7  5  1  5  3  1  8\n  7  2  8  7  4  2  6  2  6  9  4  9  8  0  7  1  3  9  5  7\n  9  1  9  3  3  4  7  3  6  2  6  9  7  1  0  6  1  2  3  2\n  2  7  6  9  9  6  4  5  4  7  3  1  6  6  5  0  6  8  4  4\n  8  9  2  9  2  9  5  8  6  7  4  5  8  2  5  9  0  7  8  4\n  1  8  5  8  8  2  6  2  6  7  2  8  5  8  2  4  2  0  8  9\n  1  7  3  4  5  5  5  3  7  1  3  6  5  2  1  9  9  5  0  1\n  6  9  5  1  9  2  9  4  1  3  3  6  2  5  7  9  5  5  3  0\nM3\n  0  7  1  8  1  5  6  7  4  4  3  2  4  7  8  8  6  8  2  1\n  5  0  1  5  8  6  9  3  5  8  6  3  3  8  1  8  5  7  5  3\n  6  4  0  7  4  1  7  7  6  6  8  5  3  3  8  1  7  5  3  5\n  1  4  5  0  8  3  4  9  8  9  6  5  2  1  3  6  1  7  8  8\n  3  2  3  9  0  5  8  8  5  5  5  8  9  3  1  4  4  5  7  2\n  8  2  8  2  5  0  1  7  8  1  4  2  6  1  7  9  5  4  4  4\n  1  3  2  4  3  3  0  4  8  5  7  7  5  2  7  4  6  8  1  8\n  9  8  2  2  5  4  6  0  9  3  7  9  2  1  3  9  1  9  1  9\n  1  1  8  4  5  7  5  2  0  1  3  5  2  8  4  2  1  1  2  8\n  3  5  1  8  1  9  4  9  7  0  2  7  1  3  2  3  5  8  2  2\n  9  9  5  2  9  6  3  7  9  6  0  8  5  4  5  2  5  3  5  3\n  3  2  9  1  5  7  4  4  5  5  6  0  8  4  7  9  1  1  5  1\n  5  8  2  4  2  6  6  4  4  7  9  2  0  9  6  4  5  3  5  3\n  6  1  8  6  3  1  4  7  6  1  5  8  6  0  8  4  2  7  9  8\n  1  3  8  6  7  1  1  2  7  8  7  3  2  1  0  9  1  7  4  9\n  9  3  2  8  9  9  2  8  8  2  6  2  9  1  9  0  6  3  1  4\n  6  7  5  1  9  5  4  5  1  6  8  6  3  5  3  3  0  5  1  8\n  4  8  4  2  3  6  1  8  3  7  1  4  5  3  4  2  6  0  7  5\n  6  1  4  9  6  7  3  5  1  2  2  3  1  3  6  7  3  6  0  3\n  2  6  3  7  9  8  4  3  1  2  4  6  1  8  8  7  3  1  6  0\nM4\n  0  5  3  4  4  9  1  2  7  6  7  7  6  8  4  9  2  4  3  1\n  3  0  8  4  1  3  1  1  3  4  3  6  4  3  7  9  3  3  5  3\n  1  6  0  1  4  9  2  1  2  8  3  4  4  3  9  8  8  7  2  2\n  7  7  4  0  6  3  3  3  3  7  7  3  9  6  5  3  1  3  8  4\n  6  7  4  6  0  9  5  6  5  7  7  5  4  5  3  1  1  4  3  7\n  6  8  9  1  9  0  9  3  1  8  9  8  4  2  5  2  5  7  2  8\n  8  9  1  9  4  3  0  8  9  6  3  4  2  5  4  8  7  7  2  5\n  1  6  2  5  9  3  4  0  6  7  1  2  5  2  2  3  6  3  8  7\n  1  7  4  9  5  3  3  3  0  4  4  6  8  3  8  6  8  8  2  8\n  3  1  6  1  3  5  9  5  3  0  7  2  6  1  2  3  6  8  3  6\n  9  4  9  9  6  1  4  2  9  8  0  3  1  3  6  4  7  6  8  5\n  9  7  4  7  4  4  8  8  2  5  7  0  9  5  6  2  1  3  3  9\n  5  6  3  8  1  4  3  8  1  4  4  5  0  6  8  3  6  7  9  3\n  5  8  3  2  5  9  8  7  9  3  1  8  5  0  5  6  2  6  7  8\n  9  8  2  4  3  1  7  6  3  1  1  4  6  3  0  9  1  5  9  6\n  5  6  7  5  4  5  2  5  8  4  6  8  7  3  1  0  1  1  8  7\n  3  2  5  1  5  8  9  9  4  2  6  1  4  9  8  7  0  1  2  3\n  3  9  5  8  2  1  9  7  6  6  1  7  1  4  3  1  8  0  3  2\n  9  5  6  1  6  7  7  9  6  8  8  6  7  2  2  5  9  8  0  2\n  8  1  3  9  8  1  9  7  3  4  6  7  9  7  1  9  1  7  6  0\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the Google OR-Tools package, which is required for using the CP Solver in the main implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/young_tableaux.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Main Function for Task Allocation Problem in Python\nDESCRIPTION: This snippet defines the main function that checks command-line arguments and calls the task allocation solver. It uses the absl library for argument parsing and error handling.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/task_allocation_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    task_allocation_sat()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Mathematical Optimization Problem Definition\nDESCRIPTION: Mathematical representation of the linear optimization problem format supported by the solver, including constraints and variable definitions. Defines the standard form for optimization problems that can be solved using this system.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/README.md#2025-04-17_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n(P) & \\max & cx\\\\\n    & s.t. & L\\leq Ax\\leq U\\\\\n    &      & l\\leq x\\leq u\\\\\n    &      &x_i\\in\\mathbb{Z}\\quad\\forall i\\in I\n```\n\n----------------------------------------\n\nTITLE: Implementing Search and Solution Display for Set Covering Problem\nDESCRIPTION: This section sets up the search strategy, executes the solver, and displays the results including the total cost and the workers to be hired.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/covering_opl.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n  db = solver.Phase(Hire, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE)\n\n  solver.NewSearch(db, [objective])\n\n  num_solutions = 0\n  while solver.NextSolution():\n    num_solutions += 1\n    print(\"Total cost\", total_cost.Value())\n    print(\"We should hire these workers: \", end=\" \")\n    for w in Workers:\n      if Hire[w].Value() == 1:\n        print(w, end=\" \")\n    print()\n    print()\n\n  solver.EndSearch()\n\n  print()\n  print(\"num_solutions:\", num_solutions)\n  print(\"failures:\", solver.Failures())\n  print(\"branches:\", solver.Branches())\n  print(\"WallTime:\", solver.WallTime())\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Defining Command-Line Arguments using argparse in Python\nDESCRIPTION: This code snippet demonstrates how to use the `argparse` module in Python to define various command-line arguments with specified types, destinations, default values, and help messages. The `parser.add_argument()` method is used to define each argument, including options for the number of matchdays, matches per day, output CSV file, time limit, CPU workers, debug mode, and maximum home stand length.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nparser.add_argument(\n        '--matchdays',\n        type=int,\n        dest='num_matchdays',\n        default=2 * 10 - 2,\n        help=\n        'Number of days on which matches are played.  Default is enough days such that every team can play every other team, or (number of teams - 1)'\n    )\n\n    parser.add_argument(\n        '--matches_per_day',\n        type=int,\n        dest='num_matches_per_day',\n        default=10 - 1,\n        help=\n        'Number of matches played per day.  Default is number of teams divided by 2.  If greater than the number of teams, then this implies some teams will play each other more than once.  In that case, home and away should alternate between the teams in repeated matchups.'\n    )\n\n    parser.add_argument(\n        '--csv',\n        type=str,\n        dest='csv',\n        default='output.csv',\n        help='A file to dump the team assignments.  Default is output.csv')\n\n    parser.add_argument(\n        '--timelimit',\n        type=int,\n        dest='time_limit',\n        default=60,\n        help='Maximum run time for solver, in seconds.  Default is 60 seconds.')\n\n    parser.add_argument(\n        '--cpu',\n        type=int,\n        dest='cpu',\n        help=\n        'Number of workers (CPUs) to use for solver.  Default is 6 or number of CPUs available, whichever is lower'\n    )\n\n    parser.add_argument('--debug',\n                        action='store_true',\n                        help=\"Turn on some print statements.\")\n\n    parser.add_argument(\n        '--max_home_stand',\n        type=int,\n        dest='max_home_stand',\n        default=2,\n        help=\n        \"Maximum consecutive home or away games.  Default to 2, which means three home or away games in a row is forbidden.\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools package required for the set cover implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/algorithms/set_cover.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Solving and Reporting Diet Optimization Results\nDESCRIPTION: Executes solver, prints solution details including total cost, selected food commodities, and solver performance metrics\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stigler_contrib.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsolver.Solve()\n\nprint(\"Cost = %0.2f\" % solver.Objective().Value())\nprint(\"Total cost: %0.2f\" % total_cost.SolutionValue())\n\nfor i in C:\n    if x[i].SolutionValue() > 0:\n        print(\"%-21s %-11s  %0.2f  %0.2f\" %\n              (commodities[i][0], commodities[i][1], x_cost[i].SolutionValue(),\n               quant[i].SolutionValue()))\n```\n\n----------------------------------------\n\nTITLE: Linking OR-Tools Library and Creating Alias Target\nDESCRIPTION: Links the pybind11 module with the OR-Tools library and creates an alias target for consistent naming across the project.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(init_pybind11 PRIVATE ${PROJECT_NAMESPACE}::ortools)\nadd_library(${PROJECT_NAMESPACE}::init_pybind11 ALIAS init_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip. This is necessary to run the optimization code in the notebook.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/steel.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Source Files for OR-Tools Graph Library in CMake\nDESCRIPTION: This snippet gathers source files, excludes test files, and removes specific files from the build. It sets up the library name and creates an object library with position-independent code.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/_.*_test.cc\")\nlist(REMOVE_ITEM _SRCS\n  ${CMAKE_CURRENT_SOURCE_DIR}/shortest_paths_benchmarks.cc\n  ${CMAKE_CURRENT_SOURCE_DIR}/solve_flow_model.cc\n)\n\nset(NAME ${PROJECT_NAME}_graph)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\n```\n\n----------------------------------------\n\nTITLE: Configuring CP-SAT Solver Test for OR-Tools\nDESCRIPTION: Sets up a test target for the CP-SAT (Constraint Programming with Satisfiability) solver implementation in OR-Tools. This test is always included (not conditional) and links against multiple test libraries for various constraint types and features.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nortools_cxx_test(\n  NAME\n    math_opt_solvers_cp_sat_solver_test\n  SOURCES\n    \"cp_sat_solver_test.cc\"\n  LINK_LIBRARIES\n    GTest::gmock\n    GTest::gmock_main\n    absl::status\n    ortools::math_opt_matchers\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_invalid_input_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_model_solve_parameters_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_multiple_solutions_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_parameter_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_mip_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qc_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qp_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_second_order_cone_tests>\"\n    \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Python Time-Based Shift Schedule Sample Data\nDESCRIPTION: Two large arrays containing shift schedule data. Each array element is structured as [ID, start_time, end_time, start_minutes, end_minutes, duration]. Times are in 24-hour format and minutes are calculated from midnight.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nSAMPLE_SHIFTS_LARGE = [\n    [0, \"04:18\", \"05:00\", 258, 300, 42],\n    [1, \"04:27\", \"05:08\", 267, 308, 41],\n    # ... additional entries\n    [135, \"06:18\", \"07:06\", 378, 426, 48]\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for OR-Tools Routing Module in CMake\nDESCRIPTION: Sets SWIG properties for the routing.i file, including C++ mode, module name, compile definitions, and compile options for .NET bindings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(SOURCE routing.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE routing.i PROPERTY SWIG_MODULE_NAME operations_research_constraint_solver)\nset_property(SOURCE routing.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE routing.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.ConstraintSolver\n  -dllimport google-ortools-native)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build for OR-Tools Sample Project\nDESCRIPTION: This CMake script configures a sample project that uses Google OR-Tools library. It sets up minimum CMake version, project details, finds OR-Tools as a dependency, configures an executable with C++17 support, adds testing capability, and defines installation targets.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/samples/cpp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(Sample VERSION 1.0.0 LANGUAGES CXX)\n\ninclude(CTest)\nfind_package(ortools CONFIG REQUIRED)\n\nadd_executable(sample main.cpp)\ntarget_compile_features(sample PUBLIC cxx_std_17)\nset_target_properties(sample PROPERTIES VERSION ${PROJECT_VERSION})\ntarget_link_libraries(sample PRIVATE ortools::ortools)\n\nif(BUILD_TESTING)\n  add_test(NAME sample_UT COMMAND sample)\nendif()\n\ninclude(GNUInstallDirs)\ninstall(TARGETS sample\n  EXPORT SampleTargets\n  DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Basic CMake Integration Example\nDESCRIPTION: Example showing how to integrate OR-Tools into a CMake project using find_package().\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(myproj VERSION 1.0)\n\nfind_package(ortools CONFIG REQUIRED)\n\nadd_executable(myapp main.cpp)\ntarget_link_libraries(myapp ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Samples Build for OR-Tools\nDESCRIPTION: This snippet configures the build process for .NET samples. It uses a glob pattern to find all .cs files and adds them as samples using the add_dotnet_sample function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/samples/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_DOTNET_SAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  foreach(SAMPLE IN LISTS DOTNET_SRCS)\n    add_dotnet_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Optional Model Output to Protobuf File\nDESCRIPTION: Provides an option to write the CP-SAT model to a protobuf file for debugging or analysis when not minimizing drivers, depending on a command-line flag.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nif not minimize_drivers and _OUTPUT_PROTO.value:\n    print(\"Writing proto to %s\" % _OUTPUT_PROTO.value)\n    with open(_OUTPUT_PROTO.value, \"w\") as text_file:\n        text_file.write(str(model))\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package required for constraint programming\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/divisible_by_9_through_1.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Example Builds in CMake for OR-Tools\nDESCRIPTION: Identifies all C++ source files with the .cc extension and adds them as examples to the build system using the add_cxx_example function. This block only executes if the BUILD_CXX_EXAMPLES option is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/contrib/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CXX_EXAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(FILE_NAME IN LISTS CXX_SRCS)\n    add_cxx_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization I/O Library Build in CMake\nDESCRIPTION: Sets up a CMake library target for OR-Tools math optimization I/O component. Configures source files, includes, and dependencies while handling conditional compilation for SCIP integration. Filters out test files and specific directories while maintaining position-independent code requirements.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/io/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_io)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB_RECURSE _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.*_test.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/python/.*\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/lp/matchers\\..*\")\nif(NOT USE_SCIP)\n  list(FILTER _SRCS EXCLUDE REGEX \"/lp_parser.h$\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/lp_parser.cc$\")\nendif()\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  ${PROJECT_NAMESPACE}::math_opt_proto\n  absl::strings\n  $<$<BOOL:${USE_SCIP}>:libscip>\n)\n```\n\n----------------------------------------\n\nTITLE: Regrouping and Counting Items in Python\nDESCRIPTION: Function that groups identical capacities from raw input into a multiset. It counts occurrences of each capacity and returns a sorted list of [size, count] pairs.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef regroup_and_count(raw_input):\n    \"\"\"Regroup all equal capacities in a multiset.\"\"\"\n    grouped = collections.defaultdict(int)\n    for i in raw_input:\n        grouped[i] += 1\n    output = []\n    for size, count in grouped.items():\n        output.append([size, count])\n    output.sort(reverse=False)\n    return output\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nqueens2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Defining Tasks Configuration in Protobuf\nDESCRIPTION: A sequence of task definitions where each task specifies a recipe_id (0 or -1), start_date (ranging from 2 to 44), and duration (ranging from 0 to 30). Tasks with recipe_id -1 appear to be milestone markers with zero duration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/testdata/fdh_scheduling_solution.pb.txt#2025-04-17_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\ntasks {\n  recipe_id: 0\n  start_date: 7\n  duration: 5\n}\ntasks {\n  recipe_id: 0\n  start_date: 5\n  duration: 2\n}\ntasks {\n  recipe_id: 0\n  start_date: 2\n  duration: 1\n}\ntasks {\n  recipe_id: 0\n  duration: 2\n}\ntasks {\n  recipe_id: -1\n  start_date: 15\n  duration: 0\n}\ntasks {\n  recipe_id: 0\n  start_date: 12\n  duration: 3\n}\ntasks {\n  recipe_id: 0\n  start_date: 3\n  duration: 2\n}\ntasks {\n  recipe_id: -1\n  start_date: 8\n  duration: 0\n}\ntasks {\n  recipe_id: 0\n  start_date: 5\n  duration: 3\n}\ntasks {\n  recipe_id: -1\n  start_date: 11\n  duration: 0\n}\ntasks {\n  recipe_id: 0\n  start_date: 8\n  duration: 3\n}\ntasks {\n  recipe_id: 0\n  start_date: 12\n  duration: 2\n}\ntasks {\n  recipe_id: -1\n  start_date: 44\n  duration: 0\n}\ntasks {\n  recipe_id: 0\n  start_date: 14\n  duration: 30\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Python Package\nDESCRIPTION: This command installs the OR-Tools package using pip. OR-Tools is a suite of tools for optimization, including constraint programming and linear programming.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_teams_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Defining Futoshiki Puzzle Examples and Solving\nDESCRIPTION: Defines two Futoshiki puzzle examples with their initial values and inequality constraints. Then calls the main function to solve both puzzles and print the results.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/futoshiki.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#\n# Example from Tailor model futoshiki.param/futoshiki.param\n# Solution:\n# 5 1 3 2 4\n# 1 4 2 5 3\n# 2 3 1 4 5\n# 3 5 4 1 2\n# 4 2 5 3 1\n#\n# Futoshiki instance, by Andras Salamon\n# specify the numbers in the grid\n#\nvalues1 = [[0, 0, 3, 2, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0]]\n\n# [i1,j1, i2,j2] requires that values[i1,j1] < values[i2,j2]\n# Note: 1-based\nlt1 = [[1, 2, 1, 1], [1, 4, 1, 5], [2, 3, 1, 3], [3, 3, 2, 3], [3, 4, 2, 4],\n       [2, 5, 3, 5], [3, 2, 4, 2], [4, 4, 4, 3], [5, 2, 5, 1], [5, 4, 5, 3],\n       [5, 5, 4, 5]]\n\n#\n# Example from http://en.wikipedia.org/wiki/Futoshiki\n# Solution:\n# 5 4 3 2 1\n# 4 3 1 5 2\n# 2 1 4 3 5\n# 3 5 2 1 4\n# 1 2 5 4 3\n#\nvalues2 = [[0, 0, 0, 0, 0], [4, 0, 0, 0, 2], [0, 0, 4, 0, 0], [0, 0, 0, 0, 4],\n           [0, 0, 0, 0, 0]]\n\n# Note: 1-based\nlt2 = [[1, 2, 1, 1], [1, 4, 1, 3], [1, 5, 1, 4], [4, 4, 4, 5], [5, 1, 5, 2],\n       [5, 2, 5, 3]]\n\nprint(\"Problem 1\")\nmain(values1, lt1)\nprint(\"\\nProblem 2\")\nmain(values2, lt2)\n```\n\n----------------------------------------\n\nTITLE: Defining Skills Constants for Bakery Scheduling in Python\nDESCRIPTION: Defines constants for different skill types used in bakery operations. These constants represent the various operations that can be performed by workers and machines in the bakery workflow.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Skills\nBAKING = \"baking\"\nPROOFING = \"proofing\"\nCOOKING = \"cooking\"\nCOOLING = \"cooling\"\nDECORATING = \"decorating\"\nDISPLAY = \"display\"\n```\n\n----------------------------------------\n\nTITLE: Manhattan Distance Calculator\nDESCRIPTION: Computes the Manhattan distance between two points in a 2D space by summing the absolute differences of coordinates.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrp_reload.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef manhattan_distance(position_1, position_2):\n    \"\"\"Computes the Manhattan distance between two points\"\"\"\n    return abs(position_1[0] - position_2[0]) + abs(position_1[1] - position_2[1])\n```\n\n----------------------------------------\n\nTITLE: Setting Build Options for Components\nDESCRIPTION: Configures build options for various components including language bindings (Python, Java, .NET), samples, examples, and documentation. Uses CMake dependent options to manage build dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\noption(BUILD_CXX \"Build C++ library\" ON)\noption(BUILD_PYTHON \"Build Python Library\" OFF)\noption(BUILD_JAVA \"Build Java Library\" OFF)\noption(BUILD_DOTNET \"Build .NET Library\" OFF)\n\nCMAKE_DEPENDENT_OPTION(BUILD_FLATZINC \"Build flatzinc\" ON \"BUILD_CXX\" OFF)\nCMAKE_DEPENDENT_OPTION(BUILD_LP_PARSER \"Build lp_parser\" ON \"BUILD_CXX\" OFF)\nCMAKE_DEPENDENT_OPTION(BUILD_MATH_OPT \"Build the MATH_OPT\" ON \"BUILD_CXX\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Prize Collecting TSP\nDESCRIPTION: Importing the necessary modules from OR-Tools and Python's typing module to solve the Prize Collecting TSP problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n```\n\n----------------------------------------\n\nTITLE: Main Function with Argument Handling\nDESCRIPTION: Entry point function that handles command-line arguments and calls the clustering implementation. Includes basic error checking for argument count.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    clustering_sat()\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Library for OR-Tools .NET Init\nDESCRIPTION: Configures SWIG to generate a library for the initialization module, specifying C# as the target language and setting the output directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(dotnet_init\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/init\n  SOURCES init.i)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code snippet installs the OR-Tools package using pip. It's a prerequisite for running the CP-SAT solver example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solve_with_time_limit_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring CoinUtils Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build CoinUtils library. It specifies the git repository, version tag, and applies a patch. This is conditionally executed if BUILD_CoinUtils is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CoinUtils)\n  message(CHECK_START \"Fetching CoinUtils\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    CoinUtils\n    GIT_REPOSITORY \"https://github.com/Mizux/CoinUtils.git\"\n    GIT_TAG \"cmake/2.11.12\"\n    GIT_SHALLOW TRUE\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/coinutils-2.11.patch\")\n  FetchContent_MakeAvailable(CoinUtils)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Library Target for Math Opt Quadratic Constraints\nDESCRIPTION: Sets up a CMake object library target for quadratic constraints, configures source files, and sets include directories and linking options. Includes test configuration when BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/quadratic/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_constraints_quadratic)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*_test.cc\")\n\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        math_opt_constraints_quadratic_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        #benchmark::benchmark\n        GTest::gmock\n        GTest::gtest_main\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring LP Data Library Build in CMake\nDESCRIPTION: CMake configuration that sets up the LP data library build. It collects source files, configures an object library with position independent code, and sets up include directories and dependencies including Abseil, Protobuf, and RE2.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/lp_data/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_lp_data)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::synchronization\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${RE2_DEPS}\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::lp_data ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Configuring pywraplp Target Properties\nDESCRIPTION: Sets include directories, compile definitions, and platform-specific properties for the pywraplp target. Handles different requirements for macOS, Unix, and Windows platforms.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(pywraplp PRIVATE ${Python3_INCLUDE_DIRS})\nset_property(TARGET pywraplp PROPERTY SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON)\ntarget_compile_definitions(pywraplp PUBLIC \"PY3\")\n\nif(APPLE)\n  set_target_properties(pywraplp PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../${PROJECT_NAME}/.libs\")\n  target_link_options(pywraplp PRIVATE \"LINKER:-undefined,dynamic_lookup\")\nelseif(UNIX)\n  set_target_properties(pywraplp PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../${PROJECT_NAME}/.libs\")\nendif()\ntarget_link_libraries(pywraplp PRIVATE ortools::ortools)\n\nif(MSVC)\n  target_link_libraries(pywraplp PRIVATE ${Python3_LIBRARIES})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring HiGHS Solver Test for OR-Tools\nDESCRIPTION: Sets up a test target for the HiGHS solver implementation with conditional compilation based on HiGHS availability. Some test libraries are commented out, indicating features not fully supported by the HiGHS integration such as logical constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_HIGHS)\n  ortools_cxx_test(\n    NAME\n      math_opt_solvers_highs_solver_test\n    SOURCES\n      \"highs_solver_test.cc\"\n    LINK_LIBRARIES\n      GTest::gmock\n      GTest::gmock_main\n      absl::status\n      ortools::math_opt_matchers\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_parameter_tests>\"\n      #\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n      #\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_incomplete_solve_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_parameter_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_mip_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Reading Survo Puzzle from File\nDESCRIPTION: Defines a function to read a Survo puzzle instance from a file. It parses the file contents to extract puzzle dimensions, row and column sums, and initial game state.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/survo_puzzle.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef read_problem(file):\n  f = open(file, \"r\")\n  r = int(f.readline())\n  c = int(f.readline())\n  rowsums = f.readline()\n  colsums = f.readline()\n  rowsums = [int(t) for t in (rowsums.rstrip()).split(\",\")]\n  colsums = [int(t) for t in (colsums.rstrip()).split(\",\")]\n  game = []\n  for i in range(r):\n    x = f.readline()\n    x = [int(t) for t in (x.rstrip()).split(\",\")]\n    row = [0] * c\n    for j in range(c):\n      row[j] = int(x[j])\n    game.append(row)\n  return [r, c, rowsums, colsums, game]\n```\n\n----------------------------------------\n\nTITLE: Source File Globbing for GSCIP Library in CMake\nDESCRIPTION: Collects all header and source files in the current directory for the GSCIP library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/gscip/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools Math Optimization Test Libraries with CMake\nDESCRIPTION: Defines multiple C++ test libraries using the ortools_cxx_library macro. Each library is configured with specific source files, dependencies, and test requirements. Libraries cover various testing aspects including base solver tests, callback tests, status tests, LP tests, MIP tests, and more.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solver_tests/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(_PREFIX math_opt)\n\nortools_cxx_library(\n  NAME\n    ${_PREFIX}_base_solver_test\n  SOURCES\n    \"base_solver_test.cc\"\n    \"base_solver_test.h\"\n  TYPE\n    STATIC\n  LINK_LIBRARIES\n    GTest::gmock\n    absl::log\n  TESTING\n)\n\nortools_cxx_library(\n  NAME\n    ${_PREFIX}_callback_tests\n  SOURCES\n    \"callback_tests.cc\"\n    \"callback_tests.h\"\n  TYPE\n    STATIC\n  LINK_LIBRARIES\n    GTest::gmock\n    absl::log\n    absl::status\n    absl::strings\n    ortools::math_opt_matchers\n    ortools::math_opt_base_solver_test\n    ortools::math_opt_test_models\n  TESTING\n)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the ortools package from PyPI, which is necessary for running the optimization routines in the following Python scripts. This command should be executed in a Jupyter notebook cell.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_groups_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Model Builder .NET Bindings with SWIG\nDESCRIPTION: Sets up SWIG properties and creates a library for the model builder component. Configures C++ support, module naming, compilation definitions, and namespace options for .NET integration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE model_builder.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE model_builder.i PROPERTY SWIG_MODULE_NAME operations_research_model_builder)\nset_property(SOURCE model_builder.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE model_builder.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.ModelBuilder\n  -dllimport google-ortools-native)\nswig_add_library(dotnet_model_builder\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/model_builder\n  SOURCES model_builder.i)\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Python Module for Linear Solver\nDESCRIPTION: Sets up SWIG configuration for generating Python bindings for the linear solver module. Configures module name, compile definitions and builds the pywraplp library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE linear_solver.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE linear_solver.i PROPERTY SWIG_MODULE_NAME pywraplp)\nset_property(SOURCE linear_solver.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nswig_add_library(pywraplp\n  TYPE MODULE\n  LANGUAGE python\n  OUTPUT_DIR ${PYTHON_PROJECT_DIR}/linear_solver\n  SOURCES linear_solver.i)\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Intervals in C++ using OR-Tools\nDESCRIPTION: Shows implementation of optional interval variables in C++ using OR-Tools. Demonstrates creating intervals with variable size and fixed size, including logging of interval properties.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid OptionalIntervalSampleSat() {\n  CpModelBuilder cp_model;\n  const int kHorizon = 100;\n  const Domain horizon(0, kHorizon);\n  const IntVar x = cp_model.NewIntVar(horizon).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar({2, 4}).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(horizon).WithName(\"z\");\n  const BoolVar presence_var = cp_model.NewBoolVar().WithName(\"presence\");\n  const IntervalVar interval_var =\n      cp_model.NewOptionalIntervalVar(x, y, z + 2, presence_var)\n          .WithName(\"interval\");\n  const IntervalVar fixed_size_interval_var =\n      cp_model.NewOptionalFixedSizeIntervalVar(x, 10, presence_var)\n          .WithName(\"fixed_size_interval_var\");\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::OptionalIntervalSampleSat();\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Variables and Literals in Java\nDESCRIPTION: Demonstrates how to create a boolean variable and its negation (literal) in Java using the CP-SAT solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.BoolVar;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.Literal;\n\n/** Code sample to demonstrate Boolean variable and literals. */\npublic class LiteralSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    CpModel model = new CpModel();\n    BoolVar x = model.newBoolVar(\"x\");\n    Literal notX = x.not();\n    System.out.println(notX);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Python pip command to install the Google OR-Tools package required for constraint programming.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular_table2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Running OR-Tools tests with C++17 on UNIX using Bazel\nDESCRIPTION: Command to run OR-Tools tests on UNIX systems using Bazel with C++17 support. This command executes all tests with optimization enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nbazel test -c opt --cxxopt=-std=c++17 ...\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the required OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/fill_a_pix.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Executing RCPSP Solver Main Function in Python\nDESCRIPTION: Call to the main function that executes the RCPSP solver with the configured parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmain()\n```\n\n----------------------------------------\n\nTITLE: Building Vehicle Route Function Signature\nDESCRIPTION: A function declaration for building a vehicle route by traversing from start to end node. This appears to be a utility for extracting route information from the OR-Tools solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ndef build_vehicle_route(manager, routing, plan, customers, veh_number):\n    \"\"\"\n    Build a route for a vehicle by starting at the strat node and\n    continuing to the end node.\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Time-based Trip or Event Data Array in JSON Format\nDESCRIPTION: A large array containing trip or event data with ID numbers, start/end times in HH:MM format, corresponding numeric time values, and duration values. Each row represents a single trip or event with consistent formatting. The data appears to span from 18:28 to 23:54 with durations ranging from 10 to 84 time units.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\n    [1090, \"18:28\", \"19:15\", 1108, 1155, 47],\n    [1091, \"18:29\", \"19:23\", 1109, 1163, 54],\n    [1092, \"18:30\", \"19:05\", 1110, 1145, 35],\n    [1093, \"18:30\", \"18:40\", 1110, 1120, 10],\n    [1094, \"18:31\", \"18:43\", 1111, 1123, 12],\n    [1095, \"18:33\", \"19:15\", 1113, 1155, 42],\n    [1096, \"18:34\", \"19:58\", 1114, 1198, 84],\n    [1097, \"18:34\", \"19:14\", 1114, 1154, 40],\n    [1098, \"18:35\", \"18:55\", 1115, 1135, 20],\n    [1099, \"18:36\", \"19:20\", 1116, 1160, 44],\n    [1100, \"18:38\", \"19:25\", 1118, 1165, 47],\n    [1101, \"18:38\", \"19:23\", 1118, 1163, 45],\n    [1102, \"18:38\", \"19:56\", 1118, 1196, 78],\n    [1103, \"18:39\", \"19:33\", 1119, 1173, 54],\n    [1104, \"18:40\", \"18:50\", 1120, 1130, 10],\n    [1105, \"18:40\", \"19:45\", 1120, 1185, 65],\n    [1106, \"18:40\", \"18:56\", 1120, 1136, 16],\n    [1107, \"18:43\", \"19:10\", 1123, 1150, 27],\n    [1108, \"18:43\", \"19:30\", 1123, 1170, 47],\n    [1109, \"18:44\", \"19:24\", 1124, 1164, 40],\n    [1110, \"18:45\", \"19:05\", 1125, 1145, 20],\n    [1111, \"18:46\", \"18:58\", 1126, 1138, 12],\n    [1112, \"18:48\", \"19:35\", 1128, 1175, 47],\n    [1113, \"18:48\", \"20:12\", 1128, 1212, 84],\n    [1114, \"18:48\", \"20:11\", 1128, 1211, 83],\n    [1115, \"18:48\", \"19:28\", 1128, 1168, 40],\n    [1116, \"18:49\", \"19:43\", 1129, 1183, 54],\n    [1117, \"18:50\", \"19:00\", 1130, 1140, 10],\n    [1118, \"18:51\", \"19:01\", 1131, 1141, 10],\n    [1119, \"18:53\", \"19:35\", 1133, 1175, 42],\n    [1120, \"18:53\", \"19:15\", 1133, 1155, 22],\n    [1121, \"18:53\", \"20:00\", 1133, 1200, 67],\n    [1122, \"18:55\", \"19:15\", 1135, 1155, 20],\n    [1123, \"18:55\", \"19:34\", 1135, 1174, 39],\n    [1124, \"18:58\", \"19:38\", 1138, 1178, 40],\n    [1125, \"18:59\", \"19:53\", 1139, 1193, 54],\n    [1126, \"18:59\", \"19:50\", 1139, 1190, 51],\n    [1127, \"18:59\", \"19:53\", 1139, 1193, 54],\n    [1128, \"19:00\", \"19:16\", 1140, 1156, 16],\n    [1129, \"19:00\", \"19:10\", 1140, 1150, 10],\n    [1130, \"19:00\", \"19:16\", 1140, 1156, 16],\n    [1131, \"19:01\", \"19:13\", 1141, 1153, 12],\n    [1132, \"19:03\", \"20:26\", 1143, 1226, 83],\n    [1133, \"19:03\", \"19:45\", 1143, 1185, 42],\n    [1134, \"19:05\", \"19:44\", 1145, 1184, 39],\n    [1135, \"19:05\", \"19:25\", 1145, 1165, 20],\n    [1136, \"19:08\", \"20:15\", 1148, 1215, 67],\n    [1137, \"19:08\", \"19:35\", 1148, 1175, 27],\n    [1138, \"19:09\", \"19:49\", 1149, 1189, 40],\n    [1139, \"19:09\", \"20:03\", 1149, 1203, 54],\n    [1140, \"19:10\", \"19:20\", 1150, 1160, 10],\n    [1141, \"19:10\", \"19:20\", 1150, 1160, 10],\n    [1142, \"19:11\", \"19:53\", 1151, 1193, 42],\n    [1143, \"19:14\", \"20:26\", 1154, 1226, 72],\n    [1144, \"19:14\", \"19:35\", 1154, 1175, 21],\n    [1145, \"19:14\", \"19:24\", 1154, 1164, 10],\n    [1146, \"19:14\", \"20:05\", 1154, 1205, 51],\n    [1147, \"19:15\", \"19:30\", 1155, 1170, 15],\n    [1148, \"19:15\", \"19:54\", 1155, 1194, 39],\n    [1149, \"19:18\", \"20:39\", 1158, 1239, 81],\n    [1150, \"19:18\", \"20:00\", 1158, 1200, 42],\n    [1151, \"19:19\", \"20:14\", 1159, 1214, 55],\n    [1152, \"19:20\", \"19:30\", 1160, 1170, 10],\n    [1153, \"19:20\", \"19:36\", 1160, 1176, 16],\n    [1154, \"19:21\", \"19:31\", 1161, 1171, 10],\n    [1155, \"19:23\", \"20:30\", 1163, 1230, 67],\n    [1156, \"19:23\", \"19:35\", 1163, 1175, 12],\n    [1157, \"19:24\", \"19:45\", 1164, 1185, 21],\n    [1158, \"19:24\", \"19:45\", 1164, 1185, 21],\n    [1159, \"19:25\", \"20:04\", 1165, 1204, 39],\n    [1160, \"19:26\", \"20:08\", 1166, 1208, 42],\n    [1161, \"19:29\", \"20:02\", 1169, 1202, 33],\n    [1162, \"19:29\", \"20:18\", 1169, 1218, 49],\n    [1163, \"19:29\", \"20:41\", 1169, 1241, 72],\n    [1164, \"19:30\", \"19:40\", 1170, 1180, 10],\n    [1165, \"19:33\", \"20:54\", 1173, 1254, 81],\n    [1166, \"19:33\", \"20:17\", 1173, 1217, 44],\n    [1167, \"19:34\", \"19:55\", 1174, 1195, 21],\n    [1168, \"19:35\", \"20:14\", 1175, 1214, 39],\n    [1169, \"19:38\", \"20:05\", 1178, 1205, 27],\n    [1170, \"19:38\", \"20:45\", 1178, 1245, 67],\n    [1171, \"19:39\", \"20:12\", 1179, 1212, 33],\n    [1172, \"19:40\", \"19:50\", 1180, 1190, 10],\n    [1173, \"19:40\", \"19:56\", 1180, 1196, 16],\n    [1174, \"19:41\", \"20:27\", 1181, 1227, 46],\n    [1175, \"19:43\", \"19:55\", 1183, 1195, 12],\n    [1176, \"19:44\", \"20:05\", 1184, 1205, 21],\n    [1177, \"19:44\", \"20:33\", 1184, 1233, 49],\n    [1178, \"19:44\", \"21:00\", 1184, 1260, 76],\n    [1179, \"19:45\", \"20:24\", 1185, 1224, 39],\n    [1180, \"19:48\", \"20:37\", 1188, 1237, 49],\n    [1181, \"19:48\", \"21:09\", 1188, 1269, 81],\n    [1182, \"19:50\", \"20:00\", 1190, 1200, 10],\n    [1183, \"19:52\", \"20:29\", 1192, 1229, 37],\n    [1184, \"19:53\", \"20:08\", 1193, 1208, 15],\n    [1185, \"19:53\", \"21:02\", 1193, 1262, 69],\n    [1186, \"19:53\", \"20:20\", 1193, 1220, 27],\n    [1187, \"19:54\", \"20:19\", 1194, 1219, 25],\n    [1188, \"19:55\", \"20:34\", 1195, 1234, 39],\n    [1189, \"19:56\", \"20:34\", 1196, 1234, 38],\n    [1190, \"19:59\", \"20:48\", 1199, 1248, 49],\n    [1191, \"19:59\", \"21:20\", 1199, 1280, 81],\n    [1192, \"20:00\", \"20:16\", 1200, 1216, 16],\n    [1193, \"20:00\", \"20:10\", 1200, 1210, 10],\n    [1194, \"20:03\", \"20:42\", 1203, 1242, 39],\n    [1195, \"20:03\", \"21:24\", 1203, 1284, 81],\n    [1196, \"20:04\", \"20:29\", 1204, 1229, 25],\n    [1197, \"20:05\", \"20:48\", 1205, 1248, 43],\n    [1198, \"20:07\", \"20:44\", 1207, 1244, 37],\n    [1199, \"20:08\", \"20:40\", 1208, 1240, 32],\n    [1200, \"20:08\", \"20:35\", 1208, 1235, 27],\n    [1201, \"20:10\", \"20:20\", 1210, 1220, 10],\n    [1202, \"20:10\", \"20:22\", 1210, 1222, 12],\n    [1203, \"20:11\", \"20:47\", 1211, 1247, 36],\n    [1204, \"20:14\", \"21:04\", 1214, 1264, 50],\n    [1205, \"20:14\", \"21:03\", 1214, 1263, 49],\n    [1206, \"20:17\", \"21:03\", 1217, 1263, 46],\n    [1207, \"20:18\", \"21:39\", 1218, 1299, 81],\n    [1208, \"20:20\", \"20:30\", 1220, 1230, 10],\n    [1209, \"20:20\", \"20:57\", 1220, 1257, 37],\n    [1210, \"20:20\", \"20:36\", 1220, 1236, 16],\n    [1211, \"20:22\", \"20:59\", 1222, 1259, 37],\n    [1212, \"20:22\", \"20:42\", 1222, 1242, 20],\n    [1213, \"20:24\", \"20:49\", 1224, 1249, 25],\n    [1214, \"20:27\", \"21:22\", 1227, 1282, 55],\n    [1215, \"20:29\", \"21:18\", 1229, 1278, 49],\n    [1216, \"20:30\", \"21:07\", 1230, 1267, 37],\n    [1217, \"20:30\", \"20:40\", 1230, 1240, 10],\n    [1218, \"20:30\", \"20:40\", 1230, 1240, 10],\n    [1219, \"20:30\", \"21:40\", 1230, 1300, 70],\n    [1220, \"20:32\", \"21:18\", 1232, 1278, 46],\n    [1221, \"20:35\", \"21:54\", 1235, 1314, 79],\n    [1222, \"20:37\", \"21:14\", 1237, 1274, 37],\n    [1223, \"20:38\", \"21:08\", 1238, 1268, 30],\n    [1224, \"20:40\", \"20:50\", 1240, 1250, 10],\n    [1225, \"20:40\", \"21:17\", 1240, 1277, 37],\n    [1226, \"20:40\", \"20:56\", 1240, 1256, 16],\n    [1227, \"20:44\", \"21:33\", 1244, 1293, 49],\n    [1228, \"20:47\", \"21:33\", 1247, 1293, 46],\n    [1229, \"20:47\", \"21:42\", 1247, 1302, 55],\n    [1230, \"20:50\", \"21:00\", 1250, 1260, 10],\n    [1231, \"20:50\", \"22:00\", 1250, 1320, 70],\n    [1232, \"20:50\", \"22:09\", 1250, 1329, 79],\n    [1233, \"20:50\", \"21:27\", 1250, 1287, 37],\n    [1234, \"20:52\", \"21:29\", 1252, 1289, 37],\n    [1235, \"20:53\", \"21:20\", 1253, 1280, 27],\n    [1236, \"20:56\", \"21:11\", 1256, 1271, 15],\n    [1237, \"20:59\", \"21:48\", 1259, 1308, 49],\n    [1238, \"21:00\", \"21:10\", 1260, 1270, 10],\n    [1239, \"21:00\", \"21:37\", 1260, 1297, 37],\n    [1240, \"21:02\", \"21:48\", 1262, 1308, 46],\n    [1241, \"21:05\", \"22:24\", 1265, 1344, 79],\n    [1242, \"21:07\", \"21:44\", 1267, 1304, 37],\n    [1243, \"21:07\", \"22:02\", 1267, 1322, 55],\n    [1244, \"21:08\", \"21:38\", 1268, 1298, 30],\n    [1245, \"21:10\", \"22:25\", 1270, 1345, 75],\n    [1246, \"21:10\", \"21:20\", 1270, 1280, 10],\n    [1247, \"21:10\", \"21:47\", 1270, 1307, 37],\n    [1248, \"21:14\", \"22:03\", 1274, 1323, 49],\n    [1249, \"21:17\", \"22:03\", 1277, 1323, 46],\n    [1250, \"21:20\", \"22:18\", 1280, 1338, 58],\n    [1251, \"21:20\", \"21:57\", 1280, 1317, 37],\n    [1252, \"21:20\", \"21:30\", 1280, 1290, 10],\n    [1253, \"21:22\", \"21:59\", 1282, 1319, 37],\n    [1254, \"21:24\", \"21:49\", 1284, 1309, 25],\n    [1255, \"21:27\", \"22:21\", 1287, 1341, 54],\n    [1256, \"21:30\", \"22:07\", 1290, 1327, 37],\n    [1257, \"21:30\", \"22:20\", 1290, 1340, 50],\n    [1258, \"21:30\", \"21:40\", 1290, 1300, 10],\n    [1259, \"21:32\", \"22:18\", 1292, 1338, 46],\n    [1260, \"21:32\", \"22:01\", 1292, 1321, 29],\n    [1261, \"21:35\", \"22:54\", 1295, 1374, 79],\n    [1262, \"21:37\", \"22:14\", 1297, 1334, 37],\n    [1263, \"21:39\", \"21:55\", 1299, 1315, 16],\n    [1264, \"21:40\", \"22:17\", 1300, 1337, 37],\n    [1265, \"21:40\", \"21:50\", 1300, 1310, 10],\n    [1266, \"21:41\", \"22:08\", 1301, 1328, 27],\n    [1267, \"21:47\", \"22:16\", 1307, 1336, 29],\n    [1268, \"21:47\", \"22:51\", 1307, 1371, 64],\n    [1269, \"21:47\", \"22:33\", 1307, 1353, 46],\n    [1270, \"21:48\", \"22:03\", 1308, 1323, 15],\n    [1271, \"21:50\", \"22:55\", 1310, 1375, 65],\n    [1272, \"21:50\", \"22:27\", 1310, 1347, 37],\n    [1273, \"21:50\", \"22:00\", 1310, 1320, 10],\n    [1274, \"21:52\", \"22:29\", 1312, 1349, 37],\n    [1275, \"21:53\", \"22:19\", 1313, 1339, 26],\n    [1276, \"22:00\", \"22:38\", 1320, 1358, 38],\n    [1277, \"22:00\", \"22:10\", 1320, 1330, 10],\n    [1278, \"22:02\", \"22:12\", 1322, 1332, 10],\n    [1279, \"22:02\", \"22:48\", 1322, 1368, 46],\n    [1280, \"22:04\", \"22:31\", 1324, 1351, 27],\n    [1281, \"22:05\", \"23:24\", 1325, 1404, 79],\n    [1282, \"22:07\", \"22:44\", 1327, 1364, 37],\n    [1283, \"22:07\", \"22:39\", 1327, 1359, 32],\n    [1284, \"22:09\", \"22:25\", 1329, 1345, 16],\n    [1285, \"22:10\", \"23:25\", 1330, 1405, 75],\n    [1286, \"22:13\", \"22:38\", 1333, 1358, 25],\n    [1287, \"22:13\", \"22:53\", 1333, 1373, 40],\n    [1288, \"22:17\", \"22:27\", 1337, 1347, 10],\n    [1289, \"22:17\", \"23:03\", 1337, 1383, 46],\n    [1290, \"22:19\", \"22:46\", 1339, 1366, 27],\n    [1291, \"22:22\", \"22:59\", 1342, 1379, 37],\n    [1292, \"22:24\", \"22:48\", 1344, 1368, 24],\n    [1293, \"22:27\", \"22:52\", 1347, 1372, 25],\n    [1294, \"22:27\", \"23:21\", 1347, 1401, 54],\n    [1295, \"22:28\", \"23:08\", 1348, 1388, 40],\n    [1296, \"22:30\", \"23:17\", 1350, 1397, 47],\n    [1297, \"22:32\", \"22:42\", 1352, 1362, 10],\n    [1298, \"22:32\", \"23:11\", 1352, 1391, 39],\n    [1299, \"22:34\", \"23:01\", 1354, 1381, 27],\n    [1300, \"22:35\", \"23:54\", 1355, 1434, 79],\n    [1301, \"22:37\", \"23:14\", 1357, 1394, 37],\n    [1302, \"22:43\", \"23:23\", 1363, 1403, 40],\n    [1303, \"22:43\", \"23:08\", 1363, 1388, 25],\n    [1304, \"22:47\", \"23:33\", 1367, 1413, 46],\n    [1305, \"22:47\", \"22:57\", 1367, 1377, 10],\n    [1306, \"22:49\", \"23:16\", 1369, 1396, 27]\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Knapsack Solver Python Module with CMake\nDESCRIPTION: Sets up a pybind11 module for the knapsack solver, configuring output name, install paths, and linking against OR-Tools library. Includes platform-specific settings for macOS and Unix systems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(knapsack_solver_pybind11 MODULE knapsack_solver.cc)\nset_target_properties(knapsack_solver_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"knapsack_solver\")\n\n# note: macOS is APPLE and also UNIX !\nif(APPLE)\n  set_target_properties(knapsack_solver_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\"\n    )\nelseif(UNIX)\n  set_target_properties(knapsack_solver_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\"\n    )\nendif()\n\ntarget_link_libraries(knapsack_solver_pybind11 PRIVATE ${PROJECT_NAMESPACE}::ortools)\nadd_library(${PROJECT_NAMESPACE}::knapsack_solver_pybind11 ALIAS knapsack_solver_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Printing Installation Type Details\nDESCRIPTION: Outputs formatted information about planned installations, including the type and number of installations\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/appointments.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"   {per_type} installations of type {name} planned\")\n```\n\n----------------------------------------\n\nTITLE: Configuring pybind11 Module for OR-Tools Python Bindings\nDESCRIPTION: Creates and configures a pybind11 module for Python bindings. Sets the library output name and platform-specific properties including install paths and runtime search paths (RPATH).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\npybind11_add_module(init_pybind11 MODULE init.cc)\nset_target_properties(init_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"init\")\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the OR-Tools package using pip, which is required for running the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/stop_after_n_solutions_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Linking Python Libraries for Windows in CMake\nDESCRIPTION: Links Python libraries specifically for Windows (MSVC) builds of the pywrapcp target.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/python/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(MSVC)\n  target_link_libraries(pywrapcp PRIVATE ${Python3_LIBRARIES})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Vector Bin Packing Executable Build\nDESCRIPTION: Creates and configures the vector bin packing executable target with C++17 support. Sets up include directories and links against the OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/packing/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(vector_bin_packing)\ntarget_sources(vector_bin_packing PRIVATE \"vector_bin_packing_main.cc\")\ntarget_include_directories(vector_bin_packing PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\ntarget_compile_features(vector_bin_packing PRIVATE cxx_std_17)\ntarget_link_libraries(vector_bin_packing PRIVATE ${PROJECT_NAMESPACE}::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools SAT Module Tests in CMake\nDESCRIPTION: Sets up test builds for the SAT module when BUILD_TESTING is enabled. For each test source file, it creates a test target with the appropriate dependencies including Google Test and benchmark libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        sat_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        benchmark::benchmark\n        GTest::gmock\n        GTest::gtest_main\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building and Installing GLOP Simple Program\nDESCRIPTION: Configures the build and installation of the simple_glop_program executable, including setting include directories, compiler features, and linking with the GLOP library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/glop/samples/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(simple_glop_program simple_glop_program.cc)\n  target_include_directories(simple_glop_program PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\n  target_compile_features(simple_glop_program PRIVATE cxx_std_17)\n  target_link_libraries(simple_glop_program PRIVATE glop)\n\n  install(TARGETS simple_glop_program)\n\n  if(BUILD_TESTING)\n    add_test(NAME cxx_simple_glop_program COMMAND simple_glop_program)\n  endif()\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Setting Up Solver for Set Covering Problem\nDESCRIPTION: This snippet imports the necessary module from OR-Tools and initializes the CP solver for the set covering problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/covering_opl.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef main():\n\n  # Create the solver.\n  solver = pywrapcp.Solver(\"Set covering\")\n```\n\n----------------------------------------\n\nTITLE: Schedule Data Array in CSV Format\nDESCRIPTION: A structured dataset containing schedule entries organized as arrays with 6 columns: ID, start time (HH:MM), end time (HH:MM), start minute (from midnight), end minute (from midnight), and duration in minutes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: csv\nCODE:\n```\n    [636, \"12:40\", \"12:50\", 760, 770, 10],\n    [637, \"12:40\", \"12:56\", 760, 776, 16],\n    [638, \"12:41\", \"13:08\", 761, 788, 27],\n    [639, \"12:43\", \"13:30\", 763, 810, 47],\n    [640, \"12:44\", \"12:55\", 764, 775, 11],\n    ...\n    [867, \"15:35\", \"15:54\", 935, 954, 19]\n```\n\n----------------------------------------\n\nTITLE: SWIG C# typemaps for int64_t compatibility on Linux\nDESCRIPTION: SWIG code to provide correct typemaps for 64-bit integers in C# bindings on Linux. This ensures proper mapping between C++ and C# types across different platforms.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_6\n\nLANGUAGE: swig\nCODE:\n```\n#if defined(SWIGCSHARP)\n#if defined(SWIGWORDSIZE64)\n%define PRIMITIVE_TYPEMAP(NEW_TYPE, TYPE)\n%clear NEW_TYPE;\n%clear NEW_TYPE *;\n%clear NEW_TYPE &;\n%clear const NEW_TYPE &;\n%apply TYPE { NEW_TYPE };\n%apply TYPE * { NEW_TYPE * };\n%apply TYPE & { NEW_TYPE & };\n%apply const TYPE & { const NEW_TYPE & };\n%enddef // PRIMITIVE_TYPEMAP\nPRIMITIVE_TYPEMAP(long int, long long);\nPRIMITIVE_TYPEMAP(unsigned long int, unsigned long long);\n#undef PRIMITIVE_TYPEMAP\n#endif // defined(SWIGWORDSIZE64)\n#endif // defined(SWIGCSHARP)\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Validators Library in CMake\nDESCRIPTION: Sets up a CMake object library for math optimization validators. Configures source files, include directories, and links required dependencies like abseil strings and math optimization protobuf libraries. Ensures position-independent code compilation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/validators/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_validators)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Defining Distance Matrix for VRP Problem\nDESCRIPTION: Declaration of a distance matrix that defines the distances between different locations in the vehicle routing problem. This matrix is used as input data for the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDISTANCE_MATRIX = [\n    # fmt:off\n    [0, 10938, 4542, 2835, 29441, 2171, 1611, 9208, 9528, 11111, 16120, 22606, 22127, 20627, 21246, 23387, 16697, 33609, 26184, 24772, 22644, 20655, 30492, 23296, 32979, 18141, 19248, 17129, 17192, 15645, 12658, 11210, 12094, 13175, 18162, 4968, 12308, 10084, 13026, 15056],\n    [10938, 0, 6422, 9742, 18988, 12974, 11216, 19715, 19004, 18271, 25070, 31971, 31632, 30571, 31578, 33841, 27315, 43964, 36944, 35689, 33569, 31481, 41360, 33760, 43631, 28730, 29976, 27803, 28076, 26408, 23504, 22025, 22000, 13197, 14936, 15146, 23246, 20956, 23963, 25994],\n    [4542, 6422, 0, 3644, 25173, 6552, 5092, 13584, 13372, 13766, 19805, 26537, 26117, 24804, 25590, 27784, 21148, 37981, 30693, 29315, 27148, 25071, 34943, 27472, 37281, 22389, 23592, 21433, 21655, 20011, 17087, 15612, 15872, 11653, 15666, 8842, 16843, 14618, 17563, 19589],\n    [2835, 9742, 3644, 0, 28681, 3851, 4341, 11660, 12294, 13912, 18893, 25283, 24777, 23173, 23636, 25696, 18950, 35927, 28233, 26543, 24127, 21864, 31765, 24018, 33904, 19005, 20295, 18105, 18551, 16763, 13958, 12459, 12296, 10370, 15331, 5430, 14044, 12135, 14771, 16743],\n    [29441, 18988, 25173, 28681, 0, 31590, 29265, 37173, 35501, 32929, 40239, 47006, 46892, 46542, 48112, 50506, 44539, 60103, 54208, 53557, 51878, 50074, 59849, 52645, 62415, 47544, 48689, 46560, 46567, 45086, 42083, 40648, 40971, 29929, 28493, 34015, 41473, 38935, 42160, 44198],\n    [2171, 12974, 6552, 3851, 31590, 0, 3046, 7856, 8864, 11330, 15411, 21597, 21065, 19382, 19791, 21845, 15099, 32076, 24425, 22848, 20600, 18537, 28396, 21125, 30825, 15975, 17101, 14971, 15104, 13503, 10544, 9080, 9983, 13435, 18755, 2947, 10344, 8306, 11069, 13078],\n    [1611, 11216, 5092, 4341, 29265, 3046, 0, 8526, 8368, 9573, 14904, 21529, 21085, 19719, 20504, 22713, 16118, 32898, 25728, 24541, 22631, 20839, 30584, 23755, 33278, 18557, 19545, 17490, 17309, 15936, 12881, 11498, 12944, 14711, 19589, 5993, 12227, 9793, 12925, 14967],\n    [9208, 19715, 13584, 11660, 37173, 7856, 8526, 0, 3248, 7855, 8245, 13843, 13272, 11526, 12038, 14201, 7599, 24411, 17259, 16387, 15050, 13999, 23134, 17899, 26460, 12894, 13251, 11680, 10455, 9997, 7194, 6574, 10678, 20959, 26458, 8180, 5255, 2615, 5730, 7552],\n    [9528, 19004, 13372, 12294, 35501, 8864, 8368, 3248, 0, 4626, 6598, 13168, 12746, 11567, 12731, 15083, 9120, 25037, 18718, 18433, 17590, 16888, 25630, 20976, 29208, 16055, 16300, 14838, 13422, 13165, 10430, 9813, 13777, 22300, 27564, 10126, 8388, 5850, 8778, 10422],\n    [11111, 18271, 13766, 13912, 32929, 11330, 9573, 7855, 4626, 0, 7318, 14185, 14005, 13655, 15438, 17849, 12839, 27179, 21947, 22230, 21814, 21366, 29754, 25555, 33535, 20674, 20872, 19457, 17961, 17787, 15048, 14372, 18115, 24280, 29101, 13400, 13008, 10467, 13375, 14935],\n    [16120, 25070, 19805, 18893, 40239, 15411, 14904, 8245, 6598, 7318, 0, 6939, 6702, 6498, 8610, 10961, 7744, 19889, 15350, 16403, 16975, 17517, 24357, 22176, 28627, 18093, 17672, 16955, 14735, 15510, 13694, 13768, 18317, 28831, 34148, 16326, 11276, 9918, 11235, 11891],\n    [22606, 31971, 26537, 25283, 47006, 21597, 21529, 13843, 13168, 14185, 6939, 0, 793, 3401, 5562, 6839, 8923, 13433, 11264, 13775, 15853, 17629, 21684, 22315, 26411, 19539, 18517, 18636, 16024, 17632, 16948, 17587, 22131, 34799, 40296, 21953, 14739, 14568, 14366, 14002],\n    [22127, 31632, 26117, 24777, 46892, 21065, 21085, 13272, 12746, 14005, 6702, 793, 0, 2608, 4809, 6215, 8151, 13376, 10702, 13094, 15099, 16845, 21039, 21535, 25744, 18746, 17725, 17845, 15232, 16848, 16197, 16859, 21391, 34211, 39731, 21345, 14006, 13907, 13621, 13225],\n    [20627, 30571, 24804, 23173, 46542, 19382, 19719, 11526, 11567, 13655, 6498, 3401, 2608, 0, 2556, 4611, 5630, 13586, 9157, 11005, 12681, 14285, 19044, 18996, 23644, 16138, 15126, 15240, 12625, 14264, 13736, 14482, 18958, 32292, 37879, 19391, 11621, 11803, 11188, 10671],\n    [21246, 31578, 25590, 23636, 48112, 19791, 20504, 12038, 12731, 15438, 8610, 5562, 4809, 2556, 0, 2411, 4917, 12395, 6757, 8451, 10292, 12158, 16488, 16799, 21097, 14374, 13194, 13590, 10943, 12824, 12815, 13779, 18042, 32259, 37918, 19416, 10975, 11750, 10424, 9475],\n    [23387, 33841, 27784, 25696, 50506, 21845, 22713, 14201, 15083, 17849, 10961, 6839, 6215, 4611, 2411, 0, 6760, 10232, 4567, 7010, 9607, 12003, 14846, 16408, 19592, 14727, 13336, 14109, 11507, 13611, 14104, 15222, 19237, 34013, 39703, 21271, 12528, 13657, 11907, 10633],\n    [16697, 27315, 21148, 18950, 44539, 15099, 16118, 7599, 9120, 12839, 7744, 8923, 8151, 5630, 4917, 6760, 0, 16982, 9699, 9400, 9302, 9823, 16998, 14534, 21042, 10911, 10190, 9900, 7397, 8758, 8119, 8948, 13353, 27354, 33023, 14542, 6106, 6901, 5609, 5084],\n    [33609, 43964, 37981, 35927, 60103, 32076, 32898, 24411, 25037, 27179, 19889, 13433, 13376, 13586, 12395, 10232, 16982, 0, 8843, 12398, 16193, 19383, 16423, 22583, 20997, 22888, 21194, 22640, 20334, 22636, 23801, 25065, 28675, 44048, 49756, 31426, 22528, 23862, 21861, 20315],\n    [26184, 36944, 30693, 28233, 54208, 24425, 25728, 17259, 18718, 21947, 15350, 11264, 10702, 9157, 6757, 4567, 9699, 8843, 0, 3842, 7518, 10616, 10666, 14237, 15515, 14053, 12378, 13798, 11537, 13852, 15276, 16632, 19957, 35660, 41373, 23361, 14333, 16125, 13624, 11866],\n    [24772, 35689, 29315, 26543, 53557, 22848, 24541, 16387, 18433, 22230, 16403, 13775, 13094, 11005, 8451, 7010, 9400, 12398, 3842, 0, 3795, 7014, 8053, 10398, 12657, 10633, 8889, 10569, 8646, 10938, 12906, 14366, 17106, 33171, 38858, 21390, 12507, 14748, 11781, 9802],\n    [22644, 33569, 27148, 24127, 51878, 20600, 22631, 15050, 17590, 21814, 16975, 15853, 15099, 12681, 10292, 9607, 9302, 16193, 7518, 3795, 0, 3250, 8084, 6873, 11763, 6949, 5177, 7050, 5619, 7730, 10187, 11689, 13792, 30012, 35654, 18799, 10406, 12981, 9718, 7682],\n    [20655, 31481, 25071, 21864, 50074, 18537, 20839, 13999, 16888, 21366, 17517, 17629, 16845, 14285, 12158, 12003, 9823, 19383, 10616, 7014, 3250, 0, 9901, 4746, 12531, 3737, 1961, 4036, 3588, 5109, 7996, 9459, 10846, 27094, 32690, 16451, 8887, 11624, 8304, 6471],\n    [30492, 41360, 34943, 31765, 59849, 28396, 30584, 23134, 25630, 29754, 24357, 21684, 21039, 19044, 16488, 14846, 16998, 16423, 10666, 8053, 8084, 9901, 0, 9363, 4870, 13117, 11575, 13793, 13300, 15009, 17856, 19337, 20454, 36551, 42017, 26352, 18403, 21033, 17737, 15720],\n    [23296, 33760, 27472, 24018, 52645, 21125, 23755, 17899, 20976, 25555, 22176, 22315, 21535, 18996, 16799, 16408, 14534, 22583, 14237, 10398, 6873, 4746, 9363, 0, 10020, 5211, 4685, 6348, 7636, 8010, 11074, 12315, 11926, 27537, 32880, 18634, 12644, 15358, 12200, 10674],\n    [32979, 43631, 37281, 33904, 62415, 30825, 33278, 26460, 29208, 33535, 28627, 26411, 25744, 23644, 21097, 19592, 21042, 20997, 15515, 12657, 11763, 12531, 4870, 10020, 0, 14901, 13738, 15855, 16118, 17348, 20397, 21793, 21936, 37429, 42654, 28485, 21414, 24144, 20816, 18908],\n    [18141, 28730, 22389, 19005, 47544, 15975, 18557, 12894, 16055, 20674, 18093, 19539, 18746, 16138, 14374, 14727, 10911, 22888, 14053, 10633, 6949, 3737, 13117, 5211, 14901, 0, 1777, 1217, 3528, 2896, 5892, 7104, 7338, 23517, 29068, 13583, 7667, 10304, 7330, 6204],\n    [19248, 29976, 23592, 20295, 48689, 17101, 19545, 13251, 16300, 20872, 17672, 18517, 17725, 15126, 13194, 13336, 10190, 21194, 12378, 8889, 5177, 1961, 11575, 4685, 13738, 1777, 0, 2217, 2976, 3610, 6675, 8055, 8965, 25197, 30774, 14865, 8007, 10742, 7532, 6000],\n    [17129, 27803, 21433, 18105, 46560, 14971, 17490, 11680, 14838, 19457, 16955, 18636, 17845, 15240, 13590, 14109, 9900, 22640, 13798, 10569, 7050, 4036, 13793, 6348, 15855, 1217, 2217, 0, 2647, 1686, 4726, 6000, 6810, 23060, 28665, 12674, 6450, 9094, 6117, 5066],\n    [17192, 28076, 21655, 18551, 46567, 15104, 17309, 10455, 13422, 17961, 14735, 16024, 15232, 12625, 10943, 11507, 7397, 20334, 11537, 8646, 5619, 3588, 13300, 7636, 16118, 3528, 2976, 2647, 0, 2320, 4593, 6093, 8479, 24542, 30219, 13194, 5301, 8042, 4735, 3039],\n    [15645, 26408, 20011, 16763, 45086, 13503, 15936, 9997, 13165, 17787, 15510, 17632, 16848, 14264, 12824, 13611, 8758, 22636, 13852, 10938, 7730, 5109, 15009, 8010, 17348, 2896, 3610, 1686, 2320, 0, 3086, 4444, 6169, 22301, 27963, 11344, 4780, 7408, 4488, 3721],\n    [12658, 23504, 17087, 13958, 42083, 10544, 12881, 7194, 10430, 15048, 13694, 16948, 16197, 13736, 12815, 14104, 8119, 23801, 15276, 12906, 10187, 7996, 17856, 11074, 20397, 5892, 6675, 4726, 4593, 3086, 0, 1501, 5239, 20390, 26101, 8611, 2418, 4580, 2599, 3496],\n    [11210, 22025, 15612, 12459, 40648, 9080, 11498, 6574, 9813, 14372, 13768, 17587, 16859, 14482, 13779, 15222, 8948, 25065, 16632, 14366, 11689, 9459, 19337, 12315, 21793, 7104, 8055, 6000, 6093, 4444, 1501, 0, 4608, 19032, 24747, 7110, 2860, 4072, 3355, 4772],\n    [12094, 22000, 15872, 12296, 40971, 9983, 12944, 10678, 13777, 18115, 18317, 22131, 21391, 18958, 18042, 19237, 13353, 28675, 19957, 17106, 13792, 10846, 20454, 11926, 21936, 7338, 8965, 6810, 8479, 6169, 5239, 4608, 0, 16249, 21866, 7146, 7403, 8446, 7773, 8614],\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Wrapper Target Properties in CMake\nDESCRIPTION: Sets include directories, compile definitions, and SWIG target properties for the pywrapcp target.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(pywrapcp PRIVATE ${Python3_INCLUDE_DIRS})\nset_property(TARGET pywrapcp PROPERTY SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON)\ntarget_compile_definitions(pywrapcp PUBLIC \"PY3\")\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for SAT Solver Interface in CMake\nDESCRIPTION: Sets SWIG properties for the SAT solver interface file (sat.i), including C++ mode, module name, compile definitions, and target Java package.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE sat.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE sat.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE sat.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE sat.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.sat)\n```\n\n----------------------------------------\n\nTITLE: Stopping Search After N Solutions in C# with OR-Tools CP-SAT Solver\nDESCRIPTION: This C# code demonstrates how to stop the search process in OR-Tools CP-SAT solver after finding a specific number of solutions. It implements a custom solution callback class to print intermediate solutions and stop the search when the limit is reached.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/solver.md#2025-04-17_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class VarArraySolutionPrinterWithLimit : CpSolverSolutionCallback\n{\n    public VarArraySolutionPrinterWithLimit(IntVar[] variables, int solution_limit)\n    {\n        variables_ = variables;\n        solution_limit_ = solution_limit;\n    }\n\n    public override void OnSolutionCallback()\n    {\n        Console.WriteLine(String.Format(\"Solution #{0}: time = {1:F2} s\", solution_count_, WallTime()));\n        foreach (IntVar v in variables_)\n        {\n            Console.WriteLine(String.Format(\"  {0} = {1}\", v.ToString(), Value(v)));\n        }\n        solution_count_++;\n        if (solution_count_ >= solution_limit_)\n        {\n            Console.WriteLine(String.Format(\"Stopping search after {0} solutions\", solution_limit_));\n            StopSearch();\n        }\n    }\n\n    public int SolutionCount()\n    {\n        return solution_count_;\n    }\n\n    private int solution_count_;\n    private IntVar[] variables_;\n    private int solution_limit_;\n}\n\npublic class StopAfterNSolutionsSampleSat\n{\n    static void Main()\n    {\n        // Creates the model.\n        CpModel model = new CpModel();\n        // Creates the variables.\n        int num_vals = 3;\n\n        IntVar x = model.NewIntVar(0, num_vals - 1, \"x\");\n        IntVar y = model.NewIntVar(0, num_vals - 1, \"y\");\n        IntVar z = model.NewIntVar(0, num_vals - 1, \"z\");\n\n        // Creates a solver and solves the model.\n        CpSolver solver = new CpSolver();\n        VarArraySolutionPrinterWithLimit cb = new VarArraySolutionPrinterWithLimit(new IntVar[] { x, y, z }, 5);\n        solver.StringParameters = \"enumerate_all_solutions:true\";\n        solver.Solve(model, cb);\n        Console.WriteLine(String.Format(\"Number of solutions found: {0}\", cb.SolutionCount()));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sicherman_dice.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring SCIP Solver Test for OR-Tools\nDESCRIPTION: Sets up a test target for the SCIP solver implementation in OR-Tools with conditional compilation based on SCIP availability. The test links against numerous mathematical optimization test libraries using WHOLE_ARCHIVE linking to ensure all tests are included.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_SCIP)\n  ortools_cxx_test(\n    NAME\n      math_opt_solvers_gscip_solver_test\n    SOURCES\n      \"gscip_solver_test.cc\"\n    LINK_LIBRARIES\n      GTest::gmock\n      GTest::gmock_main\n      absl::status\n      ortools::math_opt_matchers\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_invalid_input_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_multiple_solutions_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_parameter_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_mip_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qc_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_second_order_cone_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: This snippet installs the OR-Tools package, which is required to use Google CP Solver in Python.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/diet1.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Executing Diet Problem MIP Solver with Command-line Arguments in Python\nDESCRIPTION: This snippet handles command-line arguments to specify the solver (CBC or GLPK) and calls the main function to solve the diet problem. It ensures the correct solver is used and executes the optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/diet1_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsol = 'CBC'\nif len(sys.argv) > 1:\n  sol = sys.argv[1]\n  if sol != 'GLPK' and sol != 'CBC':\n    print('Solver must be either GLPK or CBC')\n    sys.exit(1)\n\nmain(sol)\n```\n\n----------------------------------------\n\nTITLE: Distance Matrix Initialization in Python\nDESCRIPTION: Multi-dimensional distance matrix representing distances between nodes in the graph. Each row and column represents distances from one node to all other nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n[\n    [13175, 13197, 11653, 10370, 29929, 13435, 14711, 20959, 22300, 24280, 28831, 34799, 34211, 32292, 32259, 34013, 27354, 44048, 35660, 33171, 30012, 27094, 36551, 27537, 37429, 23517, 25197, 23060, 24542, 22301, 20390, 19032, 16249, 0, 5714, 12901, 21524, 20543, 22186, 23805],\n    [18162, 14936, 15666, 15331, 28493, 18755, 19589, 26458, 27564, 29101, 34148, 40296, 39731, 37879, 37918, 39703, 33023, 49756, 41373, 38858, 35654, 32690, 42017, 32880, 42654, 29068, 30774, 28665, 30219, 27963, 26101, 24747, 21866, 5714, 0, 18516, 27229, 26181, 27895, 29519],\n    # ... additional matrix rows ...\n]\n```\n\n----------------------------------------\n\nTITLE: Adding Python Tests in CMake for OR-Tools\nDESCRIPTION: Conditionally adds Python test files when BUILD_TESTING is enabled. It glob-matches all Python files ending with '_test.py' and adds them as tests using the add_python_test function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Python pip command to install the Google OR-Tools package required for the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular_table.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Python environment. This is a prerequisite for running the routing program.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/simple_routing_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python Environment\nDESCRIPTION: This snippet installs the OR-Tools package necessary for running the travelling salesman problem example. It uses pip in a Jupyter notebook environment to handle the package installation. The output is the installed package, and no specific input is required.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/tsp_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools library for constraint programming and optimization\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/index_first_boolvar_true_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the OR-Tools Python package using pip in a Google Colab environment. This is a prerequisite for running the VRP example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_with_time_limit.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip, which is necessary to access the CP-SAT Solver functionalities in Python. The command requires an active internet connection and permissions to install packages.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip, which is required to run the shift scheduling model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/shift_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: PIP command to install the Google OR-Tools package, required for running the optimization solver\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/multiple_knapsack_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Command to install the Google OR-Tools package in a Colab environment. This is required to use the constraint solver functionality.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_pickup_delivery_fifo.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the required OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/pyls_api.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Knapsack Solver in CMake\nDESCRIPTION: Sets SWIG properties for the knapsack solver interface file, including C++ mode, module name, and compile definitions. It also specifies the .NET namespace and DLL import name.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(SOURCE knapsack_solver.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE knapsack_solver.i PROPERTY SWIG_MODULE_NAME operations_research_algorithms)\nset_property(SOURCE knapsack_solver.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE knapsack_solver.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.Algorithms\n  -dllimport google-ortools-native)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/golomb_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Creating Python Module with Pybind11\nDESCRIPTION: Creates a Python module using pybind11 for the sorted interval list component and sets its output name.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\npybind11_add_module(sorted_interval_list_pybind11 MODULE sorted_interval_list.cc)\nset_target_properties(sorted_interval_list_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"sorted_interval_list\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Testing and Installation\nDESCRIPTION: Sets up test configuration for the vector bin packing executable and defines installation rules. Includes a test case using sample data.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/packing/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  add_test(\n    NAME cxx_packing_vector_bin_packing\n    COMMAND vector_bin_packing --input ${CMAKE_CURRENT_SOURCE_DIR}/testdata/1D__bpp_scholl__bin2data.N2W2B1R0.vbp)\nendif()\n\ninstall(TARGETS vector_bin_packing)\n```\n\n----------------------------------------\n\nTITLE: Conditional Sample Building Logic in CMake\nDESCRIPTION: CMake script that controls the building of sample files. It first checks if samples should be built at all, then separately handles C++ and Python samples based on their respective build flags. For each language, it glob searches for source files and adds them as samples using custom functions.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/pdlp/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_SAMPLES)\n  return()\nendif()\n\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating OR-Tools SAT Runner Executable in CMake\nDESCRIPTION: Builds a standalone SAT runner executable, configures its sources, include directories, and links it against the OR-Tools library. Sets C++17 as the required standard for compilation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Sat Runner\nadd_executable(sat_runner)\ntarget_sources(sat_runner PRIVATE \"sat_runner.cc\")\ntarget_include_directories(sat_runner PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\ntarget_compile_features(sat_runner PRIVATE cxx_std_17)\ntarget_link_libraries(sat_runner PRIVATE ${PROJECT_NAMESPACE}::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for OR-Tools SAT C# Bindings\nDESCRIPTION: Sets SWIG interface properties for the SAT solver module, including C++ mode, module name, and compilation definitions. Configures the namespace and DLL import settings specific to the .NET project.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(SOURCE sat.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE sat.i PROPERTY SWIG_MODULE_NAME operations_research_sat)\nset_property(SOURCE sat.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE sat.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.Sat\n  -dllimport google-ortools-native)\n```\n\n----------------------------------------\n\nTITLE: Helper Functions for Grid Operations\nDESCRIPTION: Functions to handle neighboring arcs and print the puzzle solution grid with formatting\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef NeighboringArcs(i, j, h_arcs, v_arcs):\n  tmp = []\n  if j > 0:\n    tmp.append(h_arcs[i][j - 1])\n  if j < len(v_arcs) - 1:\n    tmp.append(h_arcs[i][j])\n  if i > 0:\n    tmp.append(v_arcs[j][i - 1])\n  if i < len(h_arcs) - 1:\n    tmp.append(v_arcs[j][i])\n  return tmp\n\n\ndef PrintSolution(data, h_arcs, v_arcs):\n  num_rows = len(data)\n  num_columns = len(data[0])\n\n  for i in range(num_rows):\n    first_line = ''\n    second_line = ''\n    third_line = ''\n    for j in range(num_columns):\n      h_arc = h_arcs[i][j].Value()\n      v_arc = v_arcs[j][i].Value()\n      cnt = data[i][j]\n      first_line += ' ---' if h_arc else '    '\n      second_line += '|' if v_arc else ' '\n      second_line += '   ' if cnt == -1 else ' %i ' % cnt\n      third_line += '|   ' if v_arc == 1 else '    '\n    termination = v_arcs[num_columns][i].Value()\n    second_line += '|' if termination else ' '\n    third_line += '|' if termination else ' '\n    print(first_line)\n    print(third_line)\n    print(second_line)\n    print(third_line)\n  last_line = ''\n  for j in range(num_columns):\n    h_arc = h_arcs[num_rows][j].Value()\n    last_line += ' ---' if h_arc else '    '\n  print(last_line)\n```\n\n----------------------------------------\n\nTITLE: Examining Clang INT64 macro definitions on Linux\nDESCRIPTION: Command to check how int64_t types are defined in Clang on Linux systems. This reveals that Clang uses the same underlying types as GCC on Linux.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nclang -dM -E -x c++ /dev/null | grep INT64_TYPE\n#define __INT64_TYPE__ long int\n#define __UINT64_TYPE__ long unsigned int\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for OR-Tools Routing Module in CMake\nDESCRIPTION: Sets properties for the SWIG interface file routing.i, including C++ mode, module name, compile definitions, and options.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(SOURCE routing.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE routing.i PROPERTY SWIG_MODULE_NAME pywrapcp)\nset_property(SOURCE routing.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE routing.i PROPERTY COMPILE_OPTIONS -nofastunpack)\n```\n\n----------------------------------------\n\nTITLE: Flight or Transportation Data Array in JavaScript\nDESCRIPTION: This code snippet represents a large dataset of transportation information, likely flight data. Each row contains an ID, departure time, arrival time in HH:MM format, followed by what appear to be numeric timestamps and calculated duration. This data structure is commonly used in optimization problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n    [832, \"15:10\", \"16:21\", 910, 981, 71],\n    [833, \"15:10\", \"15:20\", 910, 920, 10],\n    [834, \"15:11\", \"15:24\", 911, 924, 13],\n    [835, \"15:12\", \"15:36\", 912, 936, 24],\n    [836, \"15:13\", \"16:00\", 913, 960, 47],\n    [837, \"15:13\", \"15:40\", 913, 940, 27],\n    [838, \"15:14\", \"16:40\", 914, 1000, 86],\n    [839, \"15:16\", \"15:28\", 916, 928, 12],\n    [840, \"15:16\", \"15:55\", 916, 955, 39],\n    [841, \"15:18\", \"16:05\", 918, 965, 47],\n    [842, \"15:18\", \"16:44\", 918, 1004, 86],\n    [843, \"15:18\", \"16:05\", 918, 965, 47],\n    [844, \"15:19\", \"16:13\", 919, 973, 54],\n    [845, \"15:19\", \"15:34\", 919, 934, 15],\n    [846, \"15:20\", \"15:30\", 920, 930, 10],\n    [847, \"15:20\", \"16:31\", 920, 991, 71],\n    [848, \"15:20\", \"15:36\", 920, 936, 16],\n    [849, \"15:21\", \"15:47\", 921, 947, 26],\n    [850, \"15:21\", \"16:06\", 921, 966, 45],\n    [851, \"15:23\", \"16:10\", 923, 970, 47],\n    [852, \"15:24\", \"16:50\", 924, 1010, 86],\n    [853, \"15:24\", \"16:05\", 924, 965, 41],\n    [854, \"15:27\", \"15:51\", 927, 951, 24],\n    [855, \"15:27\", \"15:44\", 927, 944, 17],\n    [856, \"15:28\", \"16:15\", 928, 975, 47],\n    [857, \"15:28\", \"16:54\", 928, 1014, 86],\n    [858, \"15:28\", \"16:15\", 928, 975, 47],\n    [859, \"15:28\", \"15:55\", 928, 955, 27],\n    [860, \"15:29\", \"16:23\", 929, 983, 54],\n    [861, \"15:30\", \"16:41\", 930, 1001, 71],\n    [862, \"15:30\", \"15:40\", 930, 940, 10],\n    [863, \"15:31\", \"15:43\", 931, 943, 12],\n    [864, \"15:33\", \"16:20\", 933, 980, 47],\n    [865, \"15:34\", \"17:00\", 934, 1020, 86],\n    [866, \"15:34\", \"16:15\", 934, 975, 41],\n    [867, \"15:35\", \"15:54\", 935, 954, 19],\n    [868, \"15:36\", \"16:21\", 936, 981, 45],\n    [869, \"15:38\", \"16:25\", 938, 985, 47],\n    [870, \"15:38\", \"16:25\", 938, 985, 47],\n    [871, \"15:38\", \"16:39\", 938, 999, 61],\n    [872, \"15:39\", \"16:33\", 939, 993, 54],\n    [873, \"15:40\", \"15:50\", 940, 950, 10],\n    [874, \"15:40\", \"16:51\", 940, 1011, 71],\n    [875, \"15:40\", \"15:56\", 940, 956, 16],\n    [876, \"15:43\", \"16:10\", 943, 970, 27],\n    [877, \"15:43\", \"16:30\", 943, 990, 47],\n    [878, \"15:44\", \"17:10\", 944, 1030, 86],\n    [879, \"15:44\", \"16:25\", 944, 985, 41],\n    [880, \"15:45\", \"16:04\", 945, 964, 19],\n    [881, \"15:46\", \"15:58\", 946, 958, 12],\n    [882, \"15:48\", \"16:35\", 948, 995, 47],\n    [883, \"15:48\", \"16:35\", 948, 995, 47],\n    [884, \"15:48\", \"17:14\", 948, 1034, 86],\n    [885, \"15:49\", \"16:43\", 949, 1003, 54],\n    [886, \"15:50\", \"16:00\", 950, 960, 10],\n    [887, \"15:50\", \"17:01\", 950, 1021, 71],\n    [888, \"15:51\", \"16:18\", 951, 978, 27],\n    [889, \"15:52\", \"16:36\", 952, 996, 44],\n    [890, \"15:53\", \"16:40\", 953, 1000, 47],\n    [891, \"15:54\", \"17:20\", 954, 1040, 86],\n    [892, \"15:54\", \"16:35\", 954, 995, 41],\n    [893, \"15:55\", \"16:14\", 955, 974, 19],\n    [894, \"15:58\", \"16:25\", 958, 985, 27],\n    [895, \"15:58\", \"16:45\", 958, 1005, 47],\n    [896, \"15:58\", \"16:45\", 958, 1005, 47],\n    [897, \"15:58\", \"17:24\", 958, 1044, 86],\n    [898, \"15:59\", \"17:11\", 959, 1031, 72],\n    [899, \"15:59\", \"16:53\", 959, 1013, 54],\n    [900, \"16:00\", \"16:10\", 960, 970, 10],\n    [901, \"16:00\", \"16:16\", 960, 976, 16],\n    [902, \"16:01\", \"16:13\", 961, 973, 12],\n    [903, \"16:03\", \"16:50\", 963, 1010, 47],\n    [904, \"16:04\", \"17:30\", 964, 1050, 86],\n    [905, \"16:04\", \"16:45\", 964, 1005, 41],\n    [906, \"16:05\", \"16:24\", 965, 984, 19],\n    [907, \"16:06\", \"16:51\", 966, 1011, 45],\n    [908, \"16:08\", \"16:55\", 968, 1015, 47],\n    [909, \"16:08\", \"17:34\", 968, 1054, 86],\n    [910, \"16:08\", \"16:55\", 968, 1015, 47],\n    [911, \"16:09\", \"17:03\", 969, 1023, 54],\n    [912, \"16:09\", \"17:21\", 969, 1041, 72],\n    [913, \"16:10\", \"16:20\", 970, 980, 10],\n    [914, \"16:13\", \"16:40\", 973, 1000, 27],\n    [915, \"16:13\", \"17:00\", 973, 1020, 47],\n    [916, \"16:14\", \"16:55\", 974, 1015, 41],\n    [917, \"16:14\", \"17:40\", 974, 1060, 86],\n    [918, \"16:15\", \"16:34\", 975, 994, 19],\n    [919, \"16:16\", \"16:28\", 976, 988, 12],\n    [920, \"16:18\", \"17:05\", 978, 1025, 47],\n    [921, \"16:18\", \"17:05\", 978, 1025, 47],\n    [922, \"16:18\", \"17:44\", 978, 1064, 86],\n    [923, \"16:19\", \"17:31\", 979, 1051, 72],\n    [924, \"16:19\", \"17:13\", 979, 1033, 54],\n    [925, \"16:20\", \"16:30\", 980, 990, 10],\n    [926, \"16:20\", \"16:36\", 980, 996, 16],\n    [927, \"16:21\", \"16:48\", 981, 1008, 27],\n    [928, \"16:22\", \"17:06\", 982, 1026, 44],\n    [929, \"16:23\", \"17:10\", 983, 1030, 47],\n    [930, \"16:24\", \"17:05\", 984, 1025, 41],\n    [931, \"16:24\", \"17:50\", 984, 1070, 86],\n    [932, \"16:25\", \"16:44\", 985, 1004, 19],\n    [933, \"16:28\", \"17:15\", 988, 1035, 47],\n    [934, \"16:28\", \"17:15\", 988, 1035, 47],\n    [935, \"16:28\", \"16:55\", 988, 1015, 27],\n    [936, \"16:28\", \"17:54\", 988, 1074, 86],\n    [937, \"16:29\", \"17:23\", 989, 1043, 54],\n    [938, \"16:29\", \"17:41\", 989, 1061, 72],\n    [939, \"16:30\", \"16:40\", 990, 1000, 10],\n    [940, \"16:31\", \"16:43\", 991, 1003, 12],\n    [941, \"16:33\", \"17:20\", 993, 1040, 47],\n    [942, \"16:34\", \"17:15\", 994, 1035, 41],\n    [943, \"16:34\", \"18:00\", 994, 1080, 86],\n    [944, \"16:35\", \"16:54\", 995, 1014, 19],\n    [945, \"16:36\", \"17:21\", 996, 1041, 45],\n    [946, \"16:38\", \"17:25\", 998, 1045, 47],\n    [947, \"16:38\", \"17:25\", 998, 1045, 47],\n    [948, \"16:38\", \"18:04\", 998, 1084, 86],\n    [949, \"16:39\", \"17:33\", 999, 1053, 54],\n    [950, \"16:39\", \"17:51\", 999, 1071, 72],\n    [951, \"16:40\", \"16:56\", 1000, 1016, 16],\n    [952, \"16:40\", \"16:50\", 1000, 1010, 10],\n    [953, \"16:43\", \"17:10\", 1003, 1030, 27],\n    [954, \"16:43\", \"17:30\", 1003, 1050, 47],\n    [955, \"16:44\", \"17:25\", 1004, 1045, 41],\n    [956, \"16:44\", \"18:10\", 1004, 1090, 86],\n    [957, \"16:45\", \"17:04\", 1005, 1024, 19],\n    [958, \"16:46\", \"16:58\", 1006, 1018, 12],\n    [959, \"16:48\", \"18:14\", 1008, 1094, 86],\n    [960, \"16:48\", \"17:35\", 1008, 1055, 47],\n    [961, \"16:48\", \"17:35\", 1008, 1055, 47],\n    [962, \"16:49\", \"18:01\", 1009, 1081, 72],\n    [963, \"16:49\", \"17:43\", 1009, 1063, 54],\n    [964, \"16:50\", \"17:00\", 1010, 1020, 10],\n    [965, \"16:51\", \"17:18\", 1011, 1038, 27],\n    [966, \"16:52\", \"17:36\", 1012, 1056, 44],\n    [967, \"16:53\", \"17:40\", 1013, 1060, 47],\n    [968, \"16:54\", \"18:20\", 1014, 1100, 86],\n    [969, \"16:54\", \"17:35\", 1014, 1055, 41],\n    [970, \"16:55\", \"17:14\", 1015, 1034, 19],\n    [971, \"16:58\", \"17:25\", 1018, 1045, 27],\n    [972, \"16:58\", \"17:45\", 1018, 1065, 47],\n    [973, \"16:58\", \"17:45\", 1018, 1065, 47],\n    [974, \"16:58\", \"18:24\", 1018, 1104, 86],\n    [975, \"16:59\", \"18:11\", 1019, 1091, 72],\n    [976, \"16:59\", \"17:53\", 1019, 1073, 54],\n    [977, \"17:00\", \"17:16\", 1020, 1036, 16],\n    [978, \"17:00\", \"17:10\", 1020, 1030, 10],\n    [979, \"17:01\", \"17:13\", 1021, 1033, 12],\n    [980, \"17:03\", \"17:50\", 1023, 1070, 47],\n    [981, \"17:04\", \"18:30\", 1024, 1110, 86],\n    [982, \"17:04\", \"17:45\", 1024, 1065, 41],\n    [983, \"17:05\", \"17:24\", 1025, 1044, 19],\n    [984, \"17:06\", \"17:51\", 1026, 1071, 45],\n    [985, \"17:08\", \"17:55\", 1028, 1075, 47],\n    [986, \"17:08\", \"17:55\", 1028, 1075, 47],\n    [987, \"17:08\", \"18:34\", 1028, 1114, 86],\n    [988, \"17:09\", \"18:03\", 1029, 1083, 54],\n    [989, \"17:09\", \"18:21\", 1029, 1101, 72],\n    [990, \"17:10\", \"17:20\", 1030, 1040, 10],\n    [991, \"17:13\", \"17:40\", 1033, 1060, 27],\n    [992, \"17:13\", \"18:00\", 1033, 1080, 47],\n    [993, \"17:14\", \"17:55\", 1034, 1075, 41],\n    [994, \"17:14\", \"18:40\", 1034, 1120, 86],\n    [995, \"17:15\", \"17:34\", 1035, 1054, 19],\n    [996, \"17:16\", \"17:28\", 1036, 1048, 12],\n    [997, \"17:18\", \"18:05\", 1038, 1085, 47],\n    [998, \"17:18\", \"18:05\", 1038, 1085, 47],\n    [999, \"17:18\", \"18:44\", 1038, 1124, 86],\n    [1000, \"17:19\", \"18:31\", 1039, 1111, 72],\n    [1001, \"17:19\", \"18:13\", 1039, 1093, 54],\n    [1002, \"17:20\", \"17:36\", 1040, 1056, 16],\n    [1003, \"17:20\", \"17:30\", 1040, 1050, 10],\n    [1004, \"17:21\", \"17:47\", 1041, 1067, 26],\n    [1005, \"17:22\", \"18:06\", 1042, 1086, 44],\n    [1006, \"17:23\", \"18:10\", 1043, 1090, 47],\n    [1007, \"17:24\", \"18:50\", 1044, 1130, 86],\n    [1008, \"17:24\", \"18:05\", 1044, 1085, 41],\n    [1009, \"17:25\", \"17:44\", 1045, 1064, 19],\n    [1010, \"17:28\", \"17:55\", 1048, 1075, 27],\n    [1011, \"17:28\", \"18:15\", 1048, 1095, 47],\n    [1012, \"17:28\", \"18:15\", 1048, 1095, 47],\n    [1013, \"17:28\", \"18:54\", 1048, 1134, 86],\n    [1014, \"17:29\", \"18:41\", 1049, 1121, 72],\n    [1015, \"17:29\", \"18:23\", 1049, 1103, 54],\n    [1016, \"17:30\", \"17:40\", 1050, 1060, 10],\n    [1017, \"17:31\", \"17:43\", 1051, 1063, 12],\n    [1018, \"17:33\", \"18:20\", 1053, 1100, 47],\n    [1019, \"17:34\", \"18:15\", 1054, 1095, 41],\n    [1020, \"17:34\", \"19:00\", 1054, 1140, 86],\n    [1021, \"17:35\", \"17:54\", 1055, 1074, 19],\n    [1022, \"17:36\", \"18:21\", 1056, 1101, 45],\n    [1023, \"17:38\", \"18:25\", 1058, 1105, 47],\n    [1024, \"17:38\", \"19:04\", 1058, 1144, 86],\n    [1025, \"17:38\", \"18:25\", 1058, 1105, 47],\n    [1026, \"17:39\", \"18:51\", 1059, 1131, 72],\n    [1027, \"17:39\", \"18:33\", 1059, 1113, 54],\n    [1028, \"17:40\", \"17:56\", 1060, 1076, 16],\n    [1029, \"17:40\", \"17:50\", 1060, 1070, 10],\n    [1030, \"17:43\", \"18:10\", 1063, 1090, 27],\n    [1031, \"17:43\", \"18:30\", 1063, 1110, 47],\n    [1032, \"17:44\", \"18:25\", 1064, 1105, 41],\n    [1033, \"17:44\", \"19:14\", 1064, 1154, 90],\n    [1034, \"17:45\", \"18:04\", 1065, 1084, 19],\n    [1035, \"17:46\", \"17:58\", 1066, 1078, 12],\n    [1036, \"17:48\", \"18:35\", 1068, 1115, 47],\n    [1037, \"17:48\", \"18:35\", 1068, 1115, 47],\n    [1038, \"17:48\", \"19:14\", 1068, 1154, 86],\n    [1039, \"17:49\", \"19:01\", 1069, 1141, 72],\n    [1040, \"17:49\", \"18:43\", 1069, 1123, 54],\n    [1041, \"17:50\", \"18:00\", 1070, 1080, 10],\n    [1042, \"17:51\", \"18:17\", 1071, 1097, 26],\n    [1043, \"17:52\", \"18:36\", 1072, 1116, 44],\n    [1044, \"17:53\", \"18:40\", 1073, 1120, 47],\n    [1045, \"17:54\", \"18:35\", 1074, 1115, 41],\n    [1046, \"17:54\", \"18:57\", 1074, 1137, 63],\n    [1047, \"17:55\", \"18:14\", 1075, 1094, 19],\n    [1048, \"17:58\", \"18:45\", 1078, 1125, 47],\n    [1049, \"17:58\", \"18:45\", 1078, 1125, 47],\n    [1050, \"17:58\", \"18:25\", 1078, 1105, 27],\n    [1051, \"17:58\", \"19:26\", 1078, 1166, 88],\n    [1052, \"17:59\", \"18:53\", 1079, 1133, 54],\n    [1053, \"18:00\", \"19:11\", 1080, 1151, 71],\n    [1054, \"18:00\", \"18:10\", 1080, 1090, 10],\n    [1055, \"18:00\", \"18:16\", 1080, 1096, 16]\n```\n\n----------------------------------------\n\nTITLE: Configuring Graph Module Target Properties\nDESCRIPTION: Sets target properties for the graph module including position independent code and SWIG include directory settings. Links against the core OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(dotnet_graph PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_graph PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring Osi Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build Osi library. It specifies the git repository, version tag, and applies a patch. This is conditionally executed if BUILD_Osi is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_Osi)\n  message(CHECK_START \"Fetching Osi\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    Osi\n    GIT_REPOSITORY \"https://github.com/Mizux/Osi.git\"\n    GIT_TAG \"cmake/0.108.11\"\n    GIT_SHALLOW TRUE\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/osi-0.108.patch\")\n  FetchContent_MakeAvailable(Osi)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Intervals in Go using OR-Tools\nDESCRIPTION: Go implementation of optional interval variables using OR-Tools CP-SAT solver. Shows creation of intervals with both variable and fixed sizes using Go-specific syntax.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/scheduling.md#2025-04-17_snippet_9\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n)\n\nconst horizon = 100\n\nfunc optionalIntervalSampleSat() error {\n\tmodel := cpmodel.NewCpModelBuilder()\n\tdomain := cpmodel.NewDomain(0, horizon)\n\n\tx := model.NewIntVarFromDomain(domain).WithName(\"x\")\n\ty := model.NewIntVar(2, 4).WithName(\"y\")\n\tz := model.NewIntVarFromDomain(domain).WithName(\"z\")\n\tpresenceVar := model.NewBoolVar().WithName(\"presence\")\n\n\tintervalVar := model.NewOptionalIntervalVar(x, y, cpmodel.NewConstant(2).Add(z), presenceVar).WithName(\"interval\")\n\tfixedSizeIntervalVar := model.NewOptionalFixedSizeIntervalVar(x, 10, presenceVar).WithName(\"fixedSizeInterval\")\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := optionalIntervalSampleSat(); err != nil {\n\t\tlog.Exitf(\"optionalIntervalSampleSat returned with error: %v\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Simple pip install command to set up the required OR-Tools package in the environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/wedding_optimal_chart.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Build Settings\nDESCRIPTION: Sets up test configurations when BUILD_TESTING is enabled, including XPRESS interface tests and platform-specific RPATH settings for test executables.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  if (APPLE)\n    set(CMAKE_INSTALL_RPATH\n            \"@loader_path/../${CMAKE_INSTALL_LIBDIR};@loader_path\")\n  elseif (UNIX)\n    set(CMAKE_INSTALL_RPATH \"$ORIGIN/../${CMAKE_INSTALL_LIBDIR}:$ORIGIN:$ORIGIN/../lib:$ORIGIN\")\n  endif ()\n\n  if(USE_XPRESS)\n    add_executable(test_xprs_interface xpress_interface_test.cc)\n    target_compile_features(test_xprs_interface PRIVATE cxx_std_17)\n    target_link_libraries(test_xprs_interface PRIVATE ortools::ortools GTest::gtest_main)\n\n    add_test(NAME cxx_unittests_xpress_interface COMMAND test_xprs_interface)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Alpine Container Testing\nDESCRIPTION: Example command to run tests inside an Alpine Linux container.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/docker/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake alpine-edge_test\n```\n\n----------------------------------------\n\nTITLE: Defining Network Topology Structure in Protobuf\nDESCRIPTION: This code defines a network topology with 13 nodes of various types (HUT, POLE, FDH, UNDERGROUND_VAULT, CUSTOMER_ENDPOINT) connected in a tree structure. Each node contains properties specifying its type, index position, parent relationship, cable length to parent (in meters), and a reference to geodata. The structure represents a hierarchical network deployment from hub to customer endpoints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/testdata/fiber_forest.pb.txt#2025-04-17_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nnode {\n  type                : HUT\n  current_index       : 0\n  geodata_node_ref     : 0\n}\nnode {\n  type                : POLE\n  current_index       : 1\n  parent_index        : 0\n  cable_length_meters : 600\n  geodata_node_ref     : 1\n}\nnode {\n  type                : FDH\n  current_index       : 2\n  parent_index        : 1\n  cable_length_meters : 600\n  geodata_node_ref     : 2\n}\nnode {\n  type                : UNDERGROUND_VAULT\n  current_index       : 3\n  parent_index        : 1\n  cable_length_meters : 300\n  geodata_node_ref     : 3\n}\nnode {\n  type                : POLE\n  current_index       : 4\n  parent_index        : 3\n  cable_length_meters : 300\n  geodata_node_ref     : 4\n}\nnode {\n  type                : FDH\n  current_index       : 5\n  parent_index        : 4\n  cable_length_meters : 300\n  geodata_node_ref     : 5\n}\nnode {\n  type                : FDH\n  current_index       : 6\n  parent_index        : 3\n  cable_length_meters : 600\n  geodata_node_ref     : 6\n}\nnode {\n  type                : POLE\n  current_index       : 7\n  parent_index        : 6\n  cable_length_meters : 600\n  geodata_node_ref     : 7\n}\nnode {\n  type                : FDH\n  current_index       : 8\n  parent_index        : 7\n  cable_length_meters : 900\n  geodata_node_ref     : 8\n}\nnode {\n  type                : CUSTOMER_ENDPOINT\n  current_index       : 9\n  parent_index        : 2\n  cable_length_meters : 9000\n  geodata_node_ref    : 9\n}\nnode {\n  type                : CUSTOMER_ENDPOINT\n  current_index       : 10\n  parent_index        : 5\n  cable_length_meters : 9000\n  geodata_node_ref    : 10\n}\nnode {\n  type                : CUSTOMER_ENDPOINT\n  current_index       : 11\n  parent_index        : 6\n  cable_length_meters : 9000\n  geodata_node_ref    : 11\n}\nnode {\n  type                : CUSTOMER_ENDPOINT\n  current_index       : 12\n  parent_index        : 8\n  cable_length_meters : 9000\n  geodata_node_ref    : 12\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Problem Instance from File for Discrete Tomography\nDESCRIPTION: Implements a function to read a problem instance from a file, parsing row and column sums for the discrete tomography solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/discrete_tomography.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef read_problem(file):\n  f = open(file, \"r\")\n  row_sums = f.readline()\n  col_sums = f.readline()\n  row_sums = [int(r) for r in (row_sums.rstrip()).split(\",\")]\n  col_sums = [int(c) for c in (col_sums.rstrip()).split(\",\")]\n\n  return [row_sums, col_sums]\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Definitions and Include Directories for OR-Tools Graph Library in CMake\nDESCRIPTION: This snippet sets compile definitions for MSVC builds, includes necessary directories, and links required libraries for the graph component.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::hash\n  absl::meta\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto\n  $<$<BOOL:${USE_COINOR}>:Coin::Cbc>)\n```\n\n----------------------------------------\n\nTITLE: Configuring PDLP Solver Test for OR-Tools\nDESCRIPTION: Sets up a test target for the PDLP (Primal-Dual Linear Programming) solver implementation with conditional compilation based on PDLP availability. Links against linear programming test libraries with an exception for initial basis tests which may not be supported by PDLP.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_PDLP)\n  ortools_cxx_test(\n    NAME\n      math_opt_solvers_pdlp_solver_test\n    SOURCES\n      \"pdlp_solver_test.cc\"\n    LINK_LIBRARIES\n      GTest::gmock\n      GTest::gmock_main\n      absl::status\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_invalid_input_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_incomplete_solve_tests>\"\n      #\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_initial_basis_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_model_solve_parameters_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_parameter_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qc_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qp_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_second_order_cone_tests>\"\n      \"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Example Builds for Google OR-Tools\nDESCRIPTION: This snippet sets up the build process for Python examples. It glob's all .py files and adds each as a Python example using a custom CMake function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/tests/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_PYTHON_EXAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/organize_day.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Running OR-Tools Examples Using Makefile\nDESCRIPTION: Demonstrates how to compile and run OR-Tools C++ examples using the provided Makefile. This is the simplest approach for running the basic examples.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.cpp.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake run SOURCE=examples/basic_example/basic_example.cc\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Knapsack Solver in CMake\nDESCRIPTION: Sets various properties for the knapsack_solver.i SWIG interface file, including C++ mode, module name, compile definitions, and package information.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(SOURCE knapsack_solver.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE knapsack_solver.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE knapsack_solver.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE knapsack_solver.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.algorithms)\n```\n\n----------------------------------------\n\nTITLE: Defining Network Flow Graph Structure in Protocol Buffers\nDESCRIPTION: This code defines a network flow graph with arcs connecting nodes and their associated capacity values. Each arc defines a directed connection from a tail node to a head node with a specified capacity constraint. The graph appears to be structured for a max flow problem with source node 361 and sink node 362.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\narcs {\n  tail: 241\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 203\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 203\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 280\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 280\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 51\n  capacity: 97949\n}\narcs {\n  tail: 51\n  head: 362\n  capacity: 2050\n}\narcs {\n  tail: 51\n  head: 52\n  capacity: 5413139\n}\narcs {\n  tail: 51\n  head: 70\n  capacity: 327370\n}\narcs {\n  tail: 51\n  head: 31\n  capacity: 674140\n}\narcs {\n  tail: 51\n  head: 69\n  capacity: 319148\n}\narcs {\n  tail: 51\n  head: 50\n  capacity: 1558698\n}\narcs {\n  tail: 361\n  head: 69\n  capacity: 98092\n}\narcs {\n  tail: 69\n  head: 362\n  capacity: 1907\n}\narcs {\n  tail: 69\n  head: 70\n  capacity: 3767744\n}\narcs {\n  tail: 69\n  head: 89\n  capacity: 532410\n}\narcs {\n  tail: 69\n  head: 51\n  capacity: 319148\n}\narcs {\n  tail: 69\n  head: 50\n  capacity: 283385\n}\narcs {\n  tail: 69\n  head: 88\n  capacity: 91013\n}\narcs {\n  tail: 69\n  head: 87\n  capacity: 385167\n}\narcs {\n  tail: 69\n  head: 68\n  capacity: 1459586\n}\narcs {\n  tail: 361\n  head: 297\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 297\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 354\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 354\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 335\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 335\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 316\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 316\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 278\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 278\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 259\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 259\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 221\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 221\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 240\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 240\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 202\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 202\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 183\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 183\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 126\n  capacity: 12976\n}\narcs {\n  tail: 126\n  head: 362\n  capacity: 87023\n}\narcs {\n  tail: 126\n  head: 127\n  capacity: 1237476\n}\narcs {\n  tail: 126\n  head: 145\n  capacity: 342946\n}\narcs {\n  tail: 126\n  head: 107\n  capacity: 554271\n}\narcs {\n  tail: 126\n  head: 125\n  capacity: 589323\n}\narcs {\n  tail: 126\n  head: 144\n  capacity: 595661\n}\narcs {\n  tail: 361\n  head: 107\n  capacity: 21765\n}\narcs {\n  tail: 107\n  head: 362\n  capacity: 78234\n}\narcs {\n  tail: 107\n  head: 127\n  capacity: 43659\n}\narcs {\n  tail: 107\n  head: 108\n  capacity: 263988\n}\narcs {\n  tail: 107\n  head: 126\n  capacity: 554271\n}\narcs {\n  tail: 107\n  head: 88\n  capacity: 124608\n}\narcs {\n  tail: 107\n  head: 125\n  capacity: 216969\n}\narcs {\n  tail: 107\n  head: 106\n  capacity: 268050\n}\narcs {\n  tail: 361\n  head: 88\n  capacity: 57835\n}\narcs {\n  tail: 88\n  head: 362\n  capacity: 42164\n}\narcs {\n  tail: 88\n  head: 89\n  capacity: 126252\n}\narcs {\n  tail: 88\n  head: 108\n  capacity: 278534\n}\narcs {\n  tail: 88\n  head: 69\n  capacity: 91013\n}\narcs {\n  tail: 88\n  head: 106\n  capacity: 4467\n}\narcs {\n  tail: 88\n  head: 107\n  capacity: 124608\n}\narcs {\n  tail: 88\n  head: 87\n  capacity: 425841\n}\narcs {\n  tail: 361\n  head: 163\n  capacity: 98045\n}\narcs {\n  tail: 163\n  head: 362\n  capacity: 1954\n}\narcs {\n  tail: 163\n  head: 145\n  capacity: 42689\n}\narcs {\n  tail: 163\n  head: 164\n  capacity: 4520083\n}\narcs {\n  tail: 163\n  head: 144\n  capacity: 53463\n}\narcs {\n  tail: 163\n  head: 265\n  capacity: 508235\n}\narcs {\n  tail: 163\n  head: 162\n  capacity: 1833016\n}\narcs {\n  tail: 163\n  head: 264\n  capacity: 312783\n}\narcs {\n  tail: 163\n  head: 143\n  capacity: 707757\n}\narcs {\n  tail: 361\n  head: 353\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 353\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 334\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 334\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 315\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 315\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 296\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 296\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 277\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 277\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 258\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 258\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 239\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 239\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 220\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 220\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 201\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 201\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 144\n  capacity: 3623\n}\narcs {\n  tail: 144\n  head: 362\n  capacity: 96376\n}\narcs {\n  tail: 144\n  head: 145\n  capacity: 850047\n}\narcs {\n  tail: 144\n  head: 126\n  capacity: 595661\n}\narcs {\n  tail: 144\n  head: 163\n  capacity: 53463\n}\narcs {\n  tail: 144\n  head: 125\n  capacity: 976326\n}\narcs {\n  tail: 144\n  head: 143\n  capacity: 52725\n}\narcs {\n  tail: 144\n  head: 124\n  capacity: 387546\n}\narcs {\n  tail: 361\n  head: 182\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 182\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 11\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 11\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 49\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 49\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 67\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 67\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 352\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 352\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 333\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 333\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 314\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 314\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 295\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 295\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 276\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 276\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 257\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 257\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 238\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 238\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 219\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 219\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 200\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 200\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 29\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 29\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 181\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 181\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 225\n  capacity: 83668\n}\narcs {\n  tail: 225\n  head: 362\n  capacity: 16331\n}\narcs {\n  tail: 225\n  head: 245\n  capacity: 95262\n}\narcs {\n  tail: 225\n  head: 226\n  capacity: 571036\n}\narcs {\n  tail: 225\n  head: 17\n  capacity: 596578\n}\narcs {\n  tail: 225\n  head: 28\n  capacity: 34467\n}\narcs {\n  tail: 225\n  head: 207\n  capacity: 133091\n}\narcs {\n  tail: 225\n  head: 9\n  capacity: 571741\n}\narcs {\n  tail: 225\n  head: 224\n  capacity: 3842\n}\narcs {\n  tail: 225\n  head: 244\n  capacity: 1024334\n}\narcs {\n  tail: 361\n  head: 86\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 86\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 264\n  capacity: 90916\n}\narcs {\n  tail: 264\n  head: 362\n  capacity: 9083\n}\narcs {\n  tail: 264\n  head: 265\n  capacity: 2275400\n}\narcs {\n  tail: 264\n  head: 163\n  capacity: 156391\n}\narcs {\n  tail: 264\n  head: 164\n  capacity: 1378620\n}\narcs {\n  tail: 264\n  head: 244\n  capacity: 449184\n}\narcs {\n  tail: 264\n  head: 245\n  capacity: 259697\n}\narcs {\n  tail: 264\n  head: 47\n  capacity: 265261\n}\narcs {\n  tail: 361\n  head: 48\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 48\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 123\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 123\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 10\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 10\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 161\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 161\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 351\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 351\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 332\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 332\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 313\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 313\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 294\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 294\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 275\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 275\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 256\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 256\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 237\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 237\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 218\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 218\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 199\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 199\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 180\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 180\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 66\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 66\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 28\n  capacity: 99262\n}\narcs {\n  tail: 28\n  head: 362\n  capacity: 737\n}\narcs {\n  tail: 28\n  head: 244\n  capacity: 346421\n}\narcs {\n  tail: 28\n  head: 47\n  capacity: 2856042\n}\narcs {\n  tail: 28\n  head: 225\n  capacity: 68934\n}\narcs {\n  tail: 28\n  head: 27\n  capacity: 254068\n}\narcs {\n  tail: 28\n  head: 9\n  capacity: 3836796\n}\narcs {\n  tail: 361\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Tests for OR-Tools SAT Solver\nDESCRIPTION: Conditional block that adds Java tests when BUILD_TESTING is enabled. It identifies test files by the 'Test.java' suffix pattern and adds each as a test target.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/java/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB JAVA_SRCS \"*Test.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building and Running OR-Tools C++ Examples\nDESCRIPTION: Commands for building and running C++ examples from the top directory of the OR-Tools project. The user needs to replace <example>.cc with the actual example file name.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/cpp/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake build SOURCE=examples/cpp/<example>.cc\nmake run SOURCE=examples/cpp/<example>.cc\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Library for Second Order Cone Constraints\nDESCRIPTION: Sets up a CMake object library for second-order cone constraints in the math optimization module. Configures source files, include directories, and links required dependencies like Abseil strings and math optimization protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/second_order_cone/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_constraints_second_order_cone)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*_test.cc\")\n\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Boolean OR Constraint in C#\nDESCRIPTION: Demonstrates how to implement a boolean OR constraint between variables in C# using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing Google.OrTools.Sat;\n\npublic class BoolOrSampleSat\n{\n    static void Main()\n    {\n        CpModel model = new CpModel();\n\n        BoolVar x = model.NewBoolVar(\"x\");\n        BoolVar y = model.NewBoolVar(\"y\");\n\n        model.AddBoolOr(new ILiteral[] { x, y.Not() });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding SWIG Python Library for OR-Tools Routing Module in CMake\nDESCRIPTION: Adds a SWIG Python library named pywrapcp for the routing module, specifying the type, language, output directory, and source file.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nswig_add_library(pywrapcp\n  TYPE MODULE\n  LANGUAGE python\n  OUTPUT_DIR ${PYTHON_PROJECT_DIR}/constraint_solver\n  SOURCES routing.i)\n```\n\n----------------------------------------\n\nTITLE: Building OR-Tools with Dependencies\nDESCRIPTION: Example commands for generating build files with dependencies enabled in a new build directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncmake -S. -Bbuild -DBUILD_DEPS:BOOL=ON\n```\n\nLANGUAGE: sh\nCODE:\n```\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Time Schedule Data Array in JavaScript\nDESCRIPTION: Array of schedule entries where each entry contains ID, start time (HH:MM), end time (HH:MM), start minutes (from midnight), end minutes (from midnight), and duration in minutes. Data appears to represent some kind of scheduling or transit timing information.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n[\n    [136, \"06:18\", \"07:38\", 378, 458, 80],\n    [137, \"06:18\", \"07:02\", 378, 422, 44],\n    [138, \"06:19\", \"06:53\", 379, 413, 34],\n    [...],\n    [367, \"08:46\", \"09:30\", 526, 570, 44]\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Properties for JNI Library\nDESCRIPTION: Sets up target include directories and properties for the JNI constraint solver library. Configures position-independent code and links against the core OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(jniconstraint_solver PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jniconstraint_solver PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jniconstraint_solver PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Variables and Literals in C++\nDESCRIPTION: Shows how to create a boolean variable and its negation (literal) in C++ using the CP-SAT solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid LiteralSampleSat() {\n  CpModelBuilder cp_model;\n\n  const BoolVar x = cp_model.NewBoolVar().WithName(\"x\");\n  const BoolVar not_x = ~x;\n  LOG(INFO) << \"x = \" << x << \", not(x) = \" << not_x;\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::LiteralSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules for Nonogram Solver\nDESCRIPTION: This snippet imports the necessary modules from OR-Tools for implementing the Nonogram solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table2.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Output and solution handling for bin packing model\nDESCRIPTION: Handles the solution output for the bin packing model. It writes the model to a proto file if specified, solves the model using the CP-SAT solver, and reports the solution by extracting coordinates and dimensions of the used items if a feasible or optimal solution is found.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n    # Output proto to file.\n    if _OUTPUT_PROTO.value:\n        print(f\"Writing proto to {_OUTPUT_PROTO.value}\")\n        with open(_OUTPUT_PROTO.value, \"w\") as text_file:\n            text_file.write(str(model))\n\n    # solve model.\n    solver = cp_model.CpSolver()\n    if _PARAMS.value:\n        text_format.Parse(_PARAMS.value, solver.parameters)\n\n    status = solver.solve(model)\n\n    # Report solution.\n    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n        used = {i for i in range(num_items) if solver.boolean_value(is_used[i])}\n        data = pd.DataFrame(\n            {\n                \"x_start\": [solver.value(x_starts[i]) for i in used],\n                \"y_start\": [solver.value(y_starts[i]) for i in used],\n                \"item_width\": [solver.value(x_sizes[i]) for i in used],\n                \"item_height\": [solver.value(y_sizes[i]) for i in used],\n                \"x_end\": [solver.value(x_ends[i]) for i in used],\n                \"y_end\": [solver.value(y_ends[i]) for i in used],\n                \"item_value\": [item_values[i] for i in used],\n            }\n        )\n        print(data)\n```\n\n----------------------------------------\n\nTITLE: Configuring Solve Executable Build\nDESCRIPTION: Sets up the build configuration for the 'solve' executable, including source files, include paths, and linking against the OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(solve)\ntarget_sources(solve PRIVATE \"solve.cc\")\ntarget_include_directories(solve PRIVATE\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>\n)\ntarget_compile_features(solve PRIVATE cxx_std_17)\ntarget_link_libraries(solve PRIVATE ${PROJECT_NAMESPACE}::ortools)\n```\n\n----------------------------------------\n\nTITLE: Required Python Dependencies List\nDESCRIPTION: List of required Python packages including OR-Tools core library, plotting libraries (matplotlib, plotly), and SVG generation library.\nSOURCE: https://github.com/google/or-tools/blob/stable/binder/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nortools\nmatplotlib\nplotly\nsvgwrite\n```\n\n----------------------------------------\n\nTITLE: Building the OR-Tools Project\nDESCRIPTION: Command to build the OR-Tools project using the generated CMake files with verbose output. This compiles the source code according to the previous configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncmake --build build --config Release -v\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip package manager\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square_and_cards.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Properties for JNI Algorithms in CMake\nDESCRIPTION: Sets include directories, position-independent code, and links the OR-Tools library for the jnialgorithms target.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(jnialgorithms PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jnialgorithms PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jnialgorithms PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring Xpress Solver Test for OR-Tools\nDESCRIPTION: Begins the setup of a test target for the Xpress solver implementation with conditional compilation based on Xpress availability. The implementation appears to be incomplete as only the NAME and SOURCES sections are started but not completed.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_XPRESS)\n  ortools_cxx_test(\n          NAME\n          math_opt_solvers_xpress_solver_test\n          SOURCES\n\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for OR-Tools .NET Init Module\nDESCRIPTION: Sets up SWIG properties for the initialization module including C++ support, module naming, compile definitions, and namespace configuration for .NET bindings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE init.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE init.i PROPERTY SWIG_MODULE_NAME operations_research_init)\nset_property(SOURCE init.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE init.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.Init\n  -dllimport google-ortools-native)\n```\n\n----------------------------------------\n\nTITLE: OR-Tools Data Matrix Input\nDESCRIPTION: A matrix of numerical values used for optimization. First line contains three parameters (10 5 20). Each subsequent line contains 8 values representing scheduling constraints including start time, end time, weight, and other parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/testdata/jb1.txt#2025-04-17_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n10 5 20\n0 51 3.29366 2 1 14 3 12\n26 69 2.86608 2 1 16 3 7\n65 83 1.18374 2 1 4 3 7\n102 124 2.17731 2 1 8 3 11\n107 131 1.7482 2 1 11 3 4\n110 135 4.59919 2 1 19 3 15\n143 183 2.45267 2 1 11 3 10\n144 174 2.34298 2 1 9 3 10\n148 175 2.64486 2 1 14 3 9\n165 191 2.13535 2 1 9 3 7\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Test Matchers Library in CMake\nDESCRIPTION: Sets up a static library for testing matchers using the ortools_cxx_library macro. Links against Google Test/Mock framework and Abseil libraries for testing functionality.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/cpp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nortools_cxx_library(\n  NAME\n    math_opt_matchers\n  SOURCES\n    \"matchers.cc\"\n    \"matchers.h\"\n  TYPE\n    STATIC\n  LINK_LIBRARIES\n    absl::log\n    absl::status\n    absl::strings\n    GTest::gmock\n  TESTING\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Large Capacity Flow Problem in C++ using OR-Tools\nDESCRIPTION: This snippet creates a FlowGraph object and adds arcs with int64_t::max capacity to test edge cases. It sets up a simple network with two nodes and an arc between them, using the maximum possible capacity value.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nFlowGraph graph(2);\ngraph.AddArc(0, 1, std::numeric_limits<int64_t>::max());\nFLOW_TYPE flow = graph.GetMaxFlow(0, 1);\nLOG(INFO) << \"flow=\" << flow;\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Variables and Literals in Go\nDESCRIPTION: Demonstrates how to create a boolean variable and its negation (literal) in Go using the CP-SAT solver from OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/boolean_logic.md#2025-04-17_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\n// The literal_sample_sat command is a simple example of literals.\npackage main\n\nimport (\n\tlog \"github.com/golang/glog\"\n\t\"github.com/google/or-tools/ortools/sat/go/cpmodel\"\n)\n\nfunc literalSampleSat() {\n\tmodel := cpmodel.NewCpModelBuilder()\n\n\tx := model.NewBoolVar().WithName(\"x\")\n\tnotX := x.Not()\n\n\tlog.Infof(\"x = %d, x.Not() = %d\", x.Index(), notX.Index())\n}\n\nfunc main() {\n\tliteralSampleSat()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Library for OR-Tools SAT in .NET\nDESCRIPTION: Defines the SWIG library for the SAT solver targeting C#. Specifies the output directory within the .NET project structure and the source interface file to process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nswig_add_library(dotnet_sat\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/sat\n  SOURCES sat.i)\n```\n\n----------------------------------------\n\nTITLE: Early Return for Non-Example Builds in CMake\nDESCRIPTION: Checks if examples should be built at all and returns early if not. This prevents the rest of the file from being processed when examples are not needed, improving build efficiency.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/contrib/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_EXAMPLES)\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Command to install the Google OR-Tools package in a Colab environment. This package provides the constraint solver and routing library needed for the VRP implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_global_span.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Linear Solver Library Properties\nDESCRIPTION: Configures target properties for the linear solver library including SWIG include directories and position independent code settings. Links against the core OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(dotnet_linear_solver PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_linear_solver PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: SAT Solver Parameters Configuration\nDESCRIPTION: Protocol buffer definition containing configuration parameters for the SAT solver, including settings for max-SAT and CP operations.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/README.md#2025-04-17_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nsat_parameters.proto\n```\n\n----------------------------------------\n\nTITLE: Cloning the OR-Tools Repository\nDESCRIPTION: Commands to clone the OR-Tools repository from GitHub and change to the project directory. This is the first step in building the project from source.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/google/or-tools.git\ncd or-tools\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Hidato Solver\nDESCRIPTION: Imports the necessary modules from the OR-Tools library to use the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/hidato.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Examples Build in CMake for Google OR-Tools\nDESCRIPTION: This CMake script controls the build process for .NET examples in Google OR-Tools. It first checks if .NET examples should be built using the BUILD_DOTNET_EXAMPLES flag. If enabled, it finds all .cs files in the directory and adds each one as a .NET example using the add_dotnet_example function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/dotnet/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BUILD_DOTNET_EXAMPLES)\n  return()\nendif()\n\nfile(GLOB DOTNET_SRCS \"*.cs\")\nforeach(FILE_NAME IN LISTS DOTNET_SRCS)\n  add_dotnet_example(FILE_NAME ${FILE_NAME})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring jnigraph Target Properties in CMake\nDESCRIPTION: Sets include directories, position-independent code, and links the jnigraph target with the ortools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(jnigraph PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jnigraph PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jnigraph PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Solver .NET Bindings with SWIG\nDESCRIPTION: Sets up SWIG properties and creates a library for the linear solver component. Configures C++ support, module naming, compilation definitions, and namespace options for .NET integration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE linear_solver.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE linear_solver.i PROPERTY SWIG_MODULE_NAME operations_research_linear_solver)\nset_property(SOURCE linear_solver.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE linear_solver.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.LinearSolver\n  -dllimport google-ortools-native)\nswig_add_library(dotnet_linear_solver\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/linear_solver\n  SOURCES linear_solver.i)\n```\n\n----------------------------------------\n\nTITLE: CSV Results Output Function for Sports Schedule\nDESCRIPTION: Defines a function 'csv_dump_results' that takes solver results and outputs them to a CSV file. It handles file naming and writes schedule data including day, game number, home team, and away team.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef csv_dump_results(solver, fixtures, num_teams, num_matchdays, csv_basename):\n    matchdays = range(num_matchdays)\n    teams = range(num_teams)\n\n    vcsv = []\n    for d in matchdays:\n        game = 0\n        for home in range(num_teams):\n            for away in range(num_teams):\n                if solver.Value(fixtures[d][home][away]):\n                    game += 1\n                    # each row: day,game,home,away\n                    row = {\n                        'day': d + 1,\n                        'game': game,\n                        'home': home + 1,\n                        'away': away + 1\n                    }\n                    vcsv.append(row)\n\n    # check for any existing file\n    idx = 1\n    checkname = csv_basename\n    match = re.search(r\"\\.csv\", checkname)\n    if not match:\n        print(\n            'looking for a .csv ending in passed in CSV file name.  Did not find it, so appending .csv to',\n            csv_basename)\n        csv_basename += \".csv\"\n\n    checkname = csv_basename\n    while os.path.exists(checkname):\n        checkname = re.sub(r\"\\.csv\", \"_{}.csv\".format(idx), csv_basename)\n        idx += 1\n        # or just get rid of it, but that is often undesireable\n        # os.unlink(csv_basename)\n\n    with open(checkname, 'w', newline='') as csvfile:\n        fieldnames = ['day', 'game', 'home', 'away']\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n\n        writer.writeheader()\n        for row in vcsv:\n            writer.writerow(row)\n```\n\n----------------------------------------\n\nTITLE: Screen Output Function for Sports Schedule Results\nDESCRIPTION: Defines a function 'screen_dump_results' that prints the scheduling results to the console, including day, game number, home team, and away team for each match.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef screen_dump_results(solver, fixtures, num_teams, num_matchdays):\n    matchdays = range(num_matchdays)\n    teams = range(num_teams)\n\n    total_games = 0\n    for d in matchdays:\n        game = 0\n        for home in teams:\n            for away in teams:\n                match_on = solver.Value(fixtures[d][home][away])\n                if match_on:\n                    game += 1\n                    print('day %i game %i home %i away %i' %\n                          (d + 1, game, home + 1, away + 1))\n        total_games += game\n```\n\n----------------------------------------\n\nTITLE: Running Tests on the Built Project\nDESCRIPTION: Command to run tests on the built OR-Tools project. This step is optional but helps verify that the build was successful.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncmake --build build --target test\n```\n\n----------------------------------------\n\nTITLE: Adding Python Tests Configuration\nDESCRIPTION: Configures Python test files discovery and execution when BUILD_TESTING is enabled. Automatically adds tests for all Python files ending with _test.py.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries to CP Model Helper PyBind11 Module in CMake\nDESCRIPTION: Links required libraries to the CP Model Helper PyBind11 module, including the OR-Tools library, PyBind11 native proto caster, and Protocol Buffers library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(cp_model_helper_pybind11 PRIVATE\n  ${PROJECT_NAMESPACE}::ortools\n  pybind11_native_proto_caster\n  protobuf::libprotobuf)\n```\n\n----------------------------------------\n\nTITLE: Defining Makefile Variables for Optional OR-Tools Solvers\nDESCRIPTION: This snippet shows the Makefile variables used to specify the installation directories for optional third-party solvers in OR-Tools. These solvers are disabled by default and may require specific licenses.\nSOURCE: https://github.com/google/or-tools/blob/stable/makefiles/README.md#2025-04-17_snippet_1\n\nLANGUAGE: makefile\nCODE:\n```\nUNIX_CPLEX_DIR\nWINDOWS_CPLEX_DIR\nUNIX_GLPK_DIR\nWINDOWS_GLPK_DIR\nUNIX_GUROBI_DIR\nWINDOWS_GUROBI_DIR\nUNIX_XPRESS_DIR\nWINDOWS_XPRESS_DIR\n```\n\n----------------------------------------\n\nTITLE: External Dependency Configuration Settings\nDESCRIPTION: Global CMake configuration settings for external dependencies including shared library builds, position independent code, and testing configurations.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(FetchContent)\nset(FETCHCONTENT_QUIET OFF)\nset(FETCHCONTENT_UPDATES_DISCONNECTED ON)\nset(BUILD_SHARED_LIBS ON)\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\nset(BUILD_TESTING OFF)\nset(CMAKE_Fortran_COMPILER OFF)\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Java Bindings\nDESCRIPTION: Sets up SWIG interface properties for generating Java bindings, including C++ support, module naming, and compilation definitions.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE init.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE init.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE init.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE init.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.init)\n```\n\n----------------------------------------\n\nTITLE: Core CP Model Structure in Protocol Buffers\nDESCRIPTION: Proto file defining the structure for general Constraint Programming models. Used as the primary model representation format.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/README.md#2025-04-17_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\ncp_model.proto\n```\n\n----------------------------------------\n\nTITLE: Setting Platform-Specific RPATH Configuration\nDESCRIPTION: Configures RPATH settings for macOS and Unix platforms to ensure proper runtime library loading. Uses platform-specific paths and loader configurations.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/packing/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(GNUInstallDirs)\nif(APPLE)\n  set_target_properties(vector_bin_packing PROPERTIES INSTALL_RPATH\n    \"@loader_path/../${CMAKE_INSTALL_LIBDIR};@loader_path\")\nelseif(UNIX)\n  cmake_path(RELATIVE_PATH CMAKE_INSTALL_FULL_LIBDIR\n             BASE_DIRECTORY ${CMAKE_INSTALL_FULL_BINDIR}\n             OUTPUT_VARIABLE libdir_relative_path)\n  set_target_properties(vector_bin_packing PROPERTIES\n                        INSTALL_RPATH \"$ORIGIN/${libdir_relative_path}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Tests for OR-Tools Graph Library in CMake\nDESCRIPTION: This snippet sets up test configurations for the graph library, including file selection, test naming, and linking necessary libraries. It also includes a special configuration for the max flow test.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  list(FILTER _TEST_SRCS EXCLUDE REGEX \"max_flow_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        graph_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        benchmark::benchmark\n        GTest::gtest\n        GTest::gtest_main\n        GTest::gmock\n    )\n  endforeach()\n  ortools_cxx_test(\n    NAME\n      graph_max_flow_test\n    SOURCES\n      \"max_flow_test.cc\"\n    LINK_LIBRARIES\n      benchmark::benchmark\n      GTest::gtest\n      GTest::gtest_main\n      GTest::gmock\n    COMPILE_DEFINITIONS\n    -DROOT_DIR=\"$<$<BOOL:${isMultiConfig}>:../>../../\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Apache 2.0 License Header Text\nDESCRIPTION: Standard Apache 2.0 license header with Google LLC copyright notice, used for source code files in the OR-Tools project.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright 2025 Google LLC.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Sorted Interval List in CMake\nDESCRIPTION: Sets SWIG source file properties for the sorted_interval_list interface file, including C++ mode, module name, and compile definitions. These configurations ensure the SWIG wrapper is generated correctly for the C# bindings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE sorted_interval_list.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE sorted_interval_list.i PROPERTY SWIG_MODULE_NAME operations_research_util)\nset_property(SOURCE sorted_interval_list.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE sorted_interval_list.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.Util\n  -dllimport google-ortools-native)\n```\n\n----------------------------------------\n\nTITLE: Initializing Boolean Variables in OR-Tools SAT - Python\nDESCRIPTION: This snippet demonstrates how to create a Boolean variable using the OR-Tools SAT solver. It initializes the model, defines a Boolean variable, and creates its negation. The expected output is the representation of the variable and its negation printed to the console.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/literal_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\ndef literal_sample_sat():\n    model = cp_model.CpModel()\n    x = model.new_bool_var(\"x\")\n    not_x = ~x\n    print(x)\n    print(not_x)\n\nliteral_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Configuring Constraint Solver Library Build in CMake for Google OR-Tools\nDESCRIPTION: This CMake snippet configures the build process for the constraint solver library in Google OR-Tools. It sets up the library target, defines compiler options, and specifies include directories and dependencies. The library is built as an object library with position-independent code.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_constraint_solver)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\nif(MSVC AND BUILD_SHARED_LIBS)\n  target_compile_definitions(${NAME} PUBLIC \"OR_BUILD_DLL\")\n  target_compile_definitions(${NAME} PRIVATE \"OR_EXPORT\")\nendif()\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  ZLIB::ZLIB\n  absl::base\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::constraint_solver ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for OR-Tools Python Package\nDESCRIPTION: Shows the file structure after decompressing the OR-Tools archive, including license, documentation, and example directories.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.python.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nor-tools/\n  [LICENSE](LICENSE)                     <- Apache License.\n  [README.md](README.md)                 <- This file.\n  [examples/python](examples/python)     <- Python examples.\n  [examples/notebook](examples/notebook) <- Jupyter/IPython notebooks.\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for De Bruijn Sequence Generation\nDESCRIPTION: Imports the necessary modules from the ortools library to use the constraint solver functionality.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/debruijn_binary.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Example Builds in CMake for OR-Tools\nDESCRIPTION: Finds all Java source files with the .java extension and adds them as examples to the build system using the add_java_example function. This block is only executed when the BUILD_JAVA_EXAMPLES option is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/contrib/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_JAVA_EXAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Tests for RCPSP Module in CMake\nDESCRIPTION: Sets up testing for the RCPSP module by finding all Python test files and adding them as tests. This is only executed if BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/python/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building .NET Packages for OR-Tools with CMake\nDESCRIPTION: Commands to build .NET Standard 2.0 native NuGet packages for Google OR-Tools using CMake. This builds packages for multiple platforms (win-x64, linux-x64, osx-x64).\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/dotnet.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncmake -S. -Bbuild -DBUILD_DOTNET=ON\ncmake --build build --target dotnet_package -v\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Sports Scheduling\nDESCRIPTION: Imports necessary Python libraries including argparse for command-line arguments, os and re for file handling, csv for output, math for calculations, and cp_model from OR-Tools for constraint programming.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nimport os\nimport re\nimport csv\nimport math\n\nfrom ortools.sat.python import cp_model\n```\n\n----------------------------------------\n\nTITLE: Building Java Package with CMake\nDESCRIPTION: Commands to build the Java maven packages using CMake. Requires JAVA_HOME environment variable to be set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/java.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S. -Bbuild -DBUILD_JAVA=ON\ncmake --build build --target java_package -v\n```\n\n----------------------------------------\n\nTITLE: Python Sample Build Configuration\nDESCRIPTION: Sets up build process for Python samples by globbing all .py files and adding each as a sample using add_python_sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/samples/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package via pip in a Google Colab environment. OR-Tools is required to solve linear programming problems using the GLOP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/basic_example.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Cgl Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build Cgl library. It specifies the git repository, version tag, and applies a patch. This is conditionally executed if BUILD_Cgl is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_Cgl)\n  message(CHECK_START \"Fetching Cgl\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    Cgl\n    GIT_REPOSITORY \"https://github.com/Mizux/Cgl.git\"\n    GIT_TAG \"cmake/0.60.9\"\n    GIT_SHALLOW TRUE\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/cgl-0.60.patch\")\n  FetchContent_MakeAvailable(Cgl)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Makefile Variables for OR-Tools Dependencies\nDESCRIPTION: This snippet shows the Makefile variables used to specify the installation directories for various OR-Tools dependencies. These variables allow users to use their own compiled versions of the dependencies instead of the default third-party builds.\nSOURCE: https://github.com/google/or-tools/blob/stable/makefiles/README.md#2025-04-17_snippet_0\n\nLANGUAGE: makefile\nCODE:\n```\nUNIX_ZLIB_DIR\nWINDOWS_ZLIB_DIR\nUNIX_ABSL_DIR\nWINDOWS_ABSL_DIR\nUNIX_PROTOBUF_DIR\nWINDOWS_PROTOBUF_DIR\nUNIX_SCIP_DIR\nWINDOWS_SCIP_DIR\nUNIX_COINUTILS_DIR\nWINDOWS_COINUTILS_DIR\nUNIX_OSI_DIR\nWINDOWS_OSI_DIR\nUNIX_CLP_DIR\nWINDOWS_CLP_DIR\nUNIX_CGL_DIR\nWINDOWS_CGL_DIR\nUNIX_CBC_DIR\nWINDOWS_CBC_DIR\n```\n\n----------------------------------------\n\nTITLE: Warning Messages Based on CPU Core Usage in Python\nDESCRIPTION: This snippet includes conditional print statements that inform the user about the CPU core utilization in relation to the OR-Tools CP-SAT solver's tuning. It checks if the specified number of workers is less than the available CPUs and suggests using the `--cpu` option for potentially faster results. It also warns the user if they are using more workers than the solver is tuned for, which could impact performance.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nif cpu != 6:\n        # don't whinge at user if cpu is set to 6\n        if cpu < ncpu:\n            print(\n                'Using %i workers, but there are %i CPUs available.  You might get faster results by using the command line option --cpu %i, but be aware ORTools CP-SAT solver is tuned to 6 CPUs'\n                % (cpu, ncpu, ncpu))\n\n        if cpu > 6:\n            print(\n                'Using %i workers.  Be aware ORTools CP-SAT solver is tuned to 6 CPUs'\n                % cpu)\n```\n\n----------------------------------------\n\nTITLE: Building .NET Samples in OR-Tools\nDESCRIPTION: Finds all C# source files with .cs extension and builds them using add_dotnet_sample function when BUILD_DOTNET_SAMPLES is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/samples/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_DOTNET_SAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  foreach(SAMPLE IN LISTS DOTNET_SRCS)\n    add_dotnet_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Maven Package\nDESCRIPTION: Commands to build and install the Maven package locally\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/java/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmvn package\nmvn install\n```\n\n----------------------------------------\n\nTITLE: Native Content Package Configuration\nDESCRIPTION: Configuration for including native shared libraries in the NuGet package under the appropriate runtime folder.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_1\n\nLANGUAGE: csproj\nCODE:\n```\n<Content Include=\"*.so\">\n  <PackagePath>runtimes/linux-x64/native/%(Filename)%(Extension)</PackagePath>\n  <Pack>true</Pack>\n  <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n</Content>\n```\n\n----------------------------------------\n\nTITLE: QEMU ARM64 Emulation Setup\nDESCRIPTION: Commands to enable and test ARM64 (aarch64) container support on x86_64 machines using QEMU emulation.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/docker/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndocker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n```\n\nLANGUAGE: shell\nCODE:\n```\ndocker run --platform linux/arm64 --rm --init -it ubuntu:latest bash -c \"uname -a\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package with pip\nDESCRIPTION: Installs the Google OR-Tools optimization package from PyPI using pip within a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/maximize_combinations_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Builds for Math Optimization Constraints\nDESCRIPTION: Sets up test configuration for the math optimization constraints utility library. Includes test file discovery and configuration of test targets with Google Test framework dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/util/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        math_opt_constraints_util_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        #benchmark::benchmark\n        GTest::gmock\n        GTest::gtest_main\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Implementing CP-SAT Solver in Java\nDESCRIPTION: Demonstrates CP-SAT solver usage in Java with CpModel and CpSolver classes. Creates a constraint satisfaction problem with three variables and inequality constraint.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/README.md#2025-04-17_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.IntVar;\n\n/** Minimal CP-SAT example to showcase calling the solver. */\npublic final class SimpleSatProgram {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the model.\n    CpModel model = new CpModel();\n\n    // Create the variables.\n    int numVals = 3;\n\n    IntVar x = model.newIntVar(0, numVals - 1, \"x\");\n    IntVar y = model.newIntVar(0, numVals - 1, \"y\");\n    IntVar z = model.newIntVar(0, numVals - 1, \"z\");\n\n    // Create the constraints.\n    model.addDifferent(x, y);\n\n    // Create a solver and solve the model.\n    CpSolver solver = new CpSolver();\n    CpSolverStatus status = solver.solve(model);\n\n    if (status == CpSolverStatus.OPTIMAL || status == CpSolverStatus.FEASIBLE) {\n      System.out.println(\"x = \" + solver.value(x));\n      System.out.println(\"y = \" + solver.value(y));\n      System.out.println(\"z = \" + solver.value(z));\n    } else {\n      System.out.println(\"No solution found.\");\n    }\n  }\n\n  private SimpleSatProgram() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Library Dependencies and Include Paths\nDESCRIPTION: Configures include directories and links required dependencies like Abseil, Protobuf, and various solver backends (COINOR, CPLEX, GLPK, etc.).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::strings\n  absl::status\n  absl::str_format\n  protobuf::libprotobuf\n  $<$<BOOL:${USE_COINOR}>:Coin::Cbc>\n  $<$<BOOL:${USE_COINOR}>:Coin::Clp>\n  $<$<BOOL:${USE_CPLEX}>:CPLEX::CPLEX>\n  $<$<BOOL:${USE_GLPK}>:GLPK::GLPK>\n  $<$<BOOL:${USE_HIGHS}>:highs::highs>\n  $<$<BOOL:${USE_PDLP}>:Eigen3::Eigen>\n  $<$<BOOL:${USE_SCIP}>:libscip>\n  ${PROJECT_NAMESPACE}::ortools_proto)\n```\n\n----------------------------------------\n\nTITLE: Routing File Structure Reference\nDESCRIPTION: Key file references for the vehicle routing implementation, including the main routing header, parameter definitions, and solution handling.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n../constraint_solver/routing.h\n../constraint_solver/routing_parameters.proto\n../constraint_solver/routing_enums.proto\n../constraint_solver/assignment.proto\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Sample Builds for OR-Tools\nDESCRIPTION: This snippet sets up the compilation of Java samples for OR-Tools. It glob matches all .java files and adds each sample to the build process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/samples/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_JAVA_SAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(SAMPLE IN LISTS JAVA_SRCS)\n    add_java_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: CMake Integration with add_subdirectory\nDESCRIPTION: Example showing how to incorporate OR-Tools directly into a CMake project using add_subdirectory().\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.18)\nproject(myproj VERSION 1.0)\n\nadd_subdirectory(or-tools)\n\nadd_executable(myapp main.cpp)\ntarget_link_libraries(myapp ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific RPATH Configuration\nDESCRIPTION: Sets platform-specific RPATH properties for macOS and Unix systems to ensure proper runtime library loading paths\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/core/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(APPLE)\n  set_target_properties(math_opt_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH\n      \"@loader_path;@loader_path/../../../../${PYTHON_PROJECT}/.libs;@loader_path/../../../../pybind11_abseil\")\nelseif(UNIX)\n  set_target_properties(math_opt_pybind11 PROPERTIES\n    INSTALL_RPATH\n    \"$ORIGIN:$ORIGIN/../../../../${PYTHON_PROJECT}/.libs:$ORIGIN/../../../../pybind11_abseil\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Demon Profiler Protocol Buffer\nDESCRIPTION: Protocol buffer definition for capturing execution profiles and timelines of constraints and demons (daemons) in the CP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/README.md#2025-04-17_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\ndemon_profiler.proto\n```\n\n----------------------------------------\n\nTITLE: Conditional Sample Building for Multiple Languages in OR-Tools\nDESCRIPTION: This CMake script conditionally builds samples for C++, Python, Java, and .NET based on build flags. It uses glob patterns to find source files and adds samples for each language if the corresponding build flag is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_SAMPLES)\n  return()\nendif()\n\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n\nif(BUILD_JAVA_SAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(SAMPLE IN LISTS JAVA_SRCS)\n    add_java_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n\nif(BUILD_DOTNET_SAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  foreach(SAMPLE IN LISTS DOTNET_SRCS)\n    add_dotnet_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Sample Builds for OR-Tools\nDESCRIPTION: This snippet sets up the compilation of .NET samples for OR-Tools. It glob matches all .cs files and adds each sample to the build process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/samples/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_DOTNET_SAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  foreach(SAMPLE IN LISTS DOTNET_SRCS)\n    add_dotnet_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Google Colab - Python\nDESCRIPTION: This snippet installs the OR-Tools package necessary to run the integer programming example in the Google Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_mip_program_mb.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Callback Data Test for OR-Tools\nDESCRIPTION: Sets up a test target for the message callback data functionality in OR-Tools. This test focuses on the message handling system used by solvers to communicate progress and status information, linking against Abseil synchronization and cleanup libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nortools_cxx_test(\n  NAME\n    math_opt_solvers_message_callback_data_test\n  SOURCES\n    \"message_callback_data_test.cc\"\n  LINK_LIBRARIES\n    GTest::gmock_main\n    absl::cleanup\n    absl::synchronization\n)\n```\n\n----------------------------------------\n\nTITLE: Querying int64_t types on Linux using GCC\nDESCRIPTION: Shell commands to examine how int64_t is defined in GCC on Linux systems. These commands help identify the underlying typedefs used for 64-bit integer types.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngrepc -rn \"typedef.*int64_t;\" /lib/gcc\n/lib/gcc/x86_64-linux-gnu/9/include/stdint-gcc.h:43:typedef __INT64_TYPE__ int64_t;\n/lib/gcc/x86_64-linux-gnu/9/include/stdint-gcc.h:55:typedef __UINT64_TYPE__ uint64_t;\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG .NET Library for Algorithms in CMake\nDESCRIPTION: Adds a SWIG library for .NET algorithms, specifying the language as C#, output directory, and source file. This creates the necessary bindings for the knapsack solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nswig_add_library(dotnet_algorithms\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/algorithms\n  SOURCES knapsack_solver.i)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip package manager\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/costas_array.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Maven Runtime Dependency Configuration\nDESCRIPTION: XML configuration for adding native package runtime dependencies\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/java/README.md#2025-04-17_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n  <groupId>com.google.ortools</groupId>\n  <artifactId>ortools-linux-x86-64</artifactId>\n  <version>[8.0,)</version>\n  <type>jar</type>\n  <scope>runtime</scope>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Conditional Build Configuration for Python Examples in CMake\nDESCRIPTION: This snippet checks if Python examples should be built. If not, it exits the current CMake processing.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_PYTHON_EXAMPLES)\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running Make Command from Top Directory in OR-Tools CI\nDESCRIPTION: Demonstrates how to run the make command from the top-level directory by specifying the bazel subdirectory.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/docs/ci.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmake --directory=bazel\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cryptarithm_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Adding Java Tests for Algorithms in CMake\nDESCRIPTION: Conditionally adds Java tests for all files ending with 'Test.java' if BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/java/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB JAVA_SRCS \"*Test.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining CVRPTW Test Instance Data with Single Solution Constraint\nDESCRIPTION: A structured data format that specifies a test instance for the Capacitated Vehicle Routing Problem with Time Windows. The data includes vehicle capacity, customer locations, demands, and time windows. This particular instance is designed to have only one feasible solution as indicated by the 'TEST_INSTANCE_ONLY_ONE_SOLUTION' annotation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/solomon_check_id.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nTEST_INSTANCE_ONLY_ONE_SOLUTION\n\nVEHICLE\nNUMBER     CAPACITY\n  1          30\n\nCUSTOMER\nCUST NO.  XCOORD.   YCOORD.    DEMAND   READY TIME  DUE DATE   SERVICE   TIME\n\n    0      0         0          0          0       30         0\n    1      2         2         10          3        4         1\n    2      5         5         10          8        9         1\n    3      9         9         10         15       16         1\n```\n\n----------------------------------------\n\nTITLE: Configuring pybind11 Module Build for Math Optimization Solver\nDESCRIPTION: Creates and configures a pybind11 module for the math optimization solver. Sets the output library name and basic properties.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/core/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\npybind11_add_module(math_opt_pybind11 MODULE solver.cc)\nset_target_properties(math_opt_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"solver\")\n```\n\n----------------------------------------\n\nTITLE: Building All Remaining C++ Examples with CMake\nDESCRIPTION: Iterates through the filtered list of C++ source files and calls add_cxx_example for each one. This automates the process of building all valid examples in the directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/cpp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(EXAMPLE IN LISTS CXX_SRCS)\n  add_cxx_example(FILE_NAME ${EXAMPLE})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Running C++ Tests Only\nDESCRIPTION: Commands to navigate to the build directory and run only the C++ tests. This is useful when you want to test just the C++ components of the project.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncd build\nctest -R \"cxx_.*\"\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories in CMake for OR-Tools Components\nDESCRIPTION: CMake commands to include C++ and Python subdirectories in the build process. This establishes the project structure and ensures that both language implementations are built as part of the project.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(cpp)\nadd_subdirectory(python)\n```\n\n----------------------------------------\n\nTITLE: Setting Up OR-Tools Algorithm Tests in CMake\nDESCRIPTION: This snippet configures the test setup for the OR-Tools algorithms library. It selects test source files, excluding stress tests and specific files, and creates individual test targets for each test file using the ortools_cxx_test macro.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  list(FILTER _TEST_SRCS EXCLUDE REGEX \".*_stress_test.cc\")\n  list(FILTER _TEST_SRCS EXCLUDE REGEX \"set_cover_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        algorithms_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        benchmark::benchmark\n        GTest::gtest\n        GTest::gtest_main\n        GTest::gmock\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools optimization package in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code installs the OR-Tools package, which is a prerequisite for running the scheduling model. It expects a Python environment with access to pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cumulative_variable_profile_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Setting OR-Tools Version Numbers\nDESCRIPTION: Defines environment variables for OR-Tools major and minor version numbers, with a commented-out pre-release flag. This is likely used by build scripts to determine version information when compiling or packaging the OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/Version.txt#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nOR_TOOLS_MAJOR=9\nOR_TOOLS_MINOR=12\n#PRE_RELEASE=YES\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the OR-Tools package needed for running the SAT solver model. This is a prerequisite for executing the scheduling problem solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/earliness_tardiness_cost_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequence Constraints with Circuit Constraint\nDESCRIPTION: Defines a function that enforces constraints on sequences of tasks using a circuit constraint. It handles task types, sequence lengths, and cumulative durations.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/sequences_in_no_overlap_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef sequence_constraints_with_circuit(\n    model: cp_model.CpModel,\n    starts: Sequence[cp_model.IntVar],\n    durations: Sequence[int],\n    task_types: Sequence[str],\n    lengths: Sequence[cp_model.IntVar],\n    cumuls: Sequence[cp_model.IntVar],\n    sequence_length_constraints: Dict[str, Tuple[int, int]],\n    sequence_cumul_constraints: Dict[str, Tuple[int, int, int]],\n) -> Sequence[Tuple[cp_model.IntVar, int]]:\n    \"\"\"This method enforces constraints on sequences of tasks of the same type.\n\n    This method assumes that all durations are strictly positive.\n\n    The extra node (with id 0) will be used to decide which task is first with\n    its only outgoing arc, and which task is last with its only incoming arc.\n    Each task i will be associated with id i + 1, and an arc between i + 1 and j +\n    1 indicates that j is the immediate successor of i.\n\n    The circuit constraint ensures there is at most 1 hamiltonian cycle of\n    length > 1. If no such path exists, then no tasks are active.\n    In this simplified model, all tasks must be performed.\n\n    Args:\n      model: The CpModel to add the constraints to.\n      starts: The array of starts variables of all tasks.\n      durations: the durations of all tasks.\n      task_types: The type of all tasks.\n      lengths: the number of tasks of the same type in the current sequence.\n      cumuls: The computed cumul of the current sequence for each task.\n      sequence_length_constraints: the array of tuple (`task_type`, (`length_min`,\n        `length_max`)) that specifies the minimum and maximum length of the\n        sequence of tasks of type `task_type`.\n      sequence_cumul_constraints: the array of tuple (`task_type`, (`soft_max`,\n        `linear_penalty`, `hard_max`)) that specifies that if the cumul of the\n        sequence of tasks of type `task_type` is greater than `soft_max`, then\n        `linear_penalty * (cumul - soft_max)` is added to the cost\n\n    Returns:\n      The list of pairs (integer variables, penalty) to be added to the objective.\n    \"\"\"\n\n    num_tasks = len(starts)\n    all_tasks = range(num_tasks)\n\n    arcs: List[cp_model.ArcT] = []\n    for i in all_tasks:\n        # if node i is first.\n        start_lit = model.new_bool_var(f\"start_{i}\")\n        arcs.append((0, i + 1, start_lit))\n        model.add(lengths[i] == 1).only_enforce_if(start_lit)\n        model.add(cumuls[i] == durations[i]).only_enforce_if(start_lit)\n\n        # As there are no other constraints on the problem, we can add this\n        # redundant constraint. This is not valid in general.\n        model.add(starts[i] == 0).only_enforce_if(start_lit)\n\n        # if node i is last.\n        end_lit = model.new_bool_var(f\"end_{i}\")\n        arcs.append((i + 1, 0, end_lit))\n\n        # Make sure the previous length is within bounds.\n        type_length_min = sequence_length_constraints[task_types[i]][0]\n        model.add(lengths[i] >= type_length_min).only_enforce_if(end_lit)\n\n        for j in all_tasks:\n            if i == j:\n                continue\n            lit = model.new_bool_var(f\"arc_{i}_to_{j}\")\n            arcs.append((i + 1, j + 1, lit))\n\n            # The circuit constraint is use to enforce the consistency between the\n            # precedences relations and the successor arcs. This is implemented by\n            # adding the constraint that force the implication task j is the next of\n            # task i implies that start(j) is greater or equal than the end(i).\n            #\n            # In the majority of problems, the following equality must be an\n            # inequality. In that particular case, as there are no extra constraints,\n            # we can keep the equality between start(j) and end(i).\n            model.add(starts[j] == starts[i] + durations[i]).only_enforce_if(lit)\n\n            # We add the constraints to incrementally maintain the length and the\n            # cumul variables of the sequence.\n            if task_types[i] == task_types[j]:  # Same task type.\n                # Increase the length of the sequence by 1.\n                model.add(lengths[j] == lengths[i] + 1).only_enforce_if(lit)\n\n                # Increase the cumul of the sequence by the duration of the task.\n                model.add(cumuls[j] == cumuls[i] + durations[j]).only_enforce_if(lit)\n\n            else:\n                # Switching task type. task[i] is the last task of the previous\n                # sequence, task[j] is the first task of the new sequence.\n                #\n                # Reset the length to 1.\n                model.add(lengths[j] == 1).only_enforce_if(lit)\n\n                # Make sure the previous length is within bounds.\n                type_length_min = sequence_length_constraints[task_types[i]][0]\n                model.add(lengths[i] >= type_length_min).only_enforce_if(lit)\n\n                # Reset the cumul to the duration of the task.\n                model.add(cumuls[j] == durations[j]).only_enforce_if(lit)\n\n    # Add the circuit constraint.\n    model.add_circuit(arcs)\n\n    # Create the penalty terms. We can penalize each cumul locally.\n    penalty_terms = []\n    for i in all_tasks:\n        # Penalize the cumul of the last task w.r.t. the soft max\n        soft_max, linear_penalty, hard_max = sequence_cumul_constraints[task_types[i]]\n\n        # To make it separable per task, and avoid double counting, we use the\n        # following trick:\n        #     reduced_excess = min(durations[i], max(0, cumul[i] - soft_max))\n        if soft_max < hard_max:\n            excess = model.new_int_var(0, hard_max - soft_max, f\"excess+_{i}\")\n            model.add_max_equality(excess, [0, cumuls[i] - soft_max])\n            reduced_excess = model.new_int_var(0, durations[i], f\"reduced_excess_{i}\")\n            model.add_min_equality(reduced_excess, [durations[i], excess])\n            penalty_terms.append((reduced_excess, linear_penalty))\n\n    return penalty_terms\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the OR-Tools library from PyPI using pip in a Colab notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_programming.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Fat JAR Build Command\nDESCRIPTION: Command to build a dependency-inclusive Maven package (fat JAR)\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/java/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmvn package -Dfatjar=true\n```\n\n----------------------------------------\n\nTITLE: Adding Math Optimization Constraint Subdirectories in CMake\nDESCRIPTION: Adds subdirectories for different constraint types to be included in the build process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(indicator)\nadd_subdirectory(quadratic)\nadd_subdirectory(second_order_cone)\nadd_subdirectory(sos)\nadd_subdirectory(util)\n```\n\n----------------------------------------\n\nTITLE: Running OR-Tools tests with C++20 on Windows using Bazel and MSVC\nDESCRIPTION: Command to run OR-Tools tests on Windows systems using Bazel with MSVC and C++20 support. This command executes all tests with optimization enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/README.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nbazel test -c opt --cxxopt=\"/std:c++20\" ...\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: Installs the OR-Tools package from PyPI using pip within a Jupyter/Colab notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/pell_equation_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Test Compilation\nDESCRIPTION: Conditional block that adds Java tests when BUILD_TESTING is enabled. Glob searches for test files and adds them to the build system.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB JAVA_SRCS \"*Test.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Initializing Solver for Stigler's Diet Problem\nDESCRIPTION: This snippet imports the necessary OR-Tools module and sets up the linear programming solver. It allows selection between different solver backends.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stigler_contrib.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n\n\ndef main(sol=\"CBC\"):\n  # Create the solver.\n  print(\"Solver: \", sol)\n  solver = pywraplp.Solver.CreateSolver(sol)\n  if not solver:\n    return\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Graph Module\nDESCRIPTION: Sets core SWIG properties for the graph interface file including C++ mode, module name, and compile definitions. Also configures .NET namespace and DLL import settings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/csharp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE graph.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE graph.i PROPERTY SWIG_MODULE_NAME operations_research_graph)\nset_property(SOURCE graph.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE graph.i PROPERTY COMPILE_OPTIONS\n  -namespace ${DOTNET_PROJECT}.Graph\n  -dllimport google-ortools-native)\n```\n\n----------------------------------------\n\nTITLE: Configuring Clp Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build Clp library. It specifies the git repository, version tag, and applies a patch. This is conditionally executed if BUILD_Clp is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_Clp)\n  message(CHECK_START \"Fetching Clp\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    Clp\n    GIT_REPOSITORY \"https://github.com/Mizux/Clp.git\"\n    GIT_TAG \"cmake/1.17.10\"\n    GIT_SHALLOW TRUE\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/clp-1.17.patch\")\n  FetchContent_MakeAvailable(Clp)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Destroying Vagrant virtual machine\nDESCRIPTION: Command to stop and delete a Vagrant virtual machine, cleaning up all associated resources. The -f flag forces the operation without confirmation.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nvagrant destroy -f\n```\n\n----------------------------------------\n\nTITLE: Adding .NET Tests Configuration\nDESCRIPTION: Conditionally adds .NET test configurations when BUILD_TESTING is enabled. Glob matches all test files ending with 'Tests.cs' and adds them as .NET tests.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/csharp/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB DOTNET_SRCS \"*Tests.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Optional Interval Creation in OR-Tools SAT\nDESCRIPTION: This code demonstrates how to create optional interval variables using the OR-Tools CP-SAT solver in Python. It initializes a CP model, defines variables for start, end, and presence, and then creates optional interval variables using `new_optional_interval_var` and `new_optional_fixed_size_interval_var`. The function showcases creating intervals with affine expressions and fixed sizes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/optional_interval_sample_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n\n\ndef optional_interval_sample_sat():\n    \"\"\"Showcases how to build optional interval variables.\"\"\"\n    model = cp_model.CpModel()\n    horizon = 100\n\n    # An interval can be created from three affine expressions.\n    start_var = model.new_int_var(0, horizon, \"start\")\n    duration = 10  # Python cp/sat code accept integer variables or constants.\n    end_var = model.new_int_var(0, horizon, \"end\")\n    presence_var = model.new_bool_var(\"presence\")\n    interval_var = model.new_optional_interval_var(\n        start_var, duration, end_var + 2, presence_var, \"interval\"\n    )\n\n    print(f\"interval = {repr(interval_var)}\")\n\n    # If the size is fixed, a simpler version uses the start expression and the\n    # size.\n    fixed_size_interval_var = model.new_optional_fixed_size_interval_var(\n        start_var, 10, presence_var, \"fixed_size_interval_var\"\n    )\n    print(f\"fixed_size_interval_var = {repr(fixed_size_interval_var)}\")\n\n    # A fixed interval can be created using the same API.\n    fixed_interval = model.new_optional_fixed_size_interval_var(\n        5, 10, presence_var, \"fixed_interval\"\n    )\n    print(f\"fixed_interval = {repr(fixed_interval)}\")\n\n\noptional_interval_sample_sat()\n```\n\n----------------------------------------\n\nTITLE: Configuring Core Math Optimization Library in CMake\nDESCRIPTION: Creates an object library for the main mathematical optimization C++ components. Configures source files, include directories, and links against Abseil strings and protobuf dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/cpp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_cpp)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/matchers\\.\")\n\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the ortools package, which is required for solving optimization and constraint programming problems in Python. It is crucial to install this package before running the problem-solving script.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/steel_mill_slab_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for VRP Solver\nDESCRIPTION: Imports necessary modules from OR-Tools library for implementing the VRP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_solution_callback.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport weakref\n\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: Installs the Google OR-Tools package for use in the TSP solver implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/random_tsp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Command to install the OR-Tools package which is required for solving the Vehicle Routing Problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_time_windows_per_vehicles.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting output directory for SWIG Python modules in CMake\nDESCRIPTION: CMake configuration example for specifying a custom output directory for SWIG-generated Python modules. This uses the swig_add_library function with OUTPUT_DIR parameter.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(pyFoo\n  TYPE MODULE\n  LANGUAGE python\n  OUTPUT_DIR ${CMAKE_BINARY_DIR}/python/${PROJECT_NAME}/Foo\n  SOURCES foo.i)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the OR-Tools package using pip in a Jupyter notebook environment, enabling constraint programming capabilities\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assumptions_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Building and Running OrTools .NET Examples using dotnet CLI\nDESCRIPTION: Commands for building and executing OrTools example projects using the .NET Core CLI. The build command compiles the project while the run command executes it without rebuilding.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/dotnet/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet build <example>.csproj\ndotnet run --no-build --project <example>.csproj\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools Modules for VRP in Python\nDESCRIPTION: Imports necessary modules from OR-Tools for solving Vehicle Routing Problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_starts_ends.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Creating pybind11 Module for RCPSP in CMake\nDESCRIPTION: Creates a pybind11 module for the Resource-Constrained Project Scheduling Problem (RCPSP) functionality, setting the output name to 'rcpsp'. This establishes the core module configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(rcpsp_pybind11 MODULE rcpsp.cc)\nset_target_properties(rcpsp_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"rcpsp\")\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools package using pip\nDESCRIPTION: This command installs the ortools package using pip, which is required to run the CP-SAT solver. The `%pip` command is a magic command specifically for use in IPython environments such as Jupyter notebooks or Google Colab.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/reallocate_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Total Vehicle Capacity\nDESCRIPTION: A method that returns the sum of capacity across all vehicles in the fleet. This is useful for comparing against total customer demand to ensure feasibility of the routing problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ndef get_total_capacity(self):\n    return (sum([c.capacity for c in self.vehicles]))\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This code snippet shows how to install the OR-Tools package using pip in a Google Colab environment. It ensures that the necessary library is available before executing the optimization example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cp_sat_example.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Library for OR-Tools Utility in C#\nDESCRIPTION: Creates a SWIG library target for the C# bindings of the utility module. Specifies the output directory and source files for the SWIG-generated wrapper code.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(dotnet_util\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/util\n  SOURCES sorted_interval_list.i)\n```\n\n----------------------------------------\n\nTITLE: Testing Java Package with CTest\nDESCRIPTION: Commands to list and run Java tests using CTest in the build directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/java.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd build\nctest -N\n\ncd build\nctest -R \"java_.*\"\n```\n\n----------------------------------------\n\nTITLE: Vehicle Routing Problem Parameters Dataset\nDESCRIPTION: A dataset containing vehicle routing parameters with 9 columns per entry: ID, x coordinate, y coordinate, demand/load, start time, end time, service time, linked node, and dependency node. Values represent locations, time windows, and scheduling constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/pdptw_LRC2_10_6.txt#2025-04-17_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n903 399 102 20 1008 1248 10 0 861\n904 143 158 12 490 730 10 0 27\n905 18 484 10 1240 1480 10 0 397\n906 250 411 -30 692 932 10 855 0\n907 19 273 25 4006 4246 10 0 911\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Tests\nDESCRIPTION: Sets up Java test configuration when BUILD_TESTING is enabled. Glob pattern matches all test files and adds them to the test suite.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB JAVA_SRCS \"*Test.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OrTools and Running Python Examples\nDESCRIPTION: These shell commands demonstrate how to install the OrTools package using pip and run a Python example. The first command upgrades OrTools to the latest version, and the second command executes a Python script.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/python/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m pip install --upgrade --user ortools\npython3 <example>.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Gurobi Library Target in CMake for OR-Tools\nDESCRIPTION: Sets up the Gurobi library target for OR-Tools, including source files, compiler options, and dependencies. The library is built as an object library with position-independent code and links against various Abseil libraries, Protobuf, and optionally CoinOR.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/gurobi/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_gurobi)\n\nfile(GLOB_RECURSE _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/gurobi_stdout_matchers\\..*$\")\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::hash\n  absl::meta\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto\n  ${PROJECT_NAMESPACE}::math_opt_proto\n  $<$<BOOL:${USE_COINOR}>:Coin::Cbc>)\n#add_library(${PROJECT_NAMESPACE}::gurobi ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/linear_assignment_api.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_capacity.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools optimization package in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/rcpsp_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools Libraries for VRP in Python\nDESCRIPTION: Imports necessary modules from Google OR-Tools for solving Vehicle Routing Problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_breaks_from_start.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: SWIG Java typemaps for int64_t compatibility on Linux\nDESCRIPTION: SWIG code to provide correct typemaps for 64-bit integers in Java bindings on Linux. This addresses the mismatch between SWIG's default mappings and platform-specific int64_t implementations.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_5\n\nLANGUAGE: swig\nCODE:\n```\n#if defined(SWIGJAVA)\n#if defined(SWIGWORDSIZE64)\n%define PRIMITIVE_TYPEMAP(NEW_TYPE, TYPE)\n%clear NEW_TYPE;\n%clear NEW_TYPE *;\n%clear NEW_TYPE &;\n%clear const NEW_TYPE &;\n%apply TYPE { NEW_TYPE };\n%apply TYPE * { NEW_TYPE * };\n%apply TYPE & { NEW_TYPE & };\n%apply const TYPE & { const NEW_TYPE & };\n%enddef // PRIMITIVE_TYPEMAP\nPRIMITIVE_TYPEMAP(long int, long long);\nPRIMITIVE_TYPEMAP(unsigned long int, long long);\n#undef PRIMITIVE_TYPEMAP\n#endif // defined(SWIGWORDSIZE64)\n#endif // defined(SWIGJAVA)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code snippet installs the OR-Tools package, which is required for using Google's CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/grocery.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Listing Tests for OR-Tools Python Package\nDESCRIPTION: This command lists all available tests for the OR-Tools Python package using CTest in the build directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/python.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd build\nctest -N\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the OR-Tools optimization package using pip within a Jupyter/Colab notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_initial_routes.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Tests for PDLP\nDESCRIPTION: Configures Python tests for the PDLP module when BUILD_TESTING is enabled. It finds all Python test files with the *_test.py pattern and adds them as test targets using the add_python_test function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/pdlp/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: The snippet installs the OR-Tools package via pip, which is necessary to use constraint-solving algorithms for the routing problem. No parameters are required and this command should be executed in a Jupyter Notebook or Python environment supporting IPython magics.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/transit_time.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Transportation or Operations Schedule Dataset in JSON format\nDESCRIPTION: A comprehensive dataset containing schedule information with ID numbers, start/end times in HH:MM format, numerical time values, and duration calculations. Each entry is structured as an array containing six values: ID, start time, end time, start in minutes, end in minutes, and duration in minutes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\n    [868, \"15:36\", \"16:21\", 936, 981, 45],\n    [869, \"15:38\", \"16:25\", 938, 985, 47],\n    [870, \"15:38\", \"16:25\", 938, 985, 47],\n    [871, \"15:38\", \"16:39\", 938, 999, 61],\n    [872, \"15:39\", \"16:33\", 939, 993, 54],\n    [873, \"15:40\", \"15:50\", 940, 950, 10],\n    [874, \"15:40\", \"16:51\", 940, 1011, 71],\n    [875, \"15:40\", \"15:56\", 940, 956, 16],\n    [876, \"15:43\", \"16:10\", 943, 970, 27],\n    [877, \"15:43\", \"16:30\", 943, 990, 47],\n    [878, \"15:44\", \"17:10\", 944, 1030, 86],\n    [879, \"15:44\", \"16:25\", 944, 985, 41],\n    [880, \"15:45\", \"16:04\", 945, 964, 19],\n    [881, \"15:46\", \"15:58\", 946, 958, 12],\n    [882, \"15:48\", \"16:35\", 948, 995, 47],\n    [883, \"15:48\", \"16:35\", 948, 995, 47],\n    [884, \"15:48\", \"17:14\", 948, 1034, 86],\n    [885, \"15:49\", \"16:43\", 949, 1003, 54],\n    [886, \"15:50\", \"16:00\", 950, 960, 10],\n    [887, \"15:50\", \"17:01\", 950, 1021, 71],\n    [888, \"15:51\", \"16:18\", 951, 978, 27],\n    [889, \"15:52\", \"16:36\", 952, 996, 44],\n    [890, \"15:53\", \"16:40\", 953, 1000, 47],\n    [891, \"15:54\", \"17:20\", 954, 1040, 86],\n    [892, \"15:54\", \"16:35\", 954, 995, 41],\n    [893, \"15:55\", \"16:14\", 955, 974, 19],\n    [894, \"15:58\", \"16:25\", 958, 985, 27],\n    [895, \"15:58\", \"16:45\", 958, 1005, 47],\n    [896, \"15:58\", \"16:45\", 958, 1005, 47],\n    [897, \"15:58\", \"17:24\", 958, 1044, 86],\n    [898, \"15:59\", \"17:11\", 959, 1031, 72],\n    [899, \"15:59\", \"16:53\", 959, 1013, 54],\n    [900, \"16:00\", \"16:10\", 960, 970, 10],\n    [901, \"16:00\", \"16:16\", 960, 976, 16],\n    [902, \"16:01\", \"16:13\", 961, 973, 12],\n    [903, \"16:03\", \"16:50\", 963, 1010, 47],\n    [904, \"16:04\", \"17:30\", 964, 1050, 86],\n    [905, \"16:04\", \"16:45\", 964, 1005, 41],\n    [906, \"16:05\", \"16:24\", 965, 984, 19],\n    [907, \"16:06\", \"16:51\", 966, 1011, 45],\n    [908, \"16:08\", \"16:55\", 968, 1015, 47],\n    [909, \"16:08\", \"17:34\", 968, 1054, 86],\n    [910, \"16:08\", \"16:55\", 968, 1015, 47],\n    [911, \"16:09\", \"17:03\", 969, 1023, 54],\n    [912, \"16:09\", \"17:21\", 969, 1041, 72],\n    [913, \"16:10\", \"16:20\", 970, 980, 10],\n    [914, \"16:13\", \"16:40\", 973, 1000, 27],\n    [915, \"16:13\", \"17:00\", 973, 1020, 47],\n    [916, \"16:14\", \"16:55\", 974, 1015, 41],\n    [917, \"16:14\", \"17:40\", 974, 1060, 86],\n    [918, \"16:15\", \"16:34\", 975, 994, 19],\n    [919, \"16:16\", \"16:28\", 976, 988, 12],\n    [920, \"16:18\", \"17:05\", 978, 1025, 47],\n    [921, \"16:18\", \"17:05\", 978, 1025, 47],\n    [922, \"16:18\", \"17:44\", 978, 1064, 86],\n    [923, \"16:19\", \"17:31\", 979, 1051, 72],\n    [924, \"16:19\", \"17:13\", 979, 1033, 54],\n    [925, \"16:20\", \"16:30\", 980, 990, 10],\n    [926, \"16:20\", \"16:36\", 980, 996, 16],\n    [927, \"16:21\", \"16:48\", 981, 1008, 27],\n    [928, \"16:22\", \"17:06\", 982, 1026, 44],\n    [929, \"16:23\", \"17:10\", 983, 1030, 47],\n    [930, \"16:24\", \"17:05\", 984, 1025, 41],\n    [931, \"16:24\", \"17:50\", 984, 1070, 86],\n    [932, \"16:25\", \"16:44\", 985, 1004, 19],\n    [933, \"16:28\", \"17:15\", 988, 1035, 47],\n    [934, \"16:28\", \"17:15\", 988, 1035, 47],\n    [935, \"16:28\", \"16:55\", 988, 1015, 27],\n    [936, \"16:28\", \"17:54\", 988, 1074, 86],\n    [937, \"16:29\", \"17:23\", 989, 1043, 54],\n    [938, \"16:29\", \"17:41\", 989, 1061, 72],\n    [939, \"16:30\", \"16:40\", 990, 1000, 10],\n    [940, \"16:31\", \"16:43\", 991, 1003, 12],\n    [941, \"16:33\", \"17:20\", 993, 1040, 47],\n    [942, \"16:34\", \"17:15\", 994, 1035, 41],\n    [943, \"16:34\", \"18:00\", 994, 1080, 86],\n    [944, \"16:35\", \"16:54\", 995, 1014, 19],\n    [945, \"16:36\", \"17:21\", 996, 1041, 45],\n    [946, \"16:38\", \"17:25\", 998, 1045, 47],\n    [947, \"16:38\", \"17:25\", 998, 1045, 47],\n    [948, \"16:38\", \"18:04\", 998, 1084, 86],\n    [949, \"16:39\", \"17:33\", 999, 1053, 54],\n    [950, \"16:39\", \"17:51\", 999, 1071, 72],\n    [951, \"16:40\", \"16:56\", 1000, 1016, 16],\n    [952, \"16:40\", \"16:50\", 1000, 1010, 10],\n    [953, \"16:43\", \"17:10\", 1003, 1030, 27],\n    [954, \"16:43\", \"17:30\", 1003, 1050, 47],\n    [955, \"16:44\", \"17:25\", 1004, 1045, 41],\n    [956, \"16:44\", \"18:10\", 1004, 1090, 86],\n    [957, \"16:45\", \"17:04\", 1005, 1024, 19],\n    [958, \"16:46\", \"16:58\", 1006, 1018, 12],\n    [959, \"16:48\", \"18:14\", 1008, 1094, 86],\n    [960, \"16:48\", \"17:35\", 1008, 1055, 47],\n    [961, \"16:48\", \"17:35\", 1008, 1055, 47],\n    [962, \"16:49\", \"18:01\", 1009, 1081, 72],\n    [963, \"16:49\", \"17:43\", 1009, 1063, 54],\n    [964, \"16:50\", \"17:00\", 1010, 1020, 10],\n    [965, \"16:51\", \"17:18\", 1011, 1038, 27],\n    [966, \"16:52\", \"17:36\", 1012, 1056, 44],\n    [967, \"16:53\", \"17:40\", 1013, 1060, 47],\n    [968, \"16:54\", \"18:20\", 1014, 1100, 86],\n    [969, \"16:54\", \"17:35\", 1014, 1055, 41],\n    [970, \"16:55\", \"17:14\", 1015, 1034, 19],\n    [971, \"16:58\", \"17:25\", 1018, 1045, 27],\n    [972, \"16:58\", \"17:45\", 1018, 1065, 47],\n    [973, \"16:58\", \"17:45\", 1018, 1065, 47],\n    [974, \"16:58\", \"18:24\", 1018, 1104, 86],\n    [975, \"16:59\", \"18:11\", 1019, 1091, 72],\n    [976, \"16:59\", \"17:53\", 1019, 1073, 54],\n    [977, \"17:00\", \"17:16\", 1020, 1036, 16],\n    [978, \"17:00\", \"17:10\", 1020, 1030, 10],\n    [979, \"17:01\", \"17:13\", 1021, 1033, 12],\n    [980, \"17:03\", \"17:50\", 1023, 1070, 47],\n    [981, \"17:04\", \"18:30\", 1024, 1110, 86],\n    [982, \"17:04\", \"17:45\", 1024, 1065, 41],\n    [983, \"17:05\", \"17:24\", 1025, 1044, 19],\n    [984, \"17:06\", \"17:51\", 1026, 1071, 45],\n    [985, \"17:08\", \"17:55\", 1028, 1075, 47],\n    [986, \"17:08\", \"17:55\", 1028, 1075, 47],\n    [987, \"17:08\", \"18:34\", 1028, 1114, 86],\n    [988, \"17:09\", \"18:03\", 1029, 1083, 54],\n    [989, \"17:09\", \"18:21\", 1029, 1101, 72],\n    [990, \"17:10\", \"17:20\", 1030, 1040, 10],\n    [991, \"17:13\", \"17:40\", 1033, 1060, 27],\n    [992, \"17:13\", \"18:00\", 1033, 1080, 47],\n    [993, \"17:14\", \"17:55\", 1034, 1075, 41],\n    [994, \"17:14\", \"18:40\", 1034, 1120, 86],\n    [995, \"17:15\", \"17:34\", 1035, 1054, 19],\n    [996, \"17:16\", \"17:28\", 1036, 1048, 12],\n    [997, \"17:18\", \"18:05\", 1038, 1085, 47],\n    [998, \"17:18\", \"18:05\", 1038, 1085, 47],\n    [999, \"17:18\", \"18:44\", 1038, 1124, 86],\n    [1000, \"17:19\", \"18:31\", 1039, 1111, 72],\n    [1001, \"17:19\", \"18:13\", 1039, 1093, 54],\n    [1002, \"17:20\", \"17:36\", 1040, 1056, 16],\n    [1003, \"17:20\", \"17:30\", 1040, 1050, 10],\n    [1004, \"17:21\", \"17:47\", 1041, 1067, 26],\n    [1005, \"17:22\", \"18:06\", 1042, 1086, 44],\n    [1006, \"17:23\", \"18:10\", 1043, 1090, 47],\n    [1007, \"17:24\", \"18:50\", 1044, 1130, 86],\n    [1008, \"17:24\", \"18:05\", 1044, 1085, 41],\n    [1009, \"17:25\", \"17:44\", 1045, 1064, 19],\n    [1010, \"17:28\", \"17:55\", 1048, 1075, 27],\n    [1011, \"17:28\", \"18:15\", 1048, 1095, 47],\n    [1012, \"17:28\", \"18:15\", 1048, 1095, 47],\n    [1013, \"17:28\", \"18:54\", 1048, 1134, 86],\n    [1014, \"17:29\", \"18:41\", 1049, 1121, 72],\n    [1015, \"17:29\", \"18:23\", 1049, 1103, 54],\n    [1016, \"17:30\", \"17:40\", 1050, 1060, 10],\n    [1017, \"17:31\", \"17:43\", 1051, 1063, 12],\n    [1018, \"17:33\", \"18:20\", 1053, 1100, 47],\n    [1019, \"17:34\", \"18:15\", 1054, 1095, 41],\n    [1020, \"17:34\", \"19:00\", 1054, 1140, 86],\n    [1021, \"17:35\", \"17:54\", 1055, 1074, 19],\n    [1022, \"17:36\", \"18:21\", 1056, 1101, 45],\n    [1023, \"17:38\", \"18:25\", 1058, 1105, 47],\n    [1024, \"17:38\", \"19:04\", 1058, 1144, 86],\n    [1025, \"17:38\", \"18:25\", 1058, 1105, 47],\n    [1026, \"17:39\", \"18:51\", 1059, 1131, 72],\n    [1027, \"17:39\", \"18:33\", 1059, 1113, 54],\n    [1028, \"17:40\", \"17:56\", 1060, 1076, 16],\n    [1029, \"17:40\", \"17:50\", 1060, 1070, 10],\n    [1030, \"17:43\", \"18:10\", 1063, 1090, 27],\n    [1031, \"17:43\", \"18:30\", 1063, 1110, 47],\n    [1032, \"17:44\", \"18:25\", 1064, 1105, 41],\n    [1033, \"17:44\", \"19:14\", 1064, 1154, 90],\n    [1034, \"17:45\", \"18:04\", 1065, 1084, 19],\n    [1035, \"17:46\", \"17:58\", 1066, 1078, 12],\n    [1036, \"17:48\", \"18:35\", 1068, 1115, 47],\n    [1037, \"17:48\", \"18:35\", 1068, 1115, 47],\n    [1038, \"17:48\", \"19:14\", 1068, 1154, 86],\n    [1039, \"17:49\", \"19:01\", 1069, 1141, 72],\n    [1040, \"17:49\", \"18:43\", 1069, 1123, 54],\n    [1041, \"17:50\", \"18:00\", 1070, 1080, 10],\n    [1042, \"17:51\", \"18:17\", 1071, 1097, 26],\n    [1043, \"17:52\", \"18:36\", 1072, 1116, 44],\n    [1044, \"17:53\", \"18:40\", 1073, 1120, 47],\n    [1045, \"17:54\", \"18:35\", 1074, 1115, 41],\n    [1046, \"17:54\", \"18:57\", 1074, 1137, 63],\n    [1047, \"17:55\", \"18:14\", 1075, 1094, 19],\n    [1048, \"17:58\", \"18:45\", 1078, 1125, 47],\n    [1049, \"17:58\", \"18:45\", 1078, 1125, 47],\n    [1050, \"17:58\", \"18:25\", 1078, 1105, 27],\n    [1051, \"17:58\", \"19:26\", 1078, 1166, 88],\n    [1052, \"17:59\", \"18:53\", 1079, 1133, 54],\n    [1053, \"18:00\", \"19:11\", 1080, 1151, 71],\n    [1054, \"18:00\", \"18:10\", 1080, 1090, 10],\n    [1055, \"18:00\", \"18:16\", 1080, 1096, 16],\n    [1056, \"18:01\", \"18:13\", 1081, 1093, 12],\n    [1057, \"18:03\", \"18:50\", 1083, 1130, 47],\n    [1058, \"18:04\", \"18:45\", 1084, 1125, 41],\n    [1059, \"18:04\", \"19:29\", 1084, 1169, 85],\n    [1060, \"18:05\", \"18:24\", 1085, 1104, 19],\n    [1061, \"18:06\", \"18:51\", 1086, 1131, 45],\n    [1062, \"18:08\", \"18:55\", 1088, 1135, 47],\n    [1063, \"18:08\", \"19:06\", 1088, 1146, 58],\n    [1064, \"18:08\", \"18:55\", 1088, 1135, 47],\n    [1065, \"18:09\", \"19:03\", 1089, 1143, 54],\n    [1066, \"18:10\", \"18:20\", 1090, 1100, 10],\n    [1067, \"18:10\", \"19:21\", 1090, 1161, 71],\n    [1068, \"18:13\", \"19:00\", 1093, 1140, 47],\n    [1069, \"18:13\", \"18:40\", 1093, 1120, 27],\n    [1070, \"18:14\", \"19:43\", 1094, 1183, 89],\n    [1071, \"18:14\", \"18:55\", 1094, 1135, 41],\n    [1072, \"18:15\", \"18:34\", 1095, 1114, 19],\n    [1073, \"18:16\", \"18:28\", 1096, 1108, 12],\n    [1074, \"18:17\", \"18:27\", 1097, 1107, 10],\n    [1075, \"18:18\", \"19:41\", 1098, 1181, 83],\n    [1076, \"18:18\", \"18:58\", 1098, 1138, 40],\n    [1077, \"18:18\", \"19:05\", 1098, 1145, 47],\n    [1078, \"18:19\", \"19:13\", 1099, 1153, 54],\n    [1079, \"18:20\", \"19:31\", 1100, 1171, 71],\n    [1080, \"18:20\", \"18:36\", 1100, 1116, 16],\n    [1081, \"18:20\", \"18:30\", 1100, 1110, 10],\n    [1082, \"18:22\", \"19:05\", 1102, 1145, 43],\n    [1083, \"18:23\", \"19:05\", 1103, 1145, 42],\n    [1084, \"18:24\", \"19:27\", 1104, 1167, 63],\n    [1085, \"18:24\", \"19:05\", 1104, 1145, 41],\n    [1086, \"18:25\", \"18:44\", 1105, 1124, 19],\n    [1087, \"18:28\", \"19:25\", 1108, 1165, 57],\n    [1088, \"18:28\", \"18:55\", 1108, 1135, 27],\n    [1089, \"18:28\", \"19:08\", 1108, 1148, 40]\n]\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Python pip command to install the Google OR-Tools optimization package required for the solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/send_more_money_any_base.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required Google OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/production.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools optimization package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools optimization package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/jobshop_ft06_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: This code snippet installs the Google OR-Tools package in a Google Colab environment. OR-Tools is required for solving the Vehicle Routing Problem in the main script.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_items_to_deliver.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package using pip in a Jupyter notebook environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/test_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package, which is required for using Google CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/regular.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Java Library Target\nDESCRIPTION: Configures SWIG to generate Java bindings as an object library, specifying output directory and source files.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(jniinit\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/init\n  SOURCES init.i)\n```\n\n----------------------------------------\n\nTITLE: Configuring Source Files and Solver Exclusions in CMake\nDESCRIPTION: Globbing source files and conditionally excluding specific solver implementations based on USE flags. Handles different solver backends like COINOR, GLPK, HIGHS, PDLP, and SCIP.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/proto_solver/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nif(NOT USE_COINOR)\n  list(FILTER _SRCS EXCLUDE REGEX \"/clp_proto_solver.\")\n  list(FILTER _SRCS EXCLUDE REGEX \"/cbc_proto_solver.\")\nendif()\nif(NOT USE_GLPK)\n  list(FILTER _SRCS EXCLUDE REGEX \"/glpk_proto_solver.\")\nendif()\nif(NOT USE_HIGHS)\n  list(FILTER _SRCS EXCLUDE REGEX \"/highs_proto_solver.\")\nendif()\nif(NOT USE_PDLP)\n  list(FILTER _SRCS EXCLUDE REGEX \"/pdlp_proto_solver.\")\nendif()\nif(NOT USE_SCIP)\n  list(FILTER _SRCS EXCLUDE REGEX \"/scip_proto_solver.\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Examining GCC INT64 macro definitions on Linux\nDESCRIPTION: Shell commands to query the compiler's built-in 64-bit integer type macros. This helps understand how int64_t and uint64_t are implemented on Linux systems with GCC.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngcc -dM -E -x c /dev/null | grep __INT64\n#define __INT64_C(c) c ## L\n#define __INT64_MAX__ 0x7fffffffffffffffL\n#define __INT64_TYPE__ long int\n\ngcc -dM -E -x c /dev/null | grep __UINT64\n#define __UINT64_C(c) c ## UL\n#define __UINT64_MAX__ 0xffffffffffffffffUL\n#define __UINT64_TYPE__ long unsigned int\n```\n\n----------------------------------------\n\nTITLE: Entry Point Call for Vehicle Routing Problem Application in Python\nDESCRIPTION: Simple call to the main function that executes the OR-Tools vehicle routing problem solution. This is the entry point for running the entire routing optimization process.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmain()\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries to xpress_solver_test in CMake\nDESCRIPTION: This CMake snippet defines the libraries to be linked with the xpress_solver_test.cc target. It uses WHOLE_ARCHIVE linking directive to ensure all symbols from test libraries are included in the final binary, which is necessary for proper test discovery and execution.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\n\"xpress_solver_test.cc\"\nLINK_LIBRARIES\nGTest::gtest\nabsl::status\nortools::math_opt_matchers\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_callback_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_invalid_input_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_generic_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_infeasible_subsystem_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_model_solve_parameters_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_ip_parameter_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_logical_constraint_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_incomplete_solve_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_model_solve_parameters_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_parameter_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_lp_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_mip_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_multi_objective_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_status_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qp_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_second_order_cone_tests>\"\n\"$<LINK_LIBRARY:WHOLE_ARCHIVE,ortools::math_opt_qc_tests>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Dependency Validation Script for OR-Tools\nDESCRIPTION: Comprehensive script that checks for proper installation and configuration of OR-Tools and its dependencies. It validates module paths, imports required components, and ensures correct environment setup. The script includes error handling and logging functionality.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/check_dependencies.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging, sys, inspect\nfrom os.path import dirname, abspath\nfrom optparse import OptionParser\n\n\ndef log_error_and_exit(error_message):\n  logging.error(error_message)\n  raise SystemExit\n\n\n#try to import setuptools\ntry:\n  from setuptools import setup, Extension\n  from setuptools.command import easy_install\nexcept ImportError:\n  log_error_and_exit(\"\"\"setuptools is not installed for \"\"\"\"\"\"\"\"\"\"\"\"\"+sys.executable+\n                     \"\"\"\\\"\\nFollow this link for installing instructions :\\nhttps://pypi.python.org/pypi/setuptools\\nmake sure you use \"\"\"+sys.executable+\"\"\"\\\" during the installation\"\"\")\n\nfrom pkg_resources import parse_version\n\n\ndef notinstalled(modulename):\n  return modulename + \"\"\" could not be imported for \"\"\"+sys.executable+\"\"\"\\\"\\nSet PYTHONPATH to the output of this command \\\"make print-OR_TOOLS_PYTHONPATH\\\" before running the examples\"\"\"\n\n\ndef wrong_module(module_file, modulename):\n  return \"\"\"\\nThe python examples are not importing the \"\"\" + modulename + \"\"\" module from the sources.\\nRemove the site-package that contains \"\"\"+module_file+\"\"\"\", either manually or by using pip, and rerun this script again.\"\"\"\n\n\n# Returns the n_th parent of file\ndef n_dirname(n, file):\n  directory = file\n  for x in range(0, n):\n    directory = dirname(directory)\n  return directory\n\n\nparser = OptionParser(\"Log level\")\nparser.add_option(\n    \"-l\",\n    \"--log\",\n    type=\"string\",\n    help=\n    \"Available levels are CRITICAL (3), ERROR (2), WARNING (1), INFO (0), DEBUG (-1)\",\n    default=\"INFO\")\noptions, args = parser.parse_args()\n\ntry:\n  loglevel = getattr(logging, options.log.upper())\nexcept AttributeError:\n  loglevel = {\n      3: logging.CRITICAL,\n      2: logging.ERROR,\n      1: logging.WARNING,\n      0: logging.INFO,\n      -1: logging.DEBUG,\n  }[int(options.log)]\n\nlogging.basicConfig(\n    format=\"[%(levelname)s] %(message)s\", stream=sys.stdout, level=loglevel)\n\nlogging.info(\"Python path : \" + sys.executable)\nlogging.info(\"Python version : \" + sys.version)\nlogging.info(\"sys.path : \" + str(sys.path))\nortools_project_path = n_dirname(\n    3, abspath(inspect.getfile(inspect.currentframe())))\n\n#try to import ortools\ntry:\n  import ortools\nexcept ImportError:\n  logging.error(notinstalled(\"ortools\"))\n  raise SystemExit\n\n#check if we're using ortools from the sources or it's binded by pypi's module\nortools_module_file = inspect.getfile(ortools)\nortools_module_path = n_dirname(3, ortools_module_file)\nif (ortools_module_path == ortools_project_path):\n  logging.info(\"Or-tools is imported from : \" + ortools_module_file)\nelse:\n  log_error_and_exit(wrong_module(ortools_module_file, \"ortools\"))\n\n# Check if python can load the libraries' modules\n# this is useful when the library architecture is not compatbile with the python executable,\n# or when the library's dependencies are not available or not compatible.\nfrom ortools.constraint_solver import _pywrapcp\nfrom ortools.linear_solver import _pywraplp\nfrom ortools.algorithms import _pywrapknapsack_solver\nfrom ortools.graph import _pywrapgraph\n\n#try to import protobuf\ntry:\n  import google.protobuf\nexcept ImportError:\n  log_error_and_exit(notinstalled(\"protobuf\"))\n\n#check if we're using protobuf from the sources or it's binded by pypi's module\nprotobuf_module_file = inspect.getfile(google.protobuf)\nprotobuf_module_path = n_dirname(7, protobuf_module_file)\nif (protobuf_module_path == ortools_project_path):\n  logging.info(\"Protobuf is imported from : \" + protobuf_module_file)\nelse:\n  log_error_and_exit(wrong_module(protobuf_module_file, \"protobuf\"))\n\n#Check if the protobuf modules were successfully generated\nfrom google.protobuf import descriptor as _descriptor\nfrom google.protobuf import descriptor_pb2\n```\n\n----------------------------------------\n\nTITLE: Configuring Min Cost Flow Python Module with CMake\nDESCRIPTION: This snippet sets up the min_cost_flow_pybind11 module, configuring its output name, installation paths, and linking it with OR-Tools library. It handles platform-specific settings for macOS and Unix systems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(min_cost_flow_pybind11 MODULE min_cost_flow.cc)\nset_target_properties(min_cost_flow_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"min_cost_flow\")\nif(APPLE)\n  set_target_properties(min_cost_flow_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\"\n    )\nelseif(UNIX)\n  set_target_properties(min_cost_flow_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\"\n    )\nendif()\ntarget_link_libraries(min_cost_flow_pybind11 PRIVATE ${PROJECT_NAMESPACE}::ortools)\nadd_library(${PROJECT_NAMESPACE}::min_cost_flow_pybind11 ALIAS min_cost_flow_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools\nDESCRIPTION: This command installs the OR-Tools package using pip, a package installer for Python. It's a prerequisite for running the rest of the code, as it provides the necessary libraries and modules for optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/pdlp/simple_pdlp_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package for constraint programming\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/traffic_lights.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: Command to install the Google OR-Tools optimization package via pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_tsp_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_nodes_indices.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: int64_t typedefs in Visual Studio on Windows\nDESCRIPTION: C++ code snippet showing how int64_t and related types are defined in Visual Studio's stdint.h header. Windows uses 'long long' for 64-bit integers to maintain compatibility.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#if _VCRT_COMPILER_PREPROCESSOR\n\ntypedef signed char        int8_t;\ntypedef short              int16_t;\ntypedef int                int32_t;\ntypedef long long          int64_t;\ntypedef unsigned char      uint8_t;\ntypedef unsigned short     uint16_t;\ntypedef unsigned int       uint32_t;\ntypedef unsigned long long uint64_t;\n```\n\n----------------------------------------\n\nTITLE: Connecting to Vagrant virtual machine via SSH\nDESCRIPTION: Command to establish an SSH connection to the running Vagrant virtual machine, providing an interactive shell.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nvagrant ssh\n[vagrant@freebsd12 ~]$ ...\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools Python package using pip, which is required to run the VRP example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_tokens.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Properties for .NET Algorithms Library in CMake\nDESCRIPTION: Configures properties for the dotnet_algorithms target, including position-independent code and SWIG include directories. It also links the library with the OR-Tools core library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(dotnet_algorithms PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_algorithms PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installing the required OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/who_killed_agatha.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Flight Schedule Data Sample in Plaintext\nDESCRIPTION: A sample of the flight schedule data, showing the structure of each entry. Each row contains a flight number, departure time, arrival time, departure minutes, arrival minutes, and flight duration in minutes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n[600, \"12:14\", \"13:44\", 734, 824, 90],\n[601, \"12:14\", \"13:38\", 734, 818, 84],\n[602, \"12:15\", \"12:54\", 735, 774, 39],\n[603, \"12:16\", \"12:28\", 736, 748, 12],\n[604, \"12:18\", \"13:00\", 738, 780, 42]\n```\n\n----------------------------------------\n\nTITLE: Configuring Platform-Specific Properties for Unix in CMake\nDESCRIPTION: Sets platform-specific properties for the CP Model Helper PyBind11 module on Unix systems (excluding macOS). It sets the runtime path for loading dependent libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nelseif(UNIX)\n  set_target_properties(cp_model_helper_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\")\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools Algorithms Library in CMake\nDESCRIPTION: This snippet configures the OR-Tools algorithms library build. It selects source files, creates an object library, sets properties, and defines include directories and dependencies. The library is set up with position-independent code and linked against required libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.*_test.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/set_cover_solve.cc\")\n\nset(NAME ${PROJECT_NAME}_algorithms)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::algorithms ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Installing Notebook Dependencies\nDESCRIPTION: Command to install required Python packages (plotly, numpy, svgwrite) for OR-Tools notebooks.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/README.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npip3 install --user plotly numpy svgwrite\n```\n\n----------------------------------------\n\nTITLE: Listing Available Tests\nDESCRIPTION: Commands to navigate to the build directory and list all available tests without running them. This helps when you want to see what tests are available.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncd build\nctest -N\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the Google OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/knapsack_cp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Sum Assignment Python Module with CMake\nDESCRIPTION: This snippet sets up the linear_sum_assignment_pybind11 module, configuring its output name, installation paths, and linking it with OR-Tools library. It handles platform-specific settings for macOS and Unix systems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(linear_sum_assignment_pybind11 MODULE linear_sum_assignment.cc)\nset_target_properties(linear_sum_assignment_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"linear_sum_assignment\")\nif(APPLE)\n  set_target_properties(linear_sum_assignment_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\"\n    )\nelseif(UNIX)\n  set_target_properties(linear_sum_assignment_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\"\n    )\nendif()\ntarget_link_libraries(linear_sum_assignment_pybind11 PRIVATE ${PROJECT_NAMESPACE}::ortools)\nadd_library(${PROJECT_NAMESPACE}::linear_sum_assignment_pybind11 ALIAS linear_sum_assignment_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the required Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/pandigital_numbers.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools package required for the implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stable_marriage_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the required OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_default_search.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This snippet installs the OR-Tools package using pip. It's a prerequisite for running the main code.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cp_is_fun_cp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required OR-Tools package for constraint programming\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nurses_cp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools package required for solving routing problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_time_windows.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/simple_cp_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Python pip command to install the Google OR-Tools package required for the implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/p_median.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Building and Running Java Examples in OR-Tools\nDESCRIPTION: Commands for building and running Java examples from the top directory of the OR-Tools project. The process involves two steps: building the source file and then running the compiled program.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/java/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake build SOURCE=examples/java/<example>.java\nmake run SOURCE=examples/java/<example>.java\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package using pip. This is required to run the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Defining Network Flow Graph Arcs in Protobuf\nDESCRIPTION: This snippet shows the structure of defining arcs in a network flow graph using Protobuf syntax. Each arc specifies a tail node, head node, and capacity. The arcs connect various nodes in the graph, forming a complex network structure.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\narcs {\n  tail: 104\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 13\n  capacity: 91529\n}\narcs {\n  tail: 13\n  head: 362\n  capacity: 8470\n}\narcs {\n  tail: 13\n  head: 32\n  capacity: 2991389\n}\narcs {\n  tail: 13\n  head: 262\n  capacity: 319032\n}\narcs {\n  tail: 13\n  head: 31\n  capacity: 305262\n}\narcs {\n  tail: 13\n  head: 84\n  capacity: 314614\n}\narcs {\n  tail: 13\n  head: 300\n  capacity: 968549\n}\narcs {\n  tail: 13\n  head: 85\n  capacity: 4937590\n}\n```\n\n----------------------------------------\n\nTITLE: Time Entry Dataset in CSV Format\nDESCRIPTION: Structured data showing transportation or scheduling information with columns for ID, start time (HH:MM), end time (HH:MM), start minutes (from midnight), end minutes (from midnight), and duration in minutes. Times range from 06:42 to 10:43.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: csv\nCODE:\n```\n[172, \"06:42\", \"07:26\", 402, 446, 44],\n[173, \"06:42\", \"07:13\", 402, 433, 31],\n[174, \"06:43\", \"07:08\", 403, 428, 25],\n...\n[402, \"09:16\", \"09:28\", 556, 568, 12],\n[403, \"09:18\", \"10:43\", 558, 643, 85]\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip install command to set up the required OR-Tools package for constraint programming functionality.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/no_wait_baking_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Python Package\nDESCRIPTION: Command to install the Google OR-Tools package using pip, which is necessary for implementing the constraint solver and routing functionality.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp_cities.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the OR-Tools package using pip, allowing you to use the library in your Python environment. It's a prerequisite for running the max flow example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/graph/simple_max_flow_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Running make from top directory for CI testing\nDESCRIPTION: Shows how to run the Makefile from the top directory of the project by specifying the cmake directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmake --directory=cmake\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_starts_ends.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Adding SWIG Library for OR-Tools Constraint Solver in CMake\nDESCRIPTION: Adds a SWIG library target for the constraint solver, specifying the language as C# and the output directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nswig_add_library(dotnet_constraint_solver\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/constraint_solver\n  SOURCES routing.i)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Vehicle Routing\nDESCRIPTION: Command to install the OR-Tools optimization package using pip in a Colab environment. This package is required to implement vehicle routing problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_resources.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the ortools package using pip, which is required for the ski assignment optimization.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/ski_assignment.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing Google OR-Tools package\nDESCRIPTION: Command to install the Google OR-Tools optimization package, which provides the constraint programming solver needed for the implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/all_interval.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/strimko2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip, which is required for running the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/mr_smith.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the required Google OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/killer_sudoku.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing ortools Package in Python\nDESCRIPTION: This snippet shows how to install the ortools package required for running the sample code. It uses pip to ensure the package is available in the environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/reified_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package using pip. This is required to run the Rogo puzzle solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/rogo2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Conditional GLPK Integration in CMake for OR-Tools\nDESCRIPTION: This CMake snippet checks if GLPK is enabled, compiles GLPK-related source files, and sets up the build configuration for the GLPK component of OR-Tools. It includes setting compiler flags, include directories, and linking required libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/glpk/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT USE_GLPK)\n  return()\nendif()\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\n\nset(NAME ${PROJECT_NAME}_glpk)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  absl::str_format\n  $<$<BOOL:${USE_GLPK}>:GLPK::GLPK>)\n#add_library(${PROJECT_NAMESPACE}::glpk ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip install command for the Google OR-Tools optimization package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_regular.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Parsing Space-Separated Numerical Data\nDESCRIPTION: Raw data consisting of 50 records. Each record contains three lines: a record number (0-49), a single numeric value, and a row of 10 space-separated integers.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/testdata/50_10_01_ta041.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n50\n10\n1958948863\n0\n793\n46 61 3 51 37 79 83 22 27 24\n1\n2280\n52 87 1 24 16 93 87 29 92 47\n2\n939\n79 51 58 21 42 68 38 99 75 39\n3\n2591\n45 25 85 57 47 75 38 25 94 66\n4\n1540\n97 73 33 69 94 37 86 98 18 41\n...\n```\n\n----------------------------------------\n\nTITLE: Python Array of Shift Schedule Data\nDESCRIPTION: Large array containing shift schedule entries where each entry is structured as [ID, start_time, end_time, start_minutes, end_minutes, duration]. Times are in 24-hour format and minutes are calculated from midnight.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nSAMPLE_SHIFTS_LARGE = [\n    [0, \"04:18\", \"05:00\", 258, 300, 42],\n    [1, \"04:27\", \"05:08\", 267, 308, 41],\n    [2, \"04:29\", \"05:26\", 269, 326, 57],\n    # ... additional shift entries\n    [171, \"06:41\", \"08:00\", 401, 480, 79]\n]\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip install command to set up the required OR-Tools package in the environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/arc_flow_cutting_stock_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python Code Environment\nDESCRIPTION: This code snippet demonstrates how to install the OR-Tools Python package using pip. It is required to perform linear programming calculations using the OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_lp_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Package installation command for OR-Tools optimization library\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Managing RPATH in CMake\nDESCRIPTION: CMake configuration to enable building with install RPATH. This is needed to generate wrapper packages and test from the build directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Simple pip install command to set up the required OR-Tools package dependency.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stable_marriage.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Target Properties for OR-Tools Constraint Solver in CMake\nDESCRIPTION: Sets target properties for the dotnet_constraint_solver, including SWIG include directories and position-independent code. Links the target to the ortools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(dotnet_constraint_solver PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_constraint_solver PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Python pip command to install the required OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_breaks.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code snippet installs the OR-Tools package using pip. OR-Tools is required for solving the constraint satisfaction problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_speakers.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the required OR-Tools package via pip in a Colab notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/assignment.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package, which is required for the Minesweeper solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/minesweeper.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/seseman.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required OR-Tools package for constraint solving\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/least_diff.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/algorithms/knapsack.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip. It's a prerequisite for running the graph coloring algorithm.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coloring_ip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Flow Python Module with CMake\nDESCRIPTION: This snippet sets up the max_flow_pybind11 module, configuring its output name, installation paths, and linking it with OR-Tools library. It handles platform-specific settings for macOS and Unix systems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(max_flow_pybind11 MODULE max_flow.cc)\nset_target_properties(max_flow_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"max_flow\")\nif(APPLE)\n  set_target_properties(max_flow_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\"\n    )\nelseif(UNIX)\n  set_target_properties(max_flow_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\"\n    )\nendif()\ntarget_link_libraries(max_flow_pybind11 PRIVATE ${PROJECT_NAMESPACE}::ortools)\nadd_library(${PROJECT_NAMESPACE}::max_flow_pybind11 ALIAS max_flow_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Subset Sum Solver in Python\nDESCRIPTION: Imports the necessary modules from the ortools library to use the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/subset_sum.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Installing Jupyter Notebook Dependencies with Bazel\nDESCRIPTION: Command for generating the pip-compiled requirements file for the Jupyter notebook environment in the OR-Tools project using Bazel.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/notebook_requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbazel run //bazel:notebook_requirements.update\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: Command to install the Google OR-Tools package in a Colab notebook environment, which is required for solving optimization problems using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required OR-Tools package for solving optimization problems\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools optimization package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/gate_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Python environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/circuit.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Julia Registrator Command for Package Registration\nDESCRIPTION: Command used to register the ORToolsGenerated.jl package with the Julia package registry via JuliaRegistrator bot.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/julia/docs/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n@JuliaRegistrator register subdir=ortools/julia/ORToolsGenerated.jl\n```\n\n----------------------------------------\n\nTITLE: Implementing Nurse Scheduling Problem with CP-SAT in Python\nDESCRIPTION: Defines the main function that sets up and solves the nurse scheduling problem. It creates variables, adds constraints, and maximizes the objective of fulfilling shift requests.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/schedule_requests_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef main() -> None:\n    # This program tries to find an optimal assignment of nurses to shifts\n    # (3 shifts per day, for 7 days), subject to some constraints (see below).\n    # Each nurse can request to be assigned to specific shifts.\n    # The optimal assignment maximizes the number of fulfilled shift requests.\n    num_nurses = 5\n    num_shifts = 3\n    num_days = 7\n    all_nurses = range(num_nurses)\n    all_shifts = range(num_shifts)\n    all_days = range(num_days)\n    shift_requests = [\n        [[0, 0, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 1]],\n        [[0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 0], [0, 0, 1]],\n        [[0, 1, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 0]],\n        [[0, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 0]],\n        [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 0]],\n    ]\n\n    # Creates the model.\n    model = cp_model.CpModel()\n\n    # Creates shift variables.\n    # shifts[(n, d, s)]: nurse 'n' works shift 's' on day 'd'.\n    shifts = {}\n    for n in all_nurses:\n        for d in all_days:\n            for s in all_shifts:\n                shifts[(n, d, s)] = model.new_bool_var(f\"shift_n{n}_d{d}_s{s}\")\n\n    # Each shift is assigned to exactly one nurse in .\n    for d in all_days:\n        for s in all_shifts:\n            model.add_exactly_one(shifts[(n, d, s)] for n in all_nurses)\n\n    # Each nurse works at most one shift per day.\n    for n in all_nurses:\n        for d in all_days:\n            model.add_at_most_one(shifts[(n, d, s)] for s in all_shifts)\n\n    # Try to distribute the shifts evenly, so that each nurse works\n    # min_shifts_per_nurse shifts. If this is not possible, because the total\n    # number of shifts is not divisible by the number of nurses, some nurses will\n    # be assigned one more shift.\n    min_shifts_per_nurse = (num_shifts * num_days) // num_nurses\n    if num_shifts * num_days % num_nurses == 0:\n        max_shifts_per_nurse = min_shifts_per_nurse\n    else:\n        max_shifts_per_nurse = min_shifts_per_nurse + 1\n    for n in all_nurses:\n        num_shifts_worked: Union[cp_model.LinearExpr, int] = 0\n        for d in all_days:\n            for s in all_shifts:\n                num_shifts_worked += shifts[(n, d, s)]\n        model.add(min_shifts_per_nurse <= num_shifts_worked)\n        model.add(num_shifts_worked <= max_shifts_per_nurse)\n\n    model.maximize(\n        sum(\n            shift_requests[n][d][s] * shifts[(n, d, s)]\n            for n in all_nurses\n            for d in all_days\n            for s in all_shifts\n        )\n    )\n\n    # Creates the solver and solve.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL:\n        print(\"Solution:\")\n        for d in all_days:\n            print(\"Day\", d)\n            for n in all_nurses:\n                for s in all_shifts:\n                    if solver.value(shifts[(n, d, s)]) == 1:\n                        if shift_requests[n][d][s] == 1:\n                            print(\"Nurse\", n, \"works shift\", s, \"(requested).\")\n                        else:\n                            print(\"Nurse\", n, \"works shift\", s, \"(not requested).\")\n            print()\n        print(\n            f\"Number of shift requests met = {solver.objective_value}\",\n            f\"(out of {num_nurses * min_shifts_per_nurse})\",\n        )\n    else:\n        print(\"No optimal solution found !\")\n\n    # Statistics.\n    print(\"\\nStatistics\")\n    print(f\"  - conflicts: {solver.num_conflicts}\")\n    print(f\"  - branches : {solver.num_branches}\")\n    print(f\"  - wall time: {solver.wall_time}s\")\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools optimization package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/chemical_balance_lp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Conditional SCIP Usage Check in CMake\nDESCRIPTION: Checks if SCIP is enabled for the project. If not, the script returns early, skipping the rest of the configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/gscip/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT USE_SCIP)\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/seseman_b.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the Google OR-Tools package using pip, which is required to run the constraint programming example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/toNum.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools optimization package which is required to run the CVRP solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrp_reload.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the Google OR-Tools package, which is required for using the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_partition.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering_deployment.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing ortools package in Python\nDESCRIPTION: This command is used to install the ortools package using pip, the Python package installer. The ortools package provides tools for optimization, including linear and mixed-integer programming solvers. This is a prerequisite for running the subsequent code that solves the multiple knapsack problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/multiple_knapsack_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This shell command installs the ortools package using pip. It is a prerequisite for running the ranking sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/ranking_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package via pip\nDESCRIPTION: Basic pip command to install the OR-Tools package from PyPI\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/check_dependencies.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting JNI Target Properties\nDESCRIPTION: Configures the JNI target with include directories and linking options, including position-independent code settings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(jniinit PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jniinit PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jniinit PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/balance_group_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Building Complete Package Commands\nDESCRIPTION: Commands to build and pack the complete Google.OrTools package after collecting all runtime packages.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndotnet build <build_dir>/dotnet/Google.OrTools\ndotnet pack <build_dir>/dotnet/Google.OrTools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools package required for the maze solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/maze_escape_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the OR-Tools package using pip, the Python package installer. It ensures that the OR-Tools library and its dependencies are available for use in the Python environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/boolean_product_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the ortools package using pip, which is required for running the de Bruijn sequence generation code.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/debruijn_binary.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Solving Scheduling Model with OR-Tools in Python\nDESCRIPTION: This main function sets up and solves a scheduling model with given constraints and output results. Dependencies include the 'ortools.sat.python.cp_model' and Pandas library.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cumulative_variable_profile_sample_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"def main(_) -\\u003e None:\\n    \\\"\\\"\\\"Create the model and solves it.\\u0022\\u0022\\u0022\\n    max_load_df, min_load_df, tasks_df = create_data_model()\\n\\n    # Create the model.\\n    model = cp_model.CpModel()\\n\\n    # Get the max capacity from the capacity dataframe.\\n    max_load = max_load_df.max_load.max()\\n    print(f\\\"Max capacity = {max_load}\\\")\\n    print(f\\\"#tasks = {len(tasks_df)}\\\")\\n\\n    minutes_per_hour: int = 60\\n    horizon: int = 24 * 60\\n\\n    # Variables\\n    starts = model.new_int_var_series(\\n        name=\\\"starts\\\",\\n        lower_bounds=0,\\n        upper_bounds=horizon - tasks_df.duration,\\n        index=tasks_df.index,\\n    )\\n    performed = model.new_bool_var_series(name=\\\"performed\\\", index=tasks_df.index)\\n\\n    intervals = model.new_optional_fixed_size_interval_var_series(\\n        name=\\\"intervals\\\",\\n        index=tasks_df.index,\\n        starts=starts,\\n        sizes=tasks_df.duration,\\n        are_present=performed,\\n    )\\n\\n    # Set up the max profile. We use fixed (intervals, demands) to fill in the\\n    # space between the actual max load profile and the max capacity.\\n    time_period_max_intervals = model.new_fixed_size_interval_var_series(\\n        name=\\\"time_period_max_intervals\\\",\\n        index=max_load_df.index,\\n        starts=max_load_df.start_hour * minutes_per_hour,\\n        sizes=minutes_per_hour * 2,\\n    )\\n    time_period_max_heights = max_load - max_load_df.max_load\\n\\n    # Cumulative constraint for the max profile.\\n    model.add_cumulative(\\n        intervals.to_list() + time_period_max_intervals.to_list(),\\n        tasks_df.load.to_list() + time_period_max_heights.to_list(),\\n        max_load,\\n    )\\n\\n    # Set up complemented intervals (from 0 to start, and from start + size to\\n    # horizon).\\n    prefix_intervals = model.new_optional_interval_var_series(\\n        name=\\\"prefix_intervals\\\",\\n        index=tasks_df.index,\\n        starts=0,\\n        sizes=starts,\\n        ends=starts,\\n        are_present=performed,\\n    )\\n\\n    suffix_intervals = model.new_optional_interval_var_series(\\n        name=\\\"suffix_intervals\\\",\\n        index=tasks_df.index,\\n        starts=starts + tasks_df.duration,\\n        sizes=horizon - starts - tasks_df.duration,\\n        ends=horizon,\\n        are_present=performed,\\n    )\\n\\n    # Set up the min profile. We use complemented intervals to maintain the\\n    # complement of the work load, and fixed intervals to enforce the min\\n    # number of active workers per time period.\\n    #\\n    # Note that this works only if the max load cumulative is also added to the\\n    # model.\\n    time_period_min_intervals = model.new_fixed_size_interval_var_series(\\n        name=\\\"time_period_min_intervals\\\",\\n        index=min_load_df.index,\\n        starts=min_load_df.start_hour * minutes_per_hour,\\n        sizes=minutes_per_hour * 2,\\n    )\\n    time_period_min_heights = min_load_df.min_load\\n\\n    # We take into account optional intervals. The actual capacity of the min load\\n    # cumulative is the sum of all the active demands.\\n    sum_of_demands = sum(tasks_df.load)\\n    complement_capacity = model.new_int_var(0, sum_of_demands, \\\"complement_capacity\\\")\\n    model.add(complement_capacity == performed.dot(tasks_df.load))\\n\\n    # Cumulative constraint for the min profile.\\n    model.add_cumulative(\\n        prefix_intervals.to_list()\\n        + suffix_intervals.to_list()\\n        + time_period_min_intervals.to_list(),\\n        tasks_df.load.to_list()\\n        + tasks_df.load.to_list()\\n        + time_period_min_heights.to_list(),\\n        complement_capacity,\\n    )\\n\\n    # Objective: maximize the value of performed intervals.\\n    # 1 is the max priority.\\n    max_priority = max(tasks_df.priority)\\n    model.maximize(sum(performed * (max_priority + 1 - tasks_df.priority)))\\n\\n    # Create the solver and solve the model.\\n    solver = cp_model.CpSolver()\\n    # solver.parameters.log_search_progress = True  # Uncomment to see the logs.\\n    solver.parameters.num_workers = 16\\n    solver.parameters.max_time_in_seconds = 30.0\\n    status = solver.solve(model)\\n\\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\\n        start_values = solver.values(starts)\\n        performed_values = solver.boolean_values(performed)\\n        tasks: list[tuple[int, int, int]] = []\\n        for task in tasks_df.index:\\n            if performed_values[task]:\\n                print(\\n                    f\\\"task {task} duration={tasks_df[\\\"duration\\\"][task]} \\\"\\n                    f\\\"load={tasks_df[\\\"load\\\"][task]} starts at {start_values[task]}\\\"\\n                )\\n                tasks.append(\\n                    (start_values[task], tasks_df.duration[task], tasks_df.load[task])\\n                )\\n            else:\\n                print(f\\\"task {task} is not performed\\\")\\n        assert check_solution(\\n            tasks=tasks,\\n            min_load_df=min_load_df,\\n            max_load_df=max_load_df,\\n            period_length=2 * minutes_per_hour,\\n            horizon=horizon,\\n        )\\n    elif status == cp_model.INFEASIBLE:\\n        print(\\\"No solution found\\\")\\n    else:\\n        print(\\\"Something is wrong, check the status and the log of the solve\\\")\\n\\n\\nmain()\\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the ortools package using pip, which is required to run the rest of the code. It ensures that the OR-Tools library and its dependencies are available in the environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/all_different_except_zero_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Puzzle Examples and Imports\nDESCRIPTION: Imports required libraries and defines sample puzzle grids of different sizes (small, medium, big) using nested lists of integers\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import pywrapcp\nfrom collections import deque\n\nsmall = [[3, 2, -1, 3], [-1, -1, -1, 2], [3, -1, -1, -1], [3, -1, 3, 1]]\n\nmedium = [[-1, 0, -1, 1, -1, -1, 1, -1], [-1, 3, -1, -1, 2, 3, -1, 2],\n          [-1, -1, 0, -1, -1, -1, -1, 0], [-1, 3, -1, -1, 0, -1, -1, -1],\n          [-1, -1, -1, 3, -1, -1, 0, -1], [1, -1, -1, -1, -1, 3, -1, -1],\n          [3, -1, 1, 3, -1, -1, 3, -1], [-1, 0, -1, -1, 3, -1, 3, -1]]\n\nbig = [[3, -1, -1, -1, 2, -1, 1, -1, 1, 2], [1, -1, 0, -1, 3, -1, 2, 0, -1, -1],\n       [-1, 3, -1, -1, -1, -1, -1, -1, 3, -1],\n       [2, 0, -1, 3, -1, 2, 3, -1, -1, -1], [-1, -1, -1, 1, 1, 1, -1, -1, 3, 3],\n       [2, 3, -1, -1, 2, 2, 3, -1, -1, -1], [-1, -1, -1, 1, 2, -1, 2, -1, 3, 3],\n       [-1, 2, -1, -1, -1, -1, -1, -1, 2, -1],\n       [-1, -1, 1, 1, -1, 2, -1, 1, -1, 3], [3, 3, -1, 1, -1, 2, -1, -1, -1, 2]]\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/post_office_problem2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Solver Support Declaration\nDESCRIPTION: Lists all optimization solvers supported by OR-Tools, including both default enabled and disabled (*) solvers.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* CBC\n* CLP\n* CP-SAT\n* CPLEX\\*\n* GLOP\n* GLPK\\*\n* HiGHS\\*\n* PDLP\n* SCIP\n* XPRESS\n\n\\*: these solvers are disabled by default.\n```\n\n----------------------------------------\n\nTITLE: Launching Jupyter Notebook Server\nDESCRIPTION: Command to start the Jupyter Notebook server which opens the notebook dashboard in the default browser.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/README.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\njupyter notebook\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the Google OR-Tools package, which is required for using the CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/marathon2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/kakuro.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Number Base Conversion\nDESCRIPTION: Converts between a number and its representation as an array of integers in a specific base using constraint programming variables\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/divisible_by_9_through_1.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef toNum(solver, t, s, base):\n  tlen = len(t)\n  solver.Add(\n      s == solver.Sum([(base**(tlen - i - 1)) * t[i] for i in range(tlen)]))\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Python Package\nDESCRIPTION: Installation command for the OR-Tools optimization package using pip. This is required to run the network flow examples in the notebook.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/pyflow_example.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools optimization package required for the scheduling implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package for constraint solving.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins3.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package using pip. This is required to run the Nonogram solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Samples Build for OR-Tools\nDESCRIPTION: This snippet configures the build process for Python samples. It uses a glob pattern to find all .py files and adds them as samples using the add_python_sample function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/samples/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Data Model for VRP with Breaks in Python\nDESCRIPTION: Defines a function to create the data model for the VRP, including number of vehicles, depot location, time matrix, and service times.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_breaks_from_start.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data[\"num_vehicles\"] = 4\n    data[\"depot\"] = 0\n    data[\"time_matrix\"] = [\n        [0, 27, 38, 34, 29, 13, 25, 9, 15, 9, 26, 25, 19, 17, 23, 38, 33],\n        [27, 0, 34, 15, 9, 25, 36, 17, 34, 37, 54, 29, 24, 33, 50, 43, 60],\n        [38, 34, 0, 49, 43, 25, 13, 40, 23, 37, 20, 63, 58, 56, 39, 77, 37],\n        [34, 15, 49, 0, 5, 32, 43, 25, 42, 44, 61, 25, 31, 41, 58, 28, 67],\n        [29, 9, 43, 5, 0, 26, 38, 19, 36, 38, 55, 20, 25, 35, 52, 33, 62],\n        [13, 25, 25, 32, 26, 0, 11, 15, 9, 12, 29, 38, 33, 31, 25, 52, 35],\n        [25, 36, 13, 43, 38, 11, 0, 26, 9, 23, 17, 50, 44, 42, 25, 63, 24],\n        [9, 17, 40, 25, 19, 15, 26, 0, 17, 19, 36, 23, 17, 16, 33, 37, 42],\n        [15, 34, 23, 42, 36, 9, 9, 17, 0, 13, 19, 40, 34, 33, 16, 54, 25],\n        [9, 37, 37, 44, 38, 12, 23, 19, 13, 0, 17, 26, 21, 19, 13, 40, 23],\n        [26, 54, 20, 61, 55, 29, 17, 36, 19, 17, 0, 43, 38, 36, 19, 57, 17],\n        [25, 29, 63, 25, 20, 38, 50, 23, 40, 26, 43, 0, 5, 15, 32, 13, 42],\n        [19, 24, 58, 31, 25, 33, 44, 17, 34, 21, 38, 5, 0, 9, 26, 19, 36],\n        [17, 33, 56, 41, 35, 31, 42, 16, 33, 19, 36, 15, 9, 0, 17, 21, 26],\n        [23, 50, 39, 58, 52, 25, 25, 33, 16, 13, 19, 32, 26, 17, 0, 38, 9],\n        [38, 43, 77, 28, 33, 52, 63, 37, 54, 40, 57, 13, 19, 21, 38, 0, 39],\n        [33, 60, 37, 67, 62, 35, 24, 42, 25, 23, 17, 42, 36, 26, 9, 39, 0],\n    ]\n    # 15 min of service time\n    data[\"service_time\"] = [15] * len(data[\"time_matrix\"])\n    data[\"service_time\"][data[\"depot\"]] = 0\n    assert len(data[\"time_matrix\"]) == len(data[\"service_time\"])\n    return data\n```\n\n----------------------------------------\n\nTITLE: PlantUML Generation Command\nDESCRIPTION: Command to generate PNG images from PlantUML dot files in the documentation directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nplantuml -Tpng docs/{file}.dot\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package in a Colab environment using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/magic_sequence_distribute.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the OR-Tools package using pip, allowing you to use its functionalities for optimization problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/integer_programming_example.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for 3 Jugs MIP Problem\nDESCRIPTION: Imports the necessary modules from the OR-Tools library to solve the 3 jugs problem using MIP.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code snippet installs the OR-Tools package using pip. It's a prerequisite for running the solution hinting sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/solution_hinting_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Solving VRP with Multiple Starts and Ends using OR-Tools in Python\nDESCRIPTION: Implements the main function to solve a Vehicle Routing Problem with multiple start and end points using Google OR-Tools. It sets up the routing index manager, defines the routing model, and applies constraints and search parameters.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_starts_ends.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    \"\"\"Entry point of the program.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"starts\"], data[\"ends\"]\n    )\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        2000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Setting first solution heuristic.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console.\n    if solution:\n        print_solution(data, manager, routing, solution)\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip. This is a prerequisite for running the Quasigroup completion solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/quasigroup_completion.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Compiling OR-Tools with C++20 on Windows using Bazel and MSVC\nDESCRIPTION: Command to compile OR-Tools on Windows systems using Bazel with MSVC and C++20 support. This command builds the project with optimization enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbazel build -c opt --cxxopt=\"/std:c++20\" ...\n```\n\n----------------------------------------\n\nTITLE: Apache 2.0 License Header\nDESCRIPTION: Standard Apache 2.0 license header text with Google LLC copyright notice and reference to full license terms.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cvrptw_plot.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright 2025 Google LLC.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools optimization package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/rostering_with_travel.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/blending.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the Google OR-Tools optimization package via pip, which is required to run the weighted latency problem solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/weighted_latency_problem_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing ortools Package in Jupyter Notebook\nDESCRIPTION: The command is used to install the OR-Tools package in a Jupyter Notebook environment using pip. This is a prerequisite to using the library within the notebook for solving constraint satisfaction problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bool_or_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Defining Network Flow Graph Arcs in Protobuf\nDESCRIPTION: This code defines a network flow graph structure using repeated arc definitions. Each arc connects two nodes (tail and head) with a specified capacity. The arcs form a directed graph with source node 361 and sink node 362 along with various intermediate nodes.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\narcs {\n  tail: 74\n  head: 55\n  capacity: 3403922\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/volsay2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Running make command for help in CI testing\nDESCRIPTION: Shows how to get help for the Makefile used for CI testing. The Makefile provides commands for testing OR-Tools builds on various distributions.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the OR-Tools package required for the CP-SAT solver. Ensure that this package is installed in your environment before running the interval relations sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/interval_relations_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the OR-Tools package using pip, which is required for running the MIP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/3_jugs_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the ortools package using pip in a Jupyter/Colab environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/simple_mip_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package which is required for the constraint programming solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/nqueens_cp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/car.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Solving Bin Packing Problem with CP-SAT\nDESCRIPTION: Uses CP-SAT solver to optimize bin packing by creating boolean variables for item-bin assignments and minimizing bin usage\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bin_packing_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef main() -> None:\n    items, bins = create_data_model()\n\n    # Create the model.\n    model = cp_model.CpModel()\n\n    # Variables\n    # x[i, j] = 1 if item i is packed in bin j.\n    items_x_bins = pd.MultiIndex.from_product(\n        [items.index, bins.index], names=[\"item\", \"bin\"]\n    )\n    x = model.new_bool_var_series(name=\"x\", index=items_x_bins)\n\n    # y[j] = 1 if bin j is used.\n    y = model.new_bool_var_series(name=\"y\", index=bins.index)\n\n    # Constraints\n    # Each item must be in exactly one bin.\n    for unused_name, all_copies in x.groupby(\"item\"):\n        model.add_exactly_one(x[all_copies.index])\n\n    # The amount packed in each bin cannot exceed its capacity.\n    for selected_bin in bins.index:\n        items_in_bin = x.xs(selected_bin, level=\"bin\")\n        model.add(\n            items_in_bin.dot(items.weight)\n            <= bins.loc[selected_bin].capacity * y[selected_bin]\n        )\n\n    # Objective: minimize the number of bins used.\n    model.minimize(y.sum())\n\n    # Create the solver and solve the model.\n    solver = cp_model.CpSolver()\n    status = solver.solve(model)\n\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        print(f\"Number of bins used = {solver.objective_value}\")\n\n        x_values = solver.boolean_values(x)\n        y_values = solver.boolean_values(y)\n        active_bins = y_values.loc[lambda x: x].index\n\n        for b in active_bins:\n            print(f\"Bin {b}\")\n            items_in_active_bin = x_values.xs(b, level=\"bin\").loc[lambda x: x].index\n            for item in items_in_active_bin:\n                print(f\"  Item {item} - weight {items.loc[item].weight}\")\n            print(\n                \"  Packed items weight:\"\n                f\" {items.loc[items_in_active_bin].sum().to_string()}\"\n            )\n            print()\n\n        print(f\"Total packed weight: {items.weight.sum()}\")\n        print()\n        print(f\"Time = {solver.wall_time} seconds\")\n    elif status == cp_model.INFEASIBLE:\n        print(\"No solution found\")\n    else:\n        print(\"Something is wrong, check the status and the log of the solve\")\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python\nDESCRIPTION: Installs the OR-Tools library from the Python Package Index to enable solving linear optimization problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_task_sizes_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Running Makefile Help Command\nDESCRIPTION: Shows how to get help information for the Makefile. This command displays available options and instructions for using the Makefile.\nSOURCE: https://github.com/google/or-tools/blob/stable/makefiles/docs/ci.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Numerical Data Matrix\nDESCRIPTION: Two-column matrix of integers, with first line containing a sequence of numbers and subsequent lines containing tab-separated integer pairs. The data appears to represent graph edges or optimization constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/contrib/steel.txt#2025-04-17_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n20 12 14 17 18 19 20 23 24 25 26 27 28 29 30 32 35 39 42 43 44\n88\n111\n4\t1\n22\t2\n9\t3\n5\t4\n8\t5\n3\t6\n3\t4\n4\t7\n7\t4\n7\t8\n3\t6\n2\t6\n2\t4\n8\t9\n5\t10\n7\t11\n4\t7\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/einav_puzzle.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing ortools in Python\nDESCRIPTION: This snippet installs the `ortools` package, which is necessary for running the scheduling model in the script. It is a key dependency that provides access to Google's OR-Tools constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/nurses_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Prize Collecting VRP\nDESCRIPTION: Imports the necessary modules from OR-Tools CP-SAT solver and Python's typing library to implement a prize collecting vehicle routing problem with maximum distance constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\nfrom ortools.sat.python import cp_model\n```\n\n----------------------------------------\n\nTITLE: Main Package Dependencies Configuration\nDESCRIPTION: Configuration for the main package project file to include dependencies on runtime packages.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_3\n\nLANGUAGE: csproj\nCODE:\n```\n<ItemGroup Condition=\"Exists('{...}/packages/Google.OrTools.runtime.linux-x64.1.0.0.nupkg')\">\n  <PackageReference Include=\"Google.OrTools.runtime.linux-x64\" Version=\"1.0.0\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Initializing Vagrant with FreeBSD box\nDESCRIPTION: Command to initialize Vagrant with a FreeBSD 12 box template, creating a Vagrantfile that defines the virtual machine configuration.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nvagrant init generic/freebsd12\n```\n\n----------------------------------------\n\nTITLE: Defining Network Flow Graph Arcs in Protobuf Format\nDESCRIPTION: Defines directed edges (arcs) in a network flow graph using tail/head node IDs and capacity values. Format follows protocol buffer syntax with repeated arc records. Each arc contains required fields for source node (tail), destination node (head), and maximum flow capacity.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\narcs {\n  tail: 341\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 174\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 174\n  head: 362\n  capacity: 0\n}\n...\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Samples Build for OR-Tools\nDESCRIPTION: This snippet configures the build process for Java samples. It uses a glob pattern to find all .java files and adds them as samples using the add_java_sample function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/samples/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_JAVA_SAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(SAMPLE IN LISTS JAVA_SRCS)\n    add_java_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running Examples Using Makefile\nDESCRIPTION: Demonstrates how to execute example files using the provided Makefile command.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.java.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake run SOURCE=examples/BasicExample/BasicExample.java\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Command to install the Google OR-Tools package using pip, which is required to run the job shop scheduling example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/jobshop_with_maintenance_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Google Colab\nDESCRIPTION: This code snippet installs the OR-Tools package in a Google Colab environment using the pip package manager.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/ranking_circuit_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/cover_rectangle_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the required OR-Tools package using pip package manager.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/secret_santa.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools Libraries for VRP\nDESCRIPTION: Imports necessary modules from OR-Tools for solving Vehicle Routing Problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Installing pip3 Package Manager\nDESCRIPTION: Command to upgrade pip package manager to the latest version for Python3 using user installation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip3 install --user --upgrade pip\n```\n\n----------------------------------------\n\nTITLE: Calling the main Function in Python\nDESCRIPTION: This simple line executes the `main` function, which is presumed to contain the entry point and overall logic of the program. It signifies the start of the program's execution flow.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nmain()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools package required for solving optimization problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/tsp_circuit_board.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools package which is required for the optimization algorithms.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/appointments.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Displaying Python Package Directory Structure\nDESCRIPTION: This command uses the tree utility to display the directory structure of the built Python package, focusing on .py and .so files.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/python.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntree build --prune -U -P \"*.py|*.so*\" -I \"build\"\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools SAT Runner Installation in CMake\nDESCRIPTION: Sets up installation properties for the SAT runner executable, including platform-specific RPATH settings for macOS and Unix systems to ensure proper runtime library loading.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(GNUInstallDirs)\nif(APPLE)\n  set_target_properties(sat_runner PROPERTIES INSTALL_RPATH\n    \"@loader_path/../${CMAKE_INSTALL_LIBDIR};@loader_path\")\nelseif(UNIX)\n  cmake_path(RELATIVE_PATH CMAKE_INSTALL_FULL_LIBDIR\n             BASE_DIRECTORY ${CMAKE_INSTALL_FULL_BINDIR}\n             OUTPUT_VARIABLE libdir_relative_path)\n  set_target_properties(sat_runner PROPERTIES\n                        INSTALL_RPATH \"$ORIGIN/${libdir_relative_path}\")\nendif()\n\ninstall(TARGETS sat_runner)\n```\n\n----------------------------------------\n\nTITLE: Defining Network Graph Arcs with Capacities in Protobuf\nDESCRIPTION: This code defines the structure of a network flow graph where each arc connects a tail node to a head node with a specified capacity. The arcs appear to be part of a min-cut/max-flow problem structure, with nodes 361 and 362 serving as potential source and sink nodes. Many arcs have capacity values at the maximum 64-bit integer limit (9223372036854775806).\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\n  capacity: 9912\n}\narcs {\n  tail: 87\n  head: 106\n  capacity: 74929\n}\narcs {\n  tail: 361\n  head: 189\n  capacity: 31040\n}\narcs {\n  tail: 189\n  head: 362\n  capacity: 68959\n}\narcs {\n  tail: 189\n  head: 321\n  capacity: 289333\n}\narcs {\n  tail: 189\n  head: 169\n  capacity: 204234\n}\narcs {\n  tail: 189\n  head: 224\n  capacity: 741921\n}\narcs {\n  tail: 189\n  head: 207\n  capacity: 230745\n}\narcs {\n  tail: 189\n  head: 322\n  capacity: 1834011\n}\narcs {\n  tail: 189\n  head: 19\n  capacity: 62341\n}\narcs {\n  tail: 361\n  head: 98\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 98\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 1\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 1\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 211\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 211\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 114\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 114\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 117\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 117\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 20\n  capacity: 93102\n}\narcs {\n  tail: 20\n  head: 362\n  capacity: 6897\n}\narcs {\n  tail: 20\n  head: 2\n  capacity: 279405\n}\narcs {\n  tail: 20\n  head: 34\n  capacity: 112031\n}\narcs {\n  tail: 20\n  head: 21\n  capacity: 321958\n}\narcs {\n  tail: 20\n  head: 32\n  capacity: 12825082\n}\narcs {\n  tail: 20\n  head: 19\n  capacity: 4199016\n}\narcs {\n  tail: 20\n  head: 262\n  capacity: 184568\n}\narcs {\n  tail: 361\n  head: 230\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 230\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 31\n  capacity: 94909\n}\narcs {\n  tail: 31\n  head: 362\n  capacity: 5090\n}\narcs {\n  tail: 31\n  head: 32\n  capacity: 547114\n}\narcs {\n  tail: 31\n  head: 13\n  capacity: 305262\n}\narcs {\n  tail: 31\n  head: 51\n  capacity: 674140\n}\narcs {\n  tail: 31\n  head: 84\n  capacity: 483400\n}\narcs {\n  tail: 31\n  head: 52\n  capacity: 161979\n}\narcs {\n  tail: 31\n  head: 83\n  capacity: 752455\n}\narcs {\n  tail: 31\n  head: 50\n  capacity: 874412\n}\narcs {\n  tail: 361\n  head: 133\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 133\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 227\n  capacity: 84339\n}\narcs {\n  tail: 227\n  head: 362\n  capacity: 15660\n}\narcs {\n  tail: 227\n  head: 34\n  capacity: 262337\n}\narcs {\n  tail: 227\n  head: 76\n  capacity: 657517\n}\narcs {\n  tail: 227\n  head: 16\n  capacity: 86350\n}\narcs {\n  tail: 227\n  head: 246\n  capacity: 6291971\n}\narcs {\n  tail: 227\n  head: 226\n  capacity: 518692\n}\narcs {\n  tail: 227\n  head: 207\n  capacity: 140767\n}\narcs {\n  tail: 361\n  head: 136\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 136\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 39\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 39\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 244\n  capacity: 78292\n}\narcs {\n  tail: 244\n  head: 362\n  capacity: 21707\n}\narcs {\n  tail: 244\n  head: 245\n  capacity: 426167\n}\narcs {\n  tail: 244\n  head: 264\n  capacity: 449184\n}\narcs {\n  tail: 244\n  head: 47\n  capacity: 265545\n}\narcs {\n  tail: 244\n  head: 262\n  capacity: 278865\n}\narcs {\n  tail: 244\n  head: 284\n  capacity: 37469\n}\narcs {\n  tail: 244\n  head: 224\n  capacity: 66655\n}\narcs {\n  tail: 244\n  head: 322\n  capacity: 53117\n}\narcs {\n  tail: 244\n  head: 321\n  capacity: 23787\n}\narcs {\n  tail: 244\n  head: 19\n  capacity: 200825\n}\narcs {\n  tail: 244\n  head: 225\n  capacity: 1024334\n}\narcs {\n  tail: 244\n  head: 28\n  capacity: 319774\n}\narcs {\n  tail: 361\n  head: 45\n  capacity: 3558\n}\narcs {\n  tail: 45\n  head: 362\n  capacity: 96441\n}\narcs {\n  tail: 45\n  head: 46\n  capacity: 183763\n}\narcs {\n  tail: 45\n  head: 145\n  capacity: 707073\n}\narcs {\n  tail: 45\n  head: 26\n  capacity: 1480574\n}\narcs {\n  tail: 45\n  head: 127\n  capacity: 341373\n}\narcs {\n  tail: 45\n  head: 44\n  capacity: 1221967\n}\narcs {\n  tail: 45\n  head: 25\n  capacity: 659888\n}\narcs {\n  tail: 361\n  head: 249\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 249\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 50\n  capacity: 98593\n}\narcs {\n  tail: 50\n  head: 362\n  capacity: 1406\n}\narcs {\n  tail: 50\n  head: 51\n  capacity: 1558698\n}\narcs {\n  tail: 50\n  head: 31\n  capacity: 874412\n}\narcs {\n  tail: 50\n  head: 69\n  capacity: 283385\n}\narcs {\n  tail: 50\n  head: 83\n  capacity: 2337614\n}\narcs {\n  tail: 50\n  head: 68\n  capacity: 529795\n}\narcs {\n  tail: 50\n  head: 82\n  capacity: 1540481\n}\narcs {\n  tail: 361\n  head: 152\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 152\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 52\n  capacity: 98547\n}\narcs {\n  tail: 52\n  head: 362\n  capacity: 1452\n}\narcs {\n  tail: 52\n  head: 41\n  capacity: 455629\n}\narcs {\n  tail: 52\n  head: 70\n  capacity: 412413\n}\narcs {\n  tail: 52\n  head: 21\n  capacity: 3683843\n}\narcs {\n  tail: 52\n  head: 32\n  capacity: 255648\n}\narcs {\n  tail: 52\n  head: 51\n  capacity: 5413139\n}\narcs {\n  tail: 52\n  head: 53\n  capacity: 15133\n}\narcs {\n  tail: 52\n  head: 31\n  capacity: 161979\n}\narcs {\n  tail: 361\n  head: 251\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 251\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 343\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 343\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 246\n  capacity: 84834\n}\narcs {\n  tail: 246\n  head: 362\n  capacity: 15165\n}\narcs {\n  tail: 246\n  head: 76\n  capacity: 812345\n}\narcs {\n  tail: 246\n  head: 227\n  capacity: 6291971\n}\narcs {\n  tail: 246\n  head: 265\n  capacity: 1679513\n}\narcs {\n  tail: 246\n  head: 245\n  capacity: 212345\n}\narcs {\n  tail: 246\n  head: 226\n  capacity: 108569\n}\narcs {\n  tail: 361\n  head: 155\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 155\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 58\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 58\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 268\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 268\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 171\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 171\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 265\n  capacity: 89151\n}\narcs {\n  tail: 265\n  head: 362\n  capacity: 10848\n}\narcs {\n  tail: 265\n  head: 246\n  capacity: 1679513\n}\narcs {\n  tail: 265\n  head: 162\n  capacity: 1059833\n}\narcs {\n  tail: 265\n  head: 163\n  capacity: 508235\n}\narcs {\n  tail: 265\n  head: 264\n  capacity: 2401811\n}\narcs {\n  tail: 265\n  head: 245\n  capacity: 267042\n}\narcs {\n  tail: 361\n  head: 287\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 287\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 190\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 190\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 193\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 193\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 96\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 96\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 173\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 173\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 76\n  capacity: 99508\n}\narcs {\n  tail: 76\n  head: 362\n  capacity: 491\n}\narcs {\n  tail: 76\n  head: 77\n  capacity: 179350\n}\narcs {\n  tail: 76\n  head: 227\n  capacity: 694046\n}\narcs {\n  tail: 76\n  head: 246\n  capacity: 491185\n}\narcs {\n  tail: 76\n  head: 34\n  capacity: 2709268\n}\narcs {\n  tail: 76\n  head: 162\n  capacity: 313608\n}\narcs {\n  tail: 76\n  head: 143\n  capacity: 1012457\n}\narcs {\n  tail: 361\n  head: 262\n  capacity: 73534\n}\narcs {\n  tail: 262\n  head: 362\n  capacity: 26465\n}\narcs {\n  tail: 262\n  head: 145\n  capacity: 4394\n}\narcs {\n  tail: 262\n  head: 244\n  capacity: 278865\n}\narcs {\n  tail: 262\n  head: 20\n  capacity: 153806\n}\narcs {\n  tail: 262\n  head: 19\n  capacity: 248434\n}\narcs {\n  tail: 262\n  head: 126\n  capacity: 45640\n}\narcs {\n  tail: 262\n  head: 34\n  capacity: 69765\n}\narcs {\n  tail: 262\n  head: 322\n  capacity: 153574\n}\narcs {\n  tail: 262\n  head: 32\n  capacity: 149683\n}\narcs {\n  tail: 262\n  head: 85\n  capacity: 67768\n}\narcs {\n  tail: 262\n  head: 284\n  capacity: 136583\n}\narcs {\n  tail: 262\n  head: 321\n  capacity: 20294\n}\narcs {\n  tail: 262\n  head: 300\n  capacity: 381526\n}\narcs {\n  tail: 262\n  head: 13\n  capacity: 366887\n}\narcs {\n  tail: 361\n  head: 63\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 63\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 325\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 325\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 131\n  capacity: 97958\n}\narcs {\n  tail: 131\n  head: 362\n  capacity: 2041\n}\narcs {\n  tail: 131\n  head: 22\n  capacity: 213597\n}\narcs {\n  tail: 131\n  head: 113\n  capacity: 751824\n}\narcs {\n  tail: 131\n  head: 2\n  capacity: 2847937\n}\narcs {\n  tail: 131\n  head: 112\n  capacity: 460675\n}\narcs {\n  tail: 131\n  head: 150\n  capacity: 1163767\n}\narcs {\n  tail: 131\n  head: 130\n  capacity: 885018\n}\narcs {\n  tail: 361\n  head: 330\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 330\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 228\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 228\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 34\n  capacity: 95020\n}\narcs {\n  tail: 34\n  head: 362\n  capacity: 4979\n}\narcs {\n  tail: 34\n  head: 54\n  capacity: 79422\n}\narcs {\n  tail: 34\n  head: 16\n  capacity: 1405216\n}\narcs {\n  tail: 34\n  head: 35\n  capacity: 707131\n}\narcs {\n  tail: 34\n  head: 32\n  capacity: 1151946\n}\narcs {\n  tail: 34\n  head: 262\n  capacity: 13953\n}\narcs {\n  tail: 34\n  head: 76\n  capacity: 2603023\n}\narcs {\n  tail: 34\n  head: 53\n  capacity: 75677\n}\narcs {\n  tail: 34\n  head: 227\n  capacity: 288571\n}\narcs {\n  tail: 361\n  head: 233\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 233\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 305\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 305\n  head: 362\n  capacity: 0\n}\narcs {\n  tail: 361\n  head: 106\n  capacity: 3024\n}\narcs {\n  tail: 106\n  head: 362\n  capacity: 96975\n}\narcs {\n  tail: 106\n  head: 88\n  capacity: 4467\n}\narcs {\n  tail: 106\n  head: 107\n  capacity: 268050\n}\narcs {\n  tail: 106\n  head: 87\n  capacity: 71671\n}\narcs {\n  tail: 106\n  head: 78\n  capacity: 117620\n}\narcs {\n  tail: 106\n  head: 79\n  capacity: 3929566\n}\narcs {\n  tail: 106\n  head: 125\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools Python package using pip for solving optimization problems\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bin_packing_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Displaying OR-Tools Directory Structure\nDESCRIPTION: Shows the basic file structure obtained after decompressing the OR-Tools archive, including license, readme, examples, and makefile locations.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.java.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nor-tools/\n  [LICENSE](LICENSE)     <- Apache License.\n  [README.md](README.md) <- This file.\n  [examples](examples)   <- Java examples.\n  [Makefile](Makefile)   <- Main Makefile for Java.\n```\n\n----------------------------------------\n\nTITLE: Basic Markdown Documentation\nDESCRIPTION: Documentation header explaining the project's purpose as a Julia wrapper for Google's MathOpt using MathOptInterface.jl\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/julia/ORTools.jl/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# ORTools\n\nThis is the\n[MathOptInterface.jl](https://github.com/jump-dev/MathOptInterface.jl) Julia\nwrapper for Google's\n[MathOpt](https://developers.google.com/optimization/math_opt).\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/sequences_in_no_overlap_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/search_for_all_solutions_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Python Package\nDESCRIPTION: This snippet provides a command to install the OR-Tools package using pip. OR-Tools is a requirement for running the provided sample code.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/non_linear_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip. It's a prerequisite for running the main Dudeney number finder code.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/dudeney.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package via pip\nDESCRIPTION: Install the Google OR-Tools library using pip package manager in a Jupyter notebook environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/bin_packing_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the required Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/olympic.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools via pip\nDESCRIPTION: Command to install or upgrade the OR-Tools package from PyPI using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.python.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npython -m pip install --upgrade --user ortools\n```\n\n----------------------------------------\n\nTITLE: Installing ortools Package\nDESCRIPTION: This snippet shows how to install the ortools package in a Google Colab environment, which is prerequisite for running the MIP example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/mip_var_array.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting Up OR-Tools for Min-Cost Flow Problem in Python\nDESCRIPTION: This snippet installs the ortools package necessary for implementing the Min-Cost Flow algorithm. It is a prerequisite for running the subsequent code in a Google Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/graph/assignment_min_flow.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Running Python Tests for OR-Tools Package\nDESCRIPTION: This command runs only the Python tests for the OR-Tools package using CTest in the build directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/python.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd build\nctest -R \"python_.*\"\n```\n\n----------------------------------------\n\nTITLE: Parsing Numerical Data Grid\nDESCRIPTION: Grid of 9-column numerical data with ID, coordinates, timestamps and status flags. Each row contains numeric values representing location coordinates, time windows, and status indicators.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/pdptw_LRC2_10_6.txt#2025-04-17_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n603 401 281 -30 984 1224 10 201 0\n604 441 177 -24 3945 4185 10 633 0\n605 231 203 20 206 446 10 0 688\n...\n```\n\n----------------------------------------\n\nTITLE: Network Flow Arc Definitions in Protobuf\nDESCRIPTION: Defines network flow graph arcs with their tail nodes, head nodes, and capacity values. Most arcs connect to nodes 361 (source) and 362 (sink), with various intermediate nodes and capacity constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/max_flow_test1.pb.txt#2025-04-17_snippet_7\n\nLANGUAGE: protobuf\nCODE:\n```\narcs {\n  tail: 361\n  head: 14\n  capacity: 9223372036854775806\n}\narcs {\n  tail: 14\n  head: 362\n  capacity: 0\n}\n// Additional arcs omitted for brevity...\n```\n\n----------------------------------------\n\nTITLE: Running Make Command for Help in OR-Tools CI\nDESCRIPTION: Shows how to run the make command without arguments to display the help information for the CI testing system.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/docs/ci.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Analyzing Numerical Data Grid for OR-Tools\nDESCRIPTION: This snippet represents a large grid of numerical data, possibly used for testing or benchmarking OR-Tools algorithms. The data consists of integers arranged in rows and columns, which could represent various problem parameters or constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/cpp/wt40.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n   756   774   770   620   720   667   808   562   728   743   794   657   817   611   562   599   799   748   517   673\n   567   749   691   590   554   724   634   790   716   540   780   627   664   556   691   660   622   541   752   503\n    23    75    17    14    92    58    65    79    46    30    21    58   100    68     1    42    97   100     1    22\n     9     8    93    95    36    26    29    60     6    42    38    18    74    98    29    75    25    88    85    39\n     8     9     9     7     7     3     6     8     2     3     1     2     3     3     5     5     8     2     1     6\n     5     6     8     4     9     5     6     9     5     7     9     4     3     4     6     9     7     5     8     9\n   872   724   826   789   878   974   680   847   796   662   639   800   717   952   742   884   735   900   987   680\n   919   909   609   884   674   830   710   924   688   649   760   724   712   966   836   689   719   905   893   712\n    17     8    61    32    63    36    43    41    77    64    90    36    96    65    89    53    85    63     9    32\n    38    38    93    16    76    22    65    51    49    99    26    84    35     7    56    70    40    38    11    62\n    10     9    10     6     7     9     2    10     9     7     3     7     2     7     5     9     2     7     5     7\n     3     1    10     5     7     9     5     8     4     7     4     1     4     8     8     1     3     9     9     3\n   602   476   347   346   321   320   277   473   492   244   595   307   293   221   208   249   406   521   497   259\n   539   384   509   450   415   541   472   269   532   264   235   304   306   288   345   244   465   270   486   290\n    44    88    60    35    10    90    72    81    55    54    83    87    38    52    53    37    47     6    21    17\n    96    90     4    17    30    34    98    30    19    19    75    51    63    80    86    78    91     5    61    16\n     8     4     9     8     1     8     9     4     6    10     4     4     8     1     6     4     7     8     3     1\n     5     5     6     2     9     1     8     6     7     1     8     1     5     7     7     9     6     4     8     1\n   442   276   351   442   237   620   484   503   402   408   473   293   252   381   379   331   506   370   377   507\n   354   422   414   276   511   480   475   293   301   259   237   545   286   582   578   338   590   371   335   556\n     6    22    44    42    58    22    52    64    28     3    72    24    97    30    36    53    75    23    54    83\n    99    54    16    51    33    49    89    97    72    86    16    63    37    97    23    95    78    67     9    42\n     6     4     9    10     1     1     3     9     4     1    10     6     6     3     5     9     5     4     5    10\n     8     7     5    10    10     8     8     1     5     4     5     7     5     3     8     3    10     3     3     3\n   498   605   344   361   429   599   436   351   308   263   570   415   274   225   586   311   501   237   518   217\n   334   289   245   523   513   292   587   581   255   371   487   538   303   541   575   510   415   600   346   355\n    37    71    18    74    62    92    61    59    73    63     7    63    72    48    60    62    90    62     2    38\n    88    75    94    73    51     9    74    54    96    39    61    71    65    95    48    15    31    57     9    84\n     1     7     6     6     8     6     2     5     9     6     2     6    10     9     3     1     6     9     5     5\n    10     7     1     4     4     2    10     4     8     6     2     3     1     9     1    10    10     5     5     3\n   655   263   510   495   668   392   574   325   588   554   666   634   397   356   649   241   429   290   687   533\n   410   686   402   633   562   431   548   601   643   521   332   267   586   482   466   600   468   541   489   247\n   100    47    68    56     6     8    57    36    94    43    17    20    88    11    25    30    41    25    36    95\n    34    52    81    43    76    10    71     8     5    71    96    27    85    62    22    39    10    61    93    87\n     3     8    10     3     2     3     6     3     7     7     2     9     2     8     5     8     8     1     7     9\n     6     6     4     1     2    10     4     6     5     4    10     4     9     8     8     9     8     6     6     3\n   197   314   578   420   325   474   260   200   227   456   435   438   369   504   493   483   234   469   535   520\n   219   481   275   206   242   252   454   202   484   517   202   420   383   415   367   405   529   469   500   281\n    82    18    55    14     1    36    73    72    26     3     8    18     2    77    11    26     5    66     7    68\n    37    35   100    21    29    98    73    67    41    26    87    87    59    41    81    69    99    17    71     2\n     5     5     4     9    10     2     1     5     3     1     6     2     4     8     8     2     1     7     1     7\n    10     8     2     1     6     6     1     9     2     2     3     7     1     4     4    10     2     5     5     7\n     0     0   123     0     5   168   104    41     0     0     0    62   170    61   163    59     0   113    76     0\n    30    55     0   136    68   179     0     0    54     0     0     0     0     0   154    33     0    28   130     0\n     1     3    22    81    86    90    22    42    28    57    66    82    96    55    73    20    86    92    43    76\n    22    28    52    75    58    76    53    43    75     2    79    11    81    25    42    11    14    17    29    81\n     5     3     5     3     9     8     5     3    10     2     4     1     5     1     4     1     9     9     1     2\n     5     3     1     1     4    10     9     6     6     8     8     7    10     4     8     6     2     1     2     2\n     0   103     0    44     0     0    38   166     0     0    57     1     0     0   159     0    71     0     0    87\n   193     0     0     0     0     0   146   148     0   159   165    36    11    19    83     0     0     0    54     0\n     4    75    87    90    29    42    96    27    92    70    52    38    81     9    47    87    17    64    52    41\n    45    90    14    71    40    97    60    51     5    50    94    59    71    62    98    74    97     5    34    80\n     3     4     3     3     2    10     9     1     8     8     9     3     2     5     8    10     7     3     2     2\n     2     9    10     1     4     7     6     1     1     6     7     4     7     1     4     7     6     5    10     3\n    88   167   228     0     0     0    56   205     0    66     0     0     0     0     0     0     0   117     0   146\n     0     0     0    77    69   185     0   105     0     0   159     0    52    66     0     0   113    20     0   179\n    63    61    47    77    25    14    63    13    33    64     7    18    98    57    45     4    60    94    17    86\n    89    30    43    81    80    69    23    10    59    73    31    97    78    55    23    70    18    80    31    57\n     4     6     1     1     4     4     8     3     7     6     9     7     2     5     8     9     7     4     4     2\n     9     7     8     3     2     9     5     9     9     7     4     7     1     7     7     6     8     7     9     7\n   154   159    70    34    60   142   172   127     0     0   163     2     0   144     0     0   189   123    95     0\n     0     0    34     0   177     0   187     0     0    13    85     0     0     0   161    81     0     0   188    47\n    81    39    78    84    99    82    71    85    98    10    52    56    12    67    58    53     5    51     1    40\n    65    11    75    80    11    52    48    41    91    31    70    94    78    57    66    13    76    92    40    75\n     4    10     6     8     5     4     1     5     5     6     2     3     9     2     6     2     2    10     1    10\n     5     7     1     7     2     4     3     5    10     8     7     4     8     5     7     9     3     2     9     2\n     0   179    19     2   119     0    40    99    24     0     0    69     0     0     0     0   151   128   171     0\n    12   147     0     0     0     0    29   145     0   110   227    45   189     0     0     0     0    10     0     0\n    87    43    33    53     1    76    44    34    60    36    82    88    21    63    54    18    68    53    46    33\n    12    52    21    45    95    60    21    69    85    32    66    21    78    75    55    23    99    47    64    98\n     5     7    10     7     6     6     1     3     9     6     4     2     6    10     6     5     9     7     9     5\n     6     2     8     8     6     4    10     6     4     2     8     8     6     8     6     8     3     9     3     6\n  1267  1914  1785  1385  1653  1344  1888  2075  1804  1297  1990  1709  1561  1719  1947  2024  2095  2021  1591  1836\n  1616  1683  1703  1655  1612  1285  2041  1964  1720  1424  1465  1940  1747  2059  1868  1946  1597  1424  1564  1404\n    41    56    43    30    12    77    87    53    22    19    74    54    47    21    82    84    95    73    70    99\n    99    21    72    58    21    60     4    20    51    41    55    52     9    69    98    20    40   100    79    96\n     1     1     5     9     5     6     2     5     4     9     9     4     6     4     7     2     8     7     8     7\n     7     2     9     7     6    10     8     1     9     6    10     9     7     3     1     1     9     6     1     1\n  1494  1558  1707  1373  1538  1603  1783  2142  1765  1811  1878  1852  1675  1785  1921  1456  1879  1505  1979  1990\n  1387  1958  1519  1470  1475  1815  1739  1907  2090  1578  2190  1797  2202  2017  1352  1372  1485  2162  2054  2134\n    27    19    18    66    40    22    81    39    12    94    80    99    43    70    67    44    60    39    70    76\n    20    41    99     1     6    70    37    26    30    75    50    64    33    54    78    29    84    63    42    38\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the Google OR-Tools optimization package from PyPI using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_drop_nodes.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Colab environment. This is a prerequisite for running the main Volsay problem solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/volsay.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools package required for the solver\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/bacp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools optimization package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/clustering_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Java Bindings\nDESCRIPTION: Sets essential SWIG properties for the routing interface including C++ mode, module name, and compilation definitions. Configures the Java package structure for the generated bindings.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE routing.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE routing.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE routing.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE routing.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.constraintsolver)\nswig_add_library(jniconstraint_solver\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/constraintsolver\n  SOURCES routing.i)\n```\n\n----------------------------------------\n\nTITLE: Configuring GLOP Library Build in CMake for Google OR-Tools\nDESCRIPTION: This CMake script configures the build for the GLOP library in the Google OR-Tools project. It sets up the library as an object library with position-independent code, defines include directories, and specifies external dependencies including Abseil and Protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/glop/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nset(NAME ${PROJECT_NAME}_glop)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::glop ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Solution Hinting Implementation in C++\nDESCRIPTION: Shows solution hinting implementation in C++ using OR-Tools CP-SAT solver. Demonstrates variable creation, constraint addition, and solution hinting with a maximize objective.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/model.md#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stdlib.h>\n\n#include \"ortools/base/logging.h\"\n#include \"ortools/sat/cp_model.h\"\n#include \"ortools/sat/cp_model.pb.h\"\n#include \"ortools/sat/cp_model_solver.h\"\n#include \"ortools/sat/model.h\"\n#include \"ortools/util/sorted_interval_list.h\"\n\nnamespace operations_research {\nnamespace sat {\n\nvoid SolutionHintingSampleSat() {\n  CpModelBuilder cp_model;\n\n  const Domain domain(0, 2);\n  const IntVar x = cp_model.NewIntVar(domain).WithName(\"x\");\n  const IntVar y = cp_model.NewIntVar(domain).WithName(\"y\");\n  const IntVar z = cp_model.NewIntVar(domain).WithName(\"z\");\n\n  cp_model.AddNotEqual(x, y);\n\n  cp_model.Maximize(x + 2 * y + 3 * z);\n\n  // Solution hinting: x <- 1, y <- 2\n  cp_model.AddHint(x, 1);\n  cp_model.AddHint(y, 2);\n\n  Model model;\n\n  int num_solutions = 0;\n  model.Add(NewFeasibleSolutionObserver([&](const CpSolverResponse& r) {\n    LOG(INFO) << \"Solution \" << num_solutions;\n    LOG(INFO) << \"  x = \" << SolutionIntegerValue(r, x);\n    LOG(INFO) << \"  y = \" << SolutionIntegerValue(r, y);\n    LOG(INFO) << \"  z = \" << SolutionIntegerValue(r, z);\n    num_solutions++;\n  }));\n\n  // Solving part.\n  const CpSolverResponse response = SolveCpModel(cp_model.Build(), &model);\n  LOG(INFO) << CpSolverResponseStats(response);\n}\n\n}  // namespace sat\n}  // namespace operations_research\n\nint main() {\n  operations_research::sat::SolutionHintingSampleSat();\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing the Built Files\nDESCRIPTION: Command to install the built OR-Tools files to the system. This step is optional and typically used when you want to make the library available system-wide.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncmake --build build --target install\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Install the required Google OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/least_square.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Solver SWIG Interface\nDESCRIPTION: Sets up SWIG properties and generates Java bindings for the linear solver component. Configures C++ support, module name, compilation definitions, and package structure.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE linear_solver.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE linear_solver.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE linear_solver.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE linear_solver.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.linearsolver)\nswig_add_library(jnilinear_solver\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/linearsolver\n  SOURCES linear_solver.i)\n\ntarget_include_directories(jnilinear_solver PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jnilinear_solver PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jnilinear_solver PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Starting Vagrant virtual machine\nDESCRIPTION: Command to build and start a Vagrant virtual machine based on the configuration in the Vagrantfile.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nvagrant up\n```\n\n----------------------------------------\n\nTITLE: Main Program Entry Point\nDESCRIPTION: Main function to handle program execution and command line arguments\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef main(argv: Sequence[str]) -> None:\n    if len(argv) > 1:\n        raise app.UsageError(\"Too many command-line arguments.\")\n    prize_collecting_vrp()\n\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Data Input Matrix Format\nDESCRIPTION: A matrix-like data structure where each row contains an ID followed by numeric values and reference indices. The first line indicates total count (21), and entries are terminated with -999.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/pdtsp_prob10b.txt#2025-04-17_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n21\n1 682 266\n2 129 265 0 12\n3 298 495 0 13\n4 720 160 0 14\n5 93 10 0 15\n6 891 782 0 16\n7 888 533 0 17\n8 414 290 0 18\n9 61 22 0 19\n10 485 352 0 20\n11 817 619 0 21\n12 669 775 1 2\n13 628 117 1 3\n14 178 31 1 4\n15 733 97 1 5\n16 985 320 1 6\n17 319 0 1 7\n18 545 283 1 8\n19 331 664 1 9\n20 598 785 1 10\n21 245 810 1 11\n-999\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Python pip command to install the required Google OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/game_theory_taha.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Command to install Google's OR-Tools package in a Colab environment. This package is required to run the constraint programming solution.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/a_round_of_golf.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip. This is required to run the Langford's number problem solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/langford.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package from PyPI, which is required to run the alphametic solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/alphametic.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/photo_problem.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install the required Google OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/slitherlink.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python Notebook\nDESCRIPTION: This snippet installs the OR-Tools package in a Python environment, necessary to utilize Google's optimization tools for solving constraint problems. It presumes the execution within a Jupyter or Google Colab notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/cp_is_fun_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"python\\n%pip install ortools\\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip, which is required for the constraint programming solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/xkcd.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Python Package with pip\nDESCRIPTION: This command installs the Google OR-Tools optimization package via pip, which is required to run the assignment problem solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/tasks_and_workers_assignment_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the OR-Tools package using pip. This is required to use the OR-Tools library for optimization problems.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/assignment6_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip package manager.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins_grid_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the Google OR-Tools Python package in a Colab environment using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_pickup_delivery_lifo.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools optimization package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/flexible_job_shop_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This code snippet installs the Google OR-Tools package using pip. It's a prerequisite for running the set covering and partition algorithms.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering4.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Listing Available CMake Options\nDESCRIPTION: Command to display all available CMake configuration options for OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncmake -S. -Bbuild -LH\n```\n\n----------------------------------------\n\nTITLE: Generating SVG Documentation with PlantUML\nDESCRIPTION: Command for generating SVG diagrams from PlantUML dot files. This is used to create the pipeline visualizations included in the documentation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/python/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nplantuml -Tsvg docs/{file}.dot\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip. It's a prerequisite for running the project scheduling code.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/project_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: Installs the OR-Tools package using pip in a Google Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/kenken2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python\nDESCRIPTION: Installs the OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Google Colab\nDESCRIPTION: Command to install the Google OR-Tools package in the Colab environment through pip, which is required to run the constraint solver examples.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrptw_break.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Core C API Library Build in CMake\nDESCRIPTION: Creates and configures a CMake object library for the math optimization core C API. Sets up source files, include directories, and links required dependencies including Abseil strings and math optimization protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/core/c_api/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_core_c_api)\nadd_library(${NAME} OBJECT)\ntarget_sources(${NAME} PRIVATE solver.h solver.cc)\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Executing commands in Vagrant virtual machine\nDESCRIPTION: Command to run specific commands in the Vagrant virtual machine without establishing an interactive session.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nvagrant ssh -c \"pwd; ls project ...\"\n```\n\n----------------------------------------\n\nTITLE: Distance Matrix and Constants Definition\nDESCRIPTION: Defines the distance matrix between nodes and constants for maximum distance and visit values for the routing problem\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/prize_collecting_vrp_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nDISTANCE_MATRIX = [\n    [13175, 13197, 11653, 10370, 29929, 13435, 14711, 20959, 22300, 24280, 28831, 34799, 34211, 32292, 32259, 34013, 27354, 44048, 35660, 33171, 30012, 27094, 36551, 27537, 37429, 23517, 25197, 23060, 24542, 22301, 20390, 19032, 16249, 0, 5714, 12901, 21524, 20543, 22186, 23805],\n    # ... additional matrix rows omitted for brevity\n]\n\nMAX_DISTANCE = 80_000\n\nVISIT_VALUES = [60_000, 50_000, 40_000, 30_000] * (len(DISTANCE_MATRIX) // 4)\nVISIT_VALUES[0] = 0\n```\n\n----------------------------------------\n\nTITLE: Package Build Commands\nDESCRIPTION: Commands for building the runtime-specific and main NuGet packages using dotnet CLI.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndotnet pack Google.OrTools.runtime.{rid}\ndotnet pack Google.OrTools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip. It's a prerequisite for running the set covering solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package, which is required for using the CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/hidato.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Building and Running OR-Tools Notebook Locally\nDESCRIPTION: Commands to build and run the OR-Tools notebook locally using Bazel, with options for running as a server without opening a browser automatically.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbazel run -c opt --cxxopt=-std=c++17 ortools/python:ortools_notebook\n```\n\nLANGUAGE: bash\nCODE:\n```\nbazel run -c opt --cxxopt=-std=c++17 ortools/python:ortools_notebook -- --no-browser\n```\n\n----------------------------------------\n\nTITLE: Implementing Step Function with OR-Tools in Java\nDESCRIPTION: This code snippet shows how to implement a step function using OR-Tools in Java. It creates a CP-SAT model, defines variables and constraints to represent the step function, and solves the model while printing the solutions. The step function is defined for specific ranges of the primary variable 'x'.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/docs/integer_arithmetic.md#2025-04-17_snippet_12\n\nLANGUAGE: java\nCODE:\n```\npackage com.google.ortools.sat.samples;\n\nimport com.google.ortools.Loader;\nimport com.google.ortools.sat.CpModel;\nimport com.google.ortools.sat.CpSolver;\nimport com.google.ortools.sat.CpSolverSolutionCallback;\nimport com.google.ortools.sat.CpSolverStatus;\nimport com.google.ortools.sat.DecisionStrategyProto;\nimport com.google.ortools.sat.IntVar;\nimport com.google.ortools.sat.Literal;\nimport com.google.ortools.sat.SatParameters;\nimport com.google.ortools.util.Domain;\n\n/** Link integer constraints together. */\npublic class StepFunctionSampleSat {\n  public static void main(String[] args) throws Exception {\n    Loader.loadNativeLibraries();\n    // Create the CP-SAT model.\n    CpModel model = new CpModel();\n\n    // Declare our primary variable.\n    IntVar x = model.newIntVar(0, 20, \"x\");\n\n    // Create the expression variable and implement the step function\n    // Note it is not defined for var == 2.\n    //\n    //        -               3\n    // -- --      ---------   2\n    //                        1\n    //      -- ---            0\n    // 0 ================ 20\n    //\n    IntVar expr = model.newIntVar(0, 3, \"expr\");\n\n    // expr == 0 on [5, 6] U [8, 10]\n    Literal b0 = model.newBoolVar(\"b0\");\n    model.addLinearExpressionInDomain(x, Domain.fromValues(new long[] {5, 6, 8, 9, 10}))\n        .onlyEnforceIf(b0);\n    model.addEquality(expr, 0).onlyEnforceIf(b0);\n\n    // expr == 2 on [0, 1] U [3, 4] U [11, 20]\n    Literal b2 = model.newBoolVar(\"b2\");\n    model\n        .addLinearExpressionInDomain(\n            x, Domain.fromIntervals(new long[][] {{0, 1}, {3, 4}, {11, 20}}))\n        .onlyEnforceIf(b2);\n    model.addEquality(expr, 2).onlyEnforceIf(b2);\n\n    // expr == 3 when x = 7\n    Literal b3 = model.newBoolVar(\"b3\");\n    model.addEquality(x, 7).onlyEnforceIf(b3);\n    model.addEquality(expr, 3).onlyEnforceIf(b3);\n\n    // At least one bi is true. (we could use a sum == 1).\n    model.addBoolOr(new Literal[] {b0, b2, b3});\n\n    // Search for x values in increasing order.\n    model.addDecisionStrategy(new IntVar[] {x},\n        DecisionStrategyProto.VariableSelectionStrategy.CHOOSE_FIRST,\n        DecisionStrategyProto.DomainReductionStrategy.SELECT_MIN_VALUE);\n\n    // Create the solver.\n    CpSolver solver = new CpSolver();\n\n    // Force the solver to follow the decision strategy exactly.\n    solver.getParameters().setSearchBranching(SatParameters.SearchBranching.FIXED_SEARCH);\n    // Tell the solver to enumerate all solutions.\n    solver.getParameters().setEnumerateAllSolutions(true);\n\n    // Solve the problem with the printer callback.\n    CpSolverStatus unusedStatus = solver.solve(model, new CpSolverSolutionCallback() {\n      public CpSolverSolutionCallback init(IntVar[] variables) {\n        variableArray = variables;\n        return this;\n      }\n\n      @Override\n      public void onSolutionCallback() {\n        for (IntVar v : variableArray) {\n          System.out.printf(\"%s=%d \", v.getName(), value(v));\n        }\n        System.out.println();\n      }\n\n      private IntVar[] variableArray;\n    }.init(new IntVar[] {x, expr}));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Examining Build Directory Structure for OR-Tools .NET Package\nDESCRIPTION: Command to display the build directory layout for the .NET package, filtering out the obj and bin directories to show only the essential structure of generated files.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/dotnet.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntree build/dotnet --prune -I \"obj|bin\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip. This is a prerequisite for running the Survo puzzle solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/survo_puzzle.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet installs the OR-Tools package using pip, which is required for the knapsack problem implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/knapsack_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Data Building and Problem Setup\nDESCRIPTION: Function to create the initial dataset containing item dimensions, availability, values and colors. Sets up container dimensions and formats data for processing.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef build_data() -> tuple[pd.Series, int, int]:\n    \"\"\"Build the data frame.\"\"\"\n    data = \"\"\"\n    item         width    height available    value    color\n    k1             20       4       2        338.984   blue\n    k2             12      17       6        849.246   orange\n    k3             20      12       2        524.022   green\n    k4             16       7       9        263.303   red\n    k5              3       6       3        113.436   purple\n    k6             13       5       3        551.072   brown\n    k7              4       7       6         86.166   pink\n    k8              6      18       8        755.094   grey\n    k9             14       2       7        223.516   olive\n    k10             9      11       5        369.560   cyan\n    \"\"\"\n\n    data = pd.read_table(io.StringIO(data), sep=r\"\\s+\")\n    print(\"Input data\")\n    print(data)\n\n    max_height = 20\n    max_width = 30\n\n    print(f\"Container max_width:{max_width} max_height:{max_height}\")\n    print(f\"#Items: {len(data.index)}\")\n    return (data, max_height, max_width)\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Sorted Interval List\nDESCRIPTION: Sets SWIG properties for the sorted interval list interface file including C++ mode, module naming, and compilation definitions. Configures the Java package path for output generation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE sorted_interval_list.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE sorted_interval_list.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE sorted_interval_list.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE sorted_interval_list.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.util)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for OR-Tools GLOP Sample Application\nDESCRIPTION: This CMake configuration sets up a C++ project that uses Google's OR-Tools GLOP solver. It specifies the minimum CMake version, configures the project with C++17 support, links against the OR-Tools GLOP library, sets up testing, and configures installation directories.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/samples/glop/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(Sample VERSION 1.0.0 LANGUAGES CXX)\n\ninclude(CTest)\nfind_package(glop CONFIG REQUIRED)\n\nadd_executable(sample main.cpp)\ntarget_compile_features(sample PUBLIC cxx_std_17)\nset_target_properties(sample PROPERTIES VERSION ${PROJECT_VERSION})\ntarget_link_libraries(sample PRIVATE ortools::glop)\n\nif(BUILD_TESTING)\n  add_test(NAME sample_UT COMMAND sample)\nendif()\n\ninclude(GNUInstallDirs)\ninstall(TARGETS sample\n  EXPORT SampleTargets\n  DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Running Examples Using Maven\nDESCRIPTION: Shows how to compile and run examples using Maven commands in the example directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.java.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd examples/BasicExample\nmvn compile -B\nmvn run\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Jupyter notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nqueens.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries\nDESCRIPTION: Imports the necessary modules from the sys library and OR-Tools linear solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/magic_square_mip.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.linear_solver import pywraplp\n```\n\n----------------------------------------\n\nTITLE: Listing Dependencies for Google OR-Tools\nDESCRIPTION: This snippet contains a comprehensive list of dependencies with their specific versions used in the Google OR-Tools project. It includes core libraries like ZLIB, abseil-cpp, and Protobuf, mathematical programming solvers such as CoinUtils, Clp, and SCIP, Python integration libraries, and testing frameworks.\nSOURCE: https://github.com/google/or-tools/blob/stable/Dependencies.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nZLIB=1.3.1\nabseil-cpp=20240722.0\nProtobuf=v29.3\nEigen=3.4.0\nRe2=2024-04-01\nCoinUtils=2.11.12\nOsi=0.108.11\nClp=1.17.10\nCgl=0.60.9\nCbc=2.10.12\nGLPK=5.0\nHiGHS=v1.9.0\nScip=v920\n# Python\npybind11=v2.13.6\npybind11_abseil=v202402.0\npybind11_protobuf=84653a591aea5df482dc2bde42c19efafbd53a57\n# Testing\ngoogletest=v1.15.2\nbenchmark=v1.9.1\n```\n\n----------------------------------------\n\nTITLE: Running OR-Tools Example\nDESCRIPTION: Command to execute a sample Hidato puzzle example using OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.python.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npython examples/python/hidato_table.py\n```\n\n----------------------------------------\n\nTITLE: Conditional PDLP Build Setup in CMake for OR-Tools\nDESCRIPTION: This CMake script configures the build process for the PDLP component. It first checks if PDLP is enabled, then collects source files while excluding test files. It creates an OBJECT library with position-independent code and sets up the necessary include paths and dependencies such as Abseil, Eigen3, and OR-Tools protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/pdlp/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT USE_PDLP)\n  return()\nendif()\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/[^/]*_test\\\\.cc$\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/gtest[^/]*$\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/test[^/]*$\")\n\nset(NAME ${PROJECT_NAME}_pdlp)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::memory\n  absl::strings\n  absl::str_format\n  Eigen3::Eigen\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::pdlp ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Configuring OR-Tools Packing Library Build\nDESCRIPTION: Sets up the core packing library as an object library with position independent code. Configures include directories and links against required dependencies including abseil libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/packing/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/vector_bin_packing_main\\.cc\")\n\nset(NAME ${PROJECT_NAME}_packing)\n\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::flags\n  absl::strings\n  ${PROJECT_NAMESPACE}::ortools_proto)\n```\n\n----------------------------------------\n\nTITLE: Configuring Language-Specific Options in CMake for OR-Tools\nDESCRIPTION: This snippet sets up CMake options for language-specific builds including C++, .NET, Java, and Python. It includes options for documentation builds, language versions, targeted frameworks, and other language-specific settings.\nSOURCE: https://github.com/google/or-tools/blob/stable/CMakeLists.txt#2025-04-17_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CXX)\n  CMAKE_DEPENDENT_OPTION(BUILD_CXX_DOC \"Build the C++ doc\" OFF \"NOT BUILD_DOC\" ON)\n  message(STATUS \"C++: Build doc: ${BUILD_CXX_DOC}\")\nendif()\n\nif(BUILD_DOTNET)\n  option(UNIVERSAL_DOTNET_PACKAGE \"Build a .Net multi OS Package\" OFF)\n  message(STATUS \".Net: Create multiple OS Package: ${UNIVERSAL_DOTNET_PACKAGE}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_DOTNET_DOC \"Build the .Net doc\" OFF \"NOT BUILD_DOC\" ON)\n  message(STATUS \".Net: Build doc: ${BUILD_DOTNET_DOC}\")\n\n  set(DOTNET_LANG \"9.0\" CACHE STRING \"Specify the C# language version (default \\\"9.0\\\")\")\n  message(STATUS \".Net C# language version: ${DOTNET_LANG}\")\n\n  set(DOTNET_SAMPLE_LANG \"8.0\" CACHE STRING \"Specify the C# language version for samples (default \\\"8.0\\\")\")\n  message(STATUS \".Net Samples C# language version: ${DOTNET_SAMPLE_LANG}\")\n\n  option(USE_DOTNET_46 \"Use .Net Framework 4.6 support\" OFF)\n  message(STATUS \".Net: Use .Net Framework 4.6 support: ${USE_DOTNET_46}\")\n  option(USE_DOTNET_461 \"Use .Net Framework 4.6.1 support\" OFF)\n  message(STATUS \".Net: Use .Net Framework 4.6.1 support: ${USE_DOTNET_461}\")\n  option(USE_DOTNET_462 \"Use .Net Framework 4.6.2 support\" OFF)\n  message(STATUS \".Net: Use .Net Framework 4.6.2 support: ${USE_DOTNET_462}\")\n\n  option(USE_DOTNET_48 \"Use .Net Framework 4.8 support\" OFF)\n  message(STATUS \".Net: Use .Net Framework 4.8 support: ${USE_DOTNET_48}\")\n\n  option(USE_DOTNET_STD_21 \"Use .Net Standard 2.1 support\" OFF)\n  message(STATUS \".Net: Use .Net Framework 2.1 support: ${USE_DOTNET_STD_21}\")\n\n  if(APPLE AND CMAKE_SYSTEM_PROCESSOR MATCHES \"^(aarch64|arm64)\")\n    set(USE_DOTNET_CORE_31 OFF)\n  else()\n    option(USE_DOTNET_CORE_31 \"Use .Net Core 3.1 LTS support\" OFF)\n  endif()\n  message(STATUS \".Net: Use .Net Core 3.1 LTS support: ${USE_DOTNET_CORE_31}\")\n\n  option(USE_DOTNET_6 \"Use .Net 6.0 LTS support\" ON)\n  message(STATUS \".Net: Use .Net 6.0 LTS support: ${USE_DOTNET_6}\")\n\n  option(USE_DOTNET_7 \"Use .Net 7.0 support\" OFF)\n  message(STATUS \".Net: Use .Net 7.0 support: ${USE_DOTNET_7}\")\n\n  option(USE_DOTNET_8 \"Use .Net 8.0 LTS support\" OFF)\n  message(STATUS \".Net: Use .Net 8.0 support: ${USE_DOTNET_8}\")\n\n  option(USE_DOTNET_9 \"Use .Net 9.0 support\" OFF)\n  message(STATUS \".Net: Use .Net 9.0 support: ${USE_DOTNET_9}\")\nendif()\n\nif(BUILD_JAVA)\n  option(BUILD_FAT_JAR \"Create single .jar with all dependencies (including native binaries)\" OFF)\n  message(STATUS \"Java: Build single fat .jar: ${BUILD_FAT_JAR}\")\n\n  option(SKIP_GPG \"Disable GPG sign\" ON)\n  message(STATUS \"Java: Disable gpg:sign: ${SKIP_GPG}\")\n\n  option(UNIVERSAL_JAVA_PACKAGE \"Build a Java multi OS Package\" OFF)\n  message(STATUS \"Java: Create multiple OS package: ${UNIVERSAL_JAVA_PACKAGE}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_JAVA_DOC \"Build the Java doc\" OFF \"NOT BUILD_DOC\" ON)\n  message(STATUS \"Java: Build doc: ${BUILD_JAVA_DOC}\")\n\n  set(GPG_ARGS \"<arg>--pinentry-mode</arg><arg>loopback</arg>\" CACHE STRING \"Extra options for GPG\")\n  message(STATUS \"Java: Add GPG options: ${GPG_ARGS}\")\nendif()\n\nif(BUILD_PYTHON)\n  CMAKE_DEPENDENT_OPTION(BUILD_pybind11 \"Build the pybind11 dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Python: Build pybind11: ${BUILD_pybind11}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_pybind11_protobuf \"Build the pybind11_protobuf dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Python: Build pybind11_protobuf: ${BUILD_pybind11_protobuf}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_pybind11_abseil \"Build the pybind11_abseil dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Python: Build pybind11_abseil: ${BUILD_pybind11_abseil}\")\n\n  option(GENERATE_PYTHON_STUB \"Generate Python stub file (.pyi)\" ON)\n  message(STATUS \"Python: Generate stub file: ${GENERATE_PYTHON_STUB}\")\n\nCMAKE_DEPENDENT_OPTION(BUILD_PYTHON_DOC \"Build the Python doc\" OFF \"NOT BUILD_DOC\" ON)\n  message(STATUS \"Python: Build doc: ${BUILD_PYTHON_DOC}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_VENV \"Create Python venv in BINARY_DIR/python/venv\" OFF\n    \"NOT BUILD_TESTING\" ON)\n  message(STATUS \"Python: Create venv: ${BUILD_VENV}\")\n\n  CMAKE_DEPENDENT_OPTION(VENV_USE_SYSTEM_SITE_PACKAGES \"Python venv can use system site packages\" OFF\n    \"BUILD_VENV\" OFF)\n  message(STATUS \"Python: Allow venv to use system site packages: ${VENV_USE_SYSTEM_SITE_PACKAGES}\")\n\n  option(FETCH_PYTHON_DEPS \"Install python required modules if not available\" ${BUILD_DEPS})\n  message(STATUS \"Python: Fetch dependencies: ${FETCH_PYTHON_DEPS}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Tests in OR-Tools with CMake\nDESCRIPTION: This CMake script configures Python tests for the OR-Tools project. It collects all Python test files using a glob pattern, filters out tests that require external dependencies (like Gurobi and OSQP) or have known issues (segfaults, import failures), and adds the remaining tests to the test suite.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*\\/solve_gurobi_test\\.py\") # need gurobi\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*\\/solve_test\\.py\") # need OSQP\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*\\/normalize_test\\.py\") # need google3 stuff\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*\\/callback_test\") # segfault\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*\\/mathopt_test\") # import test fail\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating OR-Tools SAT Module Library in CMake\nDESCRIPTION: Defines the SAT module as an OBJECT library with position-independent code, sets include directories, and configures dependencies with various Abseil libraries, Protobuf, and optionally Coin-OR CBC.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::any\n  absl::memory\n  absl::synchronization\n  absl::strings\n  absl::str_format\n  protobuf::libprotobuf\n  $<$<BOOL:${USE_COINOR}>:Coin::Cbc>\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::sat ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for RCPSP Module in CMake\nDESCRIPTION: Specifies the libraries that the RCPSP module depends on, including the OR-Tools library, pybind11 protobuf caster, and protobuf library. This links all required components to the module.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(rcpsp_pybind11 PRIVATE\n  ${PROJECT_NAMESPACE}::ortools\n  pybind11_native_proto_caster\n  protobuf::libprotobuf)\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Storage Library Build in CMake\nDESCRIPTION: Sets up a CMake object library target for OR-Tools math optimization storage component. Configures source files, include directories, and links required dependencies including Abseil strings and math optimization protocol buffers.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/storage/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_storage)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories and Alias for RCPSP Module in CMake\nDESCRIPTION: Configures include directories for the RCPSP module build process and creates an alias target for the module. This ensures the correct header files are found during compilation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(rcpsp_pybind11 PRIVATE ${protobuf_SOURCE_DIR})\nadd_library(${PROJECT_NAMESPACE}::rcpsp_pybind11 ALIAS rcpsp_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Building Python Samples in OR-Tools\nDESCRIPTION: Finds all Python source files with .py extension and processes them using add_python_sample function when BUILD_PYTHON_SAMPLES is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/samples/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring COIN-OR Solvers in CMake for OR-Tools\nDESCRIPTION: This snippet sets up CMake options for COIN-OR solvers (Cbc, Clp) and their dependencies. It includes options to build CoinUtils, Osi, Clp, Cgl, and Cbc libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nCMAKE_DEPENDENT_OPTION(USE_COINOR \"Use the COIN-OR solver\" ON \"BUILD_CXX\" OFF)\nmessage(STATUS \"COIN-OR support: ${USE_COINOR}\")\nif(USE_COINOR)\n  CMAKE_DEPENDENT_OPTION(BUILD_CoinUtils \"Build the CoinUtils dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Build CoinUtils: ${BUILD_CoinUtils}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_Osi \"Build the Osi dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Build Osi: ${BUILD_Osi}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_Clp \"Build the Clp dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Build Clp: ${BUILD_Clp}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_Cgl \"Build the Cgl dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Build Cgl: ${BUILD_Cgl}\")\n\n  CMAKE_DEPENDENT_OPTION(BUILD_Cbc \"Build the Cbc dependency Library\" OFF\n    \"NOT BUILD_DEPS\" ON)\n  message(STATUS \"Build Cbc: ${BUILD_Cbc}\")\nelse()\n  set(BUILD_CoinUtils OFF)\n  set(BUILD_Osi OFF)\n  set(BUILD_Clp OFF)\n  set(BUILD_Cgl OFF)\n  set(BUILD_Cbc OFF)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This snippet installs the 'ortools' package which is necessary to run the following assignment problem solver code. It uses the pip package manager to ensure the library is available in the Python environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/assignment_task_sizes_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Platform-Specific Properties for RCPSP Module in CMake\nDESCRIPTION: Sets platform-specific properties for the RCPSP module, handling different runtime path configurations for macOS and Unix platforms. This ensures the module can correctly locate dependencies at runtime.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/scheduling/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# note: macOS is APPLE and also UNIX !\nif(APPLE)\n  set_target_properties(rcpsp_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\")\nelseif(UNIX)\n  set_target_properties(rcpsp_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Constraints Library in CMake\nDESCRIPTION: Sets up a CMake library target for mathematical optimization constraints utilities. Configures source files, include directories, and dependencies including Abseil strings and math optimization protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/util/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_constraints_util)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*_test.cc\")\n\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: CPLEX Configuration Instructions\nDESCRIPTION: Details how to enable and configure CPLEX solver support in the build, including path configuration options and environment variables.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nTo enable CPLEX support, configure with `-DUSE_CPLEX=ON` and\n`-DCPLEX_ROOT=/absolute/path/to/CPLEX/root/dir`, replacing\n`/absolute/path/to/CPLEX/root/dir` with the path to your CPLEX installation.\n`CPLEX_ROOT` can also be defined as an environment variable rather than an\noption at configure time.\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Constraints Library in CMake\nDESCRIPTION: Sets up a CMake library target for OR-Tools math optimization constraints indicator component. Configures source files, include directories, and links required dependencies like absl::strings and math_opt_proto.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/indicator/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_constraints_indicator)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*_test.cc\")\n\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the required Google OR-Tools package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/broken_weights.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific RPATH Configuration\nDESCRIPTION: Sets platform-specific RPATH properties for macOS and Unix systems to ensure proper library loading paths.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(APPLE)\n  set_target_properties(sorted_interval_list_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\")\nelseif(UNIX)\n  set_target_properties(sorted_interval_list_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Test Cases for Second Order Cone Constraints\nDESCRIPTION: Sets up test configurations for the second-order cone constraints component when BUILD_TESTING is enabled. Configures test sources and links required testing dependencies including Google Test and Google Mock frameworks.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/second_order_cone/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        math_opt_constraints_soc_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        #benchmark::benchmark\n        GTest::gmock\n        GTest::gtest_main\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools package required for the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/furniture_moving.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Commented Protobuf File Processing Configuration in CMake\nDESCRIPTION: Commented code that would find all .proto files, then generate corresponding C++ headers and source files using protoc compiler. The code demonstrates a typical protobuf integration pattern in CMake builds.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/cpp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n#file(GLOB_RECURSE proto_files RELATIVE ${PROJECT_SOURCE_DIR} \"*.proto\")\n#foreach(PROTO_FILE IN LISTS proto_files)\n#  message(STATUS \"protoc proto(cc): ${PROTO_FILE}\")\n#  get_filename_component(PROTO_DIR ${PROTO_FILE} DIRECTORY)\n#  get_filename_component(PROTO_NAME ${PROTO_FILE} NAME_WE)\n#  set(PROTO_HDR ${PROJECT_BINARY_DIR}/${PROTO_DIR}/${PROTO_NAME}.pb.h)\n#  set(PROTO_SRC ${PROJECT_BINARY_DIR}/${PROTO_DIR}/${PROTO_NAME}.pb.cc)\n#  message(STATUS \"protoc hdr: ${PROTO_HDR}\")\n#  message(STATUS \"protoc src: ${PROTO_SRC}\")\n#  add_custom_command(\n#    OUTPUT ${PROTO_SRC} ${PROTO_HDR}\n#    COMMAND ${PROTOC_PRG}\n#    \"--proto_path=${PROJECT_SOURCE_DIR}\"\n#    ${PROTO_DIRS}\n#    \"--cpp_out=${PROJECT_BINARY_DIR}\"\n#    ${PROTO_FILE}\n#    DEPENDS ${PROTO_FILE} ${PROTOC_PRG}\n#    COMMENT \"Generate C++ protocol buffer for ${PROTO_FILE}\"\n#    VERBATIM)\n#  list(APPEND PROTO_HDRS ${PROTO_HDR})\n#  list(APPEND PROTO_SRCS ${PROTO_SRC})\n#endforeach()\n```\n\n----------------------------------------\n\nTITLE: Library Linking and Alias Creation\nDESCRIPTION: Links the Python module with OR-Tools library and creates an alias target for the module.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(sorted_interval_list_pybind11 PRIVATE ${PROJECT_NAMESPACE}::ortools)\nadd_library(${PROJECT_NAMESPACE}::sorted_interval_list_pybind11 ALIAS sorted_interval_list_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Tests\nDESCRIPTION: Configures Python test files when BUILD_TESTING is enabled. Searches for all Python test files and adds them to the test suite.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Python Test Configuration\nDESCRIPTION: Configures Python tests by globbing test files and adding them to the test suite when BUILD_TESTING is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building C++ Samples in OR-Tools\nDESCRIPTION: Finds all C++ source files with .cc extension and builds them as samples using the add_cxx_sample function when BUILD_CXX_SAMPLES is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This snippet installs the OR-Tools library necessary for running the scheduling algorithm in Google Colab.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/vendor_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Platform-Specific Properties for macOS in CMake\nDESCRIPTION: Sets platform-specific properties for the CP Model Helper PyBind11 module on macOS systems. It ensures the correct suffix is used and sets the runtime path for loading dependent libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/python/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# note: macOS is APPLE and also UNIX !\nif(APPLE)\n  set_target_properties(cp_model_helper_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\")\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Example Builds for Google OR-Tools\nDESCRIPTION: This snippet sets up the build process for .NET examples. It glob's all .cs files and adds each as a .NET example using a custom CMake function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/tests/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_DOTNET_EXAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building Java Samples in OR-Tools\nDESCRIPTION: Finds all Java source files with .java extension and builds them using add_java_sample function when BUILD_JAVA_SAMPLES is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/samples/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_JAVA_SAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(SAMPLE IN LISTS JAVA_SRCS)\n    add_java_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Command to install the Google OR-Tools package in a Colab environment. This is required before running the line balancing solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/line_balancing_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Properties for OR-Tools C# Utility Target\nDESCRIPTION: Sets build properties for the dotnet_util target, including position-independent code and SWIG include directories. Also links the target with the main OR-Tools library to provide the underlying implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n#target_include_directories(dotnet_util PRIVATE ${DOTNET_INCLUDE_DIRS})\nset_target_properties(dotnet_util PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_util PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project Settings\nDESCRIPTION: Sets up basic CMake project configuration including version requirements, language standards, and build type settings. Configures project name, version and supported programming languages.\nSOURCE: https://github.com/google/or-tools/blob/stable/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.20)\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\nproject(ortools VERSION ${VERSION} LANGUAGES CXX C)\nset(PROJECT_NAMESPACE ortools)\n\nif(MSVC)\n  set(CMAKE_CXX_STANDARD 20)\nelse()\n  set(CMAKE_CXX_STANDARD 17)\nendif()\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting Model Builder Library Properties\nDESCRIPTION: Configures target properties for the model builder library including SWIG include directories and position independent code settings. Links against the core OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/csharp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(dotnet_model_builder PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_model_builder PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring JNI Target Properties\nDESCRIPTION: Sets up include directories and target properties for the JNI utility library. Configures position-independent code and links against the core OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(jniutil PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jniutil PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jniutil PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Setting Properties and Dependencies for SAT .NET Library\nDESCRIPTION: Configures build properties for the dotnet_sat target, enabling position-independent code and SWIG target include directories. Links the target with the main OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n#target_include_directories(dotnet_sat PRIVATE ${DOTNET_INCLUDE_DIRS})\nset_target_properties(dotnet_sat PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_sat PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the Google OR-Tools package using pip, which is required for the CP Solver implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering_skiena.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Tests for OR-Tools in CMake\nDESCRIPTION: Sets up .NET tests if BUILD_TESTING is enabled. It glob's all test files ending with 'Tests.cs' and adds them as .NET tests.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/csharp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB DOTNET_SRCS \"*Tests.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking Dependencies for Math Optimization Module\nDESCRIPTION: Configures library dependencies for the math optimization module including OR-Tools, protobuf, and pybind11 components\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/core/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(math_opt_pybind11 PRIVATE\n  ${PROJECT_NAMESPACE}::ortools\n  pybind11_abseil::absl_casters\n  pybind11_abseil::status_casters\n  pybind11_native_proto_caster\n  protobuf::libprotobuf)\nadd_library(${PROJECT_NAMESPACE}::math_opt_pybind11 ALIAS math_opt_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Adding Java Tests Configuration\nDESCRIPTION: Conditional block for adding Java tests, globbing test files and creating test targets for each test file found.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/java/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB JAVA_SRCS \"*Test.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: Installs the Google OR-Tools package using pip, which is required for the CP Solver implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/discrete_tomography.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Testing Python in Alpine Container\nDESCRIPTION: Shows an example of running Python tests within an Alpine Linux container. This command uses the Makefile to orchestrate the test execution.\nSOURCE: https://github.com/google/or-tools/blob/stable/makefiles/docs/ci.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nmake alpine_python_test\n```\n\n----------------------------------------\n\nTITLE: Conditional Build Configuration in CMake\nDESCRIPTION: Checks if math optimization should be built and returns early if not enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BUILD_MATH_OPT)\n  return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Tests for OR-Tools Routing Module in CMake\nDESCRIPTION: Configures Python tests for the routing module when BUILD_TESTING is enabled, adding each *_test.py file as a test.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/python/CMakeLists.txt#2025-04-17_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating jnigraph Library with SWIG in CMake\nDESCRIPTION: Adds a SWIG-generated library named jnigraph for Java, specifying the output directory and source file.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nswig_add_library(jnigraph\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/graph\n  SOURCES graph.i)\n```\n\n----------------------------------------\n\nTITLE: Adding Python Tests in CMake for OR-Tools\nDESCRIPTION: This snippet adds Python tests for OR-Tools if BUILD_TESTING is enabled. It glob-searches for all Python test files and adds them as tests using the add_python_test function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiling OR-Tools with C++17 on UNIX using Bazel\nDESCRIPTION: Command to compile OR-Tools on UNIX systems using Bazel with C++17 support. This command builds the project with optimization enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbazel build -c opt --cxxopt=-std=c++17 ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Cbc Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build Cbc library. It specifies the git repository, version tag, and applies a patch. This is conditionally executed if BUILD_Cbc is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_Cbc)\n  message(CHECK_START \"Fetching Cbc\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    Cbc\n    GIT_REPOSITORY \"https://github.com/Mizux/Cbc.git\"\n    GIT_TAG \"cmake/2.10.12\"\n    GIT_SHALLOW TRUE\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/cbc-2.10.patch\")\n  FetchContent_MakeAvailable(Cbc)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Solving Job Shop Scheduling Problem with CP-SAT Solver in Python\nDESCRIPTION: This code configures and runs the CP-SAT solver to find a solution for the job shop scheduling problem. It sets a time limit, applies custom parameters if provided, and uses a solution printer callback.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/scheduling_with_transitions_sat.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n#----------------------------------------------------------------------------\n  # Solve.\n  solver = cp_model.CpSolver()\n  solver.parameters.max_time_in_seconds = 60 * 60 * 2\n  if parameters:\n    text_format.Merge(parameters, solver.parameters)\n  solution_printer = SolutionPrinter(makespan)\n  status = solver.Solve(model, solution_printer)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Output Directories\nDESCRIPTION: Sets up build directory structure and output locations for different platforms (Unix/Windows). Configures paths for libraries, archives and runtime outputs.\nSOURCE: https://github.com/google/or-tools/blob/stable/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(UNIX)\n  option(BUILD_SHARED_LIBS \"Build shared libraries (.so or .dylib).\" ON)\n  set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\n  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\n  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\n  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\nelse()\n  option(BUILD_SHARED_LIBS \"Build shared libraries (.dll).\" ON)\n  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Testing Python in Alpine container\nDESCRIPTION: Example command to test the Python implementation of OR-Tools inside an Alpine Linux container.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/ci.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nmake alpine_python_test\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Solver Library Build\nDESCRIPTION: Sets up the core linear solver library build configuration, including source files, compiler options, and dependencies. Creates an OBJECT library that will be merged into libortools.so.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(REMOVE_ITEM _SRCS\n  ${CMAKE_CURRENT_SOURCE_DIR}/solve.cc\n)\nlist(FILTER _SRCS EXCLUDE REGEX \"/model_exporter_main\\.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \".*/.*_test.cc\")\nif(USE_SCIP)\n  list(APPEND _SRCS ${LPI_GLOP_SRC})\nendif()\n\nset(NAME ${PROJECT_NAME}_linear_solver)\n\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build Tree\nDESCRIPTION: Command to configure the CMake build tree with a Release configuration and enabling dependency building. This sets up the build environment before compilation.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/cpp.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release -DBUILD_DEPS=ON\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Minesweeper Solver\nDESCRIPTION: Imports the necessary modules from the sys library and the OR-Tools constraint solver package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/minesweeper.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Raw Grid Data Format\nDESCRIPTION: A tabular data format containing ID, coordinates (x,y), movement parameters, time windows, and reference points. Each row represents a distinct point or movement instruction in the grid system.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/pdptw_LRC2_10_6.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n303 440 241 -10 1145 1385 10 573 0\n304 100 266 -10 526 766 10 126 0\n305 111 178 18 506 746 10 0 748\n306 91 101 10 1133 1373 10 0 310\n307 25 307 10 938 1178 10 0 100\n...\n```\n\n----------------------------------------\n\nTITLE: Running .NET-Specific Tests for OR-Tools\nDESCRIPTION: Command to run only the .NET-related tests from the test suite using CTest with a regular expression filter to select test names starting with 'dotnet_'.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/dotnet.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd build\nctest -R \"dotnet_.*\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Port Library Build in CMake\nDESCRIPTION: Configures the build process for the OR-Tools port library component. Sets up source file collection, creates an object library with position independent code, and configures include directories and dependencies including Abseil, Protobuf, and OR-Tools proto libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/port/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\nlist(FILTER _SRCS EXCLUDE REGEX \"/[^/]*_test\\.cc$\")\n\nset(NAME ${PROJECT_NAME}_port)\n\n# Will be merge in libortools.so\n#add_library(${NAME} STATIC ${_SRCS})\nadd_library(${NAME} OBJECT ${_SRCS})\nset_target_properties(${NAME} PROPERTIES\n  POSITION_INDEPENDENT_CODE ON\n  )\ntarget_include_directories(${NAME} PRIVATE\n  ${PROJECT_SOURCE_DIR}\n  ${PROJECT_BINARY_DIR})\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  protobuf::libprotobuf\n  ${PROJECT_NAMESPACE}::ortools_proto)\n#add_library(${PROJECT_NAMESPACE}::port ALIAS ${NAME})\n```\n\n----------------------------------------\n\nTITLE: CMake Build Requirements Configuration\nDESCRIPTION: Specifies the minimum CMake version (3.18) and C++ compiler requirements (C++20, GCC 10+) needed to build OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `CMake >= 3.18`.\n* A C++20 compiler (GCC 10 or above)\n```\n\n----------------------------------------\n\nTITLE: Creating pybind11 Module for PDLP\nDESCRIPTION: Creates a Python module for PDLP using pybind11, configuring platform-specific properties for macOS and Unix systems. The configuration ensures proper library output naming and runtime search paths for dynamic libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/pdlp/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(pdlp_pybind11 MODULE pdlp.cc)\n# note: macOS is APPLE and also UNIX !\nset_target_properties(pdlp_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"pdlp\")\nif(APPLE)\n  set_target_properties(pdlp_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\")\nelseif(UNIX)\n  set_target_properties(pdlp_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\")\nendif()\ntarget_link_libraries(pdlp_pybind11 PRIVATE\n  ${PROJECT_NAMESPACE}::ortools\n  pybind11_native_proto_caster\n  protobuf::libprotobuf)\ntarget_include_directories(pdlp_pybind11 PRIVATE ${protobuf_SOURCE_DIR})\nadd_library(${PROJECT_NAMESPACE}::pdlp_pybind11 ALIAS pdlp_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Fetching Protobuf via FetchContent in CMake\nDESCRIPTION: CMake code to fetch the Protobuf library from GitHub using FetchContent. It configures various Protobuf build options and applies a patch to the fetched source code.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/host.CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(CHECK_START \"Fetching Protobuf\")\nlist(APPEND CMAKE_MESSAGE_INDENT \"  \")\nset(protobuf_BUILD_TESTS OFF)\nset(protobuf_BUILD_SHARED_LIBS ON)\nset(protobuf_BUILD_EXPORT OFF)\nset(protobuf_MSVC_STATIC_RUNTIME OFF)\nset(protobuf_WITH_ZLIB OFF)\nFetchContent_Declare(\n  protobuf\n  GIT_REPOSITORY \"https://github.com/protocolbuffers/protobuf.git\"\n  GIT_TAG \"v29.3\"\n  GIT_SUBMODULES \"\"\n  PATCH_COMMAND git apply \"${CMAKE_CURRENT_LIST_DIR}/@PATCHES_PATH@/protobuf-v29.3.patch\")\nFetchContent_MakeAvailable(protobuf)\nlist(POP_BACK CMAKE_MESSAGE_INDENT)\nmessage(CHECK_PASS \"fetched\")\n```\n\n----------------------------------------\n\nTITLE: Finding and Filtering C++ Source Files in CMake\nDESCRIPTION: Finds all C++ source files in the directory and filters out specific examples that have issues like crashes, missing dependencies, or excessive runtime. This maintains a clean build by excluding problematic examples.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/cpp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB CXX_SRCS \"*.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/binpacking_2d_sat.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/course_scheduling_run.cc\") # missing proto\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/course_scheduling.cc\") # missing proto\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/dimacs_assignment.cc\") # crash\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/dobble_ls.cc\") # Too long\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/fap_model_printer.cc\") # lib\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/fap_parser.cc\") # lib\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/fap_utilities.cc\") # lib\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/frequency_assignment_problem.cc\") # crash\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/jobshop_sat.cc\") # crash\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/knapsack_2d_sat.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/mps_driver.cc\") # crash\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/multi_knapsack_sat.cc\") # crash\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/network_routing_sat.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/parse_dimacs_assignment.cc\") # lib\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/pdlp_solve.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/pdptw.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/shift_minimization_sat.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/strawberry_fields_with_column_generation.cc\") # Too long\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/vector_bin_packing_solver.cc\")\nlist(FILTER CXX_SRCS EXCLUDE REGEX \".*/weighted_tardiness_sat.cc\")\n```\n\n----------------------------------------\n\nTITLE: Displaying OR-Tools Directory Structure in Markdown\nDESCRIPTION: Shows the file structure of the OR-Tools C++ binary archive after extraction, with file paths and descriptions for each component.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.cpp.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nor-tools_cpp/\n  [README.md](README.md) <- This file.\n  [bin](bin)             <- directory containing executable files.\n  [include](include)     <- directory containing headers files.\n  [lib](lib)             <- directory containing libraries files.\n  [share](share)         <- directory containing various files.\n  [examples](examples)   <- C++ examples.\n  [Makefile](Makefile)   <- Main Makefile for C++.\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation and RPATH Settings\nDESCRIPTION: Sets up installation rules and RPATH settings for the solve executable, with platform-specific configurations for Apple and Unix systems.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(GNUInstallDirs)\nif(APPLE)\n  set_target_properties(solve PROPERTIES INSTALL_RPATH\n    \"@loader_path/../${CMAKE_INSTALL_LIBDIR};@loader_path\")\nelseif(UNIX)\n  cmake_path(RELATIVE_PATH CMAKE_INSTALL_FULL_LIBDIR\n             BASE_DIRECTORY ${CMAKE_INSTALL_FULL_BINDIR}\n             OUTPUT_VARIABLE libdir_relative_path)\n  set_target_properties(solve PROPERTIES INSTALL_RPATH\n    \"$ORIGIN/${libdir_relative_path}\")\nendif()\n\ninstall(TARGETS solve\n  EXPORT ${PROJECT_NAME}Targets\n  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the OR-Tools package using pip, a package installer for Python.  It is necessary to install OR-Tools before running the rest of the script. This allows the script to import and use the OR-Tools constraint programming solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/nqueens_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"python\n%pip install ortools\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Printing Total Distance, Load, and Time for Vehicle Routes in Python\nDESCRIPTION: This code snippet prints the total distance, load, and time for all routes in the Vehicle Routing Problem solution. It assumes these values have been calculated elsewhere in the program.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/cvrptw_break.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nprint(f\"Total Distance of all routes: {total_distance}m\")\nprint(f\"Total Load of all routes: {total_load}\")\nprint(f\"Total Time of all routes: {total_time}min\")\n```\n\n----------------------------------------\n\nTITLE: OR-Tools Apache License Header in Python\nDESCRIPTION: Standard Apache 2.0 license header used for Python files in the Google OR-Tools project. Includes copyright notice, license link and basic terms.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Copyright 2010-2025 Google LLC\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n```\n\n----------------------------------------\n\nTITLE: Compiling OR-Tools Examples on Windows with CMake\nDESCRIPTION: Shows how to manually compile OR-Tools examples on Windows systems using CMake. Similar to the Unix approach but intended for Windows environments.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.cpp.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd examples/basic_example\ncmake -S . -B build -DCMAKE_PREFIX_PATH=../..\ncmake --build build -v\n```\n\n----------------------------------------\n\nTITLE: Calling assign_matches Function in Python\nDESCRIPTION: This code snippet calls the `assign_matches` function with the parsed command-line arguments and calculated values.  It passes arguments such as the number of teams, number of matchdays, matches per day, maximum home stand, time limit, CPU workers, output CSV file name, and a debug flag to the function.  This implies that the `assign_matches` function likely performs the main scheduling logic.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nassign_matches(args.num_teams, args.num_matchdays, num_matches_per_day,\n                   args.max_home_stand, args.time_limit, cpu, args.csv,\n                   args.debug)\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Benchmark Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build Google Benchmark library. It specifies the git repository and version tag. This is conditionally executed if BUILD_benchmark is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_benchmark)\n  message(CHECK_START \"Fetching benchmark\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    benchmark\n    GIT_REPOSITORY https://github.com/google/benchmark.git\n    GIT_TAG v1.9.1\n    GIT_SHALLOW TRUE\n    #PATCH_COMMAND git apply --ignore-whitespace \"\"\n  )\n  set(BENCHMARK_ENABLE_TESTING OFF)\n  set(BENCHMARK_ENABLE_WERROR OFF)\n  set(BENCHMARK_ENABLE_INSTALL OFF)\n  FetchContent_MakeAvailable(benchmark)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Example Builds in CMake for Google OR-Tools\nDESCRIPTION: This CMake snippet checks if Java examples should be built, then iterates through all Java source files in the current directory to add them as examples using the add_java_example function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_JAVA_EXAMPLES)\n  return()\nendif()\n\nfile(GLOB JAVA_SRCS \"*.java\")\nforeach(SAMPLE IN LISTS JAVA_SRCS)\n  add_java_example(FILE_NAME ${SAMPLE})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Optional Items Solver Implementation\nDESCRIPTION: Alternative implementation using optional interval variables for item placement. Handles both normal and rotated orientations while maintaining spatial constraints.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/knapsack_2d_sat.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef solve_with_duplicate_optional_items(data: pd.Series, max_height: int, max_width: int):\n    \"\"\"solve the problem by building 2 optional items (rotated or not) for each item.\"\"\"\n    # ... [full implementation as shown in original code] ...\n    model = cp_model.CpModel()\n    # Create variables and constraints\n    # Solve and report solution\n```\n\n----------------------------------------\n\nTITLE: Installing ortools package\nDESCRIPTION: This snippet shows how to install the ortools package using pip in a Colab environment. It uses the `%pip` magic command, which is specific to IPython environments like Jupyter and Colab.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/optional_interval_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Configuring GoogleTest Dependency in CMake\nDESCRIPTION: Sets up CMake configuration to fetch and build GoogleTest library. It specifies the git repository, version tag, and applies a patch. This is conditionally executed if BUILD_googletest is set.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/dependencies/CMakeLists.txt#2025-04-17_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_googletest)\n  message(CHECK_START \"Fetching googletest\")\n  list(APPEND CMAKE_MESSAGE_INDENT \"  \")\n  FetchContent_Declare(\n    googletest\n    GIT_REPOSITORY https://github.com/google/googletest.git\n    GIT_TAG v1.15.2\n    GIT_SHALLOW TRUE\n    PATCH_COMMAND git apply --ignore-whitespace\n    \"${CMAKE_CURRENT_LIST_DIR}/../../patches/googletest-v1.15.2.patch\"\n    #PATCH_COMMAND git apply --ignore-whitespace \"\"\n  )\n  set(gtest_force_shared_crt ON CACHE BOOL \"\" FORCE)\n  set(INSTALL_GTEST OFF)\n  set(GTEST_HAS_ABSL ON)\n  FetchContent_MakeAvailable(googletest)\n  list(POP_BACK CMAKE_MESSAGE_INDENT)\n  message(CHECK_PASS \"fetched\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Fetching Abseil-cpp via FetchContent in CMake\nDESCRIPTION: CMake code to fetch the Abseil-cpp library from GitHub using FetchContent. It sets various configuration options for Abseil and applies a patch to the fetched source code.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/host.CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(CHECK_START \"Fetching Abseil-cpp\")\nlist(APPEND CMAKE_MESSAGE_INDENT \"  \")\nset(ABSL_ENABLE_INSTALL ON)\nset(ABSL_USE_SYSTEM_INCLUDES ON)\nset(ABSL_PROPAGATE_CXX_STD ON)\nFetchContent_Declare(\n  absl\n  GIT_REPOSITORY \"https://github.com/abseil/abseil-cpp.git\"\n  GIT_TAG \"20240722.0\"\n  PATCH_COMMAND git apply \"${CMAKE_CURRENT_LIST_DIR}/@PATCHES_PATH@/abseil-cpp-20240722.0.patch\")\nFetchContent_MakeAvailable(absl)\nlist(POP_BACK CMAKE_MESSAGE_INDENT)\nmessage(CHECK_PASS \"fetched\")\n```\n\n----------------------------------------\n\nTITLE: Time Slot Array Data Structure in JavaScript\nDESCRIPTION: Each array element contains 6 values: ID (integer), start time (string), end time (string), start offset in minutes (integer), end offset in minutes (integer), and duration in minutes (integer). Times range from 09:18 to 14:04.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n[\n    [404, \"09:18\", \"10:41\", 558, 641, 83],\n    [405, \"09:18\", \"09:58\", 558, 598, 40],\n    [406, \"09:19\", \"10:13\", 559, 613, 54],\n    //... additional entries omitted for brevity\n    [634, \"12:39\", \"13:33\", 759, 813, 54],\n    [635, \"12:40\", \"13:51\", 760, 831, 71]\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Model Builder SWIG Interface\nDESCRIPTION: Sets up SWIG properties and generates Java bindings for the model builder component. Mirrors the linear solver configuration with different target names and package structure.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(SOURCE modelbuilder.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE modelbuilder.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE modelbuilder.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE modelbuilder.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.modelbuilder)\nswig_add_library(jnimodelbuilder\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/modelbuilder\n  SOURCES modelbuilder.i)\n\ntarget_include_directories(jnimodelbuilder PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jnimodelbuilder PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jnimodelbuilder PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Running Examples Using .NET CLI\nDESCRIPTION: Alternative commands using dotnet CLI to build and run examples, showing how to navigate to the example directory and execute it.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.dotnet.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd examples/BasicExample\ndotnet build\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Adding Python Tests Configuration in CMake\nDESCRIPTION: Configures Python tests when BUILD_TESTING is enabled. It finds all Python test files with the '*_test.py' pattern and adds them as test targets.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/python/CMakeLists.txt#2025-04-17_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools package\nDESCRIPTION: This command installs the ortools package using pip, which is required to run the subsequent code examples. This command is specifically intended for use within a Google Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/clone_model_mb.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Java Library Target\nDESCRIPTION: Defines a SWIG library target for Java bindings, specifying the output directory and source files. Creates an object library named 'jniutil' for the sorted interval list interface.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/util/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(jniutil\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/util\n  SOURCES sorted_interval_list.i)\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Cases for Math Optimization Constraints in CMake\nDESCRIPTION: Sets up test configurations for the math optimization constraints component when BUILD_TESTING is enabled. Automatically discovers and configures test files with Google Test dependencies.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/constraints/indicator/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB _TEST_SRCS \"*_test.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS _TEST_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        math_opt_constraints_indicator_${_NAME}\n      SOURCES\n        ${_FILE_NAME}\n      LINK_LIBRARIES\n        #benchmark::benchmark\n        GTest::gmock\n        GTest::gtest_main\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Medium Instance Sample Data\nDESCRIPTION: Sample shift data for a medium-sized scheduling instance with extended shift timings and durations\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nSAMPLE_SHIFTS_MEDIUM = [\n    [0, \"04:30\", \"04:53\", 270, 293, 23],\n    [1, \"04:46\", \"04:56\", 286, 296, 10],\n    [2, \"04:52\", \"05:56\", 292, 356, 64],\n    [3, \"04:53\", \"05:23\", 293, 323, 30],\n    [4, \"05:07\", \"05:44\", 307, 344, 37],\n    [5, \"05:10\", \"06:06\", 310, 366, 56],\n    [6, \"05:18\", \"06:03\", 318, 363, 45],\n    [7, \"05:30\", \"05:40\", 330, 340, 10],\n    [8, \"05:30\", \"05:40\", 330, 340, 10],\n    [9, \"05:33\", \"06:15\", 333, 375, 42],\n    [10, \"05:40\", \"05:50\", 340, 350, 10],\n    [11, \"05:43\", \"06:08\", 343, 368, 25],\n    [12, \"05:54\", \"07:20\", 354, 440, 86],\n    [13, \"06:04\", \"06:37\", 364, 397, 33],\n    [14, \"06:13\", \"06:58\", 373, 418, 45],\n    [15, \"06:14\", \"07:40\", 374, 460, 86],\n    [16, \"06:15\", \"07:15\", 375, 435, 60],\n    [17, \"06:16\", \"06:26\", 376, 386, 10],\n    [18, \"06:17\", \"06:34\", 377, 394, 17],\n    [19, \"06:20\", \"06:36\", 380, 396, 16],\n    [20, \"06:22\", \"07:06\", 382, 426, 44],\n    [21, \"06:24\", \"07:50\", 384, 470, 86],\n    [22, \"06:27\", \"06:44\", 387, 404, 17],\n    [23, \"06:30\", \"06:40\", 390, 400, 10],\n    [24, \"06:31\", \"06:43\", 391, 403, 12],\n    [25, \"06:33\", \"07:53\", 393, 473, 80],\n    [26, \"06:34\", \"07:09\", 394, 429, 35],\n    [27, \"06:40\", \"06:56\", 400, 416, 16],\n    [28, \"06:44\", \"07:17\", 404, 437, 33],\n    [29, \"06:46\", \"06:58\", 406, 418, 12],\n    [30, \"06:49\", \"07:43\", 409, 463, 54],\n    [31, \"06:50\", \"07:05\", 410, 425, 15],\n    [32, \"06:52\", \"07:36\", 412, 456, 44],\n    [33, \"06:54\", \"07:27\", 414, 447, 33],\n    [34, \"06:56\", \"08:23\", 416, 503, 87],\n    [35, \"07:04\", \"07:44\", 424, 464, 40],\n    [36, \"07:11\", \"08:36\", 431, 516, 85],\n    [37, \"07:17\", \"07:35\", 437, 455, 18],\n    [38, \"07:22\", \"08:06\", 442, 486, 44],\n    [39, \"07:27\", \"08:15\", 447, 495, 48],\n    [40, \"07:35\", \"07:45\", 455, 465, 10],\n    [41, \"07:43\", \"08:08\", 463, 488, 25],\n    [42, \"07:50\", \"08:37\", 470, 517, 47],\n    [43, \"07:58\", \"08:45\", 478, 525, 47],\n    [44, \"08:00\", \"08:35\", 480, 515, 35],\n    [45, \"08:06\", \"08:51\", 486, 531, 45],\n    [46, \"08:10\", \"08:45\", 490, 525, 35],\n    [47, \"08:15\", \"08:30\", 495, 510, 15],\n    [48, \"08:16\", \"09:00\", 496, 540, 44],\n    [49, \"08:18\", \"09:16\", 498, 556, 58],\n    [50, \"08:20\", \"08:36\", 500, 516, 16],\n    [51, \"08:27\", \"09:07\", 507, 547, 40],\n    [52, \"08:30\", \"08:45\", 510, 525, 15],\n    [53, \"08:35\", \"09:15\", 515, 555, 40],\n    [54, \"08:46\", \"09:30\", 526, 570, 44],\n    [55, \"08:51\", \"09:17\", 531, 557, 26],\n    [56, \"08:55\", \"09:15\", 535, 555, 20],\n    [57, \"08:58\", \"09:38\", 538, 578, 40],\n    [58, \"09:00\", \"09:35\", 540, 575, 35],\n    [59, \"09:00\", \"09:16\", 540, 556, 16],\n    [60, \"09:20\", \"09:36\", 560, 576, 16],\n    [61, \"09:31\", \"09:43\", 571, 583, 12],\n    [62, \"09:33\", \"10:15\", 573, 615, 42],\n    [63, \"09:54\", \"10:05\", 594, 605, 11],\n    [64, \"10:11\", \"10:38\", 611, 638, 27],\n    [65, \"10:18\", \"11:00\", 618, 660, 42],\n    [66, \"10:21\", \"10:47\", 621, 647, 26],\n    [67, \"10:25\", \"11:04\", 625, 664, 39],\n    [68, \"10:26\", \"11:08\", 626, 668, 42],\n    [69, \"10:44\", \"12:11\", 644, 731, 87],\n    [70, \"11:00\", \"11:16\", 660, 676, 16],\n    [71, \"11:15\", \"11:54\", 675, 714, 39],\n    [72, \"11:16\", \"11:28\", 676, 688, 12],\n    [73, \"11:20\", \"11:30\", 680, 690, 10],\n    [74, \"11:21\", \"11:47\", 681, 707, 26],\n    [75, \"11:25\", \"12:04\", 685, 724, 39],\n    [76, \"11:34\", \"11:45\", 694, 705, 11],\n    [77, \"11:35\", \"12:14\", 695, 734, 39],\n    [78, \"11:41\", \"12:23\", 701, 743, 42],\n    [79, \"11:44\", \"12:35\", 704, 755, 51],\n    [80, \"11:46\", \"11:58\", 706, 718, 12],\n    [81, \"12:00\", \"12:10\", 720, 730, 10],\n    [82, \"12:04\", \"12:15\", 724, 735, 11],\n    [83, \"12:04\", \"13:04\", 724, 784, 60],\n    [84, \"12:11\", \"12:38\", 731, 758, 27],\n    [85, \"12:15\", \"12:54\", 735, 774, 39],\n    [86, \"12:25\", \"13:10\", 745, 790, 45],\n    [87, \"12:30\", \"12:40\", 750, 760, 10],\n    [88, \"12:34\", \"13:58\", 754, 838, 84],\n    [89, \"12:38\", \"13:25\", 758, 805, 47],\n    [90, \"12:48\", \"13:35\", 768, 815, 47],\n    [91, \"13:00\", \"13:16\", 780, 796, 16],\n    [92, \"13:05\", \"13:44\", 785, 824, 39],\n    [93, \"13:08\", \"13:55\", 788, 835, 47],\n    [94, \"13:14\", \"14:38\", 794, 878, 84],\n    [95, \"13:23\", \"13:49\", 803, 829, 26],\n    [96, \"13:25\", \"14:04\", 805, 844, 39],\n    [97, \"13:28\", \"14:54\", 808, 894, 86],\n    [98, \"13:31\", \"13:43\", 811, 823, 12],\n    [99, \"13:34\", \"14:58\", 814, 898, 84],\n    [100, \"13:38\", \"14:25\", 818, 865, 47],\n    [101, \"13:38\", \"15:04\", 818, 904, 86],\n    [102, \"13:39\", \"14:33\", 819, 873, 54],\n    [103, \"13:40\", \"13:50\", 820, 830, 10],\n    [104, \"13:43\", \"14:10\", 823, 850, 27],\n    [105, \"13:48\", \"14:35\", 828, 875, 47],\n    [106, \"13:48\", \"14:35\", 828, 875, 47],\n    [107, \"13:53\", \"14:40\", 833, 880, 47],\n    [108, \"13:58\", \"15:24\", 838, 924, 86],\n    [109, \"13:58\", \"14:25\", 838, 865, 27],\n    [110, \"14:00\", \"14:16\", 840, 856, 16],\n    [111, \"14:13\", \"15:00\", 853, 900, 47],\n    [112, \"14:20\", \"15:31\", 860, 931, 71],\n    [113, \"14:25\", \"15:02\", 865, 902, 37],\n    [114, \"14:34\", \"14:45\", 874, 885, 11],\n    [115, \"14:40\", \"15:51\", 880, 951, 71],\n    [116, \"14:40\", \"14:56\", 880, 896, 16],\n    [117, \"14:46\", \"14:58\", 886, 898, 12],\n    [118, \"14:49\", \"15:43\", 889, 943, 54],\n    [119, \"14:52\", \"15:21\", 892, 921, 29],\n    [120, \"14:58\", \"16:24\", 898, 984, 86],\n    [121, \"14:59\", \"15:53\", 899, 953, 54],\n    [122, \"15:00\", \"15:10\", 900, 910, 10],\n    [123, \"15:00\", \"15:35\", 900, 935, 35],\n    [124, \"15:08\", \"15:45\", 908, 945, 37],\n    [125, \"15:12\", \"15:36\", 912, 936, 24],\n    [126, \"15:18\", \"16:05\", 918, 965, 47],\n    [127, \"15:24\", \"16:05\", 924, 965, 41],\n    [128, \"15:31\", \"15:43\", 931, 943, 12],\n    [129, \"15:35\", \"15:54\", 935, 954, 19],\n    [130, \"15:36\", \"16:21\", 936, 981, 45],\n    [131, \"15:39\", \"16:33\", 939, 993, 54],\n    [132, \"15:48\", \"16:35\", 948, 995, 47],\n    [133, \"15:50\", \"17:01\", 950, 1021, 71],\n    [134, \"16:03\", \"16:50\", 963, 1010, 47],\n    [135, \"16:18\", \"17:44\", 978, 1064, 86],\n    [136, \"16:24\", \"17:05\", 984, 1025, 41],\n    [137, \"16:28\", \"17:15\", 988, 1035, 47],\n    [138, \"16:34\", \"17:15\", 994, 1035, 41],\n    [139, \"16:38\", \"17:25\", 998, 1045, 47],\n    [140, \"16:40\", \"16:56\", 1000, 1016, 16]\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories and Creating Alias in CMake\nDESCRIPTION: Adds Protocol Buffers source directory to the include path of the CP Model Helper PyBind11 module and creates an alias for the target using the project namespace.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/python/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(cp_model_helper_pybind11 PRIVATE ${protobuf_SOURCE_DIR})\nadd_library(${PROJECT_NAMESPACE}::cp_model_helper_pybind11 ALIAS cp_model_helper_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Building and Running OR-Tools Locally with Blaze\nDESCRIPTION: Command for building and running the OR-Tools notebook locally using Blaze. This creates a customized Colab runtime with features required for the CP-SAT solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/colab/cp_sat.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nblaze run -c opt ortools/colab:or_notebook -- --logtostderr\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: The snippet installs the ortools package using the %pip magic command in a Jupyter notebook environment. This is required to use the constraint programming model provided by OR-Tools.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/zebra_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring SWIG Properties for Graph Module in CMake\nDESCRIPTION: Sets SWIG properties for the graph.i file, including C++ mode, module name, compile definitions, and package name for Java output.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/java/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(SOURCE graph.i PROPERTY CPLUSPLUS ON)\nset_property(SOURCE graph.i PROPERTY SWIG_MODULE_NAME main)\nset_property(SOURCE graph.i PROPERTY COMPILE_DEFINITIONS\n  ${OR_TOOLS_COMPILE_DEFINITIONS} ABSL_MUST_USE_RESULT=)\nset_property(SOURCE graph.i PROPERTY COMPILE_OPTIONS\n  -package ${JAVA_PACKAGE}.graph)\n```\n\n----------------------------------------\n\nTITLE: Time and Duration Dataset in Tabular Format\nDESCRIPTION: A data matrix containing time and duration records, possibly for journey or scheduling optimization. Each row includes a record ID, start and end times in HH:MM format, start and end times converted to minutes, and the duration in minutes.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_sat.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: data\nCODE:\n```\n    [1056, \"18:01\", \"18:13\", 1081, 1093, 12],\n    [1057, \"18:03\", \"18:50\", 1083, 1130, 47],\n    [1058, \"18:04\", \"18:45\", 1084, 1125, 41],\n    [1059, \"18:04\", \"19:29\", 1084, 1169, 85],\n    [1060, \"18:05\", \"18:24\", 1085, 1104, 19],\n    [1061, \"18:06\", \"18:51\", 1086, 1131, 45],\n    [1062, \"18:08\", \"18:55\", 1088, 1135, 47],\n    [1063, \"18:08\", \"19:06\", 1088, 1146, 58],\n    [1064, \"18:08\", \"18:55\", 1088, 1135, 47],\n    [1065, \"18:09\", \"19:03\", 1089, 1143, 54],\n    [1066, \"18:10\", \"18:20\", 1090, 1100, 10],\n    [1067, \"18:10\", \"19:21\", 1090, 1161, 71],\n    [1068, \"18:13\", \"19:00\", 1093, 1140, 47],\n    [1069, \"18:13\", \"18:40\", 1093, 1120, 27],\n    [1070, \"18:14\", \"19:43\", 1094, 1183, 89],\n    [1071, \"18:14\", \"18:55\", 1094, 1135, 41],\n    [1072, \"18:15\", \"18:34\", 1095, 1114, 19],\n    [1073, \"18:16\", \"18:28\", 1096, 1108, 12],\n    [1074, \"18:17\", \"18:27\", 1097, 1107, 10],\n    [1075, \"18:18\", \"19:41\", 1098, 1181, 83],\n    [1076, \"18:18\", \"18:58\", 1098, 1138, 40],\n    [1077, \"18:18\", \"19:05\", 1098, 1145, 47],\n    [1078, \"18:19\", \"19:13\", 1099, 1153, 54],\n    [1079, \"18:20\", \"19:31\", 1100, 1171, 71],\n    [1080, \"18:20\", \"18:36\", 1100, 1116, 16],\n    [1081, \"18:20\", \"18:30\", 1100, 1110, 10],\n    [1082, \"18:22\", \"19:05\", 1102, 1145, 43],\n    [1083, \"18:23\", \"19:05\", 1103, 1145, 42],\n    [1084, \"18:24\", \"19:27\", 1104, 1167, 63],\n    [1085, \"18:24\", \"19:05\", 1104, 1145, 41],\n    [1086, \"18:25\", \"18:44\", 1105, 1124, 19],\n    [1087, \"18:28\", \"19:25\", 1108, 1165, 57],\n    [1088, \"18:28\", \"18:55\", 1108, 1135, 27],\n    [1089, \"18:28\", \"19:08\", 1108, 1148, 40],\n    [1090, \"18:28\", \"19:15\", 1108, 1155, 47],\n    [1091, \"18:29\", \"19:23\", 1109, 1163, 54],\n    [1092, \"18:30\", \"19:05\", 1110, 1145, 35],\n    [1093, \"18:30\", \"18:40\", 1110, 1120, 10],\n    [1094, \"18:31\", \"18:43\", 1111, 1123, 12],\n    [1095, \"18:33\", \"19:15\", 1113, 1155, 42],\n    [1096, \"18:34\", \"19:58\", 1114, 1198, 84],\n    [1097, \"18:34\", \"19:14\", 1114, 1154, 40],\n    [1098, \"18:35\", \"18:55\", 1115, 1135, 20],\n    [1099, \"18:36\", \"19:20\", 1116, 1160, 44],\n    [1100, \"18:38\", \"19:25\", 1118, 1165, 47],\n    [1101, \"18:38\", \"19:23\", 1118, 1163, 45],\n    [1102, \"18:38\", \"19:56\", 1118, 1196, 78],\n    [1103, \"18:39\", \"19:33\", 1119, 1173, 54],\n    [1104, \"18:40\", \"18:50\", 1120, 1130, 10],\n    [1105, \"18:40\", \"19:45\", 1120, 1185, 65],\n    [1106, \"18:40\", \"18:56\", 1120, 1136, 16],\n    [1107, \"18:43\", \"19:10\", 1123, 1150, 27],\n    [1108, \"18:43\", \"19:30\", 1123, 1170, 47],\n    [1109, \"18:44\", \"19:24\", 1124, 1164, 40],\n    [1110, \"18:45\", \"19:05\", 1125, 1145, 20],\n    [1111, \"18:46\", \"18:58\", 1126, 1138, 12],\n    [1112, \"18:48\", \"19:35\", 1128, 1175, 47],\n    [1113, \"18:48\", \"20:12\", 1128, 1212, 84],\n    [1114, \"18:48\", \"20:11\", 1128, 1211, 83],\n    [1115, \"18:48\", \"19:28\", 1128, 1168, 40],\n    [1116, \"18:49\", \"19:43\", 1129, 1183, 54],\n    [1117, \"18:50\", \"19:00\", 1130, 1140, 10],\n    [1118, \"18:51\", \"19:01\", 1131, 1141, 10],\n    [1119, \"18:53\", \"19:35\", 1133, 1175, 42],\n    [1120, \"18:53\", \"19:15\", 1133, 1155, 22],\n    [1121, \"18:53\", \"20:00\", 1133, 1200, 67],\n    [1122, \"18:55\", \"19:15\", 1135, 1155, 20],\n    [1123, \"18:55\", \"19:34\", 1135, 1174, 39],\n    [1124, \"18:58\", \"19:38\", 1138, 1178, 40],\n    [1125, \"18:59\", \"19:53\", 1139, 1193, 54],\n    [1126, \"18:59\", \"19:50\", 1139, 1190, 51],\n    [1127, \"18:59\", \"19:53\", 1139, 1193, 54],\n    [1128, \"19:00\", \"19:16\", 1140, 1156, 16],\n    [1129, \"19:00\", \"19:10\", 1140, 1150, 10],\n    [1130, \"19:00\", \"19:16\", 1140, 1156, 16],\n    [1131, \"19:01\", \"19:13\", 1141, 1153, 12],\n    [1132, \"19:03\", \"20:26\", 1143, 1226, 83],\n    [1133, \"19:03\", \"19:45\", 1143, 1185, 42],\n    [1134, \"19:05\", \"19:44\", 1145, 1184, 39],\n    [1135, \"19:05\", \"19:25\", 1145, 1165, 20],\n    [1136, \"19:08\", \"20:15\", 1148, 1215, 67],\n    [1137, \"19:08\", \"19:35\", 1148, 1175, 27],\n    [1138, \"19:09\", \"19:49\", 1149, 1189, 40],\n    [1139, \"19:09\", \"20:03\", 1149, 1203, 54],\n    [1140, \"19:10\", \"19:20\", 1150, 1160, 10],\n    [1141, \"19:10\", \"19:20\", 1150, 1160, 10],\n    [1142, \"19:11\", \"19:53\", 1151, 1193, 42],\n    [1143, \"19:14\", \"20:26\", 1154, 1226, 72],\n    [1144, \"19:14\", \"19:35\", 1154, 1175, 21],\n    [1145, \"19:14\", \"19:24\", 1154, 1164, 10],\n    [1146, \"19:14\", \"20:05\", 1154, 1205, 51],\n    [1147, \"19:15\", \"19:30\", 1155, 1170, 15],\n    [1148, \"19:15\", \"19:54\", 1155, 1194, 39],\n    [1149, \"19:18\", \"20:39\", 1158, 1239, 81],\n    [1150, \"19:18\", \"20:00\", 1158, 1200, 42],\n    [1151, \"19:19\", \"20:14\", 1159, 1214, 55],\n    [1152, \"19:20\", \"19:30\", 1160, 1170, 10],\n    [1153, \"19:20\", \"19:36\", 1160, 1176, 16],\n    [1154, \"19:21\", \"19:31\", 1161, 1171, 10],\n    [1155, \"19:23\", \"20:30\", 1163, 1230, 67],\n    [1156, \"19:23\", \"19:35\", 1163, 1175, 12],\n    [1157, \"19:24\", \"19:45\", 1164, 1185, 21],\n    [1158, \"19:24\", \"19:45\", 1164, 1185, 21],\n    [1159, \"19:25\", \"20:04\", 1165, 1204, 39],\n    [1160, \"19:26\", \"20:08\", 1166, 1208, 42],\n    [1161, \"19:29\", \"20:02\", 1169, 1202, 33],\n    [1162, \"19:29\", \"20:18\", 1169, 1218, 49],\n    [1163, \"19:29\", \"20:41\", 1169, 1241, 72],\n    [1164, \"19:30\", \"19:40\", 1170, 1180, 10],\n    [1165, \"19:33\", \"20:54\", 1173, 1254, 81],\n    [1166, \"19:33\", \"20:17\", 1173, 1217, 44],\n    [1167, \"19:34\", \"19:55\", 1174, 1195, 21],\n    [1168, \"19:35\", \"20:14\", 1175, 1214, 39],\n    [1169, \"19:38\", \"20:05\", 1178, 1205, 27],\n    [1170, \"19:38\", \"20:45\", 1178, 1245, 67],\n    [1171, \"19:39\", \"20:12\", 1179, 1212, 33],\n    [1172, \"19:40\", \"19:50\", 1180, 1190, 10],\n    [1173, \"19:40\", \"19:56\", 1180, 1196, 16],\n    [1174, \"19:41\", \"20:27\", 1181, 1227, 46],\n    [1175, \"19:43\", \"19:55\", 1183, 1195, 12],\n    [1176, \"19:44\", \"20:05\", 1184, 1205, 21],\n    [1177, \"19:44\", \"20:33\", 1184, 1233, 49],\n    [1178, \"19:44\", \"21:00\", 1184, 1260, 76],\n    [1179, \"19:45\", \"20:24\", 1185, 1224, 39],\n    [1180, \"19:48\", \"20:37\", 1188, 1237, 49],\n    [1181, \"19:48\", \"21:09\", 1188, 1269, 81],\n    [1182, \"19:50\", \"20:00\", 1190, 1200, 10],\n    [1183, \"19:52\", \"20:29\", 1192, 1229, 37],\n    [1184, \"19:53\", \"20:08\", 1193, 1208, 15],\n    [1185, \"19:53\", \"21:02\", 1193, 1262, 69],\n    [1186, \"19:53\", \"20:20\", 1193, 1220, 27],\n    [1187, \"19:54\", \"20:19\", 1194, 1219, 25],\n    [1188, \"19:55\", \"20:34\", 1195, 1234, 39],\n    [1189, \"19:56\", \"20:34\", 1196, 1234, 38],\n    [1190, \"19:59\", \"20:48\", 1199, 1248, 49],\n    [1191, \"19:59\", \"21:20\", 1199, 1280, 81],\n    [1192, \"20:00\", \"20:16\", 1200, 1216, 16],\n    [1193, \"20:00\", \"20:10\", 1200, 1210, 10],\n    [1194, \"20:03\", \"20:42\", 1203, 1242, 39],\n    [1195, \"20:03\", \"21:24\", 1203, 1284, 81],\n    [1196, \"20:04\", \"20:29\", 1204, 1229, 25],\n    [1197, \"20:05\", \"20:48\", 1205, 1248, 43],\n    [1198, \"20:07\", \"20:44\", 1207, 1244, 37],\n    [1199, \"20:08\", \"20:40\", 1208, 1240, 32],\n    [1200, \"20:08\", \"20:35\", 1208, 1235, 27],\n    [1201, \"20:10\", \"20:20\", 1210, 1220, 10],\n    [1202, \"20:10\", \"20:22\", 1210, 1222, 12],\n    [1203, \"20:11\", \"20:47\", 1211, 1247, 36],\n    [1204, \"20:14\", \"21:04\", 1214, 1264, 50],\n    [1205, \"20:14\", \"21:03\", 1214, 1263, 49],\n    [1206, \"20:17\", \"21:03\", 1217, 1263, 46],\n    [1207, \"20:18\", \"21:39\", 1218, 1299, 81],\n    [1208, \"20:20\", \"20:30\", 1220, 1230, 10],\n    [1209, \"20:20\", \"20:57\", 1220, 1257, 37],\n    [1210, \"20:20\", \"20:36\", 1220, 1236, 16],\n    [1211, \"20:22\", \"20:59\", 1222, 1259, 37],\n    [1212, \"20:22\", \"20:42\", 1222, 1242, 20],\n    [1213, \"20:24\", \"20:49\", 1224, 1249, 25],\n    [1214, \"20:27\", \"21:22\", 1227, 1282, 55],\n    [1215, \"20:29\", \"21:18\", 1229, 1278, 49],\n    [1216, \"20:30\", \"21:07\", 1230, 1267, 37],\n    [1217, \"20:30\", \"20:40\", 1230, 1240, 10],\n    [1218, \"20:30\", \"20:40\", 1230, 1240, 10],\n    [1219, \"20:30\", \"21:40\", 1230, 1300, 70],\n    [1220, \"20:32\", \"21:18\", 1232, 1278, 46],\n    [1221, \"20:35\", \"21:54\", 1235, 1314, 79],\n    [1222, \"20:37\", \"21:14\", 1237, 1274, 37],\n    [1223, \"20:38\", \"21:08\", 1238, 1268, 30],\n    [1224, \"20:40\", \"20:50\", 1240, 1250, 10],\n    [1225, \"20:40\", \"21:17\", 1240, 1277, 37],\n    [1226, \"20:40\", \"20:56\", 1240, 1256, 16],\n    [1227, \"20:44\", \"21:33\", 1244, 1293, 49],\n    [1228, \"20:47\", \"21:33\", 1247, 1293, 46],\n    [1229, \"20:47\", \"21:42\", 1247, 1302, 55],\n    [1230, \"20:50\", \"21:00\", 1250, 1260, 10],\n    [1231, \"20:50\", \"22:00\", 1250, 1320, 70],\n    [1232, \"20:50\", \"22:09\", 1250, 1329, 79],\n    [1233, \"20:50\", \"21:27\", 1250, 1287, 37],\n    [1234, \"20:52\", \"21:29\", 1252, 1289, 37],\n    [1235, \"20:53\", \"21:20\", 1253, 1280, 27],\n    [1236, \"20:56\", \"21:11\", 1256, 1271, 15],\n    [1237, \"20:59\", \"21:48\", 1259, 1308, 49],\n    [1238, \"21:00\", \"21:10\", 1260, 1270, 10],\n    [1239, \"21:00\", \"21:37\", 1260, 1297, 37],\n    [1240, \"21:02\", \"21:48\", 1262, 1308, 46],\n    [1241, \"21:05\", \"22:24\", 1265, 1344, 79],\n    [1242, \"21:07\", \"21:44\", 1267, 1304, 37],\n    [1243, \"21:07\", \"22:02\", 1267, 1322, 55],\n    [1244, \"21:08\", \"21:38\", 1268, 1298, 30],\n    [1245, \"21:10\", \"22:25\", 1270, 1345, 75],\n    [1246, \"21:10\", \"21:20\", 1270, 1280, 10],\n    [1247, \"21:10\", \"21:47\", 1270, 1307, 37],\n    [1248, \"21:14\", \"22:03\", 1274, 1323, 49],\n    [1249, \"21:17\", \"22:03\", 1277, 1323, 46],\n    [1250, \"21:20\", \"22:18\", 1280, 1338, 58],\n    [1251, \"21:20\", \"21:57\", 1280, 1317, 37],\n    [1252, \"21:20\", \"21:30\", 1280, 1290, 10],\n    [1253, \"21:22\", \"21:59\", 1282, 1319, 37],\n    [1254, \"21:24\", \"21:49\", 1284, 1309, 25],\n    [1255, \"21:27\", \"22:21\", 1287, 1341, 54],\n    [1256, \"21:30\", \"22:07\", 1290, 1327, 37],\n    [1257, \"21:30\", \"22:20\", 1290, 1340, 50],\n    [1258, \"21:30\", \"21:40\", 1290, 1300, 10],\n    [1259, \"21:32\", \"22:18\", 1292, 1338, 46],\n    [1260, \"21:32\", \"22:01\", 1292, 1321, 29],\n    [1261, \"21:35\", \"22:54\", 1295, 1374, 79],\n    [1262, \"21:37\", \"22:14\", 1297, 1334, 37],\n    [1263, \"21:39\", \"21:55\", 1299, 1315, 16],\n    [1264, \"21:40\", \"22:17\", 1300, 1337, 37],\n    [1265, \"21:40\", \"21:50\", 1300, 1310, 10],\n    [1266, \"21:41\", \"22:08\", 1301, 1328, 27],\n    [1267, \"21:47\", \"22:16\", 1307, 1336, 29],\n    [1268, \"21:47\", \"22:51\", 1307, 1371, 64],\n    [1269, \"21:47\", \"22:33\", 1307, 1353, 46],\n    [1270, \"21:48\", \"22:03\", 1308, 1323, 15],\n    [1271, \"21:50\", \"22:55\", 1310, 1375, 65],\n    [1272, \"21:50\", \"22:27\", 1310, 1347, 37]\n```\n\n----------------------------------------\n\nTITLE: Setting Up .NET Tests\nDESCRIPTION: Conditionally adds .NET test configurations by globbing test files and creating test targets for each discovered test file.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/csharp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB DOTNET_SRCS \"*Tests.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: TSP Implementation Using Distance Matrix\nDESCRIPTION: Shows how to solve TSP by providing a pre-calculated distance matrix to the Vehicle Routing solver. This approach allows for custom distance calculations between points.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/docs/TSP.md#2025-04-17_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ntsp_distance_matrix.cc\n```\n\nLANGUAGE: Python\nCODE:\n```\ntsp_distance_matrix.py\n```\n\nLANGUAGE: Java\nCODE:\n```\nTspDistanceMatrix.java\n```\n\nLANGUAGE: C#\nCODE:\n```\nTspDistanceMatrix.cs\n```\n\n----------------------------------------\n\nTITLE: Creating PyBind11 Module for CP Model Helper in CMake\nDESCRIPTION: Creates a PyBind11 module for CP Model Helper and sets its output library name. This is the main module definition that will compile the C++ code into a Python-accessible library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/python/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\npybind11_add_module(cp_model_helper_pybind11 MODULE cp_model_helper.cc)\nset_target_properties(cp_model_helper_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"cp_model_helper\")\n```\n\n----------------------------------------\n\nTITLE: Setting JNI Library Properties for OR-Tools SAT Interface\nDESCRIPTION: Configures the JNI library target with JNI include directories, position independent code, and links it with the OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/java/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(jnisat PRIVATE ${JNI_INCLUDE_DIRS})\nset_target_properties(jnisat PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(jnisat PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Library Target for Graph Module\nDESCRIPTION: Defines the SWIG library target for the graph module, specifying C# as the target language and setting the output directory for generated files.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/csharp/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(dotnet_graph\n  TYPE OBJECT\n  LANGUAGE csharp\n  OUTPUT_DIR ${DOTNET_PROJECT_DIR}/ortools/graph\n  SOURCES graph.i)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Library Target for Math Optimization Labs\nDESCRIPTION: Sets up a CMake object library target for math optimization labs. Configures source files, includes directories, and links required dependencies including abseil strings and math optimization protobuf libraries.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/labs/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt_labs)\nadd_library(${NAME} OBJECT)\n\nfile(GLOB _SRCS \"*.h\" \"*.cc\")\ntarget_sources(${NAME} PRIVATE ${_SRCS})\nset_target_properties(${NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)\ntarget_include_directories(${NAME} PUBLIC\n  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)\ntarget_link_libraries(${NAME} PRIVATE\n  absl::strings\n  ${PROJECT_NAMESPACE}::math_opt_proto)\n```\n\n----------------------------------------\n\nTITLE: Python Test Configuration\nDESCRIPTION: Sets up Python test cases, excluding Gurobi-specific tests and conditionally including SCIP-dependent tests based on build configuration\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/core/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB PYTHON_SRCS \"*_test.py\")\n  list(FILTER PYTHON_SRCS EXCLUDE REGEX \".*/solver_gurobi_test.py\") # need gurobi\n\n  if(NOT USE_SCIP)\n    list(FILTER PYTHON_SRCS EXCLUDE REGEX \"solver_test.py$\")\n  endif()\n\n  foreach(FILE_NAME IN LISTS PYTHON_SRCS)\n    add_python_test(\n      FILE_NAME ${FILE_NAME}\n      COMPONENT_NAME math_opt)\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Importing OR-Tools CP-SAT Solver in Python\nDESCRIPTION: This snippet imports the CP-SAT solver from Google's OR-Tools library, which is used to solve the school scheduling problem.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/school_scheduling_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ortools.sat.python import cp_model\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Java Library for Algorithms in CMake\nDESCRIPTION: Adds a SWIG-generated Java library for the algorithms module, specifying the output directory and source file.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nswig_add_library(jnialgorithms\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/algorithms\n  SOURCES knapsack_solver.i)\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Tests in CMake\nDESCRIPTION: Sets up .NET tests if BUILD_TESTING is enabled. It glob-patterns all test files ending with 'Tests.cs' and adds each as a .NET test using a custom CMake function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/algorithms/csharp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB DOTNET_SRCS \"*Tests.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Math Optimization Library Target in CMake\nDESCRIPTION: Sets up the main math optimization library target with object files and dependencies. Configures installation of the target.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(NAME ${PROJECT_NAME}_math_opt)\nadd_library(${NAME} OBJECT)\ntarget_sources(${NAME} PUBLIC\n  $<TARGET_OBJECTS:${NAME}_core>\n  $<TARGET_OBJECTS:${NAME}_core_c_api>\n  $<TARGET_OBJECTS:${NAME}_cpp>\n  $<TARGET_OBJECTS:${NAME}_io>\n  $<TARGET_OBJECTS:${NAME}_labs>\n  $<TARGET_OBJECTS:${NAME}_solvers>\n  $<TARGET_OBJECTS:${NAME}_storage>\n  $<TARGET_OBJECTS:${NAME}_validators>\n)\ntarget_link_libraries(${NAME} INTERFACE\n  ${NAME}_constraints\n)\ninstall(TARGETS ${PROJECT_NAME}_math_opt EXPORT ${PROJECT_NAME}Targets)\n```\n\n----------------------------------------\n\nTITLE: Listing OR-Tools .NET Tests with CTest\nDESCRIPTION: Command to list all available tests in the build directory using CTest. This helps identify what tests are available to run.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/dotnet.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd build\nctest -N\n```\n\n----------------------------------------\n\nTITLE: Generating OR-Tools Requirements with Bazel\nDESCRIPTION: Command used to autogenerate the pip requirements file for OR-Tools using Bazel. This ensures consistent dependency management across the project.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/ortools_requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbazel run //bazel:ortools_requirements.update\n```\n\n----------------------------------------\n\nTITLE: Creating SWIG Java Library for OR-Tools SAT Solver\nDESCRIPTION: Configures the SWIG-generated Java library for the SAT solver, defining it as an object library with Java language output directed to the project's sat package directory.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/java/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nswig_add_library(jnisat\n  TYPE OBJECT\n  LANGUAGE java\n  OUTPUT_DIR ${JAVA_PROJECT_DIR}/${JAVA_SRC_PATH}/sat\n  SOURCES sat.i)\n```\n\n----------------------------------------\n\nTITLE: Conditional Installation of Python Examples in OR-Tools (CMake)\nDESCRIPTION: This CMake snippet checks if Python examples should be built. If not, it exits the current CMake processing. If examples are to be built, it installs all Jupyter notebook files from the current directory to a specified destination within the OR-Tools project.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_PYTHON_EXAMPLES)\n  return()\nendif()\n\ninstall(DIRECTORY .\n  DESTINATION ${CMAKE_INSTALL_DATADIR}/ortools/examples/notebook\n  FILES_MATCHING PATTERN \"*.ipynb\")\n```\n\n----------------------------------------\n\nTITLE: Configuring pybind11 Model Builder Module\nDESCRIPTION: Creates and configures the model_builder_helper pybind11 module, setting up platform-specific properties and linking required libraries including OR-Tools and Eigen.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\npybind11_add_module(model_builder_helper_pybind11 MODULE model_builder_helper.cc)\nset_target_properties(model_builder_helper_pybind11 PROPERTIES\n  LIBRARY_OUTPUT_NAME \"model_builder_helper\")\n\ntarget_include_directories(model_builder_helper_pybind11 PRIVATE\n  ${protobuf_SOURCE_DIR})\n\nif(APPLE)\n  set_target_properties(model_builder_helper_pybind11 PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../../${PYTHON_PROJECT}/.libs\")\nelseif(UNIX)\n  set_target_properties(model_builder_helper_pybind11 PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../../${PYTHON_PROJECT}/.libs\")\nendif()\n\ntarget_link_libraries(model_builder_helper_pybind11 PRIVATE\n  ${PROJECT_NAMESPACE}::ortools\n  pybind11_native_proto_caster\n  Eigen3::Eigen)\nadd_library(${PROJECT_NAMESPACE}::model_builder_helper_pybind11 ALIAS model_builder_helper_pybind11)\n```\n\n----------------------------------------\n\nTITLE: Building C++ Samples\nDESCRIPTION: Iterates through all C++ source files in the directory and adds them as samples using the add_cxx_sample function.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/glop/samples/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Platform-Specific Properties for Python Wrapper in CMake\nDESCRIPTION: Configures platform-specific properties for macOS and Unix systems, including file suffix, install RPATH, and linker options.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/python/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(APPLE)\n  set_target_properties(pywrapcp PROPERTIES\n    SUFFIX \".so\"\n    INSTALL_RPATH \"@loader_path;@loader_path/../../${PROJECT_NAME}/.libs\")\n  target_link_options(pywrapcp PRIVATE \"LINKER:-undefined,dynamic_lookup\")\nelseif(UNIX)\n  set_target_properties(pywrapcp PROPERTIES\n    INSTALL_RPATH \"$ORIGIN:$ORIGIN/../../${PROJECT_NAME}/.libs\")\nendif()\ntarget_link_libraries(pywrapcp PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Configuring Tests for OR-Tools SAT .NET Bindings\nDESCRIPTION: Conditional block that sets up tests for the SAT solver .NET integration when BUILD_TESTING is enabled. Discovers test files by globbing for *Tests.cs patterns and adds each as a .NET test.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/csharp/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_TESTING)\n  file(GLOB DOTNET_SRCS \"*Tests.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_test(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Example Builds for Google OR-Tools\nDESCRIPTION: This snippet sets up the build process for C++ examples. It glob's all .cc files, creates a test target for each, and sets up the necessary compilation flags.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/tests/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_CXX_EXAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  foreach(_FULL_FILE_NAME IN LISTS CXX_SRCS)\n    get_filename_component(_NAME ${_FULL_FILE_NAME} NAME_WE)\n    get_filename_component(_FILE_NAME ${_FULL_FILE_NAME} NAME)\n    ortools_cxx_test(\n      NAME\n        tests_${_NAME}\n      SOURCES\n        ${_FULL_FILE_NAME}\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting OR-Tools .NET Init Target Properties\nDESCRIPTION: Sets target properties for the initialization module including SWIG include directories and position-independent code requirements. Links against the main OR-Tools library.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/init/csharp/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(dotnet_init PROPERTIES\n  SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON\n  POSITION_INDEPENDENT_CODE ON)\ntarget_link_libraries(dotnet_init PRIVATE ortools::ortools)\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This code snippet shows how to install the ortools package using pip. This is a necessary prerequisite for running the min cost flow example. This command is typically used within a Google Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/graph/simple_min_cost_flow_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: DotNet Sample Build Configuration\nDESCRIPTION: Sets up build process for .NET samples by globbing all .cs files and adding each as a sample using add_dotnet_sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/samples/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_DOTNET_SAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  foreach(SAMPLE IN LISTS DOTNET_SRCS)\n    add_dotnet_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: JNA Platform Dependency Configuration\nDESCRIPTION: XML configuration for adding JNA platform dependency for runtime platform detection\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/java/README.md#2025-04-17_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n  <groupId>net.java.dev.jna</groupId>\n  <artifactId>jna-platform</artifactId>\n  <version>5.14.0</version>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Installing ortools Package\nDESCRIPTION: Installs the ortools package using pip, which is required for running the diet optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/diet1_b.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Configuring .NET Example Builds in CMake for OR-Tools\nDESCRIPTION: Collects all C# source files and filters out examples that are too long or depend on system resources. The remaining examples are added to the build using the add_dotnet_example function when BUILD_DOTNET_EXAMPLES is enabled.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/contrib/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_DOTNET_EXAMPLES)\n  file(GLOB DOTNET_SRCS \"*.cs\")\n  list(FILTER DOTNET_SRCS EXCLUDE REGEX \".*/coins_grid.cs\") # too long\n  list(FILTER DOTNET_SRCS EXCLUDE REGEX \".*/nontransitive_dice.cs\") # too long\n  list(FILTER DOTNET_SRCS EXCLUDE REGEX \".*/partition.cs\") # too long\n  # Not working everywhere since it rely on /usr/share/dict/words\n  list(FILTER DOTNET_SRCS EXCLUDE REGEX \".*/word_square.cs\")\n  foreach(FILE_NAME IN LISTS DOTNET_SRCS)\n    add_dotnet_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional C++ Sample Build Configuration\nDESCRIPTION: Configures build process for C++ samples, excluding network_design_ilph files and adding each .cc file as a sample using add_cxx_sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_CXX_SAMPLES)\n  file(GLOB CXX_SRCS \"*.cc\")\n  list(FILTER CXX_SRCS EXCLUDE REGEX \"/network_design_ilph\")\n  foreach(SAMPLE IN LISTS CXX_SRCS)\n    add_cxx_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring RPATH for GLOP on Apple and Unix Systems\nDESCRIPTION: Sets the CMAKE_INSTALL_RPATH variable for Apple and Unix systems to ensure proper library loading paths for the GLOP solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/glop/samples/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(APPLE)\n    set(CMAKE_INSTALL_RPATH\n      \"@loader_path/../${CMAKE_INSTALL_LIBDIR};@loader_path\")\n  elseif(UNIX)\n    set(CMAKE_INSTALL_RPATH \"$ORIGIN/../${CMAKE_INSTALL_LIBDIR}:$ORIGIN\")\n  endif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip in a Python environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_table2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the Google OR-Tools package via pip in a Jupyter/Colab environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_mb.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing Jupyter Notebook\nDESCRIPTION: Command to install Jupyter Notebook using pip3 with user installation flag.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npip3 install --user jupyter\n```\n\n----------------------------------------\n\nTITLE: Adding Python Examples in CMake Loop\nDESCRIPTION: This foreach loop iterates over the filtered list of Python source files and adds each as an example using a custom CMake function 'add_python_example'.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/python/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(FILE_NAME IN LISTS PYTHON_SRCS)\n  add_python_example(FILE_NAME ${FILE_NAME})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: PlantUML Image Generation\nDESCRIPTION: Command to generate SVG diagrams from PlantUML source files\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/java/README.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nplantuml -Tsvg docs/{file}.dot\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Sample Builds for OR-Tools\nDESCRIPTION: This snippet sets up the compilation of Python samples for OR-Tools. It glob matches all .py files and adds each sample to the build process.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/constraint_solver/samples/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_PYTHON_SAMPLES)\n  file(GLOB PYTHON_SRCS \"*.py\")\n  foreach(SAMPLE IN LISTS PYTHON_SRCS)\n    add_python_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Example Builds for Google OR-Tools\nDESCRIPTION: This snippet sets up the build process for Java examples. It glob's all .java files and adds each as a Java example using a custom CMake function.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/tests/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_JAVA_EXAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(FILE_NAME IN LISTS JAVA_SRCS)\n    add_java_example(FILE_NAME ${FILE_NAME})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools package required for the auction solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/combinatorial_auction2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Checking Python pip Version\nDESCRIPTION: Command to verify the installed version of pip package manager.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.python.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npython -m pip -V\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools optimization package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/bus_schedule.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/integer_programming.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Java Sample Build Configuration\nDESCRIPTION: Configures build process for Java samples by collecting all .java files and adding each as a sample using add_java_sample.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/linear_solver/samples/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_JAVA_SAMPLES)\n  file(GLOB JAVA_SRCS \"*.java\")\n  foreach(SAMPLE IN LISTS JAVA_SRCS)\n    add_java_sample(FILE_NAME ${SAMPLE})\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running Examples Using Makefile\nDESCRIPTION: Command to compile and run examples using the provided Makefile, specifically showing how to run BasicExample.cs.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.dotnet.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake run SOURCE=examples/BasicExample/BasicExample.cs\n```\n\n----------------------------------------\n\nTITLE: License Header Block\nDESCRIPTION: Standard Apache 2.0 license header template with Google LLC copyright notice and reference to full license terms.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_node_max.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright 2025 Google LLC.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Apache 2.0 License Header\nDESCRIPTION: Copyright notice and standard Apache 2.0 license header text that appears at the top of Google OR-Tools source files. Includes reference to license terms and conditions.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/stigler_contrib.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright 2025 Google LLC.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Numeric Matrix Data\nDESCRIPTION: A portion of a large numerical matrix containing floating point values arranged in rows and columns. Values range from approximately -100 to +100 with varying precision.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/qubo_sat.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n-41.9285314, 0, 0, 0, 0, 14.1035676, 33.7857218\n```\n\n----------------------------------------\n\nTITLE: CMake Conditional Block Closure\nDESCRIPTION: This snippet shows the closing of a CMake conditional block with endif(). The conditional block likely contains the library linking configuration for the xpress_solver_test target.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/math_opt/solvers/CMakeLists.txt#2025-04-17_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/jobshop_ft06_distance_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Matrix Coordinate Data Input Format\nDESCRIPTION: A structured data input format where the first line contains three integers (4 4 11) representing dimensions and count, followed by 11 lines of coordinate pairs specifying positions in a 4x4 grid.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/graph/testdata/hopcroft_karp_test.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n4 4 11\n1 1\n1 4\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n4 1\n4 2\n4 3\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Coins Grid Solver in Python\nDESCRIPTION: Imports the necessary modules from the OR-Tools library to use the constraint solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/coins_grid.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom ortools.constraint_solver import pywrapcp\n```\n\n----------------------------------------\n\nTITLE: Runtime Package Project Configuration\nDESCRIPTION: XML configuration for the runtime-specific NuGet package project file, defining assembly name, package ID, and runtime identifier.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/dotnet/README.md#2025-04-17_snippet_0\n\nLANGUAGE: csproj\nCODE:\n```\n<RuntimeIdentifier>{rid}</RuntimeIdentifier>\n<AssemblyName>Google.OrTools</AssemblyName>\n<PackageId>Google.OrTools.runtime.{rid}</PackageId>\n```\n\n----------------------------------------\n\nTITLE: Distance Matrix Data Structure\nDESCRIPTION: 21x21 symmetric matrix representing distances between locations. Each cell contains an integer value indicating the distance or cost between two points.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/routing/parsers/testdata/n20w20.001.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n21\n0 19 17 34 7 20 10 17 28 15 23 29 23 29 21 20 9 16 21 13 12\n19 0 10 41 26 3 27 25 15 17 17 14 18 48 17 6 21 14 17 13 31\n17 10 0 47 23 13 26 15 25 22 26 24 27 44 7 5 23 21 25 18 29\n34 41 47 0 36 39 25 51 36 24 27 38 25 44 54 45 25 28 26 28 27\n7 26 23 36 0 27 11 17 35 22 30 36 30 22 25 26 14 23 28 20 10\n[...remaining matrix rows...]\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Google Colab\nDESCRIPTION: Installs the OR-Tools optimization package from PyPI using pip. This step is necessary to use the optimization capabilities in the Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/proto_solve.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Java Execution with Dependencies\nDESCRIPTION: Command to execute Java program with external dependencies\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/java/README.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\njava -cp \"/path/to/dependency.jar\" -jar \"/path/to/your/executable/.jar\"\n```\n\n----------------------------------------\n\nTITLE: Apache 2.0 License Header\nDESCRIPTION: Standard Apache 2.0 license header text with Google LLC copyright notice. Specifies terms for software usage, distribution, and modification.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/sports_schedule_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright 2025 Google LLC.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: pip command to install Google OR-Tools optimization package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/steel_lns.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Examining Clang INT64 macro definitions on MacOS\nDESCRIPTION: Command to check how int64_t types are defined in Clang on MacOS. This shows that MacOS uses 'long long int' rather than 'long int' for 64-bit integers, unlike Linux.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/swig.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nclang -dM -E -x c++ /dev/null | grep INT64_TYPE\n#define __INT64_TYPE__ long long int\n#define __UINT64_TYPE__ long long unsigned int\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Jupyter environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bool_and_int_var_product_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: This snippet installs the ortools package using pip, which is required to run the cloning model example.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/clone_model_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools package using pip package manager\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/golomb8.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools package required for the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/volsay3.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the Google OR-Tools optimization package using pip in a Colab notebook environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/constraint_solver/vrp_pickup_delivery.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package for Python\nDESCRIPTION: This snippet installs the Google OR-Tools package, which is required for using the CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/max_flow_taha.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing Google OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools optimization package required for solving the wedding seating chart problem using constraint programming.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/wedding_optimal_chart_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the Google OR-Tools package required for the optimization solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/chemical_balance_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Displaying OR-Tools Directory Structure\nDESCRIPTION: Shows the basic directory structure after extracting the OR-Tools archive, including license, readme, examples, and makefile locations.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/README.dotnet.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nor-tools/\n  [LICENSE](LICENSE)     <- Apache License.\n  [README.md](README.md) <- This file.\n  [examples](examples)   <- .Net examples.\n  [Makefile](Makefile)   <- Main Makefile for .Net.\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/vendor_scheduling.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip. This is required to run the Futoshiki solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/futoshiki.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Google Colab\nDESCRIPTION: Installs the ortools package using pip in a Jupyter notebook environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/spread_robots_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package which provides the constraint programming solver used for solving the Sudoku puzzle.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/sudoku_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools with pip\nDESCRIPTION: This command installs the ortools package using pip. The ortools package is necessary for using the constraint programming solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/overlapping_intervals_sample_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"%pip install ortools\"\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the required Google OR-Tools package using pip.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nonogram_regular.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Command to install the OR-Tools package using pip, which is required for the QUBO solver implementation.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/qubo_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/contiguity_regular.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/curious_set_of_integers.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools in Python\nDESCRIPTION: Installs the OR-Tools package for Python, required for solving mathematical optimization problems such as Mixed Integer Programming. This step is necessary before running any OR-Tools based solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/linear_solver/assignment_teams_mip.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Colab\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Colab environment. This is a prerequisite for running the N-Queens solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/nqueens_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip installation command for the Google OR-Tools package required for running the optimization model.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/set_covering2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/eq10.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the OR-Tools package using pip, which is required for the constraint programming solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/lectures.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the OR-Tools package using pip, which is required for the crew allocation problem solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/crew.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installation command for the Google OR-Tools optimization package using pip\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/examples/bus_driver_scheduling_flow_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Pip command to install the required Google OR-Tools package.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/nqueens3.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: This snippet shows how to install the OR-Tools package using pip. This is a prerequisite for using the KnapsackSolver in the main code.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/algorithms/simple_knapsack_program.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package in Python\nDESCRIPTION: Installs the ortools package using pip, which is required for using Google's CP Solver.\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/contrib/crossword2.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Installing OR-Tools Package\nDESCRIPTION: Installs the Google OR-Tools package using pip in a Jupyter/Colab environment\nSOURCE: https://github.com/google/or-tools/blob/stable/examples/notebook/sat/rabbits_and_pheasants_sat.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install ortools\n```\n\n----------------------------------------\n\nTITLE: Setting SWIG Output Directory in CMake\nDESCRIPTION: CMake configuration to specify output directories for SWIG-generated Java and library files.\nSOURCE: https://github.com/google/or-tools/blob/stable/cmake/docs/java.md#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_SWIG_OUTDIR ${CMAKE_CURRENT_BINARY_DIR}/..)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/..)\nset(SWIG_OUTFILE_DIR ${CMAKE_CURRENT_BINARY_DIR}/..)\n```\n\n----------------------------------------\n\nTITLE: Running Makefile from Top Directory\nDESCRIPTION: Demonstrates how to run the Makefile from the top-level directory of the project. This command specifies the directory containing the Makefile.\nSOURCE: https://github.com/google/or-tools/blob/stable/makefiles/docs/ci.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmake --directory=makefiles\n```\n\n----------------------------------------\n\nTITLE: Testing OR-Tools in Ubuntu Container\nDESCRIPTION: Example of how to execute tests inside an Ubuntu container using the predefined make target ubuntu_test.\nSOURCE: https://github.com/google/or-tools/blob/stable/bazel/docs/ci.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nmake ubuntu_test\n```\n\n----------------------------------------\n\nTITLE: Boolean Problem Definition\nDESCRIPTION: Legacy protocol buffer format for defining boolean problems, now deprecated in favor of cp_model.proto.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/sat/README.md#2025-04-17_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nboolean_problem.proto\n```\n\n----------------------------------------\n\nTITLE: Basic Makefile Usage\nDESCRIPTION: Commands to access the Makefile help, showing two different ways to execute the make command - either from the current directory or from the project root.\nSOURCE: https://github.com/google/or-tools/blob/stable/tools/docker/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake\n```\n\nLANGUAGE: shell\nCODE:\n```\nmake --directory=tools/docker\n```\n\n----------------------------------------\n\nTITLE: Applying Apache License Notice Template\nDESCRIPTION: Boilerplate notice template for applying the Apache License 2.0 to a work, including copyright statement and standard license text that should be included in the file header.\nSOURCE: https://github.com/google/or-tools/blob/stable/ortools/julia/ORToolsGenerated.jl/LICENSE.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```"
  }
]