[
  {
    "owner": "protocolbuffers",
    "repo": "protocolbuffers.github.io",
    "content": "TITLE: Defining a Basic Person Message in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a simple 'Person' message in a .proto file with string and integer fields. It demonstrates the basic syntax for message definition including field types, names, and numerical identifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/overview.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Person {\n  string name = 1;\n  int32 id = 2;\n  string email = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Comments to proto3 Files\nDESCRIPTION: Demonstrates the proper way to add comments to .proto files, including both line-end style comments and C-style multi-line comments. The example shows how to document a message type and its fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_3\n\nLANGUAGE: proto3\nCODE:\n```\n/**\n * SearchRequest represents a search query, with pagination options to\n * indicate which results to include in the response.\n */\nmessage SearchRequest {\n  string query = 1;\n\n  // Which page number do we want?\n  int32 page_number = 2;\n\n  // Number of results to return per page.\n  int32 results_per_page = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Message Type in proto3\nDESCRIPTION: A simple example of defining a SearchRequest message type with three fields: a string query, and two int32 fields for pagination information. The snippet demonstrates basic proto3 syntax and field numbering.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_0\n\nLANGUAGE: proto3\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 results_per_page = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of a Proto3 File\nDESCRIPTION: Provides a comprehensive example of a complete .proto file, including syntax declaration, imports, options, enum definitions, and message definitions with nested messages and fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_34\n\nLANGUAGE: proto3\nCODE:\n```\nsyntax = \"proto3\";\nimport public \"other.proto\";\noption java_package = \"com.example.foo\";\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 1;\n  EAA_FINISHED = 2 [(custom_option) = \"hello world\"];\n}\nmessage Outer {\n  option (my_option).a = true;\n  message Inner {   // Level 2\n    int64 ival = 1;\n  }\n  repeated Inner inner_message = 2;\n  EnumAllowingAlias enum_field = 3;\n  map<int32, string> my_map = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Messages for Address Book in Proto2\nDESCRIPTION: This code snippet defines the message formats for a simple address book application using Protocol Buffers version 2 syntax. It includes message definitions for Person (with nested PhoneNumber and PhoneType enum) and AddressBook.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/cpptutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\npackage tutorial;\n\nmessage Person {\n  optional string name = 1;\n  optional int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    PHONE_TYPE_UNSPECIFIED = 0;\n    PHONE_TYPE_MOBILE = 1;\n    PHONE_TYPE_HOME = 2;\n    PHONE_TYPE_WORK = 3;\n  }\n\n  message PhoneNumber {\n    optional string number = 1;\n    optional PhoneType type = 2 [default = PHONE_TYPE_HOME];\n  }\n\n  repeated PhoneNumber phones = 4;\n}\n\nmessage AddressBook {\n  repeated Person people = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Aliases in Protocol Buffers\nDESCRIPTION: This example shows how to create enum aliases by assigning the same value to different enum constants using the allow_alias option. Without this option enabled, duplicate values will generate compiler warnings.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 1;\n  EAA_FINISHED = 2;\n}\n\nenum EnumNotAllowingAlias {\n  ENAA_UNSPECIFIED = 0;\n  ENAA_STARTED = 1;\n  // ENAA_RUNNING = 1;  // Uncommenting this line will cause a warning message.\n  ENAA_FINISHED = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Self-Describing Protocol Messages using FileDescriptorSet\nDESCRIPTION: This snippet demonstrates how to create a self-describing protocol message by embedding both the message descriptor information and the message itself. It utilizes FileDescriptorProto to describe the message type and its dependencies, and uses the Any message type for encapsulating the actual message content.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/techniques.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\n\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/descriptor.proto\";\n\nmessage SelfDescribingMessage {\n  // Set of FileDescriptorProtos which describe the type and its dependencies.\n  google.protobuf.FileDescriptorSet descriptor_set = 1;\n\n  // The message and its type, encoded as an Any message.\n  google.protobuf.Any message = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Proto File Structure in Proto3\nDESCRIPTION: Specifies the overall structure of a Protocol Buffers file, which can contain syntax declaration, imports, package declaration, options, and top-level definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_33\n\nLANGUAGE: ebnf\nCODE:\n```\nproto = [syntax] { import | package | option | topLevelDef | emptyStatement }\ntopLevelDef = message | enum | service\n```\n\n----------------------------------------\n\nTITLE: Generated Accessor Methods for Person Message Class\nDESCRIPTION: Sample of generated getter methods for the Person message class. Shows accessor methods for required, optional, and repeated fields in the protocol buffer message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n// required string name = 1;\npublic boolean hasName();\npublic String getName();\n\n// required int32 id = 2;\npublic boolean hasId();\npublic int getId();\n\n// optional string email = 3;\npublic boolean hasEmail();\npublic String getEmail();\n\n// repeated .tutorial.Person.PhoneNumber phones = 4;\npublic List<PhoneNumber> getPhonesList();\npublic int getPhonesCount();\npublic PhoneNumber getPhones(int index);\n```\n\n----------------------------------------\n\nTITLE: Creating a Person Message Instance in C#\nDESCRIPTION: Demonstrates how to create and initialize a Person message instance with nested types using C# object initializers. Shows how to set primitive fields and add items to repeated fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nPerson john = new Person\n{\n    Id = 1234,\n    Name = \"John Doe\",\n    Email = \"jdoe@example.com\",\n    Phones = { new Person.Types.PhoneNumber { Number = \"555-4321\", Type = Person.Types.PhoneType.Home } }\n};\n```\n\n----------------------------------------\n\nTITLE: Defining an RPC Service in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define an RPC service interface in a .proto file. It shows defining a 'SearchService' with a 'Search' method that takes a SearchRequest and returns a SearchResponse.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nservice SearchService {\n  rpc Search(SearchRequest) returns (SearchResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations and Using Them in Messages in Protocol Buffers\nDESCRIPTION: This example demonstrates how to define an enum called Corpus with possible values and use it as a field type in a SearchRequest message. The first enum value must have value zero and should use the ENUM_TYPE_UNSPECIFIED naming convention.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nenum Corpus {\n  CORPUS_UNSPECIFIED = 0;\n  CORPUS_UNIVERSAL = 1;\n  CORPUS_WEB = 2;\n  CORPUS_IMAGES = 3;\n  CORPUS_LOCAL = 4;\n  CORPUS_NEWS = 5;\n  CORPUS_PRODUCTS = 6;\n  CORPUS_VIDEO = 7;\n}\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 results_per_page = 3;\n  Corpus corpus = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Reserving Field Numbers and Names in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to reserve field numbers and names in a Protocol Buffer message definition. It shows how to reserve individual numbers, ranges, and field names to prevent reuse and potential conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n  reserved \"foo\", \"bar\";\n}\n```\n\n----------------------------------------\n\nTITLE: Using Other Message Types as Field Types in Protocol Buffers\nDESCRIPTION: This example shows how to define multiple message types and use one as a field type in another. Here, SearchResponse contains a repeated field of Result message types defined in the same file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  repeated Result results = 1;\n}\n\nmessage Result {\n  string url = 1;\n  string title = 2;\n  repeated string snippets = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Serializing a Protocol Buffer in Java\nDESCRIPTION: This Java code demonstrates how to create a Person object using the generated builder pattern, set its fields, and serialize it to an output stream. It shows the typical pattern for working with protocol buffers in Java.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/overview.md#2025-04-11_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nPerson john = Person.newBuilder()\n    .setId(1234)\n    .setName(\"John Doe\")\n    .setEmail(\"jdoe@example.com\")\n    .build();\noutput = new FileOutputStream(args[0]);\njohn.writeTo(output);\n```\n\n----------------------------------------\n\nTITLE: Reading Protocol Buffer Messages from a File in C++\nDESCRIPTION: This C++ program demonstrates how to read Protocol Buffer messages from a file. It reads an AddressBook from a file and prints all the information contained within it. The code showcases message deserialization and accessing nested message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/cpptutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <fstream>\n#include <string>\n#include \"addressbook.pb.h\"\nusing namespace std;\n\n// Iterates though all people in the AddressBook and prints info about them.\nvoid ListPeople(const tutorial::AddressBook& address_book) {\n  for (int i = 0; i < address_book.people_size(); i++) {\n    const tutorial::Person& person = address_book.people(i);\n\n    cout << \"Person ID: \" << person.id() << endl;\n    cout << \"  Name: \" << person.name() << endl;\n    if (person.has_email()) {\n      cout << \"  E-mail address: \" << person.email() << endl;\n    }\n\n    for (int j = 0; j < person.phones_size(); j++) {\n      const tutorial::Person::PhoneNumber& phone_number = person.phones(j);\n\n      switch (phone_number.type()) {\n        case tutorial::Person::PHONE_TYPE_MOBILE:\n          cout << \"  Mobile phone #: \";\n          break;\n        case tutorial::Person::PHONE_TYPE_HOME:\n          cout << \"  Home phone #: \";\n          break;\n        case tutorial::Person::PHONE_TYPE_WORK:\n          cout << \"  Work phone #: \";\n          break;\n      }\n      cout << phone_number.number() << endl;\n    }\n  }\n}\n\n// Main function:  Reads the entire address book from a file and prints all\n//   the information inside.\nint main(int argc, char* argv[]) {\n  // Verify that the version of the library that we linked against is\n  // compatible with the version of the headers we compiled against.\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n\n  if (argc != 2) {\n    cerr << \"Usage:  \" << argv[0] << \" ADDRESS_BOOK_FILE\" << endl;\n    return -1;\n  }\n\n  tutorial::AddressBook address_book;\n\n  {\n    // Read the existing address book.\n    fstream input(argv[1], ios::in | ios::binary);\n    if (!address_book.ParseFromIstream(&input)) {\n      cerr << \"Failed to parse address book.\" << endl;\n      return -1;\n    }\n  }\n\n  ListPeople(address_book);\n\n  // Optional:  Delete all global objects allocated by libprotobuf.\n  google::protobuf::ShutdownProtobufLibrary();\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Map Field in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a map field in a Protocol Buffer message. It demonstrates creating a map of string keys to Project message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_21\n\nLANGUAGE: proto\nCODE:\n```\nmap<string, Project> projects = 3;\n```\n\n----------------------------------------\n\nTITLE: Writing Address Book Data with Protocol Buffers in Dart\nDESCRIPTION: This code demonstrates how to create and write a Protocol Buffer message to a file in Dart. It creates an AddressBook with a new Person entry based on user input and writes it to a file. It handles both creating a new file and updating an existing one.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/darttutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nimport 'dart:io';\n\nimport 'dart_tutorial/addressbook.pb.dart';\n\n// This function fills in a Person message based on user input.\nPerson promptForAddress() {\n  Person person = Person();\n\n  print('Enter person ID: ');\n  String input = stdin.readLineSync();\n  person.id = int.parse(input);\n\n  print('Enter name');\n  person.name = stdin.readLineSync();\n\n  print('Enter email address (blank for none) : ');\n  String email = stdin.readLineSync();\n  if (email.isNotEmpty) {\n    person.email = email;\n  }\n\n  while (true) {\n    print('Enter a phone number (or leave blank to finish): ');\n    String number = stdin.readLineSync();\n    if (number.isEmpty) break;\n\n    Person_PhoneNumber phoneNumber = Person_PhoneNumber();\n\n    phoneNumber.number = number;\n    print('Is this a mobile, home, or work phone? ');\n\n    String type = stdin.readLineSync();\n    switch (type) {\n      case 'mobile':\n        phoneNumber.type = Person_PhoneType.PHONE_TYPE_MOBILE;\n        break;\n      case 'home':\n        phoneNumber.type = Person_PhoneType.PHONE_TYPE_HOME;\n        break;\n      case 'work':\n        phoneNumber.type = Person_PhoneType.PHONE_TYPE_WORK;\n        break;\n      default:\n        print('Unknown phone type.  Using default.');\n    }\n    person.phones.add(phoneNumber);\n  }\n\n  return person;\n}\n\n// Reads the entire address book from a file, adds one person based\n// on user input, then writes it back out to the same file.\nmain(List arguments) {\n  if (arguments.length != 1) {\n    print('Usage: add_person ADDRESS_BOOK_FILE');\n    exit(-1);\n  }\n\n  File file = File(arguments.first);\n  AddressBook addressBook;\n  if (!file.existsSync()) {\n    print('File not found. Creating new file.');\n    addressBook = AddressBook();\n  } else {\n    addressBook = AddressBook.fromBuffer(file.readAsBytesSync());\n  }\n  addressBook.people.add(promptForAddress());\n  file.writeAsBytes(addressBook.writeToBuffer());\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Protocol Buffer Messages to File in Python\nDESCRIPTION: Complete program that reads an AddressBook from a file, adds a new Person based on user input, and writes the updated AddressBook back to the file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/pythontutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\nimport addressbook_pb2\nimport sys\n\ndef PromptForAddress(person):\n  person.id = int(input(\"Enter person ID number: \"))\n  person.name = input(\"Enter name: \")\n\n  email = input(\"Enter email address (blank for none): \")\n  if email != \"\":\n    person.email = email\n\n  while True:\n    number = input(\"Enter a phone number (or leave blank to finish): \")\n    if number == \"\":\n      break\n\n    phone_number = person.phones.add()\n    phone_number.number = number\n\n    phone_type = input(\"Is this a mobile, home, or work phone? \")\n    if phone_type == \"mobile\":\n      phone_number.type = addressbook_pb2.Person.PhoneType.PHONE_TYPE_MOBILE\n    elif phone_type == \"home\":\n      phone_number.type = addressbook_pb2.Person.PhoneType.PHONE_TYPE_HOME\n    elif phone_type == \"work\":\n      phone_number.type = addressbook_pb2.Person.PhoneType.PHONE_TYPE_WORK\n    else:\n      print(\"Unknown phone type; leaving as default value.\")\n\nif len(sys.argv) != 2:\n  print(\"Usage:\", sys.argv[0], \"ADDRESS_BOOK_FILE\")\n  sys.exit(-1)\n\naddress_book = addressbook_pb2.AddressBook()\n\ntry:\n  with open(sys.argv[1], \"rb\") as f:\n    address_book.ParseFromString(f.read())\nexcept IOError:\n  print(sys.argv[1] + \": Could not open file.  Creating a new one.\")\n\nPromptForAddress(address_book.people.add())\n\nwith open(sys.argv[1], \"wb\") as f:\n  f.write(address_book.SerializeToString())\n```\n\n----------------------------------------\n\nTITLE: Defining Packed Repeated Fields in Proto2\nDESCRIPTION: Shows how to define repeated fields with packed encoding for better efficiency. Used for scalar numeric types and enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_1\n\nLANGUAGE: proto2\nCODE:\n```\nrepeated int32 samples = 4 [packed = true];\nrepeated ProtoEnum results = 5 [packed = true];\n```\n\n----------------------------------------\n\nTITLE: Using Public Imports for Transitioning Proto Files\nDESCRIPTION: This example demonstrates how to use 'import public' to create placeholder files when moving proto definitions to new locations. This allows clients to continue importing the old location while transitioning to the new structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\n// new.proto\n// All definitions are moved here\n```\n\nLANGUAGE: proto\nCODE:\n```\n// old.proto\n// This is the proto that all clients are importing.\nimport public \"new.proto\";\nimport \"other.proto\";\n```\n\nLANGUAGE: proto\nCODE:\n```\n// client.proto\nimport \"old.proto\";\n// You use definitions from old.proto and new.proto, but not other.proto\n```\n\n----------------------------------------\n\nTITLE: Reading Protocol Buffer Messages in Kotlin\nDESCRIPTION: This snippet shows how to read Protocol Buffer messages from a file in Kotlin. It includes a function to print the contents of an AddressBook and a main function to read the file and display its contents.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/kotlintutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.example.tutorial.Person\nimport com.example.tutorial.AddressBook\n\n// Iterates though all people in the AddressBook and prints info about them.\nfun print(addressBook: AddressBook) {\n  for (person in addressBook.peopleList) {\n    println(\"Person ID: ${person.id}\")\n    println(\"  Name: ${person.name}\")\n    if (person.hasEmail()) {\n      println(\"  Email address: ${person.email}\")\n    }\n    for (phoneNumber in person.phonesList) {\n      val modifier = when (phoneNumber.type) {\n        Person.PhoneType.PHONE_TYPE_MOBILE -> \"Mobile\"\n        Person.PhoneType.PHONE_TYPE_HOME -> \"Home\"\n        Person.PhoneType.PHONE_TYPE_WORK -> \"Work\"\n        else -> \"Unknown\"\n      }\n      println(\"  $modifier phone #: ${phoneNumber.number}\")\n    }\n  }\n}\n\nfun main(args: List) {\n  if (arguments.size != 1) {\n    println(\"Usage: list_person ADDRESS_BOOK_FILE\")\n    exitProcess(-1)\n  }\n  Path(arguments.single()).inputStream().use {\n    print(AddressBook.newBuilder().mergeFrom(it).build())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Go Package Option in Protocol Buffers\nDESCRIPTION: Defines the Go package import path for the generated code. This will produce code in the tutorialpb package, which is the last path component of the specified import path.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\noption go_package = \"github.com/protocolbuffers/protobuf/examples/go/tutorialpb\";\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer Data in C++\nDESCRIPTION: C++ code that demonstrates how to read a serialized Protocol Buffer from a file and access its fields. This shows the typical pattern for deserializing Protocol Buffer objects and extracting their data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/_index.md#2025-04-11_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// C++ code\nPerson john;\nfstream input(argv[1],\n    ios::in | ios::binary);\njohn.ParseFromIstream(&input);\nid = john.id();\nname = john.name();\nemail = john.email();\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC Server with Protocol Buffers in C++\nDESCRIPTION: Demonstrates how to implement an RPC server using Protocol Buffers service interface in C++ by creating a concrete service implementation and registering it with an RPC server.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_41\n\nLANGUAGE: c++\nCODE:\n```\nusing google::protobuf;\n\nclass ExampleSearchService : public SearchService {\n public:\n  void Search(protobuf::RpcController* controller,\n              const SearchRequest* request,\n              SearchResponse* response,\n              protobuf::Closure* done) {\n    if (request->query() == \"google\") {\n      response->add_result()->set_url(\"http://www.google.com\");\n    } else if (request->query() == \"protocol buffers\") {\n      response->add_result()->set_url(\"http://protobuf.googlecode.com\");\n    }\n    done->Run();\n  }\n};\n\nint main() {\n  // You provide class MyRpcServer.  It does not have to implement any\n  // particular interface; this is just an example.\n  MyRpcServer server;\n\n  protobuf::Service* service = new ExampleSearchService;\n  server.ExportOnPort(1234, service);\n  server.Run();\n\n  delete service;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Person Message in Protocol Buffers\nDESCRIPTION: A simple Protocol Buffer definition for a Person message containing name, id, and email fields. This proto file uses edition 2023 and demonstrates the basic structure of message definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Person {\n  string name = 1;\n  int32 id = 2;\n  string email = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Protocol Buffers with protoc\nDESCRIPTION: This shell command demonstrates how to use the protocol buffer compiler (protoc) to generate C++ classes from a .proto file. It specifies the source directory, destination directory, and the path to the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/cpptutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto\n```\n\n----------------------------------------\n\nTITLE: Defining an Any Field in Protocol Buffers\nDESCRIPTION: Example showing how to define a message with a google.protobuf.Any field which can contain any protocol buffer message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_35\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/any.proto\";\n\nmessage ErrorStatus {\n  string message = 1;\n  google.protobuf.Any details = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nested Message Types in Protocol Buffers\nDESCRIPTION: Demonstrates how to define and use message types within other messages. The example shows a SearchResponse message that contains repeated Result messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  repeated Result results = 1;\n}\n\nmessage Result {\n  string url = 1;\n  string title = 2;\n  repeated string snippets = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations in Protocol Buffers\nDESCRIPTION: Example showing how to define an enumeration within a message in Protocol Buffers, with named constants mapping to integer values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_31\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  enum SomeEnum {\n    VALUE_A = 0;\n    VALUE_B = 5;\n    VALUE_C = 1234;\n  }\n  optional SomeEnum bar = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Deserializing a Protocol Buffer in C++\nDESCRIPTION: This C++ snippet shows how to read a serialized protocol buffer from a file and access its fields. It demonstrates parsing from a binary input stream and retrieving the values of different field types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/overview.md#2025-04-11_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nPerson john;\nfstream input(argv[1], ios::in | ios::binary);\njohn.ParseFromIstream(&input);\nint id = john.id();\nstd::string name = john.name();\nstd::string email = john.email();\n```\n\n----------------------------------------\n\nTITLE: Computing Timestamp from current time in Python\nDESCRIPTION: Creates a Protocol Buffer Timestamp with nanosecond precision from the current system time in Python. The time.time() function provides a floating-point value that is split into seconds and nanoseconds.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnow = time.time()\nseconds = int(now)\nnanos = int((now - seconds) * 10**9)\ntimestamp = Timestamp(seconds=seconds, nanos=nanos)\n```\n\n----------------------------------------\n\nTITLE: Using Oneof Fields in C++\nDESCRIPTION: Demonstrates common operations and potential pitfalls when working with oneof fields in C++.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nSampleMessage message;\nmessage.set_name(\"name\");\nCHECK(message.has_name());\n// Calling mutable_sub_message() will clear the name field and will set\n// sub_message to a new instance of SubMessage with none of its fields set.\nmessage.mutable_sub_message();\nCHECK(!message.has_name());\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Message Type in Protocol Buffers (Edition 2023)\nDESCRIPTION: Demonstrates how to define a basic message type 'SearchRequest' with three fields: query (string), page_number (int32), and results_per_page (int32). The example shows the usage of the 'edition' specifier for edition 2023.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 results_per_page = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Message Definition in Proto3\nDESCRIPTION: Defines the basic protocol buffer structure for an address book application including Person and AddressBook messages with nested types for phone numbers and timestamps.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/darttutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\npackage tutorial;\n\nimport \"google/protobuf/timestamp.proto\";\n```\n\n----------------------------------------\n\nTITLE: Deep Nesting of Message Types in Protocol Buffers\nDESCRIPTION: This example demonstrates how to nest message types multiple levels deep. Note that nested types with the same name are completely independent if they're defined in different parent messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nmessage Outer {       // Level 0\n  message MiddleAA {  // Level 1\n    message Inner {   // Level 2\n      int64 ival = 1;\n      bool  booly = 2;\n    }\n  }\n  message MiddleBB {  // Level 1\n    message Inner {   // Level 2\n      int32 ival = 1;\n      bool  booly = 2;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Proto File Example in Protocol Buffers\nDESCRIPTION: Demonstrates a complete .proto file in Protocol Buffers Edition 2023 with imports, options, enum definitions, message definitions, and various field types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_36\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\nimport public \"other.proto\";\noption java_package = \"com.example.foo\";\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 1;\n  EAA_FINISHED = 2 [(custom_option) = \"hello world\"];\n}\nmessage Outer {\n  option (my_option).a = true;\n  message Inner {   // Level 2\n    int64 ival = 1 [features.field_presence = LEGACY_REQUIRED];\n  }\n  repeated Inner inner_message = 2;\n  EnumAllowingAlias enum_field = 3;\n  map<int32, string> my_map = 4;\n  extensions 20 to 30;\n  reserved reserved_field;\n}\nmessage Foo {\n  message GroupMessage {\n    bool a = 1;\n  }\n  GroupMessage groupmessage = [features.message_encoding = DELIMITED];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Message Type in Proto2\nDESCRIPTION: Demonstrates how to define a basic SearchRequest message type with optional fields for query string, page number, and results per page. Shows basic proto2 syntax and field definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_0\n\nLANGUAGE: proto2\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage SearchRequest {\n  optional string query = 1;\n  optional int32 page_number = 2;\n  optional int32 results_per_page = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Repeated Message Fields Assignment Limitations\nDESCRIPTION: Demonstrates the limitations of repeated message fields, specifically that they don't support item assignment. Shows both incorrect and correct approaches to modifying repeated message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nfoo.bars.add(i=3)\n# WRONG!\nfoo.bars[0] = Bar(i=15)  # Raises an exception\n# WRONG!\nfoo.bars[:] = [Bar(i=15), Bar(i=17)]  # Also raises an exception\n# WRONG!\n# AttributeError: Cannot delete field attribute\ndel foo.bars\n# RIGHT\ndel foo.bars[:]\nfoo.bars.extend([Bar(i=15), Bar(i=17)])\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Message Format for an Address Book Application\nDESCRIPTION: This proto file defines the message structure for an address book application, including Person and AddressBook messages. It specifies Java package options, field types, and demonstrates nested messages and enums. The file shows how to define optional and repeated fields with appropriate tags for efficient binary encoding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\npackage tutorial;\n\noption java_multiple_files = true;\noption java_package = \"com.example.tutorial.protos\";\noption java_outer_classname = \"AddressBookProtos\";\n\nmessage Person {\n  optional string name = 1;\n  optional int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    PHONE_TYPE_UNSPECIFIED = 0;\n    PHONE_TYPE_MOBILE = 1;\n    PHONE_TYPE_HOME = 2;\n    PHONE_TYPE_WORK = 3;\n  }\n\n  message PhoneNumber {\n    optional string number = 1;\n    optional PhoneType type = 2 [default = PHONE_TYPE_HOME];\n  }\n\n  repeated PhoneNumber phones = 4;\n}\n\nmessage AddressBook {\n  repeated Person people = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Protocol Buffer Message in C++\nDESCRIPTION: Example of defining a simple protocol buffer message named 'Foo' with a string field and a repeated integer field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Foo {\n  optional string text = 1;\n  repeated int32 numbers = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing a Protocol Buffer Message from a File in C#\nDESCRIPTION: Shows how to deserialize a Protocol Buffer message from a file using the static Parser property and ParseFrom method. This is the inverse operation of serialization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nPerson john;\nusing (var input = File.OpenRead(\"john.dat\"))\n{\n    john = Person.Parser.ParseFrom(input);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Persisting a Protocol Buffer in Java\nDESCRIPTION: Java code that demonstrates how to use a generated Protocol Buffer class to create a Person object, populate its fields, and write it to a file output stream. This shows the typical pattern for serializing Protocol Buffer objects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Java code\nPerson john = Person.newBuilder()\n    .setId(1234)\n    .setName(\"John Doe\")\n    .setEmail(\"jdoe@example.com\")\n    .build();\noutput = new FileOutputStream(args[0]);\njohn.writeTo(output);\n```\n\n----------------------------------------\n\nTITLE: Generated Accessor Methods for Protocol Buffer Fields in C++\nDESCRIPTION: Shows the accessor methods generated for different types of Protocol Buffer fields including string fields (name, email), numeric fields (id), and repeated fields (phones). Demonstrates getters, setters, has_, clear_, and mutable_ methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/cpptutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n  // name\n  inline bool has_name() const;\n  inline void clear_name();\n  inline const ::std::string& name() const;\n  inline void set_name(const ::std::string& value);\n  inline void set_name(const char* value);\n  inline ::std::string* mutable_name();\n\n  // id\n  inline bool has_id() const;\n  inline void clear_id();\n  inline int32_t id() const;\n  inline void set_id(int32_t value);\n\n  // email\n  inline bool has_email() const;\n  inline void clear_email();\n  inline const ::std::string& email() const;\n  inline void set_email(const ::std::string& value);\n  inline void set_email(const char* value);\n  inline ::std::string* mutable_email();\n\n  // phones\n  inline int phones_size() const;\n  inline void clear_phones();\n  inline const ::google::protobuf::RepeatedPtrField< ::tutorial::Person_PhoneNumber >& phones() const;\n  inline ::google::protobuf::RepeatedPtrField< ::tutorial::Person_PhoneNumber >* mutable_phones();\n  inline const ::tutorial::Person_PhoneNumber& phones(int index) const;\n  inline ::tutorial::Person_PhoneNumber* mutable_phones(int index);\n  inline ::tutorial::Person_PhoneNumber* add_phones();\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Declarations in Proto3\nDESCRIPTION: Example showing how to declare extensions within a message definition using the extension declarations syntax. This demonstrates declaring multiple extension fields with different types and packages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/extension_declarations.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Foo {\n  extensions 4 to 1000 [\n    declaration = {\n      number: 4,\n      full_name: \".my.package.event_annotations\",\n      type: \".logs.proto.ValidationAnnotations\",\n      repeated: true },\n    declaration = {\n      number: 999,\n      full_name: \".foo.package.bar\",\n      type: \"int32\"}];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Proto3\nDESCRIPTION: Specifies the syntax for map fields in Protocol Buffers, which provide a way to associate key-value pairs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_22\n\nLANGUAGE: ebnf\nCODE:\n```\nmapField = \"map\" \"<\" keyType \",\" type \">\" mapName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\nkeyType = \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" |\n          \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\"\n```\n\n----------------------------------------\n\nTITLE: Manipulating Repeated Message Fields\nDESCRIPTION: Demonstrates working with repeated message fields, including using add(), append(), and extend(). Shows how copies are made when adding messages and how to use keyword arguments and initializers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nbar = foo.bars.add()        # Adds a Bar then modify\nbar.i = 15\nfoo.bars.add().i = 32       # Adds and modify at the same time\nnew_bar = Bar()\nnew_bar.i = 40\nanother_bar = Bar()\nanother_bar.i = 57\nfoo.bars.append(new_bar)        # Uses append() to copy\nfoo.bars.extend([another_bar])  # Uses extend() to copy\n\nassert len(foo.bars) == 4\nassert foo.bars[0].i == 15\nassert foo.bars[1].i == 32\nassert foo.bars[2].i == 40\nassert foo.bars[2] == new_bar      # The appended message is equal,\nassert foo.bars[2] is not new_bar  # but it is a copy!\nassert foo.bars[3].i == 57\nassert foo.bars[3] == another_bar      # The extended message is equal,\nassert foo.bars[3] is not another_bar  # but it is a copy!\n\nfoo.bars[1].i = 56    # Modifies a single element\nassert foo.bars[1].i == 56\nfor bar in foo.bars:  # Loops and print\n  print(bar.i)\ndel foo.bars[:]       # Clears list\n\n# add() also forwards keyword arguments to the concrete class.\n# For example, you can do:\n\nfoo.bars.add(i=12, j=13)\n\n# Initializers forward keyword arguments to a concrete class too.\n# For example:\n\nfoo = Foo(             # Creates Foo\n  bars=[               # with its field bars set to a list\n    Bar(i=15, j=17),   # where each list member is also initialized during creation.\n    Bar(i=32),\n    Bar(i=47, j=77),\n  ]\n)\n\nassert len(foo.bars) == 3\nassert foo.bars[0].i == 15\nassert foo.bars[0].j == 17\nassert foo.bars[1].i == 32\nassert foo.bars[2].i == 47\nassert foo.bars[2].j == 77\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Option in Protocol Buffers\nDESCRIPTION: Shows how to set the optimize_for option to control code generation optimization for speed, code size, or lite runtime.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_28\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = CODE_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Packing Messages with Any in Python\nDESCRIPTION: Example of using the Pack() and Unpack() methods with the Any well-known type to serialize and deserialize protocol buffer messages in Python.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nany_message.Pack(message)\nany_message.Unpack(message)\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Service in Protocol Buffers\nDESCRIPTION: Demonstrates how to define an RPC service interface in a .proto file, showing a search service example with request and response types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_32\n\nLANGUAGE: proto\nCODE:\n```\nservice SearchService {\n  rpc Search(SearchRequest) returns (SearchResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Protocol Buffer Messages in Java\nDESCRIPTION: This code shows how to read Protocol Buffer messages from a file in Java. It reads an AddressBook file, iterates through all Person entries, and prints their details including ID, name, email, and phone numbers with appropriate type labels.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nimport com.example.tutorial.protos.AddressBook;\nimport com.example.tutorial.protos.Person;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nclass ListPeople {\n  // Iterates though all people in the AddressBook and prints info about them.\n  static void Print(AddressBook addressBook) {\n    for (Person person: addressBook.getPeopleList()) {\n      System.out.println(\"Person ID: \" + person.getId());\n      System.out.println(\"  Name: \" + person.getName());\n      if (person.hasEmail()) {\n        System.out.println(\"  E-mail address: \" + person.getEmail());\n      }\n\n      for (Person.PhoneNumber phoneNumber : person.getPhonesList()) {\n        switch (phoneNumber.getType()) {\n          case PHONE_TYPE_MOBILE:\n            System.out.print(\"  Mobile phone #: \");\n            break;\n          case PHONE_TYPE_HOME:\n            System.out.print(\"  Home phone #: \");\n            break;\n          case PHONE_TYPE_WORK:\n            System.out.print(\"  Work phone #: \");\n            break;\n        }\n        System.out.println(phoneNumber.getNumber());\n      }\n    }\n  }\n\n  // Main function:  Reads the entire address book from a file and prints all\n  //   the information inside.\n  public static void main(String[] args) throws Exception {\n    if (args.length != 1) {\n      System.err.println(\"Usage:  ListPeople ADDRESS_BOOK_FILE\");\n      System.exit(-1);\n    }\n\n    // Read the existing address book.\n    AddressBook addressBook =\n      AddressBook.parseFrom(new FileInputStream(args[0]));\n\n    Print(addressBook);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Package in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define a package in a .proto file to prevent name clashes between protocol message types. It shows defining a package 'foo.bar' and a message 'Open' within that package.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_22\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\nmessage Open { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Types and Fields in Protocol Buffers\nDESCRIPTION: Illustrates the definition of an enum type and optional enum fields in Protocol Buffers. These definitions result in specific C++ accessor methods for enum handling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\nenum Bar {\n  BAR_UNSPECIFIED = 0;\n  BAR_VALUE = 1;\n  BAR_OTHER_VALUE = 2;\n}\n\noptional Bar bar = 1;\nrequired Bar bar = 1;\n```\n\n----------------------------------------\n\nTITLE: Reserving Deleted Field Numbers in Protocol Buffers\nDESCRIPTION: Demonstrates how to reserve tag numbers and names for deleted fields to prevent accidental reuse. This helps maintain backwards compatibility when evolving schemas.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/dos-donts.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nreserved 2, 3;\nreserved \"foo\", \"bar\";\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Presence Numeric Fields in Protocol Buffers (proto3)\nDESCRIPTION: Shows the definition of an implicit presence numeric field in proto3 syntax. This generates specific C++ accessor methods without the 'has' method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nint32 foo = 1;  // no field label specified, defaults to implicit presence.\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compiler Usage Command\nDESCRIPTION: Command line syntax for invoking the protocol buffer compiler (protoc) to generate code in multiple target languages. Shows import path configuration and output directory specification for each supported language.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_37\n\nLANGUAGE: sh\nCODE:\n```\nprotoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto\n```\n\n----------------------------------------\n\nTITLE: Defining a Protocol Buffer Extension Field\nDESCRIPTION: Example showing how to declare extension fields for a message type. Extensions are only available in proto2 and allow adding fields to messages without modifying the original definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_43\n\nLANGUAGE: proto\nCODE:\n```\nextend Foo {\n  optional int32 bar = 123;\n  repeated int32 repeated_bar = 124;\n  optional Bar message_bar = 125;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compiler Command Usage\nDESCRIPTION: Shows the command line syntax for using the protoc compiler to generate code for multiple programming languages with import path and output directory specifications.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_45\n\nLANGUAGE: sh\nCODE:\n```\nprotoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto\n```\n\n----------------------------------------\n\nTITLE: Using Nested Extensions in Java\nDESCRIPTION: Shows how to use extensions that are defined within the scope of another message type in Java. These extensions must be accessed with the outer type's name as prefix.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_29\n\nLANGUAGE: java\nCODE:\n```\nBaz baz = createMyBaz();\nFoo foo =\n  Foo.newBuilder()\n     .setExtension(Baz.fooExt, baz)\n     .build();\nassert foo.hasExtension(Baz.fooExt);\nassert foo.getExtension(Baz.fooExt) == baz;\n```\n\n----------------------------------------\n\nTITLE: Working with Message Maps in Protocol Buffers (Python)\nDESCRIPTION: Demonstrates how to work with maps that have message type values in Protocol Buffers. Shows how submessages are automatically created when accessed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> m.message_map[5].foo = 3\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Protocol Buffer Message\nDESCRIPTION: Basic protocol buffer message definition with a single int32 field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nmessage Test1 {\n  int32 a = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Proto3 Message in Protocol Buffers\nDESCRIPTION: Example of a proto3 syntax definition for a Player message, showing optional fields, default field presence, packed repeated fields, and open enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-06-29.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\n// proto3 file\nsyntax = \"proto3\";\n\nmessage Player {\n  // in proto3, optional fields have explicit presence\n  optional string name = 1;\n  // in proto3 no specified field rule defaults to implicit presence\n  int32 id = 2;\n  // in proto3 this is packed by default\n  repeated int32 scores = 3;\n\n  enum Handed {\n    HANDED_UNSPECIFIED = 0,\n    HANDED_LEFT = 1,\n    HANDED_RIGHT = 2,\n    HANDED_AMBIDEXTROUS = 3,\n  }\n\n  // in proto3 enums are open\n  optional Handed handed = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Nested Messages Using Sub-Builders\nDESCRIPTION: Java code demonstrating the more efficient approach to modifying deeply nested message values using sub-builders, which avoids repeatedly creating and rebuilding intermediate objects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: java\nCODE:\n```\nBaz.Builder builder = baz.toBuilder();\nbuilder.getBarBuilder().getFooBuilder().setVal(10);\nbaz = builder.build();\n```\n\n----------------------------------------\n\nTITLE: Reading Protocol Buffer Messages from File in Python\nDESCRIPTION: Program that reads an AddressBook file and prints all the information contained within it, demonstrating how to access and iterate through protocol buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/pythontutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\nimport addressbook_pb2\nimport sys\n\ndef ListPeople(address_book):\n  for person in address_book.people:\n    print(\"Person ID:\", person.id)\n    print(\"  Name:\", person.name)\n    if person.HasField('email'):\n      print(\"  E-mail address:\", person.email)\n\n    for phone_number in person.phones:\n      if phone_number.type == addressbook_pb2.Person.PhoneType.PHONE_TYPE_MOBILE:\n        print(\"  Mobile phone #: \", end=\"\")\n      elif phone_number.type == addressbook_pb2.Person.PhoneType.PHONE_TYPE_HOME:\n        print(\"  Home phone #: \", end=\"\")\n      elif phone_number.type == addressbook_pb2.Person.PhoneType.PHONE_TYPE_WORK:\n        print(\"  Work phone #: \", end=\"\")\n      print(phone_number.number)\n\nif len(sys.argv) != 2:\n  print(\"Usage:\", sys.argv[0], \"ADDRESS_BOOK_FILE\")\n  sys.exit(-1)\n\naddress_book = addressbook_pb2.AddressBook()\n\nwith open(sys.argv[1], \"rb\") as f:\n  address_book.ParseFromString(f.read())\n\nListPeople(address_book)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Wire Format Specification\nDESCRIPTION: Defines the complete wire format specification for Protocol Buffers including message structure, tag encoding, value types, and data type definitions. Includes varint encoding, fixed-size types, length-prefixed fields, and packed repeated fields specifications.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_8\n\nLANGUAGE: none\nCODE:\n```\nmessage    := (tag value)*\n\ntag        := (field << 3) bit-or wire_type;\n                encoded as uint32 varint\nvalue      := varint      for wire_type == VARINT,\n              i32         for wire_type == I32,\n              i64         for wire_type == I64,\n              len-prefix  for wire_type == LEN,\n              <empty>     for wire_type == SGROUP or EGROUP\n\nvarint     := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64;\n                encoded as varints (sintN are ZigZag-encoded first)\ni32        := sfixed32 | fixed32 | float;\n                encoded as 4-byte little-endian;\n                memcpy of the equivalent C types (u?int32_t, float)\ni64        := sfixed64 | fixed64 | double;\n                encoded as 8-byte little-endian;\n                memcpy of the equivalent C types (u?int64_t, double)\n\nlen-prefix := size (message | string | bytes | packed);\n                size encoded as int32 varint\nstring     := valid UTF-8 string (e.g. ASCII);\n                max 2GB of bytes\nbytes      := any sequence of 8-bit bytes;\n                max 2GB of bytes\npacked     := varint* | i32* | i64*,\n                consecutive values of the type specified in `.proto`\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Presence Enum Field\nDESCRIPTION: Field definition example showing implicit presence enum field in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nBar bar = 1;  // no field label specified, defaults to implicit presence.\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Scalar Type Declarations\nDESCRIPTION: Defines the available scalar types in Protocol Buffers with their properties and limitations. This includes numeric types (with variable-length encoding), boolean, string (UTF-8 encoded), and bytes types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\ndouble   // standard double precision floating point type\nfloat    // standard single precision floating point type\nint32    // variable-length encoded signed 32-bit integer\nint64    // variable-length encoded signed 64-bit integer\nuint32   // variable-length encoded unsigned 32-bit integer\nuint64   // variable-length encoded unsigned 64-bit integer\nsint32   // variable-length encoded signed 32-bit integer (efficient for negative numbers)\nsint64   // variable-length encoded signed 64-bit integer (efficient for negative numbers)\nfixed32  // always 4 bytes, unsigned 32-bit integer\nfixed64  // always 8 bytes, unsigned 64-bit integer\nsfixed32 // always 4 bytes, signed 32-bit integer\nsfixed64 // always 8 bytes, signed 64-bit integer\nbool     // boolean true/false\nstring   // UTF-8 encoded text (max 2^32 length)\nbytes    // arbitrary byte sequence (max 2^32 length)\n```\n\n----------------------------------------\n\nTITLE: Defining Message Types in Protocol Buffers\nDESCRIPTION: Defines the message types for the address book application, including Person with nested PhoneNumber message, PhoneType enum, and AddressBook message. Each field has a unique tag number that identifies it in the binary encoding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage Person {\n  string name = 1;\n  int32 id = 2;  // Unique ID number for this person.\n  string email = 3;\n\n  message PhoneNumber {\n    string number = 1;\n    PhoneType type = 2;\n  }\n\n  repeated PhoneNumber phones = 4;\n\n  google.protobuf.Timestamp last_updated = 5;\n}\n\nenum PhoneType {\n  PHONE_TYPE_UNSPECIFIED = 0;\n  PHONE_TYPE_MOBILE = 1;\n  PHONE_TYPE_HOME = 2;\n  PHONE_TYPE_WORK = 3;\n}\n\n// Our address book file is just one of these.\nmessage AddressBook {\n  repeated Person people = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading and Displaying Address Book Data with Protocol Buffers in Dart\nDESCRIPTION: This code shows how to read a Protocol Buffer message from a file and display its contents. It iterates through people in the address book and prints their details including ID, name, email, and phone numbers with their respective types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/darttutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nimport 'dart:io';\n\nimport 'dart_tutorial/addressbook.pb.dart';\nimport 'dart_tutorial/addressbook.pbenum.dart';\n\n// Iterates though all people in the AddressBook and prints info about them.\nvoid printAddressBook(AddressBook addressBook) {\n  for (Person person in addressBook.people) {\n    print('Person ID: ${ person.id}');\n    print('  Name: ${ person.name}');\n    if (person.hasEmail()) {\n      print('  E-mail address:${ person.email}');\n    }\n\n    for (Person_PhoneNumber phoneNumber in person.phones) {\n      switch (phoneNumber.type) {\n        case Person_PhoneType.PHONE_TYPE_MOBILE:\n          print('   Mobile phone #: ');\n          break;\n        case Person_PhoneType.PHONE_TYPE_HOME:\n          print('   Home phone #: ');\n          break;\n        case Person_PhoneType.PHONE_TYPE_WORK:\n          print('   Work phone #: ');\n          break;\n        default:\n          print('   Unknown phone #: ');\n          break;\n      }\n      print(phoneNumber.number);\n    }\n  }\n}\n\n// Reads the entire address book from a file and prints all\n// the information inside.\nmain(List arguments) {\n  if (arguments.length != 1) {\n    print('Usage: list_person ADDRESS_BOOK_FILE');\n    exit(-1);\n  }\n\n  // Read the existing address book.\n  File file = new File(arguments.first);\n AddressBook addressBook = new AddressBook.fromBuffer(file.readAsBytesSync());\n  printAddressBook(addressBook);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Related Message Types in proto3\nDESCRIPTION: Shows how to define multiple related message types in the same .proto file. This example includes both SearchRequest and SearchResponse in one file, which is useful for closely related message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_1\n\nLANGUAGE: proto3\nCODE:\n```\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 results_per_page = 3;\n}\n\nmessage SearchResponse {\n ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumeration Types in Protocol Buffers\nDESCRIPTION: Demonstrates how to define an enum type with multiple values and use it within a message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\nenum Corpus {\n  CORPUS_UNSPECIFIED = 0;\n  CORPUS_UNIVERSAL = 1;\n  CORPUS_WEB = 2;\n  CORPUS_IMAGES = 3;\n  CORPUS_LOCAL = 4;\n  CORPUS_NEWS = 5;\n  CORPUS_PRODUCTS = 6;\n  CORPUS_VIDEO = 7;\n}\n\nmessage SearchRequest {\n  optional string query = 1;\n  optional int32 page_number = 2;\n  optional int32 results_per_page = 3;\n  optional Corpus corpus = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Protocol Buffers Text Format File\nDESCRIPTION: Provides an example of a complete Protocol Buffers text format file, demonstrating various field types and syntax features.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_28\n\nLANGUAGE: textproto\nCODE:\n```\n# This is an example of Protocol Buffer's text format.\n# Unlike .proto files, only shell-style line comments are supported.\n\nname: \"John Smith\"\n\npet {\n  kind: DOG\n  name: \"Fluffy\"\n  tail_wagginess: 0.65f\n}\n\npet <\n  kind: LIZARD\n  name: \"Lizzy\"\n  legs: 4\n>\n\nstring_value_with_escape: \"valid \\n escape\"\nrepeated_values: [ \"one\", \"two\", \"three\" ]\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for Go Output\nDESCRIPTION: Example of using the protocol buffer compiler (protoc) to generate Go code. This command demonstrates the use of various flags to control output location and naming.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --go_out=out --go_opt=paths=source_relative foo.proto bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Types in Protocol Buffers\nDESCRIPTION: This example shows how to define message types inside other message types. The Result message is defined inside SearchResponse and can be accessed within it directly.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  message Result {\n    string url = 1;\n    string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result results = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Extension Field Definitions in Proto2\nDESCRIPTION: Example of defining various types of extension fields in Protocol Buffers, including scalar, repeated, and message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nextend Concert {\n  optional int32 singular_int32 = 1;\n  repeated bytes repeated_strings = 2;\n  optional Band singular_message = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Compiler with Multiple Option Flags\nDESCRIPTION: Example of invoking the compiler with both output directory flags and separate option flags to pass multiple parameters to a generator.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nprotoc --foo_out=enable_bar:outdir --foo_opt=enable_baz\n```\n\n----------------------------------------\n\nTITLE: Installing Protocol Compiler with apt (Linux)\nDESCRIPTION: This snippet shows how to install the protocol compiler using the apt package manager on Linux. It installs the protobuf-compiler package and verifies the installed version.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/installation.md#2025-04-11_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\napt install -y protobuf-compiler\nprotoc --version  # Ensure compiler version is 3+\n```\n\n----------------------------------------\n\nTITLE: Declaring Simple Message in Protocol Buffer\nDESCRIPTION: Example of a simple message declaration in a .proto file, which will generate a corresponding C++ class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Adding Nested Structures to ListValue in Protocol Buffers\nDESCRIPTION: Shows how to add complex nested structures like Struct and ListValue to an existing ListValue. This allows creating hierarchical data structures with Protocol Buffers dynamic values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nlist_value.add_struct()[\"key\"] = 1\nlist_value.add_list().extend([1, \"two\", True])\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler (protoc) for Multiple Languages\nDESCRIPTION: This command demonstrates how to use the protoc compiler to generate code for multiple programming languages from a .proto file. It specifies import paths, output directories for each language, and the input .proto file path.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_61\n\nLANGUAGE: sh\nCODE:\n```\nprotoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Shows how to define oneof fields to ensure only one field is set at a time, saving memory and enforcing mutual exclusivity.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nmessage SampleMessage {\n  oneof test_oneof {\n    string name = 4;\n    SubMessage sub_message = 9;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Message in Protocol Buffers\nDESCRIPTION: This snippet shows a basic message declaration in a .proto file, which will generate a corresponding Java class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Writing Protocol Buffer Messages in Kotlin\nDESCRIPTION: This snippet demonstrates how to create and write Protocol Buffer messages to a file in Kotlin. It includes functions for prompting user input to create a Person message and writing an AddressBook to a file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/kotlintutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.example.tutorial.Person\nimport com.example.tutorial.AddressBook\nimport com.example.tutorial.person\nimport com.example.tutorial.addressBook\nimport com.example.tutorial.PersonKt.phoneNumber\nimport java.util.Scanner\n\n// This function fills in a Person message based on user input.\nfun promptPerson(): Person = person {\n  print(\"Enter person ID: \")\n  id = readLine().toInt()\n\n  print(\"Enter name: \")\n  name = readLine()\n\n  print(\"Enter email address (blank for none): \")\n  val email = readLine()\n  if (email.isNotEmpty()) {\n    this.email = email\n  }\n\n  while (true) {\n    print(\"Enter a phone number (or leave blank to finish): \")\n    val number = readLine()\n    if (number.isEmpty()) break\n\n    print(\"Is this a mobile, home, or work phone? \")\n    val type = when (readLine()) {\n      \"mobile\" -> Person.PhoneType.PHONE_TYPE_MOBILE\n      \"home\" -> Person.PhoneType.PHONE_TYPE_HOME\n      \"work\" -> Person.PhoneType.PHONE_TYPE_WORK\n      else -> {\n        println(\"Unknown phone type.  Using home.\")\n        Person.PhoneType.PHONE_TYPE_HOME\n      }\n    }\n    phones += phoneNumber {\n      this.number = number\n      this.type = type\n    }\n  }\n}\n\n// Reads the entire address book from a file, adds one person based\n// on user input, then writes it back out to the same file.\nfun main(args: List) {\n  if (arguments.size != 1) {\n    println(\"Usage: add_person ADDRESS_BOOK_FILE\")\n    exitProcess(-1)\n  }\n  val path = Path(arguments.single())\n  val initialAddressBook = if (!path.exists()) {\n    println(\"File not found. Creating new file.\")\n    addressBook {}\n  } else {\n    path.inputStream().use {\n      AddressBook.newBuilder().mergeFrom(it).build()\n    }\n  }\n  path.outputStream().use {\n    initialAddressBook.copy { peopleList += promptPerson() }.writeTo(it)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enums in Protocol Buffers\nDESCRIPTION: Demonstrates the proper naming convention for enum types (TitleCase) and enum values (UPPER_SNAKE_CASE) with the recommended unspecified first value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/style.md#2025-04-11_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nenum FooBar {\n  FOO_BAR_UNSPECIFIED = 0;\n  FOO_BAR_FIRST_VALUE = 1;\n  FOO_BAR_SECOND_VALUE = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Go Package in Protocol Buffer File\nDESCRIPTION: Example of how to specify the Go package import path within a .proto file using the go_package option. This is the recommended way to define the Go package for a protocol buffer definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\noption go_package = \"example.com/project/protos/fizz\";\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Default Values\nDESCRIPTION: Defines the default values for different Protocol Buffer field types when a message is parsed and the field is not present in the encoded message bytes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\nstrings -> \"\"\nbytes -> empty bytes\nbools -> false\nnumeric types -> 0\nmessage fields -> not set (language-dependent)\nenums -> first defined enum value (should be 0)\nrepeated fields -> empty\nmap fields -> empty\n```\n\n----------------------------------------\n\nTITLE: Implementing Repeated Message Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to properly structure repeated fields using messages instead of scalars or enums. Shows the flexibility of using message types for photo enhancements that can be extended with additional fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nenum EnhancementType {\n  ENHANCEMENT_TYPE_UNSPECIFIED;\n  RED_EYE_REDUCTION;\n  SKIN_SOFTENING;\n}\n\nmessage PhotoEnhancement {\n  optional EnhancementType type;\n}\n\nmessage PhotoEnhancementReply {\n  // Good: PhotoEnhancement can grow to describe enhancements that require\n  // more fields than just an enum.\n  repeated PhotoEnhancement enhancements;\n\n  // Bad: If we ever want to return parameters associated with the\n  // enhancement, we'd have to introduce a parallel array (terrible) or\n  // deprecate this field and introduce a repeated message.\n  repeated EnhancementType enhancement_types;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Protocol Buffer Message Structures\nDESCRIPTION: Definition of Person and AddressBook message types with nested PhoneNumber message and PhoneType enum. Includes field definitions with tags and types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/kotlintutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage Person {\n  string name = 1;\n  int32 id = 2;  // Unique ID number for this person.\n  string email = 3;\n\n  enum PhoneType {\n    PHONE_TYPE_UNSPECIFIED = 0;\n    PHONE_TYPE_MOBILE = 1;\n    PHONE_TYPE_HOME = 2;\n    PHONE_TYPE_WORK = 3;\n  }\n\n  message PhoneNumber {\n    string number = 1;\n    PhoneType type = 2;\n  }\n\n  repeated PhoneNumber phones = 4;\n\n  google.protobuf.Timestamp last_updated = 5;\n}\n\n// Our address book file is just one of these.\nmessage AddressBook {\n  repeated Person people = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Protocol Buffers for Go\nDESCRIPTION: Command to run the protocol buffer compiler to generate Go code from the proto definition. Specifies source directory, destination directory, and the proto file path.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nprotoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto\n```\n\n----------------------------------------\n\nTITLE: Any Field Methods in Generated Dart Code\nDESCRIPTION: Outlines the methods available for working with Any fields in the generated Dart code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nT unpackInto<T extends GeneratedMessage>(T instance,\n    {ExtensionRegistry extensionRegistry = ExtensionRegistry.EMPTY});\n\nbool canUnpackInto(GeneratedMessage instance);\n\nstatic Any pack(GeneratedMessage message,\n    {String typeUrlPrefix = 'type.googleapis.com'});\n```\n\n----------------------------------------\n\nTITLE: Message to JSON Conversion Function\nDESCRIPTION: Converts a Protocol Buffer message to JSON format and appends to output string. Uses DescriptorPool from the input message to resolve Any types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nutil::Status MessageToJsonString(\n    const Message& message,\n    std::string* output,\n    const JsonOptions& options)\n```\n\n----------------------------------------\n\nTITLE: Installing Protocol Buffer Compiler Plugin for Go\nDESCRIPTION: Command to install the protoc-gen-go binary using Go 1.16 or higher. This plugin is required for generating Go code from protocol buffer definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n----------------------------------------\n\nTITLE: Creating a Person Instance with Builder Pattern\nDESCRIPTION: Example of how to build a Person message instance using the builder pattern. Demonstrates chaining setter methods and building nested message objects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nPerson john =\n  Person.newBuilder()\n    .setId(1234)\n    .setName(\"John Doe\")\n    .setEmail(\"jdoe@example.com\")\n    .addPhones(\n      Person.PhoneNumber.newBuilder()\n        .setNumber(\"555-4321\")\n        .setType(Person.PhoneType.PHONE_TYPE_HOME)\n        .build())\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Message Field Access Comparison\nDESCRIPTION: Shows how to work with message-typed fields in both APIs, including getting, setting, checking presence, and clearing fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// Getting the value.\nb := m.GetHeadliner()\n\n// Setting the field.\nm.Headliner = &pb.Band{}\n\n// Check for presence.\nif s.Headliner != nil { … }\n\n// Clearing the field.\nm.Headliner = nil\n```\n\nLANGUAGE: go\nCODE:\n```\n// Getting the value.\ns := m.GetHeadliner()\n\n// Setting the field.\nm.SetHeadliner(&pb.Band{})\n\n// Check for presence.\nif m.HasHeadliner() { … }\n\n// Clearing the field\nm.ClearHeadliner()\n```\n\n----------------------------------------\n\nTITLE: Defining Person Message Type in Protocol Buffers\nDESCRIPTION: Example of a simple Protocol Buffer message definition for a Person type with first and last name fields. This demonstrates the basic syntax for defining message structures in proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\npackage google.profile;\nmessage Person {\n  string first_name = 1;\n  string last_name = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations and Using Them in Messages\nDESCRIPTION: Shows how to define an enumeration type 'Corpus' with multiple values and use it as a field type within a message. The first enum value (0) serves as the default value when the field is not set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nenum Corpus {\n  CORPUS_UNSPECIFIED = 0;\n  CORPUS_UNIVERSAL = 1;\n  CORPUS_WEB = 2;\n  CORPUS_IMAGES = 3;\n  CORPUS_LOCAL = 4;\n  CORPUS_NEWS = 5;\n  CORPUS_PRODUCTS = 6;\n  CORPUS_VIDEO = 7;\n}\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 results_per_page = 3;\n  Corpus corpus = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Package-Level Enum in Protocol Buffers\nDESCRIPTION: Example of defining a package-level enum in Protocol Buffers. This shows a 'Genre' enum with various music genre types defined at the package level.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\nenum Genre {\n  GENRE_UNSPECIFIED = 0;\n  GENRE_ROCK = 1;\n  GENRE_INDIE = 2;\n  GENRE_DRUM_AND_BASS = 3;\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Syntax Declaration in Proto3\nDESCRIPTION: Defines the syntax for declaring the Protocol Buffer version in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_9\n\nLANGUAGE: ebnf\nCODE:\n```\nsyntax = \"syntax\" \"=\" (\"'\" \"proto3\" \"'\" | '\"' \"proto3\" '\"') \";\"\n```\n\n----------------------------------------\n\nTITLE: Java Field Presence Handling with Explicit Presence\nDESCRIPTION: Java example showing field handling with explicit presence in Proto3 using Builders, using hasFoo() and clearFoo() methods for proper field presence tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_11\n\nLANGUAGE: java\nCODE:\n```\nMsg.Builder m = GetProto().toBuilder();\nif (m.hasFoo()) {\n  // Clear the field:\n  m.clearFoo()\n} else {\n  // Field is not present, so set it.\n  m.setFoo(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Syntax Declaration in Proto3\nDESCRIPTION: Shows an example of how to declare the Protocol Buffer version in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_10\n\nLANGUAGE: proto3\nCODE:\n```\nsyntax = \"proto3\";\n```\n\n----------------------------------------\n\nTITLE: Deserializing Protocol Buffer Messages with proto.Unmarshal in Go\nDESCRIPTION: Code example demonstrating how to read a serialized protocol buffer from a file and parse it using proto.Unmarshal. The function reads the file content, creates an empty message object, and populates it with the parsed data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Read the existing address book.\nin, err := ioutil.ReadFile(fname)\nif err != nil {\n    log.Fatalln(\"Error reading file:\", err)\n}\nbook := &pb.AddressBook{}\nif err := proto.Unmarshal(in, book); err != nil {\n    log.Fatalln(\"Failed to parse address book:\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Protocol Buffer Messages in Java\nDESCRIPTION: This code demonstrates how to create, populate, and write Protocol Buffer messages to a file in Java. It implements an address book application that reads an existing AddressBook, adds a new Person based on user input, and writes the updated AddressBook back to the file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nimport com.example.tutorial.protos.AddressBook;\nimport com.example.tutorial.protos.Person;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nclass AddPerson {\n  // This function fills in a Person message based on user input.\n  static Person PromptForAddress(BufferedReader stdin,\n                                 PrintStream stdout) throws IOException {\n    Person.Builder person = Person.newBuilder();\n\n    stdout.print(\"Enter person ID: \");\n    person.setId(Integer.valueOf(stdin.readLine()));\n\n    stdout.print(\"Enter name: \");\n    person.setName(stdin.readLine());\n\n    stdout.print(\"Enter email address (blank for none): \");\n    String email = stdin.readLine();\n    if (email.length() > 0) {\n      person.setEmail(email);\n    }\n\n    while (true) {\n      stdout.print(\"Enter a phone number (or leave blank to finish): \");\n      String number = stdin.readLine();\n      if (number.length() == 0) {\n        break;\n      }\n\n      Person.PhoneNumber.Builder phoneNumber =\n        Person.PhoneNumber.newBuilder().setNumber(number);\n\n      stdout.print(\"Is this a mobile, home, or work phone? \");\n      String type = stdin.readLine();\n      if (type.equals(\"mobile\")) {\n        phoneNumber.setType(Person.PhoneType.PHONE_TYPE_MOBILE);\n      } else if (type.equals(\"home\")) {\n        phoneNumber.setType(Person.PhoneType.PHONE_TYPE_HOME);\n      } else if (type.equals(\"work\")) {\n        phoneNumber.setType(Person.PhoneType.PHONE_TYPE_WORK);\n      } else {\n        stdout.println(\"Unknown phone type.  Using default.\");\n      }\n\n      person.addPhones(phoneNumber);\n    }\n\n    return person.build();\n  }\n\n  // Main function:  Reads the entire address book from a file,\n  //   adds one person based on user input, then writes it back out to the same\n  //   file.\n  public static void main(String[] args) throws Exception {\n    if (args.length != 1) {\n      System.err.println(\"Usage:  AddPerson ADDRESS_BOOK_FILE\");\n      System.exit(-1);\n    }\n\n    AddressBook.Builder addressBook = AddressBook.newBuilder();\n\n    // Read the existing address book.\n    try {\n      addressBook.mergeFrom(new FileInputStream(args[0]));\n    } catch (FileNotFoundException e) {\n      System.out.println(args[0] + \": File not found.  Creating a new file.\");\n    }\n\n    // Add an address.\n    addressBook.addPerson(\n      PromptForAddress(new BufferedReader(new InputStreamReader(System.in)),\n                       System.out));\n\n    // Write the new address book back to disk.\n    FileOutputStream output = new FileOutputStream(args[0]);\n    addressBook.build().writeTo(output);\n    output.close();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting API Level in Protocol Buffer File\nDESCRIPTION: Example of how to select the API level (Opaque API in this case) using the editions feature in a .proto file. This allows fine-grained control over which API is used for specific messages or files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nedition = \"2023\";\n\npackage log;\n\nimport \"google/protobuf/go_features.proto\";\noption features.(pb.go).api_level = API_OPAQUE;\n\nmessage LogEntry { … }\n```\n\n----------------------------------------\n\nTITLE: Defining an Unspecified Enum Value in Protocol Buffers\nDESCRIPTION: Illustrates the recommended pattern for including an UNSPECIFIED value as the first entry in an enum definition, using tag 0. This provides a default value and allows for graceful handling of unknown values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/dos-donts.md#2025-04-11_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nenum MyEnum {\n  MY_ENUM_UNSPECIFIED = 0;\n  // Other enum values...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Types in Protocol Buffers\nDESCRIPTION: Demonstrates how to define and use nested message types within a parent message. The example shows a SearchResponse message containing a nested Result message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  message Result {\n    optional string url = 1;\n    optional string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result results = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Map Field in Protocol Buffers\nDESCRIPTION: Example of defining a map field in Protocol Buffers with int32 keys and values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_29\n\nLANGUAGE: proto\nCODE:\n```\nmap<int32, int32> weight = 1;\n```\n\n----------------------------------------\n\nTITLE: Migrating Proto3 to Protobuf Editions Syntax\nDESCRIPTION: This snippet shows how a proto3 file is converted to use Protobuf Editions syntax. It illustrates changes in syntax declaration, field presence, and feature settings to maintain proto3 behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/overview.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\n// Editions version of proto3 file\nedition = \"2023\";\n\npackage com.example;\n\nmessage Player {\n  // fields have explicit presence, so no explicit setting needed\n  string name = 1 [default = \"N/A\"];\n  // to match the proto3 behavior, IMPLICIT is set at the field level\n  int32 id = 2 [features.field_presence = IMPLICIT];\n  // PACKED is the default state, and is provided just for illustration\n  repeated int32 scores = 3 [features.repeated_field_encoding = PACKED];\n\n  enum Handed {\n    HANDED_UNSPECIFIED = 0;\n    HANDED_LEFT = 1;\n    HANDED_RIGHT = 2;\n    HANDED_AMBIDEXTROUS = 3;\n  }\n\n  Handed handed = 4;\n\n  reserved gender;\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Operations in Protocol Buffers\nDESCRIPTION: Methods for working with Protocol Buffer extensions, including managing extension ranges, counting extensions, and looking up extensions by name or number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nextension_range_count() const\nextension_range(int index) const\nIsExtensionNumber(int number) const\nFindExtensionRangeContainingNumber(int number) const\nextension_count() const\nextension(int index) const\nFindExtensionByName(ConstStringParam name) const\nFindExtensionByLowercaseName(ConstStringParam name) const\nFindExtensionByCamelcaseName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining a oneof Field in Protocol Buffers\nDESCRIPTION: Demonstrates how to define a oneof field in a protobuf message. This example shows a oneof named 'foo' with two possible fields: an int32 'a' and a float 'b'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\noneof foo {\n  int32 a = 1;\n  float b = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Person Instance with Protocol Buffers in Go\nDESCRIPTION: Example of how to create an instance of a Person protocol buffer message including nested PhoneNumber objects. This demonstrates the standard Go struct initialization syntax used with generated protocol buffer types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_5\n\nLANGUAGE: go\nCODE:\n```\np := pb.Person{\n    Id:    1234,\n    Name:  \"John Doe\",\n    Email: \"jdoe@example.com\",\n    Phones: []*pb.Person_PhoneNumber{\n        {Number: \"555-4321\", Type: pb.PhoneType_PHONE_TYPE_HOME},\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Field Presence in C++\nDESCRIPTION: Checks if a given non-repeated field is set in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nbool Reflection::HasField(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Java Files Generation in Protocol Buffers\nDESCRIPTION: This option instructs the compiler to generate separate .java files for each top-level message, enumeration, and service declared in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\noption java_multiple_files = true;\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for Python Output\nDESCRIPTION: Example of how to invoke the protoc compiler to generate Python code from .proto files. The command specifies the input directory with --proto_path and output directory with --python_out.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --python_out=build/gen src/foo.proto src/bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: Nested Message Definition\nDESCRIPTION: Example of a nested message declaration in Protocol Buffers syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Oneof Field in Protocol Buffers\nDESCRIPTION: Example of a oneof field definition in Protocol Buffers that can contain a Bar message type among other options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_28\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    Bar bar = 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Protocol Buffer Extension\nDESCRIPTION: Example showing how to define a Protocol Buffer extension that allows kitten videos in a media.UserContent message. Demonstrates importing required proto files and extending an existing message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\n// file kittens/video_ext.proto\n\nimport \"kittens/video.proto\";\nimport \"media/user_content.proto\";\n\npackage kittens;\n\n// This extension allows kitten videos in a media.UserContent message.\nextend media.UserContent {\n  // Video is a message imported from kittens/video.proto\n  repeated Video kitten_videos = 126;\n}\n```\n\n----------------------------------------\n\nTITLE: Field Mask Path Definition in Protocol Buffers\nDESCRIPTION: Example showing how to define field paths in a FieldMask to specify which fields should be included in get operations or modified in update operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\npaths: \"f.a\"\npaths: \"f.b.d\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination with Continuation Tokens in Protocol Buffers\nDESCRIPTION: Example showing good and bad pagination strategies in Protocol Buffers, emphasizing the use of opaque continuation tokens for flexibility and stability in paginated results.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nmessage FooQuery {\n  // Bad: If the data changes between the first query and second, each of\n  // these strategies can cause you to miss results. In an eventually\n  // consistent world (that is, storage backed by Bigtable), it's not uncommon\n  // to have old data appear after the new data. Also, the offset- and\n  // page-based approaches all assume a sort-order, taking away some\n  // flexibility.\n  optional int64 max_timestamp_ms;\n  optional int32 result_offset;\n  optional int32 page_number;\n  optional int32 page_size;\n\n  // Good: You've got flexibility! Return this in a FooQueryResponse and\n  // have clients pass it back on the next query.\n  optional string next_page_token;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Any Type in C++\nDESCRIPTION: Shows how to pack and unpack Any values in C++ using PackFrom() and UnpackTo() methods. Demonstrates type-safe handling of arbitrary message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\n// Storing an arbitrary message type in Any.\nNetworkErrorDetails details = ...;\nErrorStatus status;\nstatus.add_details()->PackFrom(details);\n\n// Reading an arbitrary message from Any.\nErrorStatus status = ...;\nfor (const google::protobuf::Any& detail : status.details()) {\n  if (detail.Is<NetworkErrorDetails>()) {\n    NetworkErrorDetails network_error;\n    detail.UnpackTo(&network_error);\n    ... processing network_error ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Marking a Field as Deprecated in Protocol Buffers\nDESCRIPTION: Demonstrates how to mark a field as deprecated using the deprecated option in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_31\n\nLANGUAGE: proto\nCODE:\n```\nint32 old_field = 6 [deprecated = true];\n```\n\n----------------------------------------\n\nTITLE: Working with Singular Message Fields\nDESCRIPTION: Demonstrates how to work with embedded message fields, showing that you can't directly assign a message object but instead must set fields within it. Includes checking for field presence and clearing message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nfoo.bar = Bar()  # WRONG!\n```\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nassert not foo.HasField(\"bar\")\nfoo.bar.i = 1\nassert foo.HasField(\"bar\")\nassert foo.bar.i == 1\nfoo.ClearField(\"bar\")\nassert not foo.HasField(\"bar\")\nassert foo.bar.i == 0  # Default value\n```\n\nLANGUAGE: python\nCODE:\n```\nfoo.bar.CopyFrom(baz)\n```\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nassert not foo.HasField(\"bar\")\nprint(foo.bar.i)  # Print i's default value\nassert not foo.HasField(\"bar\")\n```\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nassert not foo.HasField(\"bar\")\nfoo.bar.SetInParent()  # Set Foo.bar to a default Bar message\nassert foo.HasField(\"bar\")\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Enum Value Options in Protocol Buffers\nDESCRIPTION: Shows how to define and use custom options for enum values in Protocol Buffers, including the use of the deprecated option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_32\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.EnumValueOptions {\n  optional string string_name = 123456789;\n}\n\nenum Data {\n  DATA_UNSPECIFIED = 0;\n  DATA_SEARCH = 1 [deprecated = true];\n  DATA_DISPLAY = 2 [\n    (string_name) = \"display_value\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reflection to Print Message Fields in C#\nDESCRIPTION: Demonstrates how to use the Protocol Buffers reflection API to enumerate and access fields of any message type. This example prints the field number, name, and value for each field in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic void PrintMessage(IMessage message)\n{\n    var descriptor = message.Descriptor;\n    foreach (var field in descriptor.Fields.InDeclarationOrder())\n    {\n        Console.WriteLine(\n            \"Field {0} ({1}): {2}\",\n            field.FieldNumber,\n            field.Name,\n            field.Accessor.GetValue(message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor Type Enumeration in C++\nDESCRIPTION: Enumeration of field types used in Protocol Buffers, including primitive types like double, float, integers, as well as complex types like strings, messages, and bytes. Each type corresponds to a specific wire format representation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldDescriptor::Type {\n  TYPE_DOUBLE = 1,\n  TYPE_FLOAT = 2,\n  TYPE_INT64 = 3,\n  TYPE_UINT64 = 4,\n  TYPE_INT32 = 5,\n  TYPE_FIXED64 = 6,\n  TYPE_FIXED32 = 7,\n  TYPE_BOOL = 8,\n  TYPE_STRING = 9,\n  TYPE_GROUP = 10,\n  TYPE_MESSAGE = 11,\n  TYPE_BYTES = 12,\n  TYPE_UINT32 = 13,\n  TYPE_ENUM = 14,\n  TYPE_SFIXED32 = 15,\n  TYPE_SFIXED64 = 16,\n  TYPE_SINT32 = 17,\n  TYPE_SINT64 = 18,\n  MAX_TYPE = 18\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Edition Statement in Protocol Buffers\nDESCRIPTION: Specifies the syntax for the edition statement which replaces the legacy 'syntax' keyword and defines the Protocol Buffers edition being used.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_9\n\nLANGUAGE: EBNF\nCODE:\n```\nedition = \"edition\" \"=\" [ ( \"'\" decimalLit \"'\" ) | ( '\"' decimalLit '\"' ) ] \";\"\n```\n\n----------------------------------------\n\nTITLE: Implementing RepeatedField Modification Methods in C++\nDESCRIPTION: Defines methods for adding, removing, and extracting elements from the RepeatedField, including single element and range operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid Add(const Element & value);\nElement * Add();\ntemplate <typename Iter>\nvoid Add(Iter begin, Iter end);\nvoid RemoveLast();\nvoid ExtractSubrange(int start, int num, Element * elements);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proper Field Documentation in Protocol Buffers\nDESCRIPTION: Example showing good versus bad documentation practices for Protocol Buffer fields. Good documentation explains constraints, expectations, and interpretation of each field concisely and precisely.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\n// Bad: Option to enable Foo\n// Good: Configuration controlling the behavior of the Foo feature.\nmessage FeatureFooConfig {\n  // Bad: Sets whether the feature is enabled\n  // Good: Required field indicating whether the Foo feature\n  // is enabled for account_id.  Must be false if account_id's\n  // FOO_OPTIN Gaia bit is not set.\n  optional bool enabled;\n}\n\n// Bad: Foo object.\n// Good: Client-facing representation of a Foo (what/foo) exposed in APIs.\nmessage Foo {\n  // Bad: Title of the foo.\n  // Good: Indicates the user-supplied title of this Foo, with no\n  // normalization or escaping.\n  // An example title: \"Picture of my cat in a box <3 <3 !!!\"\n  optional string title [(max_length) = 512];\n}\n\n// Bad: Foo config.\n// Less-Bad: If the most useful comment is re-stating the name, better to omit\n// the comment.\nFooConfig foo_config = 3;\n```\n\n----------------------------------------\n\nTITLE: Basic ZeroCopyInputStream Usage Example in C++\nDESCRIPTION: Example demonstrating how to read a file using ZeroCopyInputStream and print its contents to stdout. The example shows how to obtain buffer pointers directly from the stream, eliminating unnecessary copying.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// Read in a file and print its contents to stdout.\nint fd = open(\"myfile\", O_RDONLY);\nZeroCopyInputStream* input = new FileInputStream(fd);\n\nconst void* buffer;\nint size;\nwhile (input->Next(&buffer, &size)) {\n  cout.write(buffer, size);\n}\n\ndelete input;\nclose(fd);\n```\n\n----------------------------------------\n\nTITLE: JSON Representation of Any Type with Embedded Person Message\nDESCRIPTION: Example of how the Any type is represented in JSON when containing a Person message. Shows the @type field that specifies the type URL and the serialized message content.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"@type\": \"type.googleapis.com/google.profile.Person\",\n  \"firstName\": <string>,\n  \"lastName\": <string>\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Protocol Message to Output Stream in C++\nDESCRIPTION: Outputs a textual representation of the given message to the specified output stream. Returns false if printing fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool TextFormat::Print(\n        const Message& message,\n        io::ZeroCopyOutputStream* output)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Syntax Statement Definition\nDESCRIPTION: Defines the syntax statement used to declare the Protocol Buffer version, specifically for proto2.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_9\n\nLANGUAGE: ebnf\nCODE:\n```\nsyntax = \"syntax\" \"=\" (\"'\" \"proto2\" \"'\" | '\"' \"proto2\" '\"') \";\"\n```\n\n----------------------------------------\n\nTITLE: Converting Timestamp to/from JSON String in Python\nDESCRIPTION: Example of using ToJsonString() and FromJsonString() methods to convert between Timestamp messages and RFC 3339 date string format (JSON string).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntimestamp_message.FromJsonString(\"1970-01-01T00:00:00Z\")\nassert timestamp_message.ToJsonString() == \"1970-01-01T00:00:00Z\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Proto2 Message in Protocol Buffers\nDESCRIPTION: Example of a proto2 syntax definition for a Player message, showcasing optional and required fields, repeated fields, and enum definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-06-29.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\n// proto2 file\nsyntax = \"proto2\";\n\nmessage Player {\n  // in proto2, optional fields have explicit presence\n  optional string name = 1;\n  // proto2 still supports the problematic \"required\" field rule\n  required int32 id = 2;\n  // in proto2 this is not packed by default\n  repeated int32 scores = 3;\n\n  enum Handed {\n    HANDED_UNSPECIFIED = 0,\n    HANDED_LEFT = 1,\n    HANDED_RIGHT = 2,\n    HANDED_AMBIDEXTROUS = 3,\n  }\n\n  // in proto2 enums are closed\n  optional Handed handed = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Normal Field Examples in Protocol Buffers\nDESCRIPTION: Demonstrates the definition of normal fields in Protocol Buffers, including a nested message field and a repeated field with the 'packed' option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_18\n\nLANGUAGE: proto\nCODE:\n```\nfoo.bar nested_message = 2;\nrepeated int32 samples = 4 [packed=true];\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Fields in Protocol Buffers\nDESCRIPTION: Example showing how to define an extension field for a message type with an extension range. This allows adding fields to existing messages without modifying their original definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nextend Foo {\n  optional int32 bar = 123;\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Timestamp from Duration Addition\nDESCRIPTION: Shows how to calculate a new Timestamp by adding a Duration to an existing Timestamp, handling nanosecond overflow and underflow cases.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nTimestamp start = ...;\nDuration duration = ...;\nTimestamp end = ...;\n\nend.seconds = start.seconds + duration.seconds;\nend.nanos = start.nanos + duration.nanos;\n\nif (end.nanos < 0) {\n  end.seconds -= 1;\n  end.nanos += 1000000000;\n} else if (end.nanos >= 1000000000) {\n  end.seconds += 1;\n  end.nanos -= 1000000000;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Shows how to define a oneof field in Protocol Buffers to handle mutually exclusive fields. Demonstrates basic oneof syntax and field definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\nmessage SampleMessage {\n  oneof test_oneof {\n    string name = 4;\n    SubMessage sub_message = 9;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Object JSON Representation\nDESCRIPTION: Shows how Protocol Buffer messages are encoded as JSON objects with field names mapped to lowerCamelCase.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/json.md#2025-04-11_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\"fooBar\": v, \"g\": null, ...}\n```\n\n----------------------------------------\n\nTITLE: Setting Lite Runtime Optimization in Protocol Buffer\nDESCRIPTION: Option to optimize the generated C++ code for lite runtime, which reduces dependencies but limits available features.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = LITE_RUNTIME;\n```\n\n----------------------------------------\n\nTITLE: Defining Proto File Structure in Protocol Buffers\nDESCRIPTION: Specifies the overall structure of a .proto file in Protocol Buffers, including imports, packages, options, and top-level definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_35\n\nLANGUAGE: EBNF\nCODE:\n```\nproto = [syntax] { import | package | option | topLevelDef | emptyStatement }\ntopLevelDef = message | enum | extend | service\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Message Types in Protocol Buffers\nDESCRIPTION: Shows how to define multiple related message types (SearchRequest and SearchResponse) in a single .proto file. This approach can be useful for organizing related messages but may lead to dependency bloat if overused.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 results_per_page = 3;\n}\n\nmessage SearchResponse {\n ...\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Message Declaration in Protocol Buffers\nDESCRIPTION: Example of a nested message declaration in protobuf where Bar is defined inside Foo. In Python, this generates Bar as a static member of the Foo class, accessible as Foo.Bar.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {}\n}\n```\n\n----------------------------------------\n\nTITLE: Service Example in Protocol Buffers\nDESCRIPTION: Demonstrates the definition of a service in Protocol Buffers with an RPC method that accepts a request message and returns a response message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_34\n\nLANGUAGE: proto\nCODE:\n```\nservice SearchService {\n  rpc Search (SearchRequest) returns (SearchResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations in Protocol Buffers\nDESCRIPTION: Example of defining an enumeration within a message in Protocol Buffers. This shows a 'Kind' enum inside a 'Venue' message with various venue types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nmessage Venue {\n  enum Kind {\n    KIND_UNSPECIFIED = 0;\n    KIND_CONCERT_HALL = 1;\n    KIND_STADIUM = 2;\n    KIND_BAR = 3;\n    KIND_OPEN_AIR_FESTIVAL = 4;\n  }\n  Kind kind = 1;\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Abstract Method for Service Interface in Java\nDESCRIPTION: The protocol buffer compiler generates an abstract method for each service method defined in the service definition. This shows the generated method signature for the 'Bar' RPC method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_35\n\nLANGUAGE: java\nCODE:\n```\nabstract void bar(RpcController controller, FooRequest request,\n                  RpcCallback<FooResponse> done);\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Field JavaScript Type Options Enumeration\nDESCRIPTION: Specifies JavaScript type options for protocol buffer fields, defining how fields should be represented in JavaScript.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_36\n\nLANGUAGE: protobuf\nCODE:\n```\nenum protobuf::FieldOptions_JSType {\n  FieldOptions_JSType_JS_NORMAL = 0,\n  FieldOptions_JSType_JS_STRING = 1,\n  FieldOptions_JSType_JS_NUMBER = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Protocol Buffer Message Manipulation in Python\nDESCRIPTION: Example showing how to create and populate a Person protocol buffer message object with basic field assignments and nested message handling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/pythontutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport addressbook_pb2\nperson = addressbook_pb2.Person()\nperson.id = 1234\nperson.name = \"John Doe\"\nperson.email = \"jdoe@example.com\"\nphone = person.phones.add()\nphone.number = \"555-4321\"\nphone.type = addressbook_pb2.Person.PHONE_TYPE_HOME\n```\n\n----------------------------------------\n\nTITLE: Defining a Protocol Buffer Service\nDESCRIPTION: Shows how to define a service with RPC methods in Protocol Buffers. This definition will be used to generate C++ service interface classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_47\n\nLANGUAGE: proto\nCODE:\n```\nservice Foo {\n  rpc Bar(FooRequest) returns(FooResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Proto Rules from Protocol Buffers Project in Bazel\nDESCRIPTION: This code snippet demonstrates how to load proto rules from the Protocol Buffers project repository in Bazel build files. It includes load statements for proto_library, cc_proto_library, java_proto_library, java_lite_proto_library, and py_proto_library rules. These load statements are required for Protobuf v29.0 or higher and will be necessary after the release of Bazel 8.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v29.md#2025-04-11_snippet_0\n\nLANGUAGE: bazel\nCODE:\n```\nload(\"@protobuf//bazel:proto_library.bzl\", \"proto_library\")\n\nload(\"@protobuf//bazel:cc_proto_library.bzl\", \"cc_proto_library\")\nload(\"@protobuf//bazel:java_proto_library.bzl\", \"java_proto_library\")\nload(\"@protobuf//bazel:java_lite_proto_library.bzl\", \"java_lite_proto_library\")\nload(\"@protobuf//bazel:py_proto_library.bzl\", \"py_proto_library\")\n```\n\n----------------------------------------\n\nTITLE: Clearing Oneof Field in C++\nDESCRIPTION: Clears the currently set field in a oneof.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::ClearOneof(Message* message, const OneofDescriptor* oneof_descriptor) const\n```\n\n----------------------------------------\n\nTITLE: Getting containing message type for EnumDescriptor in C++\nDESCRIPTION: Returns the message type containing this enum type if nested in a message type, otherwise returns nullptr.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_57\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor * \n    EnumDescriptor::containing_type() const\n```\n\n----------------------------------------\n\nTITLE: Using Protocol Buffer Extensions in Objective-C\nDESCRIPTION: Example of getting and setting Protocol Buffer extension fields in Objective-C, including single and repeated field usage and clearing extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_33\n\nLANGUAGE: objc\nCODE:\n```\nFoo *fooMsg = [[Foo alloc] init];\n\n// Set the single field extensions\n[fooMsg setExtension:[Test2Root foo] value:@5];\nNSAssert([fooMsg hasExtension:[Test2Root foo]]);\nNSAssert([[fooMsg getExtension:[Test2Root foo]] intValue] == 5);\n\n// Add two things to the repeated extension:\n[fooMsg addExtension:[Test2Root repeatedFoo] value:@1];\n[fooMsg addExtension:[Test2Root repeatedFoo] value:@2];\nNSAssert([fooMsg hasExtension:[Test2Root repeatedFoo]]);\nNSAssert([[fooMsg getExtension:[Test2Root repeatedFoo]] count] == 2);\n\n// Clearing\n[fooMsg clearExtension:[Test2Root foo]];\n[fooMsg clearExtension:[Test2Root repeatedFoo]];\nNSAssert(![fooMsg hasExtension:[Test2Root foo]]);\nNSAssert(![fooMsg hasExtension:[Test2Root repeatedFoo]]);\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for Dart\nDESCRIPTION: Shows how to use the protoc compiler with the Dart plugin to generate Dart code from .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --dart_out=build/gen src/foo.proto src/bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: Enum Definition in Protocol Buffers\nDESCRIPTION: Example enum type definition in Protocol Buffers with multiple variants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nenum Bar {\n  BAR_UNSPECIFIED = 0;\n  BAR_VALUE = 1;\n  BAR_OTHER_VALUE = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Interface in Proto\nDESCRIPTION: Example of defining an RPC service interface in protocol buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_48\n\nLANGUAGE: proto\nCODE:\n```\nservice Foo {\n  rpc Bar(FooRequest) returns(FooResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: Example showing how to declare a map field with integer keys and values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\nmap<int32, int32> weight = 1;\n```\n\n----------------------------------------\n\nTITLE: C++ Map Template Interface for Protocol Buffers\nDESCRIPTION: Definition of the google::protobuf::Map template class that provides a map-like interface for Protocol Buffer map fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_30\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename Key, typename T> {\nclass Map {\n  // Member types\n  typedef Key key_type;\n  typedef T mapped_type;\n  typedef MapPair< Key, T > value_type;\n\n  // Iterators\n  iterator begin();\n  const_iterator begin() const;\n  const_iterator cbegin() const;\n  iterator end();\n  const_iterator end() const;\n  const_iterator cend() const;\n  // Capacity\n  int size() const;\n  bool empty() const;\n\n  // Element access\n  T& operator[](const Key& key);\n  const T& at(const Key& key) const;\n  T& at(const Key& key);\n\n  // Lookup\n  bool contains(const Key& key) const;\n  int count(const Key& key) const;\n  const_iterator find(const Key& key) const;\n  iterator find(const Key& key);\n\n  // Modifiers\n  pair<iterator, bool> insert(const value_type& value);\n  template<class InputIt>\n  void insert(InputIt first, InputIt last);\n  size_type erase(const Key& Key);\n  iterator erase(const_iterator pos);\n  iterator erase(const_iterator first, const_iterator last);\n  void clear();\n\n  // Copy\n  Map(const Map& other);\n  Map& operator=(const Map& other);\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Protocol Buffer Messages to a File in C++\nDESCRIPTION: This C++ program demonstrates how to write Protocol Buffer messages to a file. It reads an existing AddressBook from a file, prompts the user to add a new Person entry, and writes the updated AddressBook back to the file. The code showcases message creation, modification, and serialization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/cpptutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <fstream>\n#include <string>\n#include \"addressbook.pb.h\"\nusing namespace std;\n\n// This function fills in a Person message based on user input.\nvoid PromptForAddress(tutorial::Person* person) {\n  cout << \"Enter person ID number: \";\n  int id;\n  cin >> id;\n  person->set_id(id);\n  cin.ignore(256, '\\n');\n\n  cout << \"Enter name: \";\n  getline(cin, *person->mutable_name());\n\n  cout << \"Enter email address (blank for none): \";\n  string email;\n  getline(cin, email);\n  if (!email.empty()) {\n    person->set_email(email);\n  }\n\n  while (true) {\n    cout << \"Enter a phone number (or leave blank to finish): \";\n    string number;\n    getline(cin, number);\n    if (number.empty()) {\n      break;\n    }\n\n    tutorial::Person::PhoneNumber* phone_number = person->add_phones();\n    phone_number->set_number(number);\n\n    cout << \"Is this a mobile, home, or work phone? \";\n    string type;\n    getline(cin, type);\n    if (type == \"mobile\") {\n      phone_number->set_type(tutorial::Person::PHONE_TYPE_MOBILE);\n    } else if (type == \"home\") {\n      phone_number->set_type(tutorial::Person::PHONE_TYPE_HOME);\n    } else if (type == \"work\") {\n      phone_number->set_type(tutorial::Person::PHONE_TYPE_WORK);\n    } else {\n      cout << \"Unknown phone type.  Using default.\" << endl;\n    }\n  }\n}\n\n// Main function:  Reads the entire address book from a file,\n//   adds one person based on user input, then writes it back out to the same\n//   file.\nint main(int argc, char* argv[]) {\n  // Verify that the version of the library that we linked against is\n  // compatible with the version of the headers we compiled against.\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n\n  if (argc != 2) {\n    cerr << \"Usage:  \" << argv[0] << \" ADDRESS_BOOK_FILE\" << endl;\n    return -1;\n  }\n\n  tutorial::AddressBook address_book;\n\n  {\n    // Read the existing address book.\n    fstream input(argv[1], ios::in | ios::binary);\n    if (!input) {\n      cout << argv[1] << \": File not found.  Creating a new file.\" << endl;\n    } else if (!address_book.ParseFromIstream(&input)) {\n      cerr << \"Failed to parse address book.\" << endl;\n      return -1;\n    }\n  }\n\n  // Add an address.\n  PromptForAddress(address_book.add_people());\n\n  {\n    // Write the new address book back to disk.\n    fstream output(argv[1], ios::out | ios::trunc | ios::binary);\n    if (!address_book.SerializeToOstream(&output)) {\n      cerr << \"Failed to write address book.\" << endl;\n      return -1;\n    }\n  }\n\n  // Optional:  Delete all global objects allocated by libprotobuf.\n  google::protobuf::ShutdownProtobufLibrary();\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Active Oneof Field in C++\nDESCRIPTION: Returns the FieldDescriptor of the currently set field in a oneof, or nullptr if none is set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor* Reflection::GetOneofFieldDescriptor(const Message& message, const OneofDescriptor* oneof_descriptor) const\n```\n\n----------------------------------------\n\nTITLE: Example of Message Definition in Proto3\nDESCRIPTION: Shows an example of how to define a message with options, nested messages, and map fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_29\n\nLANGUAGE: proto3\nCODE:\n```\nmessage Outer {\n  option (my_option).a = true;\n  message Inner {   // Level 2\n    int64 ival = 1;\n  }\n  map<int32, string> my_map = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Optional and Required Message Fields\nDESCRIPTION: Field definitions showing optional and required message fields in both proto2 and proto3 syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\n//proto2\noptional Bar bar = 1;\nrequired Bar bar = 1;\n\n//proto3\nBar bar = 1;\n```\n\n----------------------------------------\n\nTITLE: Checking Message Type in Protobuf Any Object using Kotlin\nDESCRIPTION: This extension function checks if a com.google.protobuf.Any object contains a message of type T. It returns a Boolean value indicating whether the Any object contains the specified message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/is-a.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\ninline fun <T : Message> Any.isA(): Boolean\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define repeated fields in Protocol Buffers. The compiler generates accessor methods using slice types for these fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_10\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Concert {\n  repeated Band support_acts = 1;\n}\n```\n\nLANGUAGE: go\nCODE:\n```\ntype Concert struct { ... }\n\nfunc (m *Concert) GetSupportActs() []*Band { ... }\nfunc (m *Concert) SetSupportActs(v []*Band) { ... }\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Syntax Definition\nDESCRIPTION: Formal definition of Protocol Buffer file structure, showing the composition of proto files from various elements including imports, packages, options, and top-level definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_38\n\nLANGUAGE: text\nCODE:\n```\nproto = [syntax] { import | package | option | topLevelDef | emptyStatement }\ntopLevelDef = message | enum | extend | service\n```\n\n----------------------------------------\n\nTITLE: Defining File Options Optimization Mode Enum in Protocol Buffers\nDESCRIPTION: Declaration of the FileOptions_OptimizeMode enum that specifies optimization strategies for Protocol Buffer message processing. This controls how the Protocol Buffer compiler optimizes generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nenum FileOptions_OptimizeMode\n```\n\n----------------------------------------\n\nTITLE: Reserving Field Numbers in Protocol Buffers\nDESCRIPTION: This snippet shows how to reserve field numbers in a Protocol Buffer message definition. It demonstrates reserving individual numbers and a range of numbers to prevent their reuse in future updates.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n}\n```\n\n----------------------------------------\n\nTITLE: Size-Limited Task Processing with proto.Size in Go\nDESCRIPTION: Demonstrates using proto.Size to implement size-based filtering of work tasks to protect downstream systems from oversized messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/size.md#2025-04-11_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) {\n  task := produceWorkTask(value)\n  if proto.Size(task) > 500 * 1024 * 1024 {\n    // Skip every work task over 500 MB to not overwhelm\n    // the brittle downstream system.\n    return\n  }\n  emit(task)\n}\n```\n\n----------------------------------------\n\nTITLE: Python Field Presence Handling with Explicit Presence\nDESCRIPTION: Python example showing field handling with explicit presence in Proto3, using HasField() and ClearField() methods for proper field presence tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nm = example.Msg()\nif m.HasField('foo'):\n  # Clear the field:\n  m.ClearField('foo')\nelse:\n  # Field is not present, so set it.\n  m.foo = 1\n```\n\n----------------------------------------\n\nTITLE: Removing Last Element of Repeated Field in C++\nDESCRIPTION: Removes the last element of a repeated field in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::RemoveLast(Message* message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Structure in Protocol Buffers\nDESCRIPTION: A Protocol Buffer definition showing nested message types (Foo inside Bar inside Baz) that demonstrates the hierarchical relationship between messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  optional int32 val = 1;\n  // some other fields.\n}\n\nmessage Bar {\n  optional Foo foo = 1;\n  // some other fields.\n}\n\nmessage Baz {\n  optional Bar bar = 1;\n  // some other fields.\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Current Time in Timestamp Message\nDESCRIPTION: Shows how to use the GetCurrentTime() method to set a Timestamp message to the current time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntimestamp_message.GetCurrentTime()\n```\n\n----------------------------------------\n\nTITLE: Migrating Proto2 to Protobuf Editions Syntax\nDESCRIPTION: This snippet demonstrates how a proto2 file is converted to use Protobuf Editions syntax. It shows changes in syntax declaration, field presence, enum behavior, and feature settings.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/overview.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\n// Edition version of proto2 file\nedition = \"2023\";\n\npackage com.example;\n\noption features.utf8_validation = NONE;\n\nmessage Player {\n  // fields have explicit presence, so no explicit setting needed\n  string name = 1 [default = \"N/A\"];\n  // to match the proto2 behavior, LEGACY_REQUIRED is set at the field level\n  int32 id = 2 [features.field_presence = LEGACY_REQUIRED];\n  // to match the proto2 behavior, EXPANDED is set at the field level\n  repeated int32 scores = 3 [features.repeated_field_encoding = EXPANDED];\n\n  enum Handed {\n    // this overrides the default edition 2023 behavior, which is OPEN\n    option features.enum_type = CLOSED;\n    HANDED_UNSPECIFIED = 0;\n    HANDED_LEFT = 1;\n    HANDED_RIGHT = 2;\n    HANDED_AMBIDEXTROUS = 3;\n  }\n\n  Handed handed = 4;\n\n  reserved gender;\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Field Type and Label Definition\nDESCRIPTION: Defines the possible field labels (required, optional, repeated) and field types in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_16\n\nLANGUAGE: ebnf\nCODE:\n```\nlabel = \"required\" | \"optional\" | \"repeated\"\ntype = \"double\" | \"float\" | \"int32\" | \"int64\" | \"uint32\" | \"uint64\"\n      | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\"\n      | \"bool\" | \"string\" | \"bytes\" | messageType | enumType\nfieldNumber = intLit;\n```\n\n----------------------------------------\n\nTITLE: HasField and ClearField with Oneof in Protocol Buffers (Python)\nDESCRIPTION: Demonstrates that HasField and ClearField methods work with oneof names in addition to field names. ClearField on a oneof clears the currently set field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nassert not message.HasField(\"test_oneof\")\nmessage.name = \"Bender\"\nassert message.HasField(\"test_oneof\")\nmessage.serial_number = 2716057\nassert message.HasField(\"test_oneof\")\nmessage.ClearField(\"test_oneof\")\nassert not message.HasField(\"test_oneof\")\nassert not message.HasField(\"serial_number\")\n```\n\n----------------------------------------\n\nTITLE: Example of Import Statement in Proto3\nDESCRIPTION: Shows an example of how to import another .proto file with the 'public' modifier.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_12\n\nLANGUAGE: proto3\nCODE:\n```\nimport public \"other.proto\";\n```\n\n----------------------------------------\n\nTITLE: Using Reserved Values in Protocol Buffer Enums\nDESCRIPTION: This example demonstrates how to use the reserved keyword to prevent future users from reusing specific numeric values or names in enum definitions. This helps maintain compatibility when updating proto definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  reserved 2, 15, 9 to 11, 40 to max;\n  reserved \"FOO\", \"BAR\";\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Definitions from Other Proto Files\nDESCRIPTION: This example shows the syntax for importing definitions from other .proto files to use them in your current file. The import statement should be placed at the top of the file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nimport \"myproject/other_protos.proto\";\n```\n\n----------------------------------------\n\nTITLE: Checking Oneof Presence in C++\nDESCRIPTION: Checks if a oneof field is set in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nbool Reflection::HasOneof(const Message& message, const OneofDescriptor* oneof_descriptor) const\n```\n\n----------------------------------------\n\nTITLE: Manipulating Repeated Scalar Fields\nDESCRIPTION: Shows how to work with repeated scalar fields, treating them like Python sequences. Demonstrates operations like append, extend, slice assignment, indexing, iteration, and clearing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nfoo.nums.append(15)        # Appends one value\nfoo.nums.extend([32, 47])  # Appends an entire list\n\nassert len(foo.nums) == 3\nassert foo.nums[0] == 15\nassert foo.nums[1] == 32\nassert foo.nums == [15, 32, 47]\n\nfoo.nums[:] = [33, 48]     # Assigns an entire list\nassert foo.nums == [33, 48]\n\nfoo.nums[1] = 56    # Reassigns a value\nassert foo.nums[1] == 56\nfor i in foo.nums:  # Loops and print\n  print(i)\ndel foo.nums[:]     # Clears list (works just like in a Python list)\n```\n\n----------------------------------------\n\nTITLE: Proto Field Definition with Singular Scalar Fields (proto3)\nDESCRIPTION: Example showing how regular and optional int32 fields are defined in proto3. Regular fields become value types in Go while optional fields become pointer types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nint32 birth_year = 1;\noptional int32 first_active_year = 2;\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Service Interface in Protocol Buffers\nDESCRIPTION: Demonstrates how to define an RPC service interface in a Protocol Buffers file that will generate service interface code and stubs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_39\n\nLANGUAGE: proto\nCODE:\n```\nservice SearchService {\n  rpc Search(SearchRequest) returns (SearchResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Message Declaration in Protocol Buffer\nDESCRIPTION: Demonstrates how to declare a nested message within another message in protocol buffer syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Foo {\\n  message Bar {\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Container Message with Extension Declarations in Protocol Buffers\nDESCRIPTION: This example demonstrates how to define a container message with both legacy and current extension ranges, including an extension declaration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nmessage Container {\n  // Legacy range that was using an unverified allocation scheme\n  extensions 1000 to 524999999;\n  // Current range that uses extension declarations. (highest extension range)\n  extensions 525000000 to max  [\n    declaration = {\n      number: 525000001,\n      full_name: \".bar.baz_ext\",\n      type: \".bar.Baz\"\n    }\n    // 525,000,002 is the lowest field number above all other declarations\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python Nested Message Class __qualname__ Change\nDESCRIPTION: This code snippet illustrates the change in behavior for the __qualname__ attribute of nested message classes in Python. After the v30 update, __qualname__ will include the outer message name, providing more context about the class hierarchy.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-11-07.md#2025-04-11_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmessage Foo {\n  message Bar {\n    bool bool_field = 1;\n  }\n}\nnested = test_pb2.Foo.Bar()\nself.assertEqual('Bar', nested.__class__.__name__)\nself.assertEqual('Foo.Bar', nested.__class__.__qualname__) # It was 'Bar' before\n```\n\n----------------------------------------\n\nTITLE: Merging Protocol Buffer from CodedInputStream - C++\nDESCRIPTION: Reads and merges protocol buffer data from a CodedInputStream into the message. Singular fields are overwritten and repeated fields are appended to existing ones.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::MergeFromCodedStream(io::CodedInputStream* input)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Class on Arena in C++\nDESCRIPTION: This example shows how to create an instance of a custom C++ class on the arena using the Arena::Create method. It demonstrates passing constructor arguments to the created object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nclass MyCustomClass {\n    MyCustomClass(int arg1, int arg2);\n    // ...\n};\n\nvoid func() {\n    // ...\n    google::protobuf::Arena arena;\n    MyCustomClass* c = google::protobuf::Arena::Create<MyCustomClass>(&arena, constructor_arg1, constructor_arg2);\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Explicit Field Presence in JavaScript\nDESCRIPTION: This snippet shows how to handle explicit field presence in JavaScript using Protocol Buffers. It uses the hasFoo() method to check if the field is present, and then either clears it or sets it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nvar m = new Msg();\nif (m.hasFoo()) {\n  // Clear the field:\n  m.clearFoo()\n} else {\n  // Field is not present, so set it.\n  m.setFoo(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Bytes with Aliasing in EpsCopyOutputStream in C++\nDESCRIPTION: Method to write potentially aliased bytes to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_45\n\nLANGUAGE: C++\nCODE:\n```\nuint8* WriteBytesMaybeAliased(uint32 num, const std::string& s, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Defining Field Types in Proto3\nDESCRIPTION: Defines the possible field types in Protocol Buffers, including primitive types, message types, and enum types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_17\n\nLANGUAGE: ebnf\nCODE:\n```\ntype = \"double\" | \"float\" | \"int32\" | \"int64\" | \"uint32\" | \"uint64\"\n      | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\"\n      | \"bool\" | \"string\" | \"bytes\" | messageType | enumType\nfieldNumber = intLit;\n```\n\n----------------------------------------\n\nTITLE: Reserving Field Names and Numbers in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to reserve field names and numbers in a Protocol Buffer message definition. It shows the syntax for reserving individual field numbers, ranges of numbers, and specific field names to prevent their reuse and potential conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n  reserved foo, bar;\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Fields in Protocol Buffers C++\nDESCRIPTION: Shows how to list all fields of a message that are currently set, excluding unknown fields but including known extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_54\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::ListFields(\n    const Message& message,\n    std::vector< const FieldDescriptor* >* output) const\n```\n\n----------------------------------------\n\nTITLE: Map Field Example in Protocol Buffers\nDESCRIPTION: Demonstrates the definition of a map field in Protocol Buffers with string keys and Project message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_22\n\nLANGUAGE: proto\nCODE:\n```\nmap<string, Project> projects = 3;\n```\n\n----------------------------------------\n\nTITLE: Using get_or_create() with Protocol Buffer Maps (Python)\nDESCRIPTION: Demonstrates the get_or_create() method for map fields, which makes submessage creation more explicit than direct key access.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# Equivalent to:\n#   m.message_map[10]\n# but more explicit that the statement might be creating a new\n# empty message in the map.\nm.message_map.get_or_create(10)\n```\n\n----------------------------------------\n\nTITLE: Defining Constants in Proto3\nDESCRIPTION: Specifies the syntax for constant values in Protocol Buffers, including identifiers, numeric literals, string literals, boolean literals, and message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\nconstant = fullIdent | ( [ \"-\" | \"+\" ] intLit ) | ( [ \"-\" | \"+\" ] floatLit ) |\n                strLit | boolLit | MessageValue\n```\n\n----------------------------------------\n\nTITLE: Java Field Presence Handling with Implicit Presence\nDESCRIPTION: Java example demonstrating field handling with implicit presence in Proto3 using Builders, where default values are used to check and clear fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_10\n\nLANGUAGE: java\nCODE:\n```\nMsg.Builder m = GetProto().toBuilder();\nif (m.getFoo() != 0) {\n  // \"Clear\" the field:\n  m.setFoo(0);\n} else {\n  // Default value: field may not have been present.\n  m.setFoo(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Field Definitions\nDESCRIPTION: Examples showing how to define extension fields that match the declarations in the previous example. These definitions must match the number, type, and full name specified in the declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/extension_declarations.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\npackage my.package;\nextend Foo {\n  repeated logs.proto.ValidationAnnotations event_annotations = 4;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.package;\nextend Foo {\n  optional int32 bar = 999;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Floating Point Field Values in C++\nDESCRIPTION: Methods for getting float and double field values from a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\nfloat GetFloat(const Message& message, const FieldDescriptor* field) const\ndouble GetDouble(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional and Required Fields in Proto2\nDESCRIPTION: Protocol Buffer field definitions showing the syntax for optional and required fields in proto2, which generate accessor methods for checking presence, getting values, setting values, and clearing fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 foo = 1;\nrequired int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Protocol Buffer Message in Proto\nDESCRIPTION: Demonstrates a basic message declaration in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Example Protocol Buffer Text Format Representation\nDESCRIPTION: An example showing how Protocol Buffer data can be represented in text format, with labeled fields and nested messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_0\n\nLANGUAGE: textproto\nCODE:\n```\nconvolution_benchmark {\n  label: \"NHWC_128x20x20x56x160\"\n  input {\n    dimension: [128, 56, 20, 20]\n    data_type: DATA_HALF\n    format: TENSOR_NHWC\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Message in Protocol Buffers\nDESCRIPTION: Shows the proper TitleCase naming convention for message definitions in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/style.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage SongRequest {\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Map Field in Proto3\nDESCRIPTION: Shows an example of how to define a map field in a message, mapping string keys to Project values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_23\n\nLANGUAGE: proto3\nCODE:\n```\nmap<string, Project> projects = 3;\n```\n\n----------------------------------------\n\nTITLE: Original Ruby DSL Code Generation\nDESCRIPTION: Previous implementation of Ruby code generator using DSL format to define message structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-20.md#2025-04-11_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: protoc_explorer/main.proto\n\nrequire 'google/protobuf'\n\nGoogle::Protobuf::DescriptorPool.generated_pool.build do\n  add_file(\"test.proto\", :syntax => :proto3) do\n    add_message \"pkg.TestMessage\" do\n      proto3_optional :i32, :int32, 1\n      proto3_optional :msg, :message, 2, \"pkg.TestMessage\"\n    end\n  end\nend\n\nmodule Pkg\n  TestMessage = ::Google::Protobuf::DescriptorPool.generated_pool.lookup(\"pkg.TestMessage\").msgclass\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Total Bytes Limit in Protocol Buffers\nDESCRIPTION: Sets the maximum number of bytes that CodedInputStream will read before refusing to continue. Default limit is INT_MAX (~2GB), and shorter limits are recommended for servers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_33\n\nLANGUAGE: C++\nCODE:\n```\nvoid CodedInputStream::SetTotalBytesLimit(int total_bytes_limit)\n```\n\n----------------------------------------\n\nTITLE: Defining Service in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define a service in Protocol Buffers. It shows a simple 'Foo' service with a 'Bar' RPC method that takes a FooRequest and returns a FooResponse.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nservice Foo {\n  rpc Bar(FooRequest) returns(FooResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Types for Field Mask Example in Protocol Buffers\nDESCRIPTION: This snippet defines Protocol Buffer message types 'Profile' and 'User' to demonstrate field mask usage in subsequent examples.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\nmessage Profile {\n  User user = 1;\n  Photo photo = 2;\n}\nmessage User {\n  string display_name = 1;\n  string address = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional I/O Stream Example in C++\nDESCRIPTION: Example of data reading using traditional I/O streams, which requires an intermediate buffer and copying. This is shown for comparison with the zero-copy approach.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nchar buffer[BUFFER_SIZE];\ninput->Read(buffer, BUFFER_SIZE);\nDoSomething(buffer, BUFFER_SIZE);\n```\n\n----------------------------------------\n\nTITLE: Accessing Fields Named as Python Keywords (Python)\nDESCRIPTION: Demonstrates how to access Protocol Buffer fields that have names matching Python keywords using getattr() and setattr() functions instead of regular attribute access.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nbaz = Baz()\nsetattr(baz, \"from\", 99)\nassert getattr(baz, \"from\") == 99\ngetattr(baz, \"in\").append(42)\nassert getattr(baz, \"in\") == [42]\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for Java Output\nDESCRIPTION: This shell command demonstrates how to invoke the protocol buffer compiler to generate Java code, specifying the input .proto file and output directory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --java_out=build/gen src/foo.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Oneof Fields\nDESCRIPTION: Shows how to define oneof fields in Protocol Buffers to create mutually exclusive field groups.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  oneof test_oneof {\n     string name = 1;\n     int32 serial_number = 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer Message from String in C++\nDESCRIPTION: Parses a text-format protocol message directly from a string to the specified Message object. Returns true on success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool ParseFromString(ConstStringParam input, Message* output)\n```\n\n----------------------------------------\n\nTITLE: Using Map Fields in Protocol Buffers with Ruby\nDESCRIPTION: Demonstrates how to use the Google::Protobuf::Map class to create and manipulate strongly-typed map fields. Shows type checking and basic operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\nint_string_map = Google::Protobuf::Map.new(:int32, :string)\n\n# Returns nil; items is not in the map.\nprint int_string_map[5]\n\n# Raises TypeError, value should be a string\nint_string_map[11] = 200\n\n# Ok.\nint_string_map[123] = \"abc\"\n\nmessage.int32_string_map_field = int_string_map\n```\n\n----------------------------------------\n\nTITLE: Message Basic Operations\nDESCRIPTION: Essential operations for message handling including creation, copying, merging, and initialization checking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvirtual Message* New() const = 0;\nvirtual Message* New(Arena* arena) const;\nvirtual void CopyFrom(const Message& from);\nvirtual void MergeFrom(const Message& from);\nvoid CheckInitialized() const;\nvoid FindInitializationErrors(std::vector<std::string>* errors) const;\nvirtual std::string InitializationErrorString() const;\nvirtual void DiscardUnknownFields();\nvirtual size_t SpaceUsedLong() const;\nint SpaceUsed() const;\n```\n\n----------------------------------------\n\nTITLE: Accessing Extension Fields in Go\nDESCRIPTION: Example of how to set and get extension field values in Go using the proto package functions. Shows handling of different field types including scalar, repeated, and message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nm := &somepb.Concert{}\nproto.SetExtension(m, extpb.E_SingularInt32, int32(1))\nproto.SetExtension(m, extpb.E_RepeatedString, []string{\"a\", \"b\", \"c\"})\nproto.SetExtension(m, extpb.E_SingularMessage, &extpb.Band{})\n\nv1 := proto.GetExtension(m, extpb.E_SingularInt32).(int32)\nv2 := proto.GetExtension(m, extpb.E_RepeatedString).([][]byte)\nv3 := proto.GetExtension(m, extpb.E_SingularMessage).(*extpb.Band)\n```\n\n----------------------------------------\n\nTITLE: Multiple Message Types in Proto2\nDESCRIPTION: Demonstrates how to define multiple related message types in a single .proto file, showing SearchRequest and SearchResponse messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_2\n\nLANGUAGE: proto2\nCODE:\n```\nmessage SearchRequest {\n  optional string query = 1;\n  optional int32 page_number = 2;\n  optional int32 results_per_page = 3;\n}\n\nmessage SearchResponse {\n ....\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Enum Field Values in C++\nDESCRIPTION: Methods for getting enum field values from a message, both as descriptors and integer values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_33\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor* GetEnum(const Message& message, const FieldDescriptor* field) const\nint GetEnumValue(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Generated Kotlin DSL Structure\nDESCRIPTION: The Kotlin code generated by the protocol buffer compiler for a basic message, including the DSL object and factory functions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nobject FooBarKt {\n  class Dsl private constructor { ... }\n}\ninline fun fooBar(block: FooBarKt.Dsl.() -> Unit): FooBar\ninline fun FooBar.copy(block: FooBarKt.Dsl.() -> Unit): FooBar\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Enum Type\nDESCRIPTION: Example enum definition in Protocol Buffers showing a Bar enum with unspecified, value and other_value options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nenum Bar {\n  BAR_UNSPECIFIED = 0;\n  BAR_VALUE = 1;\n  BAR_OTHER_VALUE = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Message Values to Protocol Buffer Maps (Python)\nDESCRIPTION: Shows how to add a message as a map value by referencing an undefined key, which constructs and returns a new submessage automatically.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nm.message_map[key].submessage_field = 10\n```\n\n----------------------------------------\n\nTITLE: Accessing Mutable Message Fields in Protocol Buffers C++\nDESCRIPTION: Demonstrates how to get a mutable pointer to a field with a message type, optionally using a MessageFactory for construction.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_57\n\nLANGUAGE: C++\nCODE:\n```\nMessage* Reflection::MutableMessage(\n    Message* message,\n    const FieldDescriptor* field,\n    MessageFactory* factory = nullptr) const\n```\n\n----------------------------------------\n\nTITLE: Using WhichOneof() in Protocol Buffers (Python)\nDESCRIPTION: Shows how to use the WhichOneof() method to determine which field in a oneof is currently set, returning either the field name or None.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nassert message.WhichOneof(\"test_oneof\") is None\nmessage.name = \"Bender\"\nassert message.WhichOneof(\"test_oneof\") == \"name\"\n```\n\n----------------------------------------\n\nTITLE: Adding File to Unused Import Tracking\nDESCRIPTION: Adds a file to the list of files for which unused imports should be tracked. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_133\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::AddUnusedImportTrackFile(ConstStringParam file_name, bool is_error = false)\n```\n\n----------------------------------------\n\nTITLE: Implementing Any Type in Protocol Buffers\nDESCRIPTION: Demonstrates how to import and use the Any message type for embedding arbitrary serialized messages. Shows the basic structure for importing and using Any in an ErrorStatus message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/any.proto\";\n\nmessage ErrorStatus {\n  string message = 1;\n  repeated google.protobuf.Any details = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Shows how to define oneof fields in Protocol Buffers. The compiler generates accessor methods for each field within the oneof, as well as methods to check which field is set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_13\n\nLANGUAGE: protobuf\nCODE:\n```\npackage account;\nmessage Profile {\n  oneof avatar {\n    string image_url = 1;\n    bytes image_data = 2;\n  }\n}\n```\n\nLANGUAGE: go\nCODE:\n```\ntype Profile struct { ... }\n\nfunc (m *Profile) WhichAvatar() case_Profile_Avatar { ... }\nfunc (m *Profile) GetImageUrl() string { ... }\nfunc (m *Profile) GetImageData() []byte { ... }\n\nfunc (m *Profile) SetImageUrl(v string) { ... }\nfunc (m *Profile) SetImageData(v []byte) { ... }\n\nfunc (m *Profile) HasAvatar() bool { ... }\nfunc (m *Profile) HasImageUrl() bool { ... }\nfunc (m *Profile) HasImageData() bool { ... }\n\nfunc (m *Profile) ClearAvatar() { ... }\nfunc (m *Profile) ClearImageUrl() { ... }\nfunc (m *Profile) ClearImageData() { ... }\n```\n\n----------------------------------------\n\nTITLE: Examples of Normal Fields in Proto3\nDESCRIPTION: Shows examples of how to define normal fields in a message, including a nested message field and a repeated field with options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_19\n\nLANGUAGE: proto3\nCODE:\n```\nfoo.Bar nested_message = 2;\nrepeated int32 samples = 4 [packed=true];\n```\n\n----------------------------------------\n\nTITLE: Basic ZeroCopyOutputStream Usage Example in C++\nDESCRIPTION: Example showing how to copy content from an input file to an output file using ZeroCopyOutputStream. The example demonstrates buffer acquisition, writing data, and handling partial reads with BackUp().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// Copy the contents of \"infile\" to \"outfile\", using plain read() for\n// \"infile\" but a ZeroCopyOutputStream for \"outfile\".\nint infd = open(\"infile\", O_RDONLY);\nint outfd = open(\"outfile\", O_WRONLY);\nZeroCopyOutputStream* output = new FileOutputStream(outfd);\n\nvoid* buffer;\nint size;\nwhile (output->Next(&buffer, &size)) {\n  int bytes = read(infd, buffer, size);\n  if (bytes < size) {\n    // Reached EOF.\n    output->BackUp(size - bytes);\n    break;\n  }\n}\n\ndelete output;\nclose(infd);\nclose(outfd);\n```\n\n----------------------------------------\n\nTITLE: Setting and Getting Field Values in PHP Protocol Buffers\nDESCRIPTION: Example of using the generated accessor methods to set and get field values in a Protocol Buffer message. Each field has corresponding setX and getX methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: php\nCODE:\n```\n$m = new MyMessage();\n$m->setX(1);\n$val = $m->getX();\n\n$a = 1;\n$m->setX($a);\n```\n\n----------------------------------------\n\nTITLE: Address Book Protocol Definition\nDESCRIPTION: Defines the message structure for Person and AddressBook types, including nested types for phone numbers and an enum for phone types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage Person {\n  string name = 1;\n  int32 id = 2;  // Unique ID number for this person.\n  string email = 3;\n\n  enum PhoneType {\n    PHONE_TYPE_UNSPECIFIED = 0;\n    PHONE_TYPE_MOBILE = 1;\n    PHONE_TYPE_HOME = 2;\n    PHONE_TYPE_WORK = 3;\n  }\n\n  message PhoneNumber {\n    string number = 1;\n    PhoneType type = 2;\n  }\n\n  repeated PhoneNumber phones = 4;\n\n  google.protobuf.Timestamp last_updated = 5;\n}\n\n// Our address book file is just one of these.\nmessage AddressBook {\n  repeated Person people = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extensions in Protocol Buffers (C++)\nDESCRIPTION: Methods for finding extension fields by name or number in Protocol Buffer messages. These methods search for extensions that have been registered with the message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_49\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * FindKnownExtensionByName(const std::string & name) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * FindKnownExtensionByNumber(int number) const\n```\n\n----------------------------------------\n\nTITLE: Java Implementation of Protobuf Enum Synonyms\nDESCRIPTION: Shows how Protocol Buffers generates Java code for enum synonyms, where multiple enum constants share the same numeric value. The compiler defines subsequent symbols as references to the first one.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_24\n\nLANGUAGE: java\nCODE:\n```\nstatic final Foo BAZ = BAR;\n```\n\n----------------------------------------\n\nTITLE: Manipulating Struct Messages in Python\nDESCRIPTION: Shows how to directly get and set items in a Struct well-known type message using dictionary-like syntax in Python.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nstruct_message[\"key1\"] = 5\nstruct_message[\"key2\"] = \"abc\"\nstruct_message[\"key3\"] = True\n```\n\n----------------------------------------\n\nTITLE: Retrieving Message Descriptor in C++\nDESCRIPTION: Gets a non-owning pointer to the Descriptor for this message's type. The Descriptor describes the message fields, types, etc.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor* Message::GetDescriptor() const\n```\n\n----------------------------------------\n\nTITLE: C++ Field Presence Handling with Implicit Presence\nDESCRIPTION: C++ example demonstrating field handling with implicit presence in Proto3, where default values are used for checking and clearing fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nMsg m = GetProto();\nif (m.foo() != 0) {\n  // \"Clear\" the field:\n  m.set_foo(0);\n} else {\n  // Default value: field may not have been present.\n  m.set_foo(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Last Element from Repeated Message Field in C++\nDESCRIPTION: Removes the last element of a repeated message field and returns the pointer to the caller.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nMessage* ReleaseLast(Message* message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Map Field Definition in Protocol Buffers\nDESCRIPTION: Example showing how to define a map field in a Protocol Buffer message. Maps are key-value pairs defined with specific types for both keys and values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nmessage MyMessage {\n  map<int32, int32> mapfield = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Scalar Fields in Protocol Buffers (proto2)\nDESCRIPTION: Shows how to define optional and required singular scalar fields in proto2. The compiler generates accessor methods for getting, setting, checking presence, and clearing these fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_7\n\nLANGUAGE: protobuf\nCODE:\n```\noptional int32 birth_year = 1;\nrequired int32 birth_year = 1;\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc (m *Artist) GetBirthYear() int32 { ... }\nfunc (m *Artist) SetBirthYear(v int32) { ... }\nfunc (m *Artist) HasBirthYear() bool { ... }\nfunc (m *Artist) ClearBirthYear() { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Fields in Proto3\nDESCRIPTION: Specifies the syntax for reserved statements, which declare ranges of field numbers or field names that cannot be used in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_24\n\nLANGUAGE: ebnf\nCODE:\n```\nreserved = \"reserved\" ( ranges | strFieldNames ) \";\"\nranges = range { \",\" range }\nrange =  intLit [ \"to\" ( intLit | \"max\" ) ]\nstrFieldNames = strFieldName { \",\" strFieldName }\nstrFieldName = \"'\" fieldName \"'\" | '\"' fieldName '\"'\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Message in Protocol Buffers\nDESCRIPTION: Shows how to define a simple message in a .proto file. This is the basis for generating Rust code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Protocol Buffer Enumeration\nDESCRIPTION: Demonstrates how to define an enumeration in Protocol Buffers with multiple values. This is the foundation for generating corresponding C++ enum types and helper functions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_39\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  VALUE_A = 0;\n  VALUE_B = 5;\n  VALUE_C = 1234;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Mixin in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a simple mixin in Protocol Buffers, demonstrating the inclusion of one API service (AccessControl) into another (Storage).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\npackage google.acl.v1;\nservice AccessControl {\n  // Get the underlying ACL object.\n  rpc GetAcl(GetAclRequest) returns (Acl) {\n    option (google.api.http).get = \"/v1/{resource=**}:getAcl\";\n  }\n}\n\npackage google.storage.v2;\nservice Storage {\n  //       rpc GetAcl(GetAclRequest) returns (Acl);\n\n  // Get a data record.\n  rpc GetData(GetDataRequest) returns (Data) {\n    option (google.api.http).get = \"/v2/{resource=**}\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Raw Data to EpsCopyOutputStream in C++\nDESCRIPTION: Method for writing raw data to the stream, taking a data pointer, size, and destination pointer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_42\n\nLANGUAGE: C++\nCODE:\n```\nuint8* WriteRaw(const void* data, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Accessing Repeated Fields in Protocol Buffers using Reflection in C++\nDESCRIPTION: Methods for retrieving values from repeated fields within Protocol Buffer messages. These methods allow accessing individual elements in repeated fields by their index.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_42\n\nLANGUAGE: C++\nCODE:\n```\nint32 GetRepeatedInt32(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nint64 GetRepeatedInt64(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nuint32 GetRepeatedUInt32(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nuint64 GetRepeatedUInt64(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nfloat GetRepeatedFloat(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\ndouble GetRepeatedDouble(const Message & message, const FieldDescriptor * field, int index) const\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to Repeated Fields in Protocol Buffers C++ API\nDESCRIPTION: This snippet shows the method signatures for adding elements to repeated fields. These methods append new values to repeated fields, supporting various data types including int32, int64, and uint32.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_45\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddInt32(Message * message, const FieldDescriptor * field, int32 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddInt64(Message * message, const FieldDescriptor * field, int64 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddUInt32(Message * message, const FieldDescriptor * field, uint32 value) const\n```\n\n----------------------------------------\n\nTITLE: Setting Text Format Parser Methods\nDESCRIPTION: Collection of Parser class methods for configuring text format parsing behavior including extension handling, case sensitivity, unknown fields, and recursion limits.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nvoid Parser::SetFinder(const Finder* finder);\nvoid Parser::WriteLocationsTo(ParseInfoTree* tree);\nvoid Parser::AllowPartialMessage(bool allow);\nvoid Parser::AllowCaseInsensitiveField(bool allow);\nvoid Parser::AllowUnknownExtension(bool allow);\nvoid Parser::AllowUnknownField(bool allow);\nvoid Parser::SetRecursionLimit(int limit);\n```\n\n----------------------------------------\n\nTITLE: Any Type JSON Format\nDESCRIPTION: Shows the JSON structure for Protocol Buffer Any type with @type field indicating the actual data type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/json.md#2025-04-11_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\"@type\": \"url\", \"f\": v, ... }\n```\n\n----------------------------------------\n\nTITLE: Using Map Fields in PHP\nDESCRIPTION: Example of working with map fields in PHP Protocol Buffers. Generated code allows using array-like syntax to access and modify map entries.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: php\nCODE:\n```\n$m->getWeight()[1] = 1;\n```\n\n----------------------------------------\n\nTITLE: Proto Message with Repeated Field\nDESCRIPTION: Example showing how to define a repeated field in protocol buffers, which becomes a slice in Go.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nmessage Concert {\n  // Best practice: use pluralized names for repeated fields:\n  // /programming-guides/style#repeated-fields\n  repeated Band support_acts = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Enum Structure in Rust\nDESCRIPTION: Generated Rust code for enum types, using associated constants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n#[repr(transparent)]\npub struct Bar(i32);\n\nimpl Bar {\n  pub const Unspecified: Bar = Bar(0);\n  pub const Value: Bar = Bar(1);\n  pub const OtherValue: Bar = Bar(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Presence String/Bytes Fields in Protocol Buffers (proto3)\nDESCRIPTION: Shows how to define implicit presence string and bytes fields in a proto3 .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\noptional string foo = 1;\nstring foo = 1;\noptional bytes foo = 1;\nbytes foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Implementing equals method in Protobuf Kotlin ExtensionList class\nDESCRIPTION: Declaration of the equals method that overrides the standard Kotlin equals operator in the ExtensionList class. This method compares an ExtensionList instance with another object to determine equality.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/equals.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen operator override fun equals(other: Any?): Boolean\n```\n\n----------------------------------------\n\nTITLE: Manipulating Message Fields in Protocol Buffers using Reflection in C++\nDESCRIPTION: Methods for getting and setting message fields within Protocol Buffer messages. These methods allow for manipulating nested messages, including getting mutable pointers and transferring ownership.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_41\n\nLANGUAGE: C++\nCODE:\n```\nMessage * MutableMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetAllocatedMessage(Message * message, Message * sub_message, const FieldDescriptor * field) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid UnsafeArenaSetAllocatedMessage(Message * message, Message * sub_message, const FieldDescriptor * field) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_FUTURE_MUST_USE_RESULT Message * ReleaseMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nMessage * UnsafeArenaReleaseMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) const\n```\n\n----------------------------------------\n\nTITLE: Oneof Field Operations in Protocol Buffers\nDESCRIPTION: Methods for working with oneof fields in protocol buffer messages, including counting and accessing oneof declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nint Descriptor::real_oneof_decl_count() const\nconst OneofDescriptor* Descriptor::oneof_decl(int index) const\n```\n\n----------------------------------------\n\nTITLE: Swapping Elements in Repeated Field in C++\nDESCRIPTION: Swaps two elements of a repeated field within a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\nvoid SwapElements(Message* message, const FieldDescriptor* field, int index1, int index2) const\n```\n\n----------------------------------------\n\nTITLE: Defining Services in Protocol Buffers\nDESCRIPTION: Specifies the syntax for service definitions in Protocol Buffers, including RPC method declarations with streaming options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_33\n\nLANGUAGE: EBNF\nCODE:\n```\nservice = \"service\" serviceName \"{\" { option | rpc | emptyStatement } \"}\"\nrpc = \"rpc\" rpcName \"(\" [ \"stream\" ] messageType \")\" \"returns\" \"(\" [ \"stream\" ]\nmessageType \")\" (( \"{\" { option | emptyStatement } \"}\" ) | \";\" )\n```\n\n----------------------------------------\n\nTITLE: Efficiently Inserting Values into a Protocol Buffer Map\nDESCRIPTION: Example showing the most efficient way to insert new values into a google::protobuf::Map using the index operator.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\nT& operator[](const Key& key): map[new_key] = new_mapped;\n```\n\n----------------------------------------\n\nTITLE: Defining Optional String/Bytes Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define optional and required string and bytes fields in a .proto file for both proto2 and proto3.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\noptional string foo = 1;\nrequired string foo = 1;\noptional bytes foo = 1;\nrequired bytes foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Getting String Field References in C++\nDESCRIPTION: Method for getting a string field value reference without copying, if possible.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_35\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& GetStringReference(const Message& message, const FieldDescriptor* field, std::string* scratch) const\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Types in Protocol Buffers\nDESCRIPTION: Shows how to define a nested message type in a .proto file. The nested message Bar will be accessible as Foo::Bar in the generated Ruby code, maintaining the nesting structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar { }\n}\n```\n\n----------------------------------------\n\nTITLE: Swapping Elements in RepeatedField in C++\nDESCRIPTION: Swaps two elements within the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nvoid SwapElements(int index1, int index2)\n```\n\n----------------------------------------\n\nTITLE: Serializing to ZeroCopyOutputStream - C++\nDESCRIPTION: Writes the message to a zero-copy output stream. All required fields must be set before serialization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::SerializeToZeroCopyStream(io::ZeroCopyOutputStream* output) const\n```\n\n----------------------------------------\n\nTITLE: Nested Type Operations in Protocol Buffers\nDESCRIPTION: Methods for working with nested type definitions within Protocol Buffer messages, including counting nested types and accessing them by index or name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nnested_type_count() const\nnested_type(int index) const\nFindNestedTypeByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Using Oneof Fields in Ruby\nDESCRIPTION: Demonstrates how to work with oneof fields in Ruby, showing field access and mutual exclusivity behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: ruby\nCODE:\n```\nmessage = Foo.new\n\n# Fields have their defaults.\nraise unless message.name == \"\"\nraise unless message.serial_number == 0\nraise unless message.test_oneof == nil\n\nmessage.name = \"Bender\"\nraise unless message.name == \"Bender\"\nraise unless message.serial_number == 0\nraise unless message.test_oneof == :name\n\n# Setting serial_number clears name.\nmessage.serial_number = 2716057\nraise unless message.name == \"\"\nraise unless message.test_oneof == :serial_number\n\n# Setting serial_number to nil clears the oneof.\nmessage.serial_number = nil\nraise unless message.test_oneof == nil\n```\n\n----------------------------------------\n\nTITLE: Accessing Fields in Protocol Buffers Descriptor\nDESCRIPTION: Core methods for accessing and looking up message fields including by index, number, and name variations. These methods allow traversing and inspecting message field definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor* Descriptor::field(int index) const\nconst FieldDescriptor* Descriptor::FindFieldByNumber(int number) const\nconst FieldDescriptor* Descriptor::FindFieldByLowercaseName(ConstStringParam lowercase_name) const\nconst FieldDescriptor* Descriptor::FindFieldByCamelcaseName(ConstStringParam camelcase_name) const\n```\n\n----------------------------------------\n\nTITLE: Parsing Extensions with ExtensionRegistry in Java\nDESCRIPTION: Demonstrates how to parse messages with extensions by providing an ExtensionRegistry. Without registering extensions, they will be treated as unknown fields when parsing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_30\n\nLANGUAGE: java\nCODE:\n```\nExtensionRegistry registry = ExtensionRegistry.newInstance();\nregistry.add(Baz.fooExt);\nFoo foo = Foo.parseFrom(input, registry);\nassert foo.hasExtension(Baz.fooExt);\n```\n\n----------------------------------------\n\nTITLE: Repeated Field Definition and Usage\nDESCRIPTION: Example of a repeated field definition and its generated Kotlin code structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nrepeated string foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Message Type Definition\nDESCRIPTION: Example .proto file defining message types Foo and Bar, where Foo contains an optional Bar field. Used to demonstrate how embedded message fields work in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  optional Bar bar = 1;\n}\nmessage Bar {\n  optional int32 i = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Python Field Presence Handling with Implicit Presence\nDESCRIPTION: Python example demonstrating field handling with implicit presence in Proto3, where default values are used to check and clear fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nm = example.Msg()\nif m.foo != 0:\n  # \"Clear\" the field:\n  m.foo = 0\nelse:\n  # Default value: field may not have been present.\n  m.foo = 1\n```\n\n----------------------------------------\n\nTITLE: Working with RepeatedField for Repeated Field Types in Ruby\nDESCRIPTION: Demonstrates how to use the Google::Protobuf::RepeatedField class for repeated fields. Shows type checking, modification operations, and how to work with arrays while maintaining type safety.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nint_repeatedfield = Google::Protobuf::RepeatedField.new(:int32, [1, 2, 3])\n\nraise unless !int_repeatedfield.empty?\n\n# Raises TypeError.\nint_repeatedfield[2] = \"not an int32\"\n\n# Raises RangeError\nint_repeatedfield[2] = 2**33\n\nmessage.int32_repeated_field = int_repeatedfield\n\n# This isn't allowed; the regular Ruby array doesn't enforce types like we need.\nmessage.int32_repeated_field = [1, 2, 3, 4]\n\n# This is fine, since the elements are copied into the type-safe array.\nmessage.int32_repeated_field += [1, 2, 3, 4]\n\n# The elements can be cleared without reassigning.\nint_repeatedfield.clear\nraise unless int_repeatedfield.empty?\n```\n\n----------------------------------------\n\nTITLE: Proto2 Map Field Example\nDESCRIPTION: Shows an example of a map field declaration in Protocol Buffers mapping strings to Project objects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nmap<string, Project> projects = 3;\n```\n\n----------------------------------------\n\nTITLE: Implementing hashCode Function for ExtensionList in Kotlin\nDESCRIPTION: This code snippet defines the hashCode function for the ExtensionList class. It is an open override function that returns an Int value, representing the hash code of the ExtensionList instance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/hash-code.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen override fun hashCode(): Int\n```\n\n----------------------------------------\n\nTITLE: Modifying Unknown Fields in C++\nDESCRIPTION: Gets a mutable pointer to the UnknownFieldSet for a message, allowing modification of unknown fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nUnknownFieldSet* Reflection::MutableUnknownFields(Message* message) const\n```\n\n----------------------------------------\n\nTITLE: JSON to Binary Stream Conversion Function (C++)\nDESCRIPTION: Converts JSON data to protobuf binary format using a TypeResolver. Takes input/output streams and JSON parse options. Will fail if TypeResolver cannot resolve types or if input JSON format is invalid.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nutil::Status util::JsonToBinaryStream(\n        TypeResolver* resolver,\n        const std::string& type_url,\n        io::ZeroCopyInputStream* json_input,\n        io::ZeroCopyOutputStream* binary_output,\n        const JsonParseOptions& options)\n```\n\n----------------------------------------\n\nTITLE: Defining CreateStudentRequest message in Protocol Buffers\nDESCRIPTION: This snippet defines a CreateStudentRequest message that imports and uses the FullName message. It shows how to create a request-specific message while reusing common types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nimport \"full_name.proto\";\n\nmessage CreateStudentRequest {\n  FullName name = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating Repeated Fields in Protocol Buffers C++\nDESCRIPTION: Demonstrates how to remove the last element of a repeated field and release the last element of a repeated message field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_53\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::RemoveLast(\n    Message* message,\n    const FieldDescriptor* field) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_FUTURE_MUST_USE_RESULT Message* Reflection::ReleaseLast(\n    Message* message,\n    const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Defining Java Wrapper Class API for Protocol Buffers\nDESCRIPTION: This code snippet shows the API of the generated wrapper class, including methods to get the file descriptor and register extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic final class Foo {\n  private Foo() {}  // Not instantiable.\n\n  /** Returns a FileDescriptor message describing the contents of {@code foo.proto}. */\n  public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor();\n  /** Adds all extensions defined in {@code foo.proto} to the given registry. */\n  public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry);\n  public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry);\n\n  // (Nested classes omitted)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Oneof Field with Multiple Types in Protocol Buffers\nDESCRIPTION: Example showing how to define a oneof field that can contain different types like int32 or string.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_37\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    int32 foo_int = 4;\n    string foo_string = 9;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Protocol Buffer Messages in Ruby\nDESCRIPTION: Demonstrates how to create, initialize, serialize, and decode a protocol buffer message in Ruby. Shows how to set fields in the constructor and verify field values after deserialization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nmessage = MyMessage.new(:int_field => 1,\n                        :string_field => \"String\",\n                        :repeated_int_field => [1, 2, 3, 4],\n                        :submessage_field => SubMessage.new(:foo => 42))\nserialized = MyMessage.encode(message)\n\nmessage2 = MyMessage.decode(serialized)\nraise unless message2.int_field == 1\n```\n\n----------------------------------------\n\nTITLE: MessageLite Base Class Methods - Message Operations\nDESCRIPTION: Essential message manipulation methods including clearing fields, checking initialization status, and type checking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void Clear() = 0\nvirtual bool IsInitialized() const = 0\nvirtual std::string InitializationErrorString() const\nvirtual void CheckTypeAndMergeFrom(const MessageLite& other) = 0\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions in Protocol Buffers\nDESCRIPTION: Specifies the syntax for extend blocks in Protocol Buffers, which add fields to extendable message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_31\n\nLANGUAGE: EBNF\nCODE:\n```\nextend = \"extend\" messageType \"{\" {field | group} \"}\"\n```\n\n----------------------------------------\n\nTITLE: Generated C# File Structure for Protocol Buffer Messages\nDESCRIPTION: Illustrates the basic structure of a generated C# file, including namespace, descriptor class, and placeholders for enums and message classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace [...]\\n{\\n  public static partial class [... descriptor class name ...]\\n  {\\n    public static FileDescriptor Descriptor { get; }\\n  }\\n\\n  [... Enums ...]\\n  [... Message classes ...]\\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Protocol Message to String in C++\nDESCRIPTION: Outputs a textual representation of the given message directly to a string. The output string is cleared before printing and left empty if printing fails. Returns false if printing fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool TextFormat::PrintToString(\n        const Message& message,\n        std::string* output)\n```\n\n----------------------------------------\n\nTITLE: Defining ServiceDescriptorProto Message in Protocol Buffers\nDESCRIPTION: Describes a service in Protocol Buffers. It includes the service name, methods, and options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_8\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ServiceDescriptorProto {\n  optional string name = 1;\n  repeated MethodDescriptorProto method = 2;\n\n  optional ServiceOptions options = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Feature Scopes in Protobuf Editions\nDESCRIPTION: This example shows how feature settings can be applied at different scopes: file-level, non-nested (enum, message), nested (message within message), and lowest-level (field). Each scope can override settings from higher levels.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\n// File-level scope definition\noption features.bar = BAZ;\n\nenum Foo {\n  // Enum (non-nested scope) definition\n  option features.bar = QUX;\n\n  A = 1;\n  B = 2;\n}\n\nmessage Corge {\n  // Message (non-nested scope) definition\n  option features.bar = QUUX;\n\n  message Garply {\n    // Message (nested scope) definition\n    option features.bar = WALDO;\n    string id = 1;\n  }\n\n  // Field (lowest-level scope) definition\n  Foo A = 1 [features.bar = GRAULT];\n}\n```\n\n----------------------------------------\n\nTITLE: Supporting Unknown Enum Values in Protocol Buffers\nDESCRIPTION: Code example demonstrating how to safely handle unknown enum values in generic reflection-based code, checking if the reflection supports unknown values before setting them, and providing fallback mechanisms.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_69\n\nLANGUAGE: cpp\nCODE:\n```\nint new_value = GetValueFromApplicationLogic();\nif (reflection->SupportsUnknownEnumValues()) {\n  reflection->SetEnumValue(message, field, new_value);\n} else {\n  if (field_descriptor->enum_type()->\n          FindValueByNumber(new_value) != nullptr) {\n    reflection->SetEnumValue(message, field, new_value);\n  } else if (emit_unknown_enum_values) {\n    reflection->MutableUnknownFields(message)->AddVarint(\n        field->number(), new_value);\n  } else {\n    // convert value to a compatible/default value.\n    new_value = CompatibleDowngrade(new_value);\n    reflection->SetEnumValue(message, field, new_value);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Without ExtensionRegistry in Java\nDESCRIPTION: Shows what happens when parsing a message with extensions without providing the appropriate ExtensionRegistry. Extensions will not be recognized and hasExtension() will return false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_31\n\nLANGUAGE: java\nCODE:\n```\nExtensionRegistry registry = ExtensionRegistry.newInstance();\nFoo foo = Foo.parseFrom(input, registry);\nassert foo.hasExtension(Baz.fooExt) == false;\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Example showing how to define a oneof field in Protocol Buffers, which allows at most one of several fields to be set at a time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_38\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  oneof test_oneof {\n     string name = 1;\n     int32 serial_number = 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers and Generated Objective-C Code\nDESCRIPTION: This snippet shows how to define map fields in a Protocol Buffer message and demonstrates the corresponding Objective-C code generated for handling these fields, including property declarations and field number enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\nmessage Bar {...}\nmessage Foo {\n  map<int32, string> a_map = 1;\n  map<string, Bar> b_map = 2;\n};\n```\n\nLANGUAGE: objc\nCODE:\n```\ntypedef GPB_ENUM(Foo_FieldNumber) {\n  Foo_FieldNumber_AMap = 1,\n  Foo_FieldNumber_BMap = 2,\n};\n\n@interface Foo : GPBMessage\n// Map names are the camel case version of the field name.\n@property (nonatomic, readwrite, strong, null_resettable) GPBInt32ObjectDictionary *aMap;\n@property(nonatomic, readonly) NSUInteger aMap_Count;\n@property (nonatomic, readwrite, strong, null_resettable) NSMutableDictionary *bMap;\n@property(nonatomic, readonly) NSUInteger bMap_Count;\n@end\n```\n\n----------------------------------------\n\nTITLE: MessageLite Base Class Methods - Parsing Operations\nDESCRIPTION: Methods for parsing protocol buffer messages from various input sources including streams and file descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nbool ParseFromCodedStream(io::CodedInputStream* input)\nbool ParsePartialFromCodedStream(io::CodedInputStream* input)\nbool ParseFromZeroCopyStream(io::ZeroCopyInputStream* input)\nbool ParseFromFileDescriptor(int file_descriptor)\nbool ParseFromIstream(std::istream* input)\n```\n\n----------------------------------------\n\nTITLE: Declaring Fields in Proto3\nDESCRIPTION: Protocol Buffer field definition showing the syntax for fields in proto3, which are implicitly optional and have a simpler API without presence checking for scalar types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nint32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining Map::iterator Class in C++\nDESCRIPTION: This snippet defines the iterator class for the Map container in Protocol Buffers. It includes typedefs for iterator traits, member functions for iteration and access, and an implicit conversion to const_iterator.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.map.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nclass Map::iterator {\npublic:\n    typedef std::forward_iterator_tag iterator_category;\n    typedef typename Map::value_type value_type;\n    typedef ptrdiff_t difference_type;\n    typedef value_type* pointer;\n    typedef value_type& reference;\n\n    iterator();\n    explicit iterator(const InnerIt& it);\n    reference operator*() const;\n    pointer operator->() const;\n    iterator& operator++();\n    iterator operator++(int);\n    operator const_iterator() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Generated DescriptorPool\nDESCRIPTION: Gets a pointer to the generated pool where compiled protocol message classes allocate their descriptors. Users should not add their own descriptors to this pool.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_123\n\nLANGUAGE: C++\nCODE:\n```\nstatic const DescriptorPool * DescriptorPool::generated_pool()\n```\n\n----------------------------------------\n\nTITLE: Setting Java Outer Classname Option in Protocol Buffers\nDESCRIPTION: Shows how to set the java_outer_classname option to specify the wrapper Java class name for the generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\noption java_outer_classname = \"Ponycopter\";\n```\n\n----------------------------------------\n\nTITLE: Unsafe Arena Set Allocated Message in Protocol Buffers C++\nDESCRIPTION: Similar to SetAllocatedMessage, but omits all internal safety and ownership checks. This method should only be used when the objects are on the same arena or paired with a call to UnsafeArenaReleaseMessage.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_59\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::UnsafeArenaSetAllocatedMessage(\n    Message* message,\n    Message* sub_message,\n    const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Keys in Protocol Buffer Maps (Python)\nDESCRIPTION: Explains how Protocol Buffer maps behave differently from Python dicts when referencing undefined keys. Shows how undefined keys are automatically created with default values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> dict(m.mapfield)\n{}\n>>> m.mapfield[5]\n0\n>>> dict(m.mapfield)\n{5: 0}\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Types in Protocol Buffers\nDESCRIPTION: Demonstrates how to define a nested message type within another message in Protocol Buffers. The compiler generates separate structs for nested types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Artist {\n  message Name {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Public Imports for Proto File Migration\nDESCRIPTION: Demonstrates the use of 'import public' to forward imports to a new location. This technique is useful when moving proto definitions to maintain backward compatibility.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\n// new.proto\n// All definitions are moved here\n```\n\nLANGUAGE: proto\nCODE:\n```\n// old.proto\n// This is the proto that all clients are importing.\nimport public \"new.proto\";\nimport \"other.proto\";\n```\n\nLANGUAGE: proto\nCODE:\n```\n// client.proto\nimport \"old.proto\";\n// You use definitions from old.proto and new.proto, but not other.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated Fields in Protocol Buffers\nDESCRIPTION: Basic repeated field definition showing how to declare a repeated string field in a proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nrepeated string foos = 1;\n```\n\n----------------------------------------\n\nTITLE: Merging Protocol Buffer from CodedInputStream in C++\nDESCRIPTION: Methods for reading a protocol buffer from a CodedInputStream and merging it into the Message, with options for handling missing required fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nbool MergeFromCodedStream(io::CodedInputStream* input)\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool MergePartialFromCodedStream(io::CodedInputStream* input)\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested Extensions in Protocol Buffers\nDESCRIPTION: Demonstrates how to declare extensions within the scope of another message. This approach is not recommended due to potential confusion with subclassing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_27\n\nLANGUAGE: proto\nCODE:\n```\nimport \"common/user_profile.proto\";\n\npackage puppies;\n\nmessage Photo {\n  extend common.UserProfile {\n    optional int32 likes_count = 111;\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring OneofDescriptor Class in C++\nDESCRIPTION: Declaration of the OneofDescriptor class in Protocol Buffers, which describes a oneof field defined in a message type. It includes various methods for accessing oneof properties and metadata.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_50\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/descriptor.h>\nnamespace google::protobuf\n\nclass OneofDescriptor {\npublic:\n    typedef OneofDescriptorProto Proto;\n    const std::string& name() const;\n    const std::string& full_name() const;\n    int index() const;\n    bool is_synthetic() const;\n    const FileDescriptor* file() const;\n    const Descriptor* containing_type() const;\n    int field_count() const;\n    const FieldDescriptor* field(int index) const;\n    const OneofOptions& options() const;\n    void CopyTo(OneofDescriptorProto* proto) const;\n    std::string DebugString() const;\n    std::string DebugStringWithOptions(const DebugStringOptions& options) const;\n    bool GetSourceLocation(SourceLocation* out_location) const;\n};\n```\n\n----------------------------------------\n\nTITLE: JSON to Message Conversion Function\nDESCRIPTION: Converts JSON string to Protocol Buffer message format. Uses DescriptorPool from the target message to resolve Any types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nutil::Status JsonStringToMessage(\n    StringPiece input,\n    Message* message,\n    const JsonParseOptions& options)\n```\n\n----------------------------------------\n\nTITLE: Defining Maps in Protocol Buffers\nDESCRIPTION: Shows how to create associative maps in Protocol Buffers using the map syntax, supporting various key types and value types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_28\n\nLANGUAGE: proto\nCODE:\n```\nmap<string, Project> projects = 3;\n```\n\n----------------------------------------\n\nTITLE: Computing Duration Between Timestamps in Protocol Buffers\nDESCRIPTION: Demonstrates how to calculate the duration between two Timestamp values by computing the difference in seconds and nanoseconds while handling edge cases for negative durations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nTimestamp start = ...;\nTimestamp end = ...;\nDuration duration = ...;\n\nduration.seconds = end.seconds - start.seconds;\nduration.nanos = end.nanos - start.nanos;\n\nif (duration.seconds < 0 && duration.nanos > 0) {\n  duration.seconds += 1;\n  duration.nanos -= 1000000000;\n} else if (duration.seconds > 0 && duration.nanos < 0) {\n  duration.seconds -= 1;\n  duration.nanos += 1000000000;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Constants for Package-Level Enum\nDESCRIPTION: Shows how the constants for a package-level enum are prefixed with the enum name in the generated Go code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nconst (\n    Genre_GENRE_UNSPECIFIED   Genre = 0\n    Genre_GENRE_ROCK          Genre = 1\n    Genre_GENRE_INDIE         Genre = 2\n    Genre_GENRE_DRUM_AND_BASS Genre = 3\n)\n```\n\n----------------------------------------\n\nTITLE: JSON Representation of Any Type with Well-Known Type Duration\nDESCRIPTION: Example of how the Any type is represented in JSON when containing a well-known type like Duration. Shows how well-known types use a special value field for their custom JSON representation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n  \"value\": \"1.212s\"\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Duration Between Time Units and Timedelta\nDESCRIPTION: Example of using methods to convert between nanoseconds and Python timedelta objects with Duration messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nduration_message.FromNanoseconds(1999999999)\ntd = duration_message.ToTimedelta()\nassert td.seconds == 1\nassert td.microseconds == 999999\n```\n\n----------------------------------------\n\nTITLE: Accessing C++ Enum Values with IsValid Function\nDESCRIPTION: Example showing proper checking of enum values with the generated IsValid function. This is important for proto3 enums to handle unknown values safely.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_40\n\nLANGUAGE: cpp\nCODE:\n```\nFoo foo;\nassert(!foo.HasExtension(bar));\nfoo.SetExtension(bar, 1);\nassert(foo.HasExtension(bar));\nassert(foo.GetExtension(bar) == 1);\nfoo.ClearExtension(bar);\nassert(!foo.HasExtension(bar));\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Method in Python\nDESCRIPTION: Shows the Python method signature generated for an RPC service method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_49\n\nLANGUAGE: python\nCODE:\n```\ndef Bar(self, rpc_controller, request, done)\n```\n\n----------------------------------------\n\nTITLE: Proto3 Message Definition with Implicit and Explicit Presence\nDESCRIPTION: Example of a Proto3 message definition containing both implicit presence (default behavior) and explicit presence (using the optional keyword) fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage example;\n\nmessage MyMessage {\n  // implicit presence:\n  int32 not_tracked = 1;\n\n  // Explicit presence:\n  optional int32 tracked = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Map Class Template in C++ Protocol Buffers\nDESCRIPTION: Definition of the Map class template used for storing protocol buffer map fields. It provides an interface similar to std::unordered_map but is designed to work without exceptions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.map.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename Key, typename T>\nclass Map {\npublic:\n    typedef Key key_type;\n    typedef T mapped_type;\n    typedef MapPair<Key, T> value_type;\n    // ... other type definitions ...\n\n    constexpr Map();\n    explicit Map(Arena* arena);\n    Map(const Map& other);\n    Map(Map&& other);\n    Map& operator=(Map&& other);\n    template <typename InputIt>\n    Map(const InputIt& first, const InputIt& last);\n    ~Map();\n\n    // ... iterator functions ...\n    // ... capacity functions ...\n    // ... element access functions ...\n    // ... modifiers ...\n    // ... lookup ...\n    // ... bucket interface ...\n    // ... hash policy ...\n    // ... observers ...\n};\n```\n\n----------------------------------------\n\nTITLE: Clearing RepeatedField in C++\nDESCRIPTION: Clears all elements from the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvoid Clear()\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Java Files Generation in Protocol Buffers\nDESCRIPTION: Demonstrates setting the java_multiple_files option to generate separate .java files for each top-level message, service, and enumeration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_27\n\nLANGUAGE: proto\nCODE:\n```\noption java_multiple_files = true;\n```\n\n----------------------------------------\n\nTITLE: Registering Generated Protocol Buffer Files in C++\nDESCRIPTION: Registers a .proto file at static initialization time to be placed in generated_factory. Used internally to enable lazy descriptor building, allowing message types to be registered when their descriptor becomes available.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_72\n\nLANGUAGE: C++\nCODE:\n```\nstatic void MessageFactory::InternalRegisterGeneratedFile(\n        const google::protobuf::internal::DescriptorTable * table)\n```\n\n----------------------------------------\n\nTITLE: Finding Message Type by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up a Descriptor by its fully-qualified name. Returns the corresponding message descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_108\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor * FindMessageTypeByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Getting Boolean and String Field Values in C++\nDESCRIPTION: Methods for getting bool and string field values from a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nbool GetBool(const Message& message, const FieldDescriptor* field) const\nstd::string GetString(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Enumerations in Protocol Buffers\nDESCRIPTION: Example of defining an enumeration type in a Protocol Buffer (.proto) file, showing value declarations with explicit numeric values assigned to each enum constant.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_22\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  VALUE_A = 0;\n  VALUE_B = 5;\n  VALUE_C = 1234;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nested Message Extension\nDESCRIPTION: Demonstrates how to use an extension identifier that is nested within another message type. The example shows modifying an extension field that is a nested message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_42\n\nLANGUAGE: cpp\nCODE:\n```\nFoo foo;\nBaz* baz = foo.MutableExtension(Baz::foo_ext);\nFillInMyBaz(baz);\n```\n\n----------------------------------------\n\nTITLE: Reserving Field Numbers in Protocol Buffers\nDESCRIPTION: Demonstrates how to reserve field numbers that have been deleted or commented out to prevent future reuse. This is crucial for maintaining backwards compatibility and avoiding potential issues with message parsing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Failure Check (C++)\nDESCRIPTION: Returns true if any write to the underlying stream failed. Used for I/O failure detection.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\nbool Printer::failed() const\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define map fields in Protocol Buffers. The compiler generates accessor methods working with Go map types for these fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_12\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage MerchItem {}\n\nmessage MerchBooth {\n  map<string, MerchItem> items = 1;\n}\n```\n\nLANGUAGE: go\nCODE:\n```\ntype MerchBooth struct { ... }\n\nfunc (m *MerchBooth) GetItems() map[string]*MerchItem { ... }\nfunc (m *MerchBooth) SetItems(v map[string]*MerchItem) { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum Type in Protocol Buffers\nDESCRIPTION: Definition of an enum type named Bar with three values: BAR_UNSPECIFIED (0), BAR_VALUE (1), and BAR_OTHER_VALUE (2). This follows the Protocol Buffers best practice of starting with an unspecified zero value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_25\n\nLANGUAGE: proto\nCODE:\n```\nenum Bar {\n  BAR_UNSPECIFIED = 0;\n  BAR_VALUE = 1;\n  BAR_OTHER_VALUE = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Proto2 to Protobuf Editions Syntax\nDESCRIPTION: Demonstration of how a proto2 file can be converted to the new Protobuf Editions syntax, using the 2023 edition and explicit feature overrides.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-06-29.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\n// Editions version of proto2 file\nedition = \"2023\";\n\nmessage Player {\n  string name = 1;\n  int32 id = 2 [features.field_presence = LEGACY_REQUIRED];\n  repeated int32 scores = 3 [features.repeated_field_encoding = EXPANDED];\n\n  enum Handed {\n    // this overrides the default Edition 2023 behavior, which is OPEN\n    option features.enum = CLOSED;\n    HANDED_UNSPECIFIED = 0,\n    HANDED_LEFT = 1,\n    HANDED_RIGHT = 2,\n    HANDED_AMBIDEXTROUS = 3,\n  }\n\n  Handed handed = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating CodedOutputStream with eager refresh option in C++\nDESCRIPTION: Alternative constructor for CodedOutputStream that accepts a ZeroCopyOutputStream and a boolean flag to control eager refreshing behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_68\n\nLANGUAGE: C++\nCODE:\n```\nCodedOutputStream(ZeroCopyOutputStream* stream, bool do_eager_refresh)\n```\n\n----------------------------------------\n\nTITLE: Defining Identifiers in Protocol Buffers\nDESCRIPTION: Specifies the syntax for different types of identifiers used in Protocol Buffers, including message names, field names, and fully qualified identifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nident = letter { letter | decimalDigit | \"_\" }\nfullIdent = ident { \".\" ident }\nmessageName = ident\nenumName = ident\nfieldName = ident\noneofName = ident\nmapName = ident\nserviceName = ident\nrpcName = ident\nstreamName = ident\nmessageType = [ \".\" ] { ident \".\" } messageName\nenumType = [ \".\" ] { ident \".\" } enumName\ngroupName = capitalLetter { letter | decimalDigit | \"_\" }\n```\n\n----------------------------------------\n\nTITLE: Computing Timestamp from POSIX time() in C++\nDESCRIPTION: Creates a Protocol Buffer Timestamp by setting the seconds field from the POSIX time() function and setting nanos to 0. This provides second-level precision.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nTimestamp timestamp;\ntimestamp.set_seconds(time(NULL));\ntimestamp.set_nanos(0);\n```\n\n----------------------------------------\n\nTITLE: Defining Message Extensions in Protocol Buffers\nDESCRIPTION: Example of declaring an extension range in a Protocol Buffer message, which allows the message to be extended with additional fields outside its original definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_25\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 100 to 199;\n}\n```\n\n----------------------------------------\n\nTITLE: Scalar Field Access Comparison\nDESCRIPTION: Demonstrates how to access and manipulate scalar fields in both APIs, including getting, setting, checking presence, and clearing fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Getting the value.\ns := m.GetBirthYear()\n\n// Setting the field.\nm.BirthYear = proto.Int32(1989)\n\n// Check for presence.\nif s.BirthYear != nil { … }\n\n// Clearing the field.\nm.BirthYear = nil\n```\n\nLANGUAGE: go\nCODE:\n```\n// Getting the field value.\ns := m.GetBirthYear()\n\n// Setting the field.\nm.SetBirthYear(1989)\n\n// Check for presence.\nif m.HasBirthYear() { … }\n\n// Clearing the field\nm.ClearBirthYear()\n```\n\n----------------------------------------\n\nTITLE: Extend Example in Protocol Buffers\nDESCRIPTION: Demonstrates the extension of a message in Protocol Buffers by adding a new field to an extendable message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_32\n\nLANGUAGE: proto\nCODE:\n```\nextend Foo {\n  int32 bar = 126;\n}\n```\n\n----------------------------------------\n\nTITLE: Message Field Management (C++)\nDESCRIPTION: Methods for managing message fields, including clearing fields and handling unknown fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void DiscardUnknownFields();\nvirtual void Clear();\nvirtual bool IsInitialized() const;\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Objects on Arena (C++)\nDESCRIPTION: API to create any objects on the arena. Only the object is created on the arena; underlying pointers are still heap-allocated. Does not follow the arena message construction protocol for types with InternalArenaConstructable_ trait.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static PROTOBUF_NDEBUG_INLINE T * \n    Arena::Create(\n        Arena * arena,\n        Args &&... args)\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor Protocol Type Enum in Protocol Buffers\nDESCRIPTION: Declaration of the FieldDescriptorProto_Type enum that defines the possible data types for fields in Protocol Buffers. This enum is used within descriptors to specify the data type of a field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldDescriptorProto_Type\n```\n\n----------------------------------------\n\nTITLE: Serializing Protocol Buffer Messages in C++\nDESCRIPTION: Collection of methods for serializing Protocol Buffer messages to various output formats. Includes methods for full and partial serialization, with options for different output targets like streams, strings, arrays, and file descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nbool SerializeToCodedStream(io::CodedOutputStream* output) const\nbool SerializePartialToCodedStream(io::CodedOutputStream* output) const\nbool SerializeToZeroCopyStream(io::ZeroCopyOutputStream* output) const\nbool SerializePartialToZeroCopyStream(io::ZeroCopyOutputStream* output) const\nbool SerializeToString(std::string* output) const\nbool SerializePartialToString(std::string* output) const\nbool SerializeToArray(void* data, int size) const\nbool SerializePartialToArray(void* data, int size) const\nstd::string SerializeAsString() const\nstd::string SerializePartialAsString() const\nbool SerializeToFileDescriptor(int file_descriptor) const\nbool SerializePartialToFileDescriptor(int file_descriptor) const\nbool SerializeToOstream(std::ostream* output) const\nbool SerializePartialToOstream(std::ostream* output) const\nbool AppendToString(std::string* output) const\nbool AppendPartialToString(std::string* output) const\nvirtual size_t ByteSizeLong() const = 0\nint ByteSize() const\nvoid SerializeWithCachedSizes(io::CodedOutputStream* output) const\nuint8* SerializeWithCachedSizesToArray(uint8* target) const\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Structs and Lists in Python\nDESCRIPTION: Demonstrates the use of get_or_create_list() and get_or_create_struct() methods to create and access nested structures within a Struct message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nstruct.get_or_create_struct(\"key4\")[\"subkey\"] = 11.0\nstruct.get_or_create_list(\"key5\")\n```\n\n----------------------------------------\n\nTITLE: Adding Values to Repeated Fields in Protocol Buffers (C++)\nDESCRIPTION: Method definitions for adding various data types to Protocol Buffer repeated fields. These methods allow adding integer, float, boolean, string, enum, and message values to a repeated field of a protobuf message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_46\n\nLANGUAGE: C++\nCODE:\n```\nAddUInt64(Message * message, const FieldDescriptor * field, uint64 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddFloat(Message * message, const FieldDescriptor * field, float value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddDouble(Message * message, const FieldDescriptor * field, double value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddBool(Message * message, const FieldDescriptor * field, bool value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddString(Message * message, const FieldDescriptor * field, std::string value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddEnum(Message * message, const FieldDescriptor * field, const EnumValueDescriptor * value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddEnumValue(Message * message, const FieldDescriptor * field, int value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nAddAllocatedMessage(Message * message, const FieldDescriptor * field, Message * new_entry) const\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Enumerations with Synonyms in Protocol Buffers\nDESCRIPTION: Example showing how to define enum values with the same numeric value (synonyms) in Protocol Buffers. When multiple symbols share the same value, the first one becomes canonical.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_23\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  BAR = 0;\n  BAZ = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Open Struct API Oneof Operations\nDESCRIPTION: Example code showing oneof field operations using the Open Struct API, including type switching and field access.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_13\n\nLANGUAGE: go\nCODE:\n```\n// Getting the oneof field that is set.\nswitch m.GetAvatar().(type) {\ncase *pb.Profile_ImageUrl:\n  … = m.GetImageUrl()\ncase *pb.Profile_ImageData:\n  … = m.GetImageData()\n}\n\n// Setting the fields.\nm.Avatar = &pb.Profile_ImageUrl{\"http://\"}\nm.Avatar = &pb.Profile_ImageData{img}\n\n// Checking whether any oneof field is set\nif m.Avatar != nil { … }\n\n// Clearing the field.\nm.Avatar = nil\n\n// Checking if a specific field is set.\n_, ok := m.GetAvatar().(*pb.Profile_ImageUrl)\nif ok { … }\n\n// Clearing a specific field\n_, ok := m.GetAvatar().(*pb.Profile_ImageUrl)\nif ok {\n  m.Avatar = nil\n}\n\n// Copy a oneof field.\nm.Avatar = src.Avatar\n```\n\n----------------------------------------\n\nTITLE: Proto2 Enum Definition\nDESCRIPTION: Defines the syntax for enum declarations in Protocol Buffers, which create a set of named constants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_29\n\nLANGUAGE: ebnf\nCODE:\n```\nenum = \"enum\" enumName enumBody\nenumBody = \"{\" { option | enumField | emptyStatement | reserved } \"}\"\nenumField = ident \"=\" [ \"-\" ] intLit [ \"[\" enumValueOption { \",\"  enumValueOption } \"]\" ]\";\"\nenumValueOption = optionName \"=\" constant\n```\n\n----------------------------------------\n\nTITLE: Defining Arena Block Overhead Constant in C++\nDESCRIPTION: Defines a constant for the block overhead in the Arena class. This constant is used to guide initial block allocation sizes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconst size_t kBlockOverhead = =\n      internal::ThreadSafeArena::kBlockHeaderSize +\n      internal::ThreadSafeArena::kSerialArenaSize\n```\n\n----------------------------------------\n\nTITLE: Using Any Type in Protocol Buffers\nDESCRIPTION: Demonstrates how to use the Any type to embed arbitrary message types, requiring google/protobuf/any.proto import.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/any.proto\";\n\nmessage ErrorStatus {\n  string message = 1;\n  repeated google.protobuf.Any details = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Oneof Fields with Type Switch in Go\nDESCRIPTION: Example showing how to access oneof fields using a type switch to handle different possible field types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nswitch x := m.Avatar.(type) {\ncase *account.Profile_ImageUrl:\n    // Load profile image based on URL\n    // using x.ImageUrl\ncase *account.Profile_ImageData:\n    // Load profile image based on bytes\n    // using x.ImageData\ncase nil:\n    // The field is not set.\ndefault:\n    return fmt.Errorf(\"Profile.Avatar has unexpected type %T\", x)\n}\n```\n\n----------------------------------------\n\nTITLE: FieldMask Operations\nDESCRIPTION: Methods for performing operations on FieldMasks including union, intersection, and subtraction.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstatic void Union(const FieldMask& mask1, const FieldMask& mask2, FieldMask* out);\nstatic void Intersect(const FieldMask& mask1, const FieldMask& mask2, FieldMask* out);\ntemplate static void Subtract(const FieldMask& mask1, const FieldMask& mask2, FieldMask* out);\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Message Fields in Protocol Buffers\nDESCRIPTION: Shows how to define singular message fields in both proto2 and proto3. The compiler generates accessor methods for getting, setting, checking presence, and clearing these fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_9\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Band {}\n\n// proto2\nmessage Concert {\n  optional Band headliner = 1;\n}\n\n// proto3\nmessage Concert {\n  Band headliner = 1;\n}\n```\n\nLANGUAGE: go\nCODE:\n```\ntype Concert struct { ... }\n\nfunc (m *Concert) GetHeadliner() *Band { ... }\nfunc (m *Concert) SetHeadliner(v *Band) { ... }\nfunc (m *Concert) HasHeadliner() bool { ... }\nfunc (m *Concert) ClearHeadliner() { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining GeneratedCodeInfo Message in Protocol Buffers\nDESCRIPTION: Defines a message for describing the relationship between generated code and its original source file, including annotations for connecting generated code to source elements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_17\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage GeneratedCodeInfo {\n  repeated Annotation annotation = 1;\n  message Annotation {\n    repeated int32 path = 1 [packed = true];\n    optional string source_file = 2;\n    optional int32 begin = 3;\n    optional int32 end = 4;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ByteString Get Operator in Kotlin Protocol Buffers\nDESCRIPTION: Kotlin operator function that enables index-based access to bytes within a ByteString. This allows for treating ByteString similarly to an array or collection when retrieving individual bytes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\noperator fun ByteString.get(index: Int): Byte\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Example of oneof field definition showing mutually exclusive field options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\noneof choice {\n    int32 foo_int = 4;\n    string foo_string = 9;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Packed Encoding for Repeated Fields in Protocol Buffers\nDESCRIPTION: Sets a repeated numeric field to use packed encoding format for more compact binary representation. Safe to use with parsers from version 2.3.0 and later.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_48\n\nLANGUAGE: proto\nCODE:\n```\nrepeated int32 samples = 4 [packed = true];\n```\n\n----------------------------------------\n\nTITLE: Opaque API Map Operations\nDESCRIPTION: Example code showing map operations using the new Opaque API, demonstrating the updated syntax for accessing and modifying map fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// Getting the entire map value.\nv := m.GetItems()\n\n// Setting the field.\nm.SetItems(v)\n\n// Get an element in a map field.\nv := m.GetItems()[k]\n\n// Set an element in a map field.\n// This will panic if m.GetItems() is nil.\n// You should check m.GetItems() for nil\n// before doing the assignment to ensure\n// it won't panic.\nm.GetItems()[k] = v\n\n// Delete an element in a map field.\ndelete(m.GetItems(), k)\n\n// Get the size of a map field.\nn := len(m.GetItems())\n\n// Clearing the field.\nm.SetItems(nil)\n```\n\n----------------------------------------\n\nTITLE: Serializing Protocol Buffer Messages with proto.Marshal in Go\nDESCRIPTION: Code snippet showing how to serialize a protocol buffer message to its binary wire format using proto.Marshal and write it to a file. The example handles error cases for both serialization and file writing operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nbook := &pb.AddressBook{}\n// ...\n\n// Write the new address book back to disk.\nout, err := proto.Marshal(book)\nif err != nil {\n    log.Fatalln(\"Failed to encode address book:\", err)\n}\nif err := ioutil.WriteFile(fname, out, 0644); err != nil {\n    log.Fatalln(\"Failed to write address book:\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Oneof Enum in Rust\nDESCRIPTION: Generated Rust enum types for oneof fields with variants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[non_exhaustive]\n#[derive(Debug, Clone, Copy)]\npub enum ExampleNameOneof<'msg> {\n  FooInt(i32) = 4,\n  FooString(&'msg protobuf::ProtoStr) = 9,\n  not_set(std::marker::PhantomData<&'msg ()>) = 0\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum ExampleNameCase {\n  FooInt = 4,\n  FooString = 9,\n  not_set = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Message Serialization Operations (C++)\nDESCRIPTION: Methods for message serialization, including size calculation and internal serialization implementation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nvirtual size_t ByteSizeLong() const;\nvirtual uint8* _InternalSerialize(uint8* ptr, io::EpsCopyOutputStream* stream) const;\n```\n\n----------------------------------------\n\nTITLE: Nested Type Operations in Protocol Buffers\nDESCRIPTION: Methods for accessing and looking up nested type definitions within protocol buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor* Descriptor::nested_type(int index) const\nconst Descriptor* Descriptor::FindNestedTypeByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor Proto Types Enum in Protocol Buffers\nDESCRIPTION: Enumeration defining all possible field types in Protocol Buffers including primitive types like integers, floats, strings as well as message and group types\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\nenum protobuf::FieldDescriptorProto_Type {\n  FieldDescriptorProto_Type_TYPE_DOUBLE = = 1,\n  FieldDescriptorProto_Type_TYPE_FLOAT = = 2,\n  FieldDescriptorProto_Type_TYPE_INT64 = = 3,\n  FieldDescriptorProto_Type_TYPE_UINT64 = = 4,\n  FieldDescriptorProto_Type_TYPE_INT32 = = 5,\n  FieldDescriptorProto_Type_TYPE_FIXED64 = = 6,\n  FieldDescriptorProto_Type_TYPE_FIXED32 = = 7,\n  FieldDescriptorProto_Type_TYPE_BOOL = = 8,\n  FieldDescriptorProto_Type_TYPE_STRING = = 9,\n  FieldDescriptorProto_Type_TYPE_GROUP = = 10,\n  FieldDescriptorProto_Type_TYPE_MESSAGE = = 11,\n  FieldDescriptorProto_Type_TYPE_BYTES = = 12,\n  FieldDescriptorProto_Type_TYPE_UINT32 = = 13,\n  FieldDescriptorProto_Type_TYPE_ENUM = = 14,\n  FieldDescriptorProto_Type_TYPE_SFIXED32 = = 15,\n  FieldDescriptorProto_Type_TYPE_SFIXED64 = = 16,\n  FieldDescriptorProto_Type_TYPE_SINT32 = = 17,\n  FieldDescriptorProto_Type_TYPE_SINT64 = = 18\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Internal Serialization Method in C++\nDESCRIPTION: Declares a virtual method for internal serialization of a MessageLite object. It takes a pointer to a buffer and an EpsCopyOutputStream, returning a pointer to the byte after the last written byte.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvirtual uint8 * MessageLite::_InternalSerialize(\n    uint8 * ptr,\n    io::EpsCopyOutputStream * stream) const = 0\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Generic Services\nDESCRIPTION: Proto options for enabling or disabling generic service code generation in Python.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_47\n\nLANGUAGE: proto\nCODE:\n```\noption py_generic_services = true;\n```\n\nLANGUAGE: proto\nCODE:\n```\noption py_generic_services = false;\n```\n\n----------------------------------------\n\nTITLE: Listing Set Fields of a Message in C++\nDESCRIPTION: Lists all fields of the message which are currently set, excluding unknown fields but including extensions known to the parser.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\nvoid ListFields(const Message& message, std::vector<const FieldDescriptor*>* output) const\n```\n\n----------------------------------------\n\nTITLE: Examples of Prohibited Naming Conflicts in Proto3\nDESCRIPTION: Demonstrates examples of prohibited naming conflicts in Protocol Buffers messages, where entities within the same message cannot have the same name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_30\n\nLANGUAGE: proto3\nCODE:\n```\nmessage MyMessage {\n  optional string foo = 1;\n  message foo {}\n}\n\nmessage MyMessage {\n  optional string foo = 1;\n  oneof foo {\n    string bar = 2;\n  }\n}\n\nmessage MyMessage {\n  optional string foo = 1;\n  enum E {\n    foo = 0;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Proto File with Package Definition\nDESCRIPTION: A simple protocol buffer definition file showing package declaration and message definition. This example defines a package 'foo.bar' with a message 'MyMessage'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\nmessage MyMessage {}\n```\n\n----------------------------------------\n\nTITLE: Converting Protocol Buffer Map to Standard Map\nDESCRIPTION: Example showing how to convert a google::protobuf::Map to a standard C++ map using iterators.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_33\n\nLANGUAGE: cpp\nCODE:\n```\nstd::map<int32, int32> standard_map(message.weight().begin(),\n                                    message.weight().end());\n```\n\n----------------------------------------\n\nTITLE: Using Any Fields in Protocol Buffers Text Format\nDESCRIPTION: Shows how to use the expanded form of google.protobuf.Any type in Protocol Buffers text format, including both regular fields and Any expansion syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_21\n\nLANGUAGE: textproto\nCODE:\n```\nlocal_field: 10\n\n# An Any value using regular fields.\nany_value {\n  type_url: \"type.googleapis.com/com.example.SomeType\"\n  value: \"\\x0a\\x05hello\"  # serialized bytes of com.example.SomeType\n}\n\n# The same value using Any expansion\nany_value {\n  [type.googleapis.com/com.example.SomeType] {\n    field1: \"hello\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Dart List for Enum Values\nDESCRIPTION: This snippet shows how the Protocol Buffers compiler generates a static list of enum values in Dart. It creates a List<Color> containing all the defined enum values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nstatic const List<Color> values = <Color> [\n  COLOR_UNSPECIFIED,\n  COLOR_RED,\n  COLOR_GREEN,\n  COLOR_BLUE,\n];\n```\n\n----------------------------------------\n\nTITLE: Base64 Bytes Encoding\nDESCRIPTION: Demonstrates how bytes fields are encoded as base64 strings in JSON format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/json.md#2025-04-11_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"YWJjMTIzIT8kKiYoKSctPUB+\"\n```\n\n----------------------------------------\n\nTITLE: Go Map Field Accessor Methods\nDESCRIPTION: Generated Go accessor methods for map fields, showing the Get and Set method signatures for accessing map data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (m *MerchBooth) GetItems() map[string]*MerchItem\nfunc (m *MerchBooth) SetItems(map[string]*MerchItem)\n```\n\n----------------------------------------\n\nTITLE: Working with Reserved Fields in EnumDescriptor\nDESCRIPTION: Methods to access reserved ranges and names in Protocol Buffer enum types, used to prevent field number and name conflicts during schema evolution.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_53\n\nLANGUAGE: C++\nCODE:\n```\nint reserved_range_count() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumDescriptor::ReservedRange* reserved_range(int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool IsReservedNumber(int number) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumDescriptor::ReservedRange* FindReservedRangeContainingNumber(int number) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nint reserved_name_count() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& reserved_name(int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool IsReservedName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining Message Hierarchy with Default Values in Protocol Buffers\nDESCRIPTION: A Protocol Buffer example showing a message hierarchy with optional fields and a default value declaration. This illustrates how default values are specified in .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/design-decisions/nullable-getters-setters.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nmessage Msg { optional Child child = 1; }\nmessage Child { optional Grandchild grandchild = 1; }\nmessage Grandchild { optional int32 foo = 1 [default = 72]; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Options in Python\nDESCRIPTION: Demonstrates how to access a custom option value in Python by getting the message descriptor, retrieving its options, and accessing the extension via the Extensions dictionary.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nvalue = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions()\n  .Extensions[my_proto_file_pb2.my_option]\n```\n\n----------------------------------------\n\nTITLE: Generated Java Enum for Oneof Fields\nDESCRIPTION: Java enum code generated by protoc for handling oneof field cases.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: java\nCODE:\n```\npublic enum ChoiceCase\n        implements com.google.protobuf.Internal.EnumLite {\n      FOO_INT(4),\n      FOO_STRING(9),\n      ...\n      CHOICE_NOT_SET(0);\n      ...\n    };\n```\n\n----------------------------------------\n\nTITLE: Working with Repeated Protocol Buffer Extensions\nDESCRIPTION: Shows how to use extension accessors to manipulate repeated extension fields. The example adds multiple values to a repeated extension field and then accesses them.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_41\n\nLANGUAGE: cpp\nCODE:\n```\nFoo foo;\nfor (int i = 0; i < kSize; ++i) {\n  foo.AddExtension(repeated_bar, i)\n}\nassert(foo.ExtensionSize(repeated_bar) == kSize)\nfor (int i = 0; i < kSize; ++i) {\n  assert(foo.GetExtension(repeated_bar, i) == i)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Group Fields in Protocol Buffers Text Format\nDESCRIPTION: Demonstrates how to use group fields in Protocol Buffers text format, using the capitalized group name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_23\n\nLANGUAGE: textproto\nCODE:\n```\nMyGroup {\n  my_value: 1\n}\n```\n\n----------------------------------------\n\nTITLE: Using Extension Fields in Java\nDESCRIPTION: Demonstrates how to set, check, and access Protocol Buffer extension fields in Java. Extensions are accessed through special methods using extension identifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_27\n\nLANGUAGE: java\nCODE:\n```\nFoo foo =\n  Foo.newBuilder()\n     .setExtension(bar, 1)\n     .build();\nassert foo.hasExtension(bar);\nassert foo.getExtension(bar) == 1;\n```\n\n----------------------------------------\n\nTITLE: Implementing toString() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the toString() function to provide a String representation of the ExtensionList.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_7\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen override fun toString(): String\n```\n\n----------------------------------------\n\nTITLE: Getting File Options in FileDescriptor (C++)\nDESCRIPTION: Returns options for this file as specified in the .proto file via 'option' statements at the top level. Options are defined by FileOptions in descriptor.proto, along with any available extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_91\n\nLANGUAGE: C++\nCODE:\n```\nconst FileOptions & \n    FileDescriptor::options() const\n```\n\n----------------------------------------\n\nTITLE: Extracting Element Subrange from RepeatedPtrField\nDESCRIPTION: Extracts elements from a specified range in a RepeatedPtrField, transferring ownership to the caller. If elements is non-NULL, pointers to extracted elements are stored there. When used with an arena, performs object copies.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_49\n\nLANGUAGE: cpp\nCODE:\n```\nvoid RepeatedPtrField::ExtractSubrange(\n        int start,\n        int num,\n        Element ** elements)\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Range in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define an extension range in a container message. It reserves field numbers 100 to 199 for extensions and sets verification to DECLARATION.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\n// file media/user_content.proto\n\npackage media;\n\n// A container message to hold stuff that a user has created.\nmessage UserContent {\n  // Set verification to `DECLARATION` to enforce extension declarations for all\n  // extensions in this range.\n  extensions 100 to 199 [verification = DECLARATION];\n}\n```\n\n----------------------------------------\n\nTITLE: Including Protocol Buffer Descriptor Header\nDESCRIPTION: Shows how to include the Protocol Buffers descriptor header file and access the google::protobuf namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/descriptor.h>\nnamespace google::protobuf\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compilation Command\nDESCRIPTION: Shell command for compiling the proto file into C# classes using the protoc compiler.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nprotoc -I=$SRC_DIR --csharp_out=$DST_DIR $SRC_DIR/addressbook.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Scalar Fields in Protocol Buffers (proto3)\nDESCRIPTION: Demonstrates how to define singular scalar fields in proto3, including optional fields. The compiler generates accessor methods, with presence checks only for optional fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_8\n\nLANGUAGE: protobuf\nCODE:\n```\nint32 birth_year = 1;\noptional int32 first_active_year = 2;\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc (m *Artist) GetBirthYear() int32 { ... }\nfunc (m *Artist) SetBirthYear(v int32) { ... }\n\nfunc (m *Artist) GetFirstActiveYear() int32 { ... }\nfunc (m *Artist) SetFirstActiveYear(v int32) { ... }\nfunc (m *Artist) HasFirstActiveYear() bool { ... }\nfunc (m *Artist) ClearFirstActiveYear() { ... }\n```\n\n----------------------------------------\n\nTITLE: PHP Class Generated from Enum\nDESCRIPTION: Example of PHP class generated from a Protocol Buffer enum definition. Since PHP doesn't have native enums, they're represented as classes with constants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: php\nCODE:\n```\nclass TestEnum {\n  const DEFAULT = 0;\n  const A = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Descriptor Members in C++\nDESCRIPTION: Demonstrates how to access various members of the Descriptor class, including name, full name, and options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& name() const;\nconst std::string& full_name() const;\nint index() const;\nconst FileDescriptor* file() const;\nconst Descriptor* containing_type() const;\nconst MessageOptions& options() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Group Fields in Protocol Buffers\nDESCRIPTION: Illustrates how to define group fields in a Protocol Buffers message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_22\n\nLANGUAGE: proto\nCODE:\n```\nmessage MessageWithGroup {\n  optional group MyGroup = 1 {\n    optional int32 my_value = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating JSON Formatter Options in Java, C++, and Python\nDESCRIPTION: This code snippet demonstrates the replacement of deprecated JSON formatter options with new options that handle proto2 and proto3 optional fields more consistently. The change affects Java, C++, and Python implementations in Protocol Buffers 26.x.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-02-05.md#2025-04-11_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n// Old approach (deprecated)\nincludingDefaultValueFields()\n\n// New approach\nalwaysPrintFieldsWithNoPresence()\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Old approach (deprecated)\nalways_print_default_values\n\n// New approach\nalways_print_fields_with_no_presence=True\n```\n\nLANGUAGE: Python\nCODE:\n```\n# Old approach (deprecated)\nincluding_default_value_fields=True\n\n# New approach\nalways_print_fields_with_no_presence=True\n```\n\n----------------------------------------\n\nTITLE: JSON to Binary Stream Conversion\nDESCRIPTION: Converts JSON data to Protocol Buffer binary format using streams. Requires a TypeResolver and type URL for conversion.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nutil::Status JsonToBinaryStream(\n    TypeResolver* resolver,\n    const std::string& type_url,\n    io::ZeroCopyInputStream* json_input,\n    io::ZeroCopyOutputStream* binary_output,\n    const JsonParseOptions& options)\n```\n\n----------------------------------------\n\nTITLE: Generated Oneof Field Methods\nDESCRIPTION: Generated Go code showing the accessor methods for individual oneof fields, including Get, Set, Has, and Clear methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc (m *Profile) GetImageUrl() string { … }\nfunc (m *Profile) GetImageData() []byte { … }\n\nfunc (m *Profile) SetImageUrl(v string) { … }\nfunc (m *Profile) SetImageData(v []byte) { … }\n\nfunc (m *Profile) HasImageUrl() bool { … }\nfunc (m *Profile) HasImageData() bool { … }\n\nfunc (m *Profile) ClearImageUrl() { … }\nfunc (m *Profile) ClearImageData() { … }\n```\n\n----------------------------------------\n\nTITLE: JSON Print Options Structure Definition (C++)\nDESCRIPTION: Defines options for printing Protocol Buffers as JSON. Includes formatting options like whitespace, primitive field printing, enum formatting, and field name preservation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nstruct JsonPrintOptions {\n    bool add_whitespace;\n    bool always_print_primitive_fields;\n    bool always_print_enums_as_ints;\n    bool preserve_proto_field_names;\n    JsonPrintOptions();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generated PHP Protocol Buffer Classes\nDESCRIPTION: Example showing how to create a Protocol Buffer message, set fields, serialize data, and deserialize it. This demonstrates the basic methods available in generated PHP classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n$from = new Foo();\n$from->setInt32(1);\n$from->setString('a');\n$from->getRepeatedInt32()[] = 1;\n$from->getMapInt32Int32()[1] = 1;\n$data = $from->serializeToString();\ntry {\n  $to->mergeFromString($data);\n} catch (Exception $e) {\n  // Handle parsing error from invalid data.\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Path to FieldMask in Protocol Buffers C++\nDESCRIPTION: Adds a validated path to a FieldMask. Check-fails if the path is not valid for type T.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static void FieldMaskUtil::AddPathToFieldMask(\n        StringPiece path,\n        FieldMask * mask)\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Complex Message\nDESCRIPTION: The Objective-C code generated by the protoc compiler for a complex message definition including enums and field definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: objc\nCODE:\n```\n# Enum Foo_Qux\n\ntypedef GPB_ENUM(Foo_Qux) {\n  Foo_Qux_Flupple = 0,\n};\n\nGPBEnumDescriptor *Foo_Qux_EnumDescriptor(void);\n\nBOOL Foo_Qux_IsValidValue(int32_t value);\n\n# Message Foo\n\ntypedef GPB_ENUM(Foo_FieldNumber) {\n  Foo_FieldNumber_Int32Value = 2,\n  Foo_FieldNumber_MessageValue = 3,\n  Foo_FieldNumber_EnumValue = 4,\n  Foo_FieldNumber_BytesValue = 5,\n  Foo_FieldNumber_StringValue = 6,\n};\n\n@interface Foo : GPBMessage\n\n@property(nonatomic, readwrite) BOOL hasInt32Value;\n@property(nonatomic, readwrite) int32_t int32Value;\n\n@property(nonatomic, readwrite) BOOL hasStringValue;\n@property(nonatomic, readwrite, copy, null_resettable) NSString *stringValue;\n\n@property(nonatomic, readwrite) BOOL hasMessageValue;\n@property(nonatomic, readwrite, strong, null_resettable) Foo_Bar *messageValue;\n\n@property(nonatomic, readwrite) BOOL hasEnumValue;\n@property(nonatomic, readwrite) Foo_Qux enumValue;\n\n@property(nonatomic, readwrite) BOOL hasBytesValue;\n@property(nonatomic, readwrite, copy, null_resettable) NSData *bytesValue;\n\n@end\n\n# Message Foo_Bar\n\ntypedef GPB_ENUM(Foo_Bar_FieldNumber) {\n  Foo_Bar_FieldNumber_Int32Value = 1,\n};\n\n@interface Foo_Bar : GPBMessage\n\n@property(nonatomic, readwrite) BOOL hasInt32Value;\n@property(nonatomic, readwrite) int32_t int32Value;\n\n@end\n```\n\n----------------------------------------\n\nTITLE: Defining Normal Fields in Proto3\nDESCRIPTION: Specifies the syntax for normal fields in Protocol Buffers, including field options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_18\n\nLANGUAGE: ebnf\nCODE:\n```\nfield = [ \"repeated\" | \"optional\" ] type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\nfieldOptions = fieldOption { \",\"  fieldOption }\nfieldOption = optionName \"=\" constant\n```\n\n----------------------------------------\n\nTITLE: Proto2 Oneof Field Presence Checks in Ruby\nDESCRIPTION: Shows how to check field presence for oneof fields in Proto2 messages using has_* methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: ruby\nCODE:\n```\nmessage = Foo.new\n\nraise unless !message.has_test_oneof?\nraise unless !message.has_name?\nraise unless !message.has_serial_number?\nraise unless !message.has_test_oneof?\n\nmessage.name = \"Bender\"\nraise unless message.has_test_oneof?\nraise unless message.has_name?\nraise unless !message.has_serial_number?\nraise unless !message.has_test_oneof?\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor C++ Type Enumeration in C++\nDESCRIPTION: Enumeration of C++ data types used to represent Protocol Buffer fields in C++ code. Provides a mapping from protobuf types to C++ types, where each protobuf Type maps to exactly one CppType.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldDescriptor::CppType {\n  CPPTYPE_INT32 = 1,\n  CPPTYPE_INT64 = 2,\n  CPPTYPE_UINT32 = 3,\n  CPPTYPE_UINT64 = 4,\n  CPPTYPE_DOUBLE = 5,\n  CPPTYPE_FLOAT = 6,\n  CPPTYPE_BOOL = 7,\n  CPPTYPE_ENUM = 8,\n  CPPTYPE_STRING = 9,\n  CPPTYPE_MESSAGE = 10,\n  MAX_CPPTYPE = 10\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing toString Method in Kotlin DslMap\nDESCRIPTION: Method signature for overriding toString() in the DslMap class. Returns a String representation of the DslMap object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/to-string.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun toString(): String\n```\n\n----------------------------------------\n\nTITLE: Working with Enum Fields in Protocol Buffers (Python)\nDESCRIPTION: Shows how to set and compare enum field values in Python, demonstrating that they behave like scalar fields with integer values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nfoo.bar = Foo.VALUE_A\nassert foo.bar == 0\nassert foo.bar == Foo.VALUE_A\n```\n\n----------------------------------------\n\nTITLE: Proto2 Extend Example\nDESCRIPTION: Shows an example of an extend declaration in Protocol Buffers adding a field to an existing message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_35\n\nLANGUAGE: proto\nCODE:\n```\nextend Foo {\n  optional int32 bar = 126;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Proto2 Message Objects on Arena (C++)\nDESCRIPTION: API to create proto2 message objects on the arena. If the arena is NULL, a heap-allocated object is returned. Type T must be a message with cc_enable_arenas set to true.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static T * Arena::CreateMessage(\n        Arena * arena,\n        Args &&... args)\n```\n\n----------------------------------------\n\nTITLE: Erasing Single Element from RepeatedPtrField\nDESCRIPTION: Removes the element at the specified position in a RepeatedPtrField. Returns an iterator to the element after the removed one. Invalidates iterators at or after the removed element.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_53\n\nLANGUAGE: cpp\nCODE:\n```\niterator RepeatedPtrField::erase(\n        const_iterator position)\n```\n\n----------------------------------------\n\nTITLE: Defining Maps in Protocol Buffers\nDESCRIPTION: Shows how to create associative maps in Protocol Buffers using the map syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_35\n\nLANGUAGE: proto\nCODE:\n```\nmap<string, Project> projects = 3;\n```\n\n----------------------------------------\n\nTITLE: Getting Printable Name for Extensions in Protocol Buffers (C++)\nDESCRIPTION: Returns full_name() except for MessageSet extensions, where it returns the full_name() of the containing message type for backward compatibility with proto1.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_47\n\nLANGUAGE: cpp\nCODE:\n```\nconst std::string & \n    FieldDescriptor::PrintableNameForExtension() const\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Extensions in Protocol Buffers\nDESCRIPTION: Example of declaring an extension inside another message type, creating a namespace for the extension field. This pattern is commonly used to extend a message with fields of a specific type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_28\n\nLANGUAGE: proto\nCODE:\n```\nmessage Baz {\n  extend Foo {\n    optional Baz foo_ext = 124;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Initialization Verification (C++)\nDESCRIPTION: Methods to verify message initialization state and find initialization errors in required fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid CheckInitialized() const;\nvoid FindInitializationErrors(std::vector<std::string>* errors) const;\n```\n\n----------------------------------------\n\nTITLE: Using has_... and clear_... Methods with Submessage Fields\nDESCRIPTION: Alternative approach to checking and clearing submessage fields using the generated has_... and clear_... methods instead of nil comparison. Shows how to check if a submessage field is set and how to clear it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nif message.has_submessage_field?\n  raise unless message.submessage_field == nil\n  puts \"Submessage field is unset.\"\nelse\n  raise unless message.submessage_field != nil\n  message.clear_submessage_field\n  raise unless message.submessage_field == nil\n  puts \"Cleared submessage field.\"\nend\n```\n\n----------------------------------------\n\nTITLE: Getting Default Enum Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_ENUM. If no explicit default was defined, returns the first value defined in the enum type. This method never returns nullptr.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_39\n\nLANGUAGE: cpp\nCODE:\n```\nconst EnumValueDescriptor * \n    FieldDescriptor::default_value_enum() const\n```\n\n----------------------------------------\n\nTITLE: Marking Fields as Deprecated in Protocol Buffers\nDESCRIPTION: Marks a field as deprecated to discourage its use in new code. Results in appropriate deprecation annotations in generated code (like @Deprecated in Java).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_49\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 old_field = 6 [deprecated=true];\n```\n\n----------------------------------------\n\nTITLE: Creating Complete FieldMask in Protocol Buffers C++\nDESCRIPTION: Creates a FieldMask containing all fields of type T, excluding sub-message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static FieldMask FieldMaskUtil::GetFieldMaskForAllFields()\n```\n\n----------------------------------------\n\nTITLE: C++ Any Class Interface for Protocol Buffers\nDESCRIPTION: Definition of the google::protobuf::Any class interface that provides methods to pack and unpack Protocol Buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_36\n\nLANGUAGE: cpp\nCODE:\n```\nclass Any {\n public:\n  // Packs the given message into this Any using the default type URL\n  // prefix \"type.googleapis.com\". Returns false if serializing the message failed.\n  bool PackFrom(const google::protobuf::Message& message);\n\n  // Packs the given message into this Any using the given type URL\n  // prefix. Returns false if serializing the message failed.\n  bool PackFrom(const google::protobuf::Message& message,\n                ::absl::string_view type_url_prefix);\n\n  // Unpacks this Any to a Message. Returns false if this Any\n  // represents a different protobuf type or parsing fails.\n  bool UnpackTo(google::protobuf::Message* message) const;\n\n  // Returns true if this Any represents the given protobuf type.\n  template<typename T> bool Is() const;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Repeated Message Field in C++\nDESCRIPTION: Gets the internal RepeatedPtrField for a repeated message field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nconst RepeatedPtrField<Message>& GetRepeatedPtrFieldInternal(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Computing Timestamp from Java System.currentTimeMillis()\nDESCRIPTION: Creates a Protocol Buffer Timestamp with millisecond precision using Java's System.currentTimeMillis(). The code converts the millisecond value to seconds and nanoseconds for the Timestamp fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_15\n\nLANGUAGE: java\nCODE:\n```\nlong millis = System.currentTimeMillis();\n\nTimestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n    .setNanos((int) ((millis % 1000) * 1000000)).build();\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting Extension Values in Go\nDESCRIPTION: Shows how to use the generated ExtensionType value to access and set extension values in Go. It demonstrates usage with different types of extensions including scalar, repeated, and message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_32\n\nLANGUAGE: go\nCODE:\n```\nm := &somepb.Concert{}\nproto.SetExtension(m, extpb.E_SingularInt32, int32(1))\nproto.SetExtension(m, extpb.E_RepeatedString, []string{\"a\", \"b\", \"c\"})\nproto.SetExtension(m, extpb.E_SingularMessage, &extpb.Band{})\n\nv1 := proto.GetExtension(m, extpb.E_SingularInt32).(int32)\nv2 := proto.GetExtension(m, extpb.E_RepeatedString).([][]byte)\nv3 := proto.GetExtension(m, extpb.E_SingularMessage).(*extpb.Band)\n```\n\n----------------------------------------\n\nTITLE: Buffer Pre-sizing with proto.Size in Go\nDESCRIPTION: Demonstrates an advanced usage of proto.Size to pre-allocate buffers for protocol buffer marshaling, with important notes about handling lazy decoding scenarios.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/size.md#2025-04-11_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nopts := proto.MarshalOptions{\n    // Possibly avoid an extra proto.Size in Marshal itself (see docs):\n    UseCachedSize: true,\n}\n// DO NOT SUBMIT without implementing this Optimization opportunity:\n// instead of allocating, grab a sufficiently-sized buffer from a pool.\n// Knowing the size of the buffer means we can discard\n// outliers from the pool to prevent uncontrolled\n// memory growth in long-running RPC services.\nbuf := make([]byte, 0, opts.Size(m))\nvar err error\nbuf, err = opts.MarshalAppend(buf, m) // does not allocate\n// Note that len(buf) might be less than cap(buf)! Read below:\n```\n\n----------------------------------------\n\nTITLE: Multi-line Strings in Protocol Buffer Text Format\nDESCRIPTION: Example showing how to define longer strings by breaking them into several quoted strings on successive lines in the protocol buffer text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_5\n\nLANGUAGE: textproto\nCODE:\n```\n  quote:\n      \"When we got into office, the thing that surprised me most was to find \"\n      \"that things were just as bad as we'd been saying they were.\\n\\n\"\n      \"  -- John F. Kennedy\"\n```\n\n----------------------------------------\n\nTITLE: Proto2 Normal Field Definition\nDESCRIPTION: Specifies the syntax for normal fields in Protocol Buffers, including label, type, name, field number, and optional field options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_17\n\nLANGUAGE: ebnf\nCODE:\n```\nfield = label type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\nfieldOptions = fieldOption { \",\"  fieldOption }\nfieldOption = optionName \"=\" constant\n```\n\n----------------------------------------\n\nTITLE: Handling Implicit Field Presence in JavaScript\nDESCRIPTION: This snippet demonstrates how to handle implicit field presence in JavaScript using Protocol Buffers. It checks if a field has a non-zero value and either clears it or sets it to a default value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nvar m = new Msg();\nif (m.getFoo() != 0) {\n  // \"Clear\" the field:\n  m.setFoo(0);\n} else {\n  // Default value: field may not have been present.\n  m.setFoo(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Objective-C Extensions for TimeStamp Well-Known Type\nDESCRIPTION: Category extension for the TimeStamp well-known type in proto3, providing convenience methods for date and timestamp conversion.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_29\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPBTimeStamp (GPBWellKnownTypes)\n@property (nonatomic, readwrite, strong) NSDate *date;\n@property (nonatomic, readwrite) NSTimeInterval timeIntervalSince1970;\n- (instancetype)initWithDate:(NSDate *)date;\n- (instancetype)initWithTimeIntervalSince1970:\n    (NSTimeInterval)timeIntervalSince1970;\n@end\n```\n\n----------------------------------------\n\nTITLE: Getting Containing Type in Protocol Buffers Fields (C++)\nDESCRIPTION: Returns the Descriptor for the message of which this is a field. For extensions, this is the extended type. Never returns nullptr.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_41\n\nLANGUAGE: cpp\nCODE:\n```\nconst Descriptor * \n    FieldDescriptor::containing_type() const\n```\n\n----------------------------------------\n\nTITLE: Configuring Option Retention in Protocol Buffers\nDESCRIPTION: Shows how to set option retention to control whether options are retained in generated code. Source retention (RETENTION_SOURCE) means the option won't be available at runtime, which can reduce code size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_59\n\nLANGUAGE: proto\nCODE:\n```\nextend google.protobuf.FileOptions {\n  optional int32 source_retention_option = 1234\n      [retention = RETENTION_SOURCE];\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nmessage OptionsMessage {\n  optional int32 source_retention_field = 1 [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring DslMap Class in Kotlin for Protocol Buffers\nDESCRIPTION: Class declaration for DslMap, which wraps a Map with an extra generic parameter for extension method disambiguation. It extends DslProxy and implements the Map interface.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DslMap<K, V, P : DslProxy>constructor(delegate: Map<K, V>) : Map<K, V>\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions in Protocol Buffers (Proto2)\nDESCRIPTION: Example of defining an extension field in Protocol Buffers (Proto2 only). This shows how to extend a message type with additional fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_23\n\nLANGUAGE: proto\nCODE:\n```\nextend Concert {\n  optional int32 promo_id = 123;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring ZeroCopyOutputStream Class in C++\nDESCRIPTION: Abstract class declaration for ZeroCopyOutputStream, which provides methods for writing to a stream with minimal copying.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nclass ZeroCopyOutputStream {\npublic:\n  ZeroCopyOutputStream();\n  virtual ~ZeroCopyOutputStream();\n  virtual bool Next(void** data, int* size) = 0;\n  virtual void BackUp(int count) = 0;\n  virtual int64_t ByteCount() const = 0;\n  virtual bool WriteAliasedRaw(const void* data, int size);\n  virtual bool AllowsAliasing() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Field Default Values in Protocol Buffers C++\nDESCRIPTION: Methods to access default values for different field types in Protocol Buffers. Each method returns the default value for a specific C++ type when the field matches the corresponding CPPTYPE.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\ndefault_value_int32() const\ndefault_value_int64() const\ndefault_value_uint32() const\ndefault_value_uint64() const\ndefault_value_float() const\ndefault_value_double() const\ndefault_value_bool() const\ndefault_value_enum() const\ndefault_value_string() const\n```\n\n----------------------------------------\n\nTITLE: Defining Package Specifier in Protocol Buffers\nDESCRIPTION: Demonstrates how to add a package specifier to prevent name clashes between message types in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_37\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\nmessage Open { ... }\n```\n\n----------------------------------------\n\nTITLE: Accessing EnumDescriptor reserved names in C++\nDESCRIPTION: Gets a reserved name by index, where 0 <= index < reserved_name_count(). Uses an array of pointers rather than the usual array of objects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_61\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string & \n    EnumDescriptor::reserved_name(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Executing Protocol Buffer Compiler for Objective-C Output\nDESCRIPTION: Example showing how to invoke the protocol buffer compiler to generate Objective-C code from .proto files. Demonstrates usage of --proto_path and --objc_out flags.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --objc_out=build/gen src/foo.proto src/bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Fields in Proto3\nDESCRIPTION: Shows how to define a singular field in proto3 syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nint32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Extension Function - Contains Check for Protocol Buffer Messages\nDESCRIPTION: Operator function that checks if a specific extension is set on an ExtendableMessageOrBuilder. Takes an ExtensionLite parameter and returns a Boolean.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\noperator fun <M : GeneratedMessageV3.ExtendableMessage<M>, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder<M>> MorBT.contains(extension: ExtensionLite<M, *>): Boolean\n```\n\n----------------------------------------\n\nTITLE: Using Protocol Buffer Enums in Ruby\nDESCRIPTION: Demonstrates how to access and use Protocol Buffer enum values in Ruby code, including value assignment and comparison.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: ruby\nCODE:\n```\nprint Foo::SomeEnum::VALUE_A  # => 0\nmessage.bar = Foo::SomeEnum::VALUE_A\n```\n\n----------------------------------------\n\nTITLE: RepeatedField Template Declaration\nDESCRIPTION: Template class declaration for RepeatedField, used for representing repeated fields of primitive types in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/repeated_field.h>\nnamespace google::protobuf\n\ntemplate <typename >\n```\n\n----------------------------------------\n\nTITLE: Marking Field as Deprecated\nDESCRIPTION: Demonstrates how to mark a field as deprecated using the deprecated option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_39\n\nLANGUAGE: proto\nCODE:\n```\nint32 old_field = 6 [deprecated = true];\n```\n\n----------------------------------------\n\nTITLE: Including Protocol Buffer Descriptor Header in C++\nDESCRIPTION: This snippet shows how to include the protocol buffer descriptor header file in C++ code. It also specifies the namespace for the protobuf classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/descriptor.pb.h>\nnamespace google::protobuf\n```\n\n----------------------------------------\n\nTITLE: Defining a Message Type in Protocol Buffers\nDESCRIPTION: Basic Protocol Buffer message type definition used for examples in the documentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_27\n\nLANGUAGE: proto\nCODE:\n```\nmessage Bar {}\n```\n\n----------------------------------------\n\nTITLE: FieldMask String Conversion Methods\nDESCRIPTION: Methods for converting FieldMask to and from string representations using both standard and JSON formats.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::string ToString(const FieldMask& mask);\nstatic void FromString(StringPiece str, FieldMask* out);\nstatic bool ToJsonString(const FieldMask& mask, std::string* out);\nstatic bool FromJsonString(StringPiece str, FieldMask* out);\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions in Protocol Buffers (proto2)\nDESCRIPTION: A protocol buffer message definition with an extension range, which allows the message to be extended with additional fields defined outside the original message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 100 to 199;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Bazel Dependencies for μpb Integration\nDESCRIPTION: Examples of how to update Bazel dependency references after μpb's migration to the Protocol Buffers repository. Shows the change from @upb to @com_google_protobuf namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-09-15.md#2025-04-11_snippet_0\n\nLANGUAGE: bazel\nCODE:\n```\n@upb//:reflection\n```\n\nLANGUAGE: bazel\nCODE:\n```\n@com_google_protobuf//upb:reflection\n```\n\n----------------------------------------\n\nTITLE: Proto2 Oneof Field Example\nDESCRIPTION: Shows an example of a 'oneof' field declaration in Protocol Buffers with multiple field options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_22\n\nLANGUAGE: proto\nCODE:\n```\noneof foo {\n    string name = 4;\n    SubMessage sub_message = 9;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Any Fields in Protocol Buffers\nDESCRIPTION: Example showing how to use the Any type for dynamic message handling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/any.proto\";\n\nmessage ErrorStatus {\n  string message = 1;\n  google.protobuf.Any details = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: RepeatedPtrField Core Methods - C++\nDESCRIPTION: Core method declarations for the RepeatedPtrField class including element access, modification, and iteration capabilities.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_38\n\nLANGUAGE: C++\nCODE:\n```\nElement& at(int index);\nvoid RemoveLast();\nvoid DeleteSubrange(int start, int num);\nvoid Clear();\nvoid MergeFrom(const RepeatedPtrField& other);\nvoid CopyFrom(const RepeatedPtrField& other);\ntemplate<typename Iter> void Assign(Iter begin, Iter end);\nvoid Reserve(int new_size);\nint Capacity() const;\nElement** mutable_data();\nconst Element* const* data() const;\n```\n\n----------------------------------------\n\nTITLE: Swift Usage of Protocol Buffer Generated Enumerations\nDESCRIPTION: Example showing how Objective-C Protocol Buffer enumerations can be used in Swift code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\n// Swift\nlet aValue = Foo.ValueA\nlet anotherValue: Foo = .GPBUnrecognizedEnumeratorValue\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Types in Protocol Buffers\nDESCRIPTION: Demonstrates how to define nested messages and enums within a parent message in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {\n      enum Baz { ... }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Builders and Setters in Go\nDESCRIPTION: Demonstrates how to combine the use of builders and setters in Go when constructing protocol buffer messages with conditional logic.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-faq.md#2025-04-11_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nm1 := pb.M1_builder{\n    Field1: value1,\n}.Build()\nif someCondition() {\n    m1.SetField2(value2)\n    m1.SetField3(value3)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring FileInputStream::Skip Method in C++\nDESCRIPTION: This method skips a specified number of bytes in the input stream. It returns false if the end of the stream is reached or an input error occurs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool FileInputStream::Skip(int count)\n```\n\n----------------------------------------\n\nTITLE: Creating TypeResolver Function Declaration in C++\nDESCRIPTION: Function declaration for creating a TypeResolver that serves type information from a given descriptor pool. The function takes a URL prefix and descriptor pool pointer as parameters and returns a TypeResolver pointer that the caller owns.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.type_resolver_util.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nTypeResolver* NewTypeResolverForDescriptorPool(const std::string& url_prefix, const DescriptorPool* pool)\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Java Files Generation in Protocol Buffers\nDESCRIPTION: When set to true, the compiler generates separate .java files for each top-level message, service, and enumeration instead of nesting all classes in a single outer class file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_44\n\nLANGUAGE: proto\nCODE:\n```\noption java_multiple_files = true;\n```\n\n----------------------------------------\n\nTITLE: Accessing File Descriptor in C++\nDESCRIPTION: Method to get the FileDescriptor for the .proto file in which this service was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_68\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * file() const\n```\n\n----------------------------------------\n\nTITLE: Any Field Java Implementation\nDESCRIPTION: Java code showing the methods available for packing and unpacking Any fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_21\n\nLANGUAGE: java\nCODE:\n```\nclass Any {\n  // Packs the given message into an Any using the default type URL\n  // prefix \"type.googleapis.com\".\n  public static Any pack(Message message);\n  // Packs the given message into an Any using the given type URL\n  // prefix.\n  public static Any pack(Message message,\n                         String typeUrlPrefix);\n\n  // Checks whether this Any message's payload is the given type.\n  public <T extends Message> boolean is(class<T> clazz);\n\n  // Unpacks Any into the given message type. Throws exception if\n  // the type doesn't match or parsing the payload has failed.\n  public <T extends Message> T unpack(class<T> clazz)\n      throws InvalidProtocolBufferException;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Fields in Proto2\nDESCRIPTION: Demonstrates how to define optional and required singular fields in proto2.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 foo = 1;\nrequired int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Complex Message\nDESCRIPTION: Shows the complete Objective-C interface generated for a complex protocol buffer message, including field number enums and property declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: objc\nCODE:\n```\ntypedef GPB_ENUM(Foo_Bar_FieldNumber) {\n  Foo_Bar_FieldNumber_Int32Value = 1,\n};\n\n@interface Foo_Bar : GPBMessage\n@property(nonatomic, readwrite) int32_t int32Value;\n@end\n\ntypedef GPB_ENUM(Foo_FieldNumber) {\n  Foo_FieldNumber_Int32Value = 1,\n  Foo_FieldNumber_StringValue = 2,\n  Foo_FieldNumber_MessageValue = 3,\n  Foo_FieldNumber_EnumValue = 4,\n  Foo_FieldNumber_BytesValue = 5,\n};\n\ntypedef GPB_ENUM(Foo_Qux) {\n  Foo_Qux_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,\n  ...\n};\n\n@interface Foo : GPBMessage\n@property(nonatomic, readwrite) int32_t int32Value;\n@property(nonatomic, readwrite, copy, null_resettable) NSString *stringValue;\n@property(nonatomic, readwrite) BOOL hasMessageValue;\n@property(nonatomic, readwrite, strong, null_resettable) Foo_Bar *messageValue;\n@property(nonatomic, readwrite) Foo_Qux enumValue;\n@property(nonatomic, readwrite, copy, null_resettable) NSData *bytesValue;\n@end\n```\n\n----------------------------------------\n\nTITLE: RepeatedPtrField Iterator Methods - C++\nDESCRIPTION: Iterator-related method declarations providing STL-compatible iteration over the repeated field elements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_39\n\nLANGUAGE: C++\nCODE:\n```\niterator begin();\nconst_iterator begin() const;\nconst_iterator cbegin() const;\niterator end();\nconst_iterator end() const;\nconst_iterator cend() const;\nreverse_iterator rbegin();\nconst_reverse_iterator rbegin() const;\nreverse_iterator rend();\nconst_reverse_iterator rend() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Package Declaration in Proto3\nDESCRIPTION: Defines the syntax for package declarations in Protocol Buffers to prevent name clashes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_13\n\nLANGUAGE: ebnf\nCODE:\n```\npackage = \"package\" fullIdent \";\"\n```\n\n----------------------------------------\n\nTITLE: Setting source retention for a file option in Protocol Buffers\nDESCRIPTION: Shows how to set the retention option to RETENTION_SOURCE for a file option in Protocol Buffers. This specifies that the option must not be retained at runtime.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-11.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nextend google.protobuf.FileOptions {\n  optional int32 source_retention_option = 1234\n      [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Protocol Compiler with Winget (Windows)\nDESCRIPTION: This snippet shows how to install the protocol compiler using Winget on Windows. It installs the protobuf package and verifies the installed version.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/installation.md#2025-04-11_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n> winget install protobuf\n> protoc --version # Ensure compiler version is 3+\n```\n\n----------------------------------------\n\nTITLE: Printing Protocol Buffer Message to Output Stream in C++\nDESCRIPTION: Outputs a textual representation of the given protocol buffer message to the specified ZeroCopyOutputStream. Returns true on success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool Print(const Message& message, io::ZeroCopyOutputStream* output)\n```\n\n----------------------------------------\n\nTITLE: Defining GPBEnumArray Interface in Objective-C for Protocol Buffers\nDESCRIPTION: This snippet defines the interface for GPBEnumArray, which is used for representing repeated enum fields in Protocol Buffers. It includes methods for initialization, value access, enumeration, addition, removal, and manipulation of enum array elements, with additional methods for handling raw values and validation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPBEnumArray : NSObject\n@property (nonatomic, readonly) NSUInteger count;\n@property (nonatomic, readonly) GPBEnumValidationFunc validationFunc;\n\n+ (instancetype)array;\n+ (instancetype)arrayWithValidationFunction:(nullable GPBEnumValidationFunc)func;\n+ (instancetype)arrayWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                   rawValue:value;\n+ (instancetype)arrayWithValueArray:(GPBEnumArray *)array;\n+ (instancetype)arrayWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                   capacity:(NSUInteger)count;\n\n- (instancetype)initWithValidationFunction:\n  (nullable GPBEnumValidationFunc)func;\n\n// Initializes the array, copying the values.\n- (instancetype)initWithValueArray:(GPBEnumArray *)array;\n- (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func\n    values:(const int32_t [])values\n    count:(NSUInteger)count NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                  capacity:(NSUInteger)count;\n\n// These will return kGPBUnrecognizedEnumeratorValue if the value at index\n// is not a valid enumerator as defined by validationFunc. If the actual\n// value is desired, use the \"raw\" version of the method.\n- (int32_t)valueAtIndex:(NSUInteger)index;\n- (void)enumerateValuesWithBlock:\n    (void (^)(int32_t value, NSUInteger idx, BOOL *stop))block;\n- (void)enumerateValuesWithOptions:(NSEnumerationOptions)opts\n    usingBlock:(void (^)(int32_t value, NSUInteger idx, BOOL *stop))block;\n\n// These methods bypass the validationFunc to provide access to values\n// that were not known at the time the binary was compiled.\n- (int32_t)rawValueAtIndex:(NSUInteger)index;\n\n- (void)enumerateRawValuesWithBlock:\n    (void (^)(int32_t value, NSUInteger idx, BOOL *stop))block;\n- (void)enumerateRawValuesWithOptions:(NSEnumerationOptions)opts\n    usingBlock:(void (^)(int32_t value, NSUInteger idx, BOOL *stop))block;\n\n// If value is not a valid enumerator as defined by validationFunc, these\n// methods will assert in debug, and will log in release and assign the value\n// to the default value. Use the rawValue methods below to assign\n// non enumerator values.\n- (void)addValue:(int32_t)value;\n- (void)addValues:(const int32_t [])values count:(NSUInteger)count;\n- (void)insertValue:(int32_t)value atIndex:(NSUInteger)count;\n- (void)replaceValueAtIndex:(NSUInteger)index withValue:(int32_t)value;\n\n// These methods bypass the validationFunc to provide setting of values that\n// were not known at the time the binary was compiled.\n- (void)addRawValue:(int32_t)rawValue;\n- (void)addRawValuesFromEnumArray:(GPBEnumArray *)array;\n- (void)addRawValues:(const int32_t [])values count:(NSUInteger)count;\n- (void)replaceValueAtIndex:(NSUInteger)index withRawValue:(int32_t)rawValue;\n- (void)insertRawValue:(int32_t)value atIndex:(NSUInteger)count;\n\n// No validation applies to these methods.\n- (void)removeValueAtIndex:(NSUInteger)count;\n- (void)removeAll;\n- (void)exchangeValueAtIndex:(NSUInteger)idx1\n            withValueAtIndex:(NSUInteger)idx2;\n\n@end\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Oneof Field Behavior in C++\nDESCRIPTION: This snippet shows how setting a oneof field clears other members of the oneof. It demonstrates that calling mutable_sub_message() clears the previously set name field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nSampleMessage message;\nmessage.set_name(\"name\");\nCHECK_EQ(message.name(), \"name\");\n// Calling mutable_sub_message() will clear the name field and will set\n// sub_message to a new instance of SubMessage with none of its fields set.\nmessage.mutable_sub_message();\nCHECK(message.name().empty());\n```\n\n----------------------------------------\n\nTITLE: Updating Bazel References for μpb in Protocol Buffers\nDESCRIPTION: With μpb moving to the Protocol Buffers repository, Bazel projects need to update their μpb references. This includes changing the repository name and adjusting some file paths.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v25.md#2025-04-11_snippet_1\n\nLANGUAGE: Bazel\nCODE:\n```\n# Old reference\n@upb//:reflection\n\n# New reference\n@com_google_protobuf//upb:reflection\n```\n\n----------------------------------------\n\nTITLE: C++ Field Presence Handling with Explicit Presence\nDESCRIPTION: C++ example showing field handling with explicit presence in Proto3, using has_foo() and clear_foo() methods for proper field presence tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nMsg m = GetProto();\nif (m.has_foo()) {\n  // Clear the field:\n  m.clear_foo();\n} else {\n  // Field is not present, so set it.\n  m.set_foo(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Field Syntax in Protocol Buffers Text Format\nDESCRIPTION: Examples showing various field syntax options in Protocol Buffers text format, including scalar fields, message fields, and list syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_17\n\nLANGUAGE: textproto\nCODE:\n```\nscalar: 10          # Valid\nscalar  10          # Invalid\nscalars: [1, 2, 3]  # Valid\nscalars  [1, 2, 3]  # Invalid\nmessage: {}         # Valid\nmessage  {}         # Valid\nmessages: [{}, {}]  # Valid\nmessages  [{}, {}]  # Valid\n```\n\n----------------------------------------\n\nTITLE: Working with Enum Values in Ruby\nDESCRIPTION: Shows advanced enum handling in Ruby including unknown values, symbol conversion, and switch statements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: ruby\nCODE:\n```\nmessage.bar = 0\nputs message.bar.inspect  # => :VALUE_A\nmessage.bar = :VALUE_B\nputs message.bar.inspect  # => :VALUE_B\nmessage.bar = 999\nputs message.bar.inspect  # => 999\n\n# Raises: RangeError: Unknown symbol value for enum field.\nmessage.bar = :UNDEFINED_VALUE\n\n# Switching on an enum value is convenient.\ncase message.bar\nwhen :VALUE_A\n  # ...\nwhen :VALUE_B\n  # ...\nwhen :VALUE_C\n  # ...\nelse\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: RepeatedPtrField Utility Methods - C++\nDESCRIPTION: Utility method declarations for memory management and element manipulation operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_40\n\nLANGUAGE: C++\nCODE:\n```\nvoid Swap(RepeatedPtrField* other);\nvoid UnsafeArenaSwap(RepeatedPtrField* other);\nvoid SwapElements(int index1, int index2);\nsize_t SpaceUsedExcludingSelfLong() const;\nint SpaceUsedExcludingSelf() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Import Statements in Protocol Buffers\nDESCRIPTION: Specifies the syntax for import statements in Protocol Buffers, which are used to import definitions from other .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_10\n\nLANGUAGE: EBNF\nCODE:\n```\nimport = \"import\" [ \"weak\" | \"public\" ] strLit \";\"\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Enums\nDESCRIPTION: Shows the protobuf enum definition syntax in .proto files for creating enumerated values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  enum SomeEnum {\n    VALUE_A = 0;\n    VALUE_B = 5;\n    VALUE_C = 1234;\n  }\n  optional SomeEnum bar = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: FileInputStream GetErrno Method\nDESCRIPTION: Method to retrieve the errno value if an I/O error has occurred on the file descriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint GetErrno() const\n```\n\n----------------------------------------\n\nTITLE: Initializing EpsCopyOutputStream with Pre-allocated Buffer in C++\nDESCRIPTION: Constructor that initializes from a stream but with the first buffer already provided (eager initialization).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_39\n\nLANGUAGE: C++\nCODE:\n```\nEpsCopyOutputStream(void* data, int size, ZeroCopyOutputStream* stream, bool deterministic, uint8** pp)\n```\n\n----------------------------------------\n\nTITLE: Proto3 Enum Example with Edge Cases\nDESCRIPTION: Demonstrates Proto3 enum definition with repeated field, used to explain Java's handling of unrecognized values and special edge cases.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/enum.md#2025-04-11_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\nenum Enum {\n  A = 0;\n  B = 1;\n}\n\nmessage Msg {\n  repeated Enum name = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Service to Proto in C++\nDESCRIPTION: Method to copy the service descriptor to a ServiceDescriptorProto message, similar to Descriptor::CopyTo().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_73\n\nLANGUAGE: C++\nCODE:\n```\nvoid CopyTo(ServiceDescriptorProto * proto) const\n```\n\n----------------------------------------\n\nTITLE: Enabling Java Generic Services in Protocol Buffers\nDESCRIPTION: Shows the option to enable generation of generic service code in Java. Generic services provide a basic implementation not tied to any particular RPC system.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_32\n\nLANGUAGE: proto\nCODE:\n```\noption java_generic_services = true;\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated Fields in Protocol Buffers\nDESCRIPTION: Shows how to declare a repeated field in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nrepeated int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations in Protocol Buffers\nDESCRIPTION: Basic example of defining an enumeration in Protocol Buffers with multiple values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  VALUE_A = 0;\n  VALUE_B = 1;\n  VALUE_C = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Swapping RepeatedField Contents in C++\nDESCRIPTION: Swaps the entire contents of this RepeatedField with another.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nvoid Swap(RepeatedField * other)\n```\n\n----------------------------------------\n\nTITLE: Using Enums Instead of Booleans for Potentially Expandable States in Protocol Buffers\nDESCRIPTION: Example showing how to use more flexible data structures (like message types or enums) instead of boolean fields for properties that might have more than two states in the future.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage GooglePlusPost {\n  // Bad: Whether to render this post across two columns.\n  optional bool big_post;\n\n  // Good: Rendering hints for clients displaying this post.\n  // Clients should use this to decide how prominently to render this\n  // post. If absent, assume a default rendering.\n  optional LayoutConfig layout_config;\n}\n\nmessage Photo {\n  // Bad: True if it's a GIF.\n  optional bool gif;\n\n  // Good: File format of the referenced photo (for example, GIF, WebP, PNG).\n  optional PhotoType type;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Enum Value Options in C++\nDESCRIPTION: Demonstrates how to access custom enum value options in C++ code using the Protocol Buffers API.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_33\n\nLANGUAGE: cpp\nCODE:\n```\nconst absl::string_view foo = proto2::GetEnumDescriptor<Data>()\n    ->FindValueByName(\"DATA_DISPLAY\")->options().GetExtension(string_name);\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compilation Command\nDESCRIPTION: Shell command for compiling the .proto file into Dart code using the protoc compiler with the Dart plugin.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/darttutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nprotoc -I=$SRC_DIR --dart_out=$DST_DIR $SRC_DIR/addressbook.proto\n```\n\n----------------------------------------\n\nTITLE: Simple Message Declaration in Proto\nDESCRIPTION: Basic example of declaring a protocol buffer message that will be converted to a Go struct.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Artist {}\n```\n\n----------------------------------------\n\nTITLE: Reserved Fields Examples in Protocol Buffers\nDESCRIPTION: Demonstrates the declaration of reserved field numbers and names in Protocol Buffers to prevent their use in messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nreserved 2, 15, 9 to 11;\nreserved foo, bar;\n```\n\n----------------------------------------\n\nTITLE: Chaining Get Methods in Go with Nil Checks\nDESCRIPTION: Example showing how to chain get methods on potentially nil message fields without causing panics.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nvar m *Concert // defaults to nil\nlog.Infof(\"GetFoundingYear() = %d (no panic!)\", m.GetHeadliner().GetFoundingYear())\n```\n\n----------------------------------------\n\nTITLE: Accessing EnumDescriptor value count in C++\nDESCRIPTION: Gets the number of values for an EnumDescriptor. This method is guaranteed to return a value greater than zero.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_54\n\nLANGUAGE: C++\nCODE:\n```\nint EnumDescriptor::value_count() const\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC Client with Protocol Buffers in C++\nDESCRIPTION: Shows how to use generated Protocol Buffer service stubs to make RPC calls in C++ using abstract RPC interfaces that can be implemented for specific RPC systems.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_40\n\nLANGUAGE: c++\nCODE:\n```\nusing google::protobuf;\n\nprotobuf::RpcChannel* channel;\nprotobuf::RpcController* controller;\nSearchService* service;\nSearchRequest request;\nSearchResponse response;\n\nvoid DoSearch() {\n  // You provide classes MyRpcChannel and MyRpcController, which implement\n  // the abstract interfaces protobuf::RpcChannel and protobuf::RpcController.\n  channel = new MyRpcChannel(\"somehost.example.com:1234\");\n  controller = new MyRpcController;\n\n  // The protocol compiler generates the SearchService class based on the\n  // definition given earlier.\n  service = new SearchService::Stub(channel);\n\n  // Set up the request.\n  request.set_query(\"protocol buffers\");\n\n  // Execute the RPC.\n  service->Search(controller, &request, &response,\n                  protobuf::NewCallback(&Done));\n}\n\nvoid Done() {\n  delete service;\n  delete channel;\n  delete controller;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Types in Protocol Buffers\nDESCRIPTION: Demonstrates how to define nested message types within other message types, and how to reference them outside their parent message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  message Result {\n    string url = 1;\n    string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result results = 1;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nmessage SomeOtherMessage {\n  SearchResponse.Result result = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Definition in Proto\nDESCRIPTION: Example of defining an enumeration in a proto file. Enums provide a way to define named constant values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nenum TestEnum {\n  Default = 0;\n  A = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Resizing RepeatedField in C++\nDESCRIPTION: Resizes the repeated field similar to STL resize. Uses provided value to fill new elements. O(new_size - size()) for growing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedField::Resize(\n        int new_size,\n        const Element& value)\n```\n\n----------------------------------------\n\nTITLE: Declaring EnumDescriptor Class in C++\nDESCRIPTION: Declaration of the EnumDescriptor class in Protocol Buffers, which describes an enum type defined in a .proto file. It provides methods for accessing enum type information and metadata.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_51\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/descriptor.h>\nnamespace google::protobuf\n\nclass EnumDescriptor {\n    // Methods and properties not shown in the provided snippet\n};\n```\n\n----------------------------------------\n\nTITLE: Skipping bytes in CodedInputStream in C++\nDESCRIPTION: Skips a specified number of bytes in the input stream. Returns a boolean indicating success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nbool Skip(int count)\n```\n\n----------------------------------------\n\nTITLE: Checking Abseil Dependency Version with Bazel\nDESCRIPTION: Shows how to use the 'bazel mod deps' command to determine which version of Abseil is supported by your Protocol Buffers implementation. The command displays a simple dependency tree with the specific Abseil version.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/abseil.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ bazel mod deps abseil-cpp --enable_bzlmod\n<root> (protobuf@30.0-dev)\n└───abseil-cpp@20240722.0\n    ├───bazel_skylib@1.7.1\n    ├───googletest@1.15.2\n    └───platforms@0.0.10\n```\n\n----------------------------------------\n\nTITLE: Defining Extension in Protocol Buffers\nDESCRIPTION: This snippet shows how to define an extension in a .proto file. It extends the media.UserContent message with a repeated Video field for kitten videos.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\n// file kittens/video_ext.proto\n\nimport \"kittens/video.proto\";\nimport \"media/user_content.proto\";\n\npackage kittens;\n\n// This extension allows kitten videos in a media.UserContent message.\nextend media.UserContent {\n  // Video is a message imported from kittens/video.proto\n  repeated Video kitten_videos = 126;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Camelcase Name in FileDescriptor (C++)\nDESCRIPTION: Similar to FindExtensionByName(), but searches by camelcased-name. See Descriptor::FindFieldByCamelcaseName().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_96\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * \n    FileDescriptor::FindExtensionByCamelcaseName(\n        ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining GetStudentRequest message in Protocol Buffers\nDESCRIPTION: This snippet defines a GetStudentRequest message that imports and uses the StudentId message. It shows how to create a request-specific message for retrieving a student.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nimport \"student_id.proto\";\n\nmessage GetStudentRequest {\n  StudentId id = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Bar Message Type in Protocol Buffers\nDESCRIPTION: A simple Protocol Buffer message definition for a type named Bar with no fields. This is used as a foundation for the repeated field examples that follow.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_21\n\nLANGUAGE: proto\nCODE:\n```\nmessage Bar {}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations with Aliases in Protocol Buffers\nDESCRIPTION: Demonstrates how to create enum aliases by assigning the same value to different enum constants. The 'allow_alias' option must be set to true to avoid compiler warnings when using aliases.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 1;\n  EAA_FINISHED = 2;\n}\n\nenum EnumNotAllowingAlias {\n  ENAA_UNSPECIFIED = 0;\n  ENAA_STARTED = 1;\n  // ENAA_RUNNING = 1;  // Uncommenting this line will cause a warning message.\n  ENAA_FINISHED = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Validation Function for Protocol Buffer Enumerations in Objective-C\nDESCRIPTION: Generated validation function that checks if a given value matches one of the defined enumeration values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_22\n\nLANGUAGE: objc\nCODE:\n```\n// Returns YES if the given numeric value matches one of Foo's\n// defined values (0, 1, 5).\nBOOL Foo_IsValidValue(int32_t value);\n```\n\n----------------------------------------\n\nTITLE: Subrange Deletion in RepeatedPtrField\nDESCRIPTION: Method to delete a range of elements from RepeatedPtrField. Takes start index and count as parameters. Note that implementation can cause quadratic behavior in loops.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_42\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedPtrField::DeleteSubrange(\n        int start,\n        int num)\n```\n\n----------------------------------------\n\nTITLE: Accessing Services in FileDescriptor (C++)\nDESCRIPTION: Gets a service by index, where the index must be between 0 and service_count(). Services are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_88\n\nLANGUAGE: C++\nCODE:\n```\nconst ServiceDescriptor * \n    FileDescriptor::service(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Parsing Message with Extensions in Dart\nDESCRIPTION: This snippet demonstrates how to parse a Protocol Buffers message with extensions in Dart. It shows creating an ExtensionRegistry, registering an extension, and parsing a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\nExtensionRegistry registry = ExtensionRegistry();\nregistry.add(Baz.bar);\nFoo foo = Foo.fromBuffer(input, registry);\n```\n\n----------------------------------------\n\nTITLE: Field Presence Demonstration in proto3 Messages\nDESCRIPTION: Demonstrates how message-type fields always have field presence in proto3, showing that adding the 'optional' modifier doesn't change field presence for message types. The example defines three messages to illustrate this concept.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_2\n\nLANGUAGE: proto3\nCODE:\n```\nsyntax=\"proto3\";\n\npackage foo.bar;\n\nmessage Message1 {}\n\nmessage Message2 {\n  Message1 foo = 1;\n}\n\nmessage Message3 {\n  optional Message1 bar = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Opaque API in Proto File (Edition 2024)\nDESCRIPTION: Shows how to enable the Opaque API in a .proto file using Protobuf Edition 2024, which defaults to the Opaque API without extra imports or options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-faq.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2024\";\n\npackage log;\n\nmessage LogEntry { … }\n```\n\n----------------------------------------\n\nTITLE: Working with Message-Type Fields in PHP\nDESCRIPTION: Example showing how to handle message-type fields in PHP Protocol Buffers. Message fields need to be explicitly created before they can be used.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: php\nCODE:\n```\n$m = new MyMessage();\n$m->setZ(new SubMessage());\n$m->getZ()->setFoo(42);\n\n$m2 = new MyMessage();\n$m2->getZ()->setFoo(42);  // FAILS with an exception\n```\n\n----------------------------------------\n\nTITLE: Parsing Text Format Protocol Message in C++\nDESCRIPTION: Parses a text-format protocol message from the given input stream to the given message object. The message is cleared first, even if parsing fails. Returns true on success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool TextFormat::Parse(\n        io::ZeroCopyInputStream* input,\n        Message* output)\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested Extensions in Protocol Buffers\nDESCRIPTION: Demonstrates how to declare extensions within the scope of another message type, though this approach is not recommended due to potential confusion with inheritance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_21\n\nLANGUAGE: proto\nCODE:\n```\nimport \"common/user_profile.proto\";\n\npackage puppies;\n\nmessage Photo {\n  extend common.UserProfile {\n    int32 likes_count = 111;\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Message Declaration in Protocol Buffers\nDESCRIPTION: A simple protobuf message declaration that creates an empty message named Foo. This will generate a Python class that extends google.protobuf.Message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Modifying Nested Messages Using Multiple Builder Calls\nDESCRIPTION: Java code showing the verbose approach to modifying a deeply nested value by creating new builders at each level of the message hierarchy.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: java\nCODE:\n```\nbaz = baz.toBuilder().setBar(\n    baz.getBar().toBuilder().setFoo(\n        baz.getBar().getFoo().toBuilder().setVal(10).build()\n    ).build()).build();\n```\n\n----------------------------------------\n\nTITLE: Adding Cleared Element to RepeatedPtrField\nDESCRIPTION: Adds a cleared element to the pool of cleared objects in a RepeatedPtrField, transferring ownership. Cannot be used with arena-based fields or arena-allocated values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_51\n\nLANGUAGE: cpp\nCODE:\n```\nvoid RepeatedPtrField::AddCleared(\n        Element * value)\n```\n\n----------------------------------------\n\nTITLE: Running Protocol Buffers Compiler with Command Line Parameters\nDESCRIPTION: The Run method executes the Protocol Compiler with the provided command-line arguments. It returns an error code to be used as the program's exit code. Note that it may not be thread-safe due to calls to strerror().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nint CommandLineInterface::Run(\n        int argc,\n        const char *const argv)\n```\n\n----------------------------------------\n\nTITLE: Enum Aliases Definition\nDESCRIPTION: Demonstrates how to define enum aliases by assigning the same value to different enum constants using the allow_alias option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 1;\n  EAA_FINISHED = 2;\n}\n\nenum EnumNotAllowingAlias {\n  ENAA_UNSPECIFIED = 0;\n  ENAA_STARTED = 1;\n  // ENAA_RUNNING = 1;  // Uncommenting this line will cause a warning message.\n  ENAA_FINISHED = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define oneof fields in a Protocol Buffer message and shows the corresponding Objective-C code generated for handling these fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nmessage Order {\n  oneof OrderID {\n    string name = 1;\n    int32 address = 2;\n  };\n  int32 quantity = 3;\n};\n```\n\nLANGUAGE: objc\nCODE:\n```\ntypedef GPB_ENUM(Order_OrderID_OneOfCase) {\n  Order_OrderID_OneOfCase_GPBUnsetOneOfCase = 0,\n  Order_OrderID_OneOfCase_Name = 1,\n  Order_OrderID_OneOfCase_Address = 2,\n};\n\ntypedef GPB_ENUM(Order_FieldNumber) {\n  Order_FieldNumber_Name = 1,\n  Order_FieldNumber_Address = 2,\n  Order_FieldNumber_Quantity = 3,\n};\n\n@interface Order : GPBMessage\n@property (nonatomic, readwrite) Order_OrderID_OneOfCase orderIDOneOfCase;\n@property (nonatomic, readwrite, copy, null_resettable) NSString *name;\n@property (nonatomic, readwrite) int32_t address;\n@property (nonatomic, readwrite) int32_t quantity;\n@end\n\nvoid Order_ClearOrderIDOneOfCase(Order *message);\n```\n\n----------------------------------------\n\nTITLE: Indenting Text Output (C++)\nDESCRIPTION: Adds two spaces of indentation at the beginning of each line. Can be called multiple times for deeper indentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::Indent()\n```\n\n----------------------------------------\n\nTITLE: Implementing RepeatedField Assignment Operators in C++\nDESCRIPTION: Defines copy and move assignment operators for the RepeatedField class, allowing for efficient copying and moving of RepeatedField objects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedField & operator=(const RepeatedField & other);\nRepeatedField(RepeatedField && other);\nRepeatedField & operator=(RepeatedField && other);\n```\n\n----------------------------------------\n\nTITLE: Defining Source Retention Option in Protocol Buffers\nDESCRIPTION: Demonstrates how to set source retention on a file option extension. This prevents the option from being retained in the runtime binary while still being visible to protoc and its plugins.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_34\n\nLANGUAGE: proto\nCODE:\n```\nextend google.protobuf.FileOptions {\n  optional int32 source_retention_option = 1234\n      [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Source Code Info in FileDescriptor (C++)\nDESCRIPTION: Writes the source code information of this FileDescriptor into the given FileDescriptorProto. Should be used in conjunction with CopyTo().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_98\n\nLANGUAGE: C++\nCODE:\n```\nvoid FileDescriptor::CopySourceCodeInfoTo(\n        FileDescriptorProto * proto) const\n```\n\n----------------------------------------\n\nTITLE: Defining StudentService gRPC service in Protocol Buffers\nDESCRIPTION: This snippet defines a StudentService gRPC service with CreateStudent and GetStudent methods. It imports all necessary request and response messages, demonstrating how to compose a service definition using modular proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nimport \"create_student_request.proto\";\nimport \"create_student_response.proto\";\nimport \"get_student_request.proto\";\nimport \"get_student_response.proto\";\n\nservice StudentService {\n  rpc CreateStudent(CreateStudentRequest) returns (CreateStudentResponse);\n  rpc GetStudent(GetStudentRequest) returns (GetStudentResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Message with Extension Range\nDESCRIPTION: Shows how to declare a Protocol Buffer message with an extension range, which specifies the field numbers that can be used by extensions to this message type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_44\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 100 to 199;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Explicit Field Presence in Ruby\nDESCRIPTION: This snippet shows how to handle explicit field presence in Ruby using Protocol Buffers. It uses the has_foo? method to check if the field is present, and then either clears it or sets it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_15\n\nLANGUAGE: ruby\nCODE:\n```\nm = Msg.new\nif m.has_foo?\n  # Clear the field:\n  m.clear_foo\nelse\n  # Field is not present, so set it.\n  m.foo = 1\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof String View Fields\nDESCRIPTION: Example of defining string and bytes fields within a oneof with string_view feature in protocol buffer definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/string-view.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    string foo = 1 [features.(pb.cpp).string_type=VIEW];\n    ...\n}\noneof example_name {\n    bytes foo = 1 [features.(pb.cpp).string_type=VIEW];\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Service Index in C++\nDESCRIPTION: Method to get the index of this service within the file's services array.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_67\n\nLANGUAGE: C++\nCODE:\n```\nint index() const\n```\n\n----------------------------------------\n\nTITLE: Arena Memory Management in RepeatedPtrField\nDESCRIPTION: Method for swapping contents between RepeatedPtrField instances with arena safety checks. Both fields must be on same arena or heap.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_44\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedPtrField::UnsafeArenaSwap(\n        RepeatedPtrField * other)\n```\n\n----------------------------------------\n\nTITLE: Serializing to Byte Array - C++\nDESCRIPTION: Serializes the message into a byte array of specified size. All required fields must be set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::SerializeToArray(void* data, int size) const\n```\n\n----------------------------------------\n\nTITLE: Computing Serialized Size - C++\nDESCRIPTION: Virtual method that computes the serialized size of the message recursively, including all embedded messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nvirtual size_t MessageLite::ByteSizeLong() const = 0\n```\n\n----------------------------------------\n\nTITLE: Setting Explicit Default Values for Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to override the default value for a field using the 'default' field option. This allows you to specify a custom default value that will be used when the field is not explicitly set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nint32 result_per_page = 3 [default = 10];\n```\n\n----------------------------------------\n\nTITLE: Unpacking Messages from Protocol Buffers Any Type in Kotlin\nDESCRIPTION: Extension function that unpacks a typed message from a Protocol Buffers Any object. This function allows extracting a specific message type T that was previously packed into the Any object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/_index.md#2025-04-11_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\ninline fun <T : Message> Any.unpack(): T\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Definition Files in C++\nDESCRIPTION: The Parser class implements parsing of protocol definitions such as .proto files. It converts a single .proto file to a FileDescriptorProto without resolving imports or performing full validation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.parser.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass Parser {\npublic:\n  Parser();\n  ~Parser();\n  bool Parse(io::Tokenizer* input, FileDescriptorProto* file);\n  void RecordSourceLocationsTo(SourceLocationTable* location_table);\n  void RecordErrorsTo(io::ErrorCollector* error_collector);\n  const std::string& GetSyntaxIdentifier();\n  void SetRequireSyntaxIdentifier(bool value);\n  void SetStopAfterSyntaxIdentifier(bool value);\n};\n```\n\n----------------------------------------\n\nTITLE: Estimating Message Memory Usage in C++\nDESCRIPTION: Estimates the amount of memory used by a message object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nsize_t Reflection::SpaceUsedLong(const Message& message) const\n```\n\n----------------------------------------\n\nTITLE: Using Package-Qualified Type Names in Protocol Buffers\nDESCRIPTION: Shows how to reference message types from other packages using the fully qualified name in Protocol Buffers field definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_38\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  ...\n  optional foo.bar.Open open = 1;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Default Value Override\nDESCRIPTION: Shows how to explicitly override the default value for an enum field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\n  optional Corpus corpus = 4 [default = CORPUS_UNIVERSAL];\n```\n\n----------------------------------------\n\nTITLE: Reading string in CodedInputStream in C++\nDESCRIPTION: Reads a string of specified size from the input stream. Similar to ReadRaw, but reads into a string buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadString(std::string* buffer, int size)\n```\n\n----------------------------------------\n\nTITLE: Implementing Arena-based Message Construction in C++\nDESCRIPTION: C++ code demonstrating message construction using Arena allocation, including setting fields and nested message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n#include <google/protobuf/arena.h>\n\nArena arena;\n\nMyFeatureMessage* arena_message =\n   google::protobuf::Arena::Create<MyFeatureMessage>(&arena);\n\narena_message->set_feature_name(\"Proto2 Arena\");\narena_message->mutable_feature_data()->Add(2);\narena_message->mutable_feature_data()->Add(4);\narena_message->mutable_nested_message()->set_feature_id(247);\n```\n\n----------------------------------------\n\nTITLE: Generating Debug String in C++\nDESCRIPTION: Method to get a string representation of the service descriptor for debugging purposes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_74\n\nLANGUAGE: C++\nCODE:\n```\nstd::string DebugString() const\n```\n\n----------------------------------------\n\nTITLE: Defining Default Scalar Value in Proto2\nDESCRIPTION: Shows how to specify an explicit default value for a singular non-message field in proto2 syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 results_per_page = 3 [default = 10];\n```\n\n----------------------------------------\n\nTITLE: Comparing Fields in Protocol Buffer Messages with DefaultFieldComparator in C++\nDESCRIPTION: The Compare method in DefaultFieldComparator compares values of a field in two protocol buffer messages. It returns SAME, DIFFERENT, or RECURSE for submessages. The method handles both simple and repeated fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvirtual ComparisonResult DefaultFieldComparator::Compare(\n    const Message& message_1,\n    const Message& message_2,\n    const FieldDescriptor* field,\n    int index_1,\n    int index_2,\n    const util::FieldContext* field_context)\n```\n\n----------------------------------------\n\nTITLE: Proto Message with Oneof Field\nDESCRIPTION: Example showing how to define a oneof field in protocol buffers, allowing a choice between an image URL or image data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_21\n\nLANGUAGE: proto\nCODE:\n```\npackage account;\nmessage Profile {\n  oneof avatar {\n    string image_url = 1;\n    bytes image_data = 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reserved Extensions in Protocol Buffers\nDESCRIPTION: Example showing how to mark an extension declaration as reserved when the extension is no longer used, preventing reuse of its field number without breaking up the extension range.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/extension_declarations.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Foo {\n  extensions 4 to 1000 [\n    declaration = {\n      number: 500,\n      full_name: \".my.package.event_annotations\",\n      type: \".logs.proto.ValidationAnnotations\",\n      reserved: true }];\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up a FieldDescriptor for an extension by its fully-qualified name. Returns the extension descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_110\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * FindExtensionByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining Package Structure in Protocol Buffers for Ruby\nDESCRIPTION: Sample proto file demonstrating how the package declaration in a .proto file translates to a module structure in the generated Ruby code. The message will be accessed as FooBar::Baz::MyMessage.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\npackage foo_bar.baz;\n\nmessage MyMessage {}\n```\n\n----------------------------------------\n\nTITLE: Clearing Message Field in C++\nDESCRIPTION: Clears the value of a field, resetting it to its default state.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::ClearField(Message* message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Code for Nested Types\nDESCRIPTION: Shows the Rust code structure generated for nested types defined in a .proto file, including modules for containment.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct Foo {}\n\npub mod foo {\n   pub struct Bar {}\n   pub mod bar {\n      pub struct Baz { ... }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading tag in CodedInputStream in C++\nDESCRIPTION: Reads a tag from the input stream. Returns the tag number, or zero if the tag is an end-group tag.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nuint32 ReadTag()\n```\n\n----------------------------------------\n\nTITLE: Defining FileDescriptor Syntax Enumeration in C++\nDESCRIPTION: Enumeration defining the possible syntax versions for Protocol Buffer files. Includes SYNTAX_UNKNOWN (0), SYNTAX_PROTO2 (2), and SYNTAX_PROTO3 (3).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_79\n\nLANGUAGE: C++\nCODE:\n```\nenum FileDescriptor::Syntax {\n  SYNTAX_UNKNOWN = 0,\n  SYNTAX_PROTO2 = 2,\n  SYNTAX_PROTO3 = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Enum Definition in Protocol Buffers\nDESCRIPTION: Demonstrates a basic enum definition with an optional field in a message. Used to explain the difference between open and closed enum behaviors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/enum.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nenum Enum {\n  A = 0;\n  B = 1;\n}\n\nmessage Msg {\n  optional Enum enum = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Optional String/Bytes Fields in Protocol Buffers\nDESCRIPTION: Illustrates the definition of optional string and bytes fields in both proto2 and proto3 syntax. These definitions result in specific C++ accessor methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\noptional string foo = 1;\nrequired string foo = 1;\noptional bytes foo = 1;\nrequired bytes foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Writing 32-bit Varint encoded value in CodedOutputStream\nDESCRIPTION: Writes an unsigned 32-bit integer using Protocol Buffers' Varint encoding format, which uses fewer bytes for smaller values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_80\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteVarint32(uint32 value)\n```\n\n----------------------------------------\n\nTITLE: Using CodedOutputStream with Direct Buffer Writing in C++\nDESCRIPTION: Example demonstrating how to use CodedOutputStream with direct buffer writing optimization. This pattern checks if the stream has enough buffer space for the entire message, and if so, uses the ToArray methods to avoid bound checks.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_66\n\nLANGUAGE: C++\nCODE:\n```\nCodedOutputStream* coded_output = new CodedOutputStream(raw_output);\nint magic_number = 1234;\nchar text[] = \"Hello world!\";\n\nint coded_size = sizeof(magic_number) +\n                 CodedOutputStream::VarintSize32(strlen(text)) +\n                 strlen(text);\n\nuint8* buffer =\n    coded_output->GetDirectBufferForNBytesAndAdvance(coded_size);\nif (buffer != nullptr) {\n  // The output stream has enough space in the buffer: write directly to\n  // the array.\n  buffer = CodedOutputStream::WriteLittleEndian32ToArray(magic_number,\n                                                         buffer);\n  buffer = CodedOutputStream::WriteVarint32ToArray(strlen(text), buffer);\n  buffer = CodedOutputStream::WriteRawToArray(text, strlen(text), buffer);\n} else {\n  // Make bound-checked writes, which will ask the underlying stream for\n  // more space as needed.\n  coded_output->WriteLittleEndian32(magic_number);\n  coded_output->WriteVarint32(strlen(text));\n  coded_output->WriteRaw(text, strlen(text));\n}\n\ndelete coded_output;\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Protocol Buffer Enumerations\nDESCRIPTION: Shows how Protocol Buffer enumerations are mapped to Objective-C code, including the enum definition with GPB_ENUM macro and enum descriptor function.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_21\n\nLANGUAGE: objc\nCODE:\n```\n// The generated enum value name will be the enumeration name followed by\n// an underscore and then the enumerator name converted to camel case.\n// GPB_ENUM is a macro defined in the Objective-C Protocol Buffer headers\n// that enforces all enum values to be int32 and aids in Swift Enumeration\n// support.\ntypedef GPB_ENUM(Foo) {\n  Foo_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue, //proto3 only\n  Foo_ValueA = 0,\n  Foo_ValueB = 1;\n  Foo_ValueC = 5;\n};\n\n// Returns information about what values this enum type defines.\nGPBEnumDescriptor *Foo_EnumDescriptor();\n```\n\n----------------------------------------\n\nTITLE: Defining a Protocol Buffer Service in C++\nDESCRIPTION: Example of defining a simple protocol buffer service called 'MyService' with a single method 'Foo'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.service.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nservice MyService {\n  rpc Foo(MyRequest) returns(MyResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: GzipOutputStream BackUp Method\nDESCRIPTION: Marks specified number of bytes from last buffer as unused. Must be called after Next() and count must not exceed last buffer size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void GzipOutputStream::BackUp(\n        int count)\n```\n\n----------------------------------------\n\nTITLE: Message Type Full Name Accessor\nDESCRIPTION: Method to get the fully-qualified name of a message type including package and nested type scopes. Returns a period-delimited string like \"bar.Foo\" for a message Foo in package bar.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& Descriptor::full_name() const\n```\n\n----------------------------------------\n\nTITLE: Reserving Enum Values and Names in Protocol Buffers\nDESCRIPTION: Shows how to reserve enum values and names to prevent future reuse. This is important when removing enum entries to avoid compatibility issues with old data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  reserved 2, 15, 9 to 11, 40 to max;\n  reserved FOO, BAR;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading tag with cutoff in CodedInputStream in C++\nDESCRIPTION: Reads a tag with a specified cutoff value. This is usually faster than ReadTag() when cutoff is a manifest constant.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nstd::pair<uint32, bool> ReadTagWithCutoff(uint32 cutoff)\n```\n\n----------------------------------------\n\nTITLE: Getting Weak Dependency Count in FileDescriptor (C++)\nDESCRIPTION: Returns the number of files that are imported for weak fields. The weak dependency list is a subset of the dependency list.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_82\n\nLANGUAGE: C++\nCODE:\n```\nint FileDescriptor::weak_dependency_count() const\n```\n\n----------------------------------------\n\nTITLE: TextFormat Parser Class API Declaration\nDESCRIPTION: Declares the main Parser class API for Protocol Buffers text format parsing, including methods for parsing, merging, and controlling parse behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nclass Parser {\n    Parser();\n    ~Parser();\n    bool Parse(io::ZeroCopyInputStream* input, Message* output);\n    bool ParseFromString(ConstStringParam input, Message* output);\n    bool Merge(io::ZeroCopyInputStream* input, Message* output);\n    bool MergeFromString(ConstStringParam input, Message* output);\n    void RecordErrorsTo(io::ErrorCollector* error_collector);\n    void SetFinder(const Finder* finder);\n    void WriteLocationsTo(ParseInfoTree* tree);\n    void AllowPartialMessage(bool allow);\n    void AllowCaseInsensitiveField(bool allow);\n    bool ParseFieldValueFromString(const std::string& input, const FieldDescriptor* field, Message* output);\n    void AllowUnknownExtension(bool allow);\n    void AllowUnknownField(bool allow);\n    void AllowFieldNumber(bool allow);\n    void SetRecursionLimit(int limit);\n};\n```\n\n----------------------------------------\n\nTITLE: Constructing MergedDescriptorDatabase with Two Sources in C++\nDESCRIPTION: Constructor for merging two DescriptorDatabase sources. The sources remain property of the caller.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nMergedDescriptorDatabase(DescriptorDatabase* source1, DescriptorDatabase* source2)\n```\n\n----------------------------------------\n\nTITLE: Map Field Definition in Protocol Buffer\nDESCRIPTION: Protocol Buffer message definitions showing map field and its equivalent repeated message representation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nmessage Test6 {\n  map<string, int32> g = 7;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nmessage Test6 {\n  message g_Entry {\n    string key = 1;\n    int32 value = 2;\n  }\n  repeated g_Entry g = 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Repeated Message Field in Protocol Buffers\nDESCRIPTION: Definition of a repeated field of type Bar with field number 1. This demonstrates how to declare a repeated embedded message field in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_22\n\nLANGUAGE: proto\nCODE:\n```\nrepeated Bar bar = 1;\n```\n\n----------------------------------------\n\nTITLE: Finding Method by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up a MethodDescriptor by its fully-qualified name. Returns the corresponding method descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_115\n\nLANGUAGE: C++\nCODE:\n```\nconst MethodDescriptor * FindMethodByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Using ruby_package Option for Custom Ruby Namespace\nDESCRIPTION: Shows how to use the ruby_package option to override the default module structure generated from the package declaration. This allows specifying a custom Ruby namespace for the generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\noption ruby_package = \"Foo::Bar\";\n```\n\n----------------------------------------\n\nTITLE: Getting Repeated Field Size in C++\nDESCRIPTION: Returns the number of elements in a repeated field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nint Reflection::FieldSize(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Defining Package in Protocol Buffers\nDESCRIPTION: This snippet shows how to declare a package in a .proto file, which affects the Java package of the generated code unless overridden by java_package.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\n```\n\n----------------------------------------\n\nTITLE: Defining Optional and Required Numeric Fields in Protocol Buffers\nDESCRIPTION: Illustrates how to define optional and required numeric fields in a .proto file for both proto2 and proto3.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 foo = 1;\nrequired int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Setting Total Bytes Limit in CodedInputStream\nDESCRIPTION: Method signature for setting the maximum number of bytes that CodedInputStream will read before refusing to continue processing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nint = { SetTotalBytesLimit(total_bytes_limit) }\n```\n\n----------------------------------------\n\nTITLE: Getting Enum Type Count in FileDescriptor (C++)\nDESCRIPTION: Returns the number of top-level enum types defined in this file, not including nested types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_86\n\nLANGUAGE: C++\nCODE:\n```\nint FileDescriptor::enum_type_count() const\n```\n\n----------------------------------------\n\nTITLE: Initializing Printer with Annotation Support\nDESCRIPTION: Constructor for creating a Printer instance with annotation collection capabilities.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nPrinter(ZeroCopyOutputStream* output, char variable_delimiter, AnnotationCollector* annotation_collector)\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Numeric Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define optional numeric fields in Protocol Buffers for both proto2 and proto3 syntax. These definitions generate specific accessor methods in C++.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 foo = 1;\nrequired int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Setting Allocated Message in Protocol Buffers C++\nDESCRIPTION: Replaces the message specified by 'field' with the already-allocated object sub_message, passing ownership to the message. If the field contained a message, that message is deleted. If sub_message is nullptr, the field is cleared.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_58\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::SetAllocatedMessage(\n    Message* message,\n    Message* sub_message,\n    const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Example Protocol Buffer Definition File\nDESCRIPTION: Comprehensive example of a proto2 file demonstrating various Protocol Buffer features including syntax declaration, imports, package options, enums with aliases, nested messages, field options, maps, extensions, and groups.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_39\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\nimport public \"other.proto\";\noption java_package = \"com.example.foo\";\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 1;\n  EAA_FINISHED = 2 [(custom_option) = \"hello world\"];\n}\nmessage Outer {\n  option (my_option).a = true;\n  message Inner {   // Level 2\n    required int64 ival = 1;\n  }\n  repeated Inner inner_message = 2;\n  optional EnumAllowingAlias enum_field = 3;\n  map<int32, string> my_map = 4;\n  extensions 20 to 30;\n}\nmessage Foo {\n  optional group GroupMessage = 1 {\n    optional bool a = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Debugging and Testing Methods\nDESCRIPTION: Debug-focused utilities for converting messages to human-readable format with various output options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstd::string DebugString() const;\nstd::string ShortDebugString() const;\nstd::string Utf8DebugString() const;\nvoid PrintDebugString() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Protocol Buffer Message\nDESCRIPTION: Example of a nested message declaration in a .proto file. This demonstrates how to define a message within another message, which results in nested Go structs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Artist {\n  message Name {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Proto2 Message to Edition 2023 with field_presence Feature\nDESCRIPTION: This example shows how required, optional, and repeated fields in proto2 are converted to Edition 2023 syntax. The features.field_presence feature is set to LEGACY_REQUIRED for required fields, while optional fields use the default EXPLICIT behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage Foo {\n  required int32 x = 1;\n  optional int32 y = 2;\n  repeated int32 z = 3;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Foo {\n  // Setting the field_presence feature retains the proto2 required behavior\n  int32 x = 1 [features.field_presence = LEGACY_REQUIRED];\n  int32 y = 2;\n  repeated int32 z = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor Label Enumeration in C++\nDESCRIPTION: Enumeration that identifies whether a Protocol Buffer field is optional, required, or repeated. These labels define the cardinality of fields in Protocol Buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldDescriptor::Label {\n  LABEL_OPTIONAL = 1,\n  LABEL_REQUIRED = 2,\n  LABEL_REPEATED = 3,\n  MAX_LABEL = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Writing sign-extended 32-bit Varint value in CodedOutputStream\nDESCRIPTION: Equivalent to WriteVarint32() except when the value is negative, in which case it must be sign-extended to a full 10 bytes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_82\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteVarint32SignExtended(int32 value)\n```\n\n----------------------------------------\n\nTITLE: Special Naming Cases in Proto Definition\nDESCRIPTION: Example of Proto message definition with field names that require special handling in generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  optional int32 foo_array = 1;      // Ends with Array\n  optional int32 bar_OneOfCase = 2;  // Ends with oneofcase\n  optional int32 id = 3;             // Is a C/C++/Objective-C keyword\n}\n```\n\n----------------------------------------\n\nTITLE: Looking Up Extension by Printable Name in Protocol Buffers (C++)\nDESCRIPTION: Example showing how to look up an extension's FieldDescriptor given its printable name. This is the reverse operation of PrintableNameForExtension().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_48\n\nLANGUAGE: cpp\nCODE:\n```\nmessage->file()->pool()->FindExtensionByPrintableName(message, name)\n```\n\n----------------------------------------\n\nTITLE: Defining CreateStudentResponse message in Protocol Buffers\nDESCRIPTION: This snippet defines a CreateStudentResponse message that imports and uses the Student message. It demonstrates how to create a response-specific message while reusing common types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nimport \"student.proto\";\n\nmessage CreateStudentResponse {\n  Student student = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Token Structure in C++\nDESCRIPTION: Struct representing a token read from the token stream, including its type, text, and position in the input.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nstruct Tokenizer::Token {\n  TokenType type;\n  std::string text;\n  int line;\n  ColumnNumber column;\n  ColumnNumber end_column;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Set Wire Format in Protocol Buffers\nDESCRIPTION: Sets a message to use an alternative binary format compatible with Google's legacy MessageSet format. This option is rarely needed outside Google.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_47\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  option message_set_wire_format = true;\n  extensions 4 to max;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated String Fields\nDESCRIPTION: Field definitions showing repeated string and bytes fields in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\nrepeated string foo = 1;\nrepeated bytes foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Building File with Error Collection in DescriptorPool (C++)\nDESCRIPTION: Similar to BuildFile() but with error collection. Converts a FileDescriptorProto to descriptors and sends errors to the provided ErrorCollector.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_120\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * BuildFileCollectingErrors(const FileDescriptorProto & proto, ErrorCollector * error_collector)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting Fields in Protocol Buffer Messages\nDESCRIPTION: Basic example showing how to access and set fields in a protocol buffer message using Ruby accessors. The protocol buffer library enforces type checking and range validation when setting field values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nmessage.foo = get_value()\nprint message.foo\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a oneof field in a Protocol Buffers message. It demonstrates a simple message 'Foo' with a oneof field 'test' containing two options: a string 'name' and a SubMessage 'sub_message'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  oneof test {\n    string name = 1;\n    SubMessage sub_message = 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Rust Proto Library\nDESCRIPTION: Generates Rust-specific bindings for a Protobuf schema using the rust_proto_library rule. This connects the language-agnostic proto_library to Rust-specific code generation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/building-rust-protos.md#2025-04-11_snippet_1\n\nLANGUAGE: build\nCODE:\n```\nload(\"//third_party/protobuf/rust:defs.bzl\", \"rust_proto_library\")\n\nproto_library(\n    name = \"person_proto\",\n    srcs = [\"person.proto\"],\n)\n\nrust_proto_library(\n    name = \"person_rust_proto\",\n    deps = [\":person_proto\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Getting byte count from CodedOutputStream\nDESCRIPTION: Returns the total number of bytes written since this object was created, useful for tracking the size of the serialized data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_84\n\nLANGUAGE: C++\nCODE:\n```\nint ByteCount() const\n```\n\n----------------------------------------\n\nTITLE: Incorrect Access to Fields Named as Python Keywords (Python)\nDESCRIPTION: Shows incorrect attempts to access fields with Python keyword names using dot notation, which results in syntax errors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n# WRONG!\nbaz.in  # SyntaxError: invalid syntax\nbaz.from  # SyntaxError: invalid syntax\n```\n\n----------------------------------------\n\nTITLE: ConcatenatingInputStream Constructor\nDESCRIPTION: Constructor for ConcatenatingInputStream that takes an array of ZeroCopyInputStream pointers and count. All streams and array must remain valid until the stream is destroyed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nConcatenatingInputStream(ZeroCopyInputStream *const streams, int count)\n```\n\n----------------------------------------\n\nTITLE: MessageLite Base Class Methods - Arena Operations\nDESCRIPTION: Core methods for arena-based memory management in Protocol Buffers, including getting arena pointers and constructing new instances.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nArena* GetArena() const\nvoid* GetMaybeArenaPointer() const\n```\n\n----------------------------------------\n\nTITLE: Proto Message with Nested Enum\nDESCRIPTION: Definition of an enum within a message to represent the kind of venue. Each enum value has a specific name and numeric value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_25\n\nLANGUAGE: proto\nCODE:\n```\nmessage Venue {\n  enum Kind {\n    KIND_UNSPECIFIED = 0;\n    KIND_CONCERT_HALL = 1;\n    KIND_STADIUM = 2;\n    KIND_BAR = 3;\n    KIND_OPEN_AIR_FESTIVAL = 4;\n  }\n  Kind kind = 1;\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Message Options Definition in Protocol Buffers\nDESCRIPTION: Defines options for Protocol Buffer messages including wire format settings, descriptor generation, deprecation status and map entry configuration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_11\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage MessageOptions {\n  optional bool message_set_wire_format = 1 [default = false];\n  optional bool no_standard_descriptor_accessor = 2 [default = false];\n  optional bool deprecated = 3 [default = false];\n  reserved 4, 5, 6;\n  optional bool map_entry = 7;\n  reserved 8;  // javalite_serializable\n  reserved 9;  // javanano_as_lite\n  repeated UninterpretedOption uninterpreted_option = 999;\n  extensions 1000 to max;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Protocol Buffer Feature Support (C++)\nDESCRIPTION: Method to check if the Protocol Buffer implementation supports unknown enum values. This allows determining if enum values not defined in the .proto file can be handled.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_50\n\nLANGUAGE: C++\nCODE:\n```\nbool SupportsUnknownEnumValues() const\n```\n\n----------------------------------------\n\nTITLE: HTML Metadata for Protocol Buffers PHP API Documentation\nDESCRIPTION: HTML with frontmatter metadata for the Protocol Buffers PHP API documentation page. It includes title, manual link, link target, and weight specifications for site navigation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!-- mdformat global-off -->\n\n---\ntitle: \"PHP API\"\nmanualLink: \"/reference/php/api-docs/\"\nmanualLinkTarget: \"_blank\"\nweight: 735\n---\n```\n\n----------------------------------------\n\nTITLE: Complex Proto Message Definition\nDESCRIPTION: Proto message definition with various field types including nested message, enum, and primitive types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {\n    int32 int32_value = 1;\n  }\n  enum Qux {...}\n  optional int32 int32_value = 1;\n  optional string string_value = 2;\n  optional Bar message_value = 3;\n  optional Qux enum_value = 4;\n  optional bytes bytes_value = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Special Names\nDESCRIPTION: Generated Objective-C code showing how special naming cases are handled with _p suffix.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: objc\nCODE:\n```\ntypedef GPB_ENUM(Foo_FieldNumber) {\n  // If a non-repeatable field name ends with \"Array\" it will be suffixed\n  // with \"_p\" to keep the name distinct from repeated types.\n  Foo_FieldNumber_FooArray_p = 1,\n  // If a field name ends with \"OneOfCase\" it will be suffixed with \"_p\" to\n  // keep the name distinct from OneOfCase properties.\n  Foo_FieldNumber_BarOneOfCase_p = 2,\n  // If a field name is a C/C++/ObjectiveC keyword it will be suffixed with\n  // \"_p\" to allow it to compile.\n  Foo_FieldNumber_Id_p = 3,\n};\n\n@interface Foo : GPBMessage\n@property(nonatomic, readwrite) int32_t fooArray_p;\n@property(nonatomic, readwrite) int32_t barOneOfCase_p;\n@property(nonatomic, readwrite) int32_t id_p;\n@end\n```\n\n----------------------------------------\n\nTITLE: Calculating Varint Size at Compile-Time in Protocol Buffers C++\nDESCRIPTION: A template struct that calculates the size of a varint-encoded 32-bit value at compile time. It's the compile-time equivalent of the VarintSize32() method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_116\n\nLANGUAGE: cpp\nCODE:\n```\nconst size_t value = = (Value < (1 << 7))    ? 1\n                                : (Value < (1 << 14)) ? 2\n                                : (Value < (1 << 21)) ? 3\n                                : (Value < (1 << 28)) ? 4\n                                                      : 5\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Enum Declaration with C/C++/Objective-C Keyword Name\nDESCRIPTION: Example of declaring an enum with a name that conflicts with C/C++ or Objective-C keywords, requiring a suffix in generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nenum method {}\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Enum with Keyword Name\nDESCRIPTION: Shows how Protocol Buffer enums with names that match C/C++/Objective-C keywords are handled by adding an '_Enum' suffix to avoid conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_25\n\nLANGUAGE: objc\nCODE:\n```\n// The generated enumeration name is the keyword suffixed by _Enum.\ntypedef GPB_ENUM(Method_Enum) {}\n```\n\n----------------------------------------\n\nTITLE: Oneof Definition Example\nDESCRIPTION: Example of a oneof field definition in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    int32 foo_int = 4;\n    string foo_string = 9;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for I/O Errors in Protocol Buffers CodedOutputStream\nDESCRIPTION: Method that returns true if there was an underlying I/O error since the CodedOutputStream object was created. It's recommended to call Trim() before this function to catch all errors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_87\n\nLANGUAGE: C++\nCODE:\n```\nbool CodedOutputStream::HadError()\n```\n\n----------------------------------------\n\nTITLE: Go Struct for Message with Repeated Field\nDESCRIPTION: Generated Go struct for a Concert message with a repeated Band field. The field becomes a slice of pointers to Band.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: go\nCODE:\n```\ntype Concert struct {\n    SupportActs []*Band\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Building of Dependencies in Protocol Buffers (C++)\nDESCRIPTION: Internal method that enables lazy building of dependencies of a file. This delays building dependencies until absolutely necessary, which can cause issues if a proto or its dependencies have errors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_144\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::InternalSetLazilyBuildDependencies()\n```\n\n----------------------------------------\n\nTITLE: Setting Objective-C Class Prefix in Proto File\nDESCRIPTION: Demonstrates how to specify an Objective-C class prefix using the objc_class_prefix option in a .proto file. The prefix will be applied to all generated Objective-C classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\noption objc_class_prefix = \"CGOOP\";\n```\n\n----------------------------------------\n\nTITLE: Setting Enum Values in Protocol Buffers using Reflection in C++\nDESCRIPTION: Methods for setting enum field values within Protocol Buffer messages. SetEnum uses an EnumValueDescriptor while SetEnumValue allows setting the value directly using its integer value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_40\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetEnum(Message * message, const FieldDescriptor * field, const EnumValueDescriptor * value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetEnumValue(Message * message, const FieldDescriptor * field, int value) const\n```\n\n----------------------------------------\n\nTITLE: ExtendableMessage Extension Field Access in Kotlin Protocol Buffers\nDESCRIPTION: Kotlin operator function that retrieves the value of a protocol buffer extension field from an ExtendableMessage or ExtendableMessageOrBuilder. This enables property-like syntax for accessing extension fields in protobuf messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get.md#2025-04-11_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\noperator fun <M : GeneratedMessageV3.ExtendableMessage<M>, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder<M>, T : Any> MorBT.get(extension: ExtensionLite<M, T>): T\n```\n\n----------------------------------------\n\nTITLE: Releasing Message in Protocol Buffers C++\nDESCRIPTION: Releases the message specified by 'field' and returns the pointer. If the field existed, the returned pointer will be the same as the pointer returned by MutableMessage(). This function has the same effect as ClearField().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_60\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_FUTURE_MUST_USE_RESULT Message*\n    Reflection::ReleaseMessage(\n        Message* message,\n        const FieldDescriptor* field,\n        MessageFactory* factory = nullptr) const\n```\n\n----------------------------------------\n\nTITLE: Enumeration Descriptor Accessor Function Declaration in Protocol Buffers\nDESCRIPTION: Declaration of the enumeration descriptor accessor function which returns information about the enum definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_23\n\nLANGUAGE: objc\nCODE:\n```\n// GPBEnumDescriptor is defined in the runtime and contains information\n// about the enum definition, such as the enum name, enum value and enum value\n// validation function.\ntypedef GPBEnumDescriptor *(*GPBEnumDescriptorAccessorFunc)();\n```\n\n----------------------------------------\n\nTITLE: Getting Nested Message Fields in C++\nDESCRIPTION: Method for getting a nested message field from a message, with an optional message factory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_34\n\nLANGUAGE: C++\nCODE:\n```\nconst Message& GetMessage(const Message& message, const FieldDescriptor* field, MessageFactory* factory = nullptr) const\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Debug String Options Structure\nDESCRIPTION: Defines options for generating debug string output from descriptors, including whether to include comments and elide certain elements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct DebugStringOptions {\n  bool include_comments;\n  bool elide_group_body;\n  bool elide_oneof_body;\n  DebugStringOptions();\n};\n```\n\n----------------------------------------\n\nTITLE: Go Type and Constants for Nested Enum\nDESCRIPTION: Generated Go type and constants for an enum nested within a message. Constants are prefixed with the message name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_26\n\nLANGUAGE: go\nCODE:\n```\ntype Venue_Kind int32\n\nconst (\n    Venue_KIND_UNSPECIFIED       Venue_Kind = 0\n    Venue_KIND_CONCERT_HALL      Venue_Kind = 1\n    Venue_KIND_STADIUM           Venue_Kind = 2\n    Venue_KIND_BAR               Venue_Kind = 3\n    Venue_KIND_OPEN_AIR_FESTIVAL Venue_Kind = 4\n)\n```\n\n----------------------------------------\n\nTITLE: Using Map Fields in Protocol Buffers Text Format\nDESCRIPTION: Illustrates how to use map fields in Protocol Buffers text format, including both individual entry syntax and list syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_25\n\nLANGUAGE: textproto\nCODE:\n```\nmy_map { key: \"entry1\" value: 1 }\nmy_map { key: \"entry2\" value: 2 }\n\n# You can also use the list syntax\nmy_map: [\n  { key: \"entry3\" value: 3 },\n  { key: \"entry4\" value: 4 }\n]\n```\n\n----------------------------------------\n\nTITLE: Reading varint size as int in CodedInputStream in C++\nDESCRIPTION: Reads a varint from the wire into an int. This method is used when the value is known to fit in an int.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadVarintSizeAsInt(int* value)\n```\n\n----------------------------------------\n\nTITLE: Finding FileDescriptor Containing Symbol in DescriptorPool\nDESCRIPTION: Finds the FileDescriptor that defines a given symbol. Returns nullptr if not found, otherwise equivalent to calling the file() method on the result of Find*ByName().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_122\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * DescriptorPool::FindFileContainingSymbol(ConstStringParam symbol_name) const\n```\n\n----------------------------------------\n\nTITLE: Skipping Bytes in CodedInputStream in C++\nDESCRIPTION: Skips a specified number of bytes in the input stream. Returns false if an underlying read error occurs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\nbool Skip(int count)\n```\n\n----------------------------------------\n\nTITLE: Complex Message Field Definitions in Proto\nDESCRIPTION: Comprehensive example showing various field types in a protocol buffer message including primitive types, strings, nested messages, enums, and bytes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {\n    int32 int32_value = 1;\n  }\n  enum Qux {...}\n  int32 int32_value = 1;\n  string string_value = 2;\n  Bar message_value = 3;\n  Qux enum_value = 4;\n  bytes bytes_value = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Package Statement Definition\nDESCRIPTION: Defines the syntax for package declarations in Protocol Buffers, used to prevent name clashes between message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_12\n\nLANGUAGE: ebnf\nCODE:\n```\npackage = \"package\" fullIdent \";\"\n```\n\n----------------------------------------\n\nTITLE: Initializing OstreamOutputStream in C++\nDESCRIPTION: Creates a stream that writes to a given C++ ostream. An optional block_size parameter specifies the size of buffers returned by Next().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nexplicit OstreamOutputStream(std::ostream* stream, int block_size = -1)\n```\n\n----------------------------------------\n\nTITLE: Generated Name and Value Maps for Enums\nDESCRIPTION: Example of the generated maps for converting between enum values and their string representations. These maps enable conversion between integer values and string names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nvar Genre_name = map[int32]string{\n    0: \"GENRE_UNSPECIFIED\",\n    1: \"GENRE_ROCK\",\n    2: \"GENRE_INDIE\",\n    3: \"GENRE_DRUM_AND_BASS\",\n}\nvar Genre_value = map[string]int32{\n    \"GENRE_UNSPECIFIED\":   0,\n    \"GENRE_ROCK\":          1,\n    \"GENRE_INDIE\":         2,\n    \"GENRE_DRUM_AND_BASS\": 3,\n}\n```\n\n----------------------------------------\n\nTITLE: PHP Class with Reserved Name\nDESCRIPTION: Example of how the compiler handles reserved class names in PHP. When a message has a reserved name like 'Empty', the prefix 'PB' is added to avoid conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: php\nCODE:\n```\nclass PBEmpty {...}\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Symbol in MergedDescriptorDatabase in C++\nDESCRIPTION: Locates the file declaring a fully-qualified symbol name across all merged databases. Returns true and fills the output if found, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool FindFileContainingSymbol(const std::string& symbol_name, FileDescriptorProto* output)\n```\n\n----------------------------------------\n\nTITLE: FileDescriptor Method Declarations in C++\nDESCRIPTION: Collection of method declarations for the FileDescriptor class including finders for message types, enum types, services, and extensions. Also includes methods for copying, debugging, and source location handling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_80\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& name() const\nconst DescriptorPool* pool() const\nconst FileDescriptor* dependency(int index) const\nint public_dependency_count() const\nFindMessageTypeByName(ConstStringParam name) const\nFindEnumTypeByName(ConstStringParam name) const\nFindServiceByName(ConstStringParam name) const\nFindExtensionByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Protocol Buffer Message\nDESCRIPTION: Example of a simple message declaration in a .proto file. This demonstrates the basic syntax for defining a protocol buffer message, which will be translated into a Go struct.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Artist {}\n```\n\n----------------------------------------\n\nTITLE: Constructing EpsCopyOutputStream for Array Serialization in C++\nDESCRIPTION: Constructor for EpsCopyOutputStream when serializing to a pre-allocated array. This method doesn't include overflow protection as the total size is known in advance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_61\n\nLANGUAGE: C++\nCODE:\n```\n EpsCopyOutputStream::EpsCopyOutputStream(\n        void * data,\n        int size,\n        bool deterministic)\n```\n\n----------------------------------------\n\nTITLE: GBP<KEY><VALUE>Dictionary Interface Implementation in Objective-C\nDESCRIPTION: The standard dictionary interface for Protocol Buffers in Objective-C. This interface provides methods for creating dictionaries with primitive values, accessing and enumerating those values, and modifying the dictionary contents.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPB<KEY>Dictionary : NSObject\n@property (nonatomic, readonly) NSUInteger count;\n\n+ (instancetype)dictionary;\n+ (instancetype)dictionaryWithValue:(const )value\n                             forKey:(const <KEY>)key;\n+ (instancetype)dictionaryWithValues:(const  [])values\n                             forKeys:(const <KEY> [])keys\n                               count:(NSUInteger)count;\n+ (instancetype)dictionaryWithDictionary:(GPB<KEY>Dictionary *)dictionary;\n+ (instancetype)dictionaryWithCapacity:(NSUInteger)numItems;\n\n- (instancetype)initWithValues:(const  [])values\n                       forKeys:(const <KEY> [])keys\n                         count:(NSUInteger)count NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithDictionary:(GPB<KEY>Dictionary *)dictionary;\n- (instancetype)initWithCapacity:(NSUInteger)numItems;\n\n- (BOOL)valueForKey:(<KEY>)key value:(VALUE *)value;\n\n- (void)enumerateKeysAndValuesUsingBlock:\n    (void (^)(<KEY> key,  value, BOOL *stop))block;\n\n- (void)removeValueForKey:(<KEY>)aKey;\n- (void)removeAll;\n- (void)setValue:()value forKey:(<KEY>)key;\n- (void)addEntriesFromDictionary:(GPB<KEY>Dictionary *)otherDictionary;\n@end\n```\n\n----------------------------------------\n\nTITLE: Swapping Message Contents in C++\nDESCRIPTION: Swaps the complete contents of two messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nvoid Swap(Message* message1, Message* message2) const\n```\n\n----------------------------------------\n\nTITLE: Declaring Package Specification in Protocol Buffers\nDESCRIPTION: Demonstrates how to declare a package specifier in a .proto file to prevent name clashes between message types, with a basic message definition example.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_30\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\nmessage Open { ... }\n```\n\n----------------------------------------\n\nTITLE: Extension Function - Get Extension Value from Protocol Buffer Messages\nDESCRIPTION: Operator function that retrieves the current value of a proto extension from an ExtendableMessageOrBuilder. Returns the extension value of type T.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: Kotlin\nCODE:\n```\noperator fun <M : GeneratedMessageV3.ExtendableMessage<M>, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder<M>, T : Any> MorBT.get(extension: ExtensionLite<M, T>): T\n```\n\n----------------------------------------\n\nTITLE: Defining Map::const_iterator Class in C++\nDESCRIPTION: This snippet defines the const_iterator class for the Map container in Protocol Buffers. It includes typedefs for iterator traits and member functions for iteration and access.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.map.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nclass Map::const_iterator {\npublic:\n    typedef std::forward_iterator_tag iterator_category;\n    typedef typename Map::value_type value_type;\n    typedef ptrdiff_t difference_type;\n    typedef const value_type* pointer;\n    typedef const value_type& reference;\n\n    const_iterator();\n    explicit const_iterator(const InnerIt& it);\n    const_reference operator*() const;\n    const_pointer operator->() const;\n    const_iterator& operator++();\n    const_iterator operator++(int);\n};\n```\n\n----------------------------------------\n\nTITLE: PHP Classes Generated from Nested Messages\nDESCRIPTION: Example showing how nested messages from proto files are converted to PHP classes. Since PHP doesn't support nested classes, the compiler uses underscores to represent the hierarchy.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: php\nCODE:\n```\nclass TestMessage {\n  public a;\n}\n\n// PHP doesn't support nested classes.\nclass TestMessage_NestedMessage {...}\n```\n\n----------------------------------------\n\nTITLE: Reading Little-Endian 64-bit Integer\nDESCRIPTION: Static method for reading a 64-bit little-endian integer from an external buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nstatic const uint8 * ReadLittleEndian64FromArray(const uint8 * buffer, uint64 * value)\n```\n\n----------------------------------------\n\nTITLE: Simple Message Declaration in Protocol Buffer\nDESCRIPTION: Shows a basic message declaration in protocol buffer syntax, which will be used to demonstrate the corresponding generated C# code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Defining Enum in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define an enum in Protocol Buffers. It shows a 'Color' enum with four color options, including an unspecified option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nenum Color {\n  COLOR_UNSPECIFIED = 0;\n  COLOR_RED = 1;\n  COLOR_GREEN = 2;\n  COLOR_BLUE = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Messages in Proto3\nDESCRIPTION: Specifies the syntax for message definitions in Protocol Buffers, which can contain fields, nested enums, nested messages, options, oneofs, map fields, and reserved statements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_28\n\nLANGUAGE: ebnf\nCODE:\n```\nmessage = \"message\" messageName messageBody\nmessageBody = \"{\" { field | enum | message | option | oneof | mapField |\nreserved | emptyStatement } \"}\"\n```\n\n----------------------------------------\n\nTITLE: Reading 32-bit little-endian integer in CodedInputStream in C++\nDESCRIPTION: Reads a 32-bit little-endian integer from the input stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadLittleEndian32(uint32* value)\n```\n\n----------------------------------------\n\nTITLE: Getting Default uint32 Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_UINT32. Returns 0 if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_34\n\nLANGUAGE: cpp\nCODE:\n```\nuint32 FieldDescriptor::default_value_uint32() const\n```\n\n----------------------------------------\n\nTITLE: Import Statement Example in Protocol Buffers\nDESCRIPTION: Demonstrates the use of an import statement with the 'public' modifier to import definitions from another .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nimport public \"other.proto\";\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Message Structure in Proto\nDESCRIPTION: Example of a basic Protocol Buffer message definition with nested message and field declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {\n     int32 b;\n  }\n  Bar a;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor Constants and Members\nDESCRIPTION: Defines constants and member variables for the FieldDescriptor class including max field numbers, reserved ranges, and default value storage for various data types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nclass FieldDescriptor {\n  static const int kMaxNumber = (1 << 29) - 1;\n  static const int kFirstReservedNumber = 19000;\n  static const int kLastReservedNumber = 19999;\n  \n  int32 default_value_int32_;\n  int64 default_value_int64_;\n  uint32 default_value_uint32_;\n  uint64 default_value_uint64_;\n  float default_value_float_;\n  double default_value_double_;\n  bool default_value_bool_;\n  const EnumValueDescriptor* default_value_enum_;\n  const std::string* default_value_string_;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Presence Numeric Fields in Protocol Buffers (proto3)\nDESCRIPTION: Shows how to define implicit presence numeric fields in a proto3 .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nint32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Message Copy and Merge Operations (C++)\nDESCRIPTION: Methods for copying and merging Protocol Buffer messages, handling both complete copies and field merging.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void CopyFrom(const Message& from);\nvirtual void MergeFrom(const Message& from);\n```\n\n----------------------------------------\n\nTITLE: Reading 64-bit little-endian integer in CodedInputStream in C++\nDESCRIPTION: Reads a 64-bit little-endian integer from the input stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadLittleEndian64(uint64* value)\n```\n\n----------------------------------------\n\nTITLE: Using Debug Formatting in Rust for Protobuf Messages\nDESCRIPTION: Demonstrates the usage of fmt::Debug formatting syntax for Protobuf messages in Rust. Uses the {:?} format specifier to generate human-readable strings suitable for logging and error messages, with built-in redaction support for sensitive fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-redaction.md#2025-04-11_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"{:?}\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteCount() for IstreamInputStream in C++\nDESCRIPTION: Returns the total number of bytes read since the object was created.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nvirtual int64_t ByteCount() const\n```\n\n----------------------------------------\n\nTITLE: Efficient Arena Message Release Pattern - C++\nDESCRIPTION: Demonstrates the proper usage of unsafe_arena methods to avoid unnecessary copying when transferring ownership of nested messages between arena-allocated messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\narena_message_2->unsafe_arena_set_allocated_nested_message(\n   arena_message_1->unsafe_arena_release_nested_message());\n```\n\n----------------------------------------\n\nTITLE: Writing Varint32 Values to CodedOutputStream in C++\nDESCRIPTION: Writes an unsigned 32-bit integer using Varint encoding. Writing a 32-bit value is equivalent to casting it to uint64 and writing it as a 64-bit value, but may be more efficient.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_111\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CodedOutputStream::WriteVarint32(\n        uint32 value)\n```\n\n----------------------------------------\n\nTITLE: Nested Enum Declaration in Protocol Buffers\nDESCRIPTION: Example of declaring an enum inside a message type with fields using that enum type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  enum Bar {\n    VALUE_A = 0;\n    VALUE_B = 1;\n    VALUE_C = 5;\n  }\n  Bar aBar = 1;\n  Bar aDifferentBar = 2;\n  repeated Bar aRepeatedBar = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Oneof Fields in Protocol Buffers C++\nDESCRIPTION: Shows how to check if any field in a oneof is set. Returns true if any field is set, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_52\n\nLANGUAGE: C++\nCODE:\n```\nbool Reflection::HasOneof(\n    const Message& message,\n    const OneofDescriptor* oneof_descriptor) const\n```\n\n----------------------------------------\n\nTITLE: Extension Function - Type Check for Protocol Buffer Any Messages\nDESCRIPTION: Inline function that checks if a Protocol Buffer Any message contains a specific message type T. Returns Boolean indicating if the message is of the specified type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/_index.md#2025-04-11_snippet_2\n\nLANGUAGE: Kotlin\nCODE:\n```\ninline fun <T : Message> Any.isA(): Boolean\n```\n\n----------------------------------------\n\nTITLE: Getting source location for EnumDescriptor in C++\nDESCRIPTION: Updates out_location to the source location of the complete extent of this enum declaration. Returns false and leaves out_location unchanged if location information is not available.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_62\n\nLANGUAGE: C++\nCODE:\n```\nbool EnumDescriptor::GetSourceLocation(\n        SourceLocation * out_location) const\n```\n\n----------------------------------------\n\nTITLE: String Cord Type Definition in Rust\nDESCRIPTION: Enum definition for handling CORD-typed string fields, providing both owned and borrowed variants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nenum ProtoStringCow<'a> {\n  Owned(ProtoString),\n  Borrowed(&'a ProtoStr)\n}\n```\n\n----------------------------------------\n\nTITLE: Open Struct API Map Operations\nDESCRIPTION: Example code showing map operations using the Open Struct API, including getting/setting values, deleting elements, and checking map size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Getting the entire map value.\nv := m.GetItems()\n\n// Setting the field.\nm.Items = v\n\n// Get an element in a map field.\nv := m.Items[k]\n\n// Set an element in a map field.\n// This will panic if m.Items is nil.\n// You should check m.Items for nil\n// before doing the assignment to ensure\n// it won't panic.\nm.Items[k] = v\n\n// Delete an element in a map field.\ndelete(m.Items, k)\n\n// Get the size of a map field.\nn := len(m.GetItems())\n\n// Clearing the field.\nm.Items = nil\n```\n\n----------------------------------------\n\nTITLE: Simplifying Nested Types with C# 6 using static\nDESCRIPTION: Shows how to use C# 6's using static directive to simplify references to nested types within Protocol Buffer messages, making the code more readable.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Add this to the other using directives\nusing static Google.Protobuf.Examples.AddressBook.Person.Types;\n...\n// The earlier Phones assignment can now be simplified to:\nPhones = { new PhoneNumber { Number = \"555-4321\", Type = PhoneType.HOME } }\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Enum in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define a nested enum within a message in Protocol Buffers. It shows a 'Color' enum nested inside a 'Bar' message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: proto\nCODE:\n```\nmessage Bar {\n  enum Color {\n    COLOR_UNSPECIFIED = 0;\n    COLOR_RED = 1;\n    COLOR_GREEN = 2;\n    COLOR_BLUE = 3;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Syntax and Package in Protocol Buffers\nDESCRIPTION: The initial section of the protocol buffer file that declares the syntax version (proto3), package name to prevent naming conflicts, and imports the Timestamp proto definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\npackage tutorial;\n\nimport \"google/protobuf/timestamp.proto\";\n```\n\n----------------------------------------\n\nTITLE: Using Any Type in Protocol Buffers\nDESCRIPTION: Shows how to use the Any message type to embed arbitrary serialized messages without their .proto definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_31\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/any.proto\";\n\nmessage ErrorStatus {\n  string message = 1;\n  repeated google.protobuf.Any details = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated Numeric Field\nDESCRIPTION: Field definition showing a repeated integer field in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: proto\nCODE:\n```\nrepeated int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Using Oneof Fields in Protocol Buffers Text Format\nDESCRIPTION: Shows valid and invalid uses of oneof fields in Protocol Buffers text format, emphasizing that only one oneof member can be specified at a time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_27\n\nLANGUAGE: textproto\nCODE:\n```\n# Valid: only one field from the Example oneof is set.\nmessage {\n  not_part_of_oneof: \"always valid\"\n  first_oneof_field: \"valid by itself\"\n}\n\n# Valid: the other oneof field is set.\nmessage {\n  not_part_of_oneof: \"always valid\"\n  second_oneof_field: \"valid by itself\"\n}\n\n# Invalid: multiple fields from the Example oneof are set.\nmessage {\n  not_part_of_oneof: \"always valid\"\n  first_oneof_field: \"not valid\"\n  second_oneof_field: \"not valid\"\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Message Example\nDESCRIPTION: Shows an example of a message declaration in Protocol Buffers with nested message, map field, and extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_32\n\nLANGUAGE: proto\nCODE:\n```\nmessage Outer {\n  option (my_option).a = true;\n  message Inner {   // Level 2\n    required int64 ival = 1;\n  }\n  map<int32, string> my_map = 2;\n  extensions 20 to 30;\n}\n```\n\n----------------------------------------\n\nTITLE: Message Reflection Methods\nDESCRIPTION: Reflection-based implementations for basic message operations including type information and state management.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvirtual std::string GetTypeName() const;\nvirtual void Clear();\nvirtual bool IsInitialized() const;\nvirtual void CheckTypeAndMergeFrom();\n```\n\n----------------------------------------\n\nTITLE: EnumValueDescriptor Member Functions - C++\nDESCRIPTION: Core member functions of the EnumValueDescriptor class for accessing enum value properties including name, index, number, and full name. Includes methods for debug output and source location tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_63\n\nLANGUAGE: C++\nCODE:\n```\ntypedef EnumValueDescriptorProto Proto;\nconst std::string& name() const;\nint index() const;\nint number() const;\nconst std::string& full_name() const;\nconst FileDescriptor* file() const;\nconst EnumDescriptor* type() const;\nconst EnumValueOptions& options() const;\nvoid CopyTo(EnumValueDescriptorProto* proto) const;\nstd::string DebugString() const;\nstd::string DebugStringWithOptions(const DebugStringOptions& options) const;\nbool GetSourceLocation(SourceLocation* out_location) const;\n```\n\n----------------------------------------\n\nTITLE: Iterating RepeatedField in C++\nDESCRIPTION: Methods for obtaining iterators to traverse the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\niterator begin()\nconst_iterator begin() const\nconst_iterator cbegin() const\niterator end()\nconst_iterator end() const\nconst_iterator cend() const\n```\n\n----------------------------------------\n\nTITLE: EBNF Representation of Identifiers\nDESCRIPTION: Extended Backus-Naur Form (EBNF) syntax defining identifiers in the Protocol Buffer Text Format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\nIDENT = letter, { letter | dec } ;\n```\n\n----------------------------------------\n\nTITLE: Merging Protocol Buffer from String in C++\nDESCRIPTION: Method for merging a protocol buffer contained in a string into the Message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nbool MergeFromString(ConstStringParam data)\n```\n\n----------------------------------------\n\nTITLE: MethodDescriptor Class Member Functions - C++\nDESCRIPTION: Core member functions of the MethodDescriptor class for accessing method properties like name, types, and options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_77\n\nLANGUAGE: C++\nCODE:\n```\ntypedef MethodDescriptorProto Proto;\n\nconst std::string& name() const;\nconst std::string& full_name() const;\nint index() const;\nconst FileDescriptor* file() const;\nconst ServiceDescriptor* service() const;\nconst Descriptor* input_type() const;\nconst Descriptor* output_type() const;\nbool client_streaming() const;\nbool server_streaming() const;\nconst MethodOptions& options() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Service Method in Protocol Buffers\nDESCRIPTION: Example of using the Empty message type in a service definition to represent methods with no request or response parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nservice Foo {\n  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RepeatedField Constructors and Destructor in C++\nDESCRIPTION: Defines various constructors for the RepeatedField class, including default, arena-based, copy, and range constructors. Also includes the destructor declaration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr RepeatedField();\nexplicit RepeatedField(Arena * arena);\nRepeatedField(const RepeatedField & other);\ntemplate <typename Iter>\nRepeatedField(Iter begin, Iter end);\n~RepeatedField();\n```\n\n----------------------------------------\n\nTITLE: Reading Binary Data with CodedInputStream in C++\nDESCRIPTION: Shows how to read binary data from a file using CodedInputStream. Demonstrates reading a magic number and length-delimited string that was written using CodedOutputStream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint fd = open(\"myfile\", O_RDONLY);\nZeroCopyInputStream* raw_input = new FileInputStream(fd);\nCodedInputStream* coded_input = new CodedInputStream(raw_input);\n\ncoded_input->ReadLittleEndian32(&magic_number);\nif (magic_number != 1234) {\n  cerr << \"File not in expected format.\" << endl;\n  return;\n}\n\nuint32 size;\ncoded_input->ReadVarint32(&size);\n\nchar* text = new char[size + 1];\ncoded_input->ReadRaw(buffer, size);\ntext[size] = '\\0';\n\ndelete coded_input;\ndelete raw_input;\nclose(fd);\n\ncout << \"Text is: \" << text << endl;\ndelete [] text;\n```\n\n----------------------------------------\n\nTITLE: Raw Bytes Output to Buffer (C++)\nDESCRIPTION: Writes a specified number of bytes to the output buffer without processing newlines for indentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::WriteRaw(\n        const char * data,\n        int size)\n```\n\n----------------------------------------\n\nTITLE: Objective-C Extensions for Duration Well-Known Type\nDESCRIPTION: Category extension for the Duration well-known type in proto3, providing convenience methods for working with time intervals.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_30\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPBDuration (GPBWellKnownTypes)\n@property (nonatomic, readwrite) NSTimeInterval timeIntervalSince1970;\n- (instancetype)initWithTimeIntervalSince1970:\n    (NSTimeInterval)timeIntervalSince1970;\n@end\n```\n\n----------------------------------------\n\nTITLE: Setting Repeated Fields in Go\nDESCRIPTION: Example showing how to initialize and set values for a repeated field in Go.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nconcert := &Concert{\n  SupportActs: []*Band{\n    {}, // First element.\n    {}, // Second element.\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Timestamp Format\nDESCRIPTION: Illustrates RFC 3339 timestamp format used for Protobuf Timestamp type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/json.md#2025-04-11_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"1972-01-01T10:00:20.021Z\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Service Name in C++\nDESCRIPTION: Method to access the name of the service without its containing scope.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_65\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string & name() const\n```\n\n----------------------------------------\n\nTITLE: EBNF Representation of String Literals\nDESCRIPTION: Extended Backus-Naur Form (EBNF) syntax defining string literals with various escape sequences for the Protocol Buffer Text Format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_10\n\nLANGUAGE: ebnf\nCODE:\n```\nSTRING = single_string | double_string ;\nsingle_string = \"'\", { escape | char - \"'\" - newline - \"\\\" }, \"'\" ;\ndouble_string = '\"', { escape | char - '\"' - newline - \"\\\" }, '\"' ;\n\nescape = \"\\a\"                        (* ASCII #7  (bell)                 *)\n       | \"\\b\"                        (* ASCII #8  (backspace)            *)\n       | \"\\f\"                        (* ASCII #12 (form feed)            *)\n       | \"\\n\"                        (* ASCII #10 (line feed)            *)\n       | \"\\r\"                        (* ASCII #13 (carriage return)      *)\n       | \"\\t\"                        (* ASCII #9  (horizontal tab)       *)\n       | \"\\v\"                        (* ASCII #11 (vertical tab)         *)\n       | \"\\?\"                        (* ASCII #63 (question mark)        *)\n       | \"\\\\\"                        (* ASCII #92 (backslash)            *)\n       | \"\\'\"                        (* ASCII #39 (apostrophe)           *)\n       | '\\\"'                        (* ASCII #34 (quote)                *)\n       | \"\\\", oct, [ oct, [ oct ] ]  (* octal escaped byte value         *)\n       | \"\\x\", hex, [ hex ]          (* hexadecimal escaped byte value   *)\n       | \"\\u\", hex, hex, hex, hex    (* Unicode code point up to 0xffff  *)\n       | \"\\U000\",\n         hex, hex, hex, hex, hex     (* Unicode code point up to 0xfffff *)\n       | \"\\U0010\",\n         hex, hex, hex, hex ;        (* Unicode code point between 0x100000 and 0x10ffff *)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Protocol Buffer Service in C++\nDESCRIPTION: Example of implementing the 'MyService' protocol buffer service in C++, showing how to define the 'Foo' method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.service.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass MyServiceImpl : public MyService {\n public:\n  MyServiceImpl() {}\n  ~MyServiceImpl() {}\n\n  // implements MyService ---------------------------------------\n\n  void Foo(google::protobuf::RpcController* controller,\n           const MyRequest* request,\n           MyResponse* response,\n           Closure* done) {\n    // ... read request and fill in response ...\n    done->Run();\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Proto Message with Map Field\nDESCRIPTION: Example showing how to define a map field in protocol buffers, mapping from string keys to MerchItem message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\nmessage MerchItem {}\n\nmessage MerchBooth {\n  // items maps from merchandise item name (\"Signed T-Shirt\") to\n  // a MerchItem message with more details about the item.\n  map<string, MerchItem> items = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code for Message-Level Enum\nDESCRIPTION: The Go code generated by the Protocol Buffer compiler for a message-level enum. Shows the type definition and constants generated for the Venue.Kind enum.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_15\n\nLANGUAGE: go\nCODE:\n```\ntype Venue_Kind int32\n\nconst (\n    Venue_KIND_UNSPECIFIED       Venue_Kind = 0\n    Venue_KIND_CONCERT_HALL      Venue_Kind = 1\n    Venue_KIND_STADIUM           Venue_Kind = 2\n    Venue_KIND_BAR               Venue_Kind = 3\n    Venue_KIND_OPEN_AIR_FESTIVAL Venue_Kind = 4\n)\n```\n\n----------------------------------------\n\nTITLE: Defining GetStudentResponse message in Protocol Buffers\nDESCRIPTION: This snippet defines a GetStudentResponse message that imports and uses the Student message. It demonstrates how to create a response-specific message for retrieving a student.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nimport \"student.proto\";\n\nmessage GetStudentResponse {\n  Student student = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Unknown Fields to String in C++\nDESCRIPTION: Prints the fields in an UnknownFieldSet directly to a string. Returns false if printing fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool TextFormat::PrintUnknownFieldsToString(\n        const UnknownFieldSet& unknown_fields,\n        std::string* output)\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Reserved Elements to RepeatedField in C++\nDESCRIPTION: Adds multiple already reserved elements to the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nElement * AddNAlreadyReserved(int elements)\n```\n\n----------------------------------------\n\nTITLE: Defining Method Options Idempotency Level Enum in Protocol Buffers\nDESCRIPTION: Declaration of the MethodOptions_IdempotencyLevel enum that specifies the idempotency level of methods in Protocol Buffer services. This determines whether a method can be safely retried.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nenum MethodOptions_IdempotencyLevel\n```\n\n----------------------------------------\n\nTITLE: Proto2 Service Definition\nDESCRIPTION: Defines the syntax for service declarations in Protocol Buffers, which define RPC methods that can be called.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_36\n\nLANGUAGE: ebnf\nCODE:\n```\nservice = \"service\" serviceName \"{\" { option | rpc | emptyStatement } \"}\"\nrpc = \"rpc\" rpcName \"(\" [ \"stream\" ] messageType \")\" \"returns\" \"(\" [ \"stream\" ]\nmessageType \")\" (( \"{\" { option | emptyStatement } \"}\" ) | \";\" )\n```\n\n----------------------------------------\n\nTITLE: Accessing Message Types in FileDescriptor (C++)\nDESCRIPTION: Gets a top-level message type by index, where the index must be between 0 and message_type_count(). Types are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_85\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor * \n    FileDescriptor::message_type(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Accessing Service Options in C++\nDESCRIPTION: Method to get options for this service type as specified in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_69\n\nLANGUAGE: C++\nCODE:\n```\nconst ServiceOptions & options() const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Identifiers Specification\nDESCRIPTION: Defines the rules for constructing identifiers including field names, message names, service names and various type references.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nident = letter { letter | decimalDigit | \"_\" }\nfullIdent = ident { \".\" ident }\nmessageName = ident\nenumName = ident\nfieldName = ident\noneofName = ident\nmapName = ident\nserviceName = ident\nrpcName = ident\nstreamName = ident\nmessageType = [ \".\" ] { ident \".\" } messageName\nenumType = [ \".\" ] { ident \".\" } enumName\ngroupName = capitalLetter { letter | decimalDigit | \"_\" }\n```\n\n----------------------------------------\n\nTITLE: Declaring FileOutputStream::SetCloseOnDelete Method in C++\nDESCRIPTION: This method sets whether the file descriptor should be closed when the stream is destroyed. By default, it is not closed. Warning: This leaves no way to detect if close() fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvoid FileOutputStream::SetCloseOnDelete(bool value)\n```\n\n----------------------------------------\n\nTITLE: Adding Encoded File Descriptors to EncodedDescriptorDatabase\nDESCRIPTION: Method to add an encoded FileDescriptorProto to the database. The caller must ensure the bytes remain valid for the database lifetime.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nbool EncodedDescriptorDatabase::Add(\n        const void * encoded_file_descriptor,\n        int size)\n```\n\n----------------------------------------\n\nTITLE: Getting Default String Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_STRING. Returns an empty string if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_40\n\nLANGUAGE: cpp\nCODE:\n```\nconst std::string & \n    FieldDescriptor::default_value_string() const\n```\n\n----------------------------------------\n\nTITLE: Converting Proto3 to Protobuf Editions Syntax\nDESCRIPTION: Demonstration of how a proto3 file can be converted to the new Protobuf Editions syntax, using the 2023 edition and maintaining proto3 default behaviors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-06-29.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\n// Editions version of proto3 file\nedition = \"2023\";\n\nmessage Player {\n  string name = 1;\n  int32 id = 2 [features.field_presence = IMPLICIT];\n  repeated int32 scores = 3;\n\n  enum Handed {\n    HANDED_UNSPECIFIED = 0,\n    HANDED_LEFT = 1,\n    HANDED_RIGHT = 2,\n    HANDED_AMBIDEXTROUS = 3,\n  }\n\n  Handed handed = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Float Parsing in C++\nDESCRIPTION: Method to allow floats to be suffixed with the letter 'f' in the Tokenizer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nvoid Tokenizer::set_allow_f_after_float(bool value)\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Protocol Buffer Extensions\nDESCRIPTION: Shows how Protocol Buffer extensions are mapped to Objective-C classes and extension descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_32\n\nLANGUAGE: objc\nCODE:\n```\n# File Test2Root\n\n@interface Test2Root : GPBRootObject\n\n// The base class provides:\n//   + (GPBExtensionRegistry *)extensionRegistry;\n// which is an GPBExtensionRegistry that includes all the extensions defined by\n// this file and all files that it depends on.\n\n@end\n\n@interface Test2Root (DynamicMethods)\n+ (GPBExtensionDescriptor *)foo;\n+ (GPBExtensionDescriptor *)repeatedFoo;\n@end\n\n# Message Foo\n\n@interface Foo : GPBMessage\n\n@end\n\n# Message Bar\n\n@interface Bar : GPBMessage\n\n@end\n\n@interface Bar (DynamicMethods)\n\n+ (GPBExtensionDescriptor *)bar;\n+ (GPBExtensionDescriptor *)repeatedBar;\n@end\n```\n\n----------------------------------------\n\nTITLE: Accessing Repeated Fields in Go\nDESCRIPTION: Example showing how to access elements in a repeated field using both the getter method and direct field access.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nsupport := concert.GetSupportActs() // support type is []*Band.\nb1 := support[0] // b1 type is *Band, the first element in support_acts.\n```\n\n----------------------------------------\n\nTITLE: Getting Source Location in Protocol Buffers Fields (C++)\nDESCRIPTION: Updates the provided SourceLocation object with the source location of the complete extent of this field declaration. Returns false and leaves the location unchanged if location information was not available.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_49\n\nLANGUAGE: cpp\nCODE:\n```\nbool FieldDescriptor::GetSourceLocation(\n        SourceLocation * out_location) const\n```\n\n----------------------------------------\n\nTITLE: JSON Representation of Field Mask\nDESCRIPTION: This snippet demonstrates how the same field mask is represented in JSON format, with paths separated by commas and using lower-camel case naming conventions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  mask: \"user.displayName,photo\"\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Message Type by Name in FileDescriptor (C++)\nDESCRIPTION: Finds a top-level message type by name (not full_name). Returns nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_92\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor * \n    FileDescriptor::FindMessageTypeByName(\n        ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining String Literals in Protocol Buffers\nDESCRIPTION: Specifies the syntax for string literals in Protocol Buffers, including escape sequences for special characters and Unicode.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_6\n\nLANGUAGE: EBNF\nCODE:\n```\nstrLit = strLitSingle { strLitSingle }\nstrLitSingle = ( \"'\" { charValue } \"'\" ) | ( '\"' { charValue } '\"' )\ncharValue = hexEscape | octEscape | charEscape | unicodeEscape | unicodeLongEscape | /[^\\0\\n\\\\]/\nhexEscape = '\\' ( \"x\" | \"X\" ) hexDigit [ hexDigit ]\noctEscape = '\\' octalDigit [ octalDigit [ octalDigit ] ]\ncharEscape = '\\' ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | '\\' | \"'\" | '\"' )\nunicodeEscape = '\\' \"u\" hexDigit hexDigit hexDigit hexDigit\nunicodeLongEscape = '\\' \"U\" ( \"000\" hexDigit hexDigit hexDigit hexDigit hexDigit |\n                              \"0010\" hexDigit hexDigit hexDigit hexDigit\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated String View Fields\nDESCRIPTION: Example of defining repeated string and bytes fields with string_view feature in protocol buffer definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/string-view.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nrepeated string foo = 1 [features.(pb.cpp).string_type=VIEW];\nrepeated bytes foo = 1 [features.(pb.cpp).string_type=VIEW];\n```\n\n----------------------------------------\n\nTITLE: Proto Field Definition with Singular Scalar Fields (proto2)\nDESCRIPTION: Example showing how optional and required int32 fields are defined in proto2. These will be translated to pointer types in Go.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 birth_year = 1;\nrequired int32 birth_year = 1;\n```\n\n----------------------------------------\n\nTITLE: Proto Package-Level Enum\nDESCRIPTION: Definition of a package-level enum to represent music genres. Each enum value has a specific name and numeric value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_27\n\nLANGUAGE: proto\nCODE:\n```\nenum Genre {\n  GENRE_UNSPECIFIED = 0;\n  GENRE_ROCK = 1;\n  GENRE_INDIE = 2;\n  GENRE_DRUM_AND_BASS = 3;\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Repeated Fields in Protocol Buffers Text Format\nDESCRIPTION: Example showing various ways to specify repeated field values in Protocol Buffers text format, including individual entries and list syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_19\n\nLANGUAGE: textproto\nCODE:\n```\nrepeated_field: 1\nrepeated_field: 2\nrepeated_field: [3, 4, 5]\nrepeated_field: 6\nrepeated_field: [7, 8, 9]\n```\n\n----------------------------------------\n\nTITLE: Accessing Message Reflection in C++\nDESCRIPTION: Gets a non-owning pointer to the Reflection interface for this Message, which allows dynamic reading and modification of message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nconst Reflection* Message::GetReflection() const\n```\n\n----------------------------------------\n\nTITLE: Including Protocol Buffers common.h header in C++\nDESCRIPTION: Shows how to include the common.h header file from the Google Protocol Buffers library, which provides access to basic types and utilities used throughout the library. This snippet also shows the namespace used by Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.common.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/stubs/common.h>\nnamespace google::protobuf\n```\n\n----------------------------------------\n\nTITLE: Go Field Presence Handling with Explicit Presence\nDESCRIPTION: Go example showing field handling with explicit presence in Proto3, using pointer comparison and setting to nil for proper field presence tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nm := GetProto()\nif m.Foo != nil {\n  // Clear the field:\n  m.Foo = nil\n} else {\n  // Field is not present, so set it.\n  m.Foo = proto.Int32(1)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enums in Proto3\nDESCRIPTION: Specifies the syntax for enum definitions in Protocol Buffers, including enum options and enum fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_26\n\nLANGUAGE: ebnf\nCODE:\n```\nenum = \"enum\" enumName enumBody\nenumBody = \"{\" { option | enumField | emptyStatement | reserved } \"}\"\nenumField = ident \"=\" [ \"-\" ] intLit [ \"[\" enumValueOption { \",\"  enumValueOption } \"]\" ]\";\"\nenumValueOption = optionName \"=\" constant\n```\n\n----------------------------------------\n\nTITLE: Finding Enum Type by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up an EnumDescriptor by its fully-qualified name. Returns the corresponding enum descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_112\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumDescriptor * FindEnumTypeByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Opening a File for Writing in C++ GeneratorContext\nDESCRIPTION: The Open method opens a file for writing, truncating it if it exists. It returns a ZeroCopyOutputStream for writing to the file. The filename should be relative to the root of the source tree.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvirtual io::ZeroCopyOutputStream * Open(const std::string & filename) = 0\n```\n\n----------------------------------------\n\nTITLE: Accessing Generated DescriptorPool in Protocol Buffers (C++)\nDESCRIPTION: Static method that returns a pointer to the generated pool, which contains descriptors for all compiled-in protocol buffer definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_107\n\nLANGUAGE: C++\nCODE:\n```\nstatic const DescriptorPool * generated_pool()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Field Mask Projection in Protocol Buffers\nDESCRIPTION: This snippet shows how a FieldMask is applied to filter a response message in Protocol Buffers, illustrating the before and after states of the message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nf {\n  a : 22\n  b {\n    d : 1\n    x : 2\n  }\n  y : 13\n}\nz: 8\n```\n\nLANGUAGE: proto\nCODE:\n```\nf {\n  a : 22\n  b {\n    d : 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Ruby FileDescriptor Syntax in Protocol Buffers\nDESCRIPTION: This code snippet shows the deprecated syntax accessor for FileDescriptor in Ruby, which is being removed. It also introduces new semantic checks to replace the functionality.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v26.md#2025-04-11_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nFileDescriptor.syntax  # Deprecated and removed\n\n# New semantic checks\nFieldDescriptor.has_presence\nFieldDescriptor.is_packed\nFieldDescriptor.requires_utf8_validation\nEnumDescriptor.is_closed\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer Message from Input Stream in C++\nDESCRIPTION: Parses a text-format protocol message from the given ZeroCopyInputStream to the specified Message object. Returns true on success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool Parse(io::ZeroCopyInputStream* input, Message* output)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Supported Features in C++ CodeGenerator\nDESCRIPTION: The GetSupportedFeatures method indicates what features the code generator supports. It should return a bitwise OR of features from the Features enum in plugin.proto.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvirtual uint64_t CodeGenerator::GetSupportedFeatures() const\n```\n\n----------------------------------------\n\nTITLE: Parsing Float Tokens in C++\nDESCRIPTION: Static method to parse a TYPE_FLOAT token. It assumes the input text comes from a valid TYPE_FLOAT token.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nstatic double Tokenizer::ParseFloat(const std::string& text)\n```\n\n----------------------------------------\n\nTITLE: Defining Standalone Enumerations in Protocol Buffers\nDESCRIPTION: Shows how to define an enumeration in the outer scope of a Protocol Buffers file, making it accessible as a module constant.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_32\n\nLANGUAGE: proto\nCODE:\n```\nenum SomeEnum {\n    VALUE_A = 0;\n    VALUE_B = 5;\n    VALUE_C = 1234;\n}\n```\n\n----------------------------------------\n\nTITLE: Repeated Field Operations Comparison\nDESCRIPTION: Demonstrates how to work with repeated fields in both APIs, including getting, setting, accessing elements, and modifying the field contents.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// Getting the entire repeated value.\nv := m.GetSupportActs()\n\n// Setting the field.\nm.SupportActs = v\n\n// Get an element in a repeated field.\ne := m.SupportActs[i]\n\n// Set an element in a repeated field.\nm.SupportActs[i] = e\n\n// Get the length of a repeated field.\nn := len(m.GetSupportActs())\n\n// Truncate a repeated field.\nm.SupportActs = m.SupportActs[:i]\n\n// Append to a repeated field.\nm.SupportActs = append(m.GetSupportActs(), e)\nm.SupportActs = append(m.GetSupportActs(), v...)\n\n// Clearing the field.\nm.SupportActs = nil\n```\n\nLANGUAGE: go\nCODE:\n```\n// Getting the entire repeated value.\nv := m.GetSupportActs()\n\n// Setting the field.\nm.SetSupportActs(v)\n\n// Get an element in a repeated field.\ne := m.GetSupportActs()[i]\n\n// Set an element in a repeated field.\nm.GetSupportActs()[i] = e\n\n// Get the length of a repeated field.\nn := len(m.GetSupportActs())\n\n// Truncate a repeated field.\nm.SetSupportActs(m.GetSupportActs()[:i])\n\n// Append to a repeated field.\nm.SetSupportActs(append(m.GetSupportActs(), e))\nm.SetSupportActs(append(m.GetSupportActs(), v...))\n\n// Clearing the field.\nm.SetSupportActs(nil)\n```\n\n----------------------------------------\n\nTITLE: Tracking Unused Imports in Protocol Buffers (C++)\nDESCRIPTION: Adds a file to the list of files being tracked for unused imports. DescriptorBuilder will log warnings or errors for these files if they contain any unused imports.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_146\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::AddUnusedImportTrackFile(\n        ConstStringParam file_name,\n        bool is_error = false)\n```\n\n----------------------------------------\n\nTITLE: DescriptorPool Constructor in Protocol Buffers (C++)\nDESCRIPTION: Creates an empty DescriptorPool instance. This is the default constructor that initializes a normal, empty pool of descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_102\n\nLANGUAGE: C++\nCODE:\n```\nDescriptorPool()\n```\n\n----------------------------------------\n\nTITLE: Checking if EnumDescriptor is a placeholder in C++\nDESCRIPTION: Returns true if this is a placeholder for an unknown enum. This will only be the case if this descriptor comes from a DescriptorPool with AllowUnknownDependencies() set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_59\n\nLANGUAGE: C++\nCODE:\n```\nbool EnumDescriptor::is_placeholder() const\n```\n\n----------------------------------------\n\nTITLE: Implementing Field Read Masks in Protocol Buffers\nDESCRIPTION: Shows different approaches to implementing field read masks in Protocol Buffers requests. The preferred approach uses google.protobuf.FieldMask, with two alternative implementations that use boolean flags or field tag numbers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\n// Recommended: use google.protobuf.FieldMask\n\n// Alternative one:\nmessage FooReadMask {\n  optional bool return_field1;\n  optional bool return_field2;\n}\n\n// Alternative two:\nmessage BarReadMask {\n  // Tag numbers of the fields in Bar to return.\n  repeated int32 fields_to_return;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring FileInputStream::BackUp Method in C++\nDESCRIPTION: This method backs up a number of bytes in the input stream, allowing previously read data to be re-read. It's useful for procedures that need to read up to a certain point and then return.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void FileInputStream::BackUp(int count)\n```\n\n----------------------------------------\n\nTITLE: Specifying Extension Fields in Protocol Buffers Text Format\nDESCRIPTION: Demonstrates how to specify extension fields using their qualified names in Protocol Buffers text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_20\n\nLANGUAGE: textproto\nCODE:\n```\nlocal_field: 10\n[com.example.ext_field]​: 20\n```\n\n----------------------------------------\n\nTITLE: Converting Proto2 Enum to Edition 2023 with enum_type Feature\nDESCRIPTION: This example demonstrates how a proto2 closed enum is converted to Edition 2023 syntax. The features.enum_type feature is set to CLOSED to maintain the proto2 behavior where out-of-range enum values are stored in the unknown field set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nenum Foo {\n  A = 2;\n  B = 4;\n  C = 6;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nenum Foo {\n  // Setting the enum_type feature overrides the default OPEN enum\n  option features.enum_type = CLOSED;\n  A = 2;\n  B = 4;\n  C = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting API Level in Protocol Buffer File\nDESCRIPTION: Example showing how to set the api_level feature to use the Opaque API in a .proto file using editions syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage log;\n\nimport \"google/protobuf/go_features.proto\";\noption features.(pb.go).api_level = API_OPAQUE;\n\nmessage LogEntry { … }\n```\n\n----------------------------------------\n\nTITLE: Whitespace and Comments Rules in Protocol Buffer Text Format\nDESCRIPTION: Examples demonstrating the proper usage of whitespace and comments when writing values in the protocol buffer text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_1\n\nLANGUAGE: textproto\nCODE:\n```\nvalue: -2.0   # Valid: no additional whitespace.\nvalue: - 2.0  # Valid: whitespace between '-' and '2.0'.\nvalue: -\n  # comment\n  2.0         # Valid: whitespace and comments between '-' and '2.0'.\nvalue: 2 . 0  # Invalid: the floating point period is part of the lexical\n              # element, so no additional whitespace is allowed.\n```\n\n----------------------------------------\n\nTITLE: Declaring Extensions in Protocol Buffers\nDESCRIPTION: This snippet shows how to declare an extension in the container message. It specifies the field number, full name, type, and cardinality of the extension.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_21\n\nLANGUAGE: proto\nCODE:\n```\n// A container message to hold stuff that a user has created.\nmessage UserContent {\n  extensions 100 to 199 [\n    declaration = {\n      number: 126,\n      full_name: \".kittens.kitten_videos\",\n      type: \".kittens.Video\",\n      repeated: true\n    },\n    // Ensures all field numbers in this extension range are declarations.\n    verification = DECLARATION\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Number in DescriptorPool (C++)\nDESCRIPTION: Finds an extension of the given extendee by its number. Returns the corresponding extension descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_116\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * FindExtensionByNumber(const Descriptor * extendee, int number) const\n```\n\n----------------------------------------\n\nTITLE: Field Options Definition in Protocol Buffers\nDESCRIPTION: Specifies options for Protocol Buffer fields including C++ type representation, packed encoding, JavaScript type handling, lazy parsing, and deprecation status.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_12\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage FieldOptions {\n  optional CType ctype = 1 [default = STRING];\n  enum CType {\n    STRING = 0;\n    CORD = 1;\n    STRING_PIECE = 2;\n  }\n  optional bool packed = 2;\n  optional JSType jstype = 6 [default = JS_NORMAL];\n  enum JSType {\n    JS_NORMAL = 0;\n    JS_STRING = 1;\n    JS_NUMBER = 2;\n  }\n  optional bool lazy = 5 [default = false];\n  optional bool deprecated = 3 [default = false];\n  optional bool weak = 10 [default = false];\n  repeated UninterpretedOption uninterpreted_option = 999;\n  extensions 1000 to max;\n  reserved 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Map Class Member Function Signatures in C++\nDESCRIPTION: Collection of method signatures for a templated Map class including lookup operations (at, count, find), modification operations (insert, erase), and utility functions (swap, hash_function).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.map.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\ntemplate T & at(const key_arg<K>& key) const;\ntemplate T & at(const key_arg<K>& key);\ntemplate size_type count(const key_arg<K>& key) const;\ntemplate const_iterator find(const key_arg<K>& key) const;\ntemplate iterator find(const key_arg<K>& key);\ntemplate bool contains(const key_arg<K>& key) const;\ntemplate std::pair<const_iterator, const_iterator> equal_range(const key_arg<K>& key) const;\ntemplate std::pair<iterator, iterator> equal_range(const key_arg<K>& key);\nstd::pair<iterator, bool> insert(const value_type& value);\ntemplate void insert(InputIt first, InputIt last);\nvoid insert(std::initializer_list<value_type> values);\ntemplate size_type erase(const key_arg<K>& key);\niterator erase(iterator pos);\nvoid erase(iterator first, iterator last);\nvoid clear();\nMap& operator=(const Map& other);\nvoid swap(Map& other);\nvoid InternalSwap(Map& other);\nhasher hash_function() const;\nsize_t SpaceUsedExcludingSelfLong() const;\n```\n\n----------------------------------------\n\nTITLE: Field Descriptor Type and Scope Methods in Protocol Buffers C++\nDESCRIPTION: Methods for accessing field metadata including containing type, oneof membership, extension scope, and message/enum type information.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\ncontaining_type() const\ncontaining_oneof() const\nreal_containing_oneof() const\nindex_in_oneof() const\nextension_scope() const\nmessage_type() const\nenum_type() const\n```\n\n----------------------------------------\n\nTITLE: Computing Timestamp from POSIX gettimeofday() in C++\nDESCRIPTION: Creates a Protocol Buffer Timestamp with microsecond precision by using the POSIX gettimeofday() function. The seconds field is set directly, and microseconds are converted to nanoseconds.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nstruct timeval tv;\ngettimeofday(&tv, NULL);\n\nTimestamp timestamp;\ntimestamp.set_seconds(tv.tv_sec);\ntimestamp.set_nanos(tv.tv_usec * 1000);\n```\n\n----------------------------------------\n\nTITLE: Deeply Nested Message Types in Protocol Buffers\nDESCRIPTION: Illustrates how to create deeply nested message types, demonstrating that nested types with the same name are independent when defined in different parent messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\nmessage Outer {       // Level 0\n  message MiddleAA {  // Level 1\n    message Inner {   // Level 2\n      optional int64 ival = 1;\n      optional bool  booly = 2;\n    }\n  }\n  message MiddleBB {  // Level 1\n    message Inner {   // Level 2\n      optional int32  ival = 1;\n      optional bool   booly = 2;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Enum Value in Protocol Buffers C++\nDESCRIPTION: Adds an integer value to a repeated enum field. For proto3, it sets the enum field to the specified value. For proto2, it handles known and unknown enum values differently, potentially adding unknown values to the unknown field set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_64\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::AddEnumValue(\n    Message* message,\n    const FieldDescriptor* field,\n    int value) const\n```\n\n----------------------------------------\n\nTITLE: Enum Type Operations in Protocol Buffers\nDESCRIPTION: Methods for handling enum types within Protocol Buffer messages, including counting enum types, accessing them by index, and looking up enum values by name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nenum_type_count() const\nenum_type(int index) const\nFindEnumTypeByName(ConstStringParam name) const\nFindEnumValueByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Parsing Field Value from String in C++\nDESCRIPTION: Parses the given text as a single field value and stores it into the specified field of the given message. For repeated fields, the new value is added to the end.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool TextFormat::ParseFieldValueFromString(\n        const std::string& input,\n        const FieldDescriptor* field,\n        Message* message)\n```\n\n----------------------------------------\n\nTITLE: Using Extensions in Python\nDESCRIPTION: Shows how to access and modify extension fields using the Extensions dictionary in Python.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfoo = Foo()\nfoo.Extensions[proto_file_pb2.bar] = 2\nassert foo.Extensions[proto_file_pb2.bar] == 2\n```\n\n----------------------------------------\n\nTITLE: Opaque API Oneof Operations\nDESCRIPTION: Example code showing oneof field operations using the new Opaque API, demonstrating the updated syntax for handling oneof fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n// Getting the oneof field that is set.\nswitch m.WhichAvatar() {\ncase pb.Profile_ImageUrl_case:\n  … = m.GetImageUrl()\ncase pb.Profile_ImageData_case:\n  … = m.GetImageData()\n}\n\n// Setting the fields.\nm.SetImageUrl(\"http://\")\nm.SetImageData([]byte(\"…\"))\n\n// Checking whether any oneof field is set\nif m.HasAvatar() { … }\n\n// Clearing the field.\nm.ClearAvatar()\n\n// Checking if a specific field is set.\nif m.HasImageUrl() { … }\n\n// Clearing a specific field.\nm.ClearImageUrl()\n\n// Copy a oneof field\nswitch src.WhichAvatar() {\ncase pb.Profile_ImageUrl_case:\n  m.SetImageUrl(src.GetImageUrl())\ncase pb.Profile_ImageData_case:\n  m.SetImageData(src.GetImageData())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SourceCodeInfo Message in Protocol Buffers\nDESCRIPTION: Defines a message for encapsulating information about the original source file, including detailed location data for source code elements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_16\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage SourceCodeInfo {\n  repeated Location location = 1;\n  message Location {\n    repeated int32 path = 1 [packed = true];\n    repeated int32 span = 2 [packed = true];\n    optional string leading_comments = 3;\n    optional string trailing_comments = 4;\n    repeated string leading_detached_comments = 6;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EnumValueDescriptorProto Message in Protocol Buffers\nDESCRIPTION: Describes a value within an enum in Protocol Buffers. It includes the name, number, and options for the enum value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_7\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage EnumValueDescriptorProto {\n  optional string name = 1;\n  optional int32 number = 2;\n\n  optional EnumValueOptions options = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding File by Name in MergedDescriptorDatabase in C++\nDESCRIPTION: Searches for a file by its name across all merged databases. Returns true and fills the output if found, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool FindFileByName(const std::string& filename, FileDescriptorProto* output)\n```\n\n----------------------------------------\n\nTITLE: Implementing Repeated Field Wrapper in Protocol Buffers\nDESCRIPTION: Shows how to wrap repeated fields in a message to provide has-field functionality, which helps distinguish between unpopulated fields and empty lists.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nmessage FooList {\n  repeated Foo foos;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing to Array with Cached Sizes - C++\nDESCRIPTION: Serializes directly to a byte array using cached sizes, returning pointer to end of written data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\nuint8* MessageLite::SerializeWithCachedSizesToArray(uint8* target) const\n```\n\n----------------------------------------\n\nTITLE: Disabling Generic Services in Protocol Buffers\nDESCRIPTION: Disables the generation of abstract service code in C++, Java, and Python. Recommended for RPC implementations that use code generator plugins instead of abstract services.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_46\n\nLANGUAGE: proto\nCODE:\n```\n// This file relies on plugins to generate service code.\noption cc_generic_services = false;\noption java_generic_services = false;\noption py_generic_services = false;\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Message Proto Structure\nDESCRIPTION: Proto definition file containing MyFeatureMessage with optional and repeated fields, including a nested message reference.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\n// my_feature.proto\n\nsyntax = \"proto2\";\nimport \"nested_message.proto\";\n\npackage feature_package;\n\n// NEXT Tag to use: 4\nmessage MyFeatureMessage {\n  optional string feature_name = 1;\n  repeated int32 feature_data = 2;\n  optional NestedMessage nested_message = 3;\n};\n```\n\n----------------------------------------\n\nTITLE: Checking Optional Field Presence in Python Protocol Buffers\nDESCRIPTION: Demonstrates how to check if an optional field is set in a Protocol Buffer message using the 'has_' method. This is useful when working with messages that may have been created by older versions of the protocol.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/pythontutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nif message.has_field():\n```\n\n----------------------------------------\n\nTITLE: Manipulating ListValue in Python Protocol Buffers\nDESCRIPTION: Demonstrates how to use ListValue message type as a Python sequence, including adding different types of values and checking elements. ListValue allows storing heterogeneous values like numbers, strings, and booleans in a list-like structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nlist_value = struct_message.get_or_create_list(\"key\")\nlist_value.extend([6, \"seven\", True, None])\nlist_value.append(False)\nassert len(list_value) == 5\nassert list_value[0] == 6\nassert list_value[1] == \"seven\"\nassert list_value[2] == True\nassert list_value[3] == None\nassert list_Value[4] == False\n```\n\n----------------------------------------\n\nTITLE: Simple Message Declaration in Protocol Buffers\nDESCRIPTION: Basic message declaration in a .proto file that will generate a Ruby class named Foo. The generated class derives from Ruby's Object class and provides various methods for working with protocol buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Accessing Current Buffer Position in Protocol Buffers\nDESCRIPTION: Method that returns the current position in the output buffer as a pointer to the next byte to be written.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_92\n\nLANGUAGE: C++\nCODE:\n```\nuint8 * Cur() const\n```\n\n----------------------------------------\n\nTITLE: Field Descriptor Type Constants\nDESCRIPTION: Constants defining the minimum and maximum values for Protocol Buffer field descriptor types\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr FieldDescriptorProto_Type FieldDescriptorProto_Type_Type_MIN = FieldDescriptorProto_Type_TYPE_DOUBLE;\nconstexpr FieldDescriptorProto_Type FieldDescriptorProto_Type_Type_MAX = FieldDescriptorProto_Type_TYPE_SINT64;\nconstexpr int FieldDescriptorProto_Type_Type_ARRAYSIZE = FieldDescriptorProto_Type_Type_MAX + 1;\n```\n\n----------------------------------------\n\nTITLE: Defining TextFormat::FieldValuePrinter Class in C++\nDESCRIPTION: Declares the FieldValuePrinter class within the TextFormat namespace, which is deprecated and should be replaced with FastFieldValuePrinter. It includes methods for printing various data types and message components.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nclass TextFormat::FieldValuePrinter {\npublic:\n  FieldValuePrinter();\n  virtual ~FieldValuePrinter();\n  virtual std::string PrintBool(bool val) const;\n  virtual std::string PrintInt32(int32 val) const;\n  virtual std::string PrintUInt32(uint32 val) const;\n  virtual std::string PrintInt64(int64 val) const;\n  virtual std::string PrintUInt64(uint64 val) const;\n  virtual std::string PrintFloat(float val) const;\n  virtual std::string PrintDouble(double val) const;\n  virtual std::string PrintString(const std::string & val) const;\n  virtual std::string PrintBytes(const std::string & val) const;\n  virtual std::string PrintEnum(int32 val, const std::string & name) const;\n  virtual std::string PrintFieldName(const Message & message, const Reflection * reflection, const FieldDescriptor * field) const;\n  virtual std::string PrintMessageStart(const Message & message, int field_index, int field_count, bool single_line_mode) const;\n  virtual std::string PrintMessageEnd(const Message & message, int field_index, int field_count, bool single_line_mode) const;\n};\n```\n\n----------------------------------------\n\nTITLE: Using Rust Proto Library in a Binary\nDESCRIPTION: Demonstrates how to use the generated Rust Protobuf library in a Rust binary target. This includes loading the necessary Bazel rules, defining the proto and its Rust binding, and creating a binary that depends on the generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/building-rust-protos.md#2025-04-11_snippet_2\n\nLANGUAGE: build\nCODE:\n```\nload(\"//third_party/bazel_rules/rules_rust/rust:defs.bzl\", \"rust_binary\")\nload(\"//third_party/protobuf/rust:defs.bzl\", \"rust_proto_library\")\n\nproto_library(\n    name = \"person_proto\",\n    srcs = [\"person.proto\"],\n)\n\nrust_proto_library(\n    name = \"person_rust_proto\",\n    deps = [\":person_proto\"],\n)\n\nrust_binary(\n    name = \"greet\",\n    srcs = [\"greet.rs\"],\n    deps = [\n        \":person_rust_proto\",\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Binary Encoded Message Example\nDESCRIPTION: Example showing the binary encoding of a Test1 message with value 150.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\n08 96 01\n```\n\n----------------------------------------\n\nTITLE: Defining a Numeric Oneof Field in Protocol Buffers\nDESCRIPTION: Example of defining an int32 field within a oneof construct named 'example_name'. This demonstrates the syntax for declaring a numeric field in a oneof context.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_23\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    int32 foo = 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Python Generator Class Declaration\nDESCRIPTION: Declares the Generator class that implements CodeGenerator for generating Python protocol buffer classes. The class provides methods for generating Python code from .proto files and specifying supported protocol buffer features.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.python_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass Generator: public CodeGenerator {\npublic:\n  Generator();\n  virtual ~Generator();\n  virtual bool Generate(const FileDescriptor* file,\n                      const std::string& parameter,\n                      GeneratorContext* generator_context,\n                      std::string* error) const;\n  virtual uint64_t GetSupportedFeatures() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Setting UTF-8 String Escaping in TextFormat Printer (C++)\nDESCRIPTION: Controls whether to output UTF-8 instead of ASCII. When enabled, bytes >= 0x80 in string fields won't be escaped, assuming they are part of UTF-8 multi-byte sequences.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetUseUtf8StringEscaping(\n        bool as_utf8)\n```\n\n----------------------------------------\n\nTITLE: Checking Message Type with Any in Python\nDESCRIPTION: Shows how to use the Is() method to check if an Any message represents a specific protocol buffer type by comparing against the message descriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nassert any_message.Is(message.DESCRIPTOR)\n```\n\n----------------------------------------\n\nTITLE: Generated Oneof API Methods\nDESCRIPTION: Generated Go code showing the core API methods for handling oneof fields, including Which, Has, and Clear methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc (m *Profile) WhichAvatar() case_Profile_Avatar { … }\nfunc (m *Profile) HasAvatar() bool { … }\nfunc (m *Profile) ClearAvatar() { … }\n\ntype case_Profile_Avatar protoreflect.FieldNumber\n\nconst (\n  Profile_Avatar_not_set_case case_Profile_Avatar = 0\n  Profile_ImageUrl_case case_Profile_Avatar = 1\n  Profile_ImageData_case case_Profile_Avatar = 2\n)\n```\n\n----------------------------------------\n\nTITLE: Ensuring Space in EpsCopyOutputStream Buffer in C++\nDESCRIPTION: Method that guarantees space for writing kSlopBytes to the pointer. This operation never fails, though the underlying stream might produce errors that can be checked with HadError().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_62\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_MUST_USE_RESULT uint8 * \n    EpsCopyOutputStream::EnsureSpace(\n        uint8 * ptr)\n```\n\n----------------------------------------\n\nTITLE: Adding FileDescriptorProto to SimpleDescriptorDatabase (C++)\nDESCRIPTION: Method that adds a FileDescriptorProto to the database by making a copy. Returns false if the file conflicts with a file already in the database. The original object can be deleted after Add() returns.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nbool SimpleDescriptorDatabase::Add(\n        const FileDescriptorProto & file)\n```\n\n----------------------------------------\n\nTITLE: Annotating Output with Descriptor\nDESCRIPTION: Template method to link output range between two substitution variables to a descriptor object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\ntemplate void Annotate(const char* begin_varname, const char* end_varname, const SomeDescriptor* descriptor)\n```\n\n----------------------------------------\n\nTITLE: Disabling Dependencies Enforcement\nDESCRIPTION: Changes BuildFile() behavior to allow files to reference message types not declared in dependencies. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_129\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::InternalDontEnforceDependencies()\n```\n\n----------------------------------------\n\nTITLE: Generated C# Code for Enumeration\nDESCRIPTION: The C# enum generated from the Protocol Buffer Color enumeration, showing the name transformation rules applied.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nenum Color\n{\n  Unspecified = 0,\n  Red = 1,\n  Green = 5,\n  Blue = 1234\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient String Handling in Protocol Buffers C++\nDESCRIPTION: Shows how to get a string value without copying, if possible, for improved efficiency when working with string fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_56\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& Reflection::GetStringReference(\n    const Message& message,\n    const FieldDescriptor* field,\n    std::string* scratch) const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Extensions Definition\nDESCRIPTION: Defines the syntax for extension ranges in Protocol Buffers, which allow third-party extensions of messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_25\n\nLANGUAGE: ebnf\nCODE:\n```\nextensions = \"extensions\" ranges \";\"\nranges = range { \",\" range }\nrange =  intLit [ \"to\" ( intLit | \"max\" ) ]\n```\n\n----------------------------------------\n\nTITLE: Defining FlagType Enum for Code Generation\nDESCRIPTION: Enum defining different types of flags used during code generation, including descriptor initialization, extensions, and fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nenum objectivec::FlagType {\n  FLAGTYPE_DESCRIPTOR_INITIALIZATION,\n  FLAGTYPE_EXTENSION,\n  FLAGTYPE_FIELD\n}\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Extension in EncodedDescriptorDatabase (C++)\nDESCRIPTION: Method to find the file that defines an extension for a given message type and field number in the EncodedDescriptorDatabase. It fills the output with the FileDescriptorProto if found and returns true, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool EncodedDescriptorDatabase::FindFileContainingExtension(\n    const std::string & containing_type,\n    int field_number,\n    FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Checking Field Presence and Clearing Optional Fields in Ruby\nDESCRIPTION: Demonstrates how to check for the presence of optional fields using has_...? methods and how to clear fields using clear_... methods. Setting any value, even the default value, marks a field as present.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nm = MyMessage.new\nraise unless !m.has_foo?\nm.foo = 0\nraise unless m.has_foo?\nm.clear_foo\nraise unless !m.has_foo?\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Compiler for Ruby Output Generation\nDESCRIPTION: Shows how to invoke the protocol buffer compiler (protoc) with the --ruby_out flag to generate Ruby code from .proto files. The example demonstrates how the compiler transforms input paths into output file paths.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --ruby_out=build/gen src/foo.proto src/bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: Finding File by Name in EncodedDescriptorDatabase (C++)\nDESCRIPTION: Method to find a file by its name in the EncodedDescriptorDatabase. It fills the output with the FileDescriptorProto if found and returns true, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool EncodedDescriptorDatabase::FindFileByName(\n    const std::string & filename,\n    FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Annotating Output Range in Protocol Buffers Printer (C++)\nDESCRIPTION: Links an output range defined by substitution variables to a file. The range starts at begin_varname's value and ends after end_varname's value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::Annotate(\n        const char * begin_varname,\n        const char * end_varname,\n        const std::string & file_name)\n```\n\n----------------------------------------\n\nTITLE: Defining EpsCopyOutputStream Constants in C++\nDESCRIPTION: Defines a constant for the number of slop bytes used in EpsCopyOutputStream for buffer management.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_60\n\nLANGUAGE: C++\nCODE:\n```\nenum EpsCopyOutputStream::@33 {\n  kSlopBytes = = 16\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ParseFlags Enum in C++\nDESCRIPTION: Defines an enumeration of parsing flags used by the MessageLite class for various parsing operations. These flags control behavior such as merging, partial parsing, and aliasing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nenum MessageLite::ParseFlags {\n  kMerge = 0,\n  kParse = 1,\n  kMergePartial = 2,\n  kParsePartial = 3,\n  kMergeWithAliasing = 4,\n  kParseWithAliasing = 5,\n  kMergePartialWithAliasing = 6,\n  kParsePartialWithAliasing = 7\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Invalid Name Conflict Examples\nDESCRIPTION: Shows examples of prohibited name conflicts within messages in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_33\n\nLANGUAGE: proto\nCODE:\n```\nmessage MyMessage {\n  optional string foo = 1;\n  message foo {}\n}\n\nmessage MyMessage {\n  optional string foo = 1;\n  oneof foo {\n    string bar = 2;\n  }\n}\n\nmessage MyMessage {\n  optional string foo = 1;\n  extend Extendable {\n    optional string foo = 2;\n  }\n}\n\nmessage MyMessage {\n  optional string foo = 1;\n  enum E {\n    foo = 0;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Shows how to properly name and structure a oneof field in Protocol Buffers using lower_snake_case.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/style.md#2025-04-11_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\noneof song_id {\n  string song_human_readable_id = 1;\n  int64 song_machine_id = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing RPC Channel and Service Stub in C++\nDESCRIPTION: This snippet demonstrates how to create an RPC channel and initialize a service stub for remote method invocation. It shows the typical usage pattern for setting up RPC communication.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.service.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nRpcChannel* channel = new MyRpcChannel(\"remotehost.example.com:1234\");\nMyService* service = new MyService::Stub(channel);\nservice->MyMethod(request, &response, callback);\n```\n\n----------------------------------------\n\nTITLE: Defining UnknownField Type Enumeration in C++\nDESCRIPTION: Enumeration defining the possible types of unknown fields in Protocol Buffers including varint, fixed32, fixed64, length-delimited, and group types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nenum UnknownField::Type {\n  TYPE_VARINT,\n  TYPE_FIXED32,\n  TYPE_FIXED64,\n  TYPE_LENGTH_DELIMITED,\n  TYPE_GROUP\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Map Field Definition\nDESCRIPTION: Defines the syntax for map fields in Protocol Buffers, which are key-value pairs with specified key and value types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_23\n\nLANGUAGE: ebnf\nCODE:\n```\nmapField = \"map\" \"<\" keyType \",\" type \">\" mapName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\nkeyType = \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" |\n          \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\"\n```\n\n----------------------------------------\n\nTITLE: Importing Proto Definitions\nDESCRIPTION: Examples of how to import definitions from other .proto files, including public imports for forwarding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_14\n\nLANGUAGE: proto\nCODE:\n```\nimport \"myproject/other_protos.proto\";\n```\n\nLANGUAGE: proto\nCODE:\n```\n// new.proto\n// All definitions are moved here\n```\n\nLANGUAGE: proto\nCODE:\n```\n// old.proto\n// This is the proto that all clients are importing.\nimport public \"new.proto\";\nimport \"other.proto\";\n```\n\nLANGUAGE: proto\nCODE:\n```\n// client.proto\nimport \"old.proto\";\n// You use definitions from old.proto and new.proto, but not other.proto\n```\n\n----------------------------------------\n\nTITLE: Constructing MergedDescriptorDatabase with Multiple Sources in C++\nDESCRIPTION: Constructor for merging multiple DescriptorDatabase sources. The sources vector can be deleted after construction, but the DescriptorDatabases must remain valid.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nexplicit MergedDescriptorDatabase(const std::vector<DescriptorDatabase*>& sources)\n```\n\n----------------------------------------\n\nTITLE: Defining String Field in Protocol Buffer\nDESCRIPTION: Example message definition showing a simple string field in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage Test2 {\n  string b = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Releasing Last Element in Arena-based RepeatedPtrField\nDESCRIPTION: Removes the last element from an arena-based RepeatedPtrField and returns a pointer to it. The returned pointer has the arena's lifetime. Requires current_size_ > 0.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_48\n\nLANGUAGE: cpp\nCODE:\n```\nElement * RepeatedPtrField::UnsafeArenaReleaseLast()\n```\n\n----------------------------------------\n\nTITLE: Field Descriptor Label Constants\nDESCRIPTION: Constants defining the minimum and maximum values for Protocol Buffer field descriptor labels\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr FieldDescriptorProto_Label FieldDescriptorProto_Label_Label_MIN = FieldDescriptorProto_Label_LABEL_OPTIONAL;\nconstexpr FieldDescriptorProto_Label FieldDescriptorProto_Label_Label_MAX = FieldDescriptorProto_Label_LABEL_REPEATED;\nconstexpr int FieldDescriptorProto_Label_Label_ARRAYSIZE = FieldDescriptorProto_Label_Label_MAX + 1;\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer from Array in C++\nDESCRIPTION: Methods for parsing a protocol buffer contained in an array of bytes, with options for handling missing required fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool ParseFromArray(const void* data, int size)\n```\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool ParsePartialFromArray(const void* data, int size)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Oneof Field Definition\nDESCRIPTION: Defines the syntax for 'oneof' fields in Protocol Buffers, which allow you to specify that a message can have one of many fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_21\n\nLANGUAGE: ebnf\nCODE:\n```\noneof = \"oneof\" oneofName \"{\" { option | oneofField } \"}\"\noneofField = type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\n```\n\n----------------------------------------\n\nTITLE: Writing Binary Data with CodedOutputStream in C++\nDESCRIPTION: Demonstrates writing binary data to a file using CodedOutputStream. Shows how to write a magic number and a length-delimited string using varint encoding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint fd = open(\"myfile\", O_CREAT | O_WRONLY);\nZeroCopyOutputStream* raw_output = new FileOutputStream(fd);\nCodedOutputStream* coded_output = new CodedOutputStream(raw_output);\n\nint magic_number = 1234;\nchar text[] = \"Hello world!\";\ncoded_output->WriteLittleEndian32(magic_number);\ncoded_output->WriteVarint32(strlen(text));\ncoded_output->WriteRaw(text, strlen(text));\n\ndelete coded_output;\ndelete raw_output;\nclose(fd);\n```\n\n----------------------------------------\n\nTITLE: Setting Extension Values in Protocol Buffer Messages using Kotlin\nDESCRIPTION: An operator function that sets the value of a protocol buffer extension in a message builder. Takes a generic extension type and corresponding value, working with ExtendableMessage types and their builders.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/set.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\noperator fun <M : GeneratedMessageV3.ExtendableMessage<M>, \nB : GeneratedMessageV3.ExtendableBuilder<M, B>, \nT : Any> \nB.set(extension: ExtensionLite<M, T>, value: T)\n```\n\n----------------------------------------\n\nTITLE: Duration Format\nDESCRIPTION: Shows the string representation of Duration type with fractional digits and 's' suffix.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/json.md#2025-04-11_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n\"1.000340012s\"\n```\n\n----------------------------------------\n\nTITLE: Constructing CodedInputStream from ZeroCopyInputStream in C++\nDESCRIPTION: Creates a CodedInputStream that reads from a given ZeroCopyInputStream. This constructor is explicit to prevent accidental implicit conversions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nexplicit CodedInputStream(ZeroCopyInputStream* input)\n```\n\n----------------------------------------\n\nTITLE: Map Field Definition in Proto\nDESCRIPTION: Example of defining a map field in a proto file. Map fields represent key-value pairs of specified types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nmap<int32, int32> weight = 1;\n```\n\n----------------------------------------\n\nTITLE: UnknownFieldSet Class Definition in C++\nDESCRIPTION: Header file definition for UnknownFieldSet class that manages unrecognized protocol buffer fields. Contains methods for field manipulation, merging, and memory management.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/unknown_field_set.h>\n\nnamespace google::protobuf {\n\nclass UnknownFieldSet {\n public:\n  UnknownFieldSet();\n  ~UnknownFieldSet();\n  void Clear();\n  void ClearAndFreeMemory();\n  bool empty() const;\n  void MergeFrom(const UnknownFieldSet& other);\n  void MergeFromAndDestroy(UnknownFieldSet* other);\n  void Swap(UnknownFieldSet* x);\n  size_t SpaceUsedExcludingSelfLong() const;\n  int SpaceUsedExcludingSelf() const;\n  size_t SpaceUsedLong() const;\n  int SpaceUsed() const;\n  int field_count() const;\n  const UnknownField& field(int index) const;\n  UnknownField* mutable_field(int index);\n  void AddVarint(int number, uint64 value);\n  void AddFixed32(int number, uint32 value);\n  void AddFixed64(int number, uint64 value);\n};\n\n}\n```\n\n----------------------------------------\n\nTITLE: Advancing to Next Token with Comments in C++\nDESCRIPTION: Method to advance to the next token while collecting comments between tokens. It handles attached and detached comments, stripping comment markers and formatting block comments.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nbool Tokenizer::NextWithComments(\n    std::string* prev_trailing_comments,\n    std::vector<std::string>* detached_comments,\n    std::string* next_leading_comments)\n```\n\n----------------------------------------\n\nTITLE: Constructing CodedInputStream from Buffer in C++\nDESCRIPTION: Creates a CodedInputStream that reads from a given flat array. This constructor is faster than using an ArrayInputStream and implicitly calls PushLimit(size).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nexplicit CodedInputStream(const uint8 * buffer, int size)\n```\n\n----------------------------------------\n\nTITLE: Protocol Compiler Generator Parameter Example\nDESCRIPTION: Example showing how to pass extra parameters to a code generator by specifying them before the output directory, separated by a colon.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nprotoc --foo_out=enable_bar:outdir\n```\n\n----------------------------------------\n\nTITLE: Proto2 Group Field Definition (Deprecated)\nDESCRIPTION: Defines the syntax for group fields in Protocol Buffers, though this feature is deprecated in favor of nested message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_19\n\nLANGUAGE: ebnf\nCODE:\n```\ngroup = label \"group\" groupName \"=\" fieldNumber messageBody\n```\n\n----------------------------------------\n\nTITLE: Converting Proto3 Message to Edition 2023 with field_presence Feature\nDESCRIPTION: This example demonstrates how proto3 fields with implicit presence and optional fields are converted to Edition 2023 syntax. The file-level features.field_presence is set to IMPLICIT to match proto3 default behavior, with individual fields overriding as needed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage Bar {\n  int32 x = 1;\n  optional int32 y = 2;\n  repeated int32 z = 3;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n// Setting the file-level field_presence feature matches the proto3 implicit default\noption features.field_presence = IMPLICIT;\n\nmessage Bar {\n  int32 x = 1;\n  // Setting the field_presence here retains the explicit state that the proto3\n  // field has because of the optional syntax\n  int32 y = 2 [features.field_presence = EXPLICIT];\n  repeated int32 z = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: DescriptorPool Destructor in Protocol Buffers (C++)\nDESCRIPTION: Destructor for the DescriptorPool class that cleans up all the descriptors in the pool.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_104\n\nLANGUAGE: C++\nCODE:\n```\n~DescriptorPool()\n```\n\n----------------------------------------\n\nTITLE: FieldMask Field Number Operations\nDESCRIPTION: Method to create a FieldMask from field numbers after validating them.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static void FromFieldNumbers(const std::vector<int64_t>& field_numbers, FieldMask* out);\n```\n\n----------------------------------------\n\nTITLE: Proto2 Message Definition\nDESCRIPTION: Defines the syntax for message declarations in Protocol Buffers, which are the main data structures.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_31\n\nLANGUAGE: ebnf\nCODE:\n```\nmessage = \"message\" messageName messageBody\nmessageBody = \"{\" { field | enum | message | extend | extensions | group |\noption | oneof | mapField | reserved | emptyStatement } \"}\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Custom Enum Value Options in Protocol Buffers\nDESCRIPTION: Demonstrates how to create custom options for enum values by extending EnumValueOptions, and how to apply them to enum values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_50\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.EnumValueOptions {\n  optional string string_name = 123456789;\n}\n\nenum Data {\n  DATA_UNSPECIFIED = 0;\n  DATA_SEARCH = 1 [deprecated = true];\n  DATA_DISPLAY = 2 [\n    (string_name) = \"display_value\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LengthDelimited Union in C++\nDESCRIPTION: This union defines the structure for length-delimited fields in UnknownField. It includes a pointer to a string value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nunion UnknownField::LengthDelimited {\n    std::string *string_value;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing iterator method for DslList in Protocol Buffers Kotlin\nDESCRIPTION: Implementation of the iterator method for the DslList class, which returns an Iterator for traversing through the elements of the list. Essential for supporting for-each loops.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nopen operator override fun iterator(): Iterator<E>\n```\n\n----------------------------------------\n\nTITLE: Configuring Generic Service Generation\nDESCRIPTION: Shows how to enable or disable generic service code generation in a .proto file. Generic services are deprecated in favor of RPC system-specific plugins.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_46\n\nLANGUAGE: proto\nCODE:\n```\noption cc_generic_services = true;\n```\n\nLANGUAGE: proto\nCODE:\n```\noption cc_generic_services = false;\n```\n\n----------------------------------------\n\nTITLE: Using Message Types as Fields\nDESCRIPTION: Shows how to use other message types as field types within a message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  repeated Result results = 1;\n}\n\nmessage Result {\n  optional string url = 1;\n  optional string title = 2;\n  repeated string snippets = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Comment Styles in C++\nDESCRIPTION: Enum defining valid comment styles for the Tokenizer, including C++ style and shell script style comments.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nenum Tokenizer::CommentStyle {\n  CPP_COMMENT_STYLE,\n  SH_COMMENT_STYLE\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing CodedOutputStream's Underlying Buffer with GetDirectBufferPointer in C++\nDESCRIPTION: This method provides direct access to the unwritten part of the stream's underlying buffer without advancing the current position. It's useful for implementing external fast serialization routines.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_109\n\nLANGUAGE: cpp\nCODE:\n```\nbool CodedOutputStream::GetDirectBufferPointer(\n        void ** data,\n        int * size)\n```\n\n----------------------------------------\n\nTITLE: TextFormat ParseLocation Structure Definition\nDESCRIPTION: Defines a structure for tracking location information in parsed text with line and column numbers. Includes default and parameterized constructors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nstruct ParseLocation {\n    int line;\n    int column;\n    ParseLocation();\n    ParseLocation(int line_param, int column_param);\n};\n```\n\n----------------------------------------\n\nTITLE: Constructing Arena with Custom Options in C++\nDESCRIPTION: Explicit constructor for Arena class that takes ArenaOptions. This allows for custom configuration of the Arena's behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nexplicit Arena(const ArenaOptions & options)\n```\n\n----------------------------------------\n\nTITLE: Navigation Menu Links in Markdown\nDESCRIPTION: A markdown-formatted navigation menu with links to the main sections of the Protocol Buffers documentation website, including the home page, programming guides, codelabs, and reference documentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/navbar.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n*   [Home](/)\n*   [Programming Guides](/programming-guides)\n*   [Codelabs](/getting-started/codelabs)\n*   [Reference](/reference/)\n```\n\n----------------------------------------\n\nTITLE: Defining Import Statements in Proto3\nDESCRIPTION: Specifies the syntax for import statements in Protocol Buffers, including optional 'weak' and 'public' modifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_11\n\nLANGUAGE: ebnf\nCODE:\n```\nimport = \"import\" [ \"weak\" | \"public\" ] strLit \";\"\n```\n\n----------------------------------------\n\nTITLE: Inserting Code with Generated Code Info in C++ GeneratorContext\nDESCRIPTION: The OpenForInsertWithGeneratedCodeInfo method is similar to OpenForInsert but also handles generated code info. This feature will be removed in the future.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvirtual io::ZeroCopyOutputStream * OpenForInsertWithGeneratedCodeInfo(const std::string & filename, const std::string & insertion_point, const google::protobuf::GeneratedCodeInfo & info)\n```\n\n----------------------------------------\n\nTITLE: FieldMaskUtil Header Include Declaration\nDESCRIPTION: Specifies the header file inclusion for using the FieldMaskUtil functionality within the google::protobuf::util namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n#include <google/protobuf/util/field_mask_util.h>\nnamespace google::protobuf::util\n```\n\n----------------------------------------\n\nTITLE: Implementing toString Method in DslList Class for Protocol Buffers Kotlin\nDESCRIPTION: Override of the toString method in the DslList class that returns a String representation of the list. This is part of the standard object representation methods in Kotlin.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun toString(): String\n```\n\n----------------------------------------\n\nTITLE: Destructing ImportWriter in C++\nDESCRIPTION: Destructor for the ImportWriter class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n~ImportWriter()\n```\n\n----------------------------------------\n\nTITLE: Proto2 Letters and Digits Lexical Elements\nDESCRIPTION: Defines the basic character sets used in Protocol Buffers including letters, digits and various numbering systems.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\nletter = \"A\" ... \"Z\" | \"a\" ... \"z\"\ncapitalLetter =  \"A\" ... \"Z\"\ndecimalDigit = \"0\" ... \"9\"\noctalDigit   = \"0\" ... \"7\"\nhexDigit     = \"0\" ... \"9\" | \"A\" ... \"F\" | \"a\" ... \"f\"\n```\n\n----------------------------------------\n\nTITLE: Implementing FindExtensionFactory Method in Text Format Finder Class\nDESCRIPTION: Virtual method to find message factory for given extension field. Used to generalize Parser for adding extension fields to messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nvirtual MessageFactory* Finder::FindExtensionFactory(\n    const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Building File from FileDescriptorProto in Protocol Buffers (C++)\nDESCRIPTION: Converts a FileDescriptorProto to real descriptors and places them in the DescriptorPool. All dependencies of the file must already be in the pool. Returns the resulting FileDescriptor, or nullptr if there were problems.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_140\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * \n    DescriptorPool::BuildFile(\n        const FileDescriptorProto & proto)\n```\n\n----------------------------------------\n\nTITLE: FieldMask Path Validation Methods\nDESCRIPTION: Methods for validating paths and entire FieldMasks for a given type T.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static bool IsValidPath(StringPiece path);\ntemplate static bool IsValidFieldMask(const FieldMask& mask);\ntemplate static void AddPathToFieldMask(StringPiece path, FieldMask* mask);\n```\n\n----------------------------------------\n\nTITLE: Examples of Reserved Fields in Proto3\nDESCRIPTION: Shows examples of how to reserve field numbers and field names in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_25\n\nLANGUAGE: proto3\nCODE:\n```\nreserved 2, 15, 9 to 11;\nreserved \"foo\", \"bar\";\n```\n\n----------------------------------------\n\nTITLE: Restricting Option Usage with Target Types\nDESCRIPTION: Demonstrates using the 'targets' option to control which types of entities a field can be applied to when used as an option. This allows for creating shared option messages that have fields restricted to specific entity types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_60\n\nLANGUAGE: proto\nCODE:\n```\nmessage MyOptions {\n  optional string file_only_option = 1 [targets = TARGET_TYPE_FILE];\n  optional int32 message_and_enum_option = 2 [targets = TARGET_TYPE_MESSAGE,\n                                              targets = TARGET_TYPE_ENUM];\n}\n\nextend google.protobuf.FileOptions {\n  optional MyOptions file_options = 50000;\n}\n\nextend google.protobuf.MessageOptions {\n  optional MyOptions message_options = 50000;\n}\n\nextend google.protobuf.EnumOptions {\n  optional MyOptions enum_options = 50000;\n}\n\n// OK: this field is allowed on file options\noption (file_options).file_only_option = \"abc\";\n\nmessage MyMessage {\n  // OK: this field is allowed on both message and enum options\n  option (message_options).message_and_enum_option = 42;\n}\n\nenum MyEnum {\n  MY_ENUM_UNSPECIFIED = 0;\n  // Error: file_only_option cannot be set on an enum.\n  option (enum_options).file_only_option = \"xyz\";\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated HasGenerateAll Method in C++ CodeGenerator\nDESCRIPTION: The HasGenerateAll method is no longer used but kept for backward compatibility. It can be removed in a future API-breaking change.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool CodeGenerator::HasGenerateAll() const\n```\n\n----------------------------------------\n\nTITLE: Creating RepeatedField for Message Types in Ruby\nDESCRIPTION: Shows how to create and use a RepeatedField containing submessage objects. Demonstrates the three-argument constructor variant for message types, which takes the field type, message class, and initial values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: ruby\nCODE:\n```\nfirst_message = MySubMessage.new(:foo => 42)\nsecond_message = MySubMessage.new(:foo => 79)\n\nrepeated_field = Google::Protobuf::RepeatedField.new(\n    :message,\n    MySubMessage,\n    [first_message, second_message]\n)\nmessage.sub_message_repeated_field = repeated_field\n```\n\n----------------------------------------\n\nTITLE: Including TypeResolver Header in C++\nDESCRIPTION: Shows how to include the TypeResolver header file in a C++ project using Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.type_resolver.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/util/type_resolver.h>\n```\n\n----------------------------------------\n\nTITLE: ProtoDslMarker Constructor Declaration\nDESCRIPTION: Constructor definition for the ProtoDslMarker annotation class, showing it takes no parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nfun [ProtoDslMarker]()()\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Range Structure in Protocol Buffers\nDESCRIPTION: Defines a struct for representing extension ranges in Protocol Buffers. Contains members for range boundaries and extension options with corresponding type definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nstruct Descriptor::ExtensionRange {\n  typedef DescriptorProto_ExtensionRange Proto;\n  typedef ExtensionRangeOptions OptionsType;\n  int start;  // inclusive\n  int end;    // exclusive\n  const ExtensionRangeOptions* options_;\n  void CopyTo(DescriptorProto_ExtensionRange* proto) const;\n};\n```\n\n----------------------------------------\n\nTITLE: Using a Protocol Buffer Service Stub in C++\nDESCRIPTION: Example of using a protocol buffer service stub to call a remote service method 'Foo' using an RPC channel.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.service.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nMyRpcChannel channel(\"rpc:hostname:1234/myservice\");\nMyRpcController controller;\nMyServiceImpl::Stub stub(&channel);\nFooRequest request;\nFooResponse response;\n\n// ... fill in request ...\n\nstub.Foo(&controller, request, &response, NewCallback(HandleResponse));\n```\n\n----------------------------------------\n\nTITLE: Printing Protocol Buffer Message to String in C++\nDESCRIPTION: Outputs a textual representation of the given protocol buffer message directly to a string. Returns true on success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool PrintToString(const Message& message, std::string* output)\n```\n\n----------------------------------------\n\nTITLE: Trimming Unused Buffer Space in Protocol Buffers CodedOutputStream\nDESCRIPTION: Method that trims any unused space in the underlying buffer to match the number of bytes written. This is only necessary if the buffer is accessed before the stream is destroyed, as it's automatically trimmed on destruction.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_88\n\nLANGUAGE: C++\nCODE:\n```\nvoid CodedOutputStream::Trim()\n```\n\n----------------------------------------\n\nTITLE: Implementing Order Independent Repeated Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to properly structure repeated fields to avoid order dependencies between request/response and parallel arrays. Shows the evolution from a problematic implementation to a better design using unique identifiers and separate message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nmessage BatchEquationSolverResponse {\n  // Bad: Solved values are returned in the order of the equations given in\n  // the request.\n  repeated double solved_values;\n  // (Usually) Bad: Parallel array for solved_values.\n  repeated double solved_complex_values;\n}\n\n// Good: A separate message that can grow to include more fields and be\n// shared among other methods. No order dependence between request and\n// response, no order dependence between multiple repeated fields.\nmessage BatchEquationSolverResponse {\n  // Deprecated, this will continue to be populated in responses until Q2\n  // 2014, after which clients must move to using the solutions field below.\n  repeated double solved_values [deprecated = true];\n\n  // Good: Each equation in the request has a unique identifier that's\n  // included in the EquationSolution below so that the solutions can be\n  // correlated with the equations themselves. Equations are solved in\n  // parallel and as the solutions are made they are added to this array.\n  repeated EquationSolution solutions;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Protocol Buffers for Lite Runtime\nDESCRIPTION: This option generates code that implements a subset of the full protobuf runtime, suitable for resource-constrained environments.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = LITE_RUNTIME;\n```\n\n----------------------------------------\n\nTITLE: Defining StudentId message in Protocol Buffers\nDESCRIPTION: This snippet defines a StudentId message with a single string field 'value'. It demonstrates the 1-1-1 principle by having a single top-level message in its own file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nmessage StudentId {\n  string value = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BackUp() for OstreamOutputStream in C++\nDESCRIPTION: Backs up a number of bytes, preventing the end of the last buffer returned by Next() from being written.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void BackUp(int count)\n```\n\n----------------------------------------\n\nTITLE: Inefficient Message Swap Example - C++\nDESCRIPTION: Shows an inefficient swap operation between heap and arena-allocated messages that results in unnecessary copying.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nMyFeatureMessage* message_1 =\n  google::protobuf::Arena::Create<MyFeatureMessage>(arena);\nmessage_1->mutable_nested_message()->set_feature_id(11);\n\nMyFeatureMessage* message_2 = new MyFeatureMessage;\nmessage_2->mutable_nested_message()->set_feature_id(22);\n\nmessage_1->Swap(message_2); // Inefficient swap!\n```\n\n----------------------------------------\n\nTITLE: JavaGenerator Implementation in Protocol Buffers C++\nDESCRIPTION: Defines the JavaGenerator class which implements CodeGenerator to generate Java code from Protocol Buffer definitions. This class provides the core functionality for converting .proto files into Java source code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_generator.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool Generate(const FileDescriptor * file,\n        const std::string & parameter,\n        GeneratorContext * generator_context,\n        std::string * error) const\n```\n\n----------------------------------------\n\nTITLE: Implementing toString Method in ExtensionList Class in Protocol Buffers Kotlin\nDESCRIPTION: Method declaration for the toString() function which overrides the default toString() implementation. It returns a String representation of the ExtensionList instance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/to-string.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun toString(): String\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamicMessageFactory Delegation in C++ Protocol Buffers\nDESCRIPTION: Sets whether the DynamicMessageFactory should delegate to the generated factory for descriptors from the generated pool.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.dynamic_message.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetDelegateToGeneratedFactory(bool enable)\n```\n\n----------------------------------------\n\nTITLE: Implementing hashCode method for DslList in Protocol Buffers Kotlin\nDESCRIPTION: Implementation of the hashCode method for the DslList class, which returns an integer hash code value for the list. This is essential for proper functioning in hash-based collections.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun hashCode(): Int\n```\n\n----------------------------------------\n\nTITLE: Serializing with Cached Sizes - C++\nDESCRIPTION: Serializes the message using cached sizes without recomputation. Message must not have changed since last ByteSize() call.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\nvoid MessageLite::SerializeWithCachedSizes(io::CodedOutputStream* output) const\n```\n\n----------------------------------------\n\nTITLE: Map Field Access in Protocol Buffers\nDESCRIPTION: Methods for accessing map field key and value descriptors in protocol buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor* Descriptor::map_key() const\nconst FieldDescriptor* Descriptor::map_value() const\n```\n\n----------------------------------------\n\nTITLE: Getting Field Descriptors from Path in Protocol Buffers C++\nDESCRIPTION: Retrieves field descriptors for a given path from a message descriptor. Returns false if the path is invalid.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool FieldMaskUtil::GetFieldDescriptors(\n        const Descriptor * descriptor,\n        StringPiece path,\n        std::vector< const FieldDescriptor * > * field_descriptors)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Field Types in Protocol Buffers Text Format\nDESCRIPTION: Example showing the usage of regular fields, extension fields, and Any fields in Protocol Buffers text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_15\n\nLANGUAGE: textproto\nCODE:\n```\nreg_scalar: 10\nreg_message { foo: \"bar\" }\n\n[com.foo.ext.scalar]​: 10\n[com.foo.ext.message] { foo: \"bar\" }\n\nany_value {\n  [type.googleapis.com/com.foo.any] { foo: \"bar\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Packed Option for Repeated Fields in Protocol Buffers\nDESCRIPTION: Shows how to set the packed option to false for a repeated field to use unpacked wire format for compatibility with older parsers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_30\n\nLANGUAGE: proto\nCODE:\n```\nrepeated int32 samples = 4 [packed = false];\n```\n\n----------------------------------------\n\nTITLE: Defining FullName message in Protocol Buffers\nDESCRIPTION: This snippet defines a FullName message with 'family_name' and 'given_name' fields. It follows the 1-1-1 principle by having a single top-level message in its own file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nmessage FullName {\n  string family_name = 1;\n  string given_name = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Arena Allocated Space in C++\nDESCRIPTION: Method to get the total space allocated by the Arena. This includes the sum of sizes of all underlying blocks, but the exact value may vary based on implementation details.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nuint64 SpaceAllocated() const\n```\n\n----------------------------------------\n\nTITLE: Checking Extension Presence with contains Operator in Protobuf Kotlin\nDESCRIPTION: An operator function that enables checking if a specific extension is set on a Protocol Buffer message or builder. The function returns a Boolean indicating whether the extension is present in the message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/contains.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\noperator fun <M : GeneratedMessageV3.ExtendableMessage<M>, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder<M>> MorBT.contains(extension: ExtensionLite<M, *>): Boolean\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Synonym in Protocol Buffers\nDESCRIPTION: This snippet demonstrates how to define an enum with synonymous values in Protocol Buffers. It shows an enum 'Foo' where 'BAZ' is a synonym for 'BAR'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  BAR = 0;\n  BAZ = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Unknown Fields to Output Stream in C++\nDESCRIPTION: Prints the fields in an UnknownFieldSet to the specified ZeroCopyOutputStream. Returns true on success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool PrintUnknownFields(const UnknownFieldSet& unknown_fields, io::ZeroCopyOutputStream* output)\n```\n\n----------------------------------------\n\nTITLE: UnknownField Serialization Method Signature in C++\nDESCRIPTION: Method signature for serializing length-delimited fields without tags in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid UnknownField::SerializeLengthDelimitedNoTag(\n        io::CodedOutputStream * output) const\n```\n\n----------------------------------------\n\nTITLE: Checking Optional Keyword Presence in Protocol Buffers Fields (C++)\nDESCRIPTION: Returns true if the field was syntactically written with the 'optional' keyword in the .proto file. Excludes singular proto3 fields that do not have a label.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_30\n\nLANGUAGE: cpp\nCODE:\n```\nbool FieldDescriptor::has_optional_keyword() const\n```\n\n----------------------------------------\n\nTITLE: Writing Packed UInt32 to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed uint32 values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_49\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteUInt32Packed(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Optimization Option\nDESCRIPTION: Configuration option for .proto files to optimize for LITE_RUNTIME, reducing code size by implementing only MessageLite interface rather than full Message interface.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\noption optimize_for = LITE_RUNTIME;\n```\n\n----------------------------------------\n\nTITLE: Computing Timestamp from Win32 GetSystemTimeAsFileTime() in C++\nDESCRIPTION: Creates a Protocol Buffer Timestamp from the Windows file time format. This involves converting from Windows ticks (100ns units since 1601) to Unix epoch time (seconds since 1970) with nanosecond precision.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nFILETIME ft;\nGetSystemTimeAsFileTime(&ft);\nUINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n\n// A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n// is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\nTimestamp timestamp;\ntimestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\ntimestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n```\n\n----------------------------------------\n\nTITLE: Defining Messages in Protocol Buffers\nDESCRIPTION: Specifies the syntax for message definitions in Protocol Buffers, which can contain various elements like fields, nested types, and options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_29\n\nLANGUAGE: EBNF\nCODE:\n```\nmessage = \"message\" messageName messageBody\nmessageBody = \"{\" { field | enum | message | extend | extensions | group |\noption | oneof | mapField | reserved | emptyStatement } \"}\"\n```\n\n----------------------------------------\n\nTITLE: File Path Generation Function Declaration\nDESCRIPTION: Function declaration for generating file paths for output files based on the FileDescriptor input. The path depends on the Objective-C package declared in the proto package.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstd::string objectivec::FilePath(\n        const FileDescriptor* file)\n```\n\n----------------------------------------\n\nTITLE: Generating Code from Proto Files in C++\nDESCRIPTION: The GenerateAll method of CodeGenerator generates code for all given proto files. It takes a vector of FileDescriptors, a parameter string, a GeneratorContext, and an error string pointer. Returns true if successful, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool CodeGenerator::GenerateAll(\n    const std::vector< const FileDescriptor * > & files,\n    const std::string & parameter,\n    GeneratorContext * generator_context,\n    std::string * error) const\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Generated Pool\nDESCRIPTION: Gets a non-const pointer to the generated pool. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_136\n\nLANGUAGE: C++\nCODE:\n```\nstatic DescriptorPool * DescriptorPool::internal_generated_pool()\n```\n\n----------------------------------------\n\nTITLE: Assigning Elements to RepeatedField in C++\nDESCRIPTION: Replaces the contents of the RepeatedField with elements from a range defined by iterators.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\ntemplate void Assign(Iter begin, Iter end)\n```\n\n----------------------------------------\n\nTITLE: Defining ObjectiveCType Enum for Protocol Buffers\nDESCRIPTION: Enumeration defining the supported Objective-C types for Protocol Buffer field type mapping. Includes basic numeric types, strings, and data types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nenum objectivec::ObjectiveCType {\n  OBJECTIVECTYPE_INT32,\n  OBJECTIVECTYPE_UINT32,\n  OBJECTIVECTYPE_INT64,\n  OBJECTIVECTYPE_UINT64,\n  OBJECTIVECTYPE_FLOAT,\n  OBJECTIVECTYPE_DOUBLE,\n  OBJECTIVECTYPE_BOOLEAN,\n  OBJECTIVECTYPE_STRING,\n  OBJECTIVECTYPE_DATA\n}\n```\n\n----------------------------------------\n\nTITLE: Defining size Property in DslList Class for Protocol Buffers Kotlin\nDESCRIPTION: Property declaration for the size property in the DslList class, which returns an Int representing the number of elements in the list. This is an override of the standard size property in collection interfaces.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override val size: Int\n```\n\n----------------------------------------\n\nTITLE: Using Any Fields in Protocol Buffers\nDESCRIPTION: Shows how to use the Any type from google/protobuf/any.proto in a message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/any.proto\";\n\nmessage ErrorStatus {\n  string message = 1;\n  google.protobuf.Any details = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: C++ Arena Creation Method Change\nDESCRIPTION: Deprecated Arena::CreateMessage API is being removed in favor of Arena::Create method for message creation in arenas.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// Deprecated:\nArena::CreateMessage\n\n// New usage:\nArena::Create\n```\n\n----------------------------------------\n\nTITLE: TimeUtil Class Constants Declaration\nDESCRIPTION: Defines the minimum and maximum supported values for Timestamp and Duration types in seconds\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconst int64_t kTimestampMinSeconds = -62135596800LL;\nconst int64_t kTimestampMaxSeconds = 253402300799LL;\nconst int64_t kDurationMinSeconds = -315576000000LL;\nconst int64_t kDurationMaxSeconds = 315576000000LL;\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: Shows how to define map fields in a Protocol Buffers message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nmessage MessageWithMap {\n  map<string, int32> my_map = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MethodDescriptorProto Message in Protocol Buffers\nDESCRIPTION: Describes a method of a service in Protocol Buffers. It includes the method name, input and output types, options, and streaming flags.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_9\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage MethodDescriptorProto {\n  optional string name = 1;\n\n  optional string input_type = 2;\n  optional string output_type = 3;\n\n  optional MethodOptions options = 4;\n\n  optional bool client_streaming = 5 [default = false];\n  optional bool server_streaming = 6 [default = false];\n}\n```\n\n----------------------------------------\n\nTITLE: Designing Numeric Result Types in Protocol Buffers\nDESCRIPTION: Example showing how to wrap primitive types in message definitions for better API evolution. This approach allows for type reuse across methods and easier expansion when new features are needed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage MultiplicationResponse {\n  // Bad: What if you later want to return complex numbers and have an\n  // AdditionResponse that returns the same multi-field type?\n  optional double result;\n\n\n  // Good: Other methods can share this type and it can grow as your\n  // service adds new features (units, confidence intervals, etc.).\n  optional NumericResult result;\n}\n\nmessage NumericResult {\n  optional double real_value;\n  optional double complex_value;\n  optional UnitType units;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Utilities\nDESCRIPTION: Collection of utility header files for Protocol Buffers including field comparison, JSON conversion, time utilities, and type resolution\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ngoogle/protobuf/util/field_comparator.h\ngoogle/protobuf/util/field_mask_util.h\ngoogle/protobuf/util/json_util.h\ngoogle/protobuf/util/message_differencer.h\ngoogle/protobuf/util/time_util.h\ngoogle/protobuf/util/type_resolver.h\ngoogle/protobuf/util/type_resolver_util.h\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Extension in MergedDescriptorDatabase in C++\nDESCRIPTION: Searches for a file defining an extension for a given message type and field number across all merged databases. Returns true and fills the output if found, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool FindFileContainingExtension(const std::string& containing_type, int field_number, FileDescriptorProto* output)\n```\n\n----------------------------------------\n\nTITLE: Partial Merging from CodedInputStream - C++\nDESCRIPTION: Similar to MergeFromCodedStream but succeeds even if required fields are missing in the input.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::MergePartialFromCodedStream(io::CodedInputStream* input)\n```\n\n----------------------------------------\n\nTITLE: Loading Proto Rules from Protocol Buffers Repository in Bazel\nDESCRIPTION: Example showing how to explicitly load proto rules from the Protocol Buffers project repository after Bazel 8. This modification is required before Bazel 9 releases, as automatic loading of rules will be removed. These load statements require Protobuf v29.0 or higher.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-01.md#2025-04-11_snippet_0\n\nLANGUAGE: bazel\nCODE:\n```\nload(\"@protobuf//bazel:proto_library.bzl\", \"proto_library\")\n\nload(\"@protobuf//bazel:cc_proto_library.bzl\", \"cc_proto_library\")\nload(\"@protobuf//bazel:java_proto_library.bzl\", \"java_proto_library\")\nload(\"@protobuf//bazel:java_lite_proto_library.bzl\", \"java_lite_proto_library\")\nload(\"@protobuf//bazel:py_proto_library.bzl\", \"py_proto_library\")\n```\n\n----------------------------------------\n\nTITLE: Enum Helper Method in Generated Go Code\nDESCRIPTION: Example of the Enum() helper method generated for enum types, which initializes freshly allocated memory with a given value and returns the corresponding pointer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nfunc (Genre) Enum() *Genre\n```\n\n----------------------------------------\n\nTITLE: Defining Field Options in Protocol Buffers (Proto)\nDESCRIPTION: Example of defining field options in a .proto file. This shows a string field with a custom ctype option set to CORD.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_46\n\nLANGUAGE: proto\nCODE:\n```\noptional string text = 1 [ctype=CORD];\n```\n\n----------------------------------------\n\nTITLE: Setting Current Buffer Position in Protocol Buffers\nDESCRIPTION: Method that sets the current position in the output buffer. This allows direct manipulation of the write position.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_93\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetCur(uint8 * ptr)\n```\n\n----------------------------------------\n\nTITLE: Ruby Generator Class Declaration in C++\nDESCRIPTION: Declaration of the Generator class that implements the CodeGenerator interface for Ruby. This class handles generation of Ruby protocol buffer classes from .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass Generator: public CodeGenerator\n```\n\n----------------------------------------\n\nTITLE: Finding All Extensions for a Message in DescriptorPool (C++)\nDESCRIPTION: Finds all extensions of the given extendee and adds them to the provided output vector. Returns all extensions for the specified message descriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_118\n\nLANGUAGE: C++\nCODE:\n```\nvoid FindAllExtensions(const Descriptor * extendee, std::vector< const FieldDescriptor * > * out) const\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Fields in Protocol Buffers\nDESCRIPTION: Specifies the syntax for reserved field declarations in Protocol Buffers, which prevent reuse of specific field numbers or names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_25\n\nLANGUAGE: EBNF\nCODE:\n```\nreserved = \"reserved\" ( ranges | reservedIdent ) \";\"\nfieldNames = fieldName { \",\" fieldName }\n```\n\n----------------------------------------\n\nTITLE: Clearing SourceLocationTable in C++\nDESCRIPTION: Method to clear all entries from the SourceLocationTable, removing all stored location information.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.parser.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid Clear()\n```\n\n----------------------------------------\n\nTITLE: Generated C++ Code for Fields with Reserved Keywords\nDESCRIPTION: Example of the C++ code generated for fields that use reserved keywords, showing how they are modified to be valid C++ identifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n  void clear_false_() ;\n  const std::string& false_() const;\n  void set_false_(Arg_&& arg, Args_... args);\n  std::string* mutable_false_();\n  PROTOBUF_NODISCARD std::string* release_false_();\n  void set_allocated_false_(std::string* ptr);\n\n  void clear_myfalse() ;\n  const std::string& myfalse() const;\n  void set_myfalse(Arg_&& arg, Args_... args);\n  std::string* mutable_myfalse();\n  PROTOBUF_NODISCARD std::string* release_myfalse();\n  void set_allocated_myfalse(std::string* ptr);\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Source Location Structure\nDESCRIPTION: Defines the SourceLocation struct that contains information about the location of protocol buffer definitions in source files, including line numbers, columns and comments.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct SourceLocation {\n  int start_line;\n  int end_line;\n  int start_column;\n  int end_column;\n  std::string leading_comments;\n  std::string trailing_comments;\n  std::vector<std::string> leading_detached_comments;\n};\n```\n\n----------------------------------------\n\nTITLE: Constructor and Destructor for SourceLocationTable in C++\nDESCRIPTION: Defines the constructor and destructor for the SourceLocationTable class, which is used to manage source locations for Protocol Buffer descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.parser.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nSourceLocationTable()\n```\n\nLANGUAGE: C++\nCODE:\n```\n~SourceLocationTable()\n```\n\n----------------------------------------\n\nTITLE: Constructor for OnlyForUseByGeneratedProtoCode Annotation\nDESCRIPTION: The constructor definition for the OnlyForUseByGeneratedProtoCode annotation class. This annotation does not take any parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: Kotlin\nCODE:\n```\nfun [OnlyForUseByGeneratedProtoCode]()()\n```\n\n----------------------------------------\n\nTITLE: Creating Messages on Arena - C++\nDESCRIPTION: Demonstrates how to create Protocol Buffer messages using arena allocation. Creates two MyFeatureMessage instances on a new arena, with one containing a nested message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nArena* arena = new google::protobuf::Arena();\nMyFeatureMessage* arena_message_1 =\n  google::protobuf::Arena::Create<MyFeatureMessage>(arena);\narena_message_1->mutable_nested_message()->set_feature_id(11);\n\nMyFeatureMessage* arena_message_2 =\n  google::protobuf::Arena::Create<MyFeatureMessage>(arena);\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Generated Pool in Protocol Buffers (C++)\nDESCRIPTION: Internal method that returns a non-const pointer to the generated pool. Only called at static-initialization time, so thread safety is not a concern.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_148\n\nLANGUAGE: C++\nCODE:\n```\nstatic DescriptorPool * DescriptorPool::internal_generated_pool()\n```\n\n----------------------------------------\n\nTITLE: Duration/Nanoseconds Conversion in C++\nDESCRIPTION: Converts between Duration and nanosecond integer representation. Input must be within valid Duration range.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nstatic Duration TimeUtil::NanosecondsToDuration(int64_t nanos)\nstatic int64_t TimeUtil::DurationToNanoseconds(const Duration & duration)\n```\n\n----------------------------------------\n\nTITLE: Identifier Separation Rules in Protocol Buffer Text Format\nDESCRIPTION: Examples showing proper separation between numeric values and identifiers in the protocol buffer text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_2\n\nLANGUAGE: textproto\nCODE:\n```\nfoo: 10 bar: 20           # Valid: whitespace separates '10' and 'bar'\nfoo: 10,bar: 20           # Valid: ',' separates '10' and 'bar'\nfoo: 10[com.foo.ext]: 20  # Valid: '10' is followed immediately by '[', which is\n                          # not an identifier.\nfoo: 10bar: 20            # Invalid: no space between '10' and identifier 'bar'.\n```\n\n----------------------------------------\n\nTITLE: Getting Message Type Count in FileDescriptor (C++)\nDESCRIPTION: Returns the number of top-level message types defined in this file, not including nested types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_84\n\nLANGUAGE: C++\nCODE:\n```\nint FileDescriptor::message_type_count() const\n```\n\n----------------------------------------\n\nTITLE: Finding All Message Names in DescriptorDatabase (C++)\nDESCRIPTION: Method that finds all message names and appends them to the output vector. Returns true if the database supports searching all message names, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nbool DescriptorDatabase::FindAllMessageNames(\n        std::vector< std::string > * output)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Import Statement Example\nDESCRIPTION: Shows an example of a public import statement in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nimport public \"other.proto\";\n```\n\n----------------------------------------\n\nTITLE: Generated C# Structure for Timestamp Proto\nDESCRIPTION: Demonstrates the generated C# code structure for the Timestamp proto, including the use of a nested Proto namespace to avoid naming conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Google.Protobuf.WellKnownTypes\\n{\\n  namespace Proto\\n  {\\n    public static partial class Timestamp\\n    {\\n      public static FileDescriptor Descriptor { get; }\\n    }\\n  }\\n\\n  public sealed partial class Timestamp : IMessage<Timestamp>\\n  {\\n    [...]\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Values in Kotlin with Non-Nullable vs Nullable Getters\nDESCRIPTION: Comparing how non-nullable vs nullable getters would handle default values in Kotlin. Shows how the current non-nullable approach preserves default values while nullable getters would lose them.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/design-decisions/nullable-getters-setters.md#2025-04-11_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\n// With our API where getters are always non-nullable:\nmsg.child.grandchild.foo == 72\n\n// With nullable submessages the ?. operator fails to get the default value:\nmsg?.child?.grandchild?.foo == null\n\n// Or verbosely duplicating the default value at the usage site:\n(msg?.child?.grandchild?.foo ?: 72)\n```\n\n----------------------------------------\n\nTITLE: Protoc Command with File-Specific API Level\nDESCRIPTION: Command line example showing how to set API level for a specific file using the apilevelM mapping flag.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nprotoc […] --go_opt=apilevelMhello.proto=API_OPAQUE\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Level\nDESCRIPTION: Shows how to set the optimize_for option to control code generation optimization strategy.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_36\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = CODE_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Setting Integer Field Values in C++\nDESCRIPTION: Method for setting an int32 field value in a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_36\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetInt32(Message* message, const FieldDescriptor* field, int32 value) const\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Extension Example\nDESCRIPTION: Example showing how to define and use protocol buffer extensions between messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_17\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage M1 {\n  extensions 1 to max;\n}\n\nmessage M2 {\n  extend M1 {\n    optional int32 foo = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping bytes in CodedOutputStream\nDESCRIPTION: Skips a number of bytes, leaving the bytes unmodified in the underlying buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_72\n\nLANGUAGE: C++\nCODE:\n```\nbool Skip(int count)\n```\n\n----------------------------------------\n\nTITLE: Declaring Descriptor Table in Protocol Buffers\nDESCRIPTION: Declaration of the descriptor table for Protocol Buffers descriptor definitions. This table contains the serialized descriptor data for the Protocol Buffer messages defined in the descriptor.proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nconst ::protobuf::internal::DescriptorTable descriptor_table_google_2fprotobuf_2fdescriptor_2eproto\n```\n\n----------------------------------------\n\nTITLE: Getting Method Count in C++\nDESCRIPTION: Method to get the number of methods this service defines.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_70\n\nLANGUAGE: C++\nCODE:\n```\nint method_count() const\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Enum Methods in Protocol Buffers (Python)\nDESCRIPTION: Shows how to work with enum utility methods for enums declared within a message, using slightly different syntax to access the enum class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nself.assertEqual('VALUE_A', myproto_pb2.Foo.SomeEnum.Name(myproto_pb2.Foo.VALUE_A))\nself.assertEqual(5, myproto_pb2.Foo.SomeEnum.Value('VALUE_B'))\n```\n\n----------------------------------------\n\nTITLE: Overriding Default API Level on Command Line\nDESCRIPTION: Example of how to override the default API level for all files using a command-line flag when invoking the protocol buffer compiler. This is useful for quickly changing the API level without modifying .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nprotoc […] --go_opt=default_api_level=API_HYBRID\n```\n\n----------------------------------------\n\nTITLE: FileInputStream Close Method\nDESCRIPTION: Method to flush buffers and close the underlying file descriptor. Returns false if an error occurs during closing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nbool Close()\n```\n\n----------------------------------------\n\nTITLE: Trimming unused buffer space in CodedOutputStream\nDESCRIPTION: Trims any unused space in the underlying buffer so that its size matches the number of bytes written by this stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_71\n\nLANGUAGE: C++\nCODE:\n```\nvoid Trim()\n```\n\n----------------------------------------\n\nTITLE: Finding Files Containing Extensions in SimpleDescriptorDatabase\nDESCRIPTION: Method to find a file descriptor that defines an extension for a given message type and field number. The containing_type must be fully-qualified.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool SimpleDescriptorDatabase::FindFileContainingExtension(\n        const std::string & containing_type,\n        int field_number,\n        FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Nested Message Definition in Proto\nDESCRIPTION: Example of defining a nested message in a proto file. In Protocol Buffers, messages can be nested within other messages to create hierarchical structures.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage TestMessage {\n  optional int32 a = 1;\n  message NestedMessage {...}\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Go Packages on Command Line\nDESCRIPTION: Example of specifying Go import paths for multiple .proto files using command-line flags when invoking the compiler. This method is useful for build tools that manage large dependency trees.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src \\\n  --go_opt=Mprotos/buzz.proto=example.com/project/protos/fizz \\\n  --go_opt=Mprotos/bar.proto=example.com/project/protos/foo \\\n  protos/buzz.proto protos/bar.proto\n```\n\n----------------------------------------\n\nTITLE: Getting Default int32 Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_INT32. Returns 0 if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\nint32 FieldDescriptor::default_value_int32() const\n```\n\n----------------------------------------\n\nTITLE: Arena Header Include Statement\nDESCRIPTION: Include statement for using the Protocol Buffers Arena allocator.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/arena.h>\n```\n\n----------------------------------------\n\nTITLE: Using Protocol Buffer Messages in C++\nDESCRIPTION: Demonstrates creating, serializing, parsing, and accessing protocol buffer messages using both direct and reflection interfaces.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::string data;  // Will store a serialized version of the message.\n\n{\n  // Create a message and serialize it.\n  Foo foo;\n  foo.set_text(\"Hello World!\");\n  foo.add_numbers(1);\n  foo.add_numbers(5);\n  foo.add_numbers(42);\n\n  foo.SerializeToString(&data);\n}\n\n{\n  // Parse the serialized message and check that it contains the\n  // correct data.\n  Foo foo;\n  foo.ParseFromString(data);\n\n  assert(foo.text() == \"Hello World!\");\n  assert(foo.numbers_size() == 3);\n  assert(foo.numbers(0) == 1);\n  assert(foo.numbers(1) == 5);\n  assert(foo.numbers(2) == 42);\n}\n\n{\n  // Same as the last block, but do it dynamically via the Message\n  // reflection interface.\n  Message* foo = new Foo;\n  const Descriptor* descriptor = foo->GetDescriptor();\n\n  // Get the descriptors for the fields we're interested in and verify\n  // their types.\n  const FieldDescriptor* text_field = descriptor->FindFieldByName(\"text\");\n  assert(text_field != nullptr);\n  assert(text_field->type() == FieldDescriptor::TYPE_STRING);\n  assert(text_field->label() == FieldDescriptor::LABEL_OPTIONAL);\n  const FieldDescriptor* numbers_field = descriptor->\n                                         FindFieldByName(\"numbers\");\n  assert(numbers_field != nullptr);\n  assert(numbers_field->type() == FieldDescriptor::TYPE_INT32);\n  assert(numbers_field->label() == FieldDescriptor::LABEL_REPEATED);\n\n  // Parse the message.\n  foo->ParseFromString(data);\n\n  // Use the reflection interface to examine the contents.\n  const Reflection* reflection = foo->GetReflection();\n  assert(reflection->GetString(*foo, text_field) == \"Hello World!\");\n  assert(reflection->FieldSize(*foo, numbers_field) == 3);\n  assert(reflection->GetRepeatedInt32(*foo, numbers_field, 0) == 1);\n  assert(reflection->GetRepeatedInt32(*foo, numbers_field, 1) == 5);\n  assert(reflection->GetRepeatedInt32(*foo, numbers_field, 2) == 42);\n\n  delete foo;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Method by Index in C++\nDESCRIPTION: Method to get a MethodDescriptor by index, where methods are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_71\n\nLANGUAGE: C++\nCODE:\n```\nconst MethodDescriptor * method(int index) const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Option Statement Definition\nDESCRIPTION: Defines the syntax for option statements in Protocol Buffers, which can be used in proto files, messages, enums, and services.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_14\n\nLANGUAGE: ebnf\nCODE:\n```\noption = \"option\" optionName  \"=\" constant \";\"\noptionName = ( ident | bracedFullIdent ) { \".\" ( ident | bracedFullIdent ) }\nbracedFullIdent = \"(\" [\".\" ] fullIdent \")\"\n```\n\n----------------------------------------\n\nTITLE: Go Type Name for Message-Level Enum\nDESCRIPTION: Shows how the type name for an enum within a message is prefixed with the message name in the generated Go code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_16\n\nLANGUAGE: go\nCODE:\n```\ntype Venue_Kind int32\n```\n\n----------------------------------------\n\nTITLE: Declaring FileOutputStream::GetErrno Method in C++\nDESCRIPTION: This method returns the errno from an I/O error that has occurred on the file descriptor. If no error has occurred, it returns zero. Once an error occurs, the stream is broken.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nint FileOutputStream::GetErrno() const\n```\n\n----------------------------------------\n\nTITLE: Finding All File Names in DescriptorDatabase (C++)\nDESCRIPTION: Virtual method that finds all file names and appends them to the output vector. Returns true if the database supports searching all file names, false otherwise. Has a default implementation that always returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool DescriptorDatabase::FindAllFileNames(\n        std::vector< std::string > * )\n```\n\n----------------------------------------\n\nTITLE: Setting Field Encoding Format\nDESCRIPTION: Shows how to override the packed option using features for compatibility with older parsers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_38\n\nLANGUAGE: proto\nCODE:\n```\nrepeated int32 samples = 4 [features.repeated_field_encoding = EXPANDED];\n```\n\n----------------------------------------\n\nTITLE: Initializing IstreamInputStream in C++\nDESCRIPTION: Creates a stream that reads from a given C++ istream. An optional block_size parameter specifies the number of bytes to read with each Next() call.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nexplicit IstreamInputStream(std::istream* stream, int block_size = -1)\n```\n\n----------------------------------------\n\nTITLE: Example of Oneof in Proto3\nDESCRIPTION: Shows an example of how to define a oneof in a message, containing a string field and a submessage field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_21\n\nLANGUAGE: proto3\nCODE:\n```\noneof foo {\n    string name = 4;\n    SubMessage sub_message = 9;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Serialization Deterministic Mode in EpsCopyOutputStream in C++\nDESCRIPTION: Method to set whether serialization should be deterministic, ensuring consistent output across multiple serializations of the same data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_58\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetSerializationDeterministic(bool value)\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Message Type\nDESCRIPTION: Simple message type definition in Protocol Buffers showing an empty Bar message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\nmessage Bar {}\n```\n\n----------------------------------------\n\nTITLE: Declaring ServiceDescriptor Proto Typedef in C++\nDESCRIPTION: Declaration of the Proto typedef in the ServiceDescriptor class, which represents the protocol buffer representation of a service descriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_64\n\nLANGUAGE: C++\nCODE:\n```\ntypedef ServiceDescriptorProto Proto\n```\n\n----------------------------------------\n\nTITLE: Defining Message Extensions in Proto2\nDESCRIPTION: Demonstrates how to define an extension range in a protocol buffer message and add an extension field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_45\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 100 to 199;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nextend Foo {\n  optional int32 bar = 123;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Symbol in EncodedDescriptorDatabase (C++)\nDESCRIPTION: Method to find the file that declares a given fully-qualified symbol name in the EncodedDescriptorDatabase. It fills the output with the FileDescriptorProto if found and returns true, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool EncodedDescriptorDatabase::FindFileContainingSymbol(\n    const std::string & symbol_name,\n    FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Struct Literal Migration - After\nDESCRIPTION: Example of initializing a protobuf message using Builder pattern after migration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nreturn logpb.LogEntry_builder{\n    BackendServer: proto.String(host),\n}.Build()\n```\n\n----------------------------------------\n\nTITLE: Defining CppGenerator Class for Protocol Buffers in C++\nDESCRIPTION: Declares the CppGenerator class, which inherits from CodeGenerator to generate C++ code for .proto files. It includes methods for setting runtime options and generating code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.cpp_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass CppGenerator: public CodeGenerator {\npublic:\n  enum Runtime {\n    kGoogle3,\n    kOpensource,\n    kOpensourceGoogle3\n  };\n\n  CppGenerator();\n  ~CppGenerator();\n\n  void set_opensource_runtime(bool opensource);\n  void set_runtime_include_base(const std::string& base);\n\n  virtual bool Generate(const FileDescriptor* file,\n                        const std::string& parameter,\n                        GeneratorContext* generator_context,\n                        std::string* error) const;\n\n  virtual uint64_t GetSupportedFeatures() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Referencing plugin.proto File in Protocol Buffers\nDESCRIPTION: Location of the plugin.proto file containing definitions for CodeGeneratorRequest and CodeGeneratorResponse used in protoc plugins. This file defines the interface for communication between protoc and language-specific plugins.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/other.md#2025-04-11_snippet_1\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nplugin.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Field Descriptor Label Enum in Protocol Buffers\nDESCRIPTION: Declaration of the FieldDescriptorProto_Label enum that defines the possible labels (required, optional, repeated) for fields in Protocol Buffers. This enum specifies how a field should be treated.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldDescriptorProto_Label\n```\n\n----------------------------------------\n\nTITLE: Proto2 Enum Example\nDESCRIPTION: Shows an example of an enum declaration in Protocol Buffers with options and value-specific options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_30\n\nLANGUAGE: proto\nCODE:\n```\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 2 [(custom_option) = \"hello world\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Python Reflection Method Deprecation\nDESCRIPTION: Deprecated reflection.ParseMessage and reflection.MakeClass APIs are being removed in favor of message_factory.GetMessageClass().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# Deprecated:\nreflection.ParseMessage\nreflection.MakeClass\n\n# New usage:\nmessage_factory.GetMessageClass()\n```\n\n----------------------------------------\n\nTITLE: Getting Default uint64 Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_UINT64. Returns 0 if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_35\n\nLANGUAGE: cpp\nCODE:\n```\nuint64 FieldDescriptor::default_value_uint64() const\n```\n\n----------------------------------------\n\nTITLE: Resetting Arena Memory in C++\nDESCRIPTION: Frees all storage allocated by the arena after calling registered destructors and freeing owned objects. Returns the total space used by the arena. Not thread-safe.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nuint64 Arena::Reset()\n```\n\n----------------------------------------\n\nTITLE: Reading 64-bit varint in CodedInputStream in C++\nDESCRIPTION: Reads an unsigned 64-bit integer with Varint encoding from the input stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadVarint64(uint64* value)\n```\n\n----------------------------------------\n\nTITLE: Getting Extension Scope in Protocol Buffers Fields (C++)\nDESCRIPTION: For extension fields, returns the message scope in which the extension was declared, or nullptr if declared at global scope. Undefined behavior if called on non-extension fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_42\n\nLANGUAGE: cpp\nCODE:\n```\nconst Descriptor * \n    FieldDescriptor::extension_scope() const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Normal Field Examples\nDESCRIPTION: Shows examples of normal field declarations in Protocol Buffers, including optional, repeated, and field options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_18\n\nLANGUAGE: proto\nCODE:\n```\noptional foo.bar nested_message = 2;\nrepeated int32 samples = 4 [packed=true];\n```\n\n----------------------------------------\n\nTITLE: TOML Front Matter Configuration for Go Protocol Buffers Documentation\nDESCRIPTION: Defines the metadata configuration for a documentation page about Protocol Buffers in Go. Sets the page title, navigation weight, link title, description and content type using TOML format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"Go Reference\"\nweight = 600\nlinkTitle = \"Go\"\ndescription = \"Reference documentation for working with protocol buffer classes in Go\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Optimizing Protocol Buffers for Code Size\nDESCRIPTION: This option instructs the compiler to generate code that relies more on reflection, reducing code size at the cost of performance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = CODE_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Header Include\nDESCRIPTION: Header inclusion statement for using the MessageLite interface from the Protocol Buffers library.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/message_lite.h>\n```\n\n----------------------------------------\n\nTITLE: Code Migration Example - Before\nDESCRIPTION: Example of Go code using the Open Struct API style before migration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nlogEntry := &logpb.LogEntry{}\nif req.IPAddress != nil {\n    logEntry.IPAddress = redactIP(req.IPAddress)\n}\nlogEntry.BackendServer = proto.String(host)\n```\n\n----------------------------------------\n\nTITLE: Getting Repeated Field in Protocol Buffers C++\nDESCRIPTION: DEPRECATED. Use GetRepeatedFieldRef() instead. Applicable for T = Cord and all protobuf scalar types except enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_66\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nconst RepeatedField<T>& Reflection::GetRepeatedField(\n    const Message& msg,\n    const FieldDescriptor* d) const\n```\n\n----------------------------------------\n\nTITLE: Reserving Space in RepeatedField in C++\nDESCRIPTION: Reserves space to expand the field to at least the given size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reserve(int new_size)\n```\n\n----------------------------------------\n\nTITLE: Defining UninterpretedOption Message in Protocol Buffers\nDESCRIPTION: Defines a message for representing options that the parser does not recognize. It includes nested definitions for name parts and various value types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_15\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage UninterpretedOption {\n  message NamePart {\n    required string name_part = 1;\n    required bool is_extension = 2;\n  }\n  repeated NamePart name = 2;\n\n  optional string identifier_value = 3;\n  optional uint64 positive_int_value = 4;\n  optional int64 negative_int_value = 5;\n  optional double double_value = 6;\n  optional bytes string_value = 7;\n  optional string aggregate_value = 8;\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Feature Leakage in Mobile Protocol Buffers\nDESCRIPTION: Shows how sensitive feature names in protocol buffer field names can leak through mobile builds due to reflection capabilities in Android and iOS runtimes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  // This will leak existence of Google Teleport project on Android and iOS\n  optional FeatureStatus google_teleport_enabled;\n}\n```\n\n----------------------------------------\n\nTITLE: C# Field Presence Handling with Implicit Presence\nDESCRIPTION: C# example demonstrating field handling with implicit presence in Proto3, where default values are used to check and clear fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar m = GetProto();\nif (m.Foo != 0) {\n  // \"Clear\" the field:\n  m.Foo = 0;\n} else {\n  // Default value: field may not have been present.\n  m.Foo = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Package References in Protocol Buffer Messages\nDESCRIPTION: Shows how to reference message types using package specifiers within message definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_31\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  ...\n  foo.bar.Open open = 1;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FileOptions Message in Protocol Buffers\nDESCRIPTION: Specifies options for Protocol Buffer file generation. It includes various language-specific settings and code generation preferences.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_10\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage FileOptions {\n  optional string java_package = 1;\n  optional string java_outer_classname = 8;\n  optional bool java_multiple_files = 10 [default = false];\n  optional bool java_generate_equals_and_hash = 20 [deprecated=true];\n  optional bool java_string_check_utf8 = 27 [default = false];\n\n  enum OptimizeMode {\n    SPEED = 1;\n    CODE_SIZE = 2;\n    LITE_RUNTIME = 3;\n  }\n  optional OptimizeMode optimize_for = 9 [default = SPEED];\n\n  optional string go_package = 11;\n\n  optional bool cc_generic_services = 16 [default = false];\n  optional bool java_generic_services = 17 [default = false];\n  optional bool py_generic_services = 18 [default = false];\n  optional bool php_generic_services = 42 [default = false];\n\n  optional bool deprecated = 23 [default = false];\n\n  optional bool cc_enable_arenas = 31 [default = true];\n\n  optional string objc_class_prefix = 36;\n\n  optional string csharp_namespace = 37;\n\n  optional string swift_prefix = 39;\n\n  optional string php_class_prefix = 40;\n\n  optional string php_namespace = 41;\n\n  optional string php_metadata_namespace = 44;\n\n  optional string ruby_package = 45;\n\n  repeated UninterpretedOption uninterpreted_option = 999;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Int64 Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define int64 fields in both proto2 and proto3.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\n// proto2\noptional int64 bar = 1;\n\n// proto3\nint64 bar = 1;\n```\n\n----------------------------------------\n\nTITLE: Downloading Protocol Compiler Binary (Linux)\nDESCRIPTION: This snippet demonstrates how to download the latest release of the protocol compiler binary for Linux using curl. It sets a variable for the release URL and downloads the zip file for Linux x86_64 architecture.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/installation.md#2025-04-11_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nPB_REL=\"https://github.com/protocolbuffers/protobuf/releases\"\ncurl -LO $PB_REL/download/v30.2/protoc-30.2-linux-x86_64.zip\n```\n\n----------------------------------------\n\nTITLE: Serializing to String - C++\nDESCRIPTION: Serializes the message and stores it in the given string. All required fields must be set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::SerializeToString(std::string* output) const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Option Statement Example\nDESCRIPTION: Shows an example of an option statement in Protocol Buffers setting the Java package.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\noption java_package = \"com.example.foo\";\n```\n\n----------------------------------------\n\nTITLE: Handling Oneof Fields in C++\nDESCRIPTION: Demonstrates how to set and check oneof fields in C++, including potential pitfalls with memory management.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_34\n\nLANGUAGE: cpp\nCODE:\n```\nSampleMessage message;\nmessage.set_name(\"name\");\nCHECK(message.has_name());\n// Calling mutable_sub_message() will clear the name field and will set\n// sub_message to a new instance of SubMessage with none of its fields set.\nmessage.mutable_sub_message();\nCHECK(!message.has_name());\n```\n\n----------------------------------------\n\nTITLE: Getting Default double Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_DOUBLE. Returns 0.0 if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_37\n\nLANGUAGE: cpp\nCODE:\n```\ndouble FieldDescriptor::default_value_double() const\n```\n\n----------------------------------------\n\nTITLE: Creating Array on Arena Without Constructor (C++)\nDESCRIPTION: Creates an array of object type T on the arena without invoking the constructor of T. Checks at compile time that T is trivially default-constructible and trivially destructible.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static PROTOBUF_NDEBUG_INLINE T * \n    Arena::CreateArray(\n        Arena * arena,\n        size_t num_elements)\n```\n\n----------------------------------------\n\nTITLE: Writing String with Aliasing in EpsCopyOutputStream in C++\nDESCRIPTION: Method to write a potentially aliased string to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_44\n\nLANGUAGE: C++\nCODE:\n```\nuint8* WriteStringMaybeAliased(uint32 num, const std::string& s, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Getting Default bool Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_BOOL. Returns false if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_38\n\nLANGUAGE: cpp\nCODE:\n```\nbool FieldDescriptor::default_value_bool() const\n```\n\n----------------------------------------\n\nTITLE: Defining EnumDescriptorProto Message in Protocol Buffers\nDESCRIPTION: Describes an enum type in Protocol Buffers. It includes the enum name, values, options, reserved ranges, and reserved names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage EnumDescriptorProto {\n  optional string name = 1;\n\n  repeated EnumValueDescriptorProto value = 2;\n\n  optional EnumOptions options = 3;\n\n  message EnumReservedRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Inclusive.\n  }\n\n  repeated EnumReservedRange reserved_range = 4;\n\n  repeated string reserved_name = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Extensions Examples\nDESCRIPTION: Shows examples of extension range declarations in Protocol Buffers, including specific ranges and open-ended ranges.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nextensions 100 to 199;\nextensions 4, 20 to max;\n```\n\n----------------------------------------\n\nTITLE: Reparsing Message with Extensions in Dart\nDESCRIPTION: This snippet shows how to reparse a Protocol Buffers message with extensions in Dart. It demonstrates creating an ExtensionRegistry and using it to reparse a message that may contain unknown fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nFoo foo = Foo.fromBuffer(input);\nExtensionRegistry registry = ExtensionRegistry();\nregistry.add(Baz.bar);\nFoo reparsed = registry.reparseMessage(foo);\n```\n\n----------------------------------------\n\nTITLE: Setting java_outer_classname in Protocol Buffer Definition\nDESCRIPTION: Demonstrates how to set the java_outer_classname option in a .proto file. This option should be set to the .proto file name converted to TitleCase with the '.' removed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/dos-donts.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\noption java_outer_classname = \"StudentRecordRequestProto\";\n```\n\n----------------------------------------\n\nTITLE: Setting Java Package Option in Protocol Buffers\nDESCRIPTION: Demonstrates how to set the java_package option in a .proto file to specify the package for generated Java/Kotlin classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_25\n\nLANGUAGE: proto\nCODE:\n```\noption java_package = \"com.example.foo\";\n```\n\n----------------------------------------\n\nTITLE: Setting Opaque API\nDESCRIPTION: Command to switch .proto files to the Opaque API using open2opaque tool.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nopen2opaque setapi -api OPAQUE $(find . -name \"*.proto\")\n```\n\n----------------------------------------\n\nTITLE: Printing Field Value to String in C++\nDESCRIPTION: Outputs a textual representation of the value of a specific field in a message to a string. For non-repeated fields, an index of -1 must be supplied. Prints default value if the field is not set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nstatic void TextFormat::PrintFieldValueToString(\n        const Message& message,\n        const FieldDescriptor* field,\n        int index,\n        std::string* output)\n```\n\n----------------------------------------\n\nTITLE: Adding Reserved Element to RepeatedField in C++\nDESCRIPTION: Adds an already reserved element to the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddAlreadyReserved(const Element & value)\n```\n\n----------------------------------------\n\nTITLE: Serializing to Output Stream - C++\nDESCRIPTION: Serializes the message and writes it to a C++ ostream. All required fields must be set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::SerializeToOstream(std::ostream* output) const\n```\n\n----------------------------------------\n\nTITLE: Setting Java Package Option in Proto\nDESCRIPTION: Demonstrates how to set the java_package option to specify the package for generated Java/Kotlin classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_33\n\nLANGUAGE: proto\nCODE:\n```\noption java_package = \"com.example.foo\";\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Options in Java\nDESCRIPTION: Shows how to read a custom option value from a message descriptor in Java. The code retrieves the descriptor, gets its options, and then accesses the extension.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_54\n\nLANGUAGE: java\nCODE:\n```\nString value = MyProtoFile.MyMessage.getDescriptor().getOptions()\n  .getExtension(MyProtoFile.myOption);\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Range Structure in Protocol Buffers\nDESCRIPTION: Defines a struct for representing reserved field number ranges in Protocol Buffers. Contains start and end range values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nstruct Descriptor::ReservedRange {\n  int start;  // inclusive\n  int end;    // exclusive\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Markdown Front Matter for Dart API Documentation\nDESCRIPTION: This snippet defines the front matter for a Markdown file, specifying the title, external link to the Dart API documentation, link behavior, and weight for page ordering.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: \"Dart API\"\nmanualLink: \"https://pub.dartlang.org/documentation/protobuf\"\nmanualLinkTarget: \"_blank\"\nweight: 590\n---\n```\n\n----------------------------------------\n\nTITLE: Defining FieldDescriptorProto Message in Protocol Buffers\nDESCRIPTION: This snippet defines the FieldDescriptorProto message, which represents a field within a message. It includes enums for field types and labels, as well as various field attributes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_4\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage FieldDescriptorProto {\n  enum Type {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    TYPE_DOUBLE = 1;\n    TYPE_FLOAT = 2;\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    TYPE_INT64 = 3;\n    TYPE_UINT64 = 4;\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    TYPE_INT32 = 5;\n    TYPE_FIXED64 = 6;\n    TYPE_FIXED32 = 7;\n    TYPE_BOOL = 8;\n    TYPE_STRING = 9;\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    TYPE_GROUP = 10;\n    TYPE_MESSAGE = 11;  // Length-delimited aggregate.\n\n    // New in version 2.\n    TYPE_BYTES = 12;\n    TYPE_UINT32 = 13;\n    TYPE_ENUM = 14;\n    TYPE_SFIXED32 = 15;\n    TYPE_SFIXED64 = 16;\n    TYPE_SINT32 = 17;  // Uses ZigZag encoding.\n    TYPE_SINT64 = 18;  // Uses ZigZag encoding.\n  }\n\n  enum Label {\n    // 0 is reserved for errors\n    LABEL_OPTIONAL = 1;\n    LABEL_REQUIRED = 2;\n    LABEL_REPEATED = 3;\n  }\n\n  optional string name = 1;\n  optional int32 number = 3;\n  optional Label label = 4;\n\n  // If type_name is set, this need not be set.  If both this and type_name\n  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.\n  optional Type type = 5;\n\n  // For message and enum types, this is the name of the type.  If the name\n  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping\n  // rules are used to find the type (i.e. first the nested types within this\n  // message are searched, then within the parent, on up to the root\n  // namespace).\n  optional string type_name = 6;\n\n  // For extensions, this is the name of the type being extended.  It is\n  // resolved in the same manner as type_name.\n  optional string extendee = 2;\n\n  // For numeric types, contains the original text representation of the value.\n  // For booleans, \"true\" or \"false\".\n  // For strings, contains the default text contents (not escaped in any way).\n  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.\n  optional string default_value = 7;\n\n  // If set, gives the index of a oneof in the containing type's oneof_decl\n  // list.  This field is a member of that oneof.\n  optional int32 oneof_index = 9;\n\n  // JSON name of this field. The value is set by protocol compiler. If the\n  // user has set a \"json_name\" option on this field, that option's value\n  // will be used. Otherwise, it's deduced from the field's name by converting\n  // it to camelCase.\n  optional string json_name = 10;\n\n  optional FieldOptions options = 8;\n\n  // If true, this is a proto3 \"optional\". When a proto3 field is optional, it\n  // tracks presence regardless of field type.\n  //\n  // When proto3_optional is true, this field must be belong to a oneof to\n  // signal to old proto3 clients that presence is tracked for this field. This\n  // oneof is known as a \"synthetic\" oneof, and this field must be its sole\n  // member (each proto3 optional field gets its own synthetic oneof). Synthetic\n  // oneofs exist in the descriptor only, and do not generate any API. Synthetic\n  // oneofs must be ordered after all \"real\" oneofs.\n  //\n  // For message fields, proto3_optional doesn't create any semantic change,\n  // since non-repeated message fields always track presence. However it still\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Recursive Message References in Protocol Buffers\nDESCRIPTION: Shows how to create a recursive message structure in protocol buffers and how to create a message cycle in Ruby. The library will detect cycles during serialization and fail to serialize cyclic structures.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\n// foo.proto\nmessage RecursiveMessage {\n  RecursiveMessage submessage = 1;\n}\n```\n\nLANGUAGE: ruby\nCODE:\n```\n# test.rb\n\nrequire 'foo'\n\nmessage = RecursiveSubmessage.new\nmessage.submessage = message\n```\n\n----------------------------------------\n\nTITLE: Serializing to File Descriptor - C++\nDESCRIPTION: Serializes the message and writes it to the given file descriptor. All required fields must be set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::SerializeToFileDescriptor(int file_descriptor) const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Empty Statement Definition\nDESCRIPTION: Defines an empty statement in Protocol Buffers syntax, which is simply a semicolon.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_7\n\nLANGUAGE: ebnf\nCODE:\n```\nemptyStatement = \";\"\n```\n\n----------------------------------------\n\nTITLE: Arena-safe Swapping in RepeatedField in C++\nDESCRIPTION: Swaps contents between repeated fields that are guaranteed to be in the same arena or heap. Includes runtime checks to prevent cross-arena swapping.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_33\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedField::UnsafeArenaSwap(\n        RepeatedField* other)\n```\n\n----------------------------------------\n\nTITLE: Getting Enum Type in Protocol Buffers Fields (C++)\nDESCRIPTION: If field type is TYPE_ENUM, returns a descriptor for the enum. Otherwise, returns nullptr.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_44\n\nLANGUAGE: cpp\nCODE:\n```\nconst EnumDescriptor * \n    FieldDescriptor::enum_type() const\n```\n\n----------------------------------------\n\nTITLE: Creating CodeGeneratorResponse Message in Protocol Buffers C++ API\nDESCRIPTION: Defines a function to create a CodeGeneratorResponse message, possibly in an Arena-allocated memory. This is used in the Protocol Buffers compiler plugin system.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nprotobuf::compiler::CodeGeneratorResponse * Arena::CreateMaybeMessage< protobuf::compiler::CodeGeneratorResponse >(Arena * );\n```\n\n----------------------------------------\n\nTITLE: Writing Packed Enum to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed enum values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_54\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteEnumPacked(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Executing an RPC Method Call with Protocol Buffers in C++\nDESCRIPTION: Demonstrates how to use the Service class methods to execute an RPC call. It shows creating request and response messages, finding a method descriptor, and calling the method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.service.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconst MethodDescriptor* method =\n  service->GetDescriptor()->FindMethodByName(\"Foo\");\nMessage* request  = stub->GetRequestPrototype (method)->New();\nMessage* response = stub->GetResponsePrototype(method)->New();\nrequest->ParseFromString(input);\nservice->CallMethod(method, *request, response, callback);\n```\n\n----------------------------------------\n\nTITLE: Proto2 Integer Literals Definition\nDESCRIPTION: Specifies the syntax for integer literals in Protocol Buffers, supporting decimal, octal, and hexadecimal notations with optional negative signs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nintLit     = decimalLit | octalLit | hexLit\ndecimalLit = [-] ( \"1\" ... \"9\" ) { decimalDigit }\noctalLit   = [-] \"0\" { octalDigit }\nhexLit     = [-] \"0\" ( \"x\" | \"X\" ) hexDigit { hexDigit }\n```\n\n----------------------------------------\n\nTITLE: Preferred File-Level Extension Syntax\nDESCRIPTION: Demonstrates the recommended approach for defining extensions at the file level to avoid confusion with nested syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_30\n\nLANGUAGE: proto\nCODE:\n```\nimport \"media/user_content.proto\";\n\npackage puppies;\n\nmessage Photo {\n  ...\n}\n\n// This can even be in a different file.\nextend media.UserContent {\n  optional Photo puppy_photo = 127;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Size Value as Integer in Protocol Buffers\nDESCRIPTION: Reads a varint from the wire into an integer, used for reading sizes of strings, submessages, and bytes fields. Returns false if the value exceeds platform's integer representation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\nbool CodedInputStream::ReadVarintSizeAsInt(int* value)\n```\n\n----------------------------------------\n\nTITLE: Erasing Elements from RepeatedField in C++\nDESCRIPTION: Methods to erase elements from the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\niterator erase(const_iterator position)\niterator erase(const_iterator first, const_iterator last)\n```\n\n----------------------------------------\n\nTITLE: Using Setters in Go for Proto Message Construction\nDESCRIPTION: Shows an alternative approach to constructing protocol buffer messages in Go using setters instead of builders.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-faq.md#2025-04-11_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nm3 := &pb.M3{}\nm3.SetString(\"hello world\")\nm3.SetInt(42)\nm2 := &pb.M2{}\nm2.SetSubmessage(m3)\nm2.SetBytes([]byte(\"hello\"))\nm1 := &pb.M1{}\nm1.SetSubmessage(m2)\n```\n\n----------------------------------------\n\nTITLE: Defining String View Field in Proto\nDESCRIPTION: Example of defining string and bytes fields with string_view feature in protocol buffer definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/string-view.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nbytes foo = 1 [features.(pb.cpp).string_type=VIEW];\nstring foo = 1 [features.(pb.cpp).string_type=VIEW];\n```\n\n----------------------------------------\n\nTITLE: Proto3 Message Definition with Explicit Presence\nDESCRIPTION: A Proto3 message definition using explicit presence (with optional keyword) for field tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage example;\nmessage Msg {\n  optional int32 foo = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Fields in Protocol Buffers (proto2)\nDESCRIPTION: A protocol buffer extension definition that adds a new field to an existing message type using the extension mechanism available in proto2.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nextend Foo {\n  optional int32 bar = 123;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Java Outer Classname in Protocol Buffers\nDESCRIPTION: Sets the wrapper Java class name for the generated code. Without this option, the class name is derived from the .proto filename converted to camel-case.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_43\n\nLANGUAGE: proto\nCODE:\n```\noption java_outer_classname = \"Ponycopter\";\n```\n\n----------------------------------------\n\nTITLE: Implementing listIterator methods for DslList in Protocol Buffers Kotlin\nDESCRIPTION: Implementation of the listIterator methods for the DslList class, which return a ListIterator for bidirectional iteration through the list, either from the beginning or from a specified index.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun listIterator(): ListIterator<E>\nopen override fun listIterator(index: Int): ListIterator<E>\n```\n\n----------------------------------------\n\nTITLE: Migrating Legacy Extension Range in Protocol Buffers\nDESCRIPTION: This example demonstrates how to split an existing extension range into separate ranges for migrating a legacy message type to Extension Declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nmessage LegacyMessage {\n  // Legacy range that was using an unverified allocation scheme.\n  extensions 1000 to 524999999 [verification = UNVERIFIED];\n  // Current range that uses extension declarations.\n  extensions 525000000 to max  [verification = DECLARATION];\n}\n```\n\n----------------------------------------\n\nTITLE: Copying JSON Name Fields in FileDescriptor (C++)\nDESCRIPTION: Fills the json_name field of FieldDescriptorProto for all fields. Can only be called after CopyTo().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_99\n\nLANGUAGE: C++\nCODE:\n```\nvoid FileDescriptor::CopyJsonNameTo(\n        FileDescriptorProto * proto) const\n```\n\n----------------------------------------\n\nTITLE: Disabling Generic Services in Protocol Buffers\nDESCRIPTION: Demonstrates how to disable generic service code generation for C++, Java, and Python in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_29\n\nLANGUAGE: proto\nCODE:\n```\n// This file relies on plugins to generate service code.\noption cc_generic_services = false;\noption java_generic_services = false;\noption py_generic_services = false;\n```\n\n----------------------------------------\n\nTITLE: Writing String to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing a string to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_46\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteString(uint32 num, const T& s, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Accessing EnumDescriptor options in C++\nDESCRIPTION: Gets options for this enum type as specified in the .proto file. Options are defined by EnumOptions in descriptor.proto and any available extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_58\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumOptions & \n    EnumDescriptor::options() const\n```\n\n----------------------------------------\n\nTITLE: Generate output file name for C# code generation in Protocol Buffers\nDESCRIPTION: Generates the output file name for a given file descriptor. If generate_directories is true, the output file will be put under a directory corresponding to the file's namespace. The base_namespace parameter can be used to strip top-level directories.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.csharp_names.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstd::string csharp::GetOutputFile(\n        const FileDescriptor * descriptor,\n        const std::string file_extension,\n        const bool generate_directories,\n        const std::string base_namespace,\n        std::string * error)\n```\n\n----------------------------------------\n\nTITLE: Blocking Interface Method Implementation in Java\nDESCRIPTION: Example of a method signature generated for blocking interfaces, which uses synchronous semantics instead of callbacks. The method returns the response directly and throws ServiceException if there's an error.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_36\n\nLANGUAGE: java\nCODE:\n```\nabstract FooResponse bar(RpcController controller, FooRequest request)\n                         throws ServiceException;\n```\n\n----------------------------------------\n\nTITLE: Setting Default Field Value Printer in TextFormat Printer (C++)\nDESCRIPTION: Sets the default FastFieldValuePrinter that is used for all fields without a field-specific printer registered. The printer takes ownership of the provided printer object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetDefaultFieldValuePrinter(\n        const FastFieldValuePrinter * printer)\n```\n\n----------------------------------------\n\nTITLE: Accessing EnumDescriptor reserved ranges in C++\nDESCRIPTION: Gets a reserved range by index, where 0 <= index < reserved_range_count(). Ranges are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_60\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumDescriptor::ReservedRange * \n    EnumDescriptor::reserved_range(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Creating CodeGeneratorResponse_File Message in Protocol Buffers C++ API\nDESCRIPTION: Defines a function to create a CodeGeneratorResponse_File message, possibly in an Arena-allocated memory. This represents a file generated by the compiler plugin.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nprotobuf::compiler::CodeGeneratorResponse_File * Arena::CreateMaybeMessage< protobuf::compiler::CodeGeneratorResponse_File >(Arena * );\n```\n\n----------------------------------------\n\nTITLE: Checking for Errors in EpsCopyOutputStream in C++\nDESCRIPTION: Method that returns true if there was an underlying I/O error since the object was created.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_56\n\nLANGUAGE: C++\nCODE:\n```\nbool HadError() const\n```\n\n----------------------------------------\n\nTITLE: Channel Access Method for Service Stub in C++\nDESCRIPTION: Defines the method to retrieve the RpcChannel associated with a service stub, returning the channel that was provided during construction.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_51\n\nLANGUAGE: cpp\nCODE:\n```\nRpcChannel* channel()\n```\n\n----------------------------------------\n\nTITLE: Defining Options in Proto3\nDESCRIPTION: Specifies the syntax for options in Protocol Buffers, which can be used in proto files, messages, enums, and services.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_15\n\nLANGUAGE: ebnf\nCODE:\n```\noption = \"option\" optionName  \"=\" constant \";\"\noptionName = ( ident | bracedFullIdent ) { \".\" ( ident | bracedFullIdent ) }\nbracedFullIdent = \"(\" [\".\" ] fullIdent \")\"\noptionNamePart = { ident | \"(\" [\".\" ] fullIdent \")\" }\n```\n\n----------------------------------------\n\nTITLE: Legacy Ruby Code Generation with DSL\nDESCRIPTION: Previous Ruby code generation approach using DSL (Domain Specific Language) to define message structures in the generated pool.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v23.md#2025-04-11_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: protoc_explorer/main.proto\n\nrequire 'google/protobuf'\n\nGoogle::Protobuf::DescriptorPool.generated_pool.build do\n  add_file(\"test.proto\", :syntax => :proto3) do\n    add_message \"pkg.TestMessage\" do\n      proto3_optional :i32, :int32, 1\n      proto3_optional :msg, :message, 2, \"pkg.TestMessage\"\n    end\n  end\nend\n\nmodule Pkg\n  TestMessage = ::Google::Protobuf::DescriptorPool.generated_pool.lookup(\"pkg.TestMessage\").msgclass\nend\n```\n\n----------------------------------------\n\nTITLE: Writing Packed UInt64 to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed uint64 values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_52\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteUInt64Packed(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Designing Internal Pagination Token Structure in Protocol Buffers\nDESCRIPTION: Example showing different strategies for implementing internal pagination tokens that can be serialized into opaque continuation tokens for client-facing APIs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage InternalPaginationToken {\n  // Track which IDs have been seen so far. This gives perfect recall at the\n  // expense of a larger continuation token--especially as the user pages\n  // back.\n  repeated FooRef seen_ids;\n\n  // Similar to the seen_ids strategy, but puts the seen_ids in a Bloom filter\n  // to save bytes and sacrifice some precision.\n  optional bytes bloom_filter;\n\n  // A reasonable first cut and it may work for longer. Having it embedded in\n  // a continuation token lets you change it later without affecting clients.\n  optional int64 max_timestamp_ms;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Constants for Message-Level Enum\nDESCRIPTION: Shows how the constants for a message-level enum are prefixed with the enclosing message's name in the generated Go code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nconst (\n    Venue_KIND_UNSPECIFIED       Venue_Kind = 0\n    Venue_KIND_CONCERT_HALL      Venue_Kind = 1\n    Venue_KIND_STADIUM           Venue_Kind = 2\n    Venue_KIND_BAR               Venue_Kind = 3\n    Venue_KIND_OPEN_AIR_FESTIVAL Venue_Kind = 4\n)\n```\n\n----------------------------------------\n\nTITLE: MessageLite Base Class Methods - Debug String Operations\nDESCRIPTION: Methods for generating human-readable string representations of messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstd::string DebugString() const\nstd::string ShortDebugString() const\nstd::string Utf8DebugString() const\n```\n\n----------------------------------------\n\nTITLE: PHP Class Generated from Nested Enum\nDESCRIPTION: Example of how nested enums from proto files are converted to PHP classes using underscore naming convention.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: php\nCODE:\n```\nclass TestMessage_NestedEnum {...}\n```\n\n----------------------------------------\n\nTITLE: Representing Field Mask in Protocol Buffers\nDESCRIPTION: This snippet shows how a field mask is represented in Protocol Buffers, specifying paths to be included in the response.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/google.protobuf.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmask {\n  paths: \"user.display_name\"\n  paths: \"photo\"\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Repeated Field Reference in Protocol Buffers C++\nDESCRIPTION: Gets a RepeatedFieldRef object that can be used to read the underlying repeated field. The type parameter T must be set according to the field's cpp type. Requires including the \"reflection.h\" header file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_65\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nRepeatedFieldRef<T> Reflection::GetRepeatedFieldRef(\n    const Message& message,\n    const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Using Oneof Fields in Protocol Buffers (Python)\nDESCRIPTION: Demonstrates how oneof fields work in Python, showing how setting one field in the oneof automatically clears any previously set field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nmessage = Foo()\nmessage.name = \"Bender\"\nassert message.HasField(\"name\")\nmessage.serial_number = 2716057\nassert message.HasField(\"serial_number\")\nassert not message.HasField(\"name\")\n```\n\n----------------------------------------\n\nTITLE: Defining DescriptorProto Message in Protocol Buffers\nDESCRIPTION: This snippet defines the DescriptorProto message, which represents a message type in protocol buffers. It includes fields for nested types, enums, extensions, and reserved ranges.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_3\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage DescriptorProto {\n  optional string name = 1;\n\n  repeated FieldDescriptorProto field = 2;\n  repeated FieldDescriptorProto extension = 6;\n\n  repeated DescriptorProto nested_type = 3;\n  repeated EnumDescriptorProto enum_type = 4;\n\n  message ExtensionRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Exclusive.\n\n    optional ExtensionRangeOptions options = 3;\n  }\n  repeated ExtensionRange extension_range = 5;\n\n  repeated OneofDescriptorProto oneof_decl = 8;\n\n  optional MessageOptions options = 7;\n\n  // Range of reserved tag numbers. Reserved tag numbers may not be used by\n  // fields or extension ranges in the same message. Reserved ranges may\n  // not overlap.\n  message ReservedRange {\n    optional int32 start = 1;  // Inclusive.\n    optional int32 end = 2;    // Exclusive.\n  }\n  repeated ReservedRange reserved_range = 9;\n  // Reserved field names, which may not be used by fields in the same message.\n  // A given name may only be reserved once.\n  repeated string reserved_name = 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Java Class Name from ServiceDescriptor in C++\nDESCRIPTION: Function to get the fully-qualified Java class name from a ServiceDescriptor object. Requires that the descriptor parameter is not NULL.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_names.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstd::string java::ClassName(\n        const ServiceDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Replacement for Arena::GetArena in C++\nDESCRIPTION: Arena::GetArena method is being removed in v30. Instead of using this method, code should call GetArena() directly on the value object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v30.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// Old deprecated method:\nArena::GetArena\n\n// New replacement method:\nvalue->GetArena()\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Buffer in EpsCopyOutputStream in C++\nDESCRIPTION: Method for CodedOutputStream integration that sets the initial buffer for writing. This method exposes some internal functionality to match CodedOutputStream's behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_65\n\nLANGUAGE: C++\nCODE:\n```\nuint8 * EpsCopyOutputStream::SetInitialBuffer(\n        void * data,\n        int size)\n```\n\n----------------------------------------\n\nTITLE: Converting Proto2 Group to Edition 2023 with message_encoding Feature\nDESCRIPTION: This example demonstrates how proto2 groups are converted to messages in Edition 2023. The features.message_encoding feature is set to DELIMITED to preserve the group encoding behavior, while the syntax changes to use nested messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage Foo {\n  group Bar = 1 {\n    optional int32 x = 1;\n    repeated int32 y = 2;\n  }\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Foo {\n  message Bar {\n    int32 x = 1;\n    repeated int32 y = 2;\n  }\n  Bar bar = 1 [features.message_encoding = DELIMITED];\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Java Generic Services in Protocol Buffers\nDESCRIPTION: Shows how to disable generation of generic service code, which is recommended when using specific RPC systems with their own code generators or plugins.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_33\n\nLANGUAGE: proto\nCODE:\n```\noption java_generic_services = false;\n```\n\n----------------------------------------\n\nTITLE: Raw String Output to Buffer (C++)\nDESCRIPTION: Writes a string directly to the output buffer without processing newlines for indentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::PrintRaw(\n        const std::string & data)\n```\n\n----------------------------------------\n\nTITLE: Finding Field by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up a FieldDescriptor by its fully-qualified name. Returns the corresponding field descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_109\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * FindFieldByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Finding All Extension Numbers in SimpleDescriptorDatabase\nDESCRIPTION: Best-effort method to find all extension tag numbers for a given type. Returns true if search was successful, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool SimpleDescriptorDatabase::FindAllExtensionNumbers(\n        const std::string & ,\n        std::vector< int > * )\n```\n\n----------------------------------------\n\nTITLE: Enabling Aliasing in EpsCopyOutputStream in C++\nDESCRIPTION: Method to enable or disable aliasing, which allows the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying when supported.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_57\n\nLANGUAGE: C++\nCODE:\n```\nvoid EnableAliasing(bool enabled)\n```\n\n----------------------------------------\n\nTITLE: Constructor with Channel Ownership for Service Stub in C++\nDESCRIPTION: Defines an extended constructor for a service stub that accepts both an RpcChannel parameter and a channel ownership parameter to manage the channel's lifecycle.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_50\n\nLANGUAGE: cpp\nCODE:\n```\nFoo_Stub(RpcChannel* channel, ChannelOwnership ownership)\n```\n\n----------------------------------------\n\nTITLE: Generating Java Class Name from EnumDescriptor in C++\nDESCRIPTION: Function to get the fully-qualified Java class name from an EnumDescriptor object. Requires that the descriptor parameter is not NULL.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_names.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::string java::ClassName(\n        const EnumDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Example of Service Definition in Proto3\nDESCRIPTION: Shows an example of how to define a service with an RPC method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_32\n\nLANGUAGE: proto3\nCODE:\n```\nservice SearchService {\n  rpc Search (SearchRequest) returns (SearchResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Ruby encode_json Method Implementation\nDESCRIPTION: Reference to the Ruby encode_json method implementation in the Protocol Buffers codebase that will be modified to use the message's pool for encoding JSON data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-12-27.md#2025-04-11_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nencode_json\n```\n\n----------------------------------------\n\nTITLE: Writing 64-bit little-endian integer in CodedOutputStream\nDESCRIPTION: Writes a 64-bit integer in little-endian byte order to the stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_79\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteLittleEndian64(uint64 value)\n```\n\n----------------------------------------\n\nTITLE: ArenaOptions Default Constructor Declaration\nDESCRIPTION: Declaration of the default constructor for ArenaOptions struct which provides configuration options for arena allocation behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nArenaOptions()\n```\n\n----------------------------------------\n\nTITLE: Defining Container Message with Extension Range\nDESCRIPTION: Shows how to define a container message that reserves field numbers for extensions. Includes verification setting to enforce extension declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\n// file media/user_content.proto\n\npackage media;\n\n// A container message to hold stuff that a user has created.\nmessage UserContent {\n  // Set verification to `DECLARATION` to enforce extension declarations for all\n  // extensions in this range.\n  extensions 100 to 199 [verification = DECLARATION];\n}\n```\n\n----------------------------------------\n\nTITLE: Binary to JSON Stream Conversion\nDESCRIPTION: Converts Protocol Buffer binary data to JSON format using streams. Requires a TypeResolver and type URL for conversion.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nutil::Status BinaryToJsonStream(\n    TypeResolver* resolver,\n    const std::string& type_url,\n    io::ZeroCopyInputStream* binary_input,\n    io::ZeroCopyOutputStream* json_output,\n    const JsonPrintOptions& options)\n```\n\n----------------------------------------\n\nTITLE: Generated Nested Message Kotlin Code\nDESCRIPTION: The Kotlin code generated for nested message types, showing the nested object structure and factory methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nobject FooKt {\n  class Dsl { ... }\n  object BarKt {\n    class Dsl private constructor { ... }\n  }\n  inline fun bar(block: FooKt.BarKt.Dsl.() -> Unit): Foo.Bar\n}\ninline fun foo(block: FooKt.Dsl.() -> Unit): Foo\ninline fun Foo.copy(block: FooKt.Dsl.() -> Unit): Foo\ninline fun Foo.Bar.copy(block: FooKt.BarKt.Dsl.() -> Unit): Foo.Bar\n```\n\n----------------------------------------\n\nTITLE: Using Custom Options from Different Packages\nDESCRIPTION: Shows how to define a custom option in one package and use it in another. When referencing an option from another package, the package name must be prefixed to the option name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_57\n\nLANGUAGE: proto\nCODE:\n```\n// foo.proto\nimport \"google/protobuf/descriptor.proto\";\npackage foo;\nextend google.protobuf.MessageOptions {\n  optional string my_option = 51234;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\n// bar.proto\nimport \"foo.proto\";\npackage bar;\nmessage MyMessage {\n  option (foo.my_option) = \"Hello world!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Element to RepeatedField in C++\nDESCRIPTION: Appends a new uninitialized element to the repeated field and returns a pointer to it. The element is uninitialized if Element is a POD type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\nElement* RepeatedField::Add()\n```\n\n----------------------------------------\n\nTITLE: Implementing ListIterator Methods in Protocol Buffers Kotlin DslList Class\nDESCRIPTION: Documentation for two overloaded listIterator methods in the DslList class that return ListIterator objects. The first method has no parameters and returns a standard iterator, while the second accepts an index parameter to start iteration from a specific position.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/list-iterator.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun listIterator(): ListIterator<E>\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun listIterator(index: Int): ListIterator<E>\n```\n\n----------------------------------------\n\nTITLE: Well-Known Type Enumeration Definition in Protocol Buffers\nDESCRIPTION: Defines an enumeration of well-known Protocol Buffer types including wrapper types and special message types. Contains values for standard protobuf types like Any, Duration, Timestamp etc.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nenum Descriptor::WellKnownType {\n  WELLKNOWNTYPE_UNSPECIFIED,\n  WELLKNOWNTYPE_DOUBLEVALUE,\n  WELLKNOWNTYPE_FLOATVALUE,\n  WELLKNOWNTYPE_INT64VALUE,\n  WELLKNOWNTYPE_UINT64VALUE,\n  WELLKNOWNTYPE_INT32VALUE,\n  WELLKNOWNTYPE_UINT32VALUE,\n  WELLKNOWNTYPE_STRINGVALUE,\n  WELLKNOWNTYPE_BYTESVALUE,\n  WELLKNOWNTYPE_BOOLVALUE,\n  WELLKNOWNTYPE_ANY,\n  WELLKNOWNTYPE_FIELDMASK,\n  WELLKNOWNTYPE_DURATION,\n  WELLKNOWNTYPE_TIMESTAMP,\n  WELLKNOWNTYPE_VALUE,\n  WELLKNOWNTYPE_LISTVALUE,\n  WELLKNOWNTYPE_STRUCT,\n  WELLKNOWNTYPE_DO_NOT_USE__ADD_DEFAULT_INSTEAD__\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Ruby decode_json Method Implementation\nDESCRIPTION: Reference to the Ruby decode_json method implementation in the Protocol Buffers codebase that will be modified to use the message's pool for decoding JSON data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-12-27.md#2025-04-11_snippet_1\n\nLANGUAGE: Ruby\nCODE:\n```\ndecode_json\n```\n\n----------------------------------------\n\nTITLE: Writing String to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a string directly to a target array. Similar to WriteString() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_96\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteStringToArray(const std::string & str, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Generator Class Declaration in C++\nDESCRIPTION: Defines the Generator class that implements CodeGenerator for JavaScript output. The class contains methods for generating code from protocol buffer definitions and supporting features.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.js_generator.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass Generator: public CodeGenerator {\npublic:\n    Generator();\n    virtual ~Generator();\n    virtual bool Generate(const FileDescriptor* file,\n                        const std::string& parameter,\n                        GeneratorContext* generator_context,\n                        std::string* error) const;\n    virtual bool HasGenerateAll() const;\n    virtual bool GenerateAll(const std::vector<const FileDescriptor*>& files,\n                           const std::string& parameter,\n                           GeneratorContext* generator_context,\n                           std::string* error) const;\n    virtual uint64 GetSupportedFeatures() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Generating Java Class Name from Descriptor in C++\nDESCRIPTION: Function to get the fully-qualified Java class name from a Descriptor object. Requires that the descriptor parameter is not NULL.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_names.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstd::string java::ClassName(\n        const Descriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Getting Message Prototype in C++ Protocol Buffers\nDESCRIPTION: Retrieves the default (prototype) Message for a given Descriptor. This method is thread-safe and caches results.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.dynamic_message.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvirtual const Message* GetPrototype(const Descriptor* type)\n```\n\n----------------------------------------\n\nTITLE: Creating Overlaid DescriptorPool\nDESCRIPTION: Creates a DescriptorPool overlaid on top of another pool. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_127\n\nLANGUAGE: C++\nCODE:\n```\nexplicit DescriptorPool::DescriptorPool(const DescriptorPool * underlay)\n```\n\n----------------------------------------\n\nTITLE: Finding All Extension Numbers in DescriptorPoolDatabase (C++)\nDESCRIPTION: Method to find all extension numbers for a given type in the DescriptorPoolDatabase. It appends the found numbers to the output vector and returns true if successful, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool DescriptorPoolDatabase::FindAllExtensionNumbers(\n    const std::string & ,\n    std::vector< int > * )\n```\n\n----------------------------------------\n\nTITLE: Creating a CodedOutputStream from ZeroCopyOutputStream in C++\nDESCRIPTION: Constructor that creates a CodedOutputStream instance that writes to the given ZeroCopyOutputStream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_67\n\nLANGUAGE: C++\nCODE:\n```\nexplicit CodedOutputStream(ZeroCopyOutputStream* stream)\n```\n\n----------------------------------------\n\nTITLE: Calculating 32-bit Varint Size in Protocol Buffers\nDESCRIPTION: Static method that returns the number of bytes needed to encode a 32-bit unsigned integer as a variable-length encoded value (varint).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_105\n\nLANGUAGE: C++\nCODE:\n```\nstatic size_t VarintSize32(uint32 value)\n```\n\n----------------------------------------\n\nTITLE: Defining Floating-point Literals in Proto3\nDESCRIPTION: Specifies the syntax for floating-point literals in Protocol Buffers, including decimal notation, scientific notation, and special values like 'inf' and 'nan'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_4\n\nLANGUAGE: ebnf\nCODE:\n```\nfloatLit = [-] ( decimals \".\" [ decimals ] [ exponent ] | decimals exponent | \".\"decimals [ exponent ] ) | \"inf\" | \"nan\"\ndecimals  = [-] decimalDigit { decimalDigit }\nexponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum-based Field Redaction in Protocol Buffers\nDESCRIPTION: Shows how to use enum-based field annotations to mark fields for redaction by extending FieldOptions and applying content type annotations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-12-04.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\npackage my.package;\n\nextend proto2.FieldOptions {\n  # The existing field annotation\n  optional ContentType content_type = 1234567;\n};\n\nenum ContentType {\n  PUBLIC = 0;\n  SECRET = 1 [debug_redact = true];\n};\n\nmessage Foo {\n  # will not be redacted\n  optional string public_info = 1 [\n    (my.package.content_type) = PUBLIC\n  ];\n  # will be redacted\n  optional string secret = 1 [\n    (my.package.content_type) = SECRET\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Writing 32-bit Little-Endian Value to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a 32-bit integer in little-endian format directly to a target array. Similar to WriteLittleEndian32() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_98\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteLittleEndian32ToArray(uint32 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Reading Little-Endian 32-bit Integer from Array\nDESCRIPTION: Static method to read a 32-bit little-endian integer from an external buffer. Caller must ensure sufficient buffer space.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nstatic const uint8* CodedInputStream::ReadLittleEndian32FromArray(const uint8* buffer, uint32* value)\n```\n\n----------------------------------------\n\nTITLE: Legacy to Modern Extension Range Migration\nDESCRIPTION: Shows how to migrate a legacy message type to use extension declarations by splitting the extension range.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\nmessage LegacyMessage {\n  // Legacy range that was using an unverified allocation scheme.\n  extensions 1000 to 524999999 [verification = UNVERIFIED];\n  // Current range that uses extension declarations.\n  extensions 525000000 to max  [verification = DECLARATION];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RepeatedField Access Methods in C++\nDESCRIPTION: Defines methods for accessing and modifying elements in the RepeatedField, including size checks, element retrieval, and element modification.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nbool empty() const;\nint size() const;\nconst Element & Get(int index) const;\nElement * Mutable(int index);\nconst Element & operator[](int index) const;\nElement & operator[](int index);\nconst Element & at(int index) const;\nElement & at(int index);\nvoid Set(int index, const Element & value);\n```\n\n----------------------------------------\n\nTITLE: Initializing EpsCopyOutputStream for Array Serialization in C++\nDESCRIPTION: Constructor specifically for array serialization, taking a data buffer, size, and deterministic flag.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_38\n\nLANGUAGE: C++\nCODE:\n```\nEpsCopyOutputStream(void* data, int size, bool deterministic)\n```\n\n----------------------------------------\n\nTITLE: Accessing Weak Dependencies in FileDescriptor (C++)\nDESCRIPTION: Gets a weak imported file by index, where the index must be between 0 and weak_dependency_count(). Files are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_83\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * \n    FileDescriptor::weak_dependency(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Finding Enum Value by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up an EnumValueDescriptor by its fully-qualified name. Returns the corresponding enum value descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_113\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor * FindEnumValueByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Example of Enum Definition in Proto3\nDESCRIPTION: Shows an example of how to define an enum with options and enum values, including a custom option on an enum value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_27\n\nLANGUAGE: proto3\nCODE:\n```\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 2 [(custom_option) = \"hello world\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Java Package in Protocol Buffers\nDESCRIPTION: This option specifies the Java package for the generated classes, overriding the default package derived from the proto package declaration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\noption java_package = \"com.example.foo.bar\";\n```\n\n----------------------------------------\n\nTITLE: JavaNanoGenerator Class Definition and Implementation\nDESCRIPTION: Defines the JavaNanoGenerator class that implements the CodeGenerator interface to generate Java nano code for protocol buffers. Includes constructor, destructor and Generate method for converting .proto files to Java code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.javanano_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass JavaNanoGenerator: public CodeGenerator {\npublic:\n    JavaNanoGenerator();\n    ~JavaNanoGenerator();\n    \n    virtual bool Generate(\n        const FileDescriptor* file,\n        const string& parameter,\n        GeneratorContext* generator_context,\n        string* error) const;\n};\n```\n\n----------------------------------------\n\nTITLE: Bazel Flag to Allow MSVC Compilation with Protocol Buffers\nDESCRIPTION: A Bazel define flag that can be used to opt-out of the poisoning of MSVC with Bazel combination in Protocol Buffers v30+. This allows continued use of this combination before the complete removal of support in v34.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2025-01-23.md#2025-04-11_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--define=protobuf_allow_msvc=true\n```\n\n----------------------------------------\n\nTITLE: Writing 64-bit Little-Endian Value to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a 64-bit integer in little-endian format directly to a target array. Similar to WriteLittleEndian64() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_99\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteLittleEndian64ToArray(uint64 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Finding File by Name in DescriptorPoolDatabase (C++)\nDESCRIPTION: Method to find a file by its name in the DescriptorPoolDatabase. It fills the output with the FileDescriptorProto if found and returns true, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool DescriptorPoolDatabase::FindFileByName(\n    const std::string & filename,\n    FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Declaring FileOutputStream Constructor in C++\nDESCRIPTION: This constructor creates a FileOutputStream that writes to the given Unix file descriptor. An optional block_size parameter can be specified to set the size of buffers returned by Next().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nexplicit FileOutputStream::FileOutputStream(int file_descriptor, int block_size = -1)\n```\n\n----------------------------------------\n\nTITLE: Adding File to ImportWriter in C++\nDESCRIPTION: Adds a file to the ImportWriter. Takes a FileDescriptor pointer and a header extension string as parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddFile(const FileDescriptor* file, const std::string& header_extension)\n```\n\n----------------------------------------\n\nTITLE: Defining Message with Extension Range in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a message with an extension range in Protocol Buffers (proto2). It defines a 'Foo' message with an extension range and an extension field 'bar'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 100 to 199;\n}\n\nextend Foo {\n  optional int32 bar = 101;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Generated File to Pool\nDESCRIPTION: Called by generated classes at initialization time to add their descriptors to the generated pool. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_135\n\nLANGUAGE: C++\nCODE:\n```\nstatic void DescriptorPool::InternalAddGeneratedFile(const void * encoded_file_descriptor, int size)\n```\n\n----------------------------------------\n\nTITLE: Including Dynamic Message Header in C++ Protocol Buffers\nDESCRIPTION: Includes the header file for dynamic message implementation in Protocol Buffers C++ library.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.dynamic_message.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/dynamic_message.h>\n```\n\n----------------------------------------\n\nTITLE: Getting direct buffer pointer in CodedOutputStream\nDESCRIPTION: Sets *data to point directly at the unwritten part of the CodedOutputStream's underlying buffer, and *size to the size of that buffer, without advancing the stream's position.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_73\n\nLANGUAGE: C++\nCODE:\n```\nbool GetDirectBufferPointer(void** data, int* size)\n```\n\n----------------------------------------\n\nTITLE: Reading Varint32 Value in Protocol Buffers\nDESCRIPTION: Method to read an unsigned 32-bit integer using Varint encoding. This is a more efficient way to read 32-bit values compared to reading 64-bit ones and casting.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nbool CodedInputStream::ReadVarint32(uint32* value)\n```\n\n----------------------------------------\n\nTITLE: Importing Definitions from Other Proto Files\nDESCRIPTION: Shows how to import definitions from other proto files. This allows reuse of message types and other definitions across multiple proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nimport \"myproject/other_protos.proto\";\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffers Forum Page Metadata in YAML\nDESCRIPTION: YAML front matter that configures a Protocol Buffers forum page. It sets the page title as 'Forum', links to the Protocol Buffers Google Group, opens the link in a new tab, and assigns a navigation weight of 1040.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/forum-link.md#2025-04-11_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: \"Forum\"\nmanualLink: \"https://groups.google.com/g/protobuf\"\nmanualLinkTarget: \"_blank\"\nweight: 1040\n---\n```\n\n----------------------------------------\n\nTITLE: Setting Deterministic Serialization in CodedOutputStream in C++\nDESCRIPTION: Controls whether the serializer should use deterministic serialization. When enabled for protocol buffers, binary equal messages will be serialized to the same bytes, ensuring consistency across repeated serializations and different processes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_114\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CodedOutputStream::SetSerializationDeterministic(\n        bool value)\n```\n\n----------------------------------------\n\nTITLE: Markdown Formatting Configuration\nDESCRIPTION: HTML comment to disable global markdown formatting for the documentation page.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/api-docs-link.md#2025-04-11_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!-- mdformat global-off -->\n```\n\n----------------------------------------\n\nTITLE: Converting Proto2 Message to Edition 2023 with json_format Feature\nDESCRIPTION: This example shows how proto2's JSON format behavior is preserved in Edition 2023 by setting the features.json_format feature to LEGACY_BEST_EFFORT. This allows potentially ambiguous JSON mappings that were permitted in proto2.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage Foo {\n  // Warning only\n  string bar = 1;\n  string bar_ = 2;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\noption features.json_format = LEGACY_BEST_EFFORT;\n\nmessage Foo {\n  string bar = 1;\n  string bar_ = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting direct buffer for N bytes and advancing in CodedOutputStream\nDESCRIPTION: If there are at least 'size' bytes available in the current buffer, returns a pointer directly into the buffer and advances over these bytes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_74\n\nLANGUAGE: C++\nCODE:\n```\nuint8* GetDirectBufferForNBytesAndAdvance(int size)\n```\n\n----------------------------------------\n\nTITLE: Trimming EpsCopyOutputStream in C++\nDESCRIPTION: Method to flush written data into the underlying ZeroCopyOutputStream and trim the stream to the specified location.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_40\n\nLANGUAGE: C++\nCODE:\n```\nuint8* Trim(uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Finding Source Locations in SourceLocationTable in C++\nDESCRIPTION: Methods to find the precise location of errors or imports in Protocol Buffer descriptors. Find locates errors and returns line and column numbers, while FindImport performs the same function for import statements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.parser.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nbool Find(const Message* descriptor, DescriptorPool::ErrorCollector::ErrorLocation location, int* line, int* column) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool FindImport(const Message* descriptor, const std::string& name, int* line, int* column) const\n```\n\n----------------------------------------\n\nTITLE: Updating Protobuf Module\nDESCRIPTION: Command to update the Protocol Buffers module in go.mod to the latest version.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngo get google.golang.org/protobuf@latest\n```\n\n----------------------------------------\n\nTITLE: Finding FileDescriptor by Name in DescriptorPool\nDESCRIPTION: Finds a FileDescriptor in the pool by file name. Returns nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_121\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * DescriptorPool::FindFileByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Using Groups in Protocol Buffers (Python)\nDESCRIPTION: Example showing two equivalent message definitions - one using groups (deprecated) and one using nested message types. Groups combine a nested message type and field into a single declaration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n// Version 1: Using groups\nmessage SearchResponse {\n  repeated group SearchResult = 1 {\n    optional string url = 1;\n  }\n}\n// Version 2: Not using groups\nmessage SearchResponse {\n  message SearchResult {\n    optional string url = 1;\n  }\n  repeated SearchResult searchresult = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring MapPair Alias Template in C++ Protocol Buffers\nDESCRIPTION: Definition of the MapPair alias template, which is used as the value_type for the Map class. It's an alias to std::pair.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.map.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename Key, typename T>\nusing MapPair = std::pair<Key, T>;\n```\n\n----------------------------------------\n\nTITLE: FileInputStream Constructor Implementation\nDESCRIPTION: Creates a FileInputStream that reads from a Unix file descriptor with optional block size specification. Used for zero-copy streaming from files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nexplicit FileInputStream(int file_descriptor, int block_size = -1)\n```\n\n----------------------------------------\n\nTITLE: File Class Name Generation Function Declaration\nDESCRIPTION: Function declaration for generating the root class name for a given proto file. This generates an internal helper class name not meant for external use.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstd::string objectivec::FileClassName(\n        const FileDescriptor* file)\n```\n\n----------------------------------------\n\nTITLE: TimeUtil Timestamp Conversion Methods\nDESCRIPTION: Methods for converting between Timestamp and string formats, including RFC 3339 date strings\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::string ToString(const Timestamp& timestamp);\nstatic bool FromString(const std::string& value, Timestamp* timestamp);\n```\n\n----------------------------------------\n\nTITLE: Reading raw bytes in CodedInputStream in C++\nDESCRIPTION: Reads raw bytes from the input stream, copying them into the given buffer. Returns a boolean indicating success.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadRaw(void* buffer, int size)\n```\n\n----------------------------------------\n\nTITLE: Adding and Returning Pointer in RepeatedField in C++\nDESCRIPTION: Appends a new element and returns a pointer to it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nElement * AddAlreadyReserved()\n```\n\n----------------------------------------\n\nTITLE: Writing raw bytes in CodedOutputStream\nDESCRIPTION: Writes raw bytes to the stream, copying them from the given buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_75\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteRaw(const void* buffer, int size)\n```\n\n----------------------------------------\n\nTITLE: Checking Serialization Determinism in Protocol Buffers\nDESCRIPTION: Method that returns whether the user wants deterministic serialization, which ensures the same binary output for equivalent messages across different runs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_90\n\nLANGUAGE: C++\nCODE:\n```\nIsSerializationDeterministic() const\n```\n\n----------------------------------------\n\nTITLE: Defining ExtensionList Properties in Kotlin\nDESCRIPTION: Defines two properties for the ExtensionList class: 'extension' of type ExtensionLite<M, List<E>> and 'size' of type Int. The 'extension' property is a val, while 'size' is an open override val.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nval extension: ExtensionLite<M, List<E>>\nopen override val size: Int\n```\n\n----------------------------------------\n\nTITLE: Deeply Nested Message Types in Protocol Buffers\nDESCRIPTION: Shows how to nest message types at multiple levels, demonstrating that nested types with the same name are independent if defined in different parent messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\nmessage Outer {       // Level 0\n  message MiddleAA {  // Level 1\n    message Inner {   // Level 2\n      int64 ival = 1;\n      bool  booly = 2;\n    }\n  }\n  message MiddleBB {  // Level 1\n    message Inner {   // Level 2\n      int32 ival = 1;\n      bool  booly = 2;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer from String in C++\nDESCRIPTION: Methods for parsing a protocol buffer contained in a string, with options for handling missing required fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool ParseFromString(ConstStringParam data)\n```\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool ParsePartialFromString(ConstStringParam data)\n```\n\n----------------------------------------\n\nTITLE: Merging RepeatedField in C++\nDESCRIPTION: Merges elements from another RepeatedField into this one.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid MergeFrom(const RepeatedField & other)\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Example of defining oneof fields in protocol buffer message format, showing how to create a union of different field types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nmessage Profile {\n  oneof avatar {\n    string image_url = 1;\n    bytes image_data = 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Bytes to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing bytes to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_47\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteBytes(uint32 num, const T& s, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Getting Cached Size - C++\nDESCRIPTION: Virtual method that returns the result of the last ByteSize() call, used for optimization in serialization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nvirtual int MessageLite::GetCachedSize() const = 0\n```\n\n----------------------------------------\n\nTITLE: Reverse Iterating RepeatedField in C++\nDESCRIPTION: Methods for obtaining reverse iterators to traverse the RepeatedField backwards.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nreverse_iterator rbegin()\nconst_reverse_iterator rbegin() const\nreverse_iterator rend()\nconst_reverse_iterator rend() const\n```\n\n----------------------------------------\n\nTITLE: Grouping Related Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to organize related fields by grouping them into a separate message type to improve cohesion and reusability. The example shows refactoring price and currency fields into a dedicated CurrencyAmount message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  // Bad: The price and currency of this Foo.\n  optional int price;\n  optional CurrencyType currency;\n\n  // Better: Encapsulates the price and currency of this Foo.\n  optional CurrencyAmount price;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Compiler Command Line Usage\nDESCRIPTION: Examples of different ways to invoke the protocol compiler with command-line options, including output directory specification and proto path options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nprotoc --cpp_out=outdir --foo_out=outdir --proto_path=src src/foo.proto\n```\n\n----------------------------------------\n\nTITLE: Demonstrating View/Mut Proxy Types in Rust Protobuf\nDESCRIPTION: This code snippet illustrates the concept of View/Mut proxy types used in Rust Protobuf. It shows how SomeMsg, SomeMsgView, and SomeMsgMut are structured and their relationships to the underlying C++ implementation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-design-decisions.md#2025-04-11_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct SomeMsg(Box<cpp::SomeMsg>);\nstruct SomeMsgView<'a>(&'a cpp::SomeMsg);\nstruct SomeMsgMut<'a>(&'a mut cpp::SomeMsg);\n```\n\n----------------------------------------\n\nTITLE: ErrorCollector::AddError Method Signature in C++\nDESCRIPTION: Virtual method for reporting errors in a FileDescriptorProto. Used when a problem should interrupt the building of the FileDescriptorProto.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_151\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void ErrorCollector::AddError(\n        const std::string & filename,\n        const std::string & element_name,\n        const Message * descriptor,\n        ErrorLocation location,\n        const std::string & message)  = 0\n```\n\n----------------------------------------\n\nTITLE: Declaring ObjectiveCGenerator Class in C++\nDESCRIPTION: Declares the ObjectiveCGenerator class which inherits from CodeGenerator. This class is responsible for generating Objective-C code from Protocol Buffer definitions. It includes constructors, destructor, and methods for code generation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass ObjectiveCGenerator: public CodeGenerator {\npublic:\n  ObjectiveCGenerator();\n  ~ObjectiveCGenerator();\n  ObjectiveCGenerator(const ObjectiveCGenerator &);\n  ObjectiveCGenerator& operator=(const ObjectiveCGenerator &);\n\n  virtual bool HasGenerateAll() const;\n  virtual bool Generate(const FileDescriptor* file,\n                       const std::string& parameter,\n                       GeneratorContext* generator_context,\n                       std::string* error) const;\n  virtual bool GenerateAll(const std::vector<const FileDescriptor*>& files,\n                           const std::string& parameter,\n                           GeneratorContext* generator_context,\n                           std::string* error) const;\n  virtual uint64_t GetSupportedFeatures() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Getting Source Location in FileDescriptor (C++)\nDESCRIPTION: Updates out_location to the source location of the declaration denoted by path. Returns false if location information is not available. The path follows the encoding described in SourceCodeInfo.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_101\n\nLANGUAGE: C++\nCODE:\n```\nbool FileDescriptor::GetSourceLocation(\n        const std::vector< int > & path,\n        SourceLocation * out_location) const\n```\n\n----------------------------------------\n\nTITLE: Checking for end of input in CodedInputStream in C++\nDESCRIPTION: Checks if the input stream has reached its end. Usually returns true if no more bytes can be read.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nbool ExpectAtEnd()\n```\n\n----------------------------------------\n\nTITLE: Adding Pre-reserved Element in C++\nDESCRIPTION: Appends a new uninitialized element when capacity is already available. Should only be called if Capacity() > Size().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\nElement* RepeatedField::AddAlreadyReserved()\n```\n\n----------------------------------------\n\nTITLE: Writing String with Size to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a string's varint-encoded size followed by the string content directly to a target array.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_97\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteStringWithSizeToArray(const std::string & str, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Checking for I/O errors in CodedOutputStream\nDESCRIPTION: Returns true if there was an underlying I/O error since the CodedOutputStream was created.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_70\n\nLANGUAGE: C++\nCODE:\n```\nbool HadError()\n```\n\n----------------------------------------\n\nTITLE: Alternative Extension Pattern in Protocol Buffers\nDESCRIPTION: Shows the standard (preferred) way of defining extensions at file level instead of nesting them within message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_23\n\nLANGUAGE: proto\nCODE:\n```\nimport \"media/user_content.proto\";\n\npackage puppies;\n\nmessage Photo {\n  ...\n}\n\n// This can even be in a different file.\nextend media.UserContent {\n  Photo puppy_photo = 127;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Raw Data Directly to a Target Array in CodedOutputStream in C++\nDESCRIPTION: Static method for writing raw data directly to a target array. This is not inlined to avoid code bloat since the compiler often optimizes memcpy into inline copy loops.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_115\n\nLANGUAGE: cpp\nCODE:\n```\nstatic uint8 * CodedOutputStream::WriteRawToArray(\n        const void * buffer,\n        int size,\n        uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Copying RepeatedField in C++\nDESCRIPTION: Copies elements from another RepeatedField into this one.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvoid CopyFrom(const RepeatedField & other)\n```\n\n----------------------------------------\n\nTITLE: Implementing Skip() for IstreamInputStream in C++\nDESCRIPTION: Skips a number of bytes in the stream. Returns false if end of stream is reached or an input error occurred. Advances to end of stream if EOF is encountered.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool Skip(int count)\n```\n\n----------------------------------------\n\nTITLE: Compiling Protocol Buffer Definitions\nDESCRIPTION: Shell command to compile the .proto file into Kotlin and Java source code using the protocol buffer compiler.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/kotlintutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nprotoc -I=$SRC_DIR --java_out=$DST_DIR --kotlin_out=$DST_DIR $SRC_DIR/addressbook.proto\n```\n\n----------------------------------------\n\nTITLE: Checking if File is Loaded in Protocol Buffers (C++)\nDESCRIPTION: Internal method that returns whether a FileDescriptor has been constructed for the given file. This is useful for testing lazy descriptor initialization behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_145\n\nLANGUAGE: C++\nCODE:\n```\nbool DescriptorPool::InternalIsFileLoaded(\n        ConstStringParam filename) const\n```\n\n----------------------------------------\n\nTITLE: Defining Modern Extension Range in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a modern extension range with verification set to DECLARATION, allocating 1000 small numbers for dense population.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_23\n\nLANGUAGE: proto\nCODE:\n```\nmessage ModernExtendableMessage {\n  // All extensions in this range should use extension declarations.\n  extensions 1000 to 2000 [verification = DECLARATION];\n}\n```\n\n----------------------------------------\n\nTITLE: Proto2 Reserved Field Examples\nDESCRIPTION: Shows examples of reserved field declarations in Protocol Buffers, for both field numbers and field names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_28\n\nLANGUAGE: proto\nCODE:\n```\nreserved 2, 15, 9 to 11;\nreserved \"foo\", \"bar\";\n```\n\n----------------------------------------\n\nTITLE: Protocol Compiler Path Resolution Examples\nDESCRIPTION: Examples showing how a .proto file can be specified using either physical file paths or virtual paths relative to a directory specified with --proto_path.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n1. protoc --proto_path=src src/foo.proto (physical file path)\n2. protoc --proto_path=src foo.proto (virtual path relative to src)\n```\n\n----------------------------------------\n\nTITLE: Defining TOML Frontmatter for Rust Protocol Buffer Documentation Page\nDESCRIPTION: TOML frontmatter that configures the metadata for the Rust Protocol Buffer reference documentation page. It sets the page title, weight for navigation ordering, linkable title, description, document type, and hides the table of contents.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"Rust Reference\"\nweight = 781\nlinkTitle = \"Rust\"\ndescription = \"Reference documentation for working with protocol buffer classes in Rust.\"\ntype = \"docs\"\ntoc_hide = \"true\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Generated Database\nDESCRIPTION: Gets a non-const pointer to the generated descriptor database. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_137\n\nLANGUAGE: C++\nCODE:\n```\nstatic DescriptorDatabase * DescriptorPool::internal_generated_database()\n```\n\n----------------------------------------\n\nTITLE: Defining FileDescriptorProto Message in Protocol Buffers\nDESCRIPTION: This snippet defines the FileDescriptorProto message, which represents a complete .proto file. It includes fields for file name, package, imports, and top-level definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_2\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage FileDescriptorProto {\n  optional string name = 1;     // file name, relative to root of source tree\n  optional string package = 2;  // e.g. \"foo\", \"foo.bar\", etc.\n\n  // Names of files imported by this file.\n  repeated string dependency = 3;\n  // Indexes of the public imported files in the dependency list above.\n  repeated int32 public_dependency = 10;\n  // Indexes of the weak imported files in the dependency list.\n  // For Google-internal migration only. Do not use.\n  repeated int32 weak_dependency = 11;\n\n  // All top-level definitions in this file.\n  repeated DescriptorProto message_type = 4;\n  repeated EnumDescriptorProto enum_type = 5;\n  repeated ServiceDescriptorProto service = 6;\n  repeated FieldDescriptorProto extension = 7;\n\n  optional FileOptions options = 8;\n\n  // This field contains optional information about the original source code.\n  // You may safely remove this entire field without harming runtime\n  // functionality of the descriptors -- the information is needed only by\n  // development tools.\n  optional SourceCodeInfo source_code_info = 9;\n\n  // The syntax of the proto file.\n  // The supported values are \"proto2\" and \"proto3\".\n  optional string syntax = 12;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Markdown Frontmatter for Python Protocol Buffers API Documentation\nDESCRIPTION: Markdown frontmatter that configures a documentation page for the Python Protocol Buffers API. It defines the page title, sets an external link to the full API documentation, configures the link to open in a new tab, and sets the page weight in the navigation hierarchy.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- mdformat global-off -->\n\n---\ntitle: \"Python API\"\nmanualLink: \"https://googleapis.dev/python/protobuf/latest/\"\nmanualLinkTarget: \"_blank\"\nweight: 760\n---\n```\n\n----------------------------------------\n\nTITLE: Invoking Protoc Plugin on Windows\nDESCRIPTION: This snippet shows how to invoke a protoc plugin on Windows systems, specifically including the .exe suffix when specifying the plugin binary path.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.md#2025-04-11_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nprotoc --plugin=protoc-gen-NAME=path/to/mybinary.exe --NAME_out=OUT_DIR\n```\n\n----------------------------------------\n\nTITLE: Message Parsing in C++\nDESCRIPTION: C++ code demonstrating two equivalent ways to parse concatenated protocol buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nMyMessage message;\nmessage.ParseFromString(str1 + str2);\n```\n\nLANGUAGE: cpp\nCODE:\n```\nMyMessage message, message2;\nmessage.ParseFromString(str1);\nmessage2.ParseFromString(str2);\nmessage.MergeFrom(message2);\n```\n\n----------------------------------------\n\nTITLE: Verifying last read tag in CodedInputStream in C++\nDESCRIPTION: Checks if the last call to ReadTag() or ReadTagWithCutoff() returned the given value. This is useful for verifying proto2 required fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nbool LastTagWas(uint32 expected)\n```\n\n----------------------------------------\n\nTITLE: Element Removal in RepeatedPtrField\nDESCRIPTION: Methods for removing elements from RepeatedPtrField while managing ownership. RemoveLast() removes the last element while retaining ownership.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_41\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedPtrField::RemoveLast()\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteCount() for OstreamOutputStream in C++\nDESCRIPTION: Returns the total number of bytes written since the object was created.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nvirtual int64_t ByteCount() const\n```\n\n----------------------------------------\n\nTITLE: Writing Packed SInt32 to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed sint32 values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_50\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteSInt32Packed(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Defining Map Field Wire Format in Protocol Buffers\nDESCRIPTION: Shows the equivalent wire format representation of map fields for backwards compatibility with implementations that don't support maps directly.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_29\n\nLANGUAGE: proto\nCODE:\n```\nmessage MapFieldEntry {\n  key_type key = 1;\n  value_type value = 2;\n}\n\nrepeated MapFieldEntry map_field = N;\n```\n\n----------------------------------------\n\nTITLE: Printing Unknown Fields to Output Stream in C++\nDESCRIPTION: Prints the fields in an UnknownFieldSet to the specified output stream. Fields are printed by tag number only. Returns false if printing fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool TextFormat::PrintUnknownFields(\n        const UnknownFieldSet& unknown_fields,\n        io::ZeroCopyOutputStream* output)\n```\n\n----------------------------------------\n\nTITLE: Getting Capacity of RepeatedField in C++\nDESCRIPTION: Returns the current capacity of the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nint Capacity() const\n```\n\n----------------------------------------\n\nTITLE: Converting Standard Map to Protocol Buffer Map\nDESCRIPTION: Example showing how to construct a google::protobuf::Map from a standard C++ map using iterators.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_34\n\nLANGUAGE: cpp\nCODE:\n```\ngoogle::protobuf::Map<int32, int32> weight(standard_map.begin(), standard_map.end());\n```\n\n----------------------------------------\n\nTITLE: Example of Option in Proto3\nDESCRIPTION: Shows an example of how to specify an option in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_16\n\nLANGUAGE: proto3\nCODE:\n```\noption java_package = \"com.example.foo\";\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Backward Compatibility in Protobuf Editions\nDESCRIPTION: This snippet shows how Protobuf Editions maintain backward compatibility with proto2 and proto3. It demonstrates importing a proto2 definition into an editions-based file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/overview.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\n// file myproject/foo.proto\nsyntax = \"proto2\";\n\nenum Employment {\n  EMPLOYMENT_UNSPECIFIED = 0;\n  EMPLOYMENT_FULLTIME = 1;\n  EMPLOYMENT_PARTTIME = 2;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\n// file myproject/edition.proto\nedition = \"2023\";\n\nimport \"myproject/foo.proto\";\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Types in Protocol Buffer\nDESCRIPTION: Example of declaring a nested message type in a .proto file, which generates nested C++ classes and typedefs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Message Field Syntax in Protocol Buffers Text Format\nDESCRIPTION: Example showing the use of curly brackets and angle brackets for message field values in Protocol Buffers text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_18\n\nLANGUAGE: textproto\nCODE:\n```\nmessage: { foo: \"bar\" }\nmessage: < foo: \"bar\" >\n```\n\n----------------------------------------\n\nTITLE: Custom Enum Value Options\nDESCRIPTION: Example of defining and using custom options for enum values using extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_40\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.EnumValueOptions {\n  string string_name = 123456789;\n}\n\nenum Data {\n  DATA_UNSPECIFIED = 0;\n  DATA_SEARCH = 1 [deprecated = true];\n  DATA_DISPLAY = 2 [\n    (string_name) = \"display_value\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Protocol Buffer Compiler for Java\nDESCRIPTION: Shell command to run the protoc compiler with Java output option. This command specifies source directory, destination directory, and the path to the proto file to generate Java classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Generated Database in Protocol Buffers (C++)\nDESCRIPTION: Internal method that returns a non-const pointer to the generated descriptor database. Only used for testing purposes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_149\n\nLANGUAGE: C++\nCODE:\n```\nstatic DescriptorDatabase * \n    DescriptorPool::internal_generated_database()\n```\n\n----------------------------------------\n\nTITLE: Defining Field Options JavaScript Type Enum in Protocol Buffers\nDESCRIPTION: Declaration of the FieldOptions_JSType enum that specifies JavaScript type options for fields in Protocol Buffers. This controls how fields are represented in generated JavaScript code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldOptions_JSType\n```\n\n----------------------------------------\n\nTITLE: Destroying CodedInputStream in C++\nDESCRIPTION: Destroys the CodedInputStream and positions the underlying ZeroCopyInputStream at the first unread byte. If an error occurred while reading, the exact position may be anywhere between the last successfully read value and the stream's byte limit.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\n~CodedInputStream()\n```\n\n----------------------------------------\n\nTITLE: Swapping RepeatedPtrField Internal State\nDESCRIPTION: Internal method used to swap the contents of two RepeatedPtrField objects. This method is public because it needs to be called by generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_55\n\nLANGUAGE: cpp\nCODE:\n```\nvoid RepeatedPtrField::InternalSwap(\n        RepeatedPtrField * other)\n```\n\n----------------------------------------\n\nTITLE: FileInputStream Next Method Implementation\nDESCRIPTION: Virtual method to obtain the next chunk of data from the stream. Returns data pointer and size, with ownership remaining with the stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool Next(const void ** data, int * size)\n```\n\n----------------------------------------\n\nTITLE: Reading Little-Endian 32-bit Integer\nDESCRIPTION: Static method for reading a 32-bit little-endian integer from a buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nstatic const uint8 * ReadLittleEndian32FromArray(const uint8 * buffer, uint32 * value)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Package Declaration and Imports\nDESCRIPTION: Initial proto file setup defining package namespace and importing required timestamp type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\npackage tutorial;\n\nimport \"google/protobuf/timestamp.proto\";\n```\n\n----------------------------------------\n\nTITLE: Deprecated and Reserved Enum Values\nDESCRIPTION: Shows how to mark enum values as deprecated or reserved to prevent their reuse.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nenum PhoneType {\n  PHONE_TYPE_UNSPECIFIED = 0;\n  PHONE_TYPE_MOBILE = 1;\n  PHONE_TYPE_HOME = 2;\n  PHONE_TYPE_WORK = 3 [deprecated=true];\n  reserved 4,5;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer from ZeroCopyInputStream in C++\nDESCRIPTION: Methods for parsing a protocol buffer from a ZeroCopyInputStream, with options for handling missing required fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool MergeFromBoundedZeroCopyStream(io::ZeroCopyInputStream* input, int size)\n```\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool ParseFromBoundedZeroCopyStream(io::ZeroCopyInputStream* input, int size)\n```\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool ParsePartialFromBoundedZeroCopyStream(io::ZeroCopyInputStream* input, int size)\n```\n\n----------------------------------------\n\nTITLE: Updating Google Protobuf Module in Go\nDESCRIPTION: Updates the google.golang.org/protobuf module to the latest version using the go get command.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/faq.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo get -u google.golang.org/protobuf/proto\n```\n\n----------------------------------------\n\nTITLE: Printing with Variable Substitutions\nDESCRIPTION: Method to print text with variable substitutions from a map of key-value pairs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nvoid Print(const std::map<std::string, std::string>& variables, const char* text)\n```\n\n----------------------------------------\n\nTITLE: Example of Package Declaration in Proto3\nDESCRIPTION: Shows an example of how to declare a package in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_14\n\nLANGUAGE: proto3\nCODE:\n```\npackage foo.bar;\n```\n\n----------------------------------------\n\nTITLE: FieldMask Format\nDESCRIPTION: Demonstrates the string representation of FieldMask with dot-separated field paths.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/json.md#2025-04-11_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n\"f.fooBar,h\"\n```\n\n----------------------------------------\n\nTITLE: Arena Constructor Type Requirements\nDESCRIPTION: Code pattern requirement for types to be arena-constructable, showing the required constructor signatures and type traits.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nclass T {\n  T(Args... args);  // Heap constructor\n  T(Arena* arena, Args&&... args);  // Arena constructor\n  typedef void InternalArenaConstructable_;\n  typedef void DestructorSkippable_; // Optional\n};\n```\n\n----------------------------------------\n\nTITLE: Proto3 Message Definition with Implicit Presence\nDESCRIPTION: A basic Proto3 message definition using implicit presence (default behavior without optional keyword) for field tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage example;\nmessage Msg {\n  int32 foo = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Custom Enum Options in C++\nDESCRIPTION: Demonstrates how to read custom enum options in C++ code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_41\n\nLANGUAGE: cpp\nCODE:\n```\nconst absl::string_view foo = proto2::GetEnumDescriptor<Data>()\n    ->FindValueByName(\"DATA_DISPLAY\")->options().GetExtension(string_name);\n```\n\n----------------------------------------\n\nTITLE: Updating PATH for Protocol Compiler (Linux)\nDESCRIPTION: This snippet demonstrates how to update the PATH environment variable to include the directory containing the protoc executable. It appends the $HOME/.local/bin directory to the existing PATH.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/installation.md#2025-04-11_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nexport PATH=\"$PATH:$HOME/.local/bin\"\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Method Idempotency Level Enumeration\nDESCRIPTION: Defines idempotency levels for protocol buffer methods, indicating their behavior regarding side effects and repeated calls.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_37\n\nLANGUAGE: protobuf\nCODE:\n```\nenum protobuf::MethodOptions_IdempotencyLevel {\n  MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN = 0,\n  MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS = 1,\n  MethodOptions_IdempotencyLevel_IDEMPOTENT = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GPBArray Interface in Objective-C for Protocol Buffers\nDESCRIPTION: This snippet defines the interface for GPBArray, which is used for representing repeated fields in Protocol Buffers. It includes methods for initialization, value access, enumeration, addition, removal, and manipulation of array elements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPBArray : NSObject\n@property (nonatomic, readonly) NSUInteger count;\n+ (instancetype)array;\n+ (instancetype)arrayWithValue:()value;\n+ (instancetype)arrayWithValueArray:(GPBArray *)array;\n+ (instancetype)arrayWithCapacity:(NSUInteger)count;\n\n// Initializes the array, copying the values.\n- (instancetype)initWithValueArray:(GPBArray *)array;\n- (instancetype)initWithValues:(const  [])values\n                         count:(NSUInteger)count NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithCapacity:(NSUInteger)count;\n\n- ()valueAtIndex:(NSUInteger)index;\n\n- (void)enumerateValuesWithBlock:\n     (void (^)( value, NSUInteger idx, BOOL *stop))block;\n- (void)enumerateValuesWithOptions:(NSEnumerationOptions)opts\n    usingBlock:(void (^)( value, NSUInteger idx, BOOL *stop))block;\n\n- (void)addValue:()value;\n- (void)addValues:(const  [])values count:(NSUInteger)count;\n- (void)addValuesFromArray:(GPBArray *)array;\n\n- (void)removeValueAtIndex:(NSUInteger)count;\n- (void)removeAll;\n\n- (void)exchangeValueAtIndex:(NSUInteger)idx1\n            withValueAtIndex:(NSUInteger)idx2;\n- (void)insertValue:()value atIndex:(NSUInteger)count;\n- (void)replaceValueAtIndex:(NSUInteger)index withValue:()value;\n\n\n@end\n```\n\n----------------------------------------\n\nTITLE: Including Ruby Generator Header in C++\nDESCRIPTION: The header file inclusion path for the Ruby generator in Protocol Buffers, containing the Generator class in the google::protobuf::compiler::ruby namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/compiler/ruby/ruby_generator.h>\n```\n\n----------------------------------------\n\nTITLE: Calculating 64-bit Varint Size in Protocol Buffers\nDESCRIPTION: Static method that returns the number of bytes needed to encode a 64-bit unsigned integer as a variable-length encoded value (varint).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_106\n\nLANGUAGE: C++\nCODE:\n```\nstatic size_t VarintSize64(uint64 value)\n```\n\n----------------------------------------\n\nTITLE: C++ Enum Generated for Oneof Fields\nDESCRIPTION: Example of the C++ enum type generated for a oneof field, used to determine which field is currently set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_38\n\nLANGUAGE: cpp\nCODE:\n```\nenum ExampleNameCase {\n  kFooInt = 4,\n  kFooString = 9,\n  EXAMPLE_NAME_NOT_SET = 0\n}\n```\n\n----------------------------------------\n\nTITLE: ConcatenatingInputStream BackUp Method Implementation\nDESCRIPTION: Virtual method that backs up a specified number of bytes in the input stream, allowing subsequent Next() calls to re-read the same data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void ConcatenatingInputStream::BackUp(\n        int count)\n```\n\n----------------------------------------\n\nTITLE: Checking Default Serialization Determinism in Protocol Buffers\nDESCRIPTION: Static method that returns whether the default serialization behavior is deterministic (producing the same binary output for equivalent messages).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_108\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool IsDefaultSerializationDeterministic()\n```\n\n----------------------------------------\n\nTITLE: Reserved Enum Values and Names\nDESCRIPTION: Demonstrates how to reserve numeric values and names in an enum to prevent their future use.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  reserved 2, 15, 9 to 11, 40 to max;\n  reserved \"FOO\", \"BAR\";\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Default int64 Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_INT64. Returns 0 if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_33\n\nLANGUAGE: cpp\nCODE:\n```\nint64 FieldDescriptor::default_value_int64() const\n```\n\n----------------------------------------\n\nTITLE: Identifying Protocol Buffer Errors in Go\nDESCRIPTION: To identify whether an error is produced by the protobuf module, use errors.Is with proto.Error. This method is guaranteed to work for all errors from the module.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/faq.md#2025-04-11_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nerrors.Is(err, proto.Error)\n```\n\n----------------------------------------\n\nTITLE: API Level Configuration in Proto File\nDESCRIPTION: Example of setting the API level using editions feature in a .proto file to specify the use of Opaque API.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage log;\n\nimport \"google/protobuf/go_features.proto\";\noption features.(pb.go).api_level = API_OPAQUE;\n\nmessage LogEntry { … }\n```\n\n----------------------------------------\n\nTITLE: Generating Debug String with Options in C++\nDESCRIPTION: Method to get a customized string representation of the service descriptor based on provided debug options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_75\n\nLANGUAGE: C++\nCODE:\n```\nstd::string DebugStringWithOptions(const DebugStringOptions & options) const\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of proto.Size for Message Unmarshaling in Go\nDESCRIPTION: Shows an anti-pattern where proto.Size is incorrectly used for unmarshaling a stream of protocol buffer messages, which can fail with non-minimal wire format messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/size.md#2025-04-11_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc bytesToSubscriptionList(data []byte) ([]*vpb.EventSubscription, error) {\n    subList := []*vpb.EventSubscription{}\n    for len(data) > 0 {\n        subscription := &vpb.EventSubscription{}\n        if err := proto.Unmarshal(data, subscription); err != nil {\n            return nil, err\n        }\n        subList = append(subList, subscription)\n        data = data[:len(data)-proto.Size(subscription)]\n    }\n    return subList, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Integer Values in Protocol Buffers using Reflection in C++\nDESCRIPTION: Methods for setting various integer field types within Protocol Buffer messages. These methods allow for programmatically setting field values using field descriptors rather than generated accessors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_37\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetInt64(Message * message, const FieldDescriptor * field, int64 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetUInt32(Message * message, const FieldDescriptor * field, uint32 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetUInt64(Message * message, const FieldDescriptor * field, uint64 value) const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Import Statement Definition\nDESCRIPTION: Specifies the syntax for import statements in Protocol Buffers, which can be regular, weak, or public imports of other .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_10\n\nLANGUAGE: ebnf\nCODE:\n```\nimport = \"import\" [ \"weak\" | \"public\" ] strLit \";\"\n```\n\n----------------------------------------\n\nTITLE: EBNF Representation of Message Syntax\nDESCRIPTION: Extended Backus-Naur Form (EBNF) syntax defining the message structure for the Protocol Buffer Text Format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_11\n\nLANGUAGE: ebnf\nCODE:\n```\nMessage = { Field } ;\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for PHP Output\nDESCRIPTION: Example of how to invoke the protocol buffer compiler with the --php_out flag to generate PHP code from a proto file. This command reads from src/example.proto and outputs to the build/gen directory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --php_out=build/gen src/example.proto\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for C++ Output\nDESCRIPTION: Example of how to use the protocol buffer compiler to generate C++ code from .proto files. It demonstrates the use of --proto_path and --cpp_out flags.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --cpp_out=build/gen src/foo.proto src/bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: Checking if File is Loaded\nDESCRIPTION: Returns true if a FileDescriptor has been constructed for the given file. For internal (unit test) use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_132\n\nLANGUAGE: C++\nCODE:\n```\nbool DescriptorPool::InternalIsFileLoaded(ConstStringParam filename) const\n```\n\n----------------------------------------\n\nTITLE: Generated Objective-C Code for Nested Enum in Protocol Buffers\nDESCRIPTION: Shows how a nested enum is translated to Objective-C, including the enum definition, descriptor, validation function, and message class with properties.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_27\n\nLANGUAGE: objc\nCODE:\n```\ntypedef GPB_ENUM(Foo_Bar) {\n  Foo_Bar_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue, //proto3 only\n  Foo_Bar_ValueA = 0;\n  Foo_Bar_ValueB = 1;\n  Foo_Bar_ValueC = 5;\n};\n\nGPBEnumDescriptor *Foo_Bar_EnumDescriptor();\n\nBOOL Foo_Bar_IsValidValue(int32_t value);\n\n@interface Foo : GPBMessage\n@property (nonatomic, readwrite) Foo_Bar aBar;\n@property (nonatomic, readwrite) Foo_Bar aDifferentBar;\n@property (nonatomic, readwrite, strong, null_resettable)\n GPBEnumArray *aRepeatedBarArray;\n@end\n\n// proto3 only Every message that has an enum field will have an accessor function to get\n// the value of that enum as an integer. This allows clients to deal with\n// raw values if they need to.\nint32_t Foo_ABar_RawValue(Foo *message);\nvoid SetFoo_ABar_RawValue(Foo *message, int32_t value);\nint32_t Foo_ADifferentBar_RawValue(Foo *message);\nvoid SetFoo_ADifferentBar_RawValue(Foo *message, int32_t value);\n```\n\n----------------------------------------\n\nTITLE: Working with Enum Values in Protocol Buffers C++\nDESCRIPTION: Demonstrates how to get and set enum values using integer representations instead of EnumValueDescriptor pointers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_55\n\nLANGUAGE: C++\nCODE:\n```\nint Reflection::GetEnumValue(\n    const Message& message,\n    const FieldDescriptor* field) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::SetEnumValue(\n    Message* message,\n    const FieldDescriptor* field,\n    int value) const\n```\n\n----------------------------------------\n\nTITLE: GzipOutputStream Flush Method\nDESCRIPTION: Method to flush compressed data to the underlying stream. Returns true if successful. Block size must be greater than 6 bytes to avoid repeated flush markers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nbool GzipOutputStream::Flush()\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Extensions in Protocol Buffers\nDESCRIPTION: Shows how to declare an extension that is nested inside another message type. This is a common pattern for organizing related extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_45\n\nLANGUAGE: proto\nCODE:\n```\nmessage Baz {\n  extend Foo {\n    optional Baz foo_ext = 124;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Printable Name in DescriptorPool (C++)\nDESCRIPTION: Finds an extension of the given extendee by its printable name. Returns the corresponding extension descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_117\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * FindExtensionByPrintableName(const Descriptor * extendee, ConstStringParam printable_name) const\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Destructor in Arena (C++)\nDESCRIPTION: Adds a custom member function on an object to the list of destructors that will be manually called when the arena is destroyed or reset. Allows specifying any member function, not just the class destructor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nvoid Arena::OwnCustomDestructor(\n        void * object,\n        void(*)(void *) destruct)\n```\n\n----------------------------------------\n\nTITLE: Repeated Enum Field Definition in Protocol Buffers\nDESCRIPTION: Shows how repeated enum fields are defined and explains their behavior with unknown values in closed enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/enum.md#2025-04-11_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nenum Enum {\n  A = 0;\n  B = 1;\n}\n\nmessage Msg {\n  repeated Enum r = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Message Schema Definition\nDESCRIPTION: Detailed message definitions for Person and AddressBook types, including nested PhoneNumber message, PhoneType enum, and field definitions with tags.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/darttutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage Person {\n  string name = 1;\n  int32 id = 2;  // Unique ID number for this person.\n  string email = 3;\n\n  enum PhoneType {\n    PHONE_TYPE_UNSPECIFIED = 0;\n    PHONE_TYPE_MOBILE = 1;\n    PHONE_TYPE_HOME = 2;\n    PHONE_TYPE_WORK = 3;\n  }\n\n  message PhoneNumber {\n    string number = 1;\n    PhoneType type = 2;\n  }\n\n  repeated PhoneNumber phones = 4;\n\n  google.protobuf.Timestamp last_updated = 5;\n}\n\n// Our address book file is just one of these.\nmessage AddressBook {\n  repeated Person people = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Empty Messages with proto.Size in Go\nDESCRIPTION: Shows how to use proto.Size to identify empty protocol buffer messages or messages with only default values in proto3.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/size.md#2025-04-11_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nif proto.Size(m) == 0 {\n    // No fields set (or, in proto3, all fields matching the default);\n    // skip processing this message, or return an error, or similar.\n}\n```\n\n----------------------------------------\n\nTITLE: Inefficient Message Release Pattern - C++\nDESCRIPTION: Shows an inefficient usage of the release_nested_message() API that causes unnecessary copying when working with arena-allocated messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\narena_message_2->set_allocated_nested_message(arena_message_1->release_nested_message());\n\narena_message_1->release_message(); // returns a copy of the underlying nested_message and deletes underlying pointer\n```\n\n----------------------------------------\n\nTITLE: FieldMaskUtil MergeOptions Class Member Declarations\nDESCRIPTION: Defines the MergeOptions class members for configuring how Protocol Buffer fields are merged, including options for handling message and repeated fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nMergeOptions();\nvoid set_replace_message_fields(bool value);\nbool replace_message_fields() const;\nvoid set_replace_repeated_fields(bool value);\nbool replace_repeated_fields() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Services in Protocol Buffers\nDESCRIPTION: Shows the proper TitleCase naming convention for service and method definitions in Protocol Buffers, following the recommended request/response pattern.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/style.md#2025-04-11_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\nservice FooService {\n  rpc GetSomething(GetSomethingRequest) returns (GetSomethingResponse);\n  rpc ListSomething(ListSomethingRequest) returns (ListSomethingResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Writing 64-bit Varint encoded value in CodedOutputStream\nDESCRIPTION: Writes an unsigned 64-bit integer using Protocol Buffers' Varint encoding format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_81\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteVarint64(uint64 value)\n```\n\n----------------------------------------\n\nTITLE: Enabling Aliasing in EpsCopyOutputStream in C++\nDESCRIPTION: Configures the EpsCopyOutputStream to allow the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying, if it supports it. This primarily affects WriteRawMaybeAliased() behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_64\n\nLANGUAGE: C++\nCODE:\n```\nvoid EpsCopyOutputStream::EnableAliasing(\n        bool enabled)\n```\n\n----------------------------------------\n\nTITLE: Finding Method by Name in C++\nDESCRIPTION: Method to look up a MethodDescriptor by name within the service.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_72\n\nLANGUAGE: C++\nCODE:\n```\nconst MethodDescriptor * FindMethodByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Configuring Option Targets in Protocol Buffers\nDESCRIPTION: Example showing how to use option targets to control which types of entities can use specific fields within shared option messages. Includes file, message, and enum option examples with target restrictions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_36\n\nLANGUAGE: proto\nCODE:\n```\nmessage MyOptions {\n  string file_only_option = 1 [targets = TARGET_TYPE_FILE];\n  int32 message_and_enum_option = 2 [targets = TARGET_TYPE_MESSAGE,\n                                     targets = TARGET_TYPE_ENUM];\n}\n\nextend google.protobuf.FileOptions {\n  optional MyOptions file_options = 50000;\n}\n\nextend google.protobuf.MessageOptions {\n  optional MyOptions message_options = 50000;\n}\n\nextend google.protobuf.EnumOptions {\n  optional MyOptions enum_options = 50000;\n}\n\n// OK: this field is allowed on file options\noption (file_options).file_only_option = \"abc\";\n\nmessage MyMessage {\n  // OK: this field is allowed on both message and enum options\n  option (message_options).message_and_enum_option = 42;\n}\n\nenum MyEnum {\n  MY_ENUM_UNSPECIFIED = 0;\n  // Error: file_only_option cannot be set on an enum.\n  option (enum_options).file_only_option = \"xyz\";\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Nested Message Class in Objective-C\nDESCRIPTION: Shows the Objective-C class interface generated for a nested protocol buffer message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_4\n\nLANGUAGE: objc\nCODE:\n```\n@interface Foo_Bar : GPBMessage\n@end\n```\n\n----------------------------------------\n\nTITLE: Installing Protocol Buffer Go Plugin\nDESCRIPTION: Command to install the Go protocol buffer compiler plugin using Go 1.16 or higher. The plugin is required to generate Go code from .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n----------------------------------------\n\nTITLE: AnnotationProtoCollector::AddAnnotation Method Implementation in C++\nDESCRIPTION: Declaration of the overridden AddAnnotation method in AnnotationProtoCollector that implements the base class virtual method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void AddAnnotation(size_t begin_offset, size_t end_offset, const std::string & file_path, const std::vector<int> & path)\n```\n\n----------------------------------------\n\nTITLE: Accessing Stub Service Implementation in C++\nDESCRIPTION: Shows how to access the stub implementation of a service called 'Foo'. The stub can be referred to either as 'Foo_Stub' or through the typedef 'Foo::Stub'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_48\n\nLANGUAGE: cpp\nCODE:\n```\nFoo_Stub // Direct reference to the stub class\nFoo::Stub // Reference through typedef\n```\n\n----------------------------------------\n\nTITLE: Building File from FileDescriptorProto in DescriptorPool (C++)\nDESCRIPTION: Converts a FileDescriptorProto to real descriptors and places them in this DescriptorPool. Returns the resulting FileDescriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_119\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * BuildFile(const FileDescriptorProto & proto)\n```\n\n----------------------------------------\n\nTITLE: Creating a Message with Arena Allocation in C++\nDESCRIPTION: This snippet demonstrates how to create a Protocol Buffer message using arena allocation. It includes the necessary header and shows the basic usage of the Arena class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <google/protobuf/arena.h>\n{\n  google::protobuf::Arena arena;\n  MyMessage* message = google::protobuf::Arena::Create<MyMessage>(&arena);\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Statements in Proto3\nDESCRIPTION: Defines the syntax for empty statements (semicolons) in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_7\n\nLANGUAGE: ebnf\nCODE:\n```\nemptyStatement = \";\"\n```\n\n----------------------------------------\n\nTITLE: Defining Package Declaration in Protocol Buffers\nDESCRIPTION: Specifies the syntax for package declarations in Protocol Buffers, which help prevent name clashes between message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_12\n\nLANGUAGE: EBNF\nCODE:\n```\npackage = \"package\" fullIdent \";\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Proto3 Syntax in Protocol Buffer File\nDESCRIPTION: Demonstrates how to declare proto3 syntax at the beginning of a .proto file, which is required for C# code generation support.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n```\n\n----------------------------------------\n\nTITLE: Reading 32-bit varint in CodedInputStream in C++\nDESCRIPTION: Reads an unsigned integer with Varint encoding, truncating to 32 bits.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nbool ReadVarint32(uint32* value)\n```\n\n----------------------------------------\n\nTITLE: Defining Singular Bytes Fields with Cord Support in Protocol Buffers\nDESCRIPTION: Shows how to define singular bytes fields with Cord support in Protocol Buffers. This generates specific C++ accessor methods using absl::Cord.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\noptional bytes foo = 25 [ctype=CORD];\nbytes bar = 26 [ctype=CORD];\n```\n\n----------------------------------------\n\nTITLE: Registering Message Printer in Protocol Buffers TextFormat\nDESCRIPTION: Method to register a custom MessagePrinter for specific message descriptors. Returns true on successful registration, or false if a printer is already registered for the given Descriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_33\n\nLANGUAGE: cpp\nCODE:\n```\nbool Printer::RegisterMessagePrinter(\n        const Descriptor* descriptor,\n        const MessagePrinter* printer)\n```\n\n----------------------------------------\n\nTITLE: Using FieldDescriptor::cpp_string_type() API in C++\nDESCRIPTION: The v30 release will stop exposing the 'ctype' from FieldDescriptor options. Users should migrate to using the FieldDescriptor::cpp_string_type() API that was added in v28 release.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v30.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nFieldDescriptor::cpp_string_type()\n```\n\n----------------------------------------\n\nTITLE: Finding All Extension Numbers in EncodedDescriptorDatabase (C++)\nDESCRIPTION: Method to find all extension numbers for a given type in the EncodedDescriptorDatabase. It appends the found numbers to the output vector and returns true if successful, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool EncodedDescriptorDatabase::FindAllExtensionNumbers(\n    const std::string & ,\n    std::vector< int > * )\n```\n\n----------------------------------------\n\nTITLE: GzipOutputStream Next Method\nDESCRIPTION: Gets a buffer for writing data that will be compressed. Returns false on error. Buffer remains valid until next stream operation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool GzipOutputStream::Next(\n        void ** data,\n        int * size)\n```\n\n----------------------------------------\n\nTITLE: Finding Service by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up a ServiceDescriptor by its fully-qualified name. Returns the corresponding service descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_114\n\nLANGUAGE: C++\nCODE:\n```\nconst ServiceDescriptor * FindServiceByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Defining Identifiers in Proto3\nDESCRIPTION: Specifies the syntax rules for various types of identifiers used in Protocol Buffers, including field names, message names, service names, and fully-qualified identifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nident = letter { letter | decimalDigit | \"_\" }\nfullIdent = ident { \".\" ident }\nmessageName = ident\nenumName = ident\nfieldName = ident\noneofName = ident\nmapName = ident\nserviceName = ident\nrpcName = ident\nmessageType = [ \".\" ] { ident \".\" } messageName\nenumType = [ \".\" ] { ident \".\" } enumName\n```\n\n----------------------------------------\n\nTITLE: Handling Implicit Field Presence in Ruby\nDESCRIPTION: This snippet demonstrates how to handle implicit field presence in Ruby using Protocol Buffers. It checks if a field has a non-zero value and either clears it or sets it to a default value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_14\n\nLANGUAGE: ruby\nCODE:\n```\nm = Msg.new\nif m.foo != 0\n  # \"Clear\" the field:\n  m.foo = 0\nelse\n  # Default value: field may not have been present.\n  m.foo = 1\nend\n```\n\n----------------------------------------\n\nTITLE: Writing Protocol Buffer Tags to CodedOutputStream in C++\nDESCRIPTION: Optimized method for writing tags in Protocol Buffers. Similar to WriteVarint32(), but optimized specifically for tag values, compiling down to a couple of instructions for compile-time constants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_112\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CodedOutputStream::WriteTag(\n        uint32 value)\n```\n\n----------------------------------------\n\nTITLE: Raw Data Writing Operations\nDESCRIPTION: Methods for writing raw data directly to the output stream without processing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvoid PrintRaw(const std::string& data)\nvoid PrintRaw(const char* data)\nvoid WriteRaw(const char* data, int size)\n```\n\n----------------------------------------\n\nTITLE: Constructor for Service Stub in C++\nDESCRIPTION: Defines the basic constructor for a service stub that accepts an RpcChannel parameter to handle request transmission.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_49\n\nLANGUAGE: cpp\nCODE:\n```\nFoo_Stub(RpcChannel* channel)\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Printable Name in Protocol Buffers (C++)\nDESCRIPTION: Finds an extension of a given type by its printable name. The extendee must be a member of the DescriptorPool or one of its underlays. Returns nullptr if there is no known message extension with the given name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_138\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * \n    DescriptorPool::FindExtensionByPrintableName(\n        const Descriptor * extendee,\n        ConstStringParam printable_name) const\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Proto Structure\nDESCRIPTION: Proto definition file for NestedMessage containing a single optional integer field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\n// nested_message.proto\n\nsyntax = \"proto2\";\n\npackage feature_package;\n\n// NEXT Tag to use: 2\nmessage NestedMessage {\n  optional int32 feature_id = 1;\n};\n```\n\n----------------------------------------\n\nTITLE: Option Examples in Protocol Buffers\nDESCRIPTION: Demonstrates the use of options to specify the Java package and feature settings in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_15\n\nLANGUAGE: proto\nCODE:\n```\noption java_package = \"com.example.foo\";\noption features.enum_type = CLOSED;\n```\n\n----------------------------------------\n\nTITLE: Defining Hugo Front Matter for Protocol Buffers Documentation Page in YAML\nDESCRIPTION: This snippet contains the Hugo front matter configuration for a documentation page about Protocol Buffers programming guides. It sets the page title, weight (for ordering), description, and content type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n+++\ntitle = \"Programming Guides\"\nweight = 27\ndescription = \"Learn how to use Protocol Buffers in your projects.\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Extension Registry Configuration in CodedInputStream\nDESCRIPTION: Method signature and example code for setting up extension registry with DescriptorPool and MessageFactory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_35\n\nLANGUAGE: C++\nCODE:\n```\nvoid CodedInputStream::SetExtensionRegistry(\n        const DescriptorPool* pool,\n        MessageFactory* factory)\n```\n\n----------------------------------------\n\nTITLE: Accessing Oneof Methods in Protocol Buffers\nDESCRIPTION: Methods for accessing and managing oneof field descriptors in Protocol Buffers message types. Includes methods for counting oneofs and looking up oneofs by name or index.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nreal_oneof_decl_count() const\noneof_decl(int index) const\nFindOneofByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Registering Field Value Printer in Protocol Buffers TextFormat\nDESCRIPTION: Method to register a custom FastFieldValuePrinter for specific field descriptors. Returns true on successful registration and takes ownership of the printer object. Returns false if a printer is already registered for the given FieldDescriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\nbool Printer::RegisterFieldValuePrinter(\n        const FieldDescriptor* field,\n        const FastFieldValuePrinter* printer)\n```\n\n----------------------------------------\n\nTITLE: Grouping Multiple Options with Sub-messages\nDESCRIPTION: Demonstrates how to use a single extension number for multiple related options by grouping them in a sub-message. This approach helps conserve extension numbers which is important for public applications.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_58\n\nLANGUAGE: proto\nCODE:\n```\nmessage FooOptions {\n  optional int32 opt1 = 1;\n  optional string opt2 = 2;\n}\n\nextend google.protobuf.FieldOptions {\n  optional FooOptions foo_options = 1234;\n}\n\n// usage:\nmessage Bar {\n  optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = \"baz\"];\n  // alternative aggregate syntax (uses TextFormat):\n  optional int32 b = 2 [(foo_options) = { opt1: 123 opt2: \"baz\" }];\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Public Dependencies in FileDescriptor (C++)\nDESCRIPTION: Gets a public imported file by index, where the index must be between 0 and public_dependency_count(). Files are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_81\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * \n    FileDescriptor::public_dependency(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Defining String Literals in Proto3\nDESCRIPTION: Specifies the syntax for string literals in Protocol Buffers, including various types of escape sequences for special characters and Unicode characters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_6\n\nLANGUAGE: ebnf\nCODE:\n```\nstrLit = strLitSingle { strLitSingle }\nstrLitSingle = ( \"'\" { charValue } \"'\" ) |  ( '\"' { charValue } '\"' )\ncharValue = hexEscape | octEscape | charEscape | unicodeEscape | unicodeLongEscape | /[^\\0\\n\\\\]/\nhexEscape = '\\' ( \"x\" | \"X\" ) hexDigit [ hexDigit ]\noctEscape = '\\' octalDigit [ octalDigit [ octalDigit ] ]\ncharEscape = '\\' ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | '\\' | \"'\" | '\"' )\nunicodeEscape = '\\' \"u\" hexDigit hexDigit hexDigit hexDigit\nunicodeLongEscape = '\\' \"U\" ( \"000\" hexDigit hexDigit hexDigit hexDigit hexDigit |\n                              \"0010\" hexDigit hexDigit hexDigit hexDigit\n```\n\n----------------------------------------\n\nTITLE: Allowing Unknown Dependencies in Protocol Buffers (C++)\nDESCRIPTION: Configures the DescriptorPool to allow references to unknown types or files by replacing them with placeholder descriptors. This enables operations with a .proto file even without access to its dependencies.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_141\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::AllowUnknownDependencies()\n```\n\n----------------------------------------\n\nTITLE: Proto2 String Literals Definition\nDESCRIPTION: Defines the syntax for string literals in Protocol Buffers, supporting single or double quotes with various escape sequences including hex, octal, character, and Unicode escapes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_6\n\nLANGUAGE: ebnf\nCODE:\n```\nstrLit = strLitSingle { strLitSingle }\nstrLitSingle = ( \"'\" { charValue } \"'\" ) | ( '\"' { charValue } '\"' )\ncharValue = hexEscape | octEscape | charEscape | unicodeEscape | unicodeLongEscape | /[^\\0\\n\\\\]/\nhexEscape = '\\' ( \"x\" | \"X\" ) hexDigit [ hexDigit ]\noctEscape = '\\' octalDigit [ octalDigit [ octalDigit ] ]\ncharEscape = '\\' ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | '\\' | \"'\" | '\"' )\nunicodeEscape = '\\' \"u\" hexDigit hexDigit hexDigit hexDigit\nunicodeLongEscape = '\\' \"U\" ( \"000\" hexDigit hexDigit hexDigit hexDigit hexDigit |\n                              \"0010\" hexDigit hexDigit hexDigit hexDigit\n```\n\n----------------------------------------\n\nTITLE: Defining Source Retention Option in Protocol Buffers\nDESCRIPTION: Demonstrates how to set source retention on a file option extension. This prevents the option from being retained in the generated code while still being visible to protoc.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_42\n\nLANGUAGE: proto\nCODE:\n```\nextend google.protobuf.FileOptions {\n  int32 source_retention_option = 1234\n      [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DslList Function in Kotlin for Protocol Buffers\nDESCRIPTION: This function creates a DslList wrapper that delegates to a standard Kotlin List. It's likely used in the Protocol Buffers Kotlin DSL implementation for handling lists in proto message builders.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/-dsl-list.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <E> DslList(delegate: List<E>)\n```\n\n----------------------------------------\n\nTITLE: Configuring Number-Field Spacing in C++\nDESCRIPTION: Method to set whether whitespace is required between a number and a field name in the Tokenizer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvoid Tokenizer::set_require_space_after_number(bool require)\n```\n\n----------------------------------------\n\nTITLE: Raw C-String Output to Buffer (C++)\nDESCRIPTION: Writes a zero-delimited string directly to the output buffer without processing newlines for indentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::PrintRaw(\n        const char * data)\n```\n\n----------------------------------------\n\nTITLE: Configuring Markdown Metadata for C# API Documentation\nDESCRIPTION: This snippet defines YAML front matter for a Markdown file. It sets the page title, provides a manual link to external API documentation, specifies the link should open in a new tab, and sets a weight for page ordering.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: \"C# API\"\nmanualLink: \"/reference/csharp/api-docs\"\nmanualLinkTarget: \"_blank\"\nweight: 560\n---\n```\n\n----------------------------------------\n\nTITLE: Getting Field Options in Protocol Buffers (C++)\nDESCRIPTION: Returns the FieldOptions for this field, including options defined in square brackets after the field definition, such as custom options or extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_45\n\nLANGUAGE: cpp\nCODE:\n```\nconst FieldOptions & \n    FieldDescriptor::options() const\n```\n\n----------------------------------------\n\nTITLE: Configuring Short Format for Repeated Primitives in TextFormat Printer (C++)\nDESCRIPTION: Enables printing repeated primitive values in a compact array format [1, 2, 3, 4] instead of one per line. This applies only to primitive values, not strings or sub-messages/groups.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetUseShortRepeatedPrimitives(\n        bool use_short_repeated_primitives)\n```\n\n----------------------------------------\n\nTITLE: Defining Enums in Protocol Buffers\nDESCRIPTION: Specifies the syntax for enum definitions in Protocol Buffers, including enum fields, options, and value options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_27\n\nLANGUAGE: EBNF\nCODE:\n```\nenum = \"enum\" enumName enumBody\nenumBody = \"{\" { option | enumField | emptyStatement | reserved } \"}\"\nenumField = fieldName \"=\" [ \"-\" ] intLit [ \"[\" enumValueOption { \",\"  enumValueOption } \"]\" ]\";\"\nenumValueOption = optionName \"=\" constant\n```\n\n----------------------------------------\n\nTITLE: Tokenizer Parse Method Declarations\nDESCRIPTION: Static helper methods for parsing different token types including floats, strings, and integers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstatic double ParseFloat(const std::string& text);\nstatic void ParseString(const std::string& text, std::string* output);\nstatic void ParseStringAppend(const std::string& text, std::string* output);\nstatic bool ParseInteger(const std::string& text, uint64 max_value, uint64* output);\n```\n\n----------------------------------------\n\nTITLE: Destroying CodedOutputStream in C++\nDESCRIPTION: Destructor for CodedOutputStream that positions the underlying ZeroCopyOutputStream immediately after the last byte written.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_69\n\nLANGUAGE: C++\nCODE:\n```\n~CodedOutputStream()\n```\n\n----------------------------------------\n\nTITLE: Accessing Direct Buffer in CodedInputStream in C++\nDESCRIPTION: Sets *data to point directly at the unread part of the CodedInputStream's underlying buffer and *size to the buffer size. This method does not advance the stream's current position and always produces a non-empty buffer or returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\nbool GetDirectBufferPointer(const void ** data, int * size)\n```\n\n----------------------------------------\n\nTITLE: Checking if FileDescriptor is a Placeholder (C++)\nDESCRIPTION: Returns true if this is a placeholder for an unknown file. This will only be the case if this descriptor comes from a DescriptorPool with AllowUnknownDependencies() set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_100\n\nLANGUAGE: C++\nCODE:\n```\nbool FileDescriptor::is_placeholder() const\n```\n\n----------------------------------------\n\nTITLE: Setting Code Size Optimization in Protocol Buffers\nDESCRIPTION: Sets the optimize_for option to CODE_SIZE, which generates minimal classes that rely on reflection-based code for operations, resulting in smaller code size at the cost of speed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_45\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = CODE_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Modifying Repeated Field Elements in Protocol Buffers C++ API\nDESCRIPTION: This snippet shows the method signatures for modifying elements of repeated fields. These methods allow setting values at a specific index in repeated fields, supporting various data types including int32, int64, float, bool, string, enum, and message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_44\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedInt32(Message * message, const FieldDescriptor * field, int index, int32 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedInt64(Message * message, const FieldDescriptor * field, int index, int64 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedUInt32(Message * message, const FieldDescriptor * field, int index, uint32 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedUInt64(Message * message, const FieldDescriptor * field, int index, uint64 value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedFloat(Message * message, const FieldDescriptor * field, int index, float value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedDouble(Message * message, const FieldDescriptor * field, int index, double value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedBool(Message * message, const FieldDescriptor * field, int index, bool value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedString(Message * message, const FieldDescriptor * field, int index, std::string value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedEnum(Message * message, const FieldDescriptor * field, int index, const EnumValueDescriptor * value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetRepeatedEnumValue(Message * message, const FieldDescriptor * field, int index, int value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nMessage * MutableRepeatedMessage(Message * message, const FieldDescriptor * field, int index) const\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Extension in DescriptorPoolDatabase (C++)\nDESCRIPTION: Method to find the file that defines an extension for a given message type and field number in the DescriptorPoolDatabase. It fills the output with the FileDescriptorProto if found and returns true, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool DescriptorPoolDatabase::FindFileContainingExtension(\n    const std::string & containing_type,\n    int field_number,\n    FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Proto3 Repeated Field Encoding Example\nDESCRIPTION: Demonstrates repeated field encoding configuration in proto3 format and its Edition 2023 equivalent.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_7\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage Foo {\n  repeated int32 bar = 6;\n  repeated int32 baz = 7 [packed=false];\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage Foo {\n  repeated int32 bar = 6;\n  repeated int32 baz = 7 [features.repeated_field_encoding=EXPANDED];\n}\n```\n\n----------------------------------------\n\nTITLE: ZigZag Encoding Formulas\nDESCRIPTION: Code formulas demonstrating how sint32 and sint64 values are encoded using ZigZag encoding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n(n << 1) ^ (n >> 31)\n```\n\nLANGUAGE: text\nCODE:\n```\n(n << 1) ^ (n >> 63)\n```\n\n----------------------------------------\n\nTITLE: Extracting Protocol Compiler Binary (Linux)\nDESCRIPTION: This snippet shows how to extract the downloaded protocol compiler zip file to a specific directory. It uses the unzip command to extract the contents to the $HOME/.local directory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/installation.md#2025-04-11_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nunzip protoc-30.2-linux-x86_64.zip -d $HOME/.local\n```\n\n----------------------------------------\n\nTITLE: Extensions Examples in Protocol Buffers\nDESCRIPTION: Demonstrates the declaration of extension ranges in Protocol Buffers, allowing specific field number ranges to be used for extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\nextensions 100 to 199;\nextensions 4, 20 to max;\n```\n\n----------------------------------------\n\nTITLE: Hugo Front Matter Configuration\nDESCRIPTION: Markdown front matter configuration for a Hugo documentation page about Protocol Buffers Dart integration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n+++\ntitle = \"Dart Reference\"\nweight = 570\nlinkTitle = \"Dart\"\ndescription = \"Reference documentation for working with protocol buffer classes in Dart\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Declaring ErrorCollector Class for Error Handling in Protocol Buffers\nDESCRIPTION: Abstract interface for collecting errors during parsing. Provides methods to add errors and warnings with line and column information. Implementations can handle reporting errors in different ways.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass ErrorCollector {\npublic:\n  ErrorCollector();\n  virtual ~ErrorCollector();\n  virtual void AddError(int line, ColumnNumber column, const std::string & message) = 0;\n  virtual void AddWarning(int, ColumnNumber, const std::string &);\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Oneof Field\nDESCRIPTION: Example of a oneof field definition in Protocol Buffers that allows either an image URL or image data to be set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\noneof avatar {\n  string image_url = 1;\n  bytes image_data = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing EnumDescriptor Members in C++\nDESCRIPTION: EnumDescriptor provides methods to access properties of Protocol Buffer enum types, including names, values, and file information.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_52\n\nLANGUAGE: C++\nCODE:\n```\ntypedef EnumDescriptorProto Proto\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& name() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string& full_name() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nint index() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor* file() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nint value_count() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor* value(int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor* FindValueByName(ConstStringParam name) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor* FindValueByNumber(int number) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst Descriptor* containing_type() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumOptions& options() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid CopyTo(EnumDescriptorProto* proto) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nstd::string DebugString() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nstd::string DebugStringWithOptions(const DebugStringOptions& options) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool is_placeholder() const\n```\n\n----------------------------------------\n\nTITLE: FastFieldValuePrinter Virtual Method Declarations\nDESCRIPTION: Class interface defining virtual methods for printing different protocol buffer field types to text format. Methods handle primitive types, strings, enums, field names, and message formatting.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void PrintBool(bool val, BaseTextGenerator* generator) const;\nvirtual void PrintInt32(int32 val, BaseTextGenerator* generator) const;\nvirtual void PrintUInt32(uint32 val, BaseTextGenerator* generator) const;\nvirtual void PrintInt64(int64 val, BaseTextGenerator* generator) const;\nvirtual void PrintUInt64(uint64 val, BaseTextGenerator* generator) const;\nvirtual void PrintFloat(float val, BaseTextGenerator* generator) const;\nvirtual void PrintDouble(double val, BaseTextGenerator* generator) const;\nvirtual void PrintString(const std::string& val, BaseTextGenerator* generator) const;\nvirtual void PrintBytes(const std::string& val, BaseTextGenerator* generator) const;\nvirtual void PrintEnum(int32 val, const std::string& name, BaseTextGenerator* generator) const;\nvirtual void PrintFieldName(const Message& message, int field_index, int field_count, const Reflection* reflection, const FieldDescriptor* field, BaseTextGenerator* generator) const;\nvirtual void PrintFieldName(const Message& message, const Reflection* reflection, const FieldDescriptor* field, BaseTextGenerator* generator) const;\nvirtual void PrintMessageStart(const Message& message, int field_index, int field_count, bool single_line_mode, BaseTextGenerator* generator) const;\nvirtual bool PrintMessageContent(const Message& message, int field_index, int field_count, bool single_line_mode, BaseTextGenerator* generator) const;\nvirtual void PrintMessageEnd(const Message& message, int field_index, int field_count, bool single_line_mode, BaseTextGenerator* generator) const;\n```\n\n----------------------------------------\n\nTITLE: Enum Example in Protocol Buffers\nDESCRIPTION: Demonstrates the definition of an enum in Protocol Buffers with the 'allow_alias' option and a custom option on an enum value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_28\n\nLANGUAGE: proto\nCODE:\n```\nenum EnumAllowingAlias {\n  option allow_alias = true;\n  EAA_UNSPECIFIED = 0;\n  EAA_STARTED = 1;\n  EAA_RUNNING = 2 [(custom_option) = \"hello world\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining String Oneof Fields in Protocol Buffers\nDESCRIPTION: Examples showing how to define string and bytes fields within a oneof construct. Both examples use the same field name 'foo' with field number 1 in separate oneof contexts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_24\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    string foo = 1;\n    ...\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    bytes foo = 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Template Serialize Method in Protocol Buffers\nDESCRIPTION: Template method for serializing data using a provided function object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_91\n\nLANGUAGE: C++\nCODE:\n```\ntemplate void Serialize(const Func & func)\n```\n\n----------------------------------------\n\nTITLE: Sorting Map Entries in C++ Protocol Buffers\nDESCRIPTION: Static method to compute a sorted list of map entries using reflection.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.dynamic_message.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::vector<const Message*> Sort(const Message& message, int map_size, const Reflection* reflection, const FieldDescriptor* field)\n```\n\n----------------------------------------\n\nTITLE: Setting Field Order in Message Printing (C++)\nDESCRIPTION: Controls whether to print fields in source code index order instead of field number order. When true, extensions are printed at the end of the message with their relative order determined by extension number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_29\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetPrintMessageFieldsInIndexOrder(\n        bool print_message_fields_in_index_order)\n```\n\n----------------------------------------\n\nTITLE: Go Type for Package-Level Enum\nDESCRIPTION: Generated Go type for a package-level enum. The type name matches the enum name from the proto definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_28\n\nLANGUAGE: go\nCODE:\n```\ntype Genre int32\n```\n\n----------------------------------------\n\nTITLE: Setting Repeated Enum Value in Protocol Buffers C++\nDESCRIPTION: Sets an enum field's value with an integer rather than EnumValueDescriptor. For proto3, it sets the enum field to the specified value. For proto2, it handles known and unknown enum values differently.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_63\n\nLANGUAGE: C++\nCODE:\n```\nvoid Reflection::SetRepeatedEnumValue(\n    Message* message,\n    const FieldDescriptor* field,\n    int index,\n    int value) const\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Types in FileDescriptor (C++)\nDESCRIPTION: Gets a top-level enum type by index, where the index must be between 0 and enum_type_count(). Types are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_87\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumDescriptor * \n    FileDescriptor::enum_type(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Literals in Proto3\nDESCRIPTION: Defines the syntax for integer literals in Protocol Buffers, including decimal, octal, and hexadecimal representations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nintLit     = decimalLit | octalLit | hexLit\ndecimalLit = [-] ( \"1\" ... \"9\" ) { decimalDigit }\noctalLit   = [-] \"0\" { octalDigit }\nhexLit     = [-] \"0\" ( \"x\" | \"X\" ) hexDigit { hexDigit }\n```\n\n----------------------------------------\n\nTITLE: Setting Proto3 Behavior in Protocol Buffers 2023 Edition\nDESCRIPTION: Configuration example that demonstrates how to set proto3 default behaviors in a Protocol Buffers 2023 Edition file. Includes imports for language-specific features and sets options for field presence, enum type, JSON format, UTF-8 validation, and language-specific enum behaviors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\n// proto3 behaviors\nedition = \"2023\";\n\nimport \"google/protobuf/cpp_features.proto\";\nimport \"google/protobuf/java_features.proto\";\n\noption features.field_presence = IMPLICIT;\noption features.enum_type = OPEN;\n// `packed=false` needs to be transformed to field-level repeated_field_encoding\n// features in Editions syntax\noption features.json_format = ALLOW;\noption features.utf8_validation = VERIFY;\noption features.(pb.cpp).legacy_closed_enum = false;\noption features.(pb.java).legacy_closed_enum = false;\n```\n\n----------------------------------------\n\nTITLE: Declaring FileOutputStream::Close Method in C++\nDESCRIPTION: This method flushes any buffers and closes the underlying file. It returns false if an error occurs during the process. The file descriptor is closed even if an error occurs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nbool FileOutputStream::Close()\n```\n\n----------------------------------------\n\nTITLE: Initializing Tokenizer in C++\nDESCRIPTION: Constructor for the Tokenizer class, which reads and tokenizes text from an input stream and reports errors to an error collector.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nTokenizer::Tokenizer(\n    ZeroCopyInputStream* input,\n    ErrorCollector* error_collector)\n```\n\n----------------------------------------\n\nTITLE: Generated C# Code for Oneof Field\nDESCRIPTION: The C# code generated for the oneof avatar field, including an enum for the case, accessor properties, and a clear method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nenum AvatarOneofCase\n{\n  None = 0,\n  ImageUrl = 1,\n  ImageData = 2\n}\n\npublic AvatarOneofCase AvatarCase { get; }\npublic void ClearAvatar();\npublic string ImageUrl { get; set; }\npublic ByteString ImageData { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Utility Functions in Descriptor Class (C++)\nDESCRIPTION: Demonstrates utility functions in the Descriptor class for debugging and serialization purposes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid CopyTo(DescriptorProto* proto) const;\nstd::string DebugString() const;\nstd::string DebugStringWithOptions(const DebugStringOptions& options) const;\nbool is_placeholder() const;\nWellKnownType well_known_type() const;\n```\n\n----------------------------------------\n\nTITLE: Hiding Unknown Fields in TextFormat Printer (C++)\nDESCRIPTION: Controls whether unknown fields are hidden in the output. By default, unknown fields are printed with tag numbers, but setting this to true will hide them completely.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_28\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetHideUnknownFields(\n        bool hide)\n```\n\n----------------------------------------\n\nTITLE: Defining Floating-Point Literals in Protocol Buffers\nDESCRIPTION: Specifies the syntax for floating-point literals in Protocol Buffers, including decimal notation with optional exponents.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_4\n\nLANGUAGE: EBNF\nCODE:\n```\nfloatLit = [-] ( decimals \".\" [ decimals ] [ exponent ] | decimals exponent | \".\"decimals [ exponent ] ) | \"inf\" | \"nan\"\ndecimals  = [-] decimalDigit { decimalDigit }\nexponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals\n```\n\n----------------------------------------\n\nTITLE: Registering Generated Protocol Buffer Messages in C++\nDESCRIPTION: Registers a message type with its prototype. This method is called by functions registered with InternalRegisterGeneratedFile() to make message prototypes available for instantiation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_73\n\nLANGUAGE: C++\nCODE:\n```\nstatic void MessageFactory::InternalRegisterGeneratedMessage(\n        const Descriptor * descriptor,\n        const Message * prototype)\n```\n\n----------------------------------------\n\nTITLE: Accessing EpsCopyOutputStream in Protocol Buffers\nDESCRIPTION: Method that returns a pointer to the underlying EpsCopyOutputStream, which is likely used for optimized copying operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_94\n\nLANGUAGE: C++\nCODE:\n```\nEpsCopyOutputStream * EpsCopy()\n```\n\n----------------------------------------\n\nTITLE: Deprecated Repeated Field Access Methods in Protocol Buffers (C++)\nDESCRIPTION: Deprecated methods for direct access to the underlying RepeatedField and RepeatedPtrField containers of Protocol Buffer messages. These provide low-level access to the repeated field storage implementation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_48\n\nLANGUAGE: C++\nCODE:\n```\ntemplate const RepeatedField< T > & GetRepeatedField(const Message & msg, const FieldDescriptor * d) const\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate RepeatedField< T > * MutableRepeatedField(Message * msg, const FieldDescriptor * d) const\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate const RepeatedPtrField< T > & GetRepeatedPtrField(const Message & msg, const FieldDescriptor * d) const\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate RepeatedPtrField< T > * MutableRepeatedPtrField(Message * msg, const FieldDescriptor * d) const\n```\n\n----------------------------------------\n\nTITLE: Replacing UnknownFields() Method in Protocol Buffers Python\nDESCRIPTION: Example showing the transition from the deprecated message.UnknownFields() method to the new UnknownFieldSet(message) function in unknown_fields.py. The change will be deprecated in v25 and removed in v26 for both pure Python and C++ extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-08-15.md#2025-04-11_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Old method (deprecated in v25, removed in v26)\nmessage.UnknownFields()\n\n# New method\nfrom google.protobuf.unknown_fields import UnknownFieldSet\nUnknownFieldSet(message)\n```\n\n----------------------------------------\n\nTITLE: PHP Class for Enum with Reserved Names\nDESCRIPTION: Example showing how the compiler handles reserved enum names in PHP by adding the 'PB' prefix to avoid conflicts with PHP keywords.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: php\nCODE:\n```\nclass PBEmpty {\n  const PBECHO = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Protocol Compiler with Homebrew (macOS)\nDESCRIPTION: This snippet demonstrates how to install the protocol compiler using Homebrew on macOS. It installs the protobuf package and checks the installed version.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/installation.md#2025-04-11_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nbrew install protobuf\nprotoc --version  # Ensure compiler version is 3+\n```\n\n----------------------------------------\n\nTITLE: Finding All Extensions in Protocol Buffers (C++)\nDESCRIPTION: Finds all extensions of a given extendee and appends them to the output vector in an undefined order. Only extensions defined in this DescriptorPool or its underlays are guaranteed to be found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_139\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::FindAllExtensions(\n        const Descriptor * extendee,\n        std::vector< const FieldDescriptor * > * out) const\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Literals in Proto3\nDESCRIPTION: Defines the syntax for boolean literals in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_5\n\nLANGUAGE: ebnf\nCODE:\n```\nboolLit = \"true\" | \"false\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Java Files Generation\nDESCRIPTION: Demonstrates setting java_multiple_files option to generate separate .java files for each top-level message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_35\n\nLANGUAGE: proto\nCODE:\n```\noption java_multiple_files = true;\n```\n\n----------------------------------------\n\nTITLE: Using Extension Declarations in C++\nDESCRIPTION: Demonstrates how to use Protocol Buffer extensions in C++ code, showing various extension-related operations like adding and accessing extension fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nUserContent user_content;\nuser_content.AddExtension(kittens::kitten_videos, new kittens::Video());\nassert(1 == user_content.GetExtensionCount(kittens::kitten_videos));\nuser_content.GetExtension(kittens::kitten_videos, 0);\n```\n\n----------------------------------------\n\nTITLE: JSON Parse Options Structure Definition (C++)\nDESCRIPTION: Defines options for parsing JSON into Protocol Buffers format. Includes flags for ignoring unknown fields and case-insensitive enum parsing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nstruct JsonParseOptions {\n    bool ignore_unknown_fields;\n    bool case_insensitive_enum_parsing;\n    JsonParseOptions();\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Token in C++\nDESCRIPTION: Method to get the current token from the Tokenizer. This is updated when Next() is called.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nconst Token& Tokenizer::current()\n```\n\n----------------------------------------\n\nTITLE: Importing Int64 Support in Dart\nDESCRIPTION: Shows how to import the fixnum library for Int64 support in Dart.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:fixnum/fixnum.dart';\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Name in FileDescriptor (C++)\nDESCRIPTION: Finds a top-level extension definition by name. Returns nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_94\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * \n    FileDescriptor::FindExtensionByName(\n        ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Truncating Long String Fields in TextFormat Printer (C++)\nDESCRIPTION: Sets a length threshold for string field truncation. This breaks the round-trip safety of TextFormat::Printer but is useful for messages with very long strings such as encoded image data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_31\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetTruncateStringFieldLongerThan(\n        const int64 truncate_string_field_longer_than)\n```\n\n----------------------------------------\n\nTITLE: EBNF Representation of Numeric Literals\nDESCRIPTION: Extended Backus-Naur Form (EBNF) syntax defining various numeric literals including decimal, octal, hexadecimal integers and floating-point numbers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_9\n\nLANGUAGE: ebnf\nCODE:\n```\ndec_lit   = \"0\"\n          | ( dec - \"0\" ), { dec } ;\nfloat_lit = \".\", dec, { dec }, [ exp ]\n          | dec_lit, \".\", { dec }, [ exp ]\n          | dec_lit, exp ;\nexp       = ( \"E\" | \"e\" ), [ \"+\" | \"-\" ], dec, { dec } ;\n\nDEC_INT   = dec_lit\nOCT_INT   = \"0\", oct, { oct } ;\nHEX_INT   = \"0\", ( \"X\" | \"x\" ), hex, { hex } ;\nFLOAT     = float_lit, [ \"F\" | \"f\" ]\n          | dec_lit,   ( \"F\" | \"f\" ) ;\n```\n\n----------------------------------------\n\nTITLE: Setting Floating-Point Values in Protocol Buffers using Reflection in C++\nDESCRIPTION: Methods for setting floating-point field values within Protocol Buffer messages. These methods allow for programmatically setting float and double fields using field descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_38\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetFloat(Message * message, const FieldDescriptor * field, float value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetDouble(Message * message, const FieldDescriptor * field, double value) const\n```\n\n----------------------------------------\n\nTITLE: Writing 64-bit Varint to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a 64-bit integer as a variable-length encoded value (varint) directly to a target array. Similar to WriteVarint64() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_102\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteVarint64ToArray(uint64 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Truncating RepeatedField in C++\nDESCRIPTION: Resizes the RepeatedField to a new, smaller size. This operation is O(1).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvoid Truncate(int new_size)\n```\n\n----------------------------------------\n\nTITLE: Configuring Unknown Dependencies Handling in DescriptorPool\nDESCRIPTION: Configures the DescriptorPool to allow references to unknown types or files that are not found in the DescriptorPool or its backing DescriptorDatabase.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_125\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::AllowUnknownDependencies()\n```\n\n----------------------------------------\n\nTITLE: Setting Java Outer Classname in Protocol Buffers\nDESCRIPTION: This option specifies the name of the wrapper class that will contain all of the generated classes for the .proto file when java_multiple_files is false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\noption java_outer_classname = \"Foo\";\n```\n\n----------------------------------------\n\nTITLE: Checking Path Coverage in FieldMask for Protocol Buffers C++\nDESCRIPTION: Verifies if a path is covered by a given FieldMask. Parent paths are not covered by explicit child paths.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool FieldMaskUtil::IsPathInFieldMask(\n        StringPiece path,\n        const FieldMask & mask)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Constant Definition\nDESCRIPTION: Specifies the syntax for constants in Protocol Buffers, which can be identifiers, numeric literals, string literals, boolean literals, or message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\nconstant = fullIdent | ( [ \"-\" | \"+\" ] intLit ) | ( [ \"-\" | \"+\" ] floatLit ) |\n                strLit | boolLit | MessageValue\n```\n\n----------------------------------------\n\nTITLE: Listing Parsed Files in C++ GeneratorContext\nDESCRIPTION: The ListParsedFiles method returns a vector of FileDescriptors for all files being compiled in the current run. This is useful for languages that treat files differently when compiled as a set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void ListParsedFiles(std::vector< const FileDescriptor * > * output)\n```\n\n----------------------------------------\n\nTITLE: Generated Accessor Methods for Person.Builder Class\nDESCRIPTION: Sample of generated getter and setter methods for the Person.Builder class. Shows both accessors and mutators for required, optional, and repeated fields with additional methods for building the message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// required string name = 1;\npublic boolean hasName();\npublic String getName();\npublic Builder setName(String value);\npublic Builder clearName();\n\n// required int32 id = 2;\npublic boolean hasId();\npublic int getId();\npublic Builder setId(int value);\npublic Builder clearId();\n\n// optional string email = 3;\npublic boolean hasEmail();\npublic String getEmail();\npublic Builder setEmail(String value);\npublic Builder clearEmail();\n\n// repeated .tutorial.Person.PhoneNumber phones = 4;\npublic List<PhoneNumber> getPhonesList();\npublic int getPhonesCount();\npublic PhoneNumber getPhones(int index);\npublic Builder setPhones(int index, PhoneNumber value);\npublic Builder addPhones(PhoneNumber value);\npublic Builder addAllPhones(Iterable<PhoneNumber> value);\npublic Builder clearPhones();\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Front Matter for Search Results Page\nDESCRIPTION: This YAML snippet defines the front matter for a search results page. It sets the title of the page to 'Search Results' and specifies the layout to be used as 'search'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/search.md#2025-04-11_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: Search Results\nlayout: search\n---\n```\n\n----------------------------------------\n\nTITLE: Defining Package in Protocol Buffer\nDESCRIPTION: Example of how to declare a package in a .proto file, which will correspond to a C++ namespace in the generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiline Strings in C++\nDESCRIPTION: Method to allow string literals to span multiple lines in the Tokenizer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvoid Tokenizer::set_allow_multiline_strings(bool allow)\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to declare a map field in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmap<int32, int32> map_field = 1;\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Lowercase Name in FileDescriptor (C++)\nDESCRIPTION: Similar to FindExtensionByName(), but searches by lowercased-name. See Descriptor::FindFieldByLowercaseName().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_95\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * \n    FileDescriptor::FindExtensionByLowercaseName(\n        ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: FieldComparator Virtual Compare Method Signature\nDESCRIPTION: Defines the virtual Compare method interface for comparing field values between two protocol buffer messages. Takes message objects, field descriptor, indices for repeated fields, and field context as parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvirtual ComparisonResult Compare(\n    const Message& message_1,\n    const Message& message_2,\n    const FieldDescriptor* field,\n    int index_1,\n    int index_2,\n    const util::FieldContext* field_context) = 0\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Message Types in Protocol Buffers\nDESCRIPTION: A Protocol Buffer definition showing how to define a message type nested inside another message, which will generate an inner class in Java.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar { }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding EnumDescriptor values by number in C++\nDESCRIPTION: Looks up an enum value by its number. Returns nullptr if no such value exists. If multiple values have this number, the first one defined is returned.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_56\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor * \n    EnumDescriptor::FindValueByNumber(\n        int number) const\n```\n\n----------------------------------------\n\nTITLE: Enabling Aliasing in CodedOutputStream in C++\nDESCRIPTION: Controls whether the underlying ZeroCopyOutputStream can hold pointers to the original structure instead of copying. This affects the behavior of WriteRawMaybeAliased() and requires the caller to ensure the memory remains valid.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_113\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CodedOutputStream::EnableAliasing(\n        bool enabled)\n```\n\n----------------------------------------\n\nTITLE: Getting Source Location in C++\nDESCRIPTION: Method to retrieve the source location of the complete extent of this service declaration, returning false if location information is not available.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_76\n\nLANGUAGE: C++\nCODE:\n```\nbool GetSourceLocation(SourceLocation * out_location) const\n```\n\n----------------------------------------\n\nTITLE: Configuring Weak Dependencies Enforcement in DescriptorPool\nDESCRIPTION: Configures whether weak imports are allowed to be missing. By default, they are allowed and placeholder empty message fields are used.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_126\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::EnforceWeakDependencies(bool enforce)\n```\n\n----------------------------------------\n\nTITLE: Defining Field Labels and Types in Protocol Buffers\nDESCRIPTION: Specifies the syntax for field labels and types in Protocol Buffers, including scalar types and message/enum references.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_16\n\nLANGUAGE: EBNF\nCODE:\n```\nlabel = [ \"repeated\" ]\ntype = \"double\" | \"float\" | \"int32\" | \"int64\" | \"uint32\" | \"uint64\"\n      | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\"\n      | \"bool\" | \"string\" | \"bytes\" | messageType | enumType\nfieldNumber = intLit;\n```\n\n----------------------------------------\n\nTITLE: Writing Packed SInt64 to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed sint64 values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_53\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteSInt64Packed(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Defining Oneofs in Proto3\nDESCRIPTION: Specifies the syntax for oneof fields in Protocol Buffers, which allow messages to have fields where only one can be set at a time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_20\n\nLANGUAGE: ebnf\nCODE:\n```\noneof = \"oneof\" oneofName \"{\" { option | oneofField } \"}\"\noneofField = type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\n```\n\n----------------------------------------\n\nTITLE: Numeric Literal Disambiguation in Protocol Buffer Text Format\nDESCRIPTION: Examples showing how the text format parser disambiguates between different types of numeric literals based on the longest match principle.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_3\n\nLANGUAGE: textproto\nCODE:\n```\nvalue: 10   # '10' is parsed as a DEC_INT token.\nvalue: 10f  # '10f' is parsed as a FLOAT token, despite containing '10' which\n            # would also match DEC_INT. In this case, FLOAT matches a longer\n            # subsequence of the input.\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Specifies the syntax for oneof fields in Protocol Buffers, which allow a message to have exactly one of the specified fields set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_19\n\nLANGUAGE: EBNF\nCODE:\n```\noneof = \"oneof\" oneofName \"{\" { option | oneofField } \"}\"\noneofField = type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\n```\n\n----------------------------------------\n\nTITLE: Manipulating Group Fields in Protocol Buffers (Python)\nDESCRIPTION: Example demonstrating how to add and access group fields in a Protocol Buffer message. Shows the API for manipulating repeated group fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nresp = SearchResponse()\nresp.searchresult.add(url=\"https://blog.google\")\nassert resp.searchresult[0].url == \"https://blog.google\"\nassert resp.searchresult[0] == SearchResponse.SearchResult(url=\"https://blog.google\")\n```\n\n----------------------------------------\n\nTITLE: Deprecated Total Bytes Limit Setting\nDESCRIPTION: Deprecated macro for the old version of SetTotalBytesLimit that took two parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_DEPRECATED_MSG(\"Please use the single parameter version of SetTotalBytesLimit(). The second parameter is ignored.\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Space Usage of RepeatedField in C++\nDESCRIPTION: Methods to calculate the space used by the RepeatedField, excluding the size of the object itself.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nsize_t SpaceUsedExcludingSelfLong() const\nint SpaceUsedExcludingSelf() const\n```\n\n----------------------------------------\n\nTITLE: Proto Message Type Definition\nDESCRIPTION: Definition of a Band message type that will be used in other message examples.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nmessage Band {}\n```\n\n----------------------------------------\n\nTITLE: Defining FileDescriptorSet Message in Protocol Buffers\nDESCRIPTION: This snippet defines the FileDescriptorSet message, which represents a set of FileDescriptorProto messages. It's used by the protocol compiler to output parsed .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_1\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nmessage FileDescriptorSet {\n  repeated FileDescriptorProto file = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting FieldMask to JSON String in Protocol Buffers C++\nDESCRIPTION: Converts FieldMask to/from string formatted according to proto3 JSON spec. Field names must conform to style conventions (snake_case when converting to string, camelCase when converting from string).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool FieldMaskUtil::ToJsonString(\n        const FieldMask & mask,\n        std::string * out)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Group Field Example (Deprecated)\nDESCRIPTION: Shows an example of a group field declaration in Protocol Buffers, though this feature is deprecated.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\nrepeated group Result = 1 {\n    required string url = 1;\n    optional string title = 2;\n    repeated string snippets = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Protocol Buffer from String - C++\nDESCRIPTION: Method to parse a protocol buffer from a binary string format. Returns true on successful parsing. Takes input in binary wire format, not human-readable text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_ATTRIBUTE_REINITIALIZES bool MessageLite::ParseFromString(ConstStringParam data)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Enum Utility Functions in C++\nDESCRIPTION: These functions provide utility operations for Protocol Buffers enums, including validation, descriptor retrieval, name conversion, and parsing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\nbool FieldDescriptorProto_Type_IsValid(int value)\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst ::protobuf::EnumDescriptor* FieldDescriptorProto_Type_descriptor()\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate const std::string& FieldDescriptorProto_Type_Name(T enum_t_value)\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool FieldDescriptorProto_Type_Parse(::protobuf::ConstStringParam name, FieldDescriptorProto_Type* value)\n```\n\n----------------------------------------\n\nTITLE: Ensuring Space in EpsCopyOutputStream in C++\nDESCRIPTION: Method that ensures there is enough space to safely write kSlopBytes to the specified pointer. Returns a pointer where writing is safe.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_41\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_MUST_USE_RESULT uint8* EnsureSpace(uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Reading Tag in Protocol Buffers\nDESCRIPTION: Reads a tag value using ReadVarint32() and updates the last tag value. Returns zero if ReadVarint32() fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\nuint32 CodedInputStream::ReadTag()\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions in Protocol Buffers\nDESCRIPTION: Specifies the syntax for extension range declarations in Protocol Buffers, which allow third-party extensions to a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_23\n\nLANGUAGE: EBNF\nCODE:\n```\nextensions = \"extensions\" ranges \";\"\nranges = range { \",\" range }\nrange =  intLit [ \"to\" ( intLit | \"max\" ) ]\n```\n\n----------------------------------------\n\nTITLE: Defining Option Targets in Protocol Buffers\nDESCRIPTION: Demonstrates how to use option targets to control which entity types can use specific fields in shared option messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_44\n\nLANGUAGE: proto\nCODE:\n```\nmessage MyOptions {\n  string file_only_option = 1 [targets = TARGET_TYPE_FILE];\n  int32 message_and_enum_option = 2 [targets = TARGET_TYPE_MESSAGE,\n                                     targets = TARGET_TYPE_ENUM];\n}\n\nextend google.protobuf.FileOptions {\n  MyOptions file_options = 50000;\n}\n\nextend google.protobuf.MessageOptions {\n  MyOptions message_options = 50000;\n}\n\nextend google.protobuf.EnumOptions {\n  MyOptions enum_options = 50000;\n}\n\n// OK: this field is allowed on file options\noption (file_options).file_only_option = \"abc\";\n\nmessage MyMessage {\n  // OK: this field is allowed on both message and enum options\n  option (message_options).message_and_enum_option = 42;\n}\n\nenum MyEnum {\n  MY_ENUM_UNSPECIFIED = 0;\n  // Error: file_only_option cannot be set on an enum.\n  option (enum_options).file_only_option = \"xyz\";\n}\n```\n\n----------------------------------------\n\nTITLE: Repeated Field Definition in Proto\nDESCRIPTION: Example of defining a repeated field in a proto file. Repeated fields can contain multiple values of the specified type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nrepeated int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Feature Set in Protocol Buffers\nDESCRIPTION: Example of defining custom features in Protocol Buffers using feature extensions. Shows how to specify feature values, targets, support lifecycle, and edition defaults for a new enum feature.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/implementation.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage foo;\n\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.FeatureSet {\n  MyFeatures features = <extension #>;\n}\n\nmessage MyFeatures {\n  enum FeatureValue {\n    FEATURE_VALUE_UNKNOWN = 0;\n    VALUE1 = 1;\n    VALUE2 = 2;\n  }\n\n  FeatureValue feature_value = 1 [\n    targets = TARGET_TYPE_FIELD,\n    targets = TARGET_TYPE_FILE,\n    feature_support = {\n      edition_introduced: EDITION_2023,\n      edition_deprecated: EDITION_2024,\n      deprecation_warning: \"Feature will be removed in 2025\",\n      edition_removed: EDITION_2025,\n    },\n    edition_defaults = { edition: EDITION_LEGACY, value: \"VALUE1\" },\n    edition_defaults = { edition: EDITION_2024, value: \"VALUE2\" }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Fields with Python Keyword Names\nDESCRIPTION: Example showing a message definition with field names that are Python keywords, which requires special handling in Python code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_42\n\nLANGUAGE: proto\nCODE:\n```\nmessage Baz {\n  optional int32 from = 1\n  repeated int32 in = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Groups Feature in Protocol Buffers\nDESCRIPTION: Demonstrates the deprecated groups feature, which is an alternative way to nest information in message definitions. This example shows a SearchResponse containing a group of Results.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_18\n\nLANGUAGE: proto\nCODE:\n```\nmessage SearchResponse {\n  repeated group Result = 1 {\n    optional string url = 1;\n    optional string title = 2;\n    repeated string snippets = 3;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Allocated Object Addition in RepeatedPtrField\nDESCRIPTION: Method to add pre-allocated objects to RepeatedPtrField with special arena handling for submessages and strings. Strings must be heap-allocated.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_45\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedPtrField::AddAllocated(\n        Element * value)\n```\n\n----------------------------------------\n\nTITLE: Go Struct for Message with Singular Message Field\nDESCRIPTION: Generated Go struct for a Concert message with a Band field. Message fields become pointer types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: go\nCODE:\n```\ntype Concert struct {\n    Headliner *Band\n}\n```\n\n----------------------------------------\n\nTITLE: Oneof, Enum, Service and Method Options in Protocol Buffers\nDESCRIPTION: Defines options for oneof fields, enums, services and methods including deprecation status and custom extensions support.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_13\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage OneofOptions {\n  repeated UninterpretedOption uninterpreted_option = 999;\n  extensions 1000 to max;\n}\n\nmessage EnumOptions {\n  optional bool allow_alias = 2;\n  optional bool deprecated = 3 [default = false];\n  reserved 5;\n  repeated UninterpretedOption uninterpreted_option = 999;\n  extensions 1000 to max;\n}\n\nmessage EnumValueOptions {\n  optional bool deprecated = 1 [default = false];\n  repeated UninterpretedOption uninterpreted_option = 999;\n  extensions 1000 to max;\n}\n\nmessage ServiceOptions {\n  optional bool deprecated = 33 [default = false];\n  repeated UninterpretedOption uninterpreted_option = 999;\n  extensions 1000 to max;\n}\n\nmessage MethodOptions {\n  optional bool deprecated = 33 [default = false];\n}\n```\n\n----------------------------------------\n\nTITLE: TimeUtil Duration Conversion Methods\nDESCRIPTION: Methods for converting between Duration and string formats\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::string ToString(const Duration& duration);\nstatic bool FromString(const std::string& value, Duration* timestamp);\n```\n\n----------------------------------------\n\nTITLE: Setting Java Outer Classname for Proto File\nDESCRIPTION: Example of setting the java_outer_classname option for a .proto file named 'student_record_request.proto'. The classname is derived from the file name in PascalCase with 'Proto' appended.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-proto-names.md#2025-04-11_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\noption java_outer_classname = \"StudentRecordRequestProto\";\n```\n\n----------------------------------------\n\nTITLE: Zero-Copy Input Stream Basic Usage in C++\nDESCRIPTION: Basic example demonstrating the zero-copy approach for reading data, where the stream provides direct access to internal buffers, eliminating unnecessary copying operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconst void* buffer;\nint size;\ninput->Next(&buffer, &size);\nDoSomething(buffer, size);\n```\n\n----------------------------------------\n\nTITLE: Defining Reserved Field Numbers in Protocol Buffers\nDESCRIPTION: Constants defining the range of field numbers reserved for the Protocol Buffer library implementation. Users may not declare fields that use these reserved numbers (19000-19999).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\nconst int FieldDescriptor::kFirstReservedNumber = 19000\nconst int FieldDescriptor::kLastReservedNumber = 19999\n```\n\n----------------------------------------\n\nTITLE: Code Migration Example - After\nDESCRIPTION: Example of Go code after migration to the Opaque API style using accessors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nlogEntry := &logpb.LogEntry{}\nif req.HasIPAddress() {\n    logEntry.SetIPAddress(redactIP(req.GetIPAddress()))\n}\nlogEntry.SetBackendServer(host)\n```\n\n----------------------------------------\n\nTITLE: Reading Tag with Cutoff in Protocol Buffers\nDESCRIPTION: Optimized alternative to ReadTag() when using a manifest constant cutoff. Returns a pair containing the tag and a boolean indicating if the tag is within the cutoff range.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\nstd::pair<uint32, bool> CodedInputStream::ReadTagWithCutoff(uint32 cutoff)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compiler Invocation\nDESCRIPTION: Example command for invoking the protocol buffer compiler to generate both Java and Kotlin code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --java_out=build/gen/java --kotlin_out=build/gen/kotlin src/foo.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Column Number Type for Protocol Buffers\nDESCRIPTION: A typedef that represents column positions in source files where a tab character advances to the next multiple of 8 bytes. Column numbers are zero-based in this representation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ntypedef int ColumnNumber;\n```\n\n----------------------------------------\n\nTITLE: Using Repeated Fields in PHP\nDESCRIPTION: Example of working with repeated fields in PHP Protocol Buffers. Generated code provides methods to add and set elements in the repeated field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: php\nCODE:\n```\n$m->getFoo()[] =1;\n$m->setFoo($array);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Java Package Name from FileDescriptor in C++\nDESCRIPTION: Function to get the Java package name from a FileDescriptor object. Requires that the descriptor parameter is not NULL.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_names.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstd::string java::FileJavaPackage(\n        const FileDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Embedded Message Definition in Protocol Buffer\nDESCRIPTION: Message definition demonstrating embedded message field usage.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nmessage Test3 {\n  Test1 c = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Java Outer Classname in Proto\nDESCRIPTION: Shows how to set the java_outer_classname option to specify the wrapper Java class name for generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_34\n\nLANGUAGE: proto\nCODE:\n```\noption java_outer_classname = \"Ponycopter\";\n```\n\n----------------------------------------\n\nTITLE: Implementing FindAnyType Method in Text Format Finder Class\nDESCRIPTION: Virtual method to find message type for Any proto. Returns NULL if no message is known. Base implementation accepts specific prefixes and searches DescriptorPool of parent message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nvirtual const Descriptor* Finder::FindAnyType(\n    const Message& message,\n    const std::string& prefix,\n    const std::string& name) const\n```\n\n----------------------------------------\n\nTITLE: Go Struct for Message with Map Field\nDESCRIPTION: Generated Go struct for a MerchBooth message with a map field. The field becomes a map with string keys and pointer values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_20\n\nLANGUAGE: go\nCODE:\n```\ntype MerchBooth struct {\n    Items map[string]*MerchItem\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extension Numbers in DescriptorDatabase (C++)\nDESCRIPTION: Virtual method that finds all tag numbers used by known extensions of a specified type. Returns true if search was successful, false otherwise. Has a default implementation that always returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool DescriptorDatabase::FindAllExtensionNumbers(\n        const std::string & ,\n        std::vector< int > * )\n```\n\n----------------------------------------\n\nTITLE: Duration String Conversion in C++\nDESCRIPTION: Converts Duration to/from string format with 3, 6, or 9 fractional digits. Supports range from -315,576,000,000 to +315,576,000,000 seconds.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::string TimeUtil::ToString(const Duration & duration)\n```\n\n----------------------------------------\n\nTITLE: Defining CodeGeneratorRequest and CodeGeneratorResponse in Protocol Buffers\nDESCRIPTION: Reference to the protocol buffer definitions for CodeGeneratorRequest and CodeGeneratorResponse used in protoc plugins. These message types are defined in the plugin.proto file and are used for communication between protoc and language-specific plugins.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/other.md#2025-04-11_snippet_0\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nCodeGeneratorRequest\nCodeGeneratorResponse\n```\n\n----------------------------------------\n\nTITLE: Swapping Specific Fields Between Messages in C++\nDESCRIPTION: Swaps fields listed in the fields vector between two messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nvoid SwapFields(Message* message1, Message* message2, const std::vector<const FieldDescriptor*>& fields) const\n```\n\n----------------------------------------\n\nTITLE: Enforcing Weak Dependencies in Protocol Buffers (C++)\nDESCRIPTION: Controls how weak imports are handled. By default, weak imports can be missing, but calling this method with true will cause the DescriptorPool to report an import not found error.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_142\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::EnforceWeakDependencies(\n        bool enforce)\n```\n\n----------------------------------------\n\nTITLE: Defining TextFormat::Finder Class in C++\nDESCRIPTION: Declares the Finder class within the TextFormat namespace, which provides an interface for finding extensions and types in Any messages. It includes methods for finding extensions by name and number, as well as finding Any types and extension factories.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nclass TextFormat::Finder {\npublic:\n  virtual ~Finder();\n  virtual const FieldDescriptor * FindExtension(Message * message, const std::string & name) const;\n  virtual const FieldDescriptor * FindExtensionByNumber(const Descriptor * descriptor, int number) const;\n  virtual const Descriptor * FindAnyType(const Message & message, const std::string & prefix, const std::string & name) const;\n  virtual MessageFactory * FindExtensionFactory(const FieldDescriptor * field) const;\n};\n```\n\n----------------------------------------\n\nTITLE: Proto2 Extend Definition\nDESCRIPTION: Defines the syntax for extend declarations in Protocol Buffers, which add fields to existing messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_34\n\nLANGUAGE: ebnf\nCODE:\n```\nextend = \"extend\" messageType \"{\" {field | group} \"}\"\n```\n\n----------------------------------------\n\nTITLE: Nesting Message Definitions in Protocol Buffers\nDESCRIPTION: Demonstrates when to nest message definitions and when to keep them at the top level. PhotoMetadata is kept outside to enable reuse, while FooConfiguration.Rule is nested to discourage inappropriate coupling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmessage Photo {\n  // Bad: It's likely PhotoMetadata will be reused outside the scope of Photo,\n  // so it's probably a good idea not to nest it and make it easier to access.\n  message PhotoMetadata {\n    optional int32 width = 1;\n    optional int32 height = 2;\n  }\n  optional PhotoMetadata metadata = 1;\n}\n\nmessage FooConfiguration {\n  // Good: Reusing FooConfiguration.Rule outside the scope of FooConfiguration\n  // tightly-couples it with likely unrelated components, nesting it dissuades\n  // from doing that.\n  message Rule {\n    optional float multiplier = 1;\n  }\n  repeated Rule rules = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Field C Type Options Enumeration\nDESCRIPTION: Defines C type options for protocol buffer fields, specifying string representation variants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_35\n\nLANGUAGE: protobuf\nCODE:\n```\nenum protobuf::FieldOptions_CType {\n  FieldOptions_CType_STRING = 0,\n  FieldOptions_CType_CORD = 1,\n  FieldOptions_CType_STRING_PIECE = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing a Protocol Buffer Message to a File in C#\nDESCRIPTION: Demonstrates how to serialize a Protocol Buffer message to a file using the WriteTo extension method from MessageExtensions. Requires the Google.Protobuf namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nusing Google.Protobuf;\n...\nPerson john = ...; // Code as before\nusing (var output = File.Create(\"john.dat\"))\n{\n    john.WriteTo(output);\n}\n```\n\n----------------------------------------\n\nTITLE: Get file namespace for C# code generation in Protocol Buffers\nDESCRIPTION: Returns the namespace to use for a given file descriptor in C# code generation. Requires that the descriptor is not null.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.csharp_names.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstd::string csharp::GetFileNamespace(\n        const FileDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Accessing Repeated Field Methods in Protocol Buffers C++ API\nDESCRIPTION: This snippet shows the method signatures for accessing elements of repeated fields in Protocol Buffers messages. These methods allow retrieving values from a specific index in a repeated field, supporting various data types including bool, string, enum, and message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_43\n\nLANGUAGE: C++\nCODE:\n```\nbool GetRepeatedBool(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nstd::string GetRepeatedString(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor * GetRepeatedEnum(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nint GetRepeatedEnumValue(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst Message & GetRepeatedMessage(const Message & message, const FieldDescriptor * field, int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string & GetRepeatedStringReference(const Message & message, const FieldDescriptor * field, int index, std::string * scratch) const\n```\n\n----------------------------------------\n\nTITLE: Handling Any Type in C++\nDESCRIPTION: Demonstrates how to pack and unpack Any values in C++ using PackFrom() and UnpackTo() methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\n// Storing an arbitrary message type in Any.\nNetworkErrorDetails details = ...;\nErrorStatus status;\nstatus.add_details()->PackFrom(details);\n\n// Reading an arbitrary message from Any.\nErrorStatus status = ...;\nfor (const google::protobuf::Any& detail : status.details()) {\n  if (detail.Is<NetworkErrorDetails>()) {\n    NetworkErrorDetails network_error;\n    detail.UnpackTo(&network_error);\n    ... processing network_error ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Fraction and Margin for Float Comparisons in SimpleFieldComparator (C++)\nDESCRIPTION: Method to set the default fraction and margin for float comparisons of all float and double fields, unless a specific setting is provided. Requires the float comparison mode to be set to APPROXIMATE.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid SimpleFieldComparator::SetDefaultFractionAndMargin(\n    double fraction,\n    double margin)\n```\n\n----------------------------------------\n\nTITLE: Go Structs for Message with Oneof Field\nDESCRIPTION: Generated Go structs for a Profile message with a oneof field. The compiler generates wrapper structs for each oneof option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_22\n\nLANGUAGE: go\nCODE:\n```\ntype Profile struct {\n    // Types that are valid to be assigned to Avatar:\n    //  *Profile_ImageUrl\n    //  *Profile_ImageData\n    Avatar isProfile_Avatar `protobuf_oneof:\"avatar\"`\n}\n\ntype Profile_ImageUrl struct {\n        ImageUrl string\n}\ntype Profile_ImageData struct {\n        ImageData []byte\n}\n```\n\n----------------------------------------\n\nTITLE: GzipOutputStream Format Enumeration\nDESCRIPTION: Defines the compression format options for GzipOutputStream - GZIP for full GZIP format with file attributes, or ZLIB for simpler compression format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nenum GzipOutputStream::Format {\n  GZIP = 1,\n  ZLIB = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Operators and Methods for RepeatedPtrField in Protocol Buffers\nDESCRIPTION: Various operators and methods for the RepeatedPtrField class, including assignment operators, element access methods, and container operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_37\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedPtrField & operator=(const RepeatedPtrField & other)\n```\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedPtrField & operator=(RepeatedPtrField && other)\n```\n\nLANGUAGE: C++\nCODE:\n```\nbool empty() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nint size() const\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst Element & Get(int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nElement * Mutable(int index)\n```\n\nLANGUAGE: C++\nCODE:\n```\nElement * Add()\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid Add(Element && value)\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate void Add(Iter begin, Iter end)\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst Element & operator[](int index) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nElement & operator[](int index)\n```\n\nLANGUAGE: C++\nCODE:\n```\nconst Element & at(int index) const\n```\n\n----------------------------------------\n\nTITLE: Configuring TOML Frontmatter for Java Protobuf Documentation\nDESCRIPTION: TOML frontmatter configuration block that defines metadata for a documentation page about Java Protocol Buffers. Sets the page title, weight for ordering, link title, description and content type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"Java Reference\"\nweight = 640\nlinkTitle = \"Java\"\ndescription = \"Reference documentation for working with protocol buffer classes in Java.\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum Oneof Field in Protocol Buffers\nDESCRIPTION: Example of defining an enum field within a oneof construct. The field uses the previously defined Bar enum type and has field number 1.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\noneof example_name {\n    Bar bar = 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating DescriptorPool with Underlay in Protocol Buffers (C++)\nDESCRIPTION: Creates a DescriptorPool overlaid on top of another pool. When searching for a descriptor, if not found in the overlay, the underlay will be searched as a backup. This allows cross-linking with the underlay's descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_143\n\nLANGUAGE: C++\nCODE:\n```\nexplicit DescriptorPool::DescriptorPool(\n        const DescriptorPool * underlay)\n```\n\n----------------------------------------\n\nTITLE: ConcatenatingInputStream Skip Method Implementation\nDESCRIPTION: Virtual method that skips a specified number of bytes in the input stream. Returns false if end of stream is reached or on input error.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool ConcatenatingInputStream::Skip(\n        int count)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Extension Definition (Proto2 Only)\nDESCRIPTION: Example of defining extension fields for a message type with an extension range in proto2.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_31\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 100 to 199;\n}\n\nextend Foo {\n  optional int32 foo = 101;\n  repeated int32 repeated_foo = 102;\n}\n\nmessage Bar {\n  extend Foo {\n    optional int32 bar = 103;\n    repeated int32 repeated_bar = 104;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Message Definition in Proto\nDESCRIPTION: Simple message declaration in protocol buffer syntax that will generate a corresponding Objective-C class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: GzipInputStream Format Enumeration in C++\nDESCRIPTION: Defines the format enumeration used to specify the compression format for GzipInputStream. Options include AUTO for automatic detection, GZIP for GZIP streams with extra header data, and ZLIB for simpler zlib stream format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nenum GzipInputStream::Format {\n  AUTO = = 0,\n  GZIP = = 1,\n  ZLIB = = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating Singular Fields in Proto3\nDESCRIPTION: Shows how to work with singular fields in proto3, which differs from proto2 in how unset fields are handled. In proto3, fields always have a default value and HasField() is not used for primitive fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nmessage.foo = 123\nprint(message.foo)\n```\n\nLANGUAGE: python\nCODE:\n```\nmessage.foo = 123\nmessage.ClearField(\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Replacing Deprecated Python UnknownFields() Method\nDESCRIPTION: In Protocol Buffers v25, the message.UnknownFields() method will be deprecated in pure Python and C++ extensions, to be removed in v26. Users should switch to the new UnknownFieldSet(message) function in unknown_fields.py as a replacement.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v25.md#2025-04-11_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Deprecated method (will be removed in v26)\nmessage.UnknownFields()\n\n# New recommended method\nfrom google.protobuf.unknown_fields import UnknownFieldSet\nUnknownFieldSet(message)\n```\n\n----------------------------------------\n\nTITLE: Oneof Definition in Proto\nDESCRIPTION: Example of defining a oneof field in a proto file. Oneof allows you to specify that a message can have one of several possible fields, but only one can be set at a time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: proto\nCODE:\n```\nmessage TestMessage {\n  oneof test_oneof {\n    int32 oneof_int32 = 1;\n    int64 oneof_int64 = 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Enum Values in Protocol Buffers\nDESCRIPTION: Shows how to override the default value for an enum field using the 'default' field option. This changes the value that will be used when the field is not explicitly set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\n  Corpus corpus = 4 [default = CORPUS_UNIVERSAL];\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Package Namespaces\nDESCRIPTION: Core namespace declarations for Protocol Buffers implementation in C++, including main package modules for base functionality, I/O operations, utilities, and compiler implementation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ngoogle::protobuf\ngoogle::protobuf::io\ngoogle::protobuf::util\ngoogle::protobuf::compiler\n```\n\n----------------------------------------\n\nTITLE: Setting Oneof Fields in Go\nDESCRIPTION: Examples showing how to set oneof fields in Go. Each case requires using the appropriate wrapper struct.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_23\n\nLANGUAGE: go\nCODE:\n```\np1 := &account.Profile{\n  Avatar: &account.Profile_ImageUrl{ImageUrl: \"http://example.com/image.png\"},\n}\n\n// imageData is []byte\nimageData := getImageData()\np2 := &account.Profile{\n  Avatar: &account.Profile_ImageData{ImageData: imageData},\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Format Helper Function (C++)\nDESCRIPTION: Helper function for formatting text using named variables from a lookup map and directly supplied arguments. Meant to be used through compiler::cpp::Formatter.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::FormatInternal(\n        const std::vector< std::string > & args,\n        const std::map< std::string, std::string > & vars,\n        const char * format)\n```\n\n----------------------------------------\n\nTITLE: Accessing Mutable Data in RepeatedField in C++\nDESCRIPTION: Gets the underlying mutable array of the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nElement * mutable_data()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lexical Scoping in Protobuf Editions\nDESCRIPTION: This snippet demonstrates lexical scoping in Protobuf Editions. It shows how features can be set at different levels (file, field, enum) and how they can be overridden.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/overview.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\noption features.enum_type = CLOSED;\n\nmessage Person {\n  string name = 1;\n  int32 id = 2 [features.field_presence = IMPLICIT];\n\n  enum Pay_Type {\n    PAY_TYPE_UNSPECIFIED = 1;\n    PAY_TYPE_SALARY = 2;\n    PAY_TYPE_HOURLY = 3;\n  }\n\n  enum Employment {\n    option features.enum_type = OPEN;\n    EMPLOYMENT_UNSPECIFIED = 0;\n    EMPLOYMENT_FULLTIME = 1;\n    EMPLOYMENT_PARTTIME = 2;\n  }\n  Employment employment = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Symbol in DescriptorPool (C++)\nDESCRIPTION: Finds the FileDescriptor in the pool that defines the given symbol. Returns the FileDescriptor that contains the specified symbol.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_106\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * FindFileContainingSymbol(ConstStringParam symbol_name) const\n```\n\n----------------------------------------\n\nTITLE: Comparing Messages Using MessageDifferencer in SimpleFieldComparator in C++\nDESCRIPTION: The CompareWithDifferencer method allows comparison of messages using a provided MessageDifferencer instance. This can be used by subclasses to compare specific fields in a custom way while maintaining the same context.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nprotected bool SimpleFieldComparator::CompareWithDifferencer(\n    MessageDifferencer* differencer,\n    const Message& message1,\n    const Message& message2,\n    const util::FieldContext* field_context)\n```\n\n----------------------------------------\n\nTITLE: Field Descriptor Utility Methods in Protocol Buffers C++\nDESCRIPTION: Utility methods for working with field descriptors including options access, debug string generation, and proto copying functionality.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\noptions() const\nCopyTo(FieldDescriptorProto* proto) const\nDebugString() const\nDebugStringWithOptions()\n```\n\n----------------------------------------\n\nTITLE: Defining Options in Protocol Buffers\nDESCRIPTION: Specifies the syntax for options in Protocol Buffers, which can be used to customize file, message, enum, and service declarations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_14\n\nLANGUAGE: EBNF\nCODE:\n```\noption = \"option\" optionName  \"=\" constant \";\"\noptionName = ( ident | \"(\" [\".\" ] fullIdent \")\" )\n```\n\n----------------------------------------\n\nTITLE: Package Declaration Example in Protocol Buffers\nDESCRIPTION: Demonstrates the use of a package declaration to specify the namespace for message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Edition Declaration Syntax\nDESCRIPTION: Demonstrates the syntax change from using 'syntax' keyword in proto2/proto3 to using 'edition' keyword in newer versions of Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/overview.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\nsyntax = \"proto3\";\nedition = \"2028\";\n```\n\n----------------------------------------\n\nTITLE: Proto2 Service Example\nDESCRIPTION: Shows an example of a service declaration in Protocol Buffers defining an RPC method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_37\n\nLANGUAGE: proto\nCODE:\n```\nservice SearchService {\n  rpc Search (SearchRequest) returns (SearchResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Writing 32-bit little-endian integer in CodedOutputStream\nDESCRIPTION: Writes a 32-bit integer in little-endian byte order to the stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_78\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteLittleEndian32(uint32 value)\n```\n\n----------------------------------------\n\nTITLE: Working with Map Fields in Protocol Buffers (Python)\nDESCRIPTION: Demonstrates the Python API for Protocol Buffer map fields, which behaves like a Python dictionary. Shows operations like assignment, reading, iteration, and deletion.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# Assign value to map\nm.mapfield[5] = 10\n\n# Read value from map\nm.mapfield[5]\n\n# Iterate over map keys\nfor key in m.mapfield:\n  print(key)\n  print(m.mapfield[key])\n\n# Test whether key is in map:\nif 5 in m.mapfield:\n  print(\"Found!\")\n\n# Delete key from map.\ndel m.mapfield[key]\n```\n\n----------------------------------------\n\nTITLE: Handling Field Deprecation in Protocol Buffers\nDESCRIPTION: Illustrates how preemptively grouping fields can simplify deprecation paths when replacing fields with more structured alternatives. Shows deprecating a simple price field in favor of a more complete currency_amount field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  // DEPRECATED! Use currency_amount.\n  optional int price [deprecated = true];\n\n  // The price and currency of this Foo.\n  optional google.type.Money currency_amount;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Map Field Equivalent in Protocol Buffers\nDESCRIPTION: Shows the wire format equivalent of map syntax in Protocol Buffers, which enables backward compatibility with implementations that don't support maps directly.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_36\n\nLANGUAGE: proto\nCODE:\n```\nmessage MapFieldEntry {\n  optional key_type key = 1;\n  optional value_type value = 2;\n}\n\nrepeated MapFieldEntry map_field = N;\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Message Structure\nDESCRIPTION: Example .proto file defining a TestMessage with optional integer and nested message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-20.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\n\npackage pkg;\n\nmessage TestMessage {\n  optional int32 i32 = 1;\n  optional TestMessage msg = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Extension in Proto2\nDESCRIPTION: Demonstrates how to define an extension in a .proto file using Proto2 syntax. This extension adds an optional integer field 'promo_id' to the Concert message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_31\n\nLANGUAGE: proto\nCODE:\n```\nextend Concert {\n  optional int32 promo_id = 123;\n}\n```\n\n----------------------------------------\n\nTITLE: AnnotationCollector::AddAnnotation Virtual Method Declaration in C++\nDESCRIPTION: Declaration of the virtual method that records source code annotations with file path and position information.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void AddAnnotation(size_t begin_offset, size_t end_offset, const std::string & file_path, const std::vector<int> & path) = 0\n```\n\n----------------------------------------\n\nTITLE: Resizing RepeatedField in C++\nDESCRIPTION: Resizes the RepeatedField to a new size, filling new elements with the provided value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nvoid Resize(int new_size, const Element & value)\n```\n\n----------------------------------------\n\nTITLE: Generating Edition Defaults with protoc CLI\nDESCRIPTION: Command-line example for invoking protoc directly to generate edition defaults data outside of Bazel. It specifies output file path and edition range parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/implementation.md#2025-04-11_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --edition_defaults_out=defaults.binpb --edition_defaults_minimum=PROTO2 --edition_defaults_maximum=2023 <feature files...>\n```\n\n----------------------------------------\n\nTITLE: Initializing Printer with Output Stream\nDESCRIPTION: Constructor for creating a Printer instance that writes to a ZeroCopyOutputStream with specified variable delimiter.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nPrinter(ZeroCopyOutputStream* output, char variable_delimiter)\n```\n\n----------------------------------------\n\nTITLE: Converting FieldMask to Canonical Form in Protocol Buffers C++\nDESCRIPTION: Converts a FieldMask to canonical form by removing redundant paths and sorting alphabetically.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nstatic void FieldMaskUtil::ToCanonicalForm(\n        const FieldMask & mask,\n        FieldMask * out)\n```\n\n----------------------------------------\n\nTITLE: Arena Message Creation Functions\nDESCRIPTION: Template functions for creating Protocol Buffer message types in an Arena memory allocator\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_NAMESPACE_CLOSE PROTOBUF_NAMESPACE_OPEN protobuf::DescriptorProto* Arena::CreateMaybeMessage< protobuf::DescriptorProto >(Arena*);\nprotobuf::DescriptorProto_ExtensionRange* Arena::CreateMaybeMessage< protobuf::DescriptorProto_ExtensionRange >(Arena*);\nprotobuf::DescriptorProto_ReservedRange* Arena::CreateMaybeMessage< protobuf::DescriptorProto_ReservedRange >(Arena*);\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Statements in Protocol Buffers\nDESCRIPTION: Specifies the syntax for empty statements in Protocol Buffers, which consist of just a semicolon.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_7\n\nLANGUAGE: EBNF\nCODE:\n```\nemptyStatement = \";\"\n```\n\n----------------------------------------\n\nTITLE: Disabling Generic Services\nDESCRIPTION: Example of disabling generic service generation for multiple languages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_37\n\nLANGUAGE: proto\nCODE:\n```\n// This file relies on plugins to generate service code.\noption cc_generic_services = false;\noption java_generic_services = false;\noption py_generic_services = false;\n```\n\n----------------------------------------\n\nTITLE: Extracting Elements from RepeatedField in C++\nDESCRIPTION: Extracts a range of elements from the repeated field. Copies elements to the target array if provided. Warning: Implementation moves subsequent elements which can cause quadratic complexity in loops.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedField::ExtractSubrange(\n        int start,\n        int num,\n        Element* elements)\n```\n\n----------------------------------------\n\nTITLE: Implementing hashCode Function for DslMap in Protocol Buffers Kotlin\nDESCRIPTION: This code snippet shows the declaration of the hashCode function for the DslMap class. It overrides the standard hashCode method and returns an Integer value representing the hash code for a DslMap instance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/hash-code.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun hashCode(): Int\n```\n\n----------------------------------------\n\nTITLE: Expecting specific tag in CodedInputStream in C++\nDESCRIPTION: Checks if the next tag in the input stream matches the expected value. Usually returns true if calling ReadVarint32() now would produce the given value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nbool ExpectTag(uint32 expected)\n```\n\n----------------------------------------\n\nTITLE: Extracting Element Subrange from Arena-based RepeatedPtrField\nDESCRIPTION: Similar to ExtractSubrange but for arena-based RepeatedPtrField. Does not perform object copies and returns raw object pointers. The returned objects must not be freed as they are arena-allocated.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_50\n\nLANGUAGE: cpp\nCODE:\n```\nvoid RepeatedPtrField::UnsafeArenaExtractSubrange(\n        int start,\n        int num,\n        Element ** elements)\n```\n\n----------------------------------------\n\nTITLE: Unsafe Arena Release Message in Protocol Buffers C++\nDESCRIPTION: Similar to ReleaseMessage, but omits all internal safety and ownership checks. This method should only be used when the objects are on the same arena or paired with a call to UnsafeArenaSetAllocatedMessage.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_61\n\nLANGUAGE: C++\nCODE:\n```\nMessage* Reflection::UnsafeArenaReleaseMessage(\n    Message* message,\n    const FieldDescriptor* field,\n    MessageFactory* factory = nullptr) const\n```\n\n----------------------------------------\n\nTITLE: Message Creation Behavior in Protocol Buffer Maps (Python)\nDESCRIPTION: Shows how submessages are automatically created in maps even when no values are assigned to their fields, which differs from regular embedded message fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> m.message_map[10]\n<test_pb2.M2 object at 0x7fb022af28c0>\n>>> dict(m.message_map)\n{10: <test_pb2.M2 object at 0x7fb022af28c0>}\n```\n\n----------------------------------------\n\nTITLE: Adding Comments to Protocol Buffer Definitions\nDESCRIPTION: Illustrates best practices for adding comments to .proto files, including line-end style comments and multi-line C-style comments. Comments are used to provide context and explanations for message types and fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\n/**\n * SearchRequest represents a search query, with pagination options to\n * indicate which results to include in the response.\n */\nmessage SearchRequest {\n  string query = 1;\n\n  // Which page number do we want?\n  int32 page_number = 2;\n\n  // Number of results to return per page.\n  int32 results_per_page = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: New Serialized Proto Ruby Code Generation\nDESCRIPTION: New implementation using serialized descriptor format instead of DSL, providing better conformance and complete information preservation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-20.md#2025-04-11_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# frozen_string_literal: true\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: test.proto\n\nrequire 'google/protobuf'\n\ndescriptor_data = \"\\n\\ntest.proto\\x12\\x03pkg\\\"S\\n\\x0bTestMessage\\x12\\x10\\n\\x03i32\\x18\\x01 \\x01(\\x05H\\x00\\x88\\x01\\x01\\x12\\\"\\n\\x03msg\\x18\\x02 \\x01(\\x0b2\\x10.pkg.TestMessageH\\x01\\x88\\x01\\x01B\\x06\\n\\x04_i32B\\x06\\n\\x04_msgb\\x06proto3\"\nbegin\n  Google::Protobuf::DescriptorPool.generated_pool.add_serialized_file(descriptor_data)\nrescue TypeError => e\n  # <compatibility code, see below>\nend\n\nmodule Pkg\n  TestMessage = ::Google::Protobuf::DescriptorPool.generated_pool.lookup(\"pkg.TestMessage\").msgclass\nend\n```\n\n----------------------------------------\n\nTITLE: Compiling Protocol Buffers with Source Relative Paths\nDESCRIPTION: Example of compiling protocol buffer files with source-relative path options, demonstrating how to specify input and output directories.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --go_out=out --go_opt=paths=source_relative foo.proto bar/baz.proto\n```\n\n----------------------------------------\n\nTITLE: AnnotationProtoCollector Constructor Declaration in C++\nDESCRIPTION: Declaration of the constructor for AnnotationProtoCollector that takes a protocol buffer to which annotations will be added.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nexplicit AnnotationProtoCollector(AnnotationProto * annotation_proto)\n```\n\n----------------------------------------\n\nTITLE: Memory Reservation in RepeatedPtrField\nDESCRIPTION: Method to pre-allocate space in RepeatedPtrField. Only resizes pointer array without allocating objects. Array size is at least doubled when grown.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_43\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedPtrField::Reserve(\n        int new_size)\n```\n\n----------------------------------------\n\nTITLE: Printing Text with Variable Substitution (C++)\nDESCRIPTION: Prints text after applying variable substitutions from a provided map. Variables in text are identified by delimiter characters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::Print(\n        const std::map< std::string, std::string > & variables,\n        const char * text)\n```\n\n----------------------------------------\n\nTITLE: Writing Raw Data to Array in Protocol Buffers\nDESCRIPTION: Static method that writes raw bytes directly to a target array. Similar to WriteRaw() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_95\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteRawToArray(const void * buffer, int size, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Timestamp/time_t Conversion in C++\nDESCRIPTION: Converts between Timestamp and time_t formats. Handles precision differences with truncation to nearest representable value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nstatic Timestamp TimeUtil::TimeTToTimestamp(time_t value)\nstatic time_t TimeUtil::TimestampToTimeT(const Timestamp & value)\n```\n\n----------------------------------------\n\nTITLE: Go Maps for Enum Value String Representations\nDESCRIPTION: Generated Go maps for converting between enum integer values and their string representations, useful for serialization and debugging.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_30\n\nLANGUAGE: go\nCODE:\n```\nvar Genre_name = map[int32]string{\n    0: \"GENRE_UNSPECIFIED\",\n    1: \"GENRE_ROCK\",\n    2: \"GENRE_INDIE\",\n    3: \"GENRE_DRUM_AND_BASS\",\n}\nvar Genre_value = map[string]int32{\n    \"GENRE_UNSPECIFIED\":   0,\n    \"GENRE_ROCK\":          1,\n    \"GENRE_INDIE\":         2,\n    \"GENRE_DRUM_AND_BASS\": 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define oneof fields in a Protocol Buffers message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nmessage OneofExample {\n  message MessageWithOneof {\n    optional string not_part_of_oneof = 1;\n    oneof Example {\n      string first_oneof_field = 2;\n      string second_oneof_field = 3;\n    }\n  }\n  repeated MessageWithOneof message = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Message Example in Protocol Buffers\nDESCRIPTION: Demonstrates the definition of a message in Protocol Buffers with nested message types, options, maps, and extension ranges.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_30\n\nLANGUAGE: proto\nCODE:\n```\nmessage Outer {\n  option (my_option).a = true;\n  message Inner {   // Level 2\n    required int64 ival = 1;\n  }\n  map<int32, string> my_map = 2;\n  extensions 20 to 30;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FloatComparison Enum in SimpleFieldComparator Class (C++)\nDESCRIPTION: Defines an enumeration for float comparison methods within the SimpleFieldComparator class. It includes EXACT for exact comparison and APPROXIMATE for using MathUtil methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nenum SimpleFieldComparator::FloatComparison {\n  EXACT,\n  APPROXIMATE\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Message Fields in Objective-C\nDESCRIPTION: Demonstrates how to access and set nested message fields in Objective-C implementation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: objc\nCODE:\n```\nFoo *foo = [[Foo alloc] init];\nfoo.a.b = 2;\n```\n\n----------------------------------------\n\nTITLE: Writing Raw Data with Potential Aliasing in C++\nDESCRIPTION: Writes buffer data to the stream, possibly by aliasing the buffer instead of copying. The caller is responsible for ensuring the buffer remains valid for the duration of the ZeroCopyOutputStream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_63\n\nLANGUAGE: C++\nCODE:\n```\nuint8 * EpsCopyOutputStream::WriteRawMaybeAliased(\n        const void * data,\n        int size,\n        uint8 * ptr)\n```\n\n----------------------------------------\n\nTITLE: JSON Formatter Option Changes - Code Migration Examples\nDESCRIPTION: Examples showing the migration path for JSON formatter options across different language implementations. The changes affect how default-valued fields are handled for proto2 and proto3 optional fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v26.md#2025-04-11_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n// Old way\nincludingDefaultValueFields()\n\n// New way\nalwaysPrintFieldsWithNoPresence()\n```\n\nLANGUAGE: C++\nCODE:\n```\n// Old way\nalways_print_default_values\n\n// New way\nalways_print_fields_with_no_presence=True\n```\n\nLANGUAGE: Python\nCODE:\n```\n# Old way\nincluding_default_value_fields=True\n\n# New way\nalways_print_fields_with_no_presence=True\n```\n\n----------------------------------------\n\nTITLE: PHP Class Generated with Oneof Field\nDESCRIPTION: Example of PHP class generated from a message with a oneof field. The compiler generates accessor methods for each field and a special method to determine which field is set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: php\nCODE:\n```\nclass TestMessage {\n  private oneof_int32;\n  private oneof_int64;\n  public function getOneofInt32();\n  public function setOneofInt32($var);\n  public function getOneofInt64();\n  public function setOneofInt64($var);\n  public function getTestOneof();  // Return field name\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Aliases in Protocol Buffers\nDESCRIPTION: Shows how to define multiple enum constants with the same value (aliases) using the allow_alias option. When multiple constants share a value, the first one is returned by Name().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_37\n\nLANGUAGE: proto\nCODE:\n```\nenum SomeEnum {\n    option allow_alias = true;\n    VALUE_A = 0;\n    VALUE_B = 5;\n    VALUE_C = 1234;\n    VALUE_B_ALIAS = 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Proto File with Custom PHP Namespace Options\nDESCRIPTION: Example showing how to use PHP-specific options in a proto file to customize namespace generation. The php_namespace option overrides the default namespace, and php_metadata_namespace sets the metadata class namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\noption php_namespace = \"baz\\\\qux\";\noption php_metadata_namespace = \"Foo\";\nmessage MyMessage {}\n```\n\n----------------------------------------\n\nTITLE: Setting deterministic serialization in CodedOutputStream\nDESCRIPTION: Indicates to the serializer whether the user wants deterministic serialization, which ensures consistent binary output across different runs.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_86\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetSerializationDeterministic(bool value)\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Name in Protocol Buffers\nDESCRIPTION: Starting with v24, the json_name field option validation will reject embedded null characters (\\u0000) while accepting all other valid Unicode characters. Null values remain allowed in field values but are prohibited in json_name specifications.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-28.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\njson_name\n```\n\n----------------------------------------\n\nTITLE: Using Builders to Construct Messages in Go\nDESCRIPTION: Shows how to use builders to construct and initialize Protocol Buffer messages in Go, which is useful for nested messages and unit tests.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nconcert := Concert_builder{\n  SupportActs: []*Band{\n    {}, // First element.\n    {}, // Second element.\n  },\n}.Build()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Protocol Compiler in C++\nDESCRIPTION: Example of creating a custom protocol compiler that includes support for both C++ and a custom output format called 'Foo'. This demonstrates initializing the CommandLineInterface and registering generators.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint main(int argc, char* argv[]) {\n  google::protobuf::compiler::CommandLineInterface cli;\n\n  // Support generation of C++ source and headers.\n  google::protobuf::compiler::cpp::CppGenerator cpp_generator;\n  cli.RegisterGenerator(\"--cpp_out\", &cpp_generator,\n    \"Generate C++ source and header.\");\n\n  // Support generation of Foo code.\n  FooGenerator foo_generator;\n  cli.RegisterGenerator(\"--foo_out\", &foo_generator,\n    \"Generate Foo file.\");\n\n  return cli.Run(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Releasing Last Element in RepeatedPtrField\nDESCRIPTION: Removes the last element from a RepeatedPtrField and returns it, transferring ownership to the caller. Requires size() > 0. When used with an arena, performs an object copy to maintain ownership semantics.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_46\n\nLANGUAGE: cpp\nCODE:\n```\nPROTOBUF_FUTURE_MUST_USE_RESULT Element * \n    RepeatedPtrField::ReleaseLast()\n```\n\n----------------------------------------\n\nTITLE: AnnotationCollector::AddAnnotationNew Virtual Method Declaration in C++\nDESCRIPTION: Declaration of the virtual method for adding a new annotation using the Annotation object directly.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void AddAnnotationNew(Annotation & )\n```\n\n----------------------------------------\n\nTITLE: Writing 32-bit Varint Out-of-Line to Array in Protocol Buffers\nDESCRIPTION: Static method similar to WriteVarint32ToArray but with less common-case paths being implemented out-of-line rather than inlined, which can improve code size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_101\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteVarint32ToArrayOutOfLine(uint32 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Advancing to Next Token in C++\nDESCRIPTION: Method to advance the Tokenizer to the next token. Returns false if the end of the input is reached.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nbool Tokenizer::Next()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Arena for Arena-Capable Message (C++)\nDESCRIPTION: Retrieves the arena associated with a value if it's an arena-capable message, or NULL otherwise. Can often be resolved at compile time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\ntemplate static Arena * Arena::GetArena(\n        const T * value)\n```\n\n----------------------------------------\n\nTITLE: Declaring ZeroCopyInputStream Class in C++\nDESCRIPTION: Abstract class declaration for ZeroCopyInputStream, which provides methods for reading from a stream with minimal copying.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nclass ZeroCopyInputStream {\npublic:\n  ZeroCopyInputStream();\n  virtual ~ZeroCopyInputStream();\n  virtual bool Next(const void** data, int* size) = 0;\n  virtual void BackUp(int count) = 0;\n  virtual bool Skip(int count) = 0;\n  virtual int64_t ByteCount() const = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Source Retention on Message Fields\nDESCRIPTION: Shows how to configure source retention on a field within a message that will be used as an option. The retention setting only takes effect when the field appears inside an option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_35\n\nLANGUAGE: proto\nCODE:\n```\nmessage OptionsMessage {\n  int32 source_retention_field = 1 [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Binary to JSON Stream Conversion Function (C++)\nDESCRIPTION: Converts protobuf binary data to JSON format using a TypeResolver. Takes input/output streams and JSON print options. Will fail if TypeResolver cannot resolve types or if input is invalid protobuf wire format. Unknown fields are silently discarded.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.json_util.md#2025-04-11_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nutil::Status util::BinaryToJsonStream(\n        TypeResolver* resolver,\n        const std::string& type_url,\n        io::ZeroCopyInputStream* binary_input,\n        io::ZeroCopyOutputStream* json_output,\n        const JsonPrintOptions& options)\n```\n\n----------------------------------------\n\nTITLE: Writing string data in CodedOutputStream\nDESCRIPTION: Equivalent to WriteRaw(str.data(), str.size()), provides a convenient way to write string content to the stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_77\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteString(const std::string& str)\n```\n\n----------------------------------------\n\nTITLE: Writing 32-bit Varint to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a 32-bit integer as a variable-length encoded value (varint) directly to a target array. Similar to WriteVarint32() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_100\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteVarint32ToArray(uint32 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Using Grouped Fields in Java Methods\nDESCRIPTION: Shows how grouped fields in Protocol Buffers enable cleaner method signatures in Java. The example demonstrates passing a CurrencyAmount object as a parameter rather than separate price and currency fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nCurrencyAmount calculateLocalTax(CurrencyAmount price, Location where)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Basic Custom Options in Protocol Buffers\nDESCRIPTION: This example demonstrates how to define a custom message-level option by extending the MessageOptions message. The option is then applied to a message and can be accessed in code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_52\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.MessageOptions {\n  optional string my_option = 51234;\n}\n\nmessage MyMessage {\n  option (my_option) = \"Hello world!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating Singular Fields in Proto2\nDESCRIPTION: Demonstrates the handling of singular (optional or required) fields in proto2, including setting values, checking if fields are set, and clearing fields. Shows how to use HasField() and ClearField() methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nmessage.foo = 123\nprint(message.foo)\n```\n\nLANGUAGE: python\nCODE:\n```\nassert not message.HasField(\"foo\")\nmessage.foo = 123\nassert message.HasField(\"foo\")\nmessage.ClearField(\"foo\")\nassert not message.HasField(\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Comparing Fields in Protocol Buffer Messages with SimpleFieldComparator in C++\nDESCRIPTION: The SimpleCompare method compares a specific field in two protocol buffer messages. It is used by DefaultFieldComparator and can be called by subclasses for fields that don't require special handling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nprotected ComparisonResult SimpleFieldComparator::SimpleCompare(\n    const Message& message_1,\n    const Message& message_2,\n    const FieldDescriptor* field,\n    int index_1,\n    int index_2,\n    const util::FieldContext* field_context)\n```\n\n----------------------------------------\n\nTITLE: Unknown Field Set Text Formatting - Objective-C\nDESCRIPTION: Replacement of GPBTextFormatForUnknownFieldSet with GPBTextFormatForMessage for formatting unknown fields in Protocol Buffers messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_4\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBTextFormatForUnknownFieldSet()\n```\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBTextFormatForMessage()\n```\n\n----------------------------------------\n\nTITLE: Enabling Opaque API in Proto File (Edition 2023)\nDESCRIPTION: Demonstrates how to enable the Opaque API for messages in a .proto file using Protobuf Edition 2023. It includes setting the api_level feature to API_OPAQUE.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-faq.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage log;\n\nimport \"google/protobuf/go_features.proto\";\noption features.(pb.go).api_level = API_OPAQUE;\n\nmessage LogEntry { … }\n```\n\n----------------------------------------\n\nTITLE: Enabling Plugins in Protocol Buffers Compiler\nDESCRIPTION: The AllowPlugins method enables plugins support in the Protocol Buffers compiler. It takes a prefix string that determines the naming convention for plugin executables and describes the expected plugin interface and behavior.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CommandLineInterface::AllowPlugins(\n        const std::string & exe_name_prefix)\n```\n\nLANGUAGE: bash\nCODE:\n```\nplugin [--out=OUTDIR] [--parameter=PARAMETER] PROTO_FILES < DESCRIPTORS\n```\n\nLANGUAGE: bash\nCODE:\n```\nprotoc --plug_out=enable_bar:outdir --plug_opt=enable_baz\n```\n\n----------------------------------------\n\nTITLE: Releasing Cleared Element from RepeatedPtrField\nDESCRIPTION: Removes a single element from the cleared pool in a RepeatedPtrField and returns it. Requires ClearedCount() > 0. Cannot be used with arena-based fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_52\n\nLANGUAGE: cpp\nCODE:\n```\nPROTOBUF_FUTURE_MUST_USE_RESULT Element * \n    RepeatedPtrField::ReleaseCleared()\n```\n\n----------------------------------------\n\nTITLE: Including Printer Header in C++\nDESCRIPTION: Shows how to include the Printer header file in C++ code to access the Printer utility class and related annotation collectors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/io/printer.h>\nnamespace google::protobuf::io\n```\n\n----------------------------------------\n\nTITLE: Serializing as String - C++\nDESCRIPTION: Creates a new string containing the serialized message. Returns empty string on error.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nstd::string MessageLite::SerializeAsString() const\n```\n\n----------------------------------------\n\nTITLE: Getting Mutable Repeated Field in Protocol Buffers C++\nDESCRIPTION: DEPRECATED. Use GetMutableRepeatedFieldRef() instead. Applicable for T = Cord and all protobuf scalar types except enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_67\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nRepeatedField<T>* Reflection::MutableRepeatedField(\n    Message* msg,\n    const FieldDescriptor* d) const\n```\n\n----------------------------------------\n\nTITLE: Enabling aliasing in CodedOutputStream\nDESCRIPTION: Instructs the CodedOutputStream to allow the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying, if it supports it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_85\n\nLANGUAGE: C++\nCODE:\n```\nvoid EnableAliasing(bool enabled)\n```\n\n----------------------------------------\n\nTITLE: Getting direct buffer pointer in CodedInputStream in C++\nDESCRIPTION: Sets data to point directly at the unread part of the CodedInputStream's underlying buffer, and size to the buffer size. Does not advance the stream's current position.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nbool GetDirectBufferPointer(const void** data, int* size)\n```\n\n----------------------------------------\n\nTITLE: Setting Field Retention in Protocol Buffers Message\nDESCRIPTION: Shows how to set source retention on a field within a message, which takes effect when the field is used inside an option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_43\n\nLANGUAGE: proto\nCODE:\n```\nmessage OptionsMessage {\n  int32 source_retention_field = 1 [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Internal Repeated Message Field in C++\nDESCRIPTION: Gets a mutable pointer to the internal RepeatedPtrField for a repeated message field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedPtrField<Message>* MutableRepeatedPtrFieldInternal(Message* message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Declaring DslProxy Abstract Class in Kotlin\nDESCRIPTION: Definition of an abstract class DslProxy that serves as a type marker. This class is used to differentiate between different types of DSL implementations without being instantiated directly. It enables unique extension method definitions for different proxy types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-proxy/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nabstract class DslProxy\n```\n\n----------------------------------------\n\nTITLE: Initializing EpsCopyOutputStream from ZeroCopyOutputStream in C++\nDESCRIPTION: Constructor that initializes EpsCopyOutputStream from a ZeroCopyOutputStream with options for deterministic serialization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_37\n\nLANGUAGE: C++\nCODE:\n```\nEpsCopyOutputStream(ZeroCopyOutputStream* stream, bool deterministic, uint8** pp)\n```\n\n----------------------------------------\n\nTITLE: Defining Services in Proto3\nDESCRIPTION: Specifies the syntax for service definitions in Protocol Buffers, which can contain RPCs with optional streaming request and response types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_31\n\nLANGUAGE: ebnf\nCODE:\n```\nservice = \"service\" serviceName \"{\" { option | rpc | emptyStatement } \"}\"\nrpc = \"rpc\" rpcName \"(\" [ \"stream\" ] messageType \")\" \"returns\" \"(\" [ \"stream\" ]\nmessageType \")\" (( \"{\" {option | emptyStatement } \"}\" ) | \";\")\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values in Python Protocol Buffer Definitions\nDESCRIPTION: Shows how to set a default value for an optional field in a .proto file. This is important when adding new optional fields to maintain backward compatibility with older message versions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/pythontutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: Protocol Buffer\nCODE:\n```\noptional int32 my_field = 1 [default = 42];\n```\n\n----------------------------------------\n\nTITLE: Swapping RepeatedField Contents in C++\nDESCRIPTION: Swaps entire contents between two repeated fields. Copies data if fields are in separate arenas.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedField::Swap(\n        RepeatedField* other)\n```\n\n----------------------------------------\n\nTITLE: Message Unknown Fields Handling - Objective-C\nDESCRIPTION: Replacement APIs for handling unknown fields in Protocol Buffer messages, including initialization, merging, and clearing operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_5\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBMessage unknownFields\n```\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBUnknownFields initFromMessage:\n```\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBMessage mergeUnknownFields:extensionRegistry:error:\n```\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBMessage clearUnknownFields\n```\n\n----------------------------------------\n\nTITLE: Comparing Memory Usage of String Types in Go\nDESCRIPTION: This code snippet illustrates the memory usage differences between string values and string pointers in Go, both when set and unset. It's used to explain why strings remain pointers in the Opaque API.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-faq.md#2025-04-11_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nGo variable type | set? | [word]s                  | #bytes\n---------------- | ---- | ------------------------ | ------\n`string`         | yes  | 2 (data, len)            | 16\n`string`         | no   | 2 (data, len)            | 16\n`*string`        | yes  | 1 (data) + 2 (data, len) | 24\n`*string`        | no   | 1 (data)                 | 8\n```\n\n----------------------------------------\n\nTITLE: Setting Input Path Handling for Protocol Buffers Compiler\nDESCRIPTION: The SetInputsAreProtoPathRelative method is deprecated. The compiler now automatically tries to find .proto files relative to the current directory first, then treats the input as a virtual path if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CommandLineInterface::SetInputsAreProtoPathRelative(\n        bool )\n```\n\n----------------------------------------\n\nTITLE: Using Temporary RepeatedPtrField Example\nDESCRIPTION: Example demonstrating usage of temporary RepeatedPtrField with ownership transfer. Shows potential issues when using with arena allocation and how to handle them.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedPtrField<T> temp_field;\ntemp_field.AddAllocated(new T);\n... // Do something with temp_field\ntemp_field.ExtractSubrange(0, temp_field.size(), nullptr);\n```\n\n----------------------------------------\n\nTITLE: Tokenizer Constructor Declaration\nDESCRIPTION: Constructor declaration for the Tokenizer class that takes a ZeroCopyInputStream and ErrorCollector as parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nTokenizer(ZeroCopyInputStream* input, ErrorCollector* error_collector)\n```\n\n----------------------------------------\n\nTITLE: Appending Serialized Data to String - C++\nDESCRIPTION: Appends the serialized message to an existing string. All required fields must be set.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::AppendToString(std::string* output) const\n```\n\n----------------------------------------\n\nTITLE: OstreamOutputStream Next Method Implementation\nDESCRIPTION: Virtual method that obtains a buffer for writing data to the output stream. Returns false on error, and provides a buffer through data pointer and its size. The buffer remains valid until another stream method is called.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool OstreamOutputStream::Next(\n        void ** data,\n        int * size)\n```\n\n----------------------------------------\n\nTITLE: Constructing CodedInputStream from buffer in C++\nDESCRIPTION: Creates a CodedInputStream that reads from a given flat array buffer. This constructor is explicit and takes a pointer to the buffer and its size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nexplicit CodedInputStream(const uint8* buffer, int size)\n```\n\n----------------------------------------\n\nTITLE: UnknownFieldSet Memory Management Methods\nDESCRIPTION: Methods for memory management and space calculation of unknown fields\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nsize_t SpaceUsedExcludingSelfLong() const\nstatic void MergeToInternalMetadata(const UnknownFieldSet& other, internal::InternalMetadata* metadata)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Repeated Field Encoding Example\nDESCRIPTION: Shows how repeated field encoding is configured in proto2 format and its equivalent in Edition 2023.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage Foo {\n  repeated int32 bar = 6 [packed=true];\n  repeated int32 baz = 7;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\noption features.repeated_field_encoding = EXPANDED;\n\nmessage Foo {\n  repeated int32 bar = 6 [features.repeated_field_encoding=PACKED];\n  repeated int32 baz = 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Extension by Number in DescriptorPool\nDESCRIPTION: Finds an extension field by its number for a given extendee type. The extendee must be a member of this DescriptorPool or one of its underlays.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_124\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * DescriptorPool::FindExtensionByNumber(const Descriptor * extendee, int number) const\n```\n\n----------------------------------------\n\nTITLE: Defining Fields in Protocol Buffers Text Format\nDESCRIPTION: EBNF grammar specifying the syntax for scalar and message fields, including list syntax and value representations in Protocol Buffers text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_16\n\nLANGUAGE: ebnf\nCODE:\n```\nField        = ScalarField | MessageField ;\nMessageField = FieldName, [ \":\" ], ( MessageValue | MessageList ) [ \";\" | \",\" ];\nScalarField  = FieldName, \":\",     ( ScalarValue  | ScalarList  ) [ \";\" | \",\" ];\nMessageList  = \"[\", [ MessageValue, { \",\", MessageValue } ], \"]\" ;\nScalarList   = \"[\", [ ScalarValue,  { \",\", ScalarValue  } ], \"]\" ;\nMessageValue = \"{\", Message, \"}\" | \"<\", Message, \">\" ;\nScalarValue  = String\n             | Float\n             | Identifier\n             | SignedIdentifier\n             | DecSignedInteger\n             | OctSignedInteger\n             | HexSignedInteger\n             | DecUnsignedInteger\n             | OctUnsignedInteger\n             | HexUnsignedInteger ;\n```\n\n----------------------------------------\n\nTITLE: Writing Raw Data with Aliasing in EpsCopyOutputStream in C++\nDESCRIPTION: Method for writing raw data to the stream with potential aliasing support, allowing the underlying stream to reference the original data without copying.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_43\n\nLANGUAGE: C++\nCODE:\n```\nuint8* WriteRawMaybeAliased(const void* data, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Finding All File Names in EncodedDescriptorDatabase (C++)\nDESCRIPTION: Method to find all file names in the EncodedDescriptorDatabase. It appends the found names to the output vector and returns true if the database supports searching all file names, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool EncodedDescriptorDatabase::FindAllFileNames(\n    std::vector< std::string > * )\n```\n\n----------------------------------------\n\nTITLE: Defining TypeResolver Class in C++\nDESCRIPTION: Defines the abstract TypeResolver class with its constructor, destructor, and pure virtual methods for resolving message and enum types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.type_resolver.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass TypeResolver {\npublic:\n    TypeResolver();\n    virtual ~TypeResolver();\n    virtual util::Status ResolveMessageType(const std::string & type_url, google::protobuf::Type * message_type) = 0;\n    virtual util::Status ResolveEnumType(const std::string & type_url, google::protobuf::Enum * enum_type) = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Presence String/Bytes Fields in Protocol Buffers (proto3)\nDESCRIPTION: Demonstrates the definition of implicit presence string and bytes fields in proto3 syntax. These generate specific C++ accessor methods without the 'has' method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nstring foo = 1;  // no field label specified, defaults to implicit presence.\nbytes foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Python Extension Field Usage Example\nDESCRIPTION: Example demonstrating the new way to handle extensions in Python using the Extensions property, replacing the deprecated RegisterExtension method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v26.md#2025-04-11_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# Old way - will be removed\nm.RegisterExtension(extension_descriptor)\n\n# New way\nm.Extensions[extension_descriptor] = value\n```\n\n----------------------------------------\n\nTITLE: Installing Migration Tool\nDESCRIPTION: Command to install the open2opaque migration tool using go install.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngo install google.golang.org/open2opaque@latest\n```\n\n----------------------------------------\n\nTITLE: Retrieving Compiler Version in C++ GeneratorContext\nDESCRIPTION: The GetCompilerVersion method retrieves the version number of the protocol compiler associated with this GeneratorContext.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void GetCompilerVersion(Version * version) const\n```\n\n----------------------------------------\n\nTITLE: UnknownFieldSet Parsing Helper Methods\nDESCRIPTION: Methods for parsing unknown fields from various input sources like CodedInputStream, ZeroCopyStream, and arrays\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nbool MergeFromCodedStream(io::CodedInputStream* input)\nbool ParseFromCodedStream(io::CodedInputStream* input)\nbool ParseFromZeroCopyStream(io::ZeroCopyInputStream* input)\nbool ParseFromArray(const void* data, int size)\nbool ParseFromString(const std::string& data)\n```\n\n----------------------------------------\n\nTITLE: Message Class Constructors and Basic Methods\nDESCRIPTION: Core constructors and basic methods of the Protocol Buffers Message class including default constructor, arena-based constructor, and metadata access.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr Message();\nprotected virtual Metadata GetMetadata() const = 0;\nprotected explicit Message(Arena* arena);\nprotected static uint64 GetInvariantPerBuild(uint64 salt);\n```\n\n----------------------------------------\n\nTITLE: Descriptor Allocation Methods - Objective-C\nDESCRIPTION: Deprecated descriptor allocation methods for file, enum, and extension descriptors that need to be regenerated with current library versions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_6\n\nLANGUAGE: objective-c\nCODE:\n```\n+[GPBFileDescriptor allocDescriptorForClass:file:fields:fieldCount:storageSize:flags:]\n```\n\nLANGUAGE: objective-c\nCODE:\n```\n+[GPBFileDescriptor allocDescriptorForClass:rootClass:file:fields:fieldCount:storageSize:flags:]\n```\n\nLANGUAGE: objective-c\nCODE:\n```\n+[GPBEnumDescriptor allocDescriptorForName:valueNames:values:count:enumVerifier:]\n```\n\nLANGUAGE: objective-c\nCODE:\n```\n+[GPBEnumDescriptor allocDescriptorForName:valueNames:values:count:enumVerifier:extraTextFormatInfo:]\n```\n\nLANGUAGE: objective-c\nCODE:\n```\n-[GPBExtensionDescriptor initWithExtensionDescription:]\n```\n\n----------------------------------------\n\nTITLE: Defining RepeatedField Member Types in C++\nDESCRIPTION: Defines various member types for the RepeatedField class, including iterators, value types, and size types. These typedefs provide STL-like support and compatibility.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\ntypedef Element * iterator;\ntypedef const Element * const_iterator;\ntypedef Element value_type;\ntypedef value_type & reference;\ntypedef const value_type & const_reference;\ntypedef value_type * pointer;\ntypedef const value_type * const_pointer;\ntypedef int size_type;\ntypedef ptrdiff_t difference_type;\ntypedef std::reverse_iterator<const_iterator> const_reverse_iterator;\ntypedef std::reverse_iterator<iterator> reverse_iterator;\n```\n\n----------------------------------------\n\nTITLE: Constructors and Destructors for RepeatedPtrField in Protocol Buffers\nDESCRIPTION: Constructor and destructor implementations for the RepeatedPtrField class, including default, arena-based, copy, range-based, and move constructors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_36\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr RepeatedPtrField()\n```\n\nLANGUAGE: C++\nCODE:\n```\nexplicit RepeatedPtrField(Arena * arena)\n```\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedPtrField(const RepeatedPtrField & other)\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate RepeatedPtrField(Iter begin, Iter end)\n```\n\nLANGUAGE: C++\nCODE:\n```\n~RepeatedPtrField()\n```\n\nLANGUAGE: C++\nCODE:\n```\nRepeatedPtrField(RepeatedPtrField && other)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Reserved Field Definition\nDESCRIPTION: Defines the syntax for reserved fields in Protocol Buffers, which prevent reuse of specific field numbers or names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_27\n\nLANGUAGE: ebnf\nCODE:\n```\nreserved = \"reserved\" ( ranges | strFieldNames ) \";\"\nstrFieldNames = strFieldName { \",\" strFieldName }\nstrFieldName = \"'\" fieldName \"'\" | '\"' fieldName '\"'\n```\n\n----------------------------------------\n\nTITLE: Setting Boolean and String Values in Protocol Buffers using Reflection in C++\nDESCRIPTION: Methods for setting boolean and string field values within Protocol Buffer messages. These reflection methods provide a way to modify message fields generically.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_39\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetBool(Message * message, const FieldDescriptor * field, bool value) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetString(Message * message, const FieldDescriptor * field, std::string value) const\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: Specifies the syntax for map fields in Protocol Buffers, which represent key-value pairs with various supported key types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_21\n\nLANGUAGE: EBNF\nCODE:\n```\nmapField = \"map\" \"<\" keyType \",\" type \">\" mapName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\nkeyType = \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" |\n          \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\"\n```\n\n----------------------------------------\n\nTITLE: Destroying CodedInputStream in C++\nDESCRIPTION: Destructor for CodedInputStream. It positions the underlying ZeroCopyInputStream at the first unread byte.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n~CodedInputStream()\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Values in Protocol Buffers (Python)\nDESCRIPTION: Demonstrates three different ways to access enumeration values in Python from Protocol Buffers, including direct access and using the Value() method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nvalue_a = myproto_pb2.SomeEnum.VALUE_A\n# or\nmyproto_pb2.VALUE_A\n# or\nmyproto_pb2.SomeEnum.Value('VALUE_A')\n```\n\n----------------------------------------\n\nTITLE: Referencing Nested Message Types Outside Parent Message\nDESCRIPTION: This example shows how to reference a nested message type from outside its parent message. You use the Parent.Type syntax to specify the nested type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\nmessage SomeOtherMessage {\n  SearchResponse.Result result = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing raw bytes with possible aliasing in CodedOutputStream\nDESCRIPTION: Similar to WriteRaw() but will try to write aliased data if aliasing is turned on, which can avoid data copying in some cases.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_76\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteRawMaybeAliased(const void* data, int size)\n```\n\n----------------------------------------\n\nTITLE: Defining Hugo Page Metadata in TOML\nDESCRIPTION: This code snippet defines the metadata for a Hugo page using TOML format. It specifies the title, weight, description, type, and a custom parameter for the page.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"News\"\nweight = 20\ndescription = \"Get the latest news about Protocol Buffers.\"\ntype = \"docs\"\nno_list = \"true\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Setting Hybrid API\nDESCRIPTION: Command to switch .proto files to the Hybrid API using open2opaque tool.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nopen2opaque setapi -api HYBRID $(find . -name \"*.proto\")\n```\n\n----------------------------------------\n\nTITLE: Generating C# Code from Protocol Buffer Files in C++\nDESCRIPTION: This class implements the CodeGenerator interface to generate C# source files from Protocol Buffer definitions. It provides methods for generating code and specifying supported features. The generator can be registered with the CommandLineInterface in a custom protocol compiler.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.csharp_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass Generator: public CodeGenerator {\n  Generator();\n  ~Generator();\n  virtual bool Generate(const FileDescriptor* file, \n                       const std::string& parameter, \n                       GeneratorContext* generator_context, \n                       std::string* error) const;\n  virtual uint64_t GetSupportedFeatures() const;\n};\n```\n\n----------------------------------------\n\nTITLE: UnknownFieldSet Field Management Methods\nDESCRIPTION: Method signatures for managing unknown fields including adding, deleting and accessing fields within the UnknownFieldSet\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddField(const UnknownField& field)\nUnknownField* mutable_field(int index)\nconst UnknownField& field(int index) const\nvoid DeleteSubrange(int start, int num)\nvoid DeleteByNumber(int number)\n```\n\n----------------------------------------\n\nTITLE: Message Creation Methods in Protocol Buffers (C++)\nDESCRIPTION: Virtual methods for creating new Message instances, including arena-based allocation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvirtual Message* New() const = 0;\nvirtual Message* New(Arena* arena) const;\n```\n\n----------------------------------------\n\nTITLE: Removing C++ Reflection Function in Protocol Buffers\nDESCRIPTION: Documents the removal of the Reserve() function from MutableRepeatedFieldRef<T> class in Protocol Buffers v30.x. This removal is necessary to accommodate performance improvements in RepeatedPtrField, particularly for sequential access operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-12-13.md#2025-04-11_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nMutableRepeatedFieldRef<T>::Reserve()\n```\n\n----------------------------------------\n\nTITLE: RepeatedPtrField Class Declaration in Protocol Buffers C++\nDESCRIPTION: The header declaration for the RepeatedPtrField template class, which is used for repeated strings or Messages in Protocol Buffers. It provides STL-like container functionality.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_34\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/repeated_field.h>\nnamespace google::protobuf\n\ntemplate <typename >\n```\n\n----------------------------------------\n\nTITLE: Reserving Space in RepeatedField in C++\nDESCRIPTION: Reserves space to expand the field to at least the given size. Always doubles the size when growing. Avoids inlining to prevent code bloat.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\nvoid RepeatedField::Reserve(\n        int new_size)\n```\n\n----------------------------------------\n\nTITLE: Proto3 Singular Field Definition\nDESCRIPTION: Example of a field definition in proto3 syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nint32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Getting Extension Count in FileDescriptor (C++)\nDESCRIPTION: Returns the number of extensions defined at file scope, not including extensions nested within message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_89\n\nLANGUAGE: C++\nCODE:\n```\nint FileDescriptor::extension_count() const\n```\n\n----------------------------------------\n\nTITLE: Handling Submessage Fields with Nil Checks in Ruby\nDESCRIPTION: Shows how to work with submessage fields, checking if they are set using nil comparison. Demonstrates that unset submessage fields return nil and how to clear a submessage field by setting it to nil.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/ruby/ruby-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nif message.submessage_field.nil?\n  puts \"Submessage field is unset.\"\nelse\n  message.submessage_field = nil\n  puts \"Cleared submessage field.\"\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Next() for IstreamInputStream in C++\nDESCRIPTION: Obtains a chunk of data from the stream. Returns false if there's no more data or an error occurred. Sets data pointer and size of the read buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool Next(const void** data, int* size)\n```\n\n----------------------------------------\n\nTITLE: Using Builders in Go for Proto Message Construction\nDESCRIPTION: Demonstrates the recommended way to use builders for constructing protocol buffer messages in Go, showing nested message construction.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-faq.md#2025-04-11_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nm1 := pb.M1_builder{\n    Submessage: pb.M2_builder{\n        Submessage: pb.M3_builder{\n            String: proto.String(\"hello world\"),\n            Int:    proto.Int32(42),\n        }.Build(),\n        Bytes: []byte(\"hello\"),\n    }.Build(),\n}.Build()\n```\n\n----------------------------------------\n\nTITLE: Using Enum Utility Methods in Protocol Buffers (Python)\nDESCRIPTION: Demonstrates utility methods for enum types, including Name() to get a field name from a value and Value() to get a value from a name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nself.assertEqual('VALUE_A', myproto_pb2.SomeEnum.Name(myproto_pb2.VALUE_A))\nself.assertEqual(5, myproto_pb2.SomeEnum.Value('VALUE_B'))\n```\n\n----------------------------------------\n\nTITLE: Creating Version Message in Protocol Buffers C++ API\nDESCRIPTION: Defines a function to create a Version message, possibly in an Arena-allocated memory. This likely represents version information for the compiler or generated code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nprotobuf::compiler::Version * Arena::CreateMaybeMessage< protobuf::compiler::Version >(Arena * );\n```\n\n----------------------------------------\n\nTITLE: Accessing Repeated Fields in Protocol Buffers (C++)\nDESCRIPTION: Methods for accessing repeated fields in Protocol Buffer messages. These methods provide both read-only and mutable access to repeated fields using the RepeatedFieldRef template interface.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_47\n\nLANGUAGE: C++\nCODE:\n```\ntemplate RepeatedFieldRef< T > GetRepeatedFieldRef(const Message & message, const FieldDescriptor * field) const\n```\n\nLANGUAGE: C++\nCODE:\n```\ntemplate MutableRepeatedFieldRef< T > GetMutableRepeatedFieldRef(Message * message, const FieldDescriptor * field) const\n```\n\n----------------------------------------\n\nTITLE: Querying Arena Used Space in C++\nDESCRIPTION: Method to get the total space used by the Arena. This excludes free space and block overhead, but may not include space used by concurrent thread operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nuint64 SpaceUsed() const\n```\n\n----------------------------------------\n\nTITLE: Erasing Element Range from RepeatedPtrField\nDESCRIPTION: Removes elements in the range [first, last) from a RepeatedPtrField. Returns an iterator to the element after the removed range. Invalidates iterators at or after the removed range.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_54\n\nLANGUAGE: cpp\nCODE:\n```\niterator RepeatedPtrField::erase(\n        const_iterator first,\n        const_iterator last)\n```\n\n----------------------------------------\n\nTITLE: MessageDifferencer Usage - C++ Protocol Buffers\nDESCRIPTION: Example demonstrating how to properly compare protobuf values in unit tests using MessageDifferencer instead of comparing DebugString output.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/deserialize-debug.md#2025-04-11_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nusing google::protobuf::util::MessageDifferencer;\n...\nMessageDifferencer diff;\n...\ndiff.Compare(foo, bar);\n```\n\n----------------------------------------\n\nTITLE: Updating Golang Protobuf Module in Go\nDESCRIPTION: Updates the github.com/golang/protobuf module to the latest version using the go get command.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/faq.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo get -u github.com/golang/protobuf/proto\n```\n\n----------------------------------------\n\nTITLE: Generated PhoneType Enum in Person Class\nDESCRIPTION: Example of a generated enum within the Person class for the PhoneType enumeration defined in the proto file. Shows how protocol buffer enums are mapped to Java 5 enum types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/javatutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic static enum PhoneType {\n  PHONE_TYPE_UNSPECIFIED(0, 0),\n  PHONE_TYPE_MOBILE(1, 1),\n  PHONE_TYPE_HOME(2, 2),\n  PHONE_TYPE_WORK(3, 3),\n  ;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Literal Migration - Before\nDESCRIPTION: Example of initializing a protobuf message using struct literal before migration.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nreturn &logpb.LogEntry{\n    BackendServer: proto.String(host),\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Field Name Transformation Function\nDESCRIPTION: Function declaration for transforming Protocol Buffer field names to match Objective-C naming conventions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::string UnCamelCaseFieldName(const std::string& name, const FieldDescriptor* field)\n```\n\n----------------------------------------\n\nTITLE: GzipOutputStream Close Method\nDESCRIPTION: Method to finalize and close the gzip stream, writing all remaining data. Returns true if successful.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nbool GzipOutputStream::Close()\n```\n\n----------------------------------------\n\nTITLE: DescriptorPool Constructor with Database in Protocol Buffers (C++)\nDESCRIPTION: Constructor that initializes a DescriptorPool with a fallback database and optional error collector.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_103\n\nLANGUAGE: C++\nCODE:\n```\nexplicit DescriptorPool(DescriptorDatabase * fallback_database, ErrorCollector * error_collector = nullptr)\n```\n\n----------------------------------------\n\nTITLE: C# Field Presence Handling with Explicit Presence\nDESCRIPTION: C# example showing field handling with explicit presence in Proto3, using HasFoo and ClearFoo methods for proper field presence tracking.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar m = GetProto();\nif (m.HasFoo) {\n  // Clear the field:\n  m.ClearFoo();\n} else {\n  // Field is not present, so set it.\n  m.Foo = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Iterator and Type Definitions for RepeatedPtrField in Protocol Buffers\nDESCRIPTION: Type definitions for iterators, value types, and other standard container types within the RepeatedPtrField template class. These types enable STL-compatible usage patterns.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_35\n\nLANGUAGE: C++\nCODE:\n```\ntypedef internal::RepeatedPtrIterator<Element> iterator\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef internal::RepeatedPtrIterator<const Element> const_iterator\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef Element value_type\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef value_type & reference\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef const value_type & const_reference\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef value_type * pointer\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef const value_type * const_pointer\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef int size_type\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef ptrdiff_t difference_type\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef std::reverse_iterator<const_iterator> const_reverse_iterator\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef std::reverse_iterator<iterator> reverse_iterator\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef internal::RepeatedPtrOverPtrsIterator<Element *, void *> pointer_iterator\n```\n\nLANGUAGE: C++\nCODE:\n```\ntypedef internal::RepeatedPtrOverPtrsIterator<const Element *const, const void *const > const_pointer_iterator\n```\n\n----------------------------------------\n\nTITLE: Checking if a Message is Generated Using MessageFactory\nDESCRIPTION: Code example showing how to determine if a message is a generated message by checking if its MessageFactory is the same as the generated factory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_70\n\nLANGUAGE: cpp\nCODE:\n```\nif (message->GetReflection()->GetMessageFactory() ==\n    google::protobuf::MessageFactory::generated_factory()) {\n  // This is a generated message.\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Field Label Enumeration\nDESCRIPTION: Defines labels for protocol buffer fields indicating if they are optional, required, or repeated.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_33\n\nLANGUAGE: protobuf\nCODE:\n```\nenum protobuf::FieldDescriptorProto_Label {\n  FieldDescriptorProto_Label_LABEL_REQUIRED = 2,\n  FieldDescriptorProto_Label_LABEL_REPEATED = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Unknown Fields in C++\nDESCRIPTION: Gets the UnknownFieldSet for a message, which contains fields that are unknown to the message's descriptor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nconst UnknownFieldSet& Reflection::GetUnknownFields(const Message& message) const\n```\n\n----------------------------------------\n\nTITLE: ListIterator Implementations in ExtensionList - Kotlin\nDESCRIPTION: Provides two overloaded implementations of listIterator for ExtensionList: one without parameters that returns a ListIterator<E>, and another that takes an index parameter to start iteration from a specific position.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/list-iterator.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun listIterator(): ListIterator<E>\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun listIterator(index: Int): ListIterator<E>\n```\n\n----------------------------------------\n\nTITLE: Implementing BackUp() for IstreamInputStream in C++\nDESCRIPTION: Backs up a number of bytes in the stream, allowing the next Next() call to return previously read data. Must be called after Next() with a count less than or equal to the last buffer size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void BackUp(int count)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String Concatenation in Protocol Buffers Text Format\nDESCRIPTION: Example showing how multiple quoted string parts can be concatenated in Protocol Buffers text format, with and without whitespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_13\n\nLANGUAGE: textproto\nCODE:\n```\na_string: \"first part\" 'second part'\n          \"third part\"\nno_whitespace: \"first\"\"second\"'third''fourth'\n```\n\n----------------------------------------\n\nTITLE: Setting NaN Comparison Behavior in SimpleFieldComparator (C++)\nDESCRIPTION: Method to set whether NaN values should be treated as equal or different in float/double comparisons. Default behavior treats NaNs as different.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid SimpleFieldComparator::set_treat_nan_as_equal(\n    bool treat_nan_as_equal)\n```\n\n----------------------------------------\n\nTITLE: Accessing EnumDescriptor values by index in C++\nDESCRIPTION: Gets a value by index, where 0 <= index < value_count(). Values are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_55\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor * \n    EnumDescriptor::value(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: Converting Timestamp Between Time Units and Datetime\nDESCRIPTION: Demonstrates methods for converting between various time units (microseconds) and Python datetime objects with Timestamp messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntimestamp_message.FromMicroseconds(-1)\nassert timestamp_message.ToMicroseconds() == -1\ndt = datetime(2016, 1, 1)\ntimestamp_message.FromDatetime(dt)\nself.assertEqual(dt, timestamp_message.ToDatetime())\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Range with Maximum Field Number in Protocol Buffers\nDESCRIPTION: This snippet shows how to define an extension range that goes up to the maximum possible field number using the 'max' keyword.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_25\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  extensions 1000 to max;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Repeated Enum Value in Protocol Buffers C++\nDESCRIPTION: Returns an enum field's value as an integer rather than an EnumValueDescriptor*. If the integer value does not correspond to a known value descriptor, a new value descriptor is created.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_62\n\nLANGUAGE: C++\nCODE:\n```\nint Reflection::GetRepeatedEnumValue(\n    const Message& message,\n    const FieldDescriptor* field,\n    int index) const\n```\n\n----------------------------------------\n\nTITLE: UTF-8 Validation Configuration Example\nDESCRIPTION: Shows how UTF-8 validation is configured in proto2 and its Edition 2023 equivalent.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage MyMessage {\n  string foo = 1;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nmessage MyMessage {\n  string foo = 1 [features.utf8_validation = NONE];\n}\n```\n\n----------------------------------------\n\nTITLE: Message Construction Comparison\nDESCRIPTION: Demonstrates how to construct a Protocol Buffer message using both the old Open Struct API and new Opaque API approaches.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nm := &pb.Foo{\n  Uint32: proto.Uint32(5),\n  Bytes:  []byte(\"hello\"),\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nm := pb.Foo_builder{\n  Uint32: proto.Uint32(5),\n  Bytes:  []byte(\"hello\"),\n}.Build()\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Function for Protoc Plugin in C++\nDESCRIPTION: This snippet shows the basic structure of a main() function for a protoc plugin in C++. It creates an instance of a custom CodeGenerator and passes it to PluginMain, which handles the plugin's execution.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint main(int argc, char* argv[]) {\n  MyCodeGenerator generator;\n  return google::protobuf::compiler::PluginMain(argc, argv, &amp;generator);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Next() for OstreamOutputStream in C++\nDESCRIPTION: Obtains a buffer into which data can be written. Sets data pointer and size of the write buffer.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool Next(void** data, int* size)\n```\n\n----------------------------------------\n\nTITLE: Finding File by Name in DescriptorPool (C++)\nDESCRIPTION: Locates a FileDescriptor in the pool by its file name. Returns the corresponding FileDescriptor if found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_105\n\nLANGUAGE: C++\nCODE:\n```\nconst FileDescriptor * FindFileByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Generated C# Class for Simple Protocol Buffer Message\nDESCRIPTION: Illustrates the C# class generated for a simple protocol buffer message, including various methods and properties for parsing, serialization, and comparison.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed partial class Foo : IMessage<Foo>\\n{\\n  // Static properties for parsing and reflection\\n  public static MessageParser<Foo> Parser { get; }\\n  public static MessageDescriptor Descriptor { get; }\\n\\n  // Explicit implementation of IMessage.Descriptor, to avoid conflicting with\\n  // the static Descriptor property. Typically the static property is used when\\n  // referring to a type known at compile time, and the instance property is used\\n  // when referring to an arbitrary message, such as during JSON serialization.\\n  MessageDescriptor IMessage.Descriptor { get; }\\n\\n  // Parameterless constructor which calls the OnConstruction partial method if provided.\\n  public Foo();\\n  // Deep-cloning constructor\\n  public Foo(Foo);\\n  // Partial method which can be implemented in manually-written code for the same class, to provide\\n  // a hook for code which should be run whenever an instance is constructed.\\n  partial void OnConstruction();\\n\\n  // Implementation of IDeepCloneable<T>.Clone(); creates a deep clone of this message.\\n  public Foo Clone();\\n\\n  // Standard equality handling; note that IMessage<T> extends IEquatable<T>\\n  public override bool Equals(object other);\\n  public bool Equals(Foo other);\\n  public override int GetHashCode();\\n\\n  // Converts the message to a JSON representation\\n  public override string ToString();\\n\\n  // Serializes the message to the protobuf binary format\\n  public void WriteTo(CodedOutputStream output);\\n  // Calculates the size of the message in protobuf binary format\\n  public int CalculateSize();\\n\\n  // Merges the contents of the given message into this one. Typically\\n  // used by generated code and message parsers.\\n  public void MergeFrom(Foo other);\\n\\n  // Merges the contents of the given protobuf binary format stream\\n  // into this message. Typically used by generated code and message parsers.\\n  public void MergeFrom(CodedInputStream input);\\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Nested Message Types Outside Parent in Protocol Buffers\nDESCRIPTION: Shows how to reference a nested message type outside its parent message using the _Parent_._Type_ syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\nmessage SomeOtherMessage {\n  optional SearchResponse.Result result = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Fields in Protocol Buffers\nDESCRIPTION: Demonstrates how to define fields of message type in both proto2 and proto3.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\n// proto2\nmessage Baz {\n  optional Bar bar = 1;\n  // The generated code is the same result if required instead of optional.\n}\n\n// proto3\nmessage Baz {\n  Bar bar = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetLocation Method in ParseInfoTree Class\nDESCRIPTION: Method to retrieve parse location for indexed field values in parsed text. Returns location with line = -1 if none exists. Index should be -1 for non-repeated fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nParseLocation ParseInfoTree::GetLocation(\n    const FieldDescriptor* field,\n    int index) const\n```\n\n----------------------------------------\n\nTITLE: Defining Embedded Message Fields in Protocol Buffers\nDESCRIPTION: Proto definitions showing how to declare optional and required embedded message fields named 'foo' of type 'Bar'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\noptional Bar foo = 1;\nrequired Bar foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Literals in Protocol Buffers\nDESCRIPTION: Specifies the syntax for integer literals in Protocol Buffers, including decimal, octal, and hexadecimal formats.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nintLit     = decimalLit | octalLit | hexLit\ndecimalLit = [-] ( \"1\" ... \"9\" ) { decimalDigit }\noctalLit   = [-] \"0\" { octalDigit }\nhexLit     = [-] \"0\" ( \"x\" | \"X\" ) hexDigit { hexDigit }\n```\n\n----------------------------------------\n\nTITLE: EBNF Representation of Whitespace and Comments\nDESCRIPTION: Extended Backus-Naur Form (EBNF) syntax defining whitespace and comment rules for the Protocol Buffer Text Format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_7\n\nLANGUAGE: ebnf\nCODE:\n```\nCOMMENT    = \"#\", { char - newline }, [ newline ] ;\nWHITESPACE = \" \"\n           | newline\n           | ? ASCII #9  (horizontal tab) ?\n           | ? ASCII #11 (vertical tab) ?\n           | ? ASCII #12 (form feed) ?\n           | ? ASCII #13 (carriage return) ? ;\n```\n\n----------------------------------------\n\nTITLE: Extension Function - Set Extension Value in Protocol Buffer Messages\nDESCRIPTION: Operator function that sets the value of a proto extension in an ExtendableBuilder. Takes an extension and value parameter.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/_index.md#2025-04-11_snippet_4\n\nLANGUAGE: Kotlin\nCODE:\n```\noperator fun <M : GeneratedMessageV3.ExtendableMessage<M>, B : GeneratedMessageV3.ExtendableBuilder<M, B>, T : Any> B.set(extension: ExtensionLite<M, T>, value: T)\n```\n\n----------------------------------------\n\nTITLE: Writing Protocol Buffer tag in CodedOutputStream\nDESCRIPTION: This is identical to WriteVarint32(), but optimized for writing Protocol Buffer field tags, which combine field number and wire type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_83\n\nLANGUAGE: C++\nCODE:\n```\nvoid WriteTag(uint32 value)\n```\n\n----------------------------------------\n\nTITLE: TimeUtil Time Management Methods\nDESCRIPTION: Utility methods for getting current time and epoch timestamp\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstatic Timestamp GetCurrentTime();\nstatic Timestamp GetEpoch();\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Feature Set Defaults in Text Format\nDESCRIPTION: Example of compiled feature definition showing defaults between proto2 and edition 2025, with overridable and fixed features for various editions. The example demonstrates how feature values change across editions and when features become fixed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/implementation.md#2025-04-11_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ndefaults {\n  edition: EDITION_PROTO2\n  overridable_features { [foo.features] {} }\n  fixed_features {\n    // Global feature defaults…\n    [foo.features] { feature_value: VALUE1 }\n  }\n}\ndefaults {\n  edition: EDITION_PROTO3\n  overridable_features { [foo.features] {} }\n  fixed_features {\n    // Global feature defaults…\n    [foo.features] { feature_value: VALUE1 }\n  }\n}\ndefaults {\n  edition: EDITION_2023\n  overridable_features {\n    // Global feature defaults…\n    [foo.features] { feature_value: VALUE1 }\n  }\n}\ndefaults {\n  edition: EDITION_2024\n  overridable_features {\n    // Global feature defaults…\n    [foo.features] { feature_value: VALUE2 }\n  }\n}\ndefaults {\n  edition: EDITION_2025\n  overridable_features {\n    // Global feature defaults…\n  }\n  fixed_features { [foo.features] { feature_value: VALUE2 } }\n}\nminimum_edition: EDITION_PROTO2\nmaximum_edition: EDITION_2025\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: Example of defining a map field in protocol buffer message format. Shows the syntax for creating a map with string keys and MerchItems values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nmessage MerchBooth {\n  map<string, MerchItems> items = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing hashCode method in DslList class for Protocol Buffers in Kotlin\nDESCRIPTION: An override implementation of the standard hashCode function for the DslList class in Protocol Buffers Kotlin API. This method returns an integer hash code value for DslList instances.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/hash-code.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun hashCode(): Int\n```\n\n----------------------------------------\n\nTITLE: Parsing String Tokens in C++\nDESCRIPTION: Static method to parse a TYPE_STRING token. It assumes the input text comes from a valid TYPE_STRING token.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nstatic void Tokenizer::ParseString(\n    const std::string& text,\n    std::string* output)\n```\n\n----------------------------------------\n\nTITLE: Finding Oneof by Name in DescriptorPool (C++)\nDESCRIPTION: Looks up a OneofDescriptor by its fully-qualified name. Returns the corresponding oneof descriptor or nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_111\n\nLANGUAGE: C++\nCODE:\n```\nconst OneofDescriptor * FindOneofByName(ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: MethodDescriptor Utility Functions - C++\nDESCRIPTION: Utility functions for copying, debugging and source location handling in MethodDescriptor class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_78\n\nLANGUAGE: C++\nCODE:\n```\nvoid CopyTo(MethodDescriptorProto* proto) const;\nstd::string DebugString() const;\nstd::string DebugStringWithOptions(const DebugStringOptions& options) const;\nbool GetSourceLocation(SourceLocation* out_location) const;\n```\n\n----------------------------------------\n\nTITLE: Setting Java Package Option in Protocol Buffers\nDESCRIPTION: Sets the Java package name for generated Java/Kotlin classes. Without this option, the proto package is used as the Java package, which often doesn't follow Java's reverse domain name convention.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_42\n\nLANGUAGE: proto\nCODE:\n```\noption java_package = \"com.example.foo\";\n```\n\n----------------------------------------\n\nTITLE: FieldMaskUtil TrimOptions Class Member Declarations\nDESCRIPTION: Defines the TrimOptions class members for configuring how Protocol Buffer fields are trimmed, including options for handling required fields during trimming operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_mask_util.md#2025-04-11_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nTrimOptions();\nvoid set_keep_required_fields(bool value);\nbool keep_required_fields() const;\n```\n\n----------------------------------------\n\nTITLE: Specifying Letters and Digits in Protocol Buffers\nDESCRIPTION: Defines the basic character sets used in Protocol Buffers, including letters, capital letters, and various digit formats.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\nletter = \"A\" ... \"Z\" | \"a\" ... \"z\"\ncapitalLetter =  \"A\" ... \"Z\"\ndecimalDigit = \"0\" ... \"9\"\noctalDigit   = \"0\" ... \"7\"\nhexDigit     = \"0\" ... \"9\" | \"A\" ... \"F\" | \"a\" ... \"f\"\n```\n\n----------------------------------------\n\nTITLE: Expanding Any Type in TextFormat Printer (C++)\nDESCRIPTION: Controls whether google.protobuf.Any payloads are expanded in the output. When true, prints in form [type_url] { <value_printed_in_text> } instead of the default format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_30\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetExpandAny(\n        bool expand)\n```\n\n----------------------------------------\n\nTITLE: Defining Map Fields in Protocol Buffers\nDESCRIPTION: A protocol buffer definition for a map field, which represents a key-value mapping within a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nmap<int32, int32> weight = 1;\n```\n\n----------------------------------------\n\nTITLE: EBNF Notation for Protocol Buffers Specification\nDESCRIPTION: Defines the Extended Backus-Naur Form (EBNF) notation used throughout the document to specify the syntax rules.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\n|   alternation\n()  grouping\n[]  option (zero or one time)\n{}  repetition (any number of times)\n```\n\n----------------------------------------\n\nTITLE: Nested Extension Definition in Protocol Buffers\nDESCRIPTION: Example of defining an extension within a message type in Protocol Buffers. This pattern allows organizing extensions within relevant message types.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_26\n\nLANGUAGE: proto\nCODE:\n```\nmessage Promo {\n  extend Concert {\n    optional int32 promo_id = 124;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modern Extendable Message Definition\nDESCRIPTION: Example of defining a modern extendable message with a large extension range and declaration verification.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\nmessage ModernExtendableMessage {\n  // All extensions in this range should use extension declarations.\n  extensions 1000 to 2000 [verification = DECLARATION];\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Data to a Protocol Buffer Map in C++\nDESCRIPTION: Example showing how to add entries to a Protocol Buffer map field using C++ syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_31\n\nLANGUAGE: cpp\nCODE:\n```\nstd::unique_ptr<ProtoName> my_enclosing_proto(new ProtoName);\n(*my_enclosing_proto->mutable_weight())[my_key] = my_value;\n```\n\n----------------------------------------\n\nTITLE: Accessing Unknown Fields in Protocol Buffers C++\nDESCRIPTION: Demonstrates how to get and mutate unknown fields in a Protocol Buffers message. Unknown fields are those parsed but not recognized according to the message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_51\n\nLANGUAGE: C++\nCODE:\n```\nconst UnknownFieldSet& Reflection::GetUnknownFields(\n    const Message& message) const\n```\n\nLANGUAGE: C++\nCODE:\n```\nUnknownFieldSet* Reflection::MutableUnknownFields(\n    Message* message) const\n```\n\n----------------------------------------\n\nTITLE: Service Call Flow Diagram in DOT Format\nDESCRIPTION: Graphviz DOT diagram showing the call flow between Client, ProductService and LocaleService to illustrate error propagation across service boundaries.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_13\n\nLANGUAGE: dot\nCODE:\n```\ndigraph toy_example {\n  node [style=filled]\n  client [label=\"Client\"];\n  product [label=\"ProductService\"];\n  locale [label=\"LocaleService\"];\n  client -> product [label=\"GetProducts\"]\n  product -> locale [label=\"LocaliseNutritionFacts\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Go Protocol Buffers Plugin\nDESCRIPTION: Command to install the Go protocol buffer compiler plugin. The plugin needs to be in the system PATH for the protoc compiler to find it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/gotutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n----------------------------------------\n\nTITLE: Accessing DslMap Entries in Protocol Buffers Kotlin\nDESCRIPTION: Defines the entries property for DslMap that returns a Set of Map.Entry pairs. This property provides access to all key-value pairs stored in the DslMap container.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/entries.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override val entries(): Set<Map.Entry<K(), V()>>\n```\n\n----------------------------------------\n\nTITLE: Defining DescriptorDatabase Virtual Interface in C++\nDESCRIPTION: Abstract interface class that defines core operations for descriptor databases including finding files by name, symbol, and extension details. Used as base class for various descriptor database implementations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass DescriptorDatabase {\npublic:\n  DescriptorDatabase();\n  virtual ~DescriptorDatabase();\n  virtual bool FindFileByName(const std::string& filename, FileDescriptorProto* output) = 0;\n  virtual bool FindFileContainingSymbol(const std::string& symbol_name, FileDescriptorProto* output) = 0;\n  virtual bool FindFileContainingExtension(const std::string& containing_type, int field_number, FileDescriptorProto* output) = 0;\n  virtual bool FindAllExtensionNumbers(const std::string&, std::vector<int>*);\n  virtual bool FindAllFileNames(std::vector<std::string>*);\n  bool FindAllPackageNames(std::vector<std::string>* output);\n  bool FindAllMessageNames(std::vector<std::string>* output);\n};\n```\n\n----------------------------------------\n\nTITLE: Clearing Unused Import Tracking Files\nDESCRIPTION: Clears the list of files being tracked for unused imports. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_134\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::ClearUnusedImportTrackFiles()\n```\n\n----------------------------------------\n\nTITLE: Timestamp String Conversion in C++\nDESCRIPTION: Converts Timestamp to/from RFC 3339 date string format. Supports time range from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z with nano-second precision.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.time_util.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::string TimeUtil::ToString(const Timestamp & timestamp)\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Enum Value Options in C++\nDESCRIPTION: Shows how to access a custom enum value option (string_name) from C++ code using the protobuf reflection API.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_51\n\nLANGUAGE: cpp\nCODE:\n```\nconst absl::string_view foo = proto2::GetEnumDescriptor<Data>()\n    ->FindValueByName(\"DATA_DISPLAY\")->options().GetExtension(string_name);\n```\n\n----------------------------------------\n\nTITLE: Registering Object Destructor in Arena (C++)\nDESCRIPTION: Adds an object to a list of objects whose destructors will be manually called when the arena is destroyed or reset. Used for objects placement-newed into arena-allocated memory.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\ntemplate void Arena::OwnDestructor(\n        T * object)\n```\n\n----------------------------------------\n\nTITLE: Unsafe Arena Swap in RepeatedField in C++\nDESCRIPTION: Performs an unsafe arena swap of the entire contents with another RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nvoid UnsafeArenaSwap(RepeatedField * other)\n```\n\n----------------------------------------\n\nTITLE: FieldComparator Enum Definition\nDESCRIPTION: Defines the ComparisonResult enum used to specify comparison outcomes between protocol buffer fields. Values include SAME (fields are equal), DIFFERENT (fields differ), and RECURSE (submessages need recursive comparison).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nenum ComparisonResult {\n  SAME,\n  DIFFERENT,\n  RECURSE\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Protocol Buffer Service in proto syntax\nDESCRIPTION: Example of a basic service definition in Protocol Buffers that defines a service 'Foo' with a method 'Bar' that takes a FooRequest and returns a FooResponse.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_34\n\nLANGUAGE: proto\nCODE:\n```\nservice Foo {\n  rpc Bar(FooRequest) returns(FooResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Letters and Digits in Proto3\nDESCRIPTION: Defines the basic lexical elements for letters and digits that can be used in Protocol Buffers identifiers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\nletter = \"A\" ... \"Z\" | \"a\" ... \"z\"\ndecimalDigit = \"0\" ... \"9\"\noctalDigit   = \"0\" ... \"7\"\nhexDigit     = \"0\" ... \"9\" | \"A\" ... \"F\" | \"a\" ... \"f\"\n```\n\n----------------------------------------\n\nTITLE: Setting UnknownField Type in C++\nDESCRIPTION: This method sets the wire type of an UnknownField. It should only be used when creating a new UnknownField instance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.unknown_field_set.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid UnknownField::SetType(\n        Type type)\n```\n\n----------------------------------------\n\nTITLE: Getting Integer Field Values in C++\nDESCRIPTION: Methods for getting various integer field types from a message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\nint32 GetInt32(const Message& message, const FieldDescriptor* field) const\nint64 GetInt64(const Message& message, const FieldDescriptor* field) const\nuint32 GetUInt32(const Message& message, const FieldDescriptor* field) const\nuint64 GetUInt64(const Message& message, const FieldDescriptor* field) const\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Message Format\nDESCRIPTION: Basic proto3 syntax definition including package declaration and imports for an address book application.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/kotlintutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\npackage tutorial;\n\nimport \"google/protobuf/timestamp.proto\";\n```\n\n----------------------------------------\n\nTITLE: Reserving Deleted Enum Values in Protocol Buffers\nDESCRIPTION: Shows how to reserve numbers and names for deleted enum values to prevent accidental reuse. This preserves backwards compatibility when modifying enums.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/dos-donts.md#2025-04-11_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nreserved 2, 3;\nreserved \"FOO\", \"BAR\";\n```\n\n----------------------------------------\n\nTITLE: Go Field Presence Handling with Implicit Presence\nDESCRIPTION: Go example demonstrating field handling with implicit presence in Proto3, where default values are used to check and clear fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nm := GetProto()\nif m.Foo != 0 {\n  // \"Clear\" the field:\n  m.Foo = 0\n} else {\n  // Default value: field may not have been present.\n  m.Foo = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values from DslMap in Protocol Buffers Kotlin API\nDESCRIPTION: This function provides access to all values in a DslMap collection. It overrides the standard values() function from the Map interface, returning a Collection of values of type V.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/values.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override val values(): Collection<V>\n```\n\n----------------------------------------\n\nTITLE: Setting Code Size Optimization in Protocol Buffer\nDESCRIPTION: Option to optimize the generated C++ code for size, which reduces code size but may impact performance.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\noption optimize_for = CODE_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Adding Generated File to Pool in Protocol Buffers (C++)\nDESCRIPTION: Static method called by generated classes at initialization time to add their descriptors to the generated pool. Not intended for use in user code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_147\n\nLANGUAGE: C++\nCODE:\n```\nstatic void DescriptorPool::InternalAddGeneratedFile(\n        const void * encoded_file_descriptor,\n        int size)\n```\n\n----------------------------------------\n\nTITLE: Finding Files by Name in SimpleDescriptorDatabase\nDESCRIPTION: Method to find a file descriptor by its filename. Returns true and fills output if found, otherwise returns false and leaves output undefined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool SimpleDescriptorDatabase::FindFileByName(\n        const std::string & filename,\n        FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Using Package Specifier in Message Fields\nDESCRIPTION: This snippet shows how to use a package specifier when defining fields of a message type. It demonstrates referencing the 'Open' message from the 'foo.bar' package in a 'Foo' message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_23\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  ...\n  foo.bar.Open open = 1;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if CodedInputStream is flat in C++\nDESCRIPTION: Returns true if this CodedInputStream reads from a flat array instead of a ZeroCopyInputStream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nbool IsFlat() const\n```\n\n----------------------------------------\n\nTITLE: Retrieving Previous Token in C++\nDESCRIPTION: Method to get the previous token from the Tokenizer, which is what current() returned before the last call to Next().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nconst Token& Tokenizer::previous()\n```\n\n----------------------------------------\n\nTITLE: Oneof Field Construction Comparison\nDESCRIPTION: Shows how to handle oneof fields in both APIs, demonstrating the difference in syntax and structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nm := &pb.Foo{\n  Uint32: myScalar,  // could be nil\n  Union:  &pb.Foo_String{myString},\n  Kind:   pb.Foo_SPECIAL_KIND.Enum(),\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nm := pb.Foo_builder{\n  Uint32: myScalar,\n  String: myString,\n  Kind:   pb.Foo_SPECIAL_KIND.Enum(),\n}.Build()\n```\n\n----------------------------------------\n\nTITLE: Finding All Extension Numbers in MergedDescriptorDatabase in C++\nDESCRIPTION: Retrieves all extension numbers for a given type across all merged databases. Returns true if any database returned true, and merges results into the output vector.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool FindAllExtensionNumbers(const std::string& extendee_type, std::vector<int>* output)\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Values in Rust with Current API vs Hypothetical Nullable Getters\nDESCRIPTION: Comparing how the current Rust API handles default values versus how nullable getters would behave. Shows how the current approach preserves defaults while Option<T> would lose them.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/design-decisions/nullable-getters-setters.md#2025-04-11_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// With our API:\nmsg.child().grandchild().foo()   // == 72\n\n// Where every getter is an Option<T>, verbose and no default observed\nmsg.child().map(|c| c.grandchild()).map(|gc| gc.foo()) // == Option::None\n\n// For the rare situations where code may want to observe both the presence and\n// value of a field, the _opt() accessor which returns a custom Optional type\n// can also be used here (the Optional type is similar to Option except can also\n// be aware of the default value):\nmsg.child().grandchild().foo_opt() // Optional::Unset(72)\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Literals in Protocol Buffers\nDESCRIPTION: Specifies the syntax for boolean literals in Protocol Buffers, which can be either 'true' or 'false'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_5\n\nLANGUAGE: EBNF\nCODE:\n```\nboolLit = \"true\" | \"false\"\n```\n\n----------------------------------------\n\nTITLE: FileInputStream SetCloseOnDelete Method\nDESCRIPTION: Configuration method to control whether the file descriptor should be closed when the stream is destroyed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid SetCloseOnDelete(bool value)\n```\n\n----------------------------------------\n\nTITLE: Oneof Example in Protocol Buffers\nDESCRIPTION: Demonstrates the definition of a oneof in Protocol Buffers with string and submessage field alternatives.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\noneof foo {\n    string name = 4;\n    SubMessage sub_message = 9;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Arena with Initial Block in C++\nDESCRIPTION: Constructor for Arena class that takes an initial memory block and its size. This is more efficient than using ArenaOptions when only initial block configuration is needed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.arena.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nArena(char * initial_block, size_t initial_block_size)\n```\n\n----------------------------------------\n\nTITLE: Using Extensions in C++\nDESCRIPTION: This C++ code snippet demonstrates how to use extensions. It shows adding, getting, and asserting the count of extension fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\nUserContent user_content;\nuser_content.AddExtension(kittens::kitten_videos, new kittens::Video());\nassert(1 == user_content.GetExtensionCount(kittens::kitten_videos));\nuser_content.GetExtension(kittens::kitten_videos, 0);\n```\n\n----------------------------------------\n\nTITLE: Implementing contains() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the contains() function from the List interface to check if an element exists in the ExtensionList. It returns a Boolean indicating whether the element is present.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen operator override fun contains(element: E): Boolean\n```\n\n----------------------------------------\n\nTITLE: Handling Reserved Keywords in Protocol Buffer Fields\nDESCRIPTION: Example of how the protocol buffer compiler handles reserved C++ keywords in field names by appending an underscore.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nmessage MyMessage {\n  string false = 1;\n  string myFalse = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: ErrorCollector::ErrorLocation Enum Definition in C++\nDESCRIPTION: Enum that specifies which part of a Protocol Buffers construct contains an error. This is useful for mapping errors back to specific locations in .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_150\n\nLANGUAGE: C++\nCODE:\n```\nenum ErrorCollector::ErrorLocation {\n  NAME,\n  NUMBER,\n  TYPE,\n  EXTENDEE,\n  DEFAULT_VALUE,\n  INPUT_TYPE,\n  OUTPUT_TYPE,\n  OPTION_NAME,\n  OPTION_VALUE,\n  IMPORT,\n  OTHER\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Message Type in Protocol Buffers Fields (C++)\nDESCRIPTION: If field type is TYPE_MESSAGE or TYPE_GROUP, returns a descriptor for the message or group type. Otherwise, returns nullptr.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_43\n\nLANGUAGE: cpp\nCODE:\n```\nconst Descriptor * \n    FieldDescriptor::message_type() const\n```\n\n----------------------------------------\n\nTITLE: Repeated Field Definition in Protocol Buffer\nDESCRIPTION: Message definition showing string and repeated integer fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/encoding.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Test4 {\n  string d = 4;\n  repeated int32 e = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Repeated Enum Field\nDESCRIPTION: Field definition showing a repeated enum field in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/cpp-generated.md#2025-04-11_snippet_20\n\nLANGUAGE: proto\nCODE:\n```\nrepeated Bar bar = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining TokenType Enumeration in C++\nDESCRIPTION: Enumeration defining the different types of tokens that can be recognized by the Tokenizer, including identifiers, numbers, strings, and symbols.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nenum Tokenizer::TokenType {\n  TYPE_START,\n  TYPE_END,\n  TYPE_IDENTIFIER,\n  TYPE_INTEGER,\n  TYPE_FLOAT,\n  TYPE_STRING,\n  TYPE_SYMBOL\n}\n```\n\n----------------------------------------\n\nTITLE: DescriptorPool Assertion Example\nDESCRIPTION: Example code showing how to verify correct DescriptorPool usage with assertion.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_36\n\nLANGUAGE: C++\nCODE:\n```\nassert(pool->FindMessageTypeByName(m->GetDescriptor()->full_name()) ==\n       m->GetDescriptor());\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: A protocol buffer definition for a oneof field, which allows a message to have one of many fields set while ensuring only one can be set at a time.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\noneof oneof_name {\n    int32 foo = 1;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Debug Format Example - Protocol Buffers\nDESCRIPTION: Example showing the new debugging format structure with redacted SPII fields and URL prefix.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/deserialize-debug.md#2025-04-11_snippet_0\n\nLANGUAGE: none\nCODE:\n```\ngoo.gle/debugstr\nspii_field: [REDACTED]\nnormal_field: \"value\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Protocol Buffer Messages with Go-cmp\nDESCRIPTION: Uses the github.com/google/go-cmp/cmp package with protocmp.Transform() to compare protocol buffer messages in Go tests.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/faq.md#2025-04-11_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nif diff := cmp.Diff(a, b, protocmp.Transform()); diff != \"\" {\n  t.Errorf(\"unexpected difference:\\n%v\", diff)\n}\n```\n\n----------------------------------------\n\nTITLE: Code Generator Feature Enumeration in C++\nDESCRIPTION: Enumeration defining supported features for protocol buffer code generators, synchronized with plugin.proto definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nenum CodeGenerator::Feature {\n  FEATURE_PROTO3_OPTIONAL = = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Type for Package-Level Enum\nDESCRIPTION: Shows how the type name for a package-level enum is directly derived from the enum name in the Protocol Buffer definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_18\n\nLANGUAGE: go\nCODE:\n```\ntype Genre int32\n```\n\n----------------------------------------\n\nTITLE: Defining OneofDescriptorProto Message in Protocol Buffers\nDESCRIPTION: Describes a oneof field in Protocol Buffers. It includes a name and options for the oneof.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage OneofDescriptorProto {\n  optional string name = 1;\n  optional OneofOptions options = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oneof Fields in Protocol Buffers\nDESCRIPTION: Explains how to use the oneof feature to create mutually exclusive fields and save memory in messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_33\n\nLANGUAGE: proto\nCODE:\n```\nmessage SampleMessage {\n  oneof test_oneof {\n     string name = 4;\n     SubMessage sub_message = 9;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing get() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the get() function from the List interface to retrieve an element at a specific index in the ExtensionList. Returns the element of type E.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_3\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen operator override fun get(index: Int): E\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Enumeration\nDESCRIPTION: Example of an enumeration definition in Protocol Buffers with color values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nenum Color {\n  COLOR_UNSPECIFIED = 0;\n  COLOR_RED = 1;\n  COLOR_GREEN = 5;\n  COLOR_BLUE = 1234;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Field Presence Tracking in Protocol Buffers (C++)\nDESCRIPTION: Returns true if the field tracks presence, distinguishing between 'unset' and 'present with default value'. Includes required, optional, and oneof fields, but excludes maps, repeated fields, and singular proto3 fields without 'optional'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_31\n\nLANGUAGE: cpp\nCODE:\n```\nbool FieldDescriptor::has_presence() const\n```\n\n----------------------------------------\n\nTITLE: Descriptor Copy Method\nDESCRIPTION: Method to copy the contents of a Descriptor into a DescriptorProto message. The target proto must be empty before calling this method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvoid Descriptor::CopyTo(DescriptorProto* proto) const\n```\n\n----------------------------------------\n\nTITLE: Setting Version Information for Protocol Buffers Compiler\nDESCRIPTION: The SetVersionInfo method allows setting custom text that will be displayed when the --version flag is used. The text will be printed along with the libprotoc version on the next line.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface.md#2025-04-11_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nvoid CommandLineInterface::SetVersionInfo(\n        const std::string & text)\n```\n\n----------------------------------------\n\nTITLE: Adding Allocated Element to Arena-based RepeatedPtrField\nDESCRIPTION: Adds an already-allocated object to a RepeatedPtrField while skipping arena-ownership checks. The user must ensure the object is in the same arena as the RepeatedPtrField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_47\n\nLANGUAGE: cpp\nCODE:\n```\nvoid RepeatedPtrField::UnsafeArenaAddAllocated(\n        Element * value)\n```\n\nLANGUAGE: cpp\nCODE:\n```\nRepeatedPtrField<T> temp_field;\ntemp_field.AddAllocated(new T);\n... // Do something with temp_field\ntemp_field.ExtractSubrange(0, temp_field.size(), nullptr);\n```\n\n----------------------------------------\n\nTITLE: Proto2 Floating-point Literals Definition\nDESCRIPTION: Defines the syntax for floating-point literals in Protocol Buffers, including decimal notation with optional exponents and special values like 'inf' and 'nan'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_4\n\nLANGUAGE: ebnf\nCODE:\n```\nfloatLit = [-] ( decimals \".\" [ decimals ] [ exponent ] | decimals exponent | \".\"\ndecimals [ exponent ] ) | \"inf\" | \"nan\"\ndecimals  = [-] decimalDigit { decimalDigit }\nexponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with String View Name Helper\nDESCRIPTION: Example of defining an enum with the enum_name_uses_string_view feature for string_view-based name helpers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/string-view.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  VALUE_A = 0;\n  VALUE_B = 5;\n  VALUE_C = 1234;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing equals Method for DslMap in Kotlin\nDESCRIPTION: This code snippet defines the equals method for the DslMap class. It's an open operator function that overrides the default equals implementation. The method takes another object as a parameter and returns a Boolean indicating whether the objects are equal.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/equals.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen operator override fun equals(other: Any?): Boolean\n```\n\n----------------------------------------\n\nTITLE: AnnotationCollector::Annotation Type Definition in C++\nDESCRIPTION: Defines the Annotation type as a pair containing an offset range and a string payload in the AnnotationCollector class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::pair<std::pair<size_t, size_t>, std::string> Annotation\n```\n\n----------------------------------------\n\nTITLE: Simple Proto Message Declaration\nDESCRIPTION: A minimal message declaration in Protocol Buffers syntax that will generate a corresponding PHP class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/php/php-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {}\n```\n\n----------------------------------------\n\nTITLE: Basic Protocol Buffer Message Definition\nDESCRIPTION: Simple message declaration in Protocol Buffers syntax that demonstrates the basic structure.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nmessage FooBar {}\n```\n\n----------------------------------------\n\nTITLE: Updating Protoc-Gen-Go Plugin\nDESCRIPTION: Command to update the Protocol Buffers compiler Go plugin to the latest version.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n----------------------------------------\n\nTITLE: Defining IdempotencyLevel Enum in Protocol Buffers\nDESCRIPTION: Defines an enum for specifying the idempotency level of a method, which can be used to determine appropriate HTTP verbs in RPC implementations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_14\n\nLANGUAGE: Protocol Buffers\nCODE:\n```\nenum IdempotencyLevel {\n  IDEMPOTENCY_UNKNOWN = 0;\n  NO_SIDE_EFFECTS = 1;  // implies idempotent\n  IDEMPOTENT = 2;       // idempotent, but may have side effects\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Options in C++\nDESCRIPTION: Demonstrates how to read a custom option value from a message descriptor in C++. The GetExtension method is used to retrieve the extension value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_53\n\nLANGUAGE: proto\nCODE:\n```\nstring value = MyMessage::descriptor()->options().GetExtension(my_option);\n```\n\n----------------------------------------\n\nTITLE: Implementing listIterator() Functions in Kotlin for ExtensionList\nDESCRIPTION: Overrides the listIterator() functions to provide ListIterator objects for the ExtensionList, with and without a starting index.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_6\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen override fun listIterator(): ListIterator<E>\nopen override fun listIterator(index: Int): ListIterator<E>\n```\n\n----------------------------------------\n\nTITLE: Generated C# Classes for Nested Protocol Buffer Messages\nDESCRIPTION: Shows the C# class structure generated for nested protocol buffer messages, including the use of a nested Types class to avoid naming conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace [...]\\n{\\n  public sealed partial class Foo : IMessage<Foo>\\n  {\\n    public static partial class Types\\n    {\\n      public sealed partial class Bar : IMessage<Bar> { ... }\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Default float Value in Protocol Buffers Fields (C++)\nDESCRIPTION: Retrieves the field default value when cpp_type() is CPPTYPE_FLOAT. Returns 0.0 if no explicit default was defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_36\n\nLANGUAGE: cpp\nCODE:\n```\nfloat FieldDescriptor::default_value_float() const\n```\n\n----------------------------------------\n\nTITLE: Using MessageFactory with Generated Messages\nDESCRIPTION: Code example showing how the generated_factory provides access to default instances of compiled message types, allowing type checking and instantiation of messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_71\n\nLANGUAGE: cpp\nCODE:\n```\nMessageFactory::generated_factory()->GetPrototype(\n  FooMessage::descriptor()) == FooMessage::default_instance()\n```\n\n----------------------------------------\n\nTITLE: Opening a File for Appending in C++ GeneratorContext\nDESCRIPTION: The OpenForAppend method opens a file for appending. It returns a ZeroCopyOutputStream for writing to the end of the file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvirtual io::ZeroCopyOutputStream * OpenForAppend(const std::string & filename)\n```\n\n----------------------------------------\n\nTITLE: Finding Enum Value by Name in FileDescriptor (C++)\nDESCRIPTION: Finds an enum value defined in any top-level enum by name. Returns nullptr if not found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_93\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumValueDescriptor * \n    FileDescriptor::FindEnumValueByName(\n        ConstStringParam name) const\n```\n\n----------------------------------------\n\nTITLE: Proto2 Boolean Literal Definition\nDESCRIPTION: Specifies the syntax for boolean literals in Protocol Buffers, which can be either 'true' or 'false'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_5\n\nLANGUAGE: ebnf\nCODE:\n```\nboolLit = \"true\" | \"false\"\n```\n\n----------------------------------------\n\nTITLE: ConcatenatingInputStream Next Method Implementation\nDESCRIPTION: Virtual method that retrieves a chunk of data from the input stream. Returns false when no more data is available or on error. Provides data through a const void pointer and its size.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool ConcatenatingInputStream::Next(\n        const void ** data,\n        int * size)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Text Format File Header\nDESCRIPTION: Shows how to specify the schema information in the header of a Protocol Buffers text format file for developer tools.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_29\n\nLANGUAGE: textproto\nCODE:\n```\n# proto-file: some/proto/my_file.proto\n# proto-message: MyMessage\n```\n\n----------------------------------------\n\nTITLE: Declaring Default Instances for Protocol Buffer Message Types\nDESCRIPTION: Declarations of default instances for various Protocol Buffer message types. These default instances are used as templates when creating new instances of Protocol Buffer messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nDescriptorProtoDefaultTypeInternal _DescriptorProto_default_instance_\nDescriptorProto_ExtensionRangeDefaultTypeInternal _DescriptorProto_ExtensionRange_default_instance_\nDescriptorProto_ReservedRangeDefaultTypeInternal _DescriptorProto_ReservedRange_default_instance_\nEnumDescriptorProtoDefaultTypeInternal _EnumDescriptorProto_default_instance_\nEnumDescriptorProto_EnumReservedRangeDefaultTypeInternal _EnumDescriptorProto_EnumReservedRange_default_instance_\nEnumOptionsDefaultTypeInternal _EnumOptions_default_instance_\nEnumValueDescriptorProtoDefaultTypeInternal _EnumValueDescriptorProto_default_instance_\nEnumValueOptionsDefaultTypeInternal _EnumValueOptions_default_instance_\nExtensionRangeOptionsDefaultTypeInternal _ExtensionRangeOptions_default_instance_\nFieldDescriptorProtoDefaultTypeInternal _FieldDescriptorProto_default_instance_\nFieldOptionsDefaultTypeInternal _FieldOptions_default_instance_\nFileDescriptorProtoDefaultTypeInternal _FileDescriptorProto_default_instance_\nFileDescriptorSetDefaultTypeInternal _FileDescriptorSet_default_instance_\nFileOptionsDefaultTypeInternal _FileOptions_default_instance_\nGeneratedCodeInfoDefaultTypeInternal _GeneratedCodeInfo_default_instance_\nGeneratedCodeInfo_AnnotationDefaultTypeInternal _GeneratedCodeInfo_Annotation_default_instance_\nMessageOptionsDefaultTypeInternal _MessageOptions_default_instance_\nMethodDescriptorProtoDefaultTypeInternal _MethodDescriptorProto_default_instance_\nMethodOptionsDefaultTypeInternal _MethodOptions_default_instance_\nOneofDescriptorProtoDefaultTypeInternal _OneofDescriptorProto_default_instance_\nOneofOptionsDefaultTypeInternal _OneofOptions_default_instance_\nServiceDescriptorProtoDefaultTypeInternal _ServiceDescriptorProto_default_instance_\n```\n\n----------------------------------------\n\nTITLE: Defining Field Options C Type Enum in Protocol Buffers\nDESCRIPTION: Declaration of the FieldOptions_CType enum that defines the C/C++ type to use for a field in Protocol Buffers. This affects how fields are represented in generated C++ code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nenum FieldOptions_CType\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Example of Custom Options for All Protocol Buffer Constructs\nDESCRIPTION: This example demonstrates defining and using custom options for every type of Protocol Buffer construct, including file, message, field, oneof, enum, enum value, service, and method options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_56\n\nLANGUAGE: proto\nCODE:\n```\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.FileOptions {\n  optional string my_file_option = 50000;\n}\nextend google.protobuf.MessageOptions {\n  optional int32 my_message_option = 50001;\n}\nextend google.protobuf.FieldOptions {\n  optional float my_field_option = 50002;\n}\nextend google.protobuf.OneofOptions {\n  optional int64 my_oneof_option = 50003;\n}\nextend google.protobuf.EnumOptions {\n  optional bool my_enum_option = 50004;\n}\nextend google.protobuf.EnumValueOptions {\n  optional uint32 my_enum_value_option = 50005;\n}\nextend google.protobuf.ServiceOptions {\n  optional MyEnum my_service_option = 50006;\n}\nextend google.protobuf.MethodOptions {\n  optional MyMessage my_method_option = 50007;\n}\n\noption (my_file_option) = \"Hello world!\";\n\nmessage MyMessage {\n  option (my_message_option) = 1234;\n\n  optional int32 foo = 1 [(my_field_option) = 4.5];\n  optional string bar = 2;\n  oneof qux {\n    option (my_oneof_option) = 42;\n\n    string quux = 3;\n  }\n}\n\nenum MyEnum {\n  option (my_enum_option) = true;\n\n  FOO = 1 [(my_enum_value_option) = 321];\n  BAR = 2;\n}\n\nmessage RequestType {}\nmessage ResponseType {}\n\nservice MyService {\n  option (my_service_option) = FOO;\n\n  rpc MyMethod(RequestType) returns(ResponseType) {\n    // Note:  my_method_option has type MyMessage.  We can set each field\n    //   within it using a separate \"option\" line.\n    option (my_method_option).foo = 567;\n    option (my_method_option).bar = \"Some string\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the OnlyForUseByGeneratedProtoCode Annotation in Kotlin\nDESCRIPTION: Declaration of the OnlyForUseByGeneratedProtoCode annotation class which targets constructors and annotation classes. This annotation is used to mark APIs that should only be used by generated Protocol Buffer code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\n@[Target](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html)(allowedTargets =\n[[AnnotationTarget.CONSTRUCTOR](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-o-n-s-t-r-u-c-t-o-r.html#kotlin.annotation.AnnotationTarget.CONSTRUCTOR),\n[AnnotationTarget.ANNOTATION_CLASS](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-l-a-s-s.html#kotlin.annotation.AnnotationTarget.CLASS)])\n\nannotation class [OnlyForUseByGeneratedProtoCode]()\n```\n\n----------------------------------------\n\nTITLE: Declaring Go Package in Proto File\nDESCRIPTION: Example of specifying the Go package import path within a .proto file using the go_package option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\noption go_package = \"example.com/project/protos/fizz\";\n```\n\n----------------------------------------\n\nTITLE: Handling Fields in Descriptor Class (C++)\nDESCRIPTION: Shows methods for working with fields in the Descriptor class, including counting, accessing, and finding fields by various criteria.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint field_count() const;\nconst FieldDescriptor* field(int index) const;\nconst FieldDescriptor* FindFieldByNumber(int number) const;\nconst FieldDescriptor* FindFieldByName(ConstStringParam name) const;\nconst FieldDescriptor* FindFieldByLowercaseName(ConstStringParam lowercase_name) const;\nconst FieldDescriptor* FindFieldByCamelcaseName(ConstStringParam camelcase_name) const;\n```\n\n----------------------------------------\n\nTITLE: Efficient Arena Message Allocation - C++\nDESCRIPTION: Shows how to properly allocate messages on the same arena to avoid unnecessary copying during swap operations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/arenas.md#2025-04-11_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nMyFeatureMessage* message_2 =\n   google::protobuf::Arena::Create<MyFeatureMessage>(arena);\n```\n\n----------------------------------------\n\nTITLE: Inserting Code at Specific Points in C++ GeneratorContext\nDESCRIPTION: The OpenForInsert method creates a ZeroCopyOutputStream for inserting code at a specific insertion point in a file. This feature is experimental and subject to change.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvirtual io::ZeroCopyOutputStream * OpenForInsert(const std::string & filename, const std::string & insertion_point)\n```\n\n----------------------------------------\n\nTITLE: Example Proto File with C# Namespace Option\nDESCRIPTION: Shows a simplified version of the timestamp.proto file, demonstrating the use of the csharp_namespace option to specify a custom C# namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\\npackage google.protobuf;\\noption csharp_namespace = \"Google.Protobuf.WellKnownTypes\";\\n\\nmessage Timestamp { ... }\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Extensions in C++\nDESCRIPTION: Shows how to access and set nested extensions in C++ code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_28\n\nLANGUAGE: cpp\nCODE:\n```\nUserProfile user_profile;\nuser_profile.SetExtension(puppies::Photo::likes_count, 42);\n```\n\n----------------------------------------\n\nTITLE: Writing Packed Fixed Values to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed fixed-size values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_55\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteFixedPacked(int num, const T& r, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Repeated Message Fields Protocol Buffer Definition\nDESCRIPTION: A .proto file defining messages with a repeated message field, used to demonstrate how to work with repeated message fields in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  repeated Bar bars = 1;\n}\nmessage Bar {\n  optional int32 i = 1;\n  optional int32 j = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Protocol Buffer Messages with Arena Memory Management in C++\nDESCRIPTION: These functions create various Protocol Buffer message types using Arena memory management. They take an Arena pointer as an argument and return a pointer to the newly created message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\nprotobuf::EnumOptions* Arena::CreateMaybeMessage< protobuf::EnumOptions >(Arena*)\n```\n\nLANGUAGE: C++\nCODE:\n```\nprotobuf::EnumValueDescriptorProto* Arena::CreateMaybeMessage< protobuf::EnumValueDescriptorProto >(Arena*)\n```\n\nLANGUAGE: C++\nCODE:\n```\nprotobuf::EnumValueOptions* Arena::CreateMaybeMessage< protobuf::EnumValueOptions >(Arena*)\n```\n\n----------------------------------------\n\nTITLE: Finding Files Containing Symbols in SimpleDescriptorDatabase\nDESCRIPTION: Method to find a file descriptor that declares a given fully-qualified symbol name. Returns true and fills output if found.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool SimpleDescriptorDatabase::FindFileContainingSymbol(\n        const std::string & symbol_name,\n        FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Memory Safety with Oneof Fields in C++\nDESCRIPTION: This snippet illustrates a potential memory crash scenario when working with oneof fields in C++. It shows that accessing a previously set oneof field after setting a different field can lead to crashes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nSampleMessage message;\nSubMessage* sub_message = message.mutable_sub_message();\nmessage.set_name(\"name\");      // Will delete sub_message\nsub_message->set_...            // Crashes here\n```\n\n----------------------------------------\n\nTITLE: Defining ProtoDslMarker Annotation in Kotlin\nDESCRIPTION: Declaration of the ProtoDslMarker annotation class which is used to indicate APIs that are part of a DSL for generating protocol buffer messages. It uses Kotlin's DslMarker and is targeted at classes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n@[DslMarker](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/index.html)()\n@[Target](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html)(allowedTargets =\n[[AnnotationTarget.CLASS](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-l-a-s-s/index.html)])\n\nannotation class [ProtoDslMarker]()()\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compilation with Import Path Mapping\nDESCRIPTION: Example showing how to compile proto files while explicitly mapping proto files to Go import paths using command line flags.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated-opaque.md#2025-04-11_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src \\\n  --go_opt=Mprotos/buzz.proto=example.com/project/protos/fizz \\\n  --go_opt=Mprotos/bar.proto=example.com/project/protos/foo \\\n  protos/buzz.proto protos/bar.proto\n```\n\n----------------------------------------\n\nTITLE: Copying FileDescriptor to Proto (C++)\nDESCRIPTION: Copies the FileDescriptor to a FileDescriptorProto. Does not copy source code information, which must be copied separately using CopySourceCodeInfoTo().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_97\n\nLANGUAGE: C++\nCODE:\n```\nvoid FileDescriptor::CopyTo(\n        FileDescriptorProto * proto) const\n```\n\n----------------------------------------\n\nTITLE: Setting Fraction and Margin for Field Comparison in SimpleFieldComparator (C++)\nDESCRIPTION: Method to set the fraction and margin for float comparison of a specific field. Requires the field to be of double or float type and the float comparison mode to be set to APPROXIMATE.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.util.field_comparator.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid SimpleFieldComparator::SetFractionAndMargin(\n    const FieldDescriptor * field,\n    double fraction,\n    double margin)\n```\n\n----------------------------------------\n\nTITLE: Get reflection class name for C# code generation in Protocol Buffers\nDESCRIPTION: Returns the fully-qualified name of the C# class that provides access to the file descriptor. Proto compiler generates such a class for each .proto file processed. Requires that the descriptor is not null.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.csharp_names.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstd::string csharp::GetReflectionClassName(\n        const FileDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Indent Level in Protocol Buffers TextFormat Printer (C++)\nDESCRIPTION: Sets the initial indentation level for all output in the TextFormat printer. Each indent level corresponds to two spaces.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Printer::SetInitialIndentLevel(\n        int indent_level)\n```\n\n----------------------------------------\n\nTITLE: Implementing containsAll() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the containsAll() function from the List interface to check if all elements from a given collection are present in the ExtensionList. Returns a Boolean result.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen override fun containsAll(elements: Collection<E>): Boolean\n```\n\n----------------------------------------\n\nTITLE: Serializing to CodedOutputStream - C++\nDESCRIPTION: Writes the protocol buffer message to a CodedOutputStream. Returns false on write error and may fail if required fields are missing.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message_lite.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nbool MessageLite::SerializeToCodedStream(io::CodedOutputStream* output) const\n```\n\n----------------------------------------\n\nTITLE: Repeated Scalar Fields Protocol Buffer Definition\nDESCRIPTION: A .proto file defining a message with a repeated int32 field, used to demonstrate how to work with repeated scalar fields in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/python-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  repeated int32 nums = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ByteArray to ByteString in Kotlin for Protocol Buffers\nDESCRIPTION: Extension function that converts a ByteArray to an immutable ByteString object. This creates a copy of the ByteArray data for use with Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nfun ByteArray.toByteString(): ByteString\n```\n\n----------------------------------------\n\nTITLE: Accessing Const Data in RepeatedField in C++\nDESCRIPTION: Gets the underlying const array of the RepeatedField.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.repeated_field.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nconst Element * data() const\n```\n\n----------------------------------------\n\nTITLE: Go Constants for Package-Level Enum\nDESCRIPTION: Generated Go constants for a package-level enum. Constants are prefixed with the enum name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_29\n\nLANGUAGE: go\nCODE:\n```\nconst (\n    Genre_GENRE_UNSPECIFIED   Genre = 0\n    Genre_GENRE_ROCK          Genre = 1\n    Genre_GENRE_INDIE         Genre = 2\n    Genre_GENRE_DRUM_AND_BASS Genre = 3\n)\n```\n\n----------------------------------------\n\nTITLE: Problematic Enum Value Naming in Protocol Buffers\nDESCRIPTION: Illustrates a naming collision when enum values aren't properly prefixed with their enum name, which causes protoc to reject the definitions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/style.md#2025-04-11_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nenum CollectionType {\n  COLLECTION_TYPE_UNSPECIFIED = 0;\n  SET = 1;\n  MAP = 2;\n  ARRAY = 3;\n}\n\nenum TennisVictoryType {\n  TENNIS_VICTORY_TYPE_UNSPECIFIED = 0;\n  GAME = 1;\n  SET = 2;\n  MATCH = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Function - Concatenate ByteStrings\nDESCRIPTION: Operator function that concatenates two ByteStrings together. Returns a new ByteString containing the concatenated result.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/_index.md#2025-04-11_snippet_3\n\nLANGUAGE: Kotlin\nCODE:\n```\noperator fun ByteString.plus(other: ByteString): ByteString\n```\n\n----------------------------------------\n\nTITLE: Formatting Protocol Buffer Text Output in Go\nDESCRIPTION: To obtain some stability in prototext output, use the txtpbfmt parser.Format function. This can help standardize the text format output.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/faq.md#2025-04-11_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nparser.Format(prototextOutput)\n```\n\n----------------------------------------\n\nTITLE: Finding File Containing Symbol in DescriptorPoolDatabase (C++)\nDESCRIPTION: Method to find the file that declares a given fully-qualified symbol name in the DescriptorPoolDatabase. It fills the output with the FileDescriptorProto if found and returns true, otherwise returns false.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nvirtual bool DescriptorPoolDatabase::FindFileContainingSymbol(\n    const std::string & symbol_name,\n    FileDescriptorProto * output)\n```\n\n----------------------------------------\n\nTITLE: Overriding API Level for Specific File\nDESCRIPTION: Example of how to override the API level for a specific file using a command-line flag. This allows for fine-grained control over API levels when compiling multiple .proto files.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nprotoc […] --go_opt=apilevelMhello.proto=API_HYBRID\n```\n\n----------------------------------------\n\nTITLE: Generating Java Class Name from FileDescriptor in C++\nDESCRIPTION: Function to get the fully-qualified Java class name from a FileDescriptor object. Requires that the descriptor parameter is not NULL.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_names.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstd::string java::ClassName(\n        const FileDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions within Field Type Scope\nDESCRIPTION: Illustrates a common pattern of defining extensions inside the scope of the extension's field type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_29\n\nLANGUAGE: proto\nCODE:\n```\nimport \"media/user_content.proto\";\n\npackage puppies;\n\nmessage Photo {\n  extend media.UserContent {\n    optional Photo puppy_photo = 127;\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing equals() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the equals() function to compare this ExtensionList with another object for equality. Returns a Boolean indicating whether they are equal.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_2\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen operator override fun equals(other: Any?): Boolean\n```\n\n----------------------------------------\n\nTITLE: Checking Serialization Deterministic Mode in EpsCopyOutputStream in C++\nDESCRIPTION: Method that returns whether serialization is configured to be deterministic.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_59\n\nLANGUAGE: C++\nCODE:\n```\nbool IsSerializationDeterministic() const\n```\n\n----------------------------------------\n\nTITLE: Getting Supported Features in JavaGenerator\nDESCRIPTION: Implementation of GetSupportedFeatures method that indicates what features this Java code generator supports. Returns a bitwise OR of features from the Features enum in plugin.proto.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_generator.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvirtual uint64_t GetSupportedFeatures() const\n```\n\n----------------------------------------\n\nTITLE: Converting ByteBuffer to ByteString in Kotlin for Protocol Buffers\nDESCRIPTION: Extension function that copies the remaining bytes from a ByteBuffer to an immutable ByteString object for use with Protocol Buffers. This operates on the remaining bytes in the buffer's current position.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string.md#2025-04-11_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nfun ByteBuffer.toByteString(): ByteString\n```\n\n----------------------------------------\n\nTITLE: Constructing DynamicMessageFactory in C++ Protocol Buffers\nDESCRIPTION: Creates a DynamicMessageFactory instance that searches for extensions in the DescriptorPool where the extendee is defined.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.dynamic_message.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nDynamicMessageFactory()\n```\n\n----------------------------------------\n\nTITLE: Setting source retention for a field in Protocol Buffers\nDESCRIPTION: Demonstrates how to set the retention option to RETENTION_SOURCE for a field in a message in Protocol Buffers. This takes effect only when the field appears inside an option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-11.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage OptionsMessage {\n  optional int32 source_retention_field = 1 [retention = RETENTION_SOURCE];\n}\n```\n\n----------------------------------------\n\nTITLE: Converting String to ByteString with UTF-8 Encoding in Kotlin\nDESCRIPTION: This extension function encodes a String into a sequence of UTF-8 bytes and returns the result as a ByteString. It is defined in the com.google.protobuf.kotlin package and is available for use with any String object in Kotlin when the appropriate import is made.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string-utf8.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\nfun String.toByteStringUtf8(): ByteString\n```\n\n----------------------------------------\n\nTITLE: Configuring Protocol Buffers Go API Documentation Page\nDESCRIPTION: Frontmatter configuration for a documentation page about the Go Protocol Buffers API. Sets up the page title, external manual link to pkg.go.dev documentation, and navigation weight.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: \"Go API\"\nmanualLink: \"https://pkg.go.dev/google.golang.org/protobuf/proto\"\nmanualLinkTarget: \"_blank\"\nweight: 640\n---\n```\n\n----------------------------------------\n\nTITLE: Obtaining Direct Buffer Access for N Bytes in CodedOutputStream in C++\nDESCRIPTION: Returns a pointer directly into the buffer if there are at least 'size' bytes available and advances over these bytes. This allows writing directly into the buffer instead of going through CodedOutputStream methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_110\n\nLANGUAGE: cpp\nCODE:\n```\nuint8 * CodedOutputStream::GetDirectBufferForNBytesAndAdvance(\n        int size)\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Extensions in Protocol Buffers\nDESCRIPTION: Illustrates how to declare extensions nested inside another type in a .proto file. This pattern is commonly used to organize related extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_33\n\nLANGUAGE: proto\nCODE:\n```\nmessage Promo {\n  extend Concert {\n    optional int32 promo_id = 124;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Capitalized Field Name from FieldDescriptor in C++\nDESCRIPTION: Function to generate a capitalized camel case field name from a FieldDescriptor object. Requires that the descriptor parameter is not NULL.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_names.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstd::string java::CapitalizedFieldName(\n        const FieldDescriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Protoc Command with API Level Override\nDESCRIPTION: Command line example showing how to override the default API level when using protoc compiler.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc […] --go_opt=default_api_level=API_OPAQUE\n```\n\n----------------------------------------\n\nTITLE: Implementing hashCode() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the hashCode() function to generate a hash code for the ExtensionList. Returns an Int representing the hash code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_4\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen override fun hashCode(): Int\n```\n\n----------------------------------------\n\nTITLE: Invoking Protocol Buffer Compiler for C# Output\nDESCRIPTION: Shows a shell command to invoke the protocol buffer compiler with C#-specific options, including file extension and base namespace settings.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/csharp-generated.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nprotoc --proto_path=src --csharp_out=build/gen --csharp_opt=file_extension=.g.cs,base_namespace=Example,internal_access src/foo.proto\n```\n\n----------------------------------------\n\nTITLE: Adding Source Locations to SourceLocationTable in C++\nDESCRIPTION: Methods to add location information to the SourceLocationTable. Add registers the location of a descriptor element, while AddImport registers the location of an import statement.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.parser.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid Add(const Message* descriptor, DescriptorPool::ErrorCollector::ErrorLocation location, int line, int column)\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid AddImport(const Message* descriptor, const std::string& name, int line, int column)\n```\n\n----------------------------------------\n\nTITLE: Concatenating ByteStrings with Plus Operator in Kotlin\nDESCRIPTION: This function implements the '+' operator for ByteString objects, allowing two ByteString instances to be concatenated together. It takes another ByteString as a parameter and returns a new ByteString containing the combined content.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/plus.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\noperator fun ByteString.plus(other: ByteString): ByteString\n```\n\n----------------------------------------\n\nTITLE: Handling Implicit Field Presence in Objective-C\nDESCRIPTION: This snippet demonstrates how to handle implicit field presence in Objective-C using Protocol Buffers. It checks if a field has a non-zero value and either clears it or sets it to a default value.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_18\n\nLANGUAGE: objective-c\nCODE:\n```\nMsg *m = [Msg message];\nif (m.foo != 0) {\n  // \"Clear\" the field:\n  m.foo = 0;\n} else {\n  // Default value: field may not have been present.\n  m.foo = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Repeated Fields with None in Python (Now Rejected)\nDESCRIPTION: Starting from version 26.x, attempting to extend repeated fields with a None iterable will raise a TypeError. This example demonstrates the now-rejected operation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-01-05.md#2025-04-11_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nm.repeated_int32.extend(None)\n```\n\n----------------------------------------\n\nTITLE: Proto2 Singular Field Definitions\nDESCRIPTION: Example of optional and required field definitions in proto2 syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/kotlin-generated.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\noptional int32 foo = 1;\nrequired int32 foo = 1;\n```\n\n----------------------------------------\n\nTITLE: Using Extension Accessors in Dart\nDESCRIPTION: This snippet demonstrates how to use extension accessors in Dart for a Protocol Buffers message. It shows setting, checking, and getting an extension field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\nFoo foo = Foo();\nfoo.setExtension(Foo_test.bar, 1);\nassert(foo.hasExtension(Foo_test.bar));\nassert(foo.getExtension(Foo_test.bar)) == 1);\n```\n\n----------------------------------------\n\nTITLE: Recursion Depth Management Method Signatures in CodedInputStream\nDESCRIPTION: Collection of method signatures for managing recursion depth in CodedInputStream, including increment, decrement, and combined operations with limits.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_34\n\nLANGUAGE: C++\nCODE:\n```\nbool CodedInputStream::IncrementRecursionDepth()\n\nvoid CodedInputStream::UnsafeDecrementRecursionDepth()\n\nstd::pair<CodedInputStream::Limit, int> CodedInputStream::IncrementRecursionDepthAndPushLimit(int byte_limit)\n\nbool CodedInputStream::DecrementRecursionDepthAndPopLimit(Limit limit)\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Types in Protocol Buffers\nDESCRIPTION: Shows how to declare a message inside another message in a .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GeneratorOptions Struct for JavaScript Protocol Buffer Code Generation in C++\nDESCRIPTION: Defines the GeneratorOptions struct with various configuration options for generating JavaScript code from Protocol Buffers. Includes enums for import style and output mode, as well as options for namespacing, binary format support, and code annotation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.js_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct GeneratorOptions {\n  enum ImportStyle {\n    kImportClosure,\n    kImportCommonJs,\n    kImportCommonJsStrict,\n    kImportBrowser,\n    kImportEs6\n  };\n\n  enum OutputMode {\n    kOneOutputFilePerInputFile,\n    kOneOutputFilePerSCC,\n    kEverythingInOneFile\n  };\n\n  std::string output_dir;\n  std::string namespace_prefix;\n  bool binary;\n  ImportStyle import_style;\n  bool add_require_for_enums;\n  bool testonly;\n  std::string library;\n  bool error_on_name_conflict;\n  std::string extension;\n  bool one_output_file_per_input_file;\n  bool annotate_code;\n\n  GeneratorOptions();\n  bool ParseFromOptions(const std::vector<std::pair<std::string, std::string>>& options, std::string* error);\n  std::string GetFileNameExtension() const;\n  OutputMode output_mode() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Swapping Messages with Oneof Fields in C++\nDESCRIPTION: This snippet demonstrates how swapping two messages with oneof fields results in each message having the other's oneof case. It shows that after swapping, msg1 has a sub_message and msg2 has a name.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto3.md#2025-04-11_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\nSampleMessage msg1;\nmsg1.set_name(\"name\");\nSampleMessage msg2;\nmsg2.mutable_sub_message();\nmsg1.swap(&msg2);\nCHECK(msg1.has_sub_message());\nCHECK_EQ(msg2.name(), \"name\");\n```\n\n----------------------------------------\n\nTITLE: Implementing DslList Class in Kotlin\nDESCRIPTION: Defines a DslList class that wraps a List with an extra generic parameter for extension method disambiguation. It's primarily used internally by Kotlin protocol buffer extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DslList<E, P : DslProxy>(delegate: List<E>) : List<E>\n```\n\n----------------------------------------\n\nTITLE: Defining GzipOutputStream::Options Struct in C++\nDESCRIPTION: This struct defines configuration options for GzipOutputStream. It includes members for format, buffer size, compression level, and compression strategy. The struct also has a default constructor.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.gzip_stream.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nstruct GzipOutputStream::Options {\n  Format format;  // Defaults to GZIP\n  int buffer_size;  // What size buffer to use internally. Defaults to 64kB\n  int compression_level;  // A number between 0 and 9, where 0 is no compression and 9 is best compression\n  int compression_strategy;  // Defaults to Z_DEFAULT_STRATEGY\n  Options();  // Initializes with default values\n};\n```\n\n----------------------------------------\n\nTITLE: Working with Any Type in C++\nDESCRIPTION: Shows how to pack and unpack Any values in C++ using PackFrom() and UnpackTo() methods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\n// Storing an arbitrary message type in Any.\nNetworkErrorDetails details = ...;\nErrorStatus status;\nstatus.add_details()->PackFrom(details);\n\n// Reading an arbitrary message from Any.\nErrorStatus status = ...;\nfor (const google::protobuf::Any& detail : status.details()) {\n  if (detail.Is<NetworkErrorDetails>()) {\n    NetworkErrorDetails network_error;\n    detail.UnpackTo(&network_error);\n    ... processing network_error ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing ExtensionLite Object in Protocol Buffers Kotlin\nDESCRIPTION: Defines a property that exposes the underlying ExtensionLite object for a list of extensions. The ExtensionLite is parameterized with the message type M and a List of elements of type E.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/extension.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nval [extension](): [ExtensionLite]<[M](), [List]<[E]()>>\n```\n\n----------------------------------------\n\nTITLE: Extension Declaration Representation in descriptor.proto\nDESCRIPTION: Shows how extension declarations are represented in descriptor.proto as fields in the proto2.ExtensionRangeOptions message. This defines the structure for storing declaration metadata.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/extension_declarations.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage ExtensionRangeOptions {\n  message Declaration {\n    optional int32 number = 1;\n    optional string full_name = 2;\n    optional string type = 3;\n    optional bool reserved = 5;\n    optional bool repeated = 6;\n  }\n  repeated Declaration declaration = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Objective-C Unknown Fields API Update\nDESCRIPTION: GPBUnknownFieldSet is being deprecated and replaced with GPBUnknownFields to preserve field ordering. Various field handling methods are being removed or changed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_2\n\nLANGUAGE: Objective-C\nCODE:\n```\n// Deprecated:\n[GPBMessage unknownFields]\nvarintList\nfixed32List\nfixed64List\nlengthDelimitedList\ngroupList\n\n// New properties:\ntype\nvarint\nfixed32\nfixed64\nlengthDelimited\ngroup\n```\n\n----------------------------------------\n\nTITLE: Defining Hugo Frontmatter for Protocol Buffers Documentation\nDESCRIPTION: This TOML frontmatter configuration sets up metadata for a Protocol Buffers reference documentation page in Hugo. It defines the page title, weight for ordering in navigation, link title, description, and specifies the page type as documentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"Protocol Buffers Reference\"\nweight = 790\nlinkTitle = \"Protocol Buffers\"\ndescription = \"Language-agnostic information about how to use protocol buffers.\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Handling Explicit Field Presence in Objective-C\nDESCRIPTION: This snippet shows how to handle explicit field presence in Objective-C using Protocol Buffers. It uses the hasFoo method to check if the field is present, and then either clears it or sets it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/field_presence.md#2025-04-11_snippet_19\n\nLANGUAGE: objective-c\nCODE:\n```\nMsg *m = [Msg message];\nif ([m hasFoo]) {\n  // Clear the field:\n  [m clearFoo];\n} else {\n  // Field is not present, so set it.\n  m.foo = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Packed Int32 to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed int32 values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_48\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteInt32Packed(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Message in Proto\nDESCRIPTION: Example proto definition for a Foo message type with various field types including scalar, bytes, oneof union, and enum.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/opaque-migration-manual.md#2025-04-11_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Foo {\n  uint32 uint32 = 1;\n  bytes bytes = 2;\n  oneof union {\n    string    string = 4;\n    MyMessage message = 5;\n  }\n  enum Kind { … };\n  Kind kind = 9;\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Runtime Imports in C++\nDESCRIPTION: Static method to print runtime imports. Takes an io::Printer, a vector of headers to import, a runtime import prefix, and an optional default_cpp_symbol flag.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nstatic void PrintRuntimeImports(io::Printer* printer, const std::vector<std::string>& header_to_import, const std::string& runtime_import_prefix, bool default_cpp_symbol = false)\n```\n\n----------------------------------------\n\nTITLE: Adding Comments in Proto2\nDESCRIPTION: Shows different ways to add documentation comments in proto2 files, including C-style block comments and line comments.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_3\n\nLANGUAGE: proto2\nCODE:\n```\n/**\n * SearchRequest represents a search query, with pagination options to\n * indicate which results to include in the response.\n */\nmessage SearchRequest {\n  optional string query = 1;\n\n  // Which page number do we want?\n  optional int32 page_number = 2;\n\n  // Number of results to return per page.\n  optional int32 results_per_page = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing equals method for DslList in Protocol Buffers Kotlin\nDESCRIPTION: Implementation of the equals method for the DslList class, which compares the current instance with another object for equality. Returns a Boolean indicating if the objects are equal.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/_index.md#2025-04-11_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nopen operator override fun equals(other: Any?): Boolean\n```\n\n----------------------------------------\n\nTITLE: Finding All Package Names in DescriptorDatabase (C++)\nDESCRIPTION: Method that finds all package names and appends them to the output vector. Returns true if the database supports searching all package names, false otherwise.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor_database.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nbool DescriptorDatabase::FindAllPackageNames(\n        std::vector< std::string > * output)\n```\n\n----------------------------------------\n\nTITLE: Handling Name Conflicts in Protocol Buffers\nDESCRIPTION: Example showing how field name conflicts are resolved by appending field numbers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-generated.md#2025-04-11_snippet_16\n\nLANGUAGE: proto\nCODE:\n```\nint32 foos_count = 1;\nrepeated string foos = 2;\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterator for ExtensionList in Protobuf Kotlin\nDESCRIPTION: Defines an operator function that implements the Iterator interface for ExtensionList class. Returns an Iterator of generic type E, using the standard Kotlin collections Iterator interface.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/iterator.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen operator override fun iterator(): Iterator<E>\n```\n\n----------------------------------------\n\nTITLE: Generator Parameter Parsing Example in C++\nDESCRIPTION: Example showing how comma-delimited name/value pairs are parsed by ParseGeneratorParameter function. Demonstrates parsing format for generator options.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.code_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n(\"foo\", \"bar\"), (\"baz\", \"\"), (\"qux\", \"corge\")\n```\n\n----------------------------------------\n\nTITLE: Using message_factory.GetMessageClass in Python\nDESCRIPTION: The reflection.ParseMessage and reflection.MakeClass methods are being removed in v30. Code should use message_factory.GetMessageClass() instead for creating message classes from descriptors.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v30.md#2025-04-11_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Old deprecated methods:\nreflection.ParseMessage\nreflection.MakeClass\n\n# New replacement method:\nmessage_factory.GetMessageClass()\n```\n\n----------------------------------------\n\nTITLE: Defining EBNF Notation for Protocol Buffers\nDESCRIPTION: Explains the Extended Backus-Naur Form notation used throughout the specification to define the Protocol Buffers language syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\n|   alternation\n()  grouping\n[]  option (zero or one time)\n{}  repetition (any number of times)\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Reserved Names Syntax\nDESCRIPTION: Shows the updated syntax for reserving field names and enum value names in Protocol Buffers editions, where quotation marks are no longer required around the names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/overview.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nreserved foo, bar;\n```\n\n----------------------------------------\n\nTITLE: Skipping Bytes in Protocol Buffers CodedOutputStream\nDESCRIPTION: Method that skips a number of bytes, leaving them unmodified in the buffer. Returns false if a write error occurs. Caution: skipped bytes may contain uninitialized data that could leak heap memory if not properly initialized.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_89\n\nLANGUAGE: C++\nCODE:\n```\nbool CodedOutputStream::Skip(\n        int count)\n```\n\n----------------------------------------\n\nTITLE: Proto Message with Singular Message Field\nDESCRIPTION: Examples showing how to define a message field in both proto2 and proto3. Both result in pointer types in Go.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/go/go-generated.md#2025-04-11_snippet_12\n\nLANGUAGE: proto\nCODE:\n```\n// proto2\nmessage Concert {\n  optional Band headliner = 1;\n  // The generated code is the same result if required instead of optional.\n}\n\n// proto3\nmessage Concert {\n  Band headliner = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing DynamicMessageFactory with Custom DescriptorPool in C++\nDESCRIPTION: Creates a DynamicMessageFactory instance that searches for extensions in a specified DescriptorPool. This constructor is deprecated.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.dynamic_message.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nDynamicMessageFactory(const DescriptorPool* pool)\n```\n\n----------------------------------------\n\nTITLE: Reserving Field Numbers in Protocol Buffers\nDESCRIPTION: Demonstrates how to reserve field numbers in a Protocol Buffers message definition to prevent future reuse of deleted field numbers. This helps avoid potential issues caused by field number conflicts.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n}\n```\n\n----------------------------------------\n\nTITLE: Objective-C Class Prefix Validation Function\nDESCRIPTION: Function declaration for validating Objective-C class prefixes across multiple files. Returns false and sets error message if validation fails.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nbool objectivec::ValidateObjCClassPrefixes(\n        const std::vector<const FileDescriptor*>& files,\n        const Options& generation_options,\n        std::string* out_error)\n```\n\n----------------------------------------\n\nTITLE: FieldDescriptor Method Declarations in C++\nDESCRIPTION: C++ method declarations for accessing field metadata in Protocol Buffers including name, type, label and other attributes.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nstd::atomic<const Message*> default_generated_instance_;\nconst std::string& name() const;\nconst std::string& full_name() const;\nconst std::string& json_name() const;\nconst FileDescriptor* file() const;\nbool is_extension() const;\nint number() const;\nconst std::string& lowercase_name() const;\nconst std::string& camelcase_name() const;\nType type() const;\nconst char* type_name() const;\nCppType cpp_type() const;\nconst char* cpp_type_name() const;\nLabel label() const;\nbool is_required() const;\nbool is_optional() const;\nbool is_repeated() const;\nbool is_packable() const;\nbool is_packed() const;\nbool is_map() const;\nbool has_optional_keyword() const;\nbool has_presence() const;\nint index() const;\nbool has_default_value() const;\n```\n\n----------------------------------------\n\nTITLE: Writing Tag to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a Protocol Buffers tag (field number and wire type) directly to a target array. Similar to WriteTag() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_104\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteTagToArray(uint32 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Implementing iterator() Function in Kotlin for ExtensionList\nDESCRIPTION: Overrides the iterator() function to provide an Iterator for the ExtensionList, allowing iteration over its elements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/_index.md#2025-04-11_snippet_5\n\nLANGUAGE: Kotlin\nCODE:\n```\nopen operator override fun iterator(): Iterator<E>\n```\n\n----------------------------------------\n\nTITLE: Getting Enum Descriptor for CodeGeneratorResponse_Feature in C++\nDESCRIPTION: Declares a function to retrieve the EnumDescriptor for the CodeGeneratorResponse_Feature enum. This is used for reflection and metadata access in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb.md#2025-04-11_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nconst EnumDescriptor * GetEnumDescriptor< protobuf::compiler::CodeGeneratorResponse_Feature >();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python Nested Message Class __qualname__ Change\nDESCRIPTION: This snippet shows how the __qualname__ attribute of a nested message class now includes the outer message name in Python, which is a change introduced in v30.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v30.md#2025-04-11_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmessage Foo {\n  message Bar {\n    bool bool_field = 1;\n  }\n}\nnested = test_pb2.Foo.Bar()\nself.assertEqual('Bar', nested.__class__.__name__)\nself.assertEqual('Foo.Bar', nested.__class__.__qualname__) # It was 'Bar' before\n```\n\n----------------------------------------\n\nTITLE: Defining Constants in Protocol Buffers\nDESCRIPTION: Specifies the syntax for constants in Protocol Buffers, which can be identifiers, numeric literals, string literals, boolean literals, or message values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_8\n\nLANGUAGE: EBNF\nCODE:\n```\nconstant = fullIdent | ( [ \"-\" | \"+\" ] intLit ) | ( [ \"-\" | \"+\" ] floatLit ) |\n                strLit | boolLit | MessageValue\n```\n\n----------------------------------------\n\nTITLE: Legacy Closed Enum Configuration Example\nDESCRIPTION: Demonstrates configuration of legacy closed enum behavior in proto2 and Edition 2023.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_9\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto2\";\n\nimport \"myproject/proto3file.proto\";\n\nmessage Msg {\n  myproject.proto3file.Proto3Enum name = 1;\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nimport \"myproject/proto3file.proto\";\n\nimport \"google/protobuf/cpp_features.proto\";\nimport \"google/protobuf/java_features.proto\";\n\nmessage Msg {\n  myproject.proto3file.Proto3Enum name = 1 [\n    features.(pb.cpp).legacy_closed_enum = true,\n    features.(pb.java).legacy_closed_enum = true\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: OstreamOutputStream BackUp Method Implementation\nDESCRIPTION: Virtual method that allows backing up a number of bytes in the output stream, preventing the last portion of the buffer from being written. Used when the last buffer was larger than needed.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl.md#2025-04-11_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void OstreamOutputStream::BackUp(\n        int count)\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Extension in Protocol Buffers\nDESCRIPTION: This snippet shows how to define a nested extension within a message in Protocol Buffers. It defines an extension 'bar' nested inside a 'Baz' message.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_21\n\nLANGUAGE: proto\nCODE:\n```\nmessage Baz {\n  extend Foo {\n    optional int32 bar = 124;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: AnnotationCollector Destructor Declaration in C++\nDESCRIPTION: Declaration of the virtual destructor for the AnnotationCollector class.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvirtual ~AnnotationCollector()\n```\n\n----------------------------------------\n\nTITLE: Reserving Field Names in Protocol Buffers\nDESCRIPTION: Shows how to reserve field names in a Protocol Buffers message definition. This prevents reuse of deleted field names, which is particularly important for TextProto and JSON encodings where field names are serialized.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/proto2.md#2025-04-11_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n  reserved \"foo\", \"bar\";\n}\n```\n\n----------------------------------------\n\nTITLE: Printing ImportWriter Content in C++\nDESCRIPTION: Prints the content of the ImportWriter using the provided io::Printer object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvoid Print(io::Printer* printer) const\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Compiler Core\nDESCRIPTION: Core compiler components including code generator interface, command line interface, parser, and plugin infrastructure\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/_index.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\ngoogle/protobuf/compiler/code_generator.h\ngoogle/protobuf/compiler/command_line_interface.h\ngoogle/protobuf/compiler/importer.h\ngoogle/protobuf/compiler/parser.h\ngoogle/protobuf/compiler/plugin.h\ngoogle/protobuf/compiler/plugin.pb.h\n```\n\n----------------------------------------\n\nTITLE: Defining Field Names in Protocol Buffers Text Format\nDESCRIPTION: EBNF grammar specifying the syntax for regular, extension, and Any field names in Protocol Buffers text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_14\n\nLANGUAGE: ebnf\nCODE:\n```\nFieldName     = ExtensionName | AnyName | IDENT ;\nExtensionName = \"[\", TypeName, \"]\" ;\nAnyName       = \"[\", Domain, \"/\", TypeName, \"]\" ;\nTypeName      = IDENT, { \".\", IDENT } ;\nDomain        = IDENT, { \".\", IDENT } ;\n```\n\n----------------------------------------\n\nTITLE: Accessing Keys of DslMap in Kotlin Protocol Buffers\nDESCRIPTION: This property provides access to the set of keys in a DslMap. It returns a Set of type K, where K is the key type of the DslMap. The property is open and overrides a superclass implementation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/keys.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override val keys(): Set<K>\n```\n\n----------------------------------------\n\nTITLE: Including the Descriptor Header in C++\nDESCRIPTION: Shows how to include the necessary header file for using the Descriptor class in C++.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/descriptor.h>\n```\n\n----------------------------------------\n\nTITLE: Defining Student message with imports in Protocol Buffers\nDESCRIPTION: This snippet defines a Student message that imports and uses StudentId and FullName messages. It demonstrates how to compose more complex messages using imports while following the 1-1-1 principle.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/1-1-1.md#2025-04-11_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\npackage my.package;\n\nimport \"student_id.proto\";\nimport \"full_name.proto\";\n\nmessage Student {\n  StudentId id = 1;\n  FullName name = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Arena::Create Instead of Deprecated Arena::CreateMessage in C++\nDESCRIPTION: The Arena::CreateMessage method is being removed in v30. Code should be updated to use Arena::Create instead, which is the recommended replacement for object creation on an arena.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v30.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// Old deprecated method:\nArena::CreateMessage\n\n// New replacement method:\nArena::Create\n```\n\n----------------------------------------\n\nTITLE: Get class name for C# code generation in Protocol Buffers\nDESCRIPTION: Returns the fully-qualified C# class name for a given message descriptor. Requires that the descriptor is not null.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.csharp_names.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::string csharp::GetClassName(\n        const Descriptor * descriptor)\n```\n\n----------------------------------------\n\nTITLE: Accessing Extensions in FileDescriptor (C++)\nDESCRIPTION: Gets an extension descriptor by index, where the index must be between 0 and extension_count(). Extensions are returned in the order they were defined in the .proto file.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_90\n\nLANGUAGE: C++\nCODE:\n```\nconst FieldDescriptor * \n    FileDescriptor::extension(\n        int index) const\n```\n\n----------------------------------------\n\nTITLE: AnnotationProtoCollector::AddAnnotationNew Method Implementation in C++\nDESCRIPTION: Declaration of the overridden AddAnnotationNew method in AnnotationProtoCollector that implements the base class virtual method.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.printer.md#2025-04-11_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void AddAnnotationNew(Annotation & a)\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Extensions in C++\nDESCRIPTION: Shows how to access and set nested extension fields in C++ code.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/editions.md#2025-04-11_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\nUserProfile user_profile;\nuser_profile.SetExtension(puppies::Photo::likes_count, 42);\n```\n\n----------------------------------------\n\nTITLE: Getting Repeated Pointer Field in Protocol Buffers C++\nDESCRIPTION: DEPRECATED. Use GetRepeatedFieldRef() instead. Applicable for T = std::string, google::protobuf::internal::StringPieceField, and google::protobuf::Message & descendants.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.message.md#2025-04-11_snippet_68\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nconst RepeatedPtrField<T>& Reflection::GetRepeatedPtrField(\n    const Message& msg,\n    const FieldDescriptor* d) const\n```\n\n----------------------------------------\n\nTITLE: Using System Property to Allow Unsafe Java Gencode in Protocol Buffers\nDESCRIPTION: A system property flag that can be used as a temporary workaround to allow older, potentially vulnerable Java gencode to work. This should only be used as a short-term solution if immediate code updates aren't possible.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2025-01-23.md#2025-04-11_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n-Dcom.google.protobuf.use_unsafe_pre22_gencode\n```\n\n----------------------------------------\n\nTITLE: Implementing toString Method in Kotlin DslList Class\nDESCRIPTION: Method declaration showing the toString() override in the DslList class. Returns a String representation of the DslList object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/to-string.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen override fun toString(): String\n```\n\n----------------------------------------\n\nTITLE: Accessing Service Full Name in C++\nDESCRIPTION: Method to access the fully-qualified name of the service, with scope delimited by periods.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_66\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string & full_name() const\n```\n\n----------------------------------------\n\nTITLE: Using String IDs with Serialized Internal References in Protocol Buffers\nDESCRIPTION: Example demonstrating how to use string fields for IDs instead of integers, allowing for more flexibility and the ability to encode structured identifiers as opaque strings.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage GetFooRequest {\n  // Which Foo to fetch.\n  optional string foo_id;\n}\n\n// Serialized and websafe-base64-encoded into the GetFooRequest.foo_id field.\nmessage InternalFooRef {\n  // Only one of these two is set. Foos that have already been\n  // migrated use the spanner_foo_id and Foos still living in\n  // Caribou Storage Server have a classic_foo_id.\n  optional bytes spanner_foo_id;\n  optional int64 classic_foo_id;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EBNF Notation for Protocol Buffers\nDESCRIPTION: Specifies the Extended Backus-Naur Form (EBNF) notation used throughout the document to define Protocol Buffer syntax rules.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto3-spec.md#2025-04-11_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\n|   alternation\n()  grouping\n[]  option (zero or one time)\n{}  repetition (any number of times)\n```\n\n----------------------------------------\n\nTITLE: Encoding JSON in Ruby Protocol Buffers\nDESCRIPTION: This snippet shows the C implementation of the encode_json function in the Ruby extension for Protocol Buffers. It uses the message's pool for encoding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v26.md#2025-04-11_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nencode_json\n```\n\n----------------------------------------\n\nTITLE: Defining ObjectiveCType Enum for Protocol Buffer Types\nDESCRIPTION: Enum defining the mapping of protocol buffer types to Objective-C types. Includes basic types like int32, uint32, as well as complex types like enums and messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nenum objectivec::ObjectiveCType {\n  OBJECTIVECTYPE_INT32,\n  OBJECTIVECTYPE_UINT32,\n  OBJECTIVECTYPE_INT64,\n  OBJECTIVECTYPE_UINT64,\n  OBJECTIVECTYPE_FLOAT,\n  OBJECTIVECTYPE_DOUBLE,\n  OBJECTIVECTYPE_BOOLEAN,\n  OBJECTIVECTYPE_STRING,\n  OBJECTIVECTYPE_DATA,\n  OBJECTIVECTYPE_ENUM,\n  OBJECTIVECTYPE_MESSAGE\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Print Method in MessagePrinter Class\nDESCRIPTION: Pure virtual method for printing protocol buffer messages with optional single line mode using a text generator.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void Print(const Message& message, bool single_line_mode, BaseTextGenerator* generator) const = 0\n```\n\n----------------------------------------\n\nTITLE: Implementing GetTreeForNested Method in ParseInfoTree Class\nDESCRIPTION: Method to retrieve parse info tree for nested message fields. Returns owned tree that will be deleted when root tree is deleted.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nParseInfoTree* ParseInfoTree::GetTreeForNested(\n    const FieldDescriptor* field,\n    int index) const\n```\n\n----------------------------------------\n\nTITLE: Calculating Sign-Extended 32-bit Varint Size in Protocol Buffers\nDESCRIPTION: Static method that returns the number of bytes needed for a sign-extended 32-bit integer. Returns 10 bytes if negative, otherwise same as VarintSize32().\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_107\n\nLANGUAGE: C++\nCODE:\n```\nstatic size_t VarintSize32SignExtended(int32 value)\n```\n\n----------------------------------------\n\nTITLE: Defining Literals in Protocol Buffers Text Format\nDESCRIPTION: EBNF grammar defining various literal types in Protocol Buffers text format, including strings, floats, identifiers, and integer representations.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_12\n\nLANGUAGE: ebnf\nCODE:\n```\nString             = STRING, { STRING } ;\nFloat              = [ \"-\" ], FLOAT ;\nIdentifier         = IDENT ;\nSignedIdentifier   = \"-\", IDENT ;   (* For example, \"-inf\" *)\nDecSignedInteger   = \"-\", DEC_INT ;\nOctSignedInteger   = \"-\", OCT_INT ;\nHexSignedInteger   = \"-\", HEX_INT ;\nDecUnsignedInteger = DEC_INT ;\nOctUnsignedInteger = OCT_INT ;\nHexUnsignedInteger = HEX_INT ;\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Code for Enum Synonym\nDESCRIPTION: This snippet shows how the Protocol Buffers compiler generates Dart code for enum synonyms. It defines 'BAZ' as a static constant equal to 'BAR'.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nstatic const Foo BAZ = BAR;\n```\n\n----------------------------------------\n\nTITLE: GBP<KEY>EnumDictionary Interface Implementation in Objective-C\nDESCRIPTION: A specialized dictionary interface for Protocol Buffers in Objective-C that handles enum values. This interface includes validation functions and provides methods for working with both validated enum values and raw integer values.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_19\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPB<KEY>EnumDictionary : NSObject\n\n@property(nonatomic, readonly) NSUInteger count;\n@property(nonatomic, readonly) GPBEnumValidationFunc validationFunc;\n\n+ (instancetype)dictionary;\n+ (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func;\n+ (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                        rawValue:(int32_t)rawValue\n                                          forKey:(<KEY>_t)key;\n+ (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                       rawValues:(const int32_t [])values\n                                         forKeys:(const <KEY>_t [])keys\n                                           count:(NSUInteger)count;\n+ (instancetype)dictionaryWithDictionary:(GPB<KEY>EnumDictionary *)dictionary;\n+ (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                        capacity:(NSUInteger)numItems;\n\n- (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func;\n- (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                 rawValues:(const int32_t [])values\n                                   forKeys:(const <KEY>_t [])keys\n                                     count:(NSUInteger)count NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithDictionary:(GPB<KEY>EnumDictionary *)dictionary;\n- (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func\n                                  capacity:(NSUInteger)numItems;\n\n// These will return kGPBUnrecognizedEnumeratorValue if the value for the key\n// is not a valid enumerator as defined by validationFunc. If the actual value is\n// desired, use \"raw\" version of the method.\n\n- (BOOL)valueForKey:(<KEY>_t)key value:(nullable int32_t *)value;\n\n- (void)enumerateKeysAndValuesUsingBlock:\n    (void (^)(<KEY>_t key, int32_t value, BOOL *stop))block;\n\n// These methods bypass the validationFunc to provide access to values that were not\n// known at the time the binary was compiled.\n\n- (BOOL)valueForKey:(<KEY>_t)key rawValue:(nullable int32_t *)rawValue;\n\n- (void)enumerateKeysAndRawValuesUsingBlock:\n    (void (^)(<KEY>_t key, int32_t rawValue, BOOL *stop))block;\n\n- (void)addRawEntriesFromDictionary:(GPB<KEY>EnumDictionary *)otherDictionary;\n\n// If value is not a valid enumerator as defined by validationFunc, these\n// methods will assert in debug, and will log in release and assign the value\n// to the default value. Use the rawValue methods below to assign non enumerator\n// values.\n\n- (void)setValue:(int32_t)value forKey:(<KEY>_t)key;\n\n// This method bypass the validationFunc to provide setting of values that were not\n// known at the time the binary was compiled.\n- (void)setRawValue:(int32_t)rawValue forKey:(<KEY>_t)key;\n\n// No validation applies to these methods.\n\n- (void)removeValueForKey:(<KEY>_t)aKey;\n- (void)removeAll;\n\n@end\n```\n\n----------------------------------------\n\nTITLE: Including the Java Generator Header in C++\nDESCRIPTION: Shows how to include the Java generator header file in your C++ code. This is necessary when you need to use the JavaGenerator class to generate Java code from Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.java_generator.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <google/protobuf/compiler/java/java_generator.h>\n```\n\n----------------------------------------\n\nTITLE: ErrorCollector::AddWarning Method Signature in C++\nDESCRIPTION: Virtual method for reporting warnings in a FileDescriptorProto. Used when a problem should NOT interrupt the building of the FileDescriptorProto.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_152\n\nLANGUAGE: C++\nCODE:\n```\nvirtual void ErrorCollector::AddWarning(\n        const std::string & ,\n        const std::string & ,\n        const Message * ,\n        ErrorLocation ,\n        const std::string & )\n```\n\n----------------------------------------\n\nTITLE: Designing Consistent Request Options for API Endpoints\nDESCRIPTION: Demonstrates how to create a unified request options message that can be reused across multiple API endpoints returning the same data type. This approach reduces complexity and prevents bugs related to inconsistent request handling.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/api.md#2025-04-11_snippet_11\n\nLANGUAGE: proto\nCODE:\n```\nmessage FooRequestOptions {\n  // Field-level read mask of which fields to return. Only fields that\n  // were requested will be returned in the response. Clients should only\n  // ask for fields they need to help the backend optimize requests.\n  optional FooReadMask read_mask;\n\n  // Up to this many comments will be returned on each Foo in the response.\n  // Comments that are marked as spam don't count towards the maximum\n  // comments. By default, no comments are returned.\n  optional int max_comments_to_return;\n\n  // Foos that include embeds that are not on this supported types list will\n  // have the embeds down-converted to an embed specified in this list. If no\n  // supported types list is specified, no embeds will be returned. If an embed\n  // can't be down-converted to one of the supplied supported types, no embed\n  // will be returned. Clients are strongly encouraged to always include at\n  // least the THING_V2 embed type from EmbedTypes.proto.\n  repeated EmbedType embed_supported_types_list;\n}\n\nmessage GetFooRequest {\n  // What Foo to read. If the viewer doesn't have access to the Foo or the\n  // Foo has been deleted, the response will be empty but will succeed.\n  optional string foo_id;\n\n  // Clients are required to include this field. Server returns\n  // INVALID_ARGUMENT if FooRequestOptions is left empty.\n  optional FooRequestOptions params;\n}\n\nmessage ListFooRequest {\n  // Which Foos to return. Searches have 100% recall, but more clauses\n  // impact performance.\n  optional FooQuery query;\n\n  // Clients are required to include this field. The server returns\n  // INVALID_ARGUMENT if FooRequestOptions is left empty.\n  optional FooRequestOptions params;\n}\n```\n\n----------------------------------------\n\nTITLE: EBNF Representation of Character Definitions\nDESCRIPTION: Extended Backus-Naur Form (EBNF) syntax defining character sets and basic elements used in the Protocol Buffer Text Format specification.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_6\n\nLANGUAGE: ebnf\nCODE:\n```\nchar    = ? Any non-NUL unicode character ? ;\nnewline = ? ASCII #10 (line feed) ? ;\n\nletter = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\"\n       | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"\n       | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\"\n       | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"\n       | \"_\" ;\n\noct = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" ;\ndec = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\nhex = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n    | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n    | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" ;\n```\n\n----------------------------------------\n\nTITLE: Handling Poisoned Java Gencode in Protocol Buffers\nDESCRIPTION: Java gencode created before version 3.21.7 will be poisoned in the 25.x branch. To temporarily bypass this, users can set a system property, but this should only be used as a short-term workaround.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v25.md#2025-04-11_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\n// Set this system property to temporarily allow use of unsafe pre-22 gencode\n-Dcom.google.protobuf.use_unsafe_pre22_gencode\n```\n\n----------------------------------------\n\nTITLE: Invoking Protoc Plugin from Command Line\nDESCRIPTION: This snippet shows how to invoke a protoc plugin by specifying its path with the --plugin parameter. The plugin is given a name (NAME) and an output directory (OUT_DIR).\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.md#2025-04-11_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nprotoc --plugin=protoc-gen-NAME=path/to/mybinary --NAME_out=OUT_DIR\n```\n\n----------------------------------------\n\nTITLE: Writing Packed Int64 to EpsCopyOutputStream in C++\nDESCRIPTION: Template method for writing packed int64 values to the stream with a field number.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_51\n\nLANGUAGE: C++\nCODE:\n```\ntemplate uint8* WriteInt64Packed(int num, const T& r, int size, uint8* ptr)\n```\n\n----------------------------------------\n\nTITLE: Markdown Frontmatter Configuration for C++ API Documentation\nDESCRIPTION: Markdown frontmatter block that configures page metadata including title, manual link, link target and weight for the C++ API documentation page.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: \"C++ API\"\nmanualLink: \"/reference/cpp/api-docs/\"\nmanualLinkTarget: \"_blank\"\nweight: 530\n---\n```\n\n----------------------------------------\n\nTITLE: Defining ExtensionList Function in Kotlin for Protobuf\nDESCRIPTION: This function creates an ExtensionList for a given extension and delegate list. It uses generic types E and M, where M must be a subtype of MessageLite. The function takes an ExtensionLite and a List as parameters.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/-extension-list.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\nfun <E, M : MessageLite> ExtensionList(\n    extension: ExtensionLite<M, List<E>>,\n    delegate: List<E>\n)\n```\n\n----------------------------------------\n\nTITLE: TextFormat Printer Class Methods\nDESCRIPTION: Class methods for fine-grained control over protocol buffer message printing including formatting options and output customization.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.text_format.md#2025-04-11_snippet_23\n\nLANGUAGE: C++\nCODE:\n```\nclass TextFormat::Printer {\npublic:\n  Printer();\n  bool Print(const Message& message, io::ZeroCopyOutputStream* output) const;\n  bool PrintUnknownFields(const UnknownFieldSet& unknown_fields, io::ZeroCopyOutputStream* output) const;\n  bool PrintToString(const Message& message, std::string* output) const;\n  bool PrintUnknownFieldsToString(const UnknownFieldSet& unknown_fields, std::string* output) const;\n  void PrintFieldValueToString(const Message& message, const FieldDescriptor* field, int index, std::string* output) const;\n  void SetInitialIndentLevel(int indent_level);\n  void SetSingleLineMode(bool single_line_mode);\n  bool IsInSingleLineMode() const;\n  void SetUseFieldNumber(bool use_field_number);\n  void SetUseShortRepeatedPrimitives(bool use_short_repeated_primitives);\n  void SetUseUtf8StringEscaping(bool as_utf8);\n  void SetDefaultFieldValuePrinter(const FastFieldValuePrinter* printer);\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing OnlyForUseByGeneratedProtoCode Constructor in Kotlin Protocol Buffers\nDESCRIPTION: Constructor function that is restricted for use only by Protocol Buffer generated code. This is part of the com.google.protobuf.kotlin package and runs on the JVM platform.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/-only-for-use-by-generated-proto-code.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nfun OnlyForUseByGeneratedProtoCode()\n```\n\n----------------------------------------\n\nTITLE: Generator Options Boolean Property\nDESCRIPTION: Defines a boolean option that controls whether to append annotations as comments for cross-reference purposes between .js and .proto files using base64 encoded GeneratedCodeInfo messages.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.js_generator.md#2025-04-11_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nbool GeneratorOptions::annotate_code\n```\n\n----------------------------------------\n\nTITLE: Defining TOML Metadata for Protocol Buffers C# Documentation\nDESCRIPTION: This TOML snippet defines metadata for a documentation page about Protocol Buffers in C#. It includes the page title, weight for ordering, link title, description, and content type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/csharp/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n+++\ntitle = \"C# Reference\"\nweight = 540\nlinkTitle = \"C#\"\ndescription = \"Reference documentation for working with protocol buffer classes in C#\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Embedding Edition Defaults in Source Files with Bazel\nDESCRIPTION: Bazel macro for embedding compiled edition defaults into a raw string literal in source code. It specifies input defaults, output file, and template with a placeholder for the embedded data.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/implementation.md#2025-04-11_snippet_3\n\nLANGUAGE: bzl\nCODE:\n```\nembed_edition_defaults(\n    name = \"embed_my_defaults\",\n    defaults = \":my_defaults\",\n    output = \"my_defaults.h\",\n    placeholder = \"DEFAULTS_DATA\",\n    template = \"my_defaults.h.template\",\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Hugo Page Frontmatter for Protocol Buffers Python Reference\nDESCRIPTION: Hugo frontmatter block that defines metadata for a Protocol Buffers Python reference documentation page. It specifies the title, weight for ordering in navigation, link title, description, and content type.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/python/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n+++\ntitle = \"Python Reference\"\nweight = 740\nlinkTitle = \"Python\"\ndescription = \"Reference documentation for working with protocol buffer classes in Python.\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Example Proto File with Import Dependencies\nDESCRIPTION: Example showing potential import path issues with two proto files where one imports the other.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v23.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\n// foo/bar.proto\n\nsyntax = \"proto2\";\n\nmessage Bar {}\n```\n\nLANGUAGE: proto\nCODE:\n```\n// foo/baz.proto\n\nsyntax = \"proto2\";\n\nimport \"bar.proto\";\n\nmessage Baz {\n  optional Bar bar = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating CodeGeneratorRequest Message in Protocol Buffers C++ API\nDESCRIPTION: Defines a function to create a CodeGeneratorRequest message, possibly in an Arena-allocated memory. This is part of the Protocol Buffers compiler API.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nPROTOBUF_NAMESPACE_CLOSE PROTOBUF_NAMESPACE_OPEN protobuf::compiler::CodeGeneratorRequest * Arena::CreateMaybeMessage< protobuf::compiler::CodeGeneratorRequest >(Arena * );\n```\n\n----------------------------------------\n\nTITLE: Defining Normal Fields in Protocol Buffers\nDESCRIPTION: Specifies the syntax for normal fields in Protocol Buffers, including field options that can be applied to a field.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/edition-2023-spec.md#2025-04-11_snippet_17\n\nLANGUAGE: EBNF\nCODE:\n```\nfield = [label] type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"\nfieldOptions = fieldOption { \",\"  fieldOption }\nfieldOption = optionName \"=\" constant\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer File Optimization Mode Enumeration\nDESCRIPTION: Specifies optimization modes for protocol buffer files, allowing control over speed, code size, and runtime characteristics.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_34\n\nLANGUAGE: protobuf\nCODE:\n```\nenum protobuf::FileOptions_OptimizeMode {\n  FileOptions_OptimizeMode_SPEED = 1,\n  FileOptions_OptimizeMode_CODE_SIZE = 2,\n  FileOptions_OptimizeMode_LITE_RUNTIME = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Descriptor Table for Protocol Buffers Compiler Plugin in C++\nDESCRIPTION: Declares a constant DescriptorTable for the Protocol Buffers compiler plugin. This table likely contains metadata about the plugin's protocol definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb.md#2025-04-11_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconst ::protobuf::internal::DescriptorTable descriptor_table_google_2fprotobuf_2fcompiler_2fplugin_2eproto;\n```\n\n----------------------------------------\n\nTITLE: Disabling String View for Enum Name Helper\nDESCRIPTION: Example of disabling the string_view feature for enum name helpers using feature override.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/string-view.md#2025-04-11_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo {\n  option features.(pb.cpp).enum_name_uses_string_view = false;\n\n  VALUE_A = 0;\n  VALUE_B = 5;\n  VALUE_C = 1234;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Sign-Extended 32-bit Varint to Array in Protocol Buffers\nDESCRIPTION: Static method that writes a sign-extended 32-bit integer as a variable-length encoded value directly to a target array. Similar to WriteVarint32SignExtended() but writes to an array instead of a stream.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.coded_stream.md#2025-04-11_snippet_103\n\nLANGUAGE: C++\nCODE:\n```\nstatic uint8 * WriteVarint32SignExtendedToArray(int32 value, uint8 * target)\n```\n\n----------------------------------------\n\nTITLE: Configuring TOML Front Matter for Objective-C Protocol Buffers Documentation\nDESCRIPTION: This TOML front matter block configures metadata for a documentation page about Protocol Buffers in Objective-C. It defines the page title, navigation weight, link title, description, and content type as documentation.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"Objective-C Reference\"\nweight = 700\nlinkTitle = \"Objective-C\"\ndescription = \"Reference documentation for working with protocol buffer classes in Objective-C.\"\ntype = \"docs\"\n+++\n```\n\n----------------------------------------\n\nTITLE: Field Naming in Protocol Buffers\nDESCRIPTION: Demonstrates the correct lower_snake_case naming for regular and repeated fields in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/programming-guides/style.md#2025-04-11_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nstring song_name = 1;\nrepeated Song songs = 2;\n```\n\n----------------------------------------\n\nTITLE: Viewing Full Dependency Graph with Bazel\nDESCRIPTION: Demonstrates how to use the 'bazel mod graph' command to visualize the complete dependency tree including Abseil and its transitive dependencies for Protocol Buffers projects.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/abseil.md#2025-04-11_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ bazel mod graph --enable_bzlmod\n<root> (protobuf@30.0-dev)\n├───abseil-cpp@20240722.0\n│   ├───bazel_skylib@1.7.1 (*)\n│   ├───googletest@1.15.2 (*)\n│   └───platforms@0.0.10 (*)\n├───bazel_features@1.18.0\n│   └───bazel_skylib@1.7.1 (*)\n├───bazel_skylib@1.7.1\n│   ├───platforms@0.0.10 (*)\n│   └───rules_license@1.0.0 (*)\n├───googletest@1.15.2\n│   ├───abseil-cpp@20240722.0 (*)\n│   ├───platforms@0.0.10 (*)\n│   └───re2@2024-07-02\n...\n```\n\n----------------------------------------\n\nTITLE: Defining a Proto Library with Blaze\nDESCRIPTION: Creates a language-agnostic proto_library rule that defines the Protobuf schema to be used. This is the first step in building Protobuf definitions for any language.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/building-rust-protos.md#2025-04-11_snippet_0\n\nLANGUAGE: build\nCODE:\n```\nproto_library(\n    name = \"person_proto\",\n    srcs = [\"person.proto\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Message Structure\nDESCRIPTION: Example proto file defining a TestMessage with optional int32 and nested message fields using proto3 syntax.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v23.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\n\npackage pkg;\n\nmessage TestMessage {\n  optional int32 i32 = 1;\n  optional TestMessage msg = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Field Label Types Enum in Protocol Buffers\nDESCRIPTION: Enumeration defining field label types in Protocol Buffers such as optional, repeated, etc.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.pb.md#2025-04-11_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nenum protobuf::FieldDescriptorProto_Label {\n  FieldDescriptorProto_Label_LABEL_OPTIONAL = = 1\n}\n```\n\n----------------------------------------\n\nTITLE: Float Casting in Protocol Buffer Text Format\nDESCRIPTION: Examples demonstrating how to cast decimal integers as floating-point values using F and f suffixes in the protocol buffer text format.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/textformat-spec.md#2025-04-11_snippet_4\n\nLANGUAGE: textproto\nCODE:\n```\nfoo: 10    # This is an integer value.\nfoo: 10f   # This is a floating-point value.\nfoo: 1.0f  # Also optional for floating-point literals.\n```\n\n----------------------------------------\n\nTITLE: Identifying Abseil Version in CMake Projects\nDESCRIPTION: Shows a code snippet from the Abseil CMakeLists.txt file that contains version information. This can be used to verify the specific Abseil version being used in a Protocol Buffers project built with CMake.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/abseil.md#2025-04-11_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nproject(absl LANGUAGES CXX VERSION 20240722)\nset(ABSL_SOVERSION \"2407.0.0\")\ninclude(CTest)\n```\n\n----------------------------------------\n\nTITLE: Mapping Source Locations in C++ Protocol Buffers\nDESCRIPTION: The SourceLocationTable class maps (descriptor, ErrorLocation) pairs to line and column numbers in the original source code. It's used for integrating with DescriptorPool for error reporting.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.compiler.parser.md#2025-04-11_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass SourceLocationTable {\n  // Implementation details not provided in the snippet\n};\n```\n\n----------------------------------------\n\nTITLE: Getting Message Classes For Files in Python\nDESCRIPTION: Various deprecated methods in MessageFactory and SymbolDatabase are being removed. Code should use message_factory.GetMessageClass() and message_factory.GetMessageClassesForFiles() as replacements.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v30.md#2025-04-11_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Old deprecated methods:\nMessageFactory.GetPrototype\nMessageFactory.CreatePrototype\nMessageFactory.GetMessages\nSymbolDatabase.GetPrototype\nSymbolDatabase.CreatePrototype\nSymbolDatabase.GetMessages\n\n# New replacement methods:\nmessage_factory.GetMessageClass()\nmessage_factory.GetMessageClassesForFiles()\n```\n\n----------------------------------------\n\nTITLE: Proto2 Package Statement Example\nDESCRIPTION: Shows an example of a package declaration in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/protobuf/proto2-spec.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\npackage foo.bar;\n```\n\n----------------------------------------\n\nTITLE: Cord Field Definitions in Protocol Buffers\nDESCRIPTION: Example field definitions using the CORD ctype option for string and bytes fields.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/rust/rust-generated.md#2025-04-11_snippet_8\n\nLANGUAGE: proto\nCODE:\n```\noptional string foo = 1 [ctype = CORD];\nstring foo = 1 [ctype = CORD];\noptional bytes foo = 1 [ctype = CORD];\nbytes foo = 1 [ctype = CORD];\n```\n\n----------------------------------------\n\nTITLE: GPBDuration Time Interval Methods - Objective-C\nDESCRIPTION: Replacement of timeIntervalSince1970 method with timeInterval method for handling duration values in Protocol Buffers.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-10-02.md#2025-04-11_snippet_3\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBDuration timeIntervalSince1970\n```\n\nLANGUAGE: objective-c\nCODE:\n```\nGPBDuration timeInterval\n```\n\n----------------------------------------\n\nTITLE: New Ruby Code Generation with Serialized Descriptors\nDESCRIPTION: Updated Ruby code generation approach using serialized descriptors instead of DSL, providing better conformance and preserving all proto information.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v23.md#2025-04-11_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# frozen_string_literal: true\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: test.proto\n\nrequire 'google/protobuf'\n\ndescriptor_data = \"\\n\\ntest.proto\\x12\\x03pkg\\\"S\\n\\x0bTestMessage\\x12\\x10\\n\\x03i32\\x18\\x01 \\x01(\\x05H\\x00\\x88\\x01\\x01\\x12\\\"\\n\\x03msg\\x18\\x02 \\x01(\\x0b2\\x10.pkg.TestMessageH\\x01\\x88\\x01\\x01B\\x06\\n\\x04_i32B\\x06\\n\\x04_msgb\\x06proto3\"\nbegin\n  Google::Protobuf::DescriptorPool.generated_pool.add_serialized_file(descriptor_data)\nrescue TypeError => e\n  # <compatibility code, see below>\nend\n\nmodule Pkg\n  TestMessage = ::Google::Protobuf::DescriptorPool.generated_pool.lookup(\"pkg.TestMessage\").msgclass\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Java Options in Proto File\nDESCRIPTION: Example of setting recommended Java options in a .proto file. This includes enabling multiple files, specifying an outer classname, and setting a Java package.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/java-proto-names.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\noption java_multiple_files = true;\noption java_outer_classname = \"FileNameProto\";\noption java_package = \"com.google.package\";\n```\n\n----------------------------------------\n\nTITLE: Language-Specific Generators\nDESCRIPTION: Collection of language-specific code generators for Protocol Buffers including C++, Java, Python, Ruby, JavaScript, C#, and ObjectiveC implementations\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/_index.md#2025-04-11_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\ngoogle/protobuf/compiler/cpp/cpp_generator.h\ngoogle/protobuf/compiler/java/java_generator.h\ngoogle/protobuf/compiler/python/python_generator.h\ngoogle/protobuf/compiler/ruby/ruby_generator.h\ngoogle/protobuf/compiler/js/js_generator.h\ngoogle/protobuf/compiler/csharp/csharp_generator.h\ngoogle/protobuf/compiler/objectivec/objectivec_generator.h\n```\n\n----------------------------------------\n\nTITLE: Decoding JSON in Ruby Protocol Buffers\nDESCRIPTION: This snippet shows the C implementation of the decode_json function in the Ruby extension for Protocol Buffers. It uses the message's pool for decoding.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/v26.md#2025-04-11_snippet_4\n\nLANGUAGE: C\nCODE:\n```\ndecode_json\n```\n\n----------------------------------------\n\nTITLE: Parsing Integer Tokens in C++\nDESCRIPTION: Static method to parse a TYPE_INTEGER token. It checks against a maximum value and returns false if the parsed value exceeds it.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.io.tokenizer.md#2025-04-11_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nstatic bool Tokenizer::ParseInteger(\n    const std::string& text,\n    uint64 max_value,\n    uint64* output)\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Front Matter for Java API Documentation Page\nDESCRIPTION: This YAML front matter block defines metadata for a documentation page about the Java API for Protocol Buffers. It specifies the page title, a link to the full API documentation, and a weight for page ordering in a documentation system.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/java/api-docs-link.md#2025-04-11_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: \"Java API\"\nmanualLink: \"/reference/java/api-docs/overview-summary.html\"\nmanualLinkTarget: \"_blank\"\nweight: 660\n---\n```\n\n----------------------------------------\n\nTITLE: Example Proto File with Import Path Issue\nDESCRIPTION: Example showing potential import path issues with two .proto files and different import references.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-20.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\n// foo/bar.proto\n\nsyntax = \"proto2\";\n\nmessage Bar {}\n```\n\nLANGUAGE: proto\nCODE:\n```\n// foo/baz.proto\n\nsyntax = \"proto2\";\n\nimport \"bar.proto\";\n\nmessage Baz {\n  optional Bar bar = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing equals operator in DslList class (Kotlin)\nDESCRIPTION: This snippet shows the method signature for the equals operator implementation in the DslList class. It's an open operator function that overrides the standard equals method and compares the current instance with another object.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/equals.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen operator override fun equals(other: Any?): Boolean\n```\n\n----------------------------------------\n\nTITLE: Unpacking Any Message to Specific Type in Kotlin\nDESCRIPTION: This inline function extends Any to unpack and return a message of type T. It throws an InvalidProtocolBufferException if the Any object does not contain a message of type T.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/unpack.md#2025-04-11_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\ninline fun <T : Message> Any.unpack(): T\n```\n\n----------------------------------------\n\nTITLE: C# Namespace Declaration in Proto\nDESCRIPTION: Specifies the C# namespace for generated code, overriding the default package-based namespace.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/getting-started/csharptutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\noption csharp_namespace = \"Google.Protobuf.Examples.AddressBook\";\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterator for DslList in Protobuf Kotlin\nDESCRIPTION: The iterator method implementation in the DslList class that returns an Iterator for elements of type E. This method is marked as an operator function to support the for-loop iteration syntax in Kotlin.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/iterator.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nopen operator override fun iterator(): Iterator<E>\n```\n\n----------------------------------------\n\nTITLE: Nested Message Definition in Proto\nDESCRIPTION: Example of declaring a message inside another message, which generates nested Objective-C classes with underscore-separated names.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  message Bar {}\n}\n```\n\n----------------------------------------\n\nTITLE: Adding CORD support for bytes field in Protocol Buffers\nDESCRIPTION: Demonstrates how to use the ctype=CORD option for a singular bytes field in Protocol Buffers. This option specifies that the data should be stored using absl::cord instead of string.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2023-04-11.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\noptional bytes foo = 25 [ctype=CORD];\n```\n\n----------------------------------------\n\nTITLE: Enabling Lazy Dependencies Building\nDESCRIPTION: Enables lazy building of dependencies for files. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_130\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::InternalSetLazilyBuildDependencies()\n```\n\n----------------------------------------\n\nTITLE: DslMap Function Declaration in Protobuf Kotlin\nDESCRIPTION: Defines a DslMap function that wraps a Map<K,V> delegate. This is likely used for DSL-style map operations within Protocol Buffer Kotlin extensions.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/-dsl-map.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <K, V> DslMap(delegate: Map<K, V>)\n```\n\n----------------------------------------\n\nTITLE: GBP<KEY>ObjectDictionary Interface Implementation in Objective-C\nDESCRIPTION: A specialized dictionary interface for Protocol Buffers in Objective-C that handles object values. This interface provides methods for creating, accessing, and modifying dictionaries that store object references.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/objective-c/objective-c-generated.md#2025-04-11_snippet_18\n\nLANGUAGE: objc\nCODE:\n```\n@interface GPB<KEY>ObjectDictionary : NSObject\n@property (nonatomic, readonly) NSUInteger count;\n\n+ (instancetype)dictionary;\n+ (instancetype)dictionaryWithObject:(id)object\n                             forKey:(const <KEY>)key;\n+ (instancetype)\n  dictionaryWithObjects:(const id GPB_UNSAFE_UNRETAINED [])objects\n                forKeys:(const <KEY> [])keys\n                  count:(NSUInteger)count;\n+ (instancetype)dictionaryWithDictionary:(GPB<KEY>ObjectDictionary *)dictionary;\n+ (instancetype)dictionaryWithCapacity:(NSUInteger)numItems;\n\n- (instancetype)initWithObjects:(const id GPB_UNSAFE_UNRETAINED [])objects\n                        forKeys:(const <KEY> [])keys\n                          count:(NSUInteger)count NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithDictionary:(GPB<KEY>ObjectDictionary *)dictionary;\n- (instancetype)initWithCapacity:(NSUInteger)numItems;\n\n- (id)objectForKey:(uint32_t)key;\n\n- (void)enumerateKeysAndObjectsUsingBlock:\n    (void (^)(<KEY> key, id object, BOOL *stop))block;\n\n- (void)removeObjectForKey:(<KEY>)aKey;\n- (void)removeAll;\n- (void)setObject:(id)object forKey:(<KEY>)key;\n- (void)addEntriesFromDictionary:(GPB<KEY>ObjectDictionary *)otherDictionary;\n@end\n```\n\n----------------------------------------\n\nTITLE: Implementing Direct Field Redaction in Protocol Buffers\nDESCRIPTION: Demonstrates how to mark a field as sensitive using the debug_redact option directly on a field in a protocol buffer message definition.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/news/2024-12-04.md#2025-04-11_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nmessage Foo {\n  optional string secret = 1 [debug_redact = true];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Underlay Pool\nDESCRIPTION: Sets the underlay pool for a DescriptorPool. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_131\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::internal_set_underlay(const DescriptorPool * underlay)\n```\n\n----------------------------------------\n\nTITLE: Initializing ProtoDslMarker Function in Kotlin\nDESCRIPTION: Empty constructor function for the ProtoDslMarker class in the Protocol Buffers Kotlin API.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/-proto-dsl-marker.md#2025-04-11_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nfun ProtoDslMarker()\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Enum for Oneof\nDESCRIPTION: This snippet shows the Dart enum generated by the Protocol Buffers compiler for the oneof field. It creates an enum 'Foo_Test' with options corresponding to the oneof fields plus a 'notSet' option.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/dart/dart-generated.md#2025-04-11_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\nenum Foo_Test { name, subMessage, notSet }\n```\n\n----------------------------------------\n\nTITLE: Proto2 Behavior Configuration\nDESCRIPTION: Complete configuration for maintaining proto2 behavior in Edition 2023.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/features.md#2025-04-11_snippet_10\n\nLANGUAGE: proto\nCODE:\n```\nedition = \"2023\";\n\nimport \"google/protobuf/cpp_features.proto\";\nimport \"google/protobuf/java_features.proto\";\n\noption features.field_presence = EXPLICIT;\noption features.enum_type = CLOSED;\noption features.repeated_field_encoding = EXPANDED;\noption features.json_format = LEGACY_BEST_EFFORT;\noption features.utf8_validation = NONE;\noption features.(pb.cpp).legacy_closed_enum = true;\noption features.(pb.java).legacy_closed_enum = true;\n```\n\n----------------------------------------\n\nTITLE: Compiling Edition Defaults with Bazel Rule\nDESCRIPTION: Bazel rule example for compiling intermediate edition defaults objects from feature definition files. It specifies source files and edition range parameters for the compilation process.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/editions/implementation.md#2025-04-11_snippet_2\n\nLANGUAGE: bzl\nCODE:\n```\nload(\"@com_google_protobuf//editions:defaults.bzl\", \"compile_edition_defaults\")\n\ncompile_edition_defaults(\n    name = \"my_defaults\",\n    srcs = [\"//some/path:lang_features_proto\"],\n    maximum_edition = \"PROTO2\",\n    minimum_edition = \"2024\",\n)\n```\n\n----------------------------------------\n\nTITLE: Disabling UTF-8 Enforcement Configuration\nDESCRIPTION: Disallows [enforce_utf8 = false] in .proto files. For internal use only.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/reference/cpp/api-docs/google.protobuf.descriptor.md#2025-04-11_snippet_128\n\nLANGUAGE: C++\nCODE:\n```\nvoid DescriptorPool::DisallowEnforceUtf8()\n```\n\n----------------------------------------\n\nTITLE: TOML Front Matter Configuration for Proto Best Practices Page\nDESCRIPTION: TOML configuration block that defines metadata for a documentation page about Protocol Buffer best practices. Specifies the title, weight, description, type and list display settings.\nSOURCE: https://github.com/protocolbuffers/protocolbuffers.github.io/blob/main/content/best-practices/_index.md#2025-04-11_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n+++\ntitle = \"Proto Best Practices\"\nweight = 90\ndescription = \"An overview of best practices topics.\"\ntype = \"docs\"\nno_list = \"true\"\n+++\n```"
  }
]