[
  {
    "owner": "get-convex",
    "repo": "aggregate",
    "content": "TITLE: Implementing User Score Aggregation in TypeScript\nDESCRIPTION: Example showing how to aggregate scores by user, including calculating high scores and averages both for individual users and globally.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// aggregateScoreByUser is the leaderboard scores grouped by username.\nconst bounds = { prefix: [username] };\nconst highScoreForUser = await aggregateScoreByUser.max(ctx, { bounds });\nconst avgScoreForUser =\n  (await aggregateScoreByUser.sum(ctx, { bounds })) /\n  (await aggregateScoreByUser.count(ctx, { bounds }));\n// It still enables adding or averaging all scores across all usernames.\nconst globalAverageScore =\n  (await aggregateScoreByUser.sum(ctx)) /\n  (await aggregateScoreByUser.count(ctx));\n```\n\n----------------------------------------\n\nTITLE: Registering Triggers for Automatic Aggregate Updates in TypeScript\nDESCRIPTION: Code demonstrating how to set up triggers that automatically update aggregates when the source table changes. This approach uses the convex-helpers Triggers utility to hook up writes to the table with the TableAggregate.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Triggers hook up writes to the table to the TableAggregate.\nconst triggers = new Triggers<DataModel>();\ntriggers.register(\"mytable\", aggregate.trigger());\nexport const mutation = customMutation(rawMutation, customCtx(triggers.wrapDB));\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Aggregate Operations in TypeScript\nDESCRIPTION: A mutation demonstrating how aggregates handle concurrent operations atomically. Unlike manual counter implementations, the Aggregate component ensures that parallel inserts correctly increase counters by the expected amount.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport const addTwo = mutation({\n  handler: async (ctx) => {\n    await Promise.all([\n      aggregate.insert(ctx, \"some key\", \"a\"),\n      aggregate.insert(ctx, \"other key\", \"b\"),\n    ]);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Managing TableAggregate CRUD Operations\nDESCRIPTION: Demonstrates how to handle insert, update, and delete operations on the aggregate data structure in sync with table modifications.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// When you insert into the table, call `aggregate.insert`\nconst id = await ctx.db.insert(\"mytable\", { foo, bar });\nconst doc = await ctx.db.get(id);\nawait aggregate.insert(ctx, doc!);\n\n// If you update a document, use `aggregate.replace`\nconst oldDoc = await ctx.db.get(id);\nawait ctx.db.patch(id, { foo });\nconst newDoc = await ctx.db.get(id);\nawait aggregate.replace(ctx, oldDoc!, newDoc!);\n\n// And if you delete a document, use `aggregate.delete`\nconst oldDoc = await ctx.db.get(id);\nawait ctx.db.delete(id);\nawait aggregate.delete(ctx, oldDoc!);\n```\n\n----------------------------------------\n\nTITLE: Using Function Encapsulation for Table Updates with Aggregate in TypeScript\nDESCRIPTION: An example showing the recommended approach of encapsulating table updates in separate functions. The mutation 'playAGame' calls 'insertScore', which handles both inserting into the 'scores' table and updating the aggregate.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Example of a mutation that calls `insertScore`.\nexport const playAGame = mutation(async (ctx) => {\n  ...\n  await insertScore(ctx, gameId, user1, user1Score);\n  await insertScore(ctx, gameId, user2, user2Score);\n});\n\n// All inserts to the \"scores\" table go through this function.\nasync function insertScore(ctx, gameId, username, score) {\n  const id = await ctx.db.insert(\"scores\", { gameId, username, score });\n  await doc = await ctx.db.get(id);\n  await aggregateByGame.insert(ctx, doc!);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TableAggregate for Basic Data Aggregation\nDESCRIPTION: Demonstrates how to create a TableAggregate instance with sorting and summing capabilities. The code shows configuration of sort keys and sum values for aggregating table data.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { components } from \"./_generated/api\";\nimport { DataModel } from \"./_generated/dataModel\";\nimport { mutation as rawMutation } from \"./_generated/server\";\nimport { TableAggregate } from \"@convex-dev/aggregate\";\n\nconst aggregate = new TableAggregate<{\n  Key: number;\n  DataModel: DataModel;\n  TableName: \"mytable\";\n}>(components.aggregate, {\n  sortKey: (doc) => doc._creationTime, // Allows querying across time ranges.\n  sumValue: (doc) => doc.value, // The value to be used in `.sum` calculations.\n});\n```\n\n----------------------------------------\n\nTITLE: Using Bounds to Optimize Aggregate Queries in TypeScript\nDESCRIPTION: Examples of how to use bounds to limit the read dependency footprint of aggregate queries. The first query only reads scores in a specific range, while the second query only reads data for a specific user.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// This query only reads scores between 95 and 100, so in a query it only reruns\n// when a score in that range changes, and in a mutation it only conflicts with\n// mutations that modify a score in that range.\nawait aggregateByScore.count(ctx, {\n  lower: { key: 95, inclusive: false },\n  upper: { key: 100, inclusive: true },\n});\n\n// This query only reads data from a specific user, so it will only rerun or\n// conflict when a mutation modifies that user.\nawait aggregateScoreByUser.count(ctx, { prefix: [username] });\n```\n\n----------------------------------------\n\nTITLE: Calculating Aggregate Values\nDESCRIPTION: Shows how to perform aggregate calculations using the TableAggregate instance within Convex functions.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// convex/myfunctions.ts\n// then in your queries and mutations you can do\nconst tableCount = await aggregateByGame.count(ctx);\n// or any of the other examples listed above.\n```\n\n----------------------------------------\n\nTITLE: Using DirectAggregate for Non-Table Data\nDESCRIPTION: Demonstrates how to use DirectAggregate for aggregating data that isn't stored in a table, including insert, delete, and replace operations.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { components } from \"./_generated/api\";\nimport { DataModel } from \"./_generated/dataModel\";\nimport { DirectAggregate } from \"@convex-dev/aggregate\";\n// Note the `id` should be unique to be a tie-breaker in case two data points\n// have the same key.\nconst aggregate = new DirectAggregate<{\n  Key: number;\n  Id: string;\n}>(components.aggregate);\n\n// within a mutation, add values to be aggregated\nawait aggregate.insert(ctx, { key, id });\n// if you want to use `.sum` to aggregate sums of values, insert with a sumValue\nawait aggregate.insert(ctx, { key, id, sumValue });\n// or delete values that were previously added\nawait aggregate.delete(ctx, { key, id });\n// or update values\nawait aggregate.replace(ctx, { key: oldKey, id }, { key: newKey });\n```\n\n----------------------------------------\n\nTITLE: Configuring Game Leaderboard Aggregate\nDESCRIPTION: Shows how to create a namespaced aggregate for game leaderboards with typed parameters for namespace, key, data model, and table name.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst leaderboardByGame = new TableAggregate<{\n  Namespace: Id<\"games\">;\n  Key: number;\n  DataModel: DataModel;\n  TableName: \"scores\";\n}>(components.leaderboardByGame, {\n  namespace: (doc) => doc.gameId,\n  sortKey: (doc) => doc.score,\n});\n```\n\n----------------------------------------\n\nTITLE: User Namespace Aggregation Implementation\nDESCRIPTION: Demonstrates how to implement user-specific aggregation using namespaces for improved throughput without cross-user aggregation capability.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst forUser = { namespace: username };\nconst highScoreForUser = await aggregateScoreByUser.max(ctx, forUser);\nconst avgScoreForUser =\n  (await aggregateScoreByUser.sum(ctx, forUser)) /\n  (await aggregateScoreByUser.count(ctx, forUser));\n```\n\n----------------------------------------\n\nTITLE: Configuring Game-Specific TableAggregate\nDESCRIPTION: Shows how to create a TableAggregate for game leaderboard data with custom namespace and sorting configuration using username and score as composite keys.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst aggregateByGame = new TableAggregate<{\n  Namespace: Id<\"games\">;\n  Key: [string, number];\n  DataModel: DataModel;\n  TableName: \"leaderboard\";\n}>(components.aggregateByGame, {\n  namespace: (doc) => doc.gameId,\n  sortKey: (doc) => [doc.username, doc.score],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Offset-based Pagination\nDESCRIPTION: Shows how to implement offset-based pagination using TableAggregate for photo albums.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport const pageOfPhotos({\n  args: { offset: v.number(), numItems: v.number(), album: v.string() },\n  handler: async (ctx, { offset, numItems, album }) => {\n    const { key } = await photos.at(ctx, offset, { namespace: album });\n    return await ctx.db.query(\"photos\")\n      .withIndex(\"by_album_creation_time\", q=>q.eq(\"album\", album).gte(\"_creationTime\", key))\n      .take(numItems);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Photo Album Schema and Aggregate\nDESCRIPTION: Shows how to define a schema for photos and create a corresponding TableAggregate for album-based pagination.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// convex/schema.ts\ndefineSchema({\n  photos: defineTable({\n    album: v.string(),\n    url: v.string(),\n  }).index(\"by_album_creation_time\", [\"album\"]),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// convex/convex.config.ts\napp.use(aggregate, { name: \"photos\" });\n\n// convex/photos.ts\nconst photos = new TableAggregate<{\n  Namespace: string; // album name\n  Key: number; // creation time\n  DataModel: DataModel;\n  TableName: \"photos\";\n}>(components.photos, {\n  namespace: (doc) => doc.album,\n  sortKey: (doc) => doc._creationTime,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Aggregates\nDESCRIPTION: Example of how to define multiple aggregate instances with different names for various use cases.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\napp.use(aggregate, { name: \"aggregateScores\" });\napp.use(aggregate, { name: \"aggregateByGame\" });\n```\n\n----------------------------------------\n\nTITLE: Querying Game Leaderboard Score\nDESCRIPTION: Example of retrieving the high score for a specific game using the namespaced leaderboard aggregate.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst footballHighScore = await leaderboardByGame.max(ctx, {\n  namespace: footballId,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Total Count and Randomization\nDESCRIPTION: Demonstrates how to create a TableAggregate for simple counting and randomization without ordering or partitioning.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst randomize = new TableAggregate<{\n  Key: null;\n  DataModel: DataModel;\n  TableName: \"mytable\";\n}>(components.aggregate, {\n  sortKey: (doc) => null,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Convex Aggregate Component\nDESCRIPTION: Configuration setup for the Convex Aggregate component in a TypeScript environment.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// convex/convex.config.ts\nimport { defineApp } from \"convex/server\";\nimport aggregate from \"@convex-dev/aggregate/convex.config\";\n\nconst app = defineApp();\napp.use(aggregate);\nexport default app;\n```\n\n----------------------------------------\n\nTITLE: Installing Convex Aggregate Component\nDESCRIPTION: Command to install the Convex Aggregate component via npm.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/README.md#2025-04-20_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @convex-dev/aggregate\n```\n\n----------------------------------------\n\nTITLE: Project Description in Markdown\nDESCRIPTION: A simple README file that provides an overview of the example application and directs users to the relevant files for Aggregate component usage examples.\nSOURCE: https://github.com/get-convex/aggregate/blob/main/example/README.md#2025-04-20_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Example app\n\nSee convex/config.ts and convex/leaderboard.ts for example usages of the\nAggregate component.\n```"
  }
]