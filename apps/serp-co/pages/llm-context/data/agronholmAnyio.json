[
  {
    "owner": "agronholm",
    "repo": "anyio",
    "content": "TITLE: TLS Listener Example in AnyIO\nDESCRIPTION: This code demonstrates how to set up a TLS listener using AnyIO with a self-signed certificate. It creates an SSL context, loads the certificate and key, creates a TLSListener, and serves incoming connections, echoing a personalized greeting.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nimport ssl\n\nfrom anyio import create_tcp_listener, run\nfrom anyio.streams.tls import TLSListener\n\n\nasync def handle(client):\n    async with client:\n        name = await client.receive()\n        await client.send(b'Hello, %s\\n' % name)\n\n\nasync def main():\n    # Create a context for the purpose of authenticating clients\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n\n    # Load the server certificate and private key\n    context.load_cert_chain(certfile='cert.pem', keyfile='key.pem')\n\n    # Create the listener and start serving connections\n    listener = TLSListener(await create_tcp_listener(local_port=1234), context)\n    await listener.serve(handle)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Working with Processes (AnyIO)\nDESCRIPTION: This snippet demonstrates how to launch a subprocess with AnyIO's open_process function and interact with it. It opens the 'ps' process, reads its standard output as text, and prints each line.  Requires anyio and anyio.streams.text.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import open_process, run\nfrom anyio.streams.text import TextReceiveStream\n\n\nasync def main():\n    async with await open_process(['ps']) as process:\n        async for text in TextReceiveStream(process.stdout):\n            print(text)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using AnyIO Locks\nDESCRIPTION: This code demonstrates the usage of AnyIO locks to ensure sole access to a shared resource.  Tasks acquire the lock before accessing the resource and release it afterwards. Only the task that acquired the lock is allowed to release it. The `fast_acquire` parameter can be passed to the Lock constructor to potentially improve performance.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Lock, create_task_group, sleep, run\n\n\nasync def use_resource(tasknum, lock):\n    async with lock:\n        print('Task number', tasknum, 'is now working with the shared resource')\n        await sleep(1)\n\n\nasync def main():\n    lock = Lock()\n    async with create_task_group() as tg:\n        for num in range(4):\n            tg.start_soon(use_resource, num, lock)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Creating a UDP Socket with AnyIO\nDESCRIPTION: This example creates a UDP socket using AnyIO's create_udp_socket. It listens for incoming packets and sends a response back to the sender.  Requires the anyio and socket libraries.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport socket\n\nfrom anyio import create_udp_socket, run\n\n\nasync def main():\n    async with await create_udp_socket(\n        family=socket.AF_INET, local_port=1234\n    ) as udp:\n        async for packet, (host, port) in udp:\n            await udp.sendto(b'Hello, ' + packet, host, port)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Running a function in a worker thread in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates how to run a synchronous function (time.sleep) in a worker thread using AnyIO's to_thread.run_sync function. This prevents the main asynchronous event loop from blocking. The run function is used to start the asynchronous main function.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom anyio import to_thread, run\n\n\nasync def main():\n    await to_thread.run_sync(time.sleep, 5)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using timeouts with move_on_after in AnyIO\nDESCRIPTION: This code demonstrates how to use the `move_on_after` function in AnyIO to implement a timeout. It creates a task group, uses `move_on_after` to set a timeout, and then attempts to sleep for a longer duration. If the sleep exceeds the timeout, the context block is exited, and the `cancelled_caught` property indicates whether the timeout was reached.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_task_group, move_on_after, sleep, run\n\n\nasync def main():\n    async with create_task_group() as tg:\n        with move_on_after(1) as scope:\n            print('Starting sleep')\n            await sleep(2)\n            print('This should never be printed')\n\n        # The cancelled_caught property will be True if timeout was reached\n        print('Exited cancel scope, cancelled =', scope.cancelled_caught)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Finalization with shielding and cleanup in AnyIO\nDESCRIPTION: This code extends the previous example by demonstrating how to use a shielded cancel scope within the exception handler to allow asynchronous cleanup operations to complete even when the task is cancelled.  The `some_cleanup_function` will execute despite the surrounding scope being cancelled, ensuring critical cleanup happens.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def do_something():\n    try:\n        await run_async_stuff()\n    except get_cancelled_exc_class():\n        with CancelScope(shield=True):\n            await some_cleanup_function()\n\n        raise\n```\n\n----------------------------------------\n\nTITLE: Running a One-Shot Command Directly (AnyIO)\nDESCRIPTION: This snippet demonstrates running an external command (ps) directly, using AnyIO's run_process function and passing the command as a list of strings (shell=False). The first element is the executable, and subsequent elements are its arguments. The output is decoded and printed.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import run_process, run\n\n\nasync def main():\n    result = await run_process(['ps'])\n    print(result.stdout.decode())\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Creating and Running Tasks with AnyIO\nDESCRIPTION: This example demonstrates how to create and run tasks concurrently using AnyIO's task groups. It defines a simple task that prints messages and sleeps for a short duration, then spawns multiple instances of this task within a task group.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import sleep, create_task_group, run\n\n\nasync def sometask(num: int) -> None:\n    print('Task', num, 'running')\n    await sleep(1)\n    print('Task', num, 'finished')\n\n\nasync def main() -> None:\n    async with create_task_group() as tg:\n        for num in range(5):\n            tg.start_soon(sometask, num)\n\n    print('All tasks finished!')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Creating BlockingPortal directly in AnyIO (Python)\nDESCRIPTION: This snippet shows how to create a BlockingPortal directly when an event loop is already running. This allows external threads to access and run asynchronous code within the existing event loop.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import run\nfrom anyio.from_thread import BlockingPortal\n\n\nasync def main():\n    async with BlockingPortal() as portal:\n        # ...hand off the portal to external threads...\n        await portal.sleep_until_stopped()\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: File Stream Example in AnyIO\nDESCRIPTION: This example demonstrates how to use file streams to read from and write to files on the file system using AnyIO. It writes 'Hello, World!' to a file, then reads the contents of the file and prints it to the console.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import run\nfrom anyio.streams.file import FileReadStream, FileWriteStream\n\n\nasync def main():\n    path = '/tmp/testfile'\n    async with await FileWriteStream.from_path(path) as stream:\n        await stream.send(b'Hello, World!')\n\n    async with await FileReadStream.from_path(path) as stream:\n        async for chunk in stream:\n            print(chunk.decode(), end='')\n\n    print()\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous File Reading with AnyIO\nDESCRIPTION: This snippet demonstrates how to asynchronously open and read the contents of a file using AnyIO's `open_file` function.  It utilizes an asynchronous context manager and reads the entire file content into a variable.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import open_file, run\n\n\nasync def main():\n    async with await open_file('/some/path/somewhere') as f:\n        contents = await f.read()\n        print(contents)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using AnyIO CapacityLimiters\nDESCRIPTION: This code demonstrates how to use AnyIO capacity limiters to restrict the number of concurrent borrowers of a shared resource. Each borrower can only hold a single token at a time (by default, the current task). The total number of tokens can be adjusted using the `total_tokens` property.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import CapacityLimiter, create_task_group, sleep, run\n\n\nasync def use_resource(tasknum, limiter):\n    async with limiter:\n        print('Task number', tasknum, 'is now working with the shared resource')\n        await sleep(1)\n\n\nasync def main():\n    limiter = CapacityLimiter(2)\n    async with create_task_group() as tg:\n        for num in range(10):\n            tg.start_soon(use_resource, num, limiter)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Receiving File Descriptors over UNIX Sockets (Client)\nDESCRIPTION: This snippet shows how to receive file descriptors over a UNIX socket using AnyIO. It connects to a server, receives a file descriptor, opens the file, and prints its contents. Requires the anyio and os libraries.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom anyio import connect_unix, run\n\n\nasync def main():\n    async with await connect_unix('/tmp/mysock') as client:\n        _, fds = await client.receive_fds(0, 1)\n        with os.fdopen(fds[0]) as file:\n            print(file.read())\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Calling synchronous code from a worker thread to the event loop (Python)\nDESCRIPTION: This example illustrates calling synchronous code from a worker thread within the main event loop. This is achieved using from_thread.run_sync, which ensures that the specified function (event.set in this case) is executed in the main event loop thread, thus preventing thread-safety issues when dealing with asynchronous objects. Dependencies: anyio\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom anyio import Event, from_thread, to_thread, run\n\ndef worker(event):\n    time.sleep(1)\n    from_thread.run_sync(event.set)\n\nasync def main():\n    event = Event()\n    await to_thread.run_sync(worker, event)\n    await event.wait()\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Connecting to a UNIX Socket with AnyIO\nDESCRIPTION: This example demonstrates how to connect to a UNIX domain socket using AnyIO's connect_unix function. It connects to a specified path, sends data, and receives a response.  Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import connect_unix, run\n\n\nasync def main():\n    async with await connect_unix('/tmp/mysock') as client:\n        await client.send(b'Client\\n')\n        response = await client.receive(1024)\n        print(response)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Reacting to cancellation in worker threads in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates how to check for cancellation within a worker thread using from_thread.check_cancelled. If the host task has been cancelled, it raises a CancellationError. Dependencies: anyio.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import to_thread, from_thread\n\ndef sync_function():\n    while True:\n        from_thread.check_cancelled()\n        print(\"Not cancelled yet\")\n        sleep(1)\n\nasync def foo():\n    with move_on_after(3):\n        await to_thread.run_sync(sync_function)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous File Creation with Path\nDESCRIPTION: This snippet demonstrates how to create a file with binary content using AnyIO's asynchronous `Path` object. The `write_bytes` method is used to write the specified bytes to the file asynchronously.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Path, run\n\n\nasync def main():\n    path = Path('/foo/bar')\n    await path.write_bytes(b'hello, world')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Running Functions in Worker Processes (AnyIO)\nDESCRIPTION: This snippet shows how to run a CPU-intensive function in a separate process using AnyIO's to_process.run_sync. It defines a simple function that sleeps for 1 second and returns the concatenation of two strings.  It also includes the necessary `if __name__ == '__main__':` guard.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom anyio import run, to_process\n\n\ndef cpu_intensive_function(arg1, arg2):\n    time.sleep(1)\n    return arg1 + arg2\n\nasync def main():\n    result = await to_process.run_sync(cpu_intensive_function, 'Hello, ', 'world!')\n    print(result)\n\n# This check is important when the application uses to_process.run_sync()\nif __name__ == '__main__':\n    run(main)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous File Iteration with AnyIO\nDESCRIPTION: This snippet illustrates asynchronous line-by-line iteration over a file using AnyIO.  It uses `open_file` within an asynchronous context manager and iterates through each line of the file.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import open_file, run\n\n\nasync def main():\n    async with await open_file('/some/path/somewhere') as f:\n        async for line in f:\n            print(line, end='')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using AnyIO ResourceGuards\nDESCRIPTION: This snippet showcases using ResourceGuard to prevent concurrent access to a resource. Attempting to call the `do_something()` method on the same Resource instance before the first call finishes will raise a BusyResourceError. Resource guards are appropriate for resources, like sockets, which are highly sensitive to concurrent use.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Resource:\n    def __init__(self):\n        self._guard = ResourceGuard()\n\n    async def do_something() -> None:\n        with self._guard:\n            ...\n```\n\n----------------------------------------\n\nTITLE: Text Stream Example in AnyIO\nDESCRIPTION: This example demonstrates the usage of text streams in AnyIO to encode and decode strings to bytes and vice versa. It creates byte streams, wraps them with TextSendStream and TextReceiveStream, and sends text through them, printing the results at each stage.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import run, create_memory_object_stream\nfrom anyio.streams.text import TextReceiveStream, TextSendStream\n\n\nasync def main():\n    bytes_send, bytes_receive = create_memory_object_stream[bytes](1)\n    text_send = TextSendStream(bytes_send)\n    await text_send.send('åäö')\n    result = await bytes_receive.receive()\n    print(repr(result))\n\n    text_receive = TextReceiveStream(bytes_receive)\n    await bytes_send.send(result)\n    result = await text_receive.receive()\n    print(repr(result))\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Starting tasks using BlockingPortal.start_task in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates the use of BlockingPortal.start_task to start an async task from a worker thread. Unlike start_task_soon, this method waits for the task to signal readiness by calling task_status.started(). Dependencies: anyio\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import sleep, TASK_STATUS_IGNORED\nfrom anyio.from_thread import start_blocking_portal\n\n\nasync def service_task(*, task_status=TASK_STATUS_IGNORED):\n    task_status.started('STARTED')\n    await sleep(1)\n    return 'DONE'\n\n\nwith start_blocking_portal() as portal:\n    future, start_value = portal.start_task(service_task)\n    print('Task has started with value', start_value)\n\n    return_value = future.result()\n    print('Task has finished with return value', return_value)\n```\n\n----------------------------------------\n\nTITLE: Handling KeyboardInterrupt and SystemExit with AnyIO\nDESCRIPTION: This code snippet shows how to handle `KeyboardInterrupt` (Ctrl+C) and external termination signals (e.g., SIGTERM) using AnyIO. It uses `open_signal_receiver` to listen for `signal.SIGINT` and `signal.SIGTERM`, and then cancels a task group's cancel scope to initiate a graceful shutdown. Requires the `signal` and `anyio` libraries.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/signals.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport signal\n\nfrom anyio import open_signal_receiver, create_task_group, run\nfrom anyio.abc import CancelScope\n\n\nasync def signal_handler(scope: CancelScope):\n    with open_signal_receiver(signal.SIGINT, signal.SIGTERM) as signals:\n        async for signum in signals:\n            if signum == signal.SIGINT:\n                print('Ctrl+C pressed!')\n            else:\n                print('Terminated!')\n\n            scope.cancel()\n            return\n\n\nasync def main():\n    async with create_task_group() as tg:\n        tg.start_soon(signal_handler, tg.cancel_scope)\n        ...\n\n    run(main)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Directory Iteration with Path\nDESCRIPTION: This example illustrates how to asynchronously iterate through the contents of a directory using AnyIO's `Path` object. It checks if each item is a file and, if so, reads and prints its text content.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Path, run\n\n\nasync def main():\n    # Print the contents of every file (assumed to be text) in the directory /foo/bar\n    dir_path = Path('/foo/bar')\n    async for path in dir_path.iterdir():\n        if await path.is_file():\n            print(await path.read_text())\n            print('---------------------')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Synchronous Callback with Memory Object Stream in AnyIO\nDESCRIPTION: This example illustrates how to use a memory object stream within a synchronous callback function in AnyIO. It demonstrates that memory object streams can be closed synchronously using the `close()` method or as a context manager, sending a message using `send_nowait`.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio.streams.memory import MemoryObjectSendStream\n\n\ndef synchronous_callback(send_stream: MemoryObjectSendStream[str]) -> None:\n    with send_stream:\n        send_stream.send_nowait('hello')\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Errors in a Task Group (Python 3.11+)\nDESCRIPTION: This example demonstrates how to handle multiple exceptions that might occur within a task group using the `except*` syntax, available in Python 3.11 and later. It catches `ValueError` and `KeyError` exceptions raised by tasks within the group and handles them separately.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import create_task_group\n\ntry:\n    async with create_task_group() as tg:\n        tg.start_soon(some_task)\n        tg.start_soon(another_task)\nexcept* ValueError as excgroup:\n    for exc in excgroup.exceptions:\n        ...  # handle each ValueError\nexcept* KeyError as excgroup:\n    for exc in excgroup.exceptions:\n        ...  # handle each KeyError\n```\n\n----------------------------------------\n\nTITLE: Using asynchronous context managers from worker threads in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates how to wrap an asynchronous context manager and use it synchronously within a worker thread. It relies on BlockingPortal.wrap_async_context_manager to bridge the gap between the asynchronous and synchronous worlds. Dependencies: anyio.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio.from_thread import start_blocking_portal\n\n\nclass AsyncContextManager:\n    async def __aenter__(self):\n        print('entering')\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print('exiting with', exc_type)\n\n\nasync_cm = AsyncContextManager()\nwith start_blocking_portal() as portal, portal.wrap_async_context_manager(async_cm):\n    print('inside the context manager block')\n```\n\n----------------------------------------\n\nTITLE: Improved Asynchronous Context Manager with AsyncContextManagerMixin\nDESCRIPTION: Shows a better way to implement the asynchronous context manager from the previous example, using AnyIO's `AsyncContextManagerMixin`. This ensures that the task group is always exited correctly, even if an error occurs during context entry, by leveraging `async with` to handle the lifetime of the task group.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\nfrom typing import Self\n\nfrom anyio import AsyncContextManagerMixin, create_task_group\n\nclass MyBetterContextManager(AsyncContextManagerMixin):\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:\n        async with create_task_group() as task_group:\n            # Still crashes, but at least now the task group is exited\n            task_group.start_soon(self.my_background_func)\n            yield self\n\n    async my_background_func(self, arg: int) -> None:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Wrapping Existing File Objects Asynchronously\nDESCRIPTION: This code shows how to wrap an existing, already opened file object with AnyIO's `wrap_file` function to enable asynchronous iteration. The `wrap_file` function takes a synchronous file object and returns an asynchronous iterable.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import wrap_file, run\n\n\nasync def main():\n    with open('/some/path/somewhere') as f:\n        async for line in wrap_file(f):\n            print(line, end='')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: AsyncContextManagerMixin Example in AnyIO\nDESCRIPTION: This code demonstrates the use of `AsyncContextManagerMixin` to simplify the implementation of asynchronous context managers. It defines a custom context manager `MyAsyncContextManager` that utilizes a task group and avoids the need for directly calling `__aenter__()` and `__aexit__()`.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom collections.abc import AsyncGenerator\nfrom typing import Self\n\nfrom anyio import AsyncContextManagerMixin, create_task_group\n\n\nclass MyAsyncContextManager(AsyncContextManagerMixin):\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:\n        async with create_task_group() as tg:\n            ...  # launch tasks\n            yield self\n```\n\n----------------------------------------\n\nTITLE: Creating Self-Signed Certificates with trustme\nDESCRIPTION: This snippet shows how to generate self-signed certificates on the fly using the trustme library for testing purposes. It defines pytest fixtures for creating a certificate authority (CA), a server context, and a client context. These contexts can then be used with TLSListener or TLSStream to establish a secure connection.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport ssl\n\nimport pytest\nimport trustme\n\n\n@pytest.fixture(scope='session')\ndef ca():\n    return trustme.CA()\n\n\n@pytest.fixture(scope='session')\ndef server_context(ca):\n    server_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    ca.issue_cert('localhost').configure_cert(server_context)\n    return server_context\n\n\n@pytest.fixture(scope='session')\ndef client_context(ca):\n    client_context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ca.configure_trust(client_context)\n    return client_context\n```\n\n----------------------------------------\n\nTITLE: Marking Asynchronous Tests using anyio_backend fixture\nDESCRIPTION: This snippet shows how to mark asynchronous tests by directly including the `anyio_backend` fixture as a parameter in the test function. The `anyio_backend` fixture ensures the test is run with the AnyIO pytest plugin.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n\nasync def test_something(anyio_backend):\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Running a Test on a Specific Backend\nDESCRIPTION: This snippet shows how to run a single test on a specific backend using `@pytest.mark.parametrize`.  Remember to include the `anyio_backend` parameter to the actual test function. This example ensures the test runs only with the `asyncio` backend.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n\n@pytest.mark.parametrize('anyio_backend', ['asyncio'])\nasync def test_on_asyncio_only(anyio_backend):\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks\nDESCRIPTION: This command installs pre-commit hooks in the local Git repository. These hooks automatically run code style and quality checks before each commit, ensuring that changes meet the project's standards.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Marking Asynchronous Tests using pytest.mark.anyio\nDESCRIPTION: This snippet demonstrates how to mark a module containing asynchronous tests using the `@pytest.mark.anyio` marker. This is equivalent to applying `pytest.mark.usefixtures('anyio_backend')` to all test functions in the module, ensuring that the AnyIO pytest plugin picks them up.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n# This is the same as using the @pytest.mark.anyio on all test functions in the module\npytestmark = pytest.mark.anyio\n\n\nasync def test_something():\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Context Manager with AsyncContextManagerMixin\nDESCRIPTION: Demonstrates how to create an asynchronous context manager using AnyIO's AsyncContextManagerMixin. It defines a class `MyAsyncContextManager` that inherits from `AsyncContextManagerMixin` and implements the `__asynccontextmanager__` method using the `@asynccontextmanager` decorator. The `__asynccontextmanager__` method yields the instance, defining the enter and exit actions within the asynchronous context.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\nfrom typing import Self\n\nfrom anyio import AsyncContextManagerMixin\n\nclass MyAsyncContextManager(AsyncContextManagerMixin):\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:\n        print(\"entering context\")\n        yield self\n        print(\"exiting context\")\n```\n\n----------------------------------------\n\nTITLE: Specifying Backend Options with Tuples\nDESCRIPTION: This snippet demonstrates how to specify different backends and their options for testing. It uses `pytest.param` to define multiple configurations with different asyncio and trio options. The `anyio_backend` fixture returns a tuple containing the backend name and options dictionary.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n\n@pytest.fixture(params=[\n    pytest.param(('asyncio', {'use_uvloop': True}), id='asyncio+uvloop'),\n    pytest.param(('asyncio', {'use_uvloop': False}), id='asyncio'),\n    pytest.param(('trio', {'restrict_keyboard_interrupt_to_checkpoints': True}), id='trio')\n])\ndef anyio_backend(request):\n    return request.param\n\n```\n\n----------------------------------------\n\nTITLE: Specifying the Backend to Run On\nDESCRIPTION: This snippet shows how to specify the backend to run the tests on by overriding the `anyio_backend` fixture. This configuration will run all tests using the asyncio backend.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n\n@pytest.fixture\ndef anyio_backend():\n    return 'asyncio'\n\n```\n\n----------------------------------------\n\nTITLE: pytest.raises with ExceptionGroup\nDESCRIPTION: Illustrates how to adapt pytest tests to account for the change where task groups now raise ExceptionGroup even for single exceptions.  The test now checks for an ExceptionGroup containing a ValueError.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom exceptiongroup import ExceptionGroup\n\nwith pytest.raises(ExceptionGroup) as exc:\n    await function_using_a_taskgroup()\n\nassert len(exc.value.exceptions) == 1\nassert isinstance(exc.value.exceptions[0], ValueError)\n```\n\n----------------------------------------\n\nTITLE: Creating an Event in AnyIO with create_event\nDESCRIPTION: This code snippet demonstrates how to create an event object in AnyIO using the `create_event` function. The function `foo` is an asynchronous function that returns an `Event` object created using `create_event()`. The `anyio.abc.Event` is imported as well for type hinting.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_event\nfrom anyio.abc import Event\n\nasync def foo() -> Event:\n    return create_event()\n```\n\n----------------------------------------\n\nTITLE: Testing Network Services with ephemeral ports\nDESCRIPTION: This snippet demonstrates how to use AnyIO's native capability to bind to ephemeral ports and retrieve the assigned port number. It creates a TCP listener without specifying a local port, then retrieves the assigned port using `listener.extra(SocketAttribute.local_port)`.  This avoids the potential race condition of using `free_tcp_port`.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import connect_tcp, create_task_group, create_tcp_listener\nfrom anyio.abc import SocketAttribute, SocketStream\n\nasync def test_echo() -> None:\n    async def handle(client_stream: SocketStream) -> None:\n        async with client_stream:\n            payload = await client_stream.receive()\n            await client_stream.send(payload[::-1])\n\n        async with (\n            await create_tcp_listener(local_host=\"127.0.0.1\") as listener,\n            create_task_group() as tg\n        ):\n            tg.start_soon(listener.serve, handle)\n            port = listener.extra(SocketAttribute.local_port)\n\n            async with await connect_tcp(\"127.0.0.1\", port) as stream:\n                await stream.send(b\"hello\")\n                assert await stream.receive() == b\"olleh\"\n\n            tg.cancel_scope.cancel()\n\n```\n\n----------------------------------------\n\nTITLE: Running a function in a worker interpreter with AnyIO\nDESCRIPTION: This snippet demonstrates how to use `anyio.to_interpreter.run_sync` to execute a CPU-intensive function in a separate subinterpreter. It imports the necessary modules, defines an asynchronous main function, and calls the target function with arguments. The result is then printed to the console. Requires AnyIO and a `cpu_intensive_function` from `yourothermodule`.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/subinterpreters.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport time\n\nfrom anyio import run, to_interpreter\n\nfrom yourothermodule import cpu_intensive_function\n\nasync def main():\n    result = await to_interpreter.run_sync(\n        cpu_intensive_function, 'Hello, ', 'world!'\n    )\n    print(result)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Starting and Initializing Tasks with Task Status\nDESCRIPTION: This example shows how to use task status to wait until a task has successfully initialized itself. The `start_some_service` function starts a TCP listener and signals the caller when the listener is ready. The `main` function uses a task group to start the service and then connects to it.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import (\n    TASK_STATUS_IGNORED,\n    create_task_group,\n    connect_tcp,\n    create_tcp_listener,\n    run,\n)\nfrom anyio.abc import TaskStatus\n\n\nasync def handler(stream):\n    ...\n\n\nasync def start_some_service(\n    port: int, *, task_status: TaskStatus[None] = TASK_STATUS_IGNORED\n):\n    async with await create_tcp_listener(\n        local_host=\"127.0.0.1\", local_port=port\n    ) as listener:\n        task_status.started()\n        await listener.serve(handler)\n\n\nasync def main():\n    async with create_task_group() as tg:\n        await tg.start(start_some_service, 5000)\n        async with await connect_tcp(\"127.0.0.1\", 5000) as stream:\n            ...\n\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Adjusting the default maximum worker thread count in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates how to adjust the maximum number of worker threads that AnyIO will spawn. It modifies the total_tokens attribute of the current default thread limiter. Dependencies: anyio.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import to_thread\n\nasync def foo():\n    # Set the maximum number of worker threads to 60\n    to_thread.current_default_thread_limiter().total_tokens = 60\n```\n\n----------------------------------------\n\nTITLE: Install AnyIO\nDESCRIPTION: This command installs the AnyIO library using pip, the Python package installer. It is the basic way to get started using AnyIO.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install anyio\n```\n\n----------------------------------------\n\nTITLE: Shielding a task from cancellation in AnyIO\nDESCRIPTION: This code demonstrates how to shield a task from cancellation using a `CancelScope` with the `shield=True` argument. It creates a task group, starts an external task, cancels the task group's cancel scope, and then sleeps in the host task. The shielded block prevents the external task from being cancelled immediately, allowing the host task to complete its sleep.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import CancelScope, create_task_group, sleep, run\n\n\nasync def external_task():\n    print('Started sleeping in the external task')\n    await sleep(1)\n    print('This line should never be seen')\n\n\nasync def main():\n    async with create_task_group() as tg:\n        with CancelScope(shield=True) as scope:\n            tg.start_soon(external_task)\n            tg.cancel_scope.cancel()\n            print('Started sleeping in the host task')\n            await sleep(1)\n            print('Finished sleeping in the host task')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using AnyIO Conditions\nDESCRIPTION: This code demonstrates the use of AnyIO conditions for task synchronization. A condition combines an event and a lock. Tasks wait on the condition, and another task notifies them.  Only the task which locked a Condition can release it. The `notify`, `notify_all`, and `wait` methods are used for signaling and waiting.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Condition, create_task_group, sleep, run\n\n\nasync def listen(tasknum, condition):\n    async with condition:\n        await condition.wait()\n        print('Woke up task number', tasknum)\n\n\nasync def main():\n    condition = Condition()\n    async with create_task_group() as tg:\n        for tasknum in range(6):\n            tg.start_soon(listen, tasknum, condition)\n\n        await sleep(1)\n        async with condition:\n            condition.notify(1)\n\n        await sleep(1)\n        async with condition:\n            condition.notify(2)\n\n        await sleep(1)\n        async with condition:\n            condition.notify_all()\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Install AnyIO with Trio Support\nDESCRIPTION: This command installs AnyIO along with support for the Trio backend. This is done by using the \"trio\" extra during installation. This allows the user to run AnyIO programs using Trio as the asynchronous framework.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install anyio[trio]\n```\n\n----------------------------------------\n\nTITLE: Testing Network Services with free_tcp_port\nDESCRIPTION: This snippet demonstrates how to use the `free_tcp_port` fixture to avoid port conflicts when testing network services. It creates a TCP listener on an ephemeral port and then connects to it, sending and receiving data.  The `free_tcp_port` fixture provides an available TCP port number.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import connect_tcp, create_task_group, create_tcp_listener\nfrom anyio.abc import SocketStream\n\n\nasync def test_echo(free_tcp_port: int) -> None:\n    async def handle(client_stream: SocketStream) -> None:\n        async with client_stream:\n            payload = await client_stream.receive()\n            await client_stream.send(payload[::-1])\n\n    async with (\n        await create_tcp_listener(local_port=free_tcp_port) as listener,\n        create_task_group() as tg\n    ):\n        tg.start_soon(listener.serve, handle)\n\n        async with await connect_tcp(\"127.0.0.1\", free_tcp_port) as stream:\n            await stream.send(b\"hello\")\n            assert await stream.receive() == b\"olleh\"\n\n        tg.cancel_scope.cancel()\n\n```\n\n----------------------------------------\n\nTITLE: Broken Asynchronous Context Manager Example\nDESCRIPTION: Illustrates a common error when implementing asynchronous context managers, where a task group might not be properly exited if an exception occurs during the `__aenter__` method.  The `__aexit__` method will not be called if `create_task_group` fails or if the `start_soon` method fails due to a missing argument.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Self\n\nfrom anyio import create_task_group\n\nclass MyBrokenContextManager:\n    async def __aenter__(self) -> Self:\n        self._task_group = await create_task_group()\n        # BOOM: missing the \"arg\" argument here to my_background_func!\n        self._task_group.start_soon(self.my_background_func)\n        return self\n\n    async def __aexit__(self, exc_type, exc_value, traceback) -> bool | None:\n        return await self._task_group.__aexit__(exc_type, exc_value, traceback)\n\n    async my_background_func(self, arg: int) -> None:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Accessing Remote Address with SocketAttribute in AnyIO\nDESCRIPTION: This code demonstrates how to access the remote address of a TCP connection using the `SocketAttribute` typed attribute. It establishes a TCP connection and then prints the remote address obtained from the stream's extra attributes.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import connect_tcp\nfrom anyio.abc import SocketAttribute\n\n\nasync def connect(host, port, tls: bool):\n    stream = await connect_tcp(host, port, tls=tls)\n    print('Connected to', stream.extra(SocketAttribute.remote_address))\n```\n\n----------------------------------------\n\nTITLE: Opening a Cancel Scope (AnyIO 2/3 Compatibility)\nDESCRIPTION: Illustrates how to open a cancel scope using `maybe_async_cm` for compatibility between AnyIO 2 and AnyIO 3. `maybe_async_cm` manages the transition between `async with` and `with` statements.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import CancelScope, maybe_async_cm\n\nasync def foo():\n    async with maybe_async_cm(CancelScope()) as scope:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Errors in a Task Group (Older Python Versions)\nDESCRIPTION: This example demonstrates how to handle multiple exceptions in a task group in older Python versions using the `catch()` function from the `exceptiongroup` package. It defines handlers for `ValueError` and `KeyError` and associates them with the respective exception types within the `catch()` context.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import create_task_group\nfrom exceptiongroup import catch\n\ndef handle_valueerror(excgroup: ExceptionGroup) -> None:\n    for exc in excgroup.exceptions:\n        ...  # handle each ValueError\n\ndef handle_keyerror(excgroup: ExceptionGroup) -> None:\n    for exc in excgroup.exceptions:\n        ...  # handle each KeyError\n\nwith catch({\n    ValueError: handle_valueerror,\n    KeyError: handle_keyerror\n}):\n    async with create_task_group() as tg:\n        tg.start_soon(some_task)\n        tg.start_soon(another_task)\n```\n\n----------------------------------------\n\nTITLE: Inheriting Asynchronous Context Manager Classes\nDESCRIPTION: Demonstrates how to inherit from a class using AsyncContextManagerMixin and correctly call the superclass's `__asynccontextmanager__` method within the subclass.  This ensures that both the superclass and subclass asynchronous context management logic are executed in the correct order.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\nfrom typing import Self\n\nfrom anyio import AsyncContextManagerMixin\n\nclass SuperclassContextManager(AsyncContextManagerMixin):\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:\n        print(\"superclass entered\")\n        try:\n            yield self\n        finally:\n            print(\"superclass exited\")\n\n\nclass SubclassContextManager(SuperclassContextManager):\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:\n        print(\"subclass entered\")\n        try:\n            async with super().__asynccontextmanager__():\n                yield self\n        finally:\n            print(\"subclass exited\")\n```\n\n----------------------------------------\n\nTITLE: Using Trio's Native run() function\nDESCRIPTION: This example demonstrates how to use the native `trio.run()` function to execute an AnyIO program. It imports `sniffio`, `trio`, and `sleep` from `anyio`, defines an asynchronous `main` function that prints messages and pauses execution using `sleep(1)`, and then uses `trio.run(main)` to start the asynchronous execution.  It also demonstrates using sniffio to determine the current async library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sniffio\nimport trio\nfrom anyio import sleep\n\n\nasync def main():\n    print('Hello')\n    await sleep(1)\n    print(\"I'm running on\", sniffio.current_async_library())\n\ntrio.run(main)\n```\n\n----------------------------------------\n\nTITLE: Async Fixtures with Higher Scopes\nDESCRIPTION: This example showcases async fixtures with scopes other than `function`. A custom `anyio_backend` fixture with module scope is defined. The `server` fixture with module scope then utilizes this custom `anyio_backend` fixture. This is required because the default `anyio_backend` fixture has function scope.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n\n@pytest.fixture(scope='module')\ndef anyio_backend():\n    return 'asyncio'\n\n\n@pytest.fixture(scope='module')\nasync def server(anyio_backend):\n    server = await setup_server()\n    yield\n    await server.shutdown()\n\n```\n\n----------------------------------------\n\nTITLE: Memory Object Stream Example in AnyIO\nDESCRIPTION: This example demonstrates how to use memory object streams to implement a producer-consumer pattern using AnyIO. It creates a sender and receiver stream, starts a task to process items from the receiver stream, and sends numbers through the sender stream.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import create_task_group, create_memory_object_stream, run\nfrom anyio.streams.memory import MemoryObjectReceiveStream\n\n\nasync def process_items(receive_stream: MemoryObjectReceiveStream[str]) -> None:\n    async with receive_stream:\n        async for item in receive_stream:\n            print('received', item)\n\n\nasync def main():\n    # The [str] specifies the type of the objects being passed through the\n    # memory object stream. This is a bit of trick, as create_memory_object_stream\n    # is actually a class masquerading as a function.\n    send_stream, receive_stream = create_memory_object_stream[str]()\n    async with create_task_group() as tg:\n        tg.start_soon(process_items, receive_stream)\n        async with send_stream:\n            for num in range(10):\n                await send_stream.send(f'number {num}')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Connecting to TLS Server with AnyIO\nDESCRIPTION: This snippet demonstrates how to establish a TLS connection to a server using AnyIO's connect_tcp function. It includes loading a CA certificate and sending/receiving data over the secure connection.  The 'cert.pem' file is assumed to contain the necessary CA certificate for verifying the server's identity.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport ssl\nfrom anyio import connect_tcp, run\n\n\nasync def main():\n    # These two steps are only required for certificates that are not trusted by the\n    # installed CA certificates on your machine, so you can skip this part if you\n    # use Let's Encrypt or a commercial certificate vendor\n    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    context.load_verify_locations(cafile='cert.pem')\n\n    async with await connect_tcp('localhost', 1234, ssl_context=context) as client:\n        await client.send(b'Client\\n')\n        response = await client.receive()\n        print(response)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Inheriting Synchronous Context Manager Classes\nDESCRIPTION: Demonstrates how to inherit from a class using ContextManagerMixin and correctly call the superclass's `__contextmanager__` method within the subclass.  This ensures that both the superclass and subclass context management logic are executed in the correct order.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom typing import Self\n\nfrom anyio import ContextManagerMixin\n\nclass SuperclassContextManager(ContextManagerMixin):\n    @contextmanager\n    def __contextmanager__(self) -> Generator[Self]:\n        print(\"superclass entered\")\n        try:\n            yield self\n        finally:\n            print(\"superclass exited\")\n\n\nclass SubclassContextManager(SuperclassContextManager):\n    @contextmanager\n    def __contextmanager__(self) -> Generator[Self]:\n        print(\"subclass entered\")\n        try:\n            with super().__contextmanager__():\n                yield self\n        finally:\n            print(\"subclass exited\")\n```\n\n----------------------------------------\n\nTITLE: Setting nonlocal variables in exception handlers\nDESCRIPTION: Shows how to set nonlocal variables inside an exception handler, such as one used by the `exceptiongroup.catch()` function.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef handle_valueerror(exc):\n    nonlocal somevariable\n    somevariable = 'whatever'\n```\n\n----------------------------------------\n\nTITLE: Inheriting and Overriding Typed Attributes in AnyIO\nDESCRIPTION: This code demonstrates how to inherit from another typed attribute provider and override an attribute's value. It inherits from `MyAttributeProvider` and overrides the value of `string_valued_attribute` in the `extra_attributes` property.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass AnotherAttributeProvider(MyAttributeProvider):\n    @property\n    def extra_attributes() -> Mapping[Any, Callable[[], Any]]:\n        return {\n            **super().extra_attributes,\n            MyTypedAttribute.string_valued_attribute: lambda: 'overridden attribute value'\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Context Manager with ContextManagerMixin\nDESCRIPTION: Demonstrates how to create a synchronous context manager using AnyIO's ContextManagerMixin. It defines a class `MyContextManager` that inherits from `ContextManagerMixin` and implements the `__contextmanager__` method using the `@contextmanager` decorator. The `__contextmanager__` method yields the instance, defining the enter and exit actions within the context.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom typing import Self\n\nfrom anyio import ContextManagerMixin\n\nclass MyContextManager(ContextManagerMixin):\n    @contextmanager\n    def __contextmanager__(self) -> Generator[Self]:\n        print(\"entering context\")\n        yield self\n        print(\"exiting context\")\n```\n\n----------------------------------------\n\nTITLE: Suppressing Deprecation Warning for TaskGroup.spawn()\nDESCRIPTION: Shows how to suppress the deprecation warning when using `TaskGroup.spawn()` for code that needs to work with both AnyIO 2 and 3. A warnings context manager is used to catch the warning.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nasync def foo():\n    async with create_task_group() as tg:\n        with warnings.catch_warnings():\n            await tg.spawn(otherfunc)\n```\n\n----------------------------------------\n\nTITLE: Finalization with cancellation exception handling in AnyIO\nDESCRIPTION: This code shows how to perform cleanup operations in response to the failure of an operation, specifically when a cancellation exception is raised. It uses `get_cancelled_exc_class` to retrieve the cancellation exception class specific to the currently running async framework and catches it within a try-except block.  It's crucial to reraise the cancellation exception to avoid undefined behavior.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import get_cancelled_exc_class\n\n\nasync def do_something():\n    try:\n        await run_async_stuff()\n    except get_cancelled_exc_class():\n        # (perform cleanup)\n        raise\n```\n\n----------------------------------------\n\nTITLE: Buffered Byte Receive Stream Example in AnyIO\nDESCRIPTION: This example demonstrates the use of a buffered byte receive stream in AnyIO.  It creates a memory object stream, sends byte chunks through it, and then uses a BufferedByteReceiveStream to receive an exact number of bytes and receive data until a specific delimiter is found.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom anyio import run, create_memory_object_stream\nfrom anyio.streams.buffered import BufferedByteReceiveStream\n\n\nasync def main():\n    send, receive = create_memory_object_stream[bytes](4)\n    buffered = BufferedByteReceiveStream(receive)\n    for part in b'hel', b'lo, ', b'wo', b'rld!':\n        await send.send(part)\n\n    result = await buffered.receive_exactly(8)\n    print(repr(result))\n\n    result = await buffered.receive_until(b'!', 10)\n    print(repr(result))\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Receiving Signals with AnyIO\nDESCRIPTION: This code snippet demonstrates how to use AnyIO's `open_signal_receiver` to listen for `signal.SIGTERM` and `signal.SIGHUP` signals. When a signal is received, the code checks which signal it is and performs an action (either returns or prints a message). Requires the `signal` and `anyio` libraries.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/signals.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport signal\n\nfrom anyio import open_signal_receiver, run\n\n\nasync def main():\n    with open_signal_receiver(signal.SIGTERM, signal.SIGHUP) as signals:\n        async for signum in signals:\n            if signum == signal.SIGTERM:\n                return\n            elif signum == signal.SIGHUP:\n                print('Reloading configuration')\n\n    run(main)\n```\n\n----------------------------------------\n\nTITLE: Dubious usage of async generator with task group\nDESCRIPTION: This code example illustrates a problematic pattern where an async generator is used with a task group, violating structural concurrency. The spawned task might raise an exception after the host task has yielded, leading to unexpected behavior. This pattern should be avoided to prevent potential issues with cancellation and exception handling.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Bad!\nasync def some_generator():\n    async with create_task_group() as tg:\n        tg.start_soon(foo)\n        yield\n```\n\n----------------------------------------\n\nTITLE: Cloning the Forked Repository\nDESCRIPTION: This command clones a forked AnyIO repository to your local machine using Git. Replace 'yourusername' with your actual GitHub username.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_3\n\nLANGUAGE: git\nCODE:\n```\ngit clone git@github.com/yourusername/anyio\n```\n\n----------------------------------------\n\nTITLE: Creating and Serving a UNIX Socket Listener with AnyIO\nDESCRIPTION: This code shows how to create a UNIX domain socket listener using AnyIO's create_unix_listener and serve incoming connections. It defines a handler function that receives data from a client and sends back a response. Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_unix_listener, run\n\n\nasync def handle(client):\n    async with client:\n        name = await client.receive(1024)\n        await client.send(b'Hello, %s\\n' % name)\n\n\nasync def main():\n    listener = await create_unix_listener('/tmp/mysock')\n    await listener.serve(handle)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Calling asynchronous code from a worker thread in AnyIO (Python)\nDESCRIPTION: This snippet shows how to call an asynchronous function (sleep) from a worker thread using AnyIO's from_thread.run function. This requires that the worker thread was started using to_thread.run_sync. This example demonstrates how to execute asynchronous code within a synchronous function that's already running in a separate thread.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import from_thread, sleep, to_thread, run\n\n\ndef blocking_function():\n    from_thread.run(sleep, 5)\n\n\nasync def main():\n    await to_thread.run_sync(blocking_function)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using AnyIO Semaphores\nDESCRIPTION: This code demonstrates the use of AnyIO semaphores to limit access to a shared resource. A semaphore is initialized with a maximum value, and tasks acquire and release the semaphore to access the resource. The `fast_acquire` parameter can be passed to the Semaphore constructor to potentially improve performance.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Semaphore, create_task_group, sleep, run\n\n\nasync def use_resource(tasknum, semaphore):\n    async with semaphore:\n        print('Task number', tasknum, 'is now working with the shared resource')\n        await sleep(1)\n\n\nasync def main():\n    semaphore = Semaphore(2)\n    async with create_task_group() as tg:\n        for num in range(10):\n            tg.start_soon(use_resource, num, semaphore)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Sending File Descriptors over UNIX Sockets (Server)\nDESCRIPTION: This snippet demonstrates how to send file descriptors over a UNIX socket using AnyIO. It creates a listener, handles connections, opens a file, and sends its descriptor to the client. Requires the anyio and pathlib libraries.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\n\nfrom anyio import create_unix_listener, run\n\n\nasync def handle(client):\n    async with client:\n        with path.open('r') as file:\n            await client.send_fds(b'this message is ignored', [file])\n\n\nasync def main():\n    listener = await create_unix_listener('/tmp/mysock')\n    await listener.serve(handle)\n\npath = Path('/tmp/examplefile')\npath.write_text('Test file')\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Forked Repository\nDESCRIPTION: This command pushes the changes you've made on your local branch to your forked repository on GitHub.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_5\n\nLANGUAGE: git\nCODE:\n```\ngit push\n```\n\n----------------------------------------\n\nTITLE: Collapsing Single-Exception Groups for AnyIO 3 and 4 Compatibility\nDESCRIPTION: Provides a context manager that \"collapses\" single-exception groups by unwrapping them, ensuring compatibility between AnyIO 3 and 4. This code checks for BaseExceptionGroup and if it contains only one exception, it unwraps it.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom contextlib import contextmanager\nfrom typing import Generator\n\nhas_exceptiongroups = True\nif sys.version_info < (3, 11):\n    try:\n        from exceptiongroup import BaseExceptionGroup\n    except ImportError:\n        has_exceptiongroups = False\n\n\n@contextmanager\ndef collapse_excgroups() -> Generator[None, None, None]:\n    try:\n        yield\n    except BaseException as exc:\n        if has_exceptiongroups:\n            while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:\n                exc = exc.exceptions[0]\n\n        raise exc\n```\n\n----------------------------------------\n\nTITLE: Spawning tasks from worker threads using BlockingPortal in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates how to spawn tasks from worker threads using BlockingPortal.start_task_soon. It starts multiple long-running tasks and waits for their completion using concurrent.futures.as_completed. Dependencies: concurrent.futures, anyio.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom concurrent.futures import as_completed\n\nfrom anyio import sleep\nfrom anyio.from_thread import start_blocking_portal\n\n\nasync def long_running_task(index):\n    await sleep(1)\n    print(f'Task {index} running...')\n    await sleep(index)\n    return f'Task {index} return value'\n\n\nwith start_blocking_portal() as portal:\n    futures = [portal.start_task_soon(long_running_task, i) for i in range(1, 5)]\n    for future in as_completed(futures):\n        print(future.result())\n```\n\n----------------------------------------\n\nTITLE: Safe usage of async context manager with task group\nDESCRIPTION: This code shows a generally safe pattern for using an async context manager with a task group. As long as the same host task continues to run throughout the entire enclosed code block, this pattern should be acceptable, preventing issues with structural concurrency and exception handling.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import asynccontextmanager\n\n\n# Okay in most cases!\n@asynccontextmanager\nasync def some_context_manager():\n    async with create_task_group() as tg:\n        tg.start_soon(foo)\n        yield\n```\n\n----------------------------------------\n\nTITLE: Creating and Serving a TCP Listener with AnyIO\nDESCRIPTION: This code shows how to create a TCP listener using AnyIO's create_tcp_listener and serve incoming connections. It defines a handler function that receives data from a client and sends back a response. Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_tcp_listener, run\n\n\nasync def handle(client):\n    async with client:\n        name = await client.receive(1024)\n        await client.send(b'Hello, %s\\n' % name)\n\n\nasync def main():\n    listener = await create_tcp_listener(local_port=1234)\n    await listener.serve(handle)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Creating a Connected UNIX Datagram Socket with AnyIO\nDESCRIPTION: This code demonstrates how to create a connected UNIX datagram socket using AnyIO's create_connected_unix_datagram_socket. It sends data to a specified remote path without needing to specify the address on each send. Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_connected_unix_datagram_socket, run\n\n\nasync def main():\n    async with await create_connected_unix_datagram_socket(\n        remote_path='/dev/log'\n    ) as unix_dg:\n        await unix_dg.send(b'Hi there!\\n')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Sharing a blocking portal on demand in AnyIO (Python)\nDESCRIPTION: This snippet shows how to use BlockingPortalProvider to efficiently share a single blocking portal across multiple threads, avoiding the overhead of creating a new portal for each call.  Dependencies: anyio.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio.from_thread import BlockingPortalProvider\n\nclass MyAPI:\n    def __init__(self, async_obj) -> None:\n        self._async_obj = async_obj\n        self._portal_provider = BlockingPortalProvider()\n\n    def do_stuff(self) -> None:\n        with self._portal_provider as portal:\n            portal.call(self._async_obj.do_async_stuff)\n```\n\n----------------------------------------\n\nTITLE: Using AnyIO Events\nDESCRIPTION: This code demonstrates how to use AnyIO events to notify tasks. An event is created, a task is started to set the event, and the main task waits for the event to be set before printing a message. AnyIO events cannot be reused and must be replaced.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Event, create_task_group, run\n\n\nasync def notify(event):\n    event.set()\n\n\nasync def main():\n    event = Event()\n    async with create_task_group() as tg:\n        tg.start_soon(notify, event)\n        await event.wait()\n        print('Received notification!')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Synchronization Primitives (AnyIO 3)\nDESCRIPTION: Illustrates the new way of creating an event by instantiating the `Event` class directly in AnyIO 3.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import Event\n\nasync def main():\n    event = Event()\n```\n\n----------------------------------------\n\nTITLE: Creating a Connected UDP Socket with AnyIO\nDESCRIPTION: This code demonstrates how to create a connected UDP socket using AnyIO's create_connected_udp_socket. It sends data to a specified remote host and port without needing to specify the address on each send. Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_connected_udp_socket, run\n\n\nasync def main():\n    async with await create_connected_udp_socket(\n            remote_host='hostname', remote_port=1234) as udp:\n        await udp.send(b'Hi there!\\n')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Fixture Example\nDESCRIPTION: This snippet demonstrates the use of an asynchronous fixture with AnyIO. The `server` fixture sets up and shuts down an asynchronous server, which is then used in the `test_server` function.  The module is marked with `pytest.mark.anyio` to enable AnyIO support.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\npytestmark = pytest.mark.anyio\n\n\n@pytest.fixture\nasync def server():\n    server = await setup_server()\n    yield server\n    await server.shutdown()\n\n\nasync def test_server(server):\n    result = await server.do_something()\n    assert result == 'foo'\n\n```\n\n----------------------------------------\n\nTITLE: Creating a UNIX Datagram Socket with AnyIO\nDESCRIPTION: This example shows how to create a UNIX datagram socket using AnyIO's create_unix_datagram_socket. It listens for incoming packets and sends a response back to the sender. Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_unix_datagram_socket, run\n\n\nasync def main():\n    async with await create_unix_datagram_socket(\n        local_path='/tmp/mysock'\n    ) as unix_dg:\n        async for packet, path in unix_dg:\n            await unix_dg.sendto(b'Hello, ' + packet, path)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Simple Async AnyIO Program\nDESCRIPTION: This code snippet demonstrates a basic AnyIO program. It imports the `run` function from the `anyio` library, defines an asynchronous `main` function that prints \"Hello, world!\", and then uses `run(main)` to execute the asynchronous function on the default backend (asyncio).\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import run\n\n\nasync def main():\n    print('Hello, world!')\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Providing Values for Custom Typed Attributes in AnyIO\nDESCRIPTION: This code demonstrates how to provide values for custom typed attributes using the `TypedAttributeProvider` class. The `extra_attributes` property returns a mapping of attribute keys to callable functions that return the attribute values.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable, Mapping\n\nfrom anyio import TypedAttributeProvider\n\n\nclass MyAttributeProvider(TypedAttributeProvider):\n    @property\n    def extra_attributes() -> Mapping[Any, Callable[[], Any]]:\n        return {\n            MyTypedAttribute.string_valued_attribute: lambda: 'my attribute value',\n            MyTypedAttribute.some_float_attribute: lambda: 6.492\n        }\n```\n\n----------------------------------------\n\nTITLE: Connecting to a TCP Socket with AnyIO\nDESCRIPTION: This code snippet demonstrates how to connect to a TCP socket using AnyIO's connect_tcp function. It connects to a specified hostname and port, sends data, and receives a response. Requires the anyio library.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import connect_tcp, run\n\n\nasync def main():\n    async with await connect_tcp('hostname', 1234) as client:\n        await client.send(b'Client\\n')\n        response = await client.receive()\n        print(response)\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Using start_blocking_portal with trio backend in AnyIO (Python)\nDESCRIPTION: This snippet demonstrates how to use start_blocking_portal to create a new event loop and a blocking portal in a thread, enabling synchronous code to call asynchronous code. It specifies 'trio' as the backend.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio.from_thread import start_blocking_portal\n\n\nwith start_blocking_portal(backend='trio') as portal:\n    portal.call(...)\n```\n\n----------------------------------------\n\nTITLE: Autouse Asynchronous Fixture Example\nDESCRIPTION: This snippet demonstrates an `autouse` asynchronous fixture.  The `server` fixture is automatically used by all tests in the module. The `anyio_backend` fixture is used within the `server` fixture to ensure that AnyIO support is enabled.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nimport pytest\n\n\n@pytest.fixture(autouse=True)\nasync def server(anyio_backend):\n    server = await setup_server()\n    yield\n    await server.shutdown()\n\n\nasync def test_server():\n    result = await client.do_something_on_the_server()\n    assert result == 'foo'\n\n```\n\n----------------------------------------\n\nTITLE: Running a One-Shot Command with Shell (AnyIO)\nDESCRIPTION: This snippet demonstrates how to run an external command (ps) using AnyIO's run_process function, passing the command as a string. This uses the default shell (shell=True). The result is decoded and printed to the console.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import run_process, run\n\n\nasync def main():\n    result = await run_process('ps')\n    print(result.stdout.decode())\n\nrun(main)\n```\n\n----------------------------------------\n\nTITLE: Running Async Program with Trio Backend\nDESCRIPTION: This code snippet shows how to run an asynchronous program using the Trio backend. The `run` function is called with the `backend` argument set to `'trio'`, which tells AnyIO to execute the asynchronous `main` function using the Trio asynchronous framework.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nrun(main, backend='trio')\n```\n\n----------------------------------------\n\nTITLE: Catching ValueError with exceptiongroup backport (Python < 3.11)\nDESCRIPTION: Shows how to catch a ValueError using the exceptiongroup backport for compatibility with Python versions older than 3.11.  The catch context manager is used to handle the exception.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom exceptiongroup import ExceptionGroup, catch\n\ndef handle_value_errors(excgrp: ExceptionGroup) -> None:\n    ...\n\nwith catch({ValueError: handle_value_errors}):\n    await function_using_a_taskgroup()\n```\n\n----------------------------------------\n\nTITLE: Generating Self-Signed Certificate with OpenSSL\nDESCRIPTION: This command demonstrates how to create a self-signed certificate for localhost using the openssl command-line tool. It generates a 2048-bit RSA key and a certificate valid for one year.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nopenssl req -x509 -newkey rsa:2048 -subj '/CN=localhost' -keyout key.pem -out cert.pem -nodes -days 365\n```\n\n----------------------------------------\n\nTITLE: Creating Type Annotated Memory Object Streams (AnyIO 4)\nDESCRIPTION: Shows the new syntax for creating type annotated memory object streams in AnyIO 4. :class:`create_memory_object_stream() <create_memory_object_stream>` is now a class, and you need to parametrize it with the desired type.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsend, receive = create_memory_object_stream[int](100)\n```\n\n----------------------------------------\n\nTITLE: Setting an Event (AnyIO 2/3 Compatibility)\nDESCRIPTION: Demonstrates how to set an event using `maybe_async` for compatibility between AnyIO 2 and AnyIO 3. The `maybe_async` function handles whether to await the event.set() call.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio.abc import Event\nfrom anyio import maybe_async\n\n\nasync def foo(event: Event):\n    await maybe_async(event.set())\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Typed Attributes in AnyIO\nDESCRIPTION: This code defines a custom typed attribute set called `MyTypedAttribute` using `TypedAttributeSet`. It defines two attributes: `string_valued_attribute` of type `str` and `some_float_attribute` of type `float`.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import TypedAttributeSet, typed_attribute\n\n\nclass MyTypedAttribute(TypedAttributeSet):\n    string_valued_attribute: str = typed_attribute()\n    some_float_attribute: float = typed_attribute()\n```\n\n----------------------------------------\n\nTITLE: Catching ValueError with ExceptionGroup (Python 3.11+)\nDESCRIPTION: Demonstrates how to catch a ValueError wrapped in an ExceptionGroup in Python 3.11 and later using the except* syntax.  excgrp is now an ExceptionGroup object.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    await function_using_a_taskgroup()\nexcept* ValueError as excgrp:\n    # Note: excgrp is an ExceptionGroup now!\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using uvloop Event Loop Factory (AnyIO 4)\nDESCRIPTION: Shows the updated method of using uvloop with :func:`run` in AnyIO 4 by providing an event loop factory instead of an event loop policy.  The loop_factory option should be set to uvloop.new_event_loop.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nanyio.run(main, backend_options={\"loop_factory\": uvloop.new_event_loop})\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Tox\nDESCRIPTION: This command is used to run the test suite for AnyIO using tox. The -p flag runs the checks on all environments in parallel, speeding up the testing process.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntox -p\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with Tox\nDESCRIPTION: This command builds the AnyIO documentation using tox. It generates a 'build' directory containing the formatted HTML documentation, which can then be viewed.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntox -e docs\n```\n\n----------------------------------------\n\nTITLE: Using uvloop Event Loop Policy (AnyIO 3)\nDESCRIPTION: Illustrates how to use a custom asyncio event loop policy with :func:`run` in AnyIO 3. This involves setting the event_loop_policy in backend_options.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nanyio.run(main, backend_options={\"event_loop_policy\": uvloop.EventLoopPolicy()})\n```\n\n----------------------------------------\n\nTITLE: Using start_blocking_portal as a context manager\nDESCRIPTION: Demonstrates the required usage of `start_blocking_portal` as a context manager. The blocking portal must be used with the 'with' statement.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import sleep\nfrom anyio.from_thread import start_blocking_portal\n\nwith start_blocking_portal() as portal:\n    portal.call(sleep, 1)\n```\n\n----------------------------------------\n\nTITLE: Synchronization Primitives (AnyIO 2/3 Compatibility)\nDESCRIPTION: Provides a compatibility solution for creating synchronization primitives by assigning the class to the factory function name when the class is available.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from anyio import Event\n    create_event = Event\nexcept ImportError:\n```\n\n----------------------------------------\n\nTITLE: Creating a Branch for a Pull Request\nDESCRIPTION: This command creates a new branch for your pull request and switches to it.  Replace 'myfixname' with a descriptive name for your branch.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_4\n\nLANGUAGE: git\nCODE:\n```\ngit checkout -b myfixname\n```\n\n----------------------------------------\n\nTITLE: Creating Type Annotated Memory Object Streams (AnyIO 3)\nDESCRIPTION: Demonstrates the old way of creating type annotated memory object streams in AnyIO 3. The desired type is passed as the second argument.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsend, receive = create_memory_object_stream(100, int)\n```\n\n----------------------------------------\n\nTITLE: Synchronization Primitive Factories (AnyIO 2)\nDESCRIPTION: Shows the old way of creating an event using the `create_event()` factory function in AnyIO 2.\nSOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom anyio import create_event\n\nasync def main():\n    event = create_event()\n```"
  }
]