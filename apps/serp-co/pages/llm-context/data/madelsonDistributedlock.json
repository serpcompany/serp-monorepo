[
  {
    "owner": "madelson",
    "repo": "distributedlock",
    "content": "TITLE: Acquiring a Distributed Lock Using Async/Await Pattern in C#\nDESCRIPTION: Basic example of acquiring a distributed lock asynchronously using the await pattern. The lock is automatically released when execution leaves the using block due to await using syntax.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nawait using (await myDistributedLock.AcquireAsync())\n{\n\t// I hold the lock here\n}\n```\n\n----------------------------------------\n\nTITLE: Acquiring a Distributed Lock Using Synchronous Pattern in C#\nDESCRIPTION: Example of acquiring a distributed lock synchronously using the using statement. The lock is automatically released when the using block is exited.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar myDistributedLock = new SqlDistributedLock(name, connectionString); // e. g. if we are using SQL Server\nusing (myDistributedLock.Acquire())\n{\n\t// we hold the lock here\n} // implicit Dispose() call from using block releases it here\n```\n\n----------------------------------------\n\nTITLE: Acquiring an Azure Blob Lease Distributed Lock in C#\nDESCRIPTION: Demonstrates how to create and use an AzureBlobLeaseDistributedLock. It shows the process of creating a BlobContainerClient, initializing the lock, and attempting to acquire it asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.Azure.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar container = new BlobContainerClient(myAzureConnectionString, \"my-locking-container-name\");\nvar @lock = new AzureBlobLeaseDistributedLock(container, \"MyLockName\");\nawait using (var handle = await @lock.TryAcquireAsync())\n{\n  if (handle != null) { /* I have the lock */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Using TryAcquire Pattern with Distributed Locks in C#\nDESCRIPTION: Demonstrates the non-blocking TryAcquire method which returns null if the lock cannot be acquired, rather than waiting. This pattern allows for executing alternate code paths when a lock is unavailable.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/README.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing (var handle = myDistributedLock.TryAcquire())\n{\n\tif (handle != null)\n\t{\n\t\t// we acquired the lock :-)\n\t}\n\telse\n\t{\n\t\t// someone else has it :-(\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency Injection with Distributed Lock Providers in ASP.NET Core\nDESCRIPTION: Example of integrating DistributedLock with ASP.NET Core's dependency injection system. Shows how to register a lock provider in Startup.cs and use it within a service class.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/README.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// in your Startup.cs:\nservices.AddSingleton<IDistributedLockProvider>(_ => new PostgresDistributedSynchronizationProvider(myConnectionString));\nservices.AddTransient<SomeService>();\n\n// in SomeService.cs\npublic class SomeService\n{\n\tprivate readonly IDistributedLockProvider _synchronizationProvider;\n\n\tpublic SomeService(IDistributedLockProvider synchronizationProvider)\n\t{\n\t\tthis._synchronizationProvider = synchronizationProvider;\n\t}\n\t\n\tpublic void InitializeUserAccount(int id)\n\t{\n\t\t// use the provider to construct a lock\n\t\tvar @lock = this._synchronizationProvider.CreateLock($\"UserAccount{id}\");\n\t\tusing (@lock.Acquire())\n\t\t{\n\t\t\t// do stuff\n\t\t}\n\t\t\n\t\t// ALTERNATIVELY, for common use-cases extension methods allow this to be done with a single call\n\t\tusing (this._synchronizationProvider.AcquireLock($\"UserAccount{id}\"))\n\t\t{\n\t\t\t// do stuff\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Azure Blob Lease Distributed Lock Class Definition in C#\nDESCRIPTION: Defines the AzureBlobLeaseDistributedLock class which implements distributed locking using Azure Blob Storage. It provides constructors for initializing with container or blob clients, and methods for acquiring locks synchronously and asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Azure/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.Acquire(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle!\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.AcquireAsync(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle!>\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.AzureBlobLeaseDistributedLock(Azure.Storage.Blobs.BlobContainerClient! blobContainerClient, string! name, System.Action<Medallion.Threading.Azure.AzureBlobLeaseOptionsBuilder!>? options = null) -> void\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.AzureBlobLeaseDistributedLock(Azure.Storage.Blobs.Specialized.BlobBaseClient! blobClient, System.Action<Medallion.Threading.Azure.AzureBlobLeaseOptionsBuilder!>? options = null) -> void\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.Name.get -> string!\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.TryAcquire(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle?\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLock.TryAcquireAsync(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle?>\n```\n\n----------------------------------------\n\nTITLE: Implementing Distributed Cache with Reader-Writer Locks in C#\nDESCRIPTION: Example implementation of a distributed cache using SqlDistributedReaderWriterLock. Shows how to efficiently handle cache operations using read and write locks, with double-checking pattern to prevent race conditions.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Reader-writer locks.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass DistributedCache\n{\n    // uses the SQLServer implementation, but others are available as well\n    private readonly SqlDistributedReaderWriterLock _cacheLock = \n        new SqlDistributedReaderWriterLock(\"DistributedCache\", connectionString);\n        \n    /// <summary>\n    /// If key is present in the cache, returns the associated value. If key is not present, generates a new\n    /// value with the provided valueFactory, stores that value in the cache, and returns the generated value.\n    /// </summary>\n    public async Task<object> GetOrCreateAsync(string key, Func<string, object> valueFactory)\n    {\n        // first, take the read lock to avoid blocking the cache in the case of a cache hit\n        await using (await this._cacheLock.AcquireReadLockAsync())\n        {\n            var cached = await this.GetValueOrDefaultNoLockAsync(key);\n            if (cached != null) { return cached; } // cache hit\n        }\n        \n        // seems like we'll need to write to the cache; take the write lock\n        await using (await this._cacheLock.AcquireWriteLockAsync())\n        {\n            // double-check: the value might have been written by another process \n            // while we were waiting to get the write lock\n            var cached = await this.GetValueOrDefaultNoLockAsync(key);\n            if (cached != null) { return cached; } // cache hit\n            \n            var generated = valueFactory(key);\n            await this.SetValueAsync(key, generated);\n            return generated;\n        }\n    }\n    \n    private async Task<object?> GetValueOrDefaultNoLockAsync(string key) { /* reads from underlying storage */ }\n    \n    private async Task SetValueAsync(string key, object value) { /* writes to underlying storage */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Distributed Lock in a Using Block in C#\nDESCRIPTION: Demonstrates using the IDistributedLock interface in a proper using block pattern to ensure locks are properly released when exiting the scope. This pattern leverages C#'s IDisposable implementation for automatic resource cleanup.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var myLock = myLockProvider.CreateLock(\"MyLockName\"))\n{\n    myLock.Acquire();\n    // critical section\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Shopping Cart Service with Upgradeable Reader-Writer Locks in C#\nDESCRIPTION: Demonstrates the use of upgradeable reader-writer locks in a shopping cart service. Shows how to handle concurrent cart operations while maintaining data consistency during checkout process.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Reader-writer locks.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass ShoppingCartService\n{\n    public ShoppingCartDetails GetDetails(Guid cartId)\n    {\n        using (this.GetCartLock(cartId).AcquireReadLock())\n        {\n            // read from cart data model\n        }\n    }\n    \n    public void Checkout(Guid cartId)\n    {\n        using var handle = this.GetCartLock(cartId).AcquireUpgradeableReadLock();\n        \n        // This makes some API calls to other systems and can be slow. We want an upgradeable \n        // read lock because we don't want to call Submit() multiple times for the same cart, but we\n        // don't need to block readers of the cart data model because we're not editing it\n        var submissionInfo = SubmitOrder(cartId);\n        \n        // now it's time to edit the cart data model, so upgrade to a write lock\n        handle.UpgradeToWriteLock();\n        \n        // write to cart data model\n    }\n    \n    private SqlDistributedReaderWriterLock GetCartLock(Guid cartId) =>\n        new SqlDistributedReaderWriterLock(\"Cart_\" + cartId, connectionString);\n}\n```\n\n----------------------------------------\n\nTITLE: Azure Blob Lease Distributed Synchronization Provider Class Definition in C#\nDESCRIPTION: Defines the AzureBlobLeaseDistributedSynchronizationProvider class which creates lock instances. It serves as a factory for creating locks with consistent configuration settings.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Azure/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Azure.AzureBlobLeaseDistributedSynchronizationProvider\nMedallion.Threading.Azure.AzureBlobLeaseDistributedSynchronizationProvider.AzureBlobLeaseDistributedSynchronizationProvider(Azure.Storage.Blobs.BlobContainerClient! blobContainerClient, System.Action<Medallion.Threading.Azure.AzureBlobLeaseOptionsBuilder!>? options = null) -> void\nMedallion.Threading.Azure.AzureBlobLeaseDistributedSynchronizationProvider.CreateLock(string! name) -> Medallion.Threading.Azure.AzureBlobLeaseDistributedLock!\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Distributed Semaphore in C#\nDESCRIPTION: Demonstrates how to create and use a Redis-based distributed semaphore to limit concurrent access to a resource. The example shows limiting database access to 5 concurrent callers using a semaphore with proper resource disposal pattern.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Semaphores.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// uses the Redis implementation; others are available\nvar semaphore = new RedisDistributedSemaphore(\"ComputeDatabase\", maxCount: 5, database: database);\nusing (semaphore.Acquire())\n{\n    // only 5 callers can be inside this block concurrently\n    UseComputeDatabase();\n}\n```\n\n----------------------------------------\n\nTITLE: Azure Blob Lease Distributed Lock Handle Class Definition in C#\nDESCRIPTION: Defines the AzureBlobLeaseDistributedLockHandle class which represents an acquired lock. It provides methods for releasing locks and properties for accessing the lease ID and monitoring lock status.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Azure/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle.Dispose() -> void\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle.HandleLostToken.get -> System.Threading.CancellationToken\nMedallion.Threading.Azure.AzureBlobLeaseDistributedLockHandle.LeaseId.get -> string!\n```\n\n----------------------------------------\n\nTITLE: Using SqlDistributedLock with Async/Await in C#\nDESCRIPTION: Example demonstrating how to acquire and use a SQL Server-based distributed lock asynchronously. The lock is created with a name and connection string, then acquired using async/await pattern.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.SqlServer.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar @lock = new SqlDistributedLock(\"MyLockName\", connectionString);\nawait using (await @lock.AcquireAsync())\n{\n  // I have the lock\n}\n```\n\n----------------------------------------\n\nTITLE: Oracle Distributed Reader-Writer Lock Definition\nDESCRIPTION: Implementation of a distributed reader-writer lock using Oracle. Supports read, upgradeable read, and write lock modes with async operations.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Oracle/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Oracle.OracleDistributedReaderWriterLock\nMedallion.Threading.Oracle.OracleDistributedReaderWriterLock.AcquireReadLock(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default)\nMedallion.Threading.Oracle.OracleDistributedReaderWriterLock.AcquireWriteLock(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default)\n```\n\n----------------------------------------\n\nTITLE: Basic PostgreSQL Distributed Lock Usage in C#\nDESCRIPTION: Demonstrates how to create and acquire a distributed lock using PostgreSQL advisory locks. The example shows the basic pattern of creating a lock with a named key and connection string, then acquiring it asynchronously using a using block.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.Postgres.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar @lock = new PostgresDistributedLock(new PostgresAdvisoryLockKey(\"MyLockName\", allowHashing: true), connectionString);\nawait using (await @lock.AcquireAsync())\n{\n   // I have the lock\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventWaitHandleDistributedLock Class in C#\nDESCRIPTION: This class implements a distributed lock using event wait handles. It provides methods for acquiring and releasing locks both synchronously and asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.WaitHandles/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock.Acquire(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle!\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock.AcquireAsync(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle!>\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock.EventWaitHandleDistributedLock(string! name, System.TimeSpan? abandonmentCheckCadence = null, bool exactName = false) -> void\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock.Name.get -> string!\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock.TryAcquire(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle?\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLock.TryAcquireAsync(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle?>\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using RedisDistributedLock in C#\nDESCRIPTION: This snippet demonstrates how to create a Redis connection, initialize a RedisDistributedLock, and attempt to acquire the lock asynchronously. It shows the basic usage pattern for distributed locking with Redis.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.Redis.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar connection = await ConnectionMultiplexer.ConnectAsync(connectionString); // uses StackExchange.Redis\nvar @lock = new RedisDistributedLock(\"MyLockName\", connection.GetDatabase());\nawait using (var handle = await @lock.TryAcquireAsync())\n{\n    if (handle != null) { /* I have the lock */ }\n}\n```\n\n----------------------------------------\n\nTITLE: FileDistributedLockHandle Class API Signatures in C#\nDESCRIPTION: Defines the public API for the FileDistributedLockHandle class, which represents an acquired distributed lock. This handle provides methods for disposing the lock both synchronously and asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.FileSystem/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.FileSystem.FileDistributedLockHandle\nMedallion.Threading.FileSystem.FileDistributedLockHandle.Dispose() -> void\nMedallion.Threading.FileSystem.FileDistributedLockHandle.DisposeAsync() -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Using FileDistributedLock with TryAcquireAsync in C#\nDESCRIPTION: Example of creating and using a FileDistributedLock to acquire a distributed lock based on a file. The lock is created in the current directory with a specified name, and then acquired asynchronously with TryAcquireAsync.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.FileSystem.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar lockFileDirectory = new DirectoryInfo(Environment.CurrentDirectory); // choose where the lock files will live\nvar @lock = new FileDistributedLock(lockFileDirectory, \"MyLockName\");\nawait using (var handle = await @lock.TryAcquireAsync())\n{\n    if (handle != null) { /* I have the lock */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing SqlDistributedSynchronizationProvider in C#\nDESCRIPTION: Constructors for SqlDistributedSynchronizationProvider class. Provides options to initialize with a connection string, database connection, or transaction.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.SqlServer/PublicAPI.Shipped.txt#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.SqlServer.SqlDistributedSynchronizationProvider.SqlDistributedSynchronizationProvider(string! connectionString, System.Action<Medallion.Threading.SqlServer.SqlConnectionOptionsBuilder!>? options = null) -> void\n\nMedallion.Threading.SqlServer.SqlDistributedSynchronizationProvider.SqlDistributedSynchronizationProvider(System.Data.IDbConnection! connection) -> void\n\nMedallion.Threading.SqlServer.SqlDistributedSynchronizationProvider.SqlDistributedSynchronizationProvider(System.Data.IDbTransaction! transaction) -> void\n```\n\n----------------------------------------\n\nTITLE: Acquiring an Oracle Distributed Lock in C#\nDESCRIPTION: This code demonstrates how to create and acquire a distributed lock using the OracleDistributedLock class. It shows the basic pattern of instantiating a lock with a name and connection string, then acquiring and using the lock within a using block.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.Oracle.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar @lock = new OracleDistributedLock(\"MyLockName\", connectionString);\nusing (@lock.Acquire())\n{\n   // I have the lock\n}\n```\n\n----------------------------------------\n\nTITLE: Managing SqlDistributedSemaphoreHandle in C#\nDESCRIPTION: Methods for disposing SqlDistributedSemaphoreHandle and accessing its HandleLostToken. Includes both synchronous and asynchronous disposal methods.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.SqlServer/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.SqlServer.SqlDistributedSemaphoreHandle.Dispose() -> void\n\nMedallion.Threading.SqlServer.SqlDistributedSemaphoreHandle.DisposeAsync() -> System.Threading.Tasks.ValueTask\n\nMedallion.Threading.SqlServer.SqlDistributedSemaphoreHandle.HandleLostToken.get -> System.Threading.CancellationToken\n```\n\n----------------------------------------\n\nTITLE: Acquiring a MySQL Distributed Lock in C#\nDESCRIPTION: Demonstrates how to create and acquire a MySQL-based distributed lock using the MySqlDistributedLock class. The lock is acquired asynchronously and automatically released when the using block ends.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.MySql.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar @lock = new MySqlDistributedLock(\"mylockname\", connectionString);\nawait using (await @lock.AcquireAsync())\n{\n   // I have the lock\n}\n```\n\n----------------------------------------\n\nTITLE: Oracle Connection Options Builder\nDESCRIPTION: Builder pattern implementation for configuring Oracle connection options including multiplexing and keepalive settings.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Oracle/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Oracle.OracleConnectionOptionsBuilder\nMedallion.Threading.Oracle.OracleConnectionOptionsBuilder.KeepaliveCadence(System.TimeSpan keepaliveCadence)\nMedallion.Threading.Oracle.OracleConnectionOptionsBuilder.UseMultiplexing(bool useMultiplexing = true)\n```\n\n----------------------------------------\n\nTITLE: Using ZooKeeperDistributedLock in C#\nDESCRIPTION: This snippet demonstrates how to create and use a ZooKeeperDistributedLock. It shows the basic pattern of acquiring the lock asynchronously and using it within a using block.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.ZooKeeper.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar @lock = new ZooKeeperDistributedLock(\"MyLockName\", connectionString);\nawait using (await @lock.AcquireAsync())\n{\n  // I have the lock\n}\n```\n\n----------------------------------------\n\nTITLE: Using EventWaitHandleDistributedLock for Process Synchronization in C#\nDESCRIPTION: Example demonstrating how to create and acquire a distributed lock using the EventWaitHandleDistributedLock class. This implementation allows coordinating between processes on the same Windows machine using global WaitHandles.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.WaitHandles.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar @lock = new EventWaitHandleDistributedLock(\"MyLockName\");\nawait using (await @lock.AcquireAsync())\n{\n  // I have the lock!\n}\n```\n\n----------------------------------------\n\nTITLE: Async Disposal in DistributedLock 2.0\nDESCRIPTION: Demonstrates the new support for IAsyncDisposable in DistributedLock 2.0, allowing for fully asynchronous acquisition and release of locks. The example shows both the traditional pattern (compatible with 1.x and 2.0) and the new fully async pattern only available in 2.0.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Migrating from 1.x to 2.x.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// 1.x and 2.0 (acquires asynchronously, releases synchronously)\nusing (await myLock.AcquireAsync()) { }\n\n// 2.0 only (acquires and releases asynchronously)\nawait using (await myLock.AcquireAsync()) { }\n```\n\n----------------------------------------\n\nTITLE: ValueTask Usage in DistributedLock 2.0\nDESCRIPTION: Shows how DistributedLock 2.0 uses ValueTask return values instead of Task<IDisposable> to prevent incorrect usage patterns. The example illustrates a common error in 1.x where developers might forget 'await' and incorrectly dispose the Task rather than the lock handle, and how 2.0 prevents this by making such code not compile.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Migrating from 1.x to 2.x.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// 1.x\n// Forgetting 'await' means that the using block is disposing the Task and not the lock handle.\n// We will likely enter the block before the handle is acquired and will never release the handle!\nusing (myLock.AcquireAsync()) { } \n\n// 2.0\n// this code will not compile (since ValueTask is not IDisposable)\nusing (myLock.AcquireAsync()) { }\n```\n\n----------------------------------------\n\nTITLE: Migrating Safe Naming Behavior in DistributedLock\nDESCRIPTION: Demonstrates how the safe naming behavior has changed between versions 1.x and 2.x. In 2.0, safe naming is enabled by default, whereas in 1.x it required an explicit call to GetSafeName(). The example shows both safe name and exact name usage patterns in both versions.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Migrating from 1.x to 2.x.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// 1.x\nnew SqlDistributedLock(SqlDistributedLock.GetSafeName(name), connectionString); // safe name\nnew SqlDistributedLock(name, connectionString); // exact name (rare)\n\n// 2.0\nnew SqlDistributedLock(name, connectionString) // safe name\nnew SqlDistributedLock(name, connectionString, exactName: true) // exact name (rare)\n```\n\n----------------------------------------\n\nTITLE: Implementing Handle Loss Detection in C#\nDESCRIPTION: Demonstrates how to use HandleLostToken to detect when a distributed lock handle has been disrupted. The code shows checking for handle loss detection support and registering a callback for handle loss notification.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Other topics.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var handle = myLock.Acquire();\n\nif (!handle.HandleLostToken.CanBeCanceled) { Console.WriteLine(\"Implementation does not support lost handle detection\"); }\n\nhandle.HandeLostToken.Register(() => Console.WriteLine(\"Lock was lost!\"));\n```\n\n----------------------------------------\n\nTITLE: Acquiring a Distributed Lock in C#\nDESCRIPTION: Demonstrates how to acquire and release a distributed lock using async/await pattern. The lock is acquired asynchronously and automatically released when the using block exits.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/package.readme.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nawait using (await myDistributedLock.AcquireAsync())\n{\n\t// I hold the lock here\n}\n```\n\n----------------------------------------\n\nTITLE: Transaction-Scoped Lock Acquisition in C#\nDESCRIPTION: Shows how to acquire a transaction-scoped lock using an existing database transaction. This pattern is available since version 1.3 and does not require a using block as the lock is automatically released when the transaction ends.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.Postgres.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing (var transaction = connection.BeginTransaction())\n{\n   ...\n   // acquires the lock; it will be held until the transaction ends\n   await PostgresDistributedLock.AcquireWithTransactionAsync(key, transaction);\n   ...\n}\n```\n\n----------------------------------------\n\nTITLE: Granting DBMS_LOCK Permissions in Oracle SQL\nDESCRIPTION: This SQL snippet shows how to grant execution permissions on the SYS.DBMS_LOCK package to a specific Oracle user. This setup step is required for users to access the DBMS_LOCK functionality that the library depends on.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/DistributedLock.Oracle.md#2025-04-23_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nconnect as sys\ngrant execute on SYS.DBMS_LOCK to someuser;\n```\n\n----------------------------------------\n\nTITLE: Distributed Lock Extension Methods\nDESCRIPTION: Extension methods for IDistributedLockProvider interface providing synchronization functionality with timeout and cancellation support.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Core/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic Medallion.Threading.DistributedLockProviderExtensions.TryAcquireLockAsync(this Medallion.Threading.IDistributedLockProvider! provider, string! name, System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.IDistributedSynchronizationHandle?>\n```\n\n----------------------------------------\n\nTITLE: Distributed Reader-Writer Lock Extension Methods\nDESCRIPTION: Extension methods for IDistributedReaderWriterLockProvider interface providing read and write lock functionality with timeout and cancellation support.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Core/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Medallion.Threading.DistributedReaderWriterLockProviderExtensions.AcquireReadLock(this Medallion.Threading.IDistributedReaderWriterLockProvider! provider, string! name, System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.IDistributedSynchronizationHandle!\nstatic Medallion.Threading.DistributedReaderWriterLockProviderExtensions.AcquireWriteLock(this Medallion.Threading.IDistributedReaderWriterLockProvider! provider, string! name, System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.IDistributedSynchronizationHandle!\n```\n\n----------------------------------------\n\nTITLE: Distributed Semaphore Extension Methods\nDESCRIPTION: Extension methods for IDistributedSemaphoreProvider interface providing semaphore functionality with count limits, timeout and cancellation support.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Core/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Medallion.Threading.DistributedSemaphoreProviderExtensions.AcquireSemaphore(this Medallion.Threading.IDistributedSemaphoreProvider! provider, string! name, int maxCount, System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.IDistributedSynchronizationHandle!\nstatic Medallion.Threading.DistributedSemaphoreProviderExtensions.TryAcquireSemaphore(this Medallion.Threading.IDistributedSemaphoreProvider! provider, string! name, int maxCount, System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.IDistributedSynchronizationHandle?\n```\n\n----------------------------------------\n\nTITLE: Distributed Upgradeable Reader-Writer Lock Extension Methods\nDESCRIPTION: Extension methods for IDistributedUpgradeableReaderWriterLockProvider interface providing upgradeable read lock functionality with timeout and cancellation support.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Core/PublicAPI.Shipped.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Medallion.Threading.DistributedUpgradeableReaderWriterLockProviderExtensions.AcquireUpgradeableReadLock(this Medallion.Threading.IDistributedUpgradeableReaderWriterLockProvider! provider, string! name, System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.IDistributedLockUpgradeableHandle!\nstatic Medallion.Threading.DistributedUpgradeableReaderWriterLockProviderExtensions.TryAcquireUpgradeableReadLock(this Medallion.Threading.IDistributedUpgradeableReaderWriterLockProvider! provider, string! name, System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.IDistributedLockUpgradeableHandle?\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgresDistributedLock with DbDataSource in C#\nDESCRIPTION: Constructor for the PostgresDistributedLock class that accepts a lock key, database data source, and optional connection configuration. This creates a distributed lock using PostgreSQL's advisory lock mechanism.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Postgres.PostgresDistributedLock.PostgresDistributedLock(Medallion.Threading.Postgres.PostgresAdvisoryLockKey key, System.Data.Common.DbDataSource! dbDataSource, System.Action<Medallion.Threading.Postgres.PostgresConnectionOptionsBuilder!>? options = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgresDistributedReaderWriterLock with DbDataSource in C#\nDESCRIPTION: Constructor for the PostgresDistributedReaderWriterLock class that accepts a lock key, database data source, and optional connection configuration. This creates a distributed reader-writer lock using PostgreSQL's advisory lock mechanism.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Postgres.PostgresDistributedReaderWriterLock.PostgresDistributedReaderWriterLock(Medallion.Threading.Postgres.PostgresAdvisoryLockKey key, System.Data.Common.DbDataSource! dbDataSource, System.Action<Medallion.Threading.Postgres.PostgresConnectionOptionsBuilder!>? options = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgresDistributedSynchronizationProvider with DbDataSource in C#\nDESCRIPTION: Constructor for the PostgresDistributedSynchronizationProvider class that accepts a database data source and optional connection configuration. This provider can create various distributed synchronization primitives using PostgreSQL.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Postgres.PostgresDistributedSynchronizationProvider.PostgresDistributedSynchronizationProvider(System.Data.Common.DbDataSource! dbDataSource, System.Action<Medallion.Threading.Postgres.PostgresConnectionOptionsBuilder!>? options = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronization Primitives with SqlDistributedSynchronizationProvider in C#\nDESCRIPTION: Methods for creating various synchronization primitives using SqlDistributedSynchronizationProvider. Includes creation of locks, reader-writer locks, and semaphores.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.SqlServer/PublicAPI.Shipped.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.SqlServer.SqlDistributedSynchronizationProvider.CreateLock(string! name, bool exactName = false) -> Medallion.Threading.SqlServer.SqlDistributedLock!\n\nMedallion.Threading.SqlServer.SqlDistributedSynchronizationProvider.CreateReaderWriterLock(string! name, bool exactName = false) -> Medallion.Threading.SqlServer.SqlDistributedReaderWriterLock!\n\nMedallion.Threading.SqlServer.SqlDistributedSynchronizationProvider.CreateSemaphore(string! name, int maxCount) -> Medallion.Threading.SqlServer.SqlDistributedSemaphore!\n```\n\n----------------------------------------\n\nTITLE: Initializing SqlDistributedSemaphore in C#\nDESCRIPTION: Constructor for SqlDistributedSemaphore class. It initializes a new instance with a given name, maximum count, and database transaction.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.SqlServer/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.SqlServer.SqlDistributedSemaphore.SqlDistributedSemaphore(string! name, int maxCount, System.Data.IDbTransaction! transaction) -> void\n```\n\n----------------------------------------\n\nTITLE: Acquiring SqlDistributedSemaphore in C#\nDESCRIPTION: Methods for acquiring a SqlDistributedSemaphore. TryAcquire is synchronous while TryAcquireAsync is asynchronous. Both methods accept timeout and cancellation token parameters.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.SqlServer/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.SqlServer.SqlDistributedSemaphore.TryAcquire(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.SqlServer.SqlDistributedSemaphoreHandle?\n\nMedallion.Threading.SqlServer.SqlDistributedSemaphore.TryAcquireAsync(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.SqlServer.SqlDistributedSemaphoreHandle?>\n```\n\n----------------------------------------\n\nTITLE: Managing SqlDistributedReaderWriterLockUpgradeableHandle in C#\nDESCRIPTION: Overridden methods for SqlDistributedReaderWriterLockUpgradeableHandle. Includes asynchronous disposal and accessing the HandleLostToken.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.SqlServer/PublicAPI.Shipped.txt#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\noverride Medallion.Threading.SqlServer.SqlDistributedReaderWriterLockUpgradeableHandle.DisposeAsync() -> System.Threading.Tasks.ValueTask\n\noverride Medallion.Threading.SqlServer.SqlDistributedReaderWriterLockUpgradeableHandle.HandleLostToken.get -> System.Threading.CancellationToken\n```\n\n----------------------------------------\n\nTITLE: FileDistributedLock Class API Signatures in C#\nDESCRIPTION: Defines the public API surface for the FileDistributedLock class, which provides file-based distributed locking functionality. It includes constructors for creating locks based on file paths and methods for acquiring locks synchronously and asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.FileSystem/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.FileSystem.FileDistributedLock\nMedallion.Threading.FileSystem.FileDistributedLock.Acquire(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.FileSystem.FileDistributedLockHandle!\nMedallion.Threading.FileSystem.FileDistributedLock.AcquireAsync(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.FileSystem.FileDistributedLockHandle!>\nMedallion.Threading.FileSystem.FileDistributedLock.FileDistributedLock(System.IO.DirectoryInfo! lockFileDirectory, string! name) -> void\nMedallion.Threading.FileSystem.FileDistributedLock.FileDistributedLock(System.IO.FileInfo! lockFile) -> void\nMedallion.Threading.FileSystem.FileDistributedLock.Name.get -> string!\nMedallion.Threading.FileSystem.FileDistributedLock.TryAcquire(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.FileSystem.FileDistributedLockHandle?\nMedallion.Threading.FileSystem.FileDistributedLock.TryAcquireAsync(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.FileSystem.FileDistributedLockHandle?>\n```\n\n----------------------------------------\n\nTITLE: FileDistributedSynchronizationProvider Class API Signatures in C#\nDESCRIPTION: Defines the public API for the FileDistributedSynchronizationProvider class, which creates distributed locks. It includes a constructor that takes a directory for lock files and a method to create lock instances.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.FileSystem/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.FileSystem.FileDistributedSynchronizationProvider\nMedallion.Threading.FileSystem.FileDistributedSynchronizationProvider.CreateLock(string! name) -> Medallion.Threading.FileSystem.FileDistributedLock!\nMedallion.Threading.FileSystem.FileDistributedSynchronizationProvider.FileDistributedSynchronizationProvider(System.IO.DirectoryInfo! lockFileDirectory) -> void\n```\n\n----------------------------------------\n\nTITLE: Oracle Distributed Lock Class Definition\nDESCRIPTION: Core class for managing distributed locks in Oracle. Provides methods for acquiring and releasing locks with timeout and cancellation support.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Oracle/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Oracle.OracleDistributedLock\nMedallion.Threading.Oracle.OracleDistributedLock.Acquire(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default)\nMedallion.Threading.Oracle.OracleDistributedLock.AcquireAsync(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default)\n```\n\n----------------------------------------\n\nTITLE: Azure Blob Lease Options Builder Class Definition in C#\nDESCRIPTION: Defines the AzureBlobLeaseOptionsBuilder class which provides fluent configuration for Azure Blob Lease options. It allows customization of lease duration, renewal cadence, and busy-wait behavior.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Azure/PublicAPI.Shipped.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.Azure.AzureBlobLeaseOptionsBuilder\nMedallion.Threading.Azure.AzureBlobLeaseOptionsBuilder.BusyWaitSleepTime(System.TimeSpan min, System.TimeSpan max) -> Medallion.Threading.Azure.AzureBlobLeaseOptionsBuilder!\nMedallion.Threading.Azure.AzureBlobLeaseOptionsBuilder.Duration(System.TimeSpan duration) -> Medallion.Threading.Azure.AzureBlobLeaseOptionsBuilder!\nMedallion.Threading.Azure.AzureBlobLeaseOptionsBuilder.RenewalCadence(System.TimeSpan renewalCadence) -> Medallion.Threading.Azure.AzureBlobLeaseOptionsBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining WaitHandleDistributedSemaphoreHandle Class in C#\nDESCRIPTION: This class represents a handle for the distributed semaphore. It provides methods for disposing the semaphore handle and accessing the handle lost token.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.WaitHandles/PublicAPI.Shipped.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle.Dispose() -> void\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle.DisposeAsync() -> System.Threading.Tasks.ValueTask\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle.HandleLostToken.get -> System.Threading.CancellationToken\n```\n\n----------------------------------------\n\nTITLE: Defining WaitHandleDistributedSynchronizationProvider Class in C#\nDESCRIPTION: This class provides methods for creating distributed locks and semaphores. It acts as a factory for creating synchronization primitives with specified parameters.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.WaitHandles/PublicAPI.Shipped.txt#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.WaitHandles.WaitHandleDistributedSynchronizationProvider\nMedallion.Threading.WaitHandles.WaitHandleDistributedSynchronizationProvider.CreateLock(string! name, bool exactName = false) -> Medallion.Threading.WaitHandles.EventWaitHandleDistributedLock!\nMedallion.Threading.WaitHandles.WaitHandleDistributedSynchronizationProvider.CreateSemaphore(string! name, int maxCount, bool exactName = false) -> Medallion.Threading.WaitHandles.WaitHandleDistributedSemaphore!\nMedallion.Threading.WaitHandles.WaitHandleDistributedSynchronizationProvider.WaitHandleDistributedSynchronizationProvider(System.TimeSpan? abandonmentCheckCadence = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining WaitHandleDistributedSemaphore Class in C#\nDESCRIPTION: This class implements a distributed semaphore using wait handles. It provides methods for acquiring and releasing semaphore slots both synchronously and asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.WaitHandles/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.Acquire(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle!\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.AcquireAsync(System.TimeSpan? timeout = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle!>\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.MaxCount.get -> int\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.Name.get -> string!\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.TryAcquire(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Medallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle?\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.TryAcquireAsync(System.TimeSpan timeout = default(System.TimeSpan), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<Medallion.Threading.WaitHandles.WaitHandleDistributedSemaphoreHandle?>\nMedallion.Threading.WaitHandles.WaitHandleDistributedSemaphore.WaitHandleDistributedSemaphore(string! name, int maxCount, System.TimeSpan? abandonmentCheckCadence = null, bool exactName = false) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining EventWaitHandleDistributedLockHandle Class in C#\nDESCRIPTION: This class represents a handle for the distributed lock. It provides methods for disposing the lock handle both synchronously and asynchronously.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.WaitHandles/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle.Dispose() -> void\nMedallion.Threading.WaitHandles.EventWaitHandleDistributedLockHandle.DisposeAsync() -> System.Threading.Tasks.ValueTask\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Mutex-like Lock Interface in C#\nDESCRIPTION: Defines the basic IDistributedLock interface to provide mutex-like locking functionality. This interface specifies a mechanism for acquiring and releasing locks with a strong focus on the IDisposable pattern for proper resource cleanup.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IDistributedLock : IDisposable\n{\n    void Acquire();\n    bool TryAcquire(TimeSpan timeout = default);\n    void Release();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Try/Finally Pattern with Distributed Lock in C#\nDESCRIPTION: Shows an alternative lock usage pattern using try/finally blocks to ensure the lock is released even if exceptions occur. This approach provides more granular control over lock acquisition and release timing.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nIDistributedLock myLock = null;\ntry\n{\n    myLock = myLockProvider.CreateLock(\"MyLockName\");\n    myLock.Acquire();\n    // critical section\n}\nfinally\n{\n    myLock?.Dispose();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Timeout with TryAcquire Method in C#\nDESCRIPTION: Demonstrates using the TryAcquire method with a timeout to attempt lock acquisition with a time limit. This pattern allows handling situations where lock acquisition might fail after waiting for a specified duration.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI/net8.0/PublicAPI.Unshipped.txt#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var myLock = myLockProvider.CreateLock(\"MyLockName\"))\n{\n    if (myLock.TryAcquire(TimeSpan.FromSeconds(10)))\n    {\n        // critical section\n    }\n    else\n    {\n        // handle failure to acquire\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing DistributedLock Packages with NuGet\nDESCRIPTION: Shows how to install DistributedLock packages using NuGet Package Manager Console for different backend implementations including Redis, SQL Server, and ZooKeeper.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Azure/PublicAPI.Unshipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nInstall-Package DistributedLock.Redis\nInstall-Package DistributedLock.SqlServer\nInstall-Package DistributedLock.ZooKeeper\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of DistributedLock with Redis Backend\nDESCRIPTION: Demonstrates how to use the RedisDistributedLock class to acquire and release a distributed lock in a .NET application. Shows the implementation of proper lock disposal patterns.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Azure/PublicAPI.Unshipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing StackExchange.Redis;\n\nusing Medallion.Threading.Redis;\n\n// 1: create a connection\nvar redis = ConnectionMultiplexer.Connect(\"localhost\");\n\n// 2: create a lock provider\nvar lockProvider = new RedisDistributedSynchronizationProvider(redis.GetDatabase());\n\n// 3: create and enter a lock\nusing (var handle = lockProvider.AcquireLock(\"MyLockName\"))\n{\n    // do stuff\n}\n```\n\n----------------------------------------\n\nTITLE: Acquiring a distributed lock with SQL Server\nDESCRIPTION: Example of how to acquire a distributed lock using SQL Server. The code demonstrates creating a lock instance, acquiring it with a timeout, and performing synchronized operations.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI.Unshipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar connectionString = \"Server=.;Database=DistributedLock.SqlServer.Sample;Integrated Security=true\";\nusing (var @lock = new SqlDistributedLock(\"MyLockName\", connectionString))\nusing (var handle = @lock.Acquire(TimeSpan.FromSeconds(10)))\n{\n    // I now have exclusive access to the locked resource until this handle is disposed\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a distributed lock with Redis\nDESCRIPTION: Example of implementing distributed locks with Redis. The code shows how to create a Redis-based lock, acquire it, and perform operations with exclusive access.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/src/DistributedLock.Postgres/PublicAPI.Unshipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar connectionString = \"localhost\";\nusing (var @lock = new RedisDistributedLock(\"MyLockName\", connectionString))\nusing (var handle = @lock.Acquire(TimeSpan.FromSeconds(10)))\n{\n    // I now have exclusive access to the locked resource until this handle is disposed\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MariaDB Performance Schema for DistributedLock Tests\nDESCRIPTION: Configuration snippet for enabling the performance_schema in MariaDB, which is required by DistributedLock tests. This should be added to the my.ini/my.cnf file.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Developing DistributedLock.md#2025-04-23_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n# activates the performance_schema tables which are needed by DistributedLock tests\nperformance_schema=ON\n```\n\n----------------------------------------\n\nTITLE: Setting up MySQL/MariaDB Database and User for DistributedLock\nDESCRIPTION: SQL commands to create the distributed_lock database and configure a user with appropriate permissions for testing. This includes granting privileges on the database and the performance schema.\nSOURCE: https://github.com/madelson/distributedlock/blob/master/docs/Developing DistributedLock.md#2025-04-23_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE DATABASE distributed_lock;\nCREATE USER 'DistributedLock'@'localhost' IDENTIFIED BY '<password>';\nGRANT ALL PRIVILEGES ON distributed_lock.* TO 'DistributedLock'@'localhost';\nGRANT SELECT ON performance_schema.* TO 'DistributedLock'@'localhost';\n```"
  }
]