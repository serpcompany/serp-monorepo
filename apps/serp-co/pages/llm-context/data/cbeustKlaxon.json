[
  {
    "owner": "cbeust",
    "repo": "klaxon",
    "content": "TITLE: Parsing JSON into Kotlin Objects with Basic Object Binding\nDESCRIPTION: Demonstrates how to parse a JSON string into a Kotlin object using Klaxon's object binding API.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Person(val name: String, val age: Int)\n```\n\n----------------------------------------\n\nTITLE: Installing Klaxon in Gradle\nDESCRIPTION: Gradle dependency configuration for adding Klaxon to a Kotlin project.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\ndependencies {\n    implementation 'com.beust:klaxon:5.5'\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing JSON Object Properties in Kotlin\nDESCRIPTION: Demonstrates how to access properties of a JsonObject using type-specific getter methods like string(), int(), etc.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_30\n\nLANGUAGE: kotlin\nCODE:\n```\nval firstName = obj.string(\"firstName\")\nval lastName = obj.string(\"lastName\")\nprintln(\"Name: $firstName $lastName\")\n\n// Prints: Name: Cedric Beust\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON from String in Kotlin\nDESCRIPTION: Shows how to parse a JSON string using Klaxon's Parser class. The example creates a JsonObject from a string and then accesses its properties.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_29\n\nLANGUAGE: kotlin\nCODE:\n```\nval parser: Parser = Parser.default()\nval stringBuilder: StringBuilder = StringBuilder(\"{\\\"name\\\":\\\"Cedric Beust\\\", \\\"age\\\":23}\")\nval json: JsonObject = parser.parse(stringBuilder) as JsonObject\nprintln(\"Name : ${json.string(\"name\")}, Age : ${json.int(\"age\")}\")\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping JSON Arrays in Kotlin\nDESCRIPTION: Shows how to use Kotlin's collection operations like filter and map on JsonArrays to extract and transform data.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_31\n\nLANGUAGE: kotlin\nCODE:\n```\nval array = parse(\"/e.json\") as JsonArray<JsonObject>\n\nval ages = array.long(\"age\")\nprintln(\"Ages: $ages\")\n\n// Prints: Ages: JsonArray(value=[20, 25, 38])\n\nval oldPeople = array.filter {\n    it.long(\"age\")!! > 30\n}\nprintln(\"Old people: $oldPeople\")\n\n// Prints: Old people: [JsonObject(map={age=38, name=Jessica})]\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with Custom Field Names\nDESCRIPTION: Demonstrates parsing JSON with custom field names defined by the @Json annotation.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nval result = Klaxon()\n    .parse<Person>(\"\"\"\n    {\n      \"the_name\": \"John Smith\", // note the field name\n      \"age\": 23\n    }\n\"\"\")\n\nassert(result.name == \"John Smith\")\nassert(result.age == 23)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Field Names with @Json Annotation\nDESCRIPTION: Shows how to use the @Json annotation with the 'name' attribute to map JSON fields with different names to Kotlin properties.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\ndata class Person(\n    @Json(name = \"the_name\")\n    val name: String\n)\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with Default Parameters\nDESCRIPTION: Demonstrates parsing JSON into a Kotlin object with default parameter values, showing how missing properties are handled.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nval result = Klaxon()\n    .parse<Person>(\"\"\"\n    {\n      \"name\": \"John Smith\",\n    }\n    \"\"\")\n\nassert(result?.name == \"John Smith\")\nassert(result.age == 23)\n```\n\n----------------------------------------\n\nTITLE: Using Default Parameters with Klaxon Object Binding\nDESCRIPTION: Shows how Klaxon supports parsing JSON into Kotlin classes that have default parameter values.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Person (val name: String, var age: Int = 23)\n```\n\n----------------------------------------\n\nTITLE: Complex JSON Parsing and Manipulation in Kotlin\nDESCRIPTION: Demonstrates more complex operations on nested JSON structures, including filtering, mapping, and chaining operations.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_32\n\nLANGUAGE: kotlin\nCODE:\n```\nprintln(\"=== Everyone who studied in Berkeley:\")\nval berkeley = array.filter {\n    it.obj(\"schoolResults\")?.string(\"location\") == \"Berkeley\"\n}.map {\n    it.string(\"last\")\n}\nprintln(\"$berkeley\")\n\n// Prints:\n// === Everyone who studied in Berkeley:\n// [Cooper, Harkness]\n\nprintln(\"=== All grades bigger than 75\")\nval result = array.flatMap {\n    it.obj(\"schoolResults\")\n            ?.array<JsonObject>(\"scores\")?.filter {\n                it.long(\"grade\")!! > 75\n            }!!\n}\nprintln(\"Result: $result\")\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Objects with Klaxon DSL in Kotlin\nDESCRIPTION: Shows how to use Klaxon's DSL to create JSON objects in a declarative and imperative style.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_33\n\nLANGUAGE: kotlin\nCODE:\n```\nval obj = json {\n    \"color\" to \"red\",\n    \"age\" to 23\n}\n\nval obj = json {\n   repeat(3) {\n      put(\"field$it\", it * 2)\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening and Path Lookup in JSON with Klaxon\nDESCRIPTION: Demonstrates how to use the lookup function to find nested values in a JSON structure using a dot-notation path.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_34\n\nLANGUAGE: kotlin\nCODE:\n```\n(parse(\"my.json\") as JsonObject).lookup<String?>(\"users.email\")\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Type Converter\nDESCRIPTION: Shows how to register and use a custom type converter to parse JSON with the Klaxon API.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_16\n\nLANGUAGE: kotlin\nCODE:\n```\nval result = Klaxon()\n    .converter(myConverter)\n    .parse<BooleanHolder>(\"\"\"\n        { \"flag\" : 1 }\n    \"\"\")\n\nassert(result.flag)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Type Converter\nDESCRIPTION: Demonstrates how to create a custom converter to handle special JSON field formatting, converting between 0/1 and boolean values.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_15\n\nLANGUAGE: kotlin\nCODE:\n```\nclass BooleanHolder(val flag: Boolean)\n\nval myConverter = object: Converter {\n    override fun canConvert(cls: Class<*>)\n        = cls == BooleanHolder::class.java\n\n    override fun toJson(value: Any): String\n        = \"\"\"{\"flag\" : \"${if ((value as BooleanHolder).flag == true) 1 else 0}\"\"\"\n\n    override fun fromJson(jv: JsonValue)\n        = BooleanHolder(jv.objInt(\"flag\") != 0)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON from Resource in Kotlin\nDESCRIPTION: Demonstrates how to parse a JSON file from a resource stream using Klaxon's Parser class. The function returns Any? which should be cast to the expected type (JsonObject or JsonArray).\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_28\n\nLANGUAGE: kotlin\nCODE:\n```\nfun parse(name: String) : Any? {\n    val cls = Parser::class.java\n    return cls.getResourceAsStream(name)?.let { inputStream ->\n        return Parser.default().parse(inputStream)\n    }\n}\n\n// ...\n\nval obj = parse(\"/object.json\") as JsonObject\n```\n\n----------------------------------------\n\nTITLE: Using a Field-Specific Type Converter\nDESCRIPTION: Demonstrates registering and using a field-specific converter with a custom annotation to parse dates in JSON.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_20\n\nLANGUAGE: kotlin\nCODE:\n```\nval result = Klaxon()\n    .fieldConverter(KlaxonDate::class, dateConverter)\n    .parse<WithDate>(\"\"\"\n    {\n      \"theDate\": \"2017-05-10 16:30\"\n    }\n\"\"\")\n\nassert(result?.date == LocalDateTime.of(2017, 5, 10, 16, 30))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Date Converter\nDESCRIPTION: Creates a custom converter to handle parsing date strings from JSON into LocalDateTime objects.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_19\n\nLANGUAGE: kotlin\nCODE:\n```\nval dateConverter = object: Converter {\n    override fun canConvert(cls: Class<*>)\n        = cls == LocalDateTime::class.java\n\n    override fun fromJson(jv: JsonValue) =\n        if (jv.string != null) {\n            LocalDateTime.parse(jv.string, DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"))\n        } else {\n            throw KlaxonException(\"Couldn't parse date: ${jv.string}\")\n        }\n\n    override fun toJson(o: Any)\n            = \"\"\" { \"date\" : $o } \"\"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Field Annotation for Type Conversion\nDESCRIPTION: Demonstrates how to create a custom annotation for field-specific type conversion.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_17\n\nLANGUAGE: kotlin\nCODE:\n```\n@Target(AnnotationTarget.FIELD)\nannotation class KlaxonDate\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Field Annotation\nDESCRIPTION: Shows how to use a custom field annotation to apply special handling for specific fields in a class.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_18\n\nLANGUAGE: kotlin\nCODE:\n```\nclass WithDate @JvmOverloads constructor(\n    @KlaxonDate\n    val date: LocalDateTime\n)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Properties During JSON Parsing\nDESCRIPTION: Shows how to use the @Json annotation with the 'ignored' attribute to exclude properties from JSON serialization/deserialization.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Ignored(val name: String) {\n   @Json(ignored = true)\n   val actualName: String get() = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Excluding Null Values from JSON with @Json serializeNull\nDESCRIPTION: Demonstrates how to use the @Json annotation with 'serializeNull' attribute to omit null values from JSON output.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_11\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Data(\n    @Json(serializeNull = false)\n    val id: Int?\n)\nprintln(Klaxon().toJsonString(Data(null)))\n\n// displays {}\n```\n\n----------------------------------------\n\nTITLE: Global Configuration for Null Value Serialization\nDESCRIPTION: Shows how to configure Klaxon globally to exclude null values from all JSON serialization without annotating each field.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_12\n\nLANGUAGE: kotlin\nCODE:\n```\nval settings = KlaxonSettings(serializeNull = false)\n```\n\n----------------------------------------\n\nTITLE: Using Global Null Serialization Settings\nDESCRIPTION: Demonstrates using global Klaxon settings to control null value serialization across an entire class.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_13\n\nLANGUAGE: kotlin\nCODE:\n```\ndata class User(\n    val username: String, val email: String, // mandatory\n    val phone: String?, val fax: String?, val age: Int? // optional\n)\n\nKlaxon(settings)\n  .toJsonString(User(\"user\", \"user@example.org\", null, null, null))\n\n// displays {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Field Renaming Logic\nDESCRIPTION: Shows how to implement a custom FieldRenamer to automatically convert between camelCase and snake_case in JSON field names.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_14\n\nLANGUAGE: kotlin\nCODE:\n```\n    val renamer = object: FieldRenamer {\n        override fun toJson(fieldName: String) = FieldRenamer.camelToUnderscores(fieldName)\n        override fun fromJson(fieldName: String) = FieldRenamer.underscoreToCamel(fieldName)\n    }\n\n    val klaxon = Klaxon().fieldRenamer(renamer)\n```\n\n----------------------------------------\n\nTITLE: Using Private Properties to Exclude from JSON Parsing\nDESCRIPTION: Demonstrates how private properties are automatically excluded from JSON serialization/deserialization.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Ignored(val name: String) {\n   private val actualName: String get() = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Null Value Serialization in JSON Output\nDESCRIPTION: Shows default behavior of serializing null values to JSON.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Data(\n    val id: Int?\n)\nprintln(Klaxon().toJsonString(Data(null)))\n\n// displays { \"id\": null }\n```\n\n----------------------------------------\n\nTITLE: Streaming JSON Reading Example\nDESCRIPTION: Example demonstrating how to use JsonReader for streaming JSON parsing with type-safe value extraction.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_26\n\nLANGUAGE: kotlin\nCODE:\n```\nval objectString = \"\"\"{\\n     \"name\" : \"Joe\",\\n     \"age\" : 23,\\n     \"flag\" : true,\\n     \"array\" : [1, 3],\\n     \"obj1\" : { \"a\" : 1, \"b\" : 2 }\\n}\"\"\"\n\nJsonReader(StringReader(objectString)).use { reader ->\n    reader.beginObject() {\n        var name: String? = null\n        var age: Int? = null\n        var flag: Boolean? = null\n        var array: List<Any> = arrayListOf<Any>()\n        var obj1: JsonObject? = null\n        while (reader.hasNext()) {\n            val readName = reader.nextName()\n            when (readName) {\n                \"name\" -> name = reader.nextString()\n                \"age\" -> age = reader.nextInt()\n                \"flag\" -> flag = reader.nextBoolean()\n                \"array\" -> array = reader.nextArray()\n                \"obj1\" -> obj1 = reader.nextObject()\n                else -> Assert.fail(\"Unexpected name: $readName\")\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling JSON Field Order with @Json Index\nDESCRIPTION: Shows how to use the @Json annotation with 'index' attribute to control the order of fields in the generated JSON output.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Data(\n    @Json(index = 1) val id: String,\n    @Json(index = 2) val name: String\n)\nprintln(Klaxon().toJsonString(Data(\"id\", \"foo\")))\n\n// displays { \"id\": \"id\", \"name\": \"foo\" }\n```\n\n----------------------------------------\n\nTITLE: Controlling JSON Field Order with Reversed Indices\nDESCRIPTION: Demonstrates how changing the index values affects the order of fields in JSON output.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nclass Data(\n    @Json(index = 2) val id: String,\n    @Json(index = 1) val name: String\n)\nprintln(Klaxon().toJsonString(Data(\"id\", \"foo\")))\n\n// displays { \"name\": \"foo\" , \"id\": \"id\" }\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Class Definition\nDESCRIPTION: Kotlin class hierarchy for handling polymorphic shape types with TypeFor annotation.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_24\n\nLANGUAGE: kotlin\nCODE:\n```\n@TypeFor(field = \"type\", adapter = ShapeTypeAdapter::class)\nopen class Shape(val type: String)\ndata class Rectangle(val width: Int, val height: Int): Shape(\"rectangle\")\ndata class Circle(val radius: Int): Shape(\"circle\")\n```\n\n----------------------------------------\n\nTITLE: Shape Type Adapter Implementation\nDESCRIPTION: TypeAdapter implementation for converting between JSON type values and Kotlin shape classes.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_25\n\nLANGUAGE: kotlin\nCODE:\n```\nclass ShapeTypeAdapter: TypeAdapter<Shape> {\n    override fun classFor(type: Any): KClass<out Shape> = when(type as String) {\n        \"rectangle\" -> Rectangle::class\n        \"circle\" -> Circle::class\n        else -> throw IllegalArgumentException(\"Unknown type: $type\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Polymorphic JSON Example\nDESCRIPTION: Sample JSON showing polymorphic data structure with shape types determined by a type field.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_23\n\nLANGUAGE: json\nCODE:\n```\n[\n    { \"type\": \"rectangle\", \"width\": 100, \"height\": 50 },\n    { \"type\": \"circle\", \"radius\": 20}\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyStrategy Example\nDESCRIPTION: Example showing how to implement and register a PropertyStrategy with Klaxon to ignore specific properties by name.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_22\n\nLANGUAGE: kotlin\nCODE:\n```\nval ps = object: PropertyStrategy {\n    override fun accept(property: KProperty<*>) = property.name != \"something\"\n}\nval klaxon = Klaxon().propertyStrategy(ps)\n```\n\n----------------------------------------\n\nTITLE: Defining PropertyStrategy Interface in Kotlin\nDESCRIPTION: Interface definition for dynamically filtering properties during JSON parsing. Used to selectively include/exclude properties based on custom logic.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_21\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface PropertyStrategy {\n    /**\n     * @return true if this property should be mapped.\n     */\n    fun accept(property: KProperty<*>): Boolean\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Path Matcher Implementation\nDESCRIPTION: Example showing how to implement a PathMatcher for filtering JSON elements based on their path.\nSOURCE: https://github.com/cbeust/klaxon/blob/master/README.md#2025-04-22_snippet_27\n\nLANGUAGE: kotlin\nCODE:\n```\nval pathMatcher = object : PathMatcher {\n    override fun pathMatches(path: String) = Pattern.matches(\".*library.*books.*author.*\", path)\n\n    override fun onMatch(path: String, value: Any) {\n        println(\"Adding $path = $value\")\n    }\n}\n\nKlaxon()\n    .pathMatcher(pathMatcher)\n    .parseJsonObject(document)\n```"
  }
]