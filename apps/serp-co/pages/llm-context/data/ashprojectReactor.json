[
  {
    "owner": "ash-project",
    "repo": "reactor",
    "content": "TITLE: Defining a User Registration Workflow using Reactor DSL in Elixir\nDESCRIPTION: This code demonstrates how to compose multiple steps into a complete user registration workflow using Reactor's DSL. It handles user registration, Stripe customer/subscription creation, email sending, and Salesforce tracking with proper dependencies.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/tutorials/getting-started-with-reactor.md#2025-04-19_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.RegisterUserReactor do\n  use Reactor\n\n  input :email\n  input :password\n  input :plan_name\n\n  step :register_user, MyApp.RegisterUserStep do\n    argument :email, input(:email)\n    argument :password, input(:password)\n  end\n\n  step :create_stripe_customer, MyApp.CreateStripeCustomerStep do\n    argument :email, input(:email)\n  end\n\n  step :find_stripe_plan, MyApp.FindStripePlanStep do\n    argument :plan_name, input(:plan_name)\n  end\n\n  step :create_stripe_subscription, MyApp.CreateStripeSubscriptionStep do\n    argument :customer_id do\n      source result(:create_stripe_customer)\n      transform &(&1.id)\n    end\n\n    argument :plan_id do\n      source result(:find_stripe_plan)\n      transform &(&1.id)\n    end\n  end\n\n  step :send_welcome_email, MyApp.SendWelcomeEmailStep do\n    argument :email, input(:email)\n    argument :_subscription, result(:create_stripe_subscription)\n  end\n\n  step :track_conversion, MyApp.TrackSalesforceConversionStep do\n    argument :email, input(:email)\n    argument :plan_name, input(:plan_name)\n    argument :_welcome_email, result(:send_welcome_email)\n  end\n\n  return :register_user\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reactor Step for Stripe Subscription Creation in Elixir\nDESCRIPTION: This snippet demonstrates how to implement the Reactor.Step behaviour for creating a Stripe subscription with compensation (retry on network errors) and undo logic for rollbacks.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/tutorials/getting-started-with-reactor.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.CreateStripeSubscriptionStep do\n  use Reactor.Step\n\n  @impl true\n  def run(arguments, context, options) do\n    Stripe.Subscription.create(arguments.customer_id, items: [plan: arguments.plan_id])\n  end\n\n  @impl true\n  def compensate(%{code: :network_error}, arguments, context, options) do\n    :retry\n  end\n\n  def compensate(error, arguments, context, options) do\n    :ok\n  end\n\n  @impl true\n  def undo(subscription, arguments, context, options) do\n    case Stripe.Subscription.delete(subscription) do\n      {:ok, _} -> :ok\n      {:error, reason} -> {:error, reason}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Input Definition Examples in Reactor DSL\nDESCRIPTION: Shows examples of defining inputs in Reactor, including a simple named input and an input with a transformation function that converts a string to an integer.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_38\n\nLANGUAGE: elixir\nCODE:\n```\ninput :name\n\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninput :age do\n  transform &String.to_integer/1\nend\n\n```\n\n----------------------------------------\n\nTITLE: Argument Usage Examples\nDESCRIPTION: Demonstrates various ways to specify arguments in Reactor steps including input handling, transformations, and result usage.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_41\n\nLANGUAGE: elixir\nCODE:\n```\nargument :name, input(:name)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :year, input(:date, [:year])\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user, result(:create_user)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user) do\n  transform & &1.id\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user, [:id])\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :three, value(3)\n```\n\n----------------------------------------\n\nTITLE: Argument Usage Examples - Elixir\nDESCRIPTION: Examples showing different ways to define arguments in Reactor steps, including input mapping, result referencing, and value transformations.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_46\n\nLANGUAGE: elixir\nCODE:\n```\nargument :name, input(:name)\n\nargument :year, input(:date, [:year])\n\nargument :user, result(:create_user)\n\nargument :user_id, result(:create_user) do\n  transform & &1.id\nend\n\nargument :user_id, result(:create_user, [:id])\n\nargument :three, value(3)\n```\n\n----------------------------------------\n\nTITLE: Argument Definition Examples in Reactor DSL\nDESCRIPTION: Shows different ways to define arguments in Reactor DSL, including using inputs, accessing nested properties, using results from other steps, transforming values, and using literal values.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_31\n\nLANGUAGE: elixir\nCODE:\n```\nargument :name, input(:name)\n\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :year, input(:date, [:year])\n\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user, result(:create_user)\n\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user) do\n  transform & &1.id\nend\n\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user, [:id])\n\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :three, value(3)\n\n```\n\n----------------------------------------\n\nTITLE: Where Condition Example in Reactor DSL\nDESCRIPTION: Demonstrates how to use a 'where' condition to check if a file exists before attempting to read it. This ensures the step only executes when the precondition is met.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_35\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Step Definition Examples\nDESCRIPTION: Shows different ways to define steps including module implementation and inline function definitions.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_45\n\nLANGUAGE: elixir\nCODE:\n```\nstep :create_user, MyApp.Steps.CreateUser do\n  argument :username, input(:username)\n  argument :password_hash, result(:hash_password)\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\nstep :hash_password do\n  argument :password, input(:password)\n\n  run fn %{password: password}, _ ->\n    {:ok, Bcrypt.hash_pwd_salt(password)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Stripe Subscription Cancellation Flow\nDESCRIPTION: Shows a multi-step process to list and cancel Stripe subscriptions, using map and step operations with chained results.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_40\n\nLANGUAGE: elixir\nCODE:\n```\nstep :get_subscriptions do\n  run fn _, _ ->\n    Stripe.Subscription.list()\n  end\nend\n\nmap :cancel_subscriptions do\n  source result(:get_subscriptions)\n\n  step :cancel do\n    argument :sub_id, element(:cancel_subscriptions, [:id])\n\n    run fn args, _ ->\n      Stripe.Subscription.cancel(arg.sub_id, %{prorate: true, invoice_now: true})\n    end\n  end\n\n  return :cancel\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Arguments in Reactor DSL\nDESCRIPTION: Specifies an argument to a Reactor step. Arguments can be derived from inputs, results of other steps, or literal values, and can be optionally transformed before being passed to steps.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_30\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, source \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Defining Map Operation in Reactor DSL\nDESCRIPTION: Executes nested steps for every item in an iterable collection. This allows mapping over a bounded collection, applying steps to each element and returning a list of new values.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_36\n\nLANGUAGE: elixir\nCODE:\n```\nmap name\n```\n\n----------------------------------------\n\nTITLE: Cache-Aware File Reading with Guard Template in Elixir\nDESCRIPTION: Shows how to use the guard template to implement cache-aware file reading. The guard function checks a cache before allowing file reading, providing an optimization pathway.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_52\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Cached File Reading with Guard - Elixir\nDESCRIPTION: Example demonstrating a guarded file reading step that checks a cache before executing the actual file read operation.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_49\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Guard Function with Cache Example\nDESCRIPTION: Demonstrates how to use a guard function to implement a caching mechanism where step execution is bypassed if a cached value is found. The example shows a file reading operation that checks a cache first.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_28\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Input in Reactor DSL\nDESCRIPTION: Specifies an input value to the Reactor. Inputs are values passed to the Reactor when executing, similar to function arguments, and can be optionally transformed before being used by steps.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_37\n\nLANGUAGE: elixir\nCODE:\n```\ninput name\n```\n\n----------------------------------------\n\nTITLE: Guard with Cache Example\nDESCRIPTION: Shows how to implement a guard with cache checking before executing the main step logic.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_44\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Advanced Conditional Execution with Guard in Reactor DSL\nDESCRIPTION: Provides a more flexible way to conditionally execute steps or replace their results. Guards can either continue execution or halt with a replacement result.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: Guarded Step Execution with Caching in Reactor DSL (Elixir)\nDESCRIPTION: Implements a guard for conditional step execution or result replacement. It uses a cache to potentially skip file reading if the content is already cached.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Guard Example with Caching in Reactor DSL\nDESCRIPTION: Shows how to implement a caching mechanism using guards, where the step only executes if the result isn't already in the cache.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Guard Function in Reactor DSL\nDESCRIPTION: Provides a flexible method for conditionally executing a step or replacing its result. The guard function takes step arguments and context and returns either :cont to proceed or {:halt, result} to bypass execution.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_27\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: Defining Guard in Reactor DSL\nDESCRIPTION: Provides a flexible method for conditionally executing a step or replacing its result. The guard function can either allow the step to continue or halt it with a specific result.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: DSL Guard Template Definition in Elixir\nDESCRIPTION: Template definition for the guard function that provides conditional step execution with result replacement capability. Returns either :cont to continue or {:halt, result} to skip execution.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_53\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: Defining Collect Step in Reactor DSL\nDESCRIPTION: Creates a step that collects and returns its arguments. The collected arguments can be optionally transformed before being returned.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ncollect name\n```\n\n----------------------------------------\n\nTITLE: Conditional File Reading Step - Elixir\nDESCRIPTION: Example showing a file reading step with a conditional where clause that checks if the file exists before execution.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_48\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Where Clause Example in Reactor DSL\nDESCRIPTION: Demonstrates using a where clause to conditionally execute a file reading step only if the file exists.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Execution with Where\nDESCRIPTION: Demonstrates conditional step execution using the where clause to check file existence.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_43\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Argument Example: Transforming Step Result\nDESCRIPTION: Demonstrates transforming a step result before using it as an argument.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user) do\n  transform & &1.id\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Execution in Reactor DSL (Elixir)\nDESCRIPTION: Defines a condition for executing a step using the 'where' clause. It takes a predicate function that determines whether the step should be executed.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Execution with Where Clause\nDESCRIPTION: Provides a simple way to conditionally execute a step based on a predicate function. The step only executes if the predicate returns true.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Defining Where Clause in Reactor DSL\nDESCRIPTION: Adds a condition for executing the surrounding step. The step will only execute if the predicate function returns true. It's a simpler version of the guard clause.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Argument Example: Using Constant Value\nDESCRIPTION: Demonstrates using a constant value as an argument source.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\nargument :three, value(3)\n```\n\n----------------------------------------\n\nTITLE: Defining Where Conditions in Reactor DSL\nDESCRIPTION: Provides a simple conditional for step execution. The 'where' clause takes a predicate function that determines whether the surrounding step should execute based on its arguments or context.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_34\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Execution with Where Template in Elixir\nDESCRIPTION: Demonstrates using the where template to conditionally execute a step based on a predicate function. The example shows checking if a file exists before attempting to read it.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_51\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: DSL Where Template Definition in Elixir\nDESCRIPTION: Template definition for the where predicate that provides simple conditional step execution. A simplified version of guard for basic boolean conditions.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_54\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Welcome Message Template - Elixir\nDESCRIPTION: Example showing how to create a template step that generates a welcome message using EEx templating.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_50\n\nLANGUAGE: elixir\nCODE:\n```\ntemplate :welcome_message do\n  arguments :user\n  template \"\"\"\n  Welcome <%= @user.name %>! 🎉\n  \"\"\"\nend\n```\n\n----------------------------------------\n\nTITLE: Wait For Step Example - Elixir\nDESCRIPTION: Demonstrates how to make a step wait for another step's completion using the wait_for directive.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_47\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Wait For Step Example\nDESCRIPTION: Shows how to make a step wait for another step's completion before execution.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_42\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Wait For Example in Reactor DSL\nDESCRIPTION: Shows how to make a step wait for another step to complete before execution. The example demonstrates waiting for a 'create_user' step.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_33\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Waiting for Step Completion in Reactor DSL\nDESCRIPTION: Introduces dependency between steps by making the current step wait for completion of another step before starting. This effectively creates an execution order without using the other step's result.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Wait For Example in Reactor DSL\nDESCRIPTION: Shows how to wait for a specific step to complete before executing the current step.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Defining Wait For Dependencies in Reactor DSL\nDESCRIPTION: Establishes dependencies between steps, ensuring that specified steps complete before the current step starts. This is syntactic sugar for creating an unnamed argument that depends on the result of another step.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_32\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Defining Wait For in Reactor DSL\nDESCRIPTION: Specifies that the current step should wait for another named step to complete before starting. It desugars to an argument with a result from the step to wait for.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Defining Wait For Dependency in Reactor DSL (Elixir)\nDESCRIPTION: Specifies a step to wait for before executing the current step. It desugars to an argument with a result from the step to wait for.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Defining a Group in Reactor DSL\nDESCRIPTION: Creates a group of steps with before_all and after_all functions. The group allows executing functions before and after a collection of steps, providing a way to share setup and teardown operations.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_29\n\nLANGUAGE: elixir\nCODE:\n```\ngroup name\n```\n\n----------------------------------------\n\nTITLE: Defining Around Step in Reactor DSL\nDESCRIPTION: Wraps a function around a group of steps. The around function can be a function or an MFA tuple. It allows for optional async execution and can include a description.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\naround name, fun \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Double Numbers Map Example\nDESCRIPTION: Demonstrates a basic map operation that doubles input numbers using a source and step configuration.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_39\n\nLANGUAGE: elixir\nCODE:\n```\nmap :double_numbers do\n  source input(:numbers)\n\n  step :double do\n    argument :number, element(:double_numbers)\n\n    run fn %{number: number}, _ ->\n      {:ok, number * 2}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Argument Example: Using Step Result\nDESCRIPTION: Shows how to use the result of another step as an argument source.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user, result(:create_user)\n```\n\n----------------------------------------\n\nTITLE: Argument Example: Accessing Property in Step Result\nDESCRIPTION: Shows how to directly access a property within a step result using a path.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user, [:id])\n```\n\n----------------------------------------\n\nTITLE: Argument Example: Using Input Value with Path\nDESCRIPTION: Demonstrates accessing a nested property within an input value using a path.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nargument :year, input(:date, [:year])\n```\n\n----------------------------------------\n\nTITLE: Argument Example: Using Input Values\nDESCRIPTION: Shows how to reference an input value as an argument source.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nargument :name, input(:name)\n```\n\n----------------------------------------\n\nTITLE: Defining Argument in Reactor DSL\nDESCRIPTION: Specifies an argument for a Reactor step. The argument can be from various sources and can be optionally transformed before being passed to the step.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, source \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Specifying Arguments in Reactor Debug DSL\nDESCRIPTION: Defines an argument for a Reactor step. Arguments can be sourced from step results, input values, or constants, and can be transformed before use.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, source \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Debug Example Usage in Reactor DSL\nDESCRIPTION: Shows how to use the debug step in a Reactor workflow, demonstrating how to add an argument that references the result of another step.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\ndebug :debug do\n  argument :suss, result(:suss_step)\nend\n```\n\n----------------------------------------\n\nTITLE: Debugging with Reactor DSL in Elixir\nDESCRIPTION: Inserts a step which sends debug information to the Logger. This can be used to monitor workflow execution and troubleshoot issues.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\ndebug name\n```\n\n----------------------------------------\n\nTITLE: Forcing Failure in Reactor Workflow with Flunk\nDESCRIPTION: Creates a step that always causes the Reactor to exit with an error. This is useful for testing error handling or explicitly failing in certain conditions.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_25\n\nLANGUAGE: elixir\nCODE:\n```\nflunk name, message\n```\n\n----------------------------------------\n\nTITLE: Flunk Example in Reactor DSL\nDESCRIPTION: Demonstrates how to create a step that forces the workflow to fail with a custom error message.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\nflunk :outaroad, \"Ran out of road before reaching 88Mph\"\n```\n\n----------------------------------------\n\nTITLE: Installing Reactor Package Dependencies in Elixir\nDESCRIPTION: Configuration snippet showing how to add Reactor as a dependency in a Mix project's deps function. Specifies version 0.15.2 of the reactor package.\nSOURCE: https://github.com/ash-project/reactor/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndef deps do\n  [\n    {:reactor, \"~> 0.15.2\"}\n  ]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Middleware in Reactor DSL\nDESCRIPTION: Adds a middleware module to the Reactor. The middleware can be given an optional description.\nSOURCE: https://github.com/ash-project/reactor/blob/main/documentation/dsls/DSL-Reactor.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nmiddleware module\n```"
  }
]