[
  {
    "owner": "aembke",
    "repo": "fred.rs",
    "content": "TITLE: Initializing Redis Client with Custom Configuration in Rust\nDESCRIPTION: Example showing how to create and initialize a Redis client with custom TCP configuration, handle connection errors, and perform basic get/set operations. Demonstrates type conversion and error handling.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n  let config = Config::from_url(\"redis://localhost:6379/1\")?\n  let client = Builder::from_config(config)\n    .with_connection_config(|config| {\n      config.connection_timeout = Duration::from_secs(5);\n      config.tcp = TcpConfig {\n        nodelay: Some(true),\n        ..Default::default()\n      };\n    })\n    .build()?\n  client.init().await?\n\n  client.on_error(|(error, server)| async move {\n    println!(\"{:?}: Connection error: {:?}\", server, error);\n    Ok(())\n  });\n\n  // convert responses to many common Rust types\n  let foo: Option<String> = client.get(\"foo\").await?\n  assert!(foo.is_none());\n\n  client.set(\"foo\", \"bar\", None, None, false).await?\n  // or use turbofish to declare response types\n  println!(\"Foo: {:?}\", client.get::<String, _>(\"foo\").await?);\n\n  client.quit().await?\n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Redis connection and command execution in Rust\nDESCRIPTION: Demonstrates how to establish a connection to Redis using FRED and execute basic commands asynchronously. Shows the typical pattern of creating a client, connecting to Redis, and sending commands.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), RedisError> {\n  let config = RedisConfig::default();\n  let client = RedisClient::new(config);\n  // connect to the redis server\n  client.connect();\n  // wait for the client to connect\n  client.wait_for_connect().await?;\n  \n  // set a value\n  let _: () = client.set(\"foo\", \"bar\", None, None, false).await?;\n  // get a value\n  let value: String = client.get(\"foo\").await?;\n  println!(\"Value: {}\", value);\n  \n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Connection Configuration with Fred\nDESCRIPTION: Shows how to create a client with custom connection configuration, demonstrating options for TCP keep-alive settings and reconnection strategy.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet config = RedisConfig {\n  server: ServerConfig::new_centralized(\"127.0.0.1\", 6379),\n  connection: Some(ConnectionConfig {\n    tcp: Some(TcpConfig {\n      keepalive: Some(KeepAlive {\n        secs: 10,\n        nanos: 0\n      }),\n      nodelay: Some(true),\n      ..Default::default()\n    }),\n    reconnect: Some(ReconnectConfig {\n      max_attempts: 5,\n      retry_strategy: Some(RedisRetryStrategy::FixedInterval {\n        seconds: 10,\n        nanos: 0\n      }),\n      ..Default::default()\n    })\n    ..Default::default()\n  }),\n  ..Default::default()\n};\n\nlet client = RedisClient::new(config);\n// the client will try to connect to localhost:6379 up to 5 times with \n// a 10 second delay between attempts\nclient.connect(None);\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Connection in Rust Redis Client\nDESCRIPTION: The connect method of the Client struct that spawns a Tokio task to handle the client's connection lifecycle. It creates connections and then enters the read_or_write loop to process incoming and outgoing messages.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nimpl Client {\n  pub fn connect(&self) -> JoinHandle<Result<(), Error>> {\n    let inner = self.inner.clone();\n\n    tokio::spawn(async move {\n      let mut router = Router::new();\n      create_connections(&inner, &mut router).await?;\n      read_or_write(inner, router).await\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing custom Redis commands with the Builder API in Rust\nDESCRIPTION: Shows how to use the Builder API to implement custom Redis commands that may not be directly exposed by the library. This pattern allows for more flexibility when working with custom or less common Redis commands.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), RedisError> {\n  let config = RedisConfig::default();\n  let client = RedisClient::new(config);\n  client.connect();\n  client.wait_for_connect().await?;\n  \n  // create and use the command builder to implement custom commands\n  let exists: bool = client.exists(\"foo\").await?;\n  let args: RedisValue = client.custom_command([\"HSET\", \"foo\", \"field\", \"value\"]).await?;\n  let value: RedisValue = client.custom_command([\"HGET\", \"foo\", \"field\"]).await?;\n  \n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Using Pipeline in Fred\nDESCRIPTION: Shows how to use the pipeline feature for batching multiple Redis commands to improve performance by reducing network round-trips.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet response: (Option<String>, i64) = client.pipeline(|pipeline| {\n  pipeline.get(\"foo\");\n  pipeline.incr(\"counter\");\n}).await?;\n```\n\n----------------------------------------\n\nTITLE: Using Transaction in Fred\nDESCRIPTION: Demonstrates how to use Redis transactions with MULTI/EXEC to execute a group of commands atomically, with type-safety for responses.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// use `transaction` or `atomic` for blocking commands, or `transaction_async` for fully async transactions\nlet response: (Option<String>, i64) = client.transaction(|transaction| {\n  transaction.get(\"foo\");\n  transaction.incr(\"counter\");\n}).await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Transactions with FRED in Rust\nDESCRIPTION: Shows how to use Redis transactions with FRED, which provides a way to execute multiple commands atomically. This example demonstrates transaction creation, command queueing, and execution with the EXEC command.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), RedisError> {\n  let config = RedisConfig::default();\n  let client = RedisClient::new(config);\n  client.connect();\n  client.wait_for_connect().await?;\n  \n  // create a transaction and queue commands\n  let transaction = client.multi();\n  let response: (bool, String, usize) = transaction\n    .exists(\"foo\")\n    .get(\"bar\")\n    .hlen(\"baz\")\n    .exec().await?;\n  \n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConnectionKind Enum for Transport Layer Abstraction in Rust\nDESCRIPTION: Definition of the ConnectionKind enum which abstracts different connection types (TCP, TLS, Unix sockets) behind a common interface. This approach hides connection details from library users while supporting multiple transport mechanisms.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nenum ConnectionKind {\n  Tcp(TcpStream),\n  #[cfg(feature = \"enable-rustls\")]\n  Rustls(TlsStream<TcpStream>),\n  #[cfg(feature = \"enable-native-tls\")]\n  NativeTls(TlsStream<TcpStream>),\n  #[cfg(feature = \"unix-sockets\")]\n  Unix(UnixStream)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the RESP3 Protocol with Fred\nDESCRIPTION: Demonstrates how to configure the Fred client to use the RESP3 protocol, enabling newer Redis features and improved type handling.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet config = RedisConfig {\n  protocol: ProtocolVersion::RESP3,\n  ..Default::default()\n};\nlet client = RedisClient::new(config);\n```\n\n----------------------------------------\n\nTITLE: Setting Up TLS Connection in Fred\nDESCRIPTION: Demonstrates configuration for TLS-secured Redis connections, including certificate verification settings and custom root certificates.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet server = ServerConfig::Centralized {\n  server: \"redis.server.com:6379\".into(),\n  tls: Some(TlsConfig {\n    verify_hostname: true,\n    root_certificates: Some(root_certs),\n    ..Default::default()\n  })\n};\n\nlet config = RedisConfig {\n  server,\n  ..Default::default()\n};\nlet client = RedisClient::new(config);\n```\n\n----------------------------------------\n\nTITLE: Implementing Protocol Framing with ConnectionKind in Rust\nDESCRIPTION: Extended ConnectionKind implementation that uses Tokio's codec framework for protocol framing. This wraps each connection type in a Peekable struct for error handling and implements a custom codec that handles both RESP2 and RESP3 protocols.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nenum ProtocolFrame {\n  Resp2(Resp2Frame),\n  Resp3(Resp3Frame)\n}\n\nenum ConnectionKind {\n  Tcp(Peekable<Framed<TcpStream, Codec>>),\n  #[cfg(feature = \"unix-sockets\")]\n  Unix(Peekable<Framed<UnixStream, Codec>>),\n  #[cfg(any(feature = \"enable-rustls\", feature = \"enable-rustls-ring\"))]\n  Rustls(Peekable<Framed<RustlsStream<TcpStream>, Codec>>),\n  #[cfg(feature = \"enable-native-tls\")]\n  NativeTls(Peekable<Framed<NativeTlsStream<TcpStream>, Codec>>),\n}\n\nimpl Stream for ConnectionKind {\n  type Item = Result<ProtocolFrame, Error>;\n\n  // ...\n}\n\nimpl Sink<ProtocolFrame> for ConnectionKind {\n  type Error = Error;\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Connections with Fred\nDESCRIPTION: Shows how to handle client connection management, including connecting, checking connection state, and implementing custom reconnection behavior.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// subscribe to connection events\nlet policy_id = client.connection_policy_id();\nlet mut backoff = ExponentialBackoff::default();\n\nclient.on_connect(move |client| {\n  client.connection_policy().reset_policy(policy_id, &backoff);\n});\n\nclient.on_reconnect(move |client, error| {\n  // each reconnection attempt increases the backoff delay\n  backoff.next();\n});\n\nclient.on_disconnect(|_, error| {\n  // called when a client disconnects for any reason besides a manual `client.quit()` call\n});\n\nclient.on_error(|_, error| {\n  // called when any error occurs\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Middleware in Fred\nDESCRIPTION: Shows how to create custom middleware to intercept and modify Redis commands, useful for implementing features like tracing, metrics, or custom command transformations.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// a middleware that counts the number of SET commands\npub struct CommandCounter {\n  counts: Arc<RwLock<HashMap<String, usize>>>\n}\n\nimpl CommandCounter {\n  pub fn new() -> Self {\n    CommandCounter { counts: Arc::new(RwLock::new(HashMap::new())) }\n  }\n\n  pub async fn get_count(&self, cmd: &str) -> usize {\n    let guard = self.counts.read().await;\n    *guard.get(cmd).unwrap_or(&0)\n  }\n}\n\n#[async_trait]\nimpl RedisMiddleware for CommandCounter {\n  async fn handle_request(&self, cmd: RedisCommand) -> RedisCommand {\n    // inspect the command here if necessary\n    if cmd.kind() == \"SET\" {\n      let mut guard = self.counts.write().await;\n      let counter = guard.entry(\"SET\".into()).or_insert(0);\n      *counter += 1;\n    }\n\n    cmd\n  }\n\n  async fn handle_response(&self, _response: &RedisValue) -> Result<(), RedisError> {\n    // inspect the response here if necessary\n    Ok(())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Reconnection Strategy in Fred\nDESCRIPTION: Demonstrates implementing a custom reconnection strategy with the connection policy, allowing fine-grained control over reconnection behavior.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// a custom reconnection policy that follows a fibonacci sequence\npub struct FibonacciBackoff {\n  a: u64,\n  b: u64,\n  max_delay: Duration\n}\n\nimpl Default for FibonacciBackoff {\n  fn default() -> Self {\n    Self {\n      a: 1,\n      b: 1,\n      max_delay: Duration::from_secs(5 * 60)\n    }\n  }\n}\n\nimpl FibonacciBackoff {\n  pub fn reset(&mut self) {\n    self.a = 1;\n    self.b = 1;\n  }\n\n  pub fn next(&mut self) -> Duration {\n    let c = self.a + self.b;\n    self.a = self.b;\n    self.b = c;\n\n    let delay = Duration::from_secs(self.a);\n    if delay > self.max_delay {\n      self.max_delay\n    }else{\n      delay\n    }\n  }\n}\n\nimpl ReconnectPolicy for FibonacciBackoff {\n  fn apply<T: DerefMut<Target=Self> + Deref<Target=Self>>(policy: T) -> Box<dyn ReconnectStrategy> {\n    Box::new(FibonacciReconnectStrategy { backoff: policy })\n  }\n}\n\npub struct FibonacciReconnectStrategy {\n  backoff: Box<dyn DerefMut<Target=FibonacciBackoff> + Deref<Target=FibonacciBackoff>>\n}\n\n#[async_trait]\nimpl ReconnectStrategy for FibonacciReconnectStrategy {\n  // return a delay until the next reconnection attempt\n  fn next_delay(&mut self, attempt: u32) -> Option<Duration> {\n    Some(self.backoff.next())\n  }\n\n  fn reset(&mut self) {\n    self.backoff.reset()\n  }\n\n  // return None to stop reconnection attempts\n  fn max_attempts(&self) -> Option<u32> {\n    Some(20)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Publisher-Subscriber pattern in Redis using Rust\nDESCRIPTION: Demonstrates how to implement the publisher-subscriber pattern using FRED. This example shows how to create a subscriber client, subscribe to channels, and handle incoming messages with a callback function.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\nuse std::sync::Arc;\n\nasync fn pubsub_example() -> Result<(), RedisError> {\n  let subscriber_config = RedisConfig::default();\n  // optional: use the builder pattern\n  let subscriber = RedisClient::new(subscriber_config);\n  subscriber.connect();\n  subscriber.wait_for_connect().await?;\n  \n  // subscribe to a channel\n  let callback = Arc::new(|message: Message| {\n    println!(\"Received message: {:?}\", message);\n  });\n  subscriber.subscribe(\"foo\", callback).await?;\n  \n  // publish a message using a separate client\n  let publisher_config = RedisConfig::default();\n  let publisher = RedisClient::new(publisher_config);\n  publisher.connect();\n  publisher.wait_for_connect().await?;\n  publisher.publish(\"foo\", \"bar\").await?;\n  \n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Get Command in Rust Redis Client\nDESCRIPTION: Demonstrates the implementation of the 'get' command in the Redis client. Shows how commands are sent to the router task and responses are received asynchronously.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl Client {\n  pub async fn get<K: Into<Key>>(&self, key: K) -> Result<Value, Error> {\n    let (tx, rx) = oneshot_channel();\n    let command = Command {\n      kind: CommandKind::Get,\n      args: vec![key.into().into()],\n      tx\n    };\n\n    self.inner.command_tx.load().send(command);\n    rx.await.and_then(|f| f.into())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Pipelining for batched Redis operations in Rust\nDESCRIPTION: Demonstrates how to use Redis pipelining in FRED to batch multiple commands together for improved efficiency. Pipelining reduces network round-trips by sending multiple commands at once and processing responses in bulk.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), RedisError> {\n  let config = RedisConfig::default();\n  let client = RedisClient::new(config);\n  client.connect();\n  client.wait_for_connect().await?;\n  \n  let pipeline = client.pipeline();\n  let response: (bool, String, usize) = pipeline\n    .exists(\"foo\")\n    .get(\"bar\")\n    .hlen(\"baz\")\n    .all().await?;\n  \n  println!(\"Exists: {}, Value: {}, Length: {}\", response.0, response.1, response.2);\n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Redis Pipeline in Rust\nDESCRIPTION: Demonstrates how to create and execute a Redis pipeline within a single Tokio task. The example shows buffering commands in memory and sending them to the server in one round trip.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nasync fn example(client: &Client) -> Result<(), Error> {\n  let pipeline = client.pipeline();\n\n  // commands are buffered in memory. the pipeline interface could be synchronous (the first two await points return \n  // immediately), but that would require duplicating >200 public functions, massively inflating compilation times just\n  // to avoid an await point that doesn't actually wait on anything. instead the client interfaces re-use the same \n  // async interfaces but with a different implementation that buffers the commands in memory first.\n  let _: () = pipeline.incr(\"foo\").await?;\n  let _: () = pipeline.incr(\"foo\").await?;\n  // commands are sent when calling all(), last(), or try_all(()\n  let (first, second): (i64, i64) = pipeline.all().await?;\n  assert_eq!((first, second), (1, 2));\n\n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Redis GET Operation with Fred\nDESCRIPTION: Demonstrates a simple Redis GET operation using the Fred client, showcasing the basic pattern for executing Redis commands.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet client = RedisClient::default();\n// connect to a Redis server at localhost:6379\nclient.connect(None);\n// wait for the client to connect\nclient.wait_for_connect().await?;\n\nlet value: Option<String> = client.get(\"foo\").await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Serialization/Deserialization in Fred\nDESCRIPTION: Shows how to create and use custom de/serializers to handle custom types when interacting with Redis through Fred.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyType {\n  value: String\n}\n\n// implement serialization to convert MyType -> RedisValue\nimpl RedisValueBuildable for MyType {\n  fn into_redis_value(self) -> RedisValue {\n    RedisValue::String(self.value.into_bytes().into())\n  }\n}\n\n// implement deserialization to convert RedisValue -> MyType\nimpl TryFromRedisValue for MyType {\n  fn try_from_redis_value(value: RedisValue) -> Result<Self, RedisError> {\n    match value {\n      RedisValue::String(bytes) => {\n        let value = String::from_utf8(bytes.to_vec())?;\n        Ok(MyType { value })\n      },\n      other => Err(RedisError::new(\n        RedisErrorKind::Parse, \n        \"Expected string value\"\n      ))\n    }\n  }\n}\n\n// Store the type directly\nlet foo = MyType { value: \"abc\".into() };\nclient.set(\"foo\", foo).await?;\n\n// And read it back\nlet result: MyType = client.get(\"foo\").await?;\n```\n\n----------------------------------------\n\nTITLE: Creating Centralized Redis Client Pools in Rust\nDESCRIPTION: Demonstrates how to create a centralized pool of Redis clients using FRED. This approach is useful for applications that need to manage multiple Redis connections across different parts of the codebase.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\nuse lazy_static::lazy_static;\nuse std::sync::Arc;\n\nlazy_static! {\n  pub static ref REDIS: Arc<RedisClient> = {\n    let config = RedisConfig::default();\n    let client = RedisClient::new(config);\n\n    client.connect();\n    Arc::new(client)\n  };\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), RedisError> {\n  // wait for the client to connect\n  REDIS.wait_for_connect().await?;\n  \n  // use the client anywhere in the codebase\n  let value: String = REDIS.get(\"foo\").await?;\n  println!(\"Value: {}\", value);\n  \n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Using the pattern API with Redis in Rust\nDESCRIPTION: Shows how to use the pattern API in FRED to work with Redis patterns, particularly for pub/sub operations. This example demonstrates subscribing to pattern channels and handling messages with a callback function.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse fred::prelude::*;\nuse std::sync::Arc;\n\nasync fn pattern_example() -> Result<(), RedisError> {\n  let subscriber_config = RedisConfig::default();\n  let subscriber = RedisClient::new(subscriber_config);\n  subscriber.connect();\n  subscriber.wait_for_connect().await?;\n  \n  // subscribe to a pattern\n  let callback = Arc::new(|message: Message| {\n    println!(\"Received message: {:?}\", message);\n  });\n  subscriber.psubscribe(\"foo*\", callback).await?;\n  \n  // publish a message\n  let publisher_config = RedisConfig::default();\n  let publisher = RedisClient::new(publisher_config);\n  publisher.connect();\n  publisher.wait_for_connect().await?;\n  publisher.publish(\"foo-1\", \"bar\").await?;\n  \n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Connection Read and Write Operations in Rust\nDESCRIPTION: High-level implementation of the read and write methods for a Connection that handles command queuing and response matching. This demonstrates the basic pipeline buffering system where commands are buffered when sent and popped when responses are received.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nimpl Connection {\n  pub async fn write(&mut self, command: Command) -> Result<(), Error> {\n    let frame = encode_frame(&command)?;\n    self.buffer.push_back(command);\n    self.transport.send(frame).await\n  }\n\n  pub async fn read(&mut self) -> Result<Option<(Resp3Frame, Command)>, Error> {\n    let frame = self.transport.next().await?;\n    Ok(self.buffer.pop_front().map(|cmd| (frame, cmd)))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Connection Struct with Command Buffering in Rust\nDESCRIPTION: Definition of the Connection struct that tracks in-flight requests awaiting responses. The buffer field is a VecDeque that functions as a queue, leveraging Redis's guarantee of responding to requests in the order they were sent.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\npub struct Connection {\n  pub transport: ConnectionKind,\n  pub buffer: VecDeque<Command>,\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Interface on Client Structs\nDESCRIPTION: Shows how to implement the KeysInterface trait for both the main Client struct and the Transaction struct to expose the MGET command functionality.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/CONTRIBUTING.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl KeysInterface for Client {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl KeysInterface for Transaction {}\n```\n\n----------------------------------------\n\nTITLE: Defining Command and CommandKind Structs in Rust\nDESCRIPTION: Defines the Command and CommandKind structs used to represent Redis commands. The Command struct includes the command type, arguments, and a channel for sending the response.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nenum CommandKind {\n  Get,\n  Set,\n  Del,\n  // ...\n}\n\nstruct Command {\n  pub kind: CommandKind,\n  pub args: Vec<Value>,\n  pub tx: Option<OneshotSender<Resp3Frame>>,\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router and Connection Management System in Rust\nDESCRIPTION: Implementation of the Connections enum and Router struct that manage different Redis topologies (centralized, sentinel, clustered). This system handles command routing, connection tracking, and cluster routing caching to direct commands to the appropriate Redis servers.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\npub enum Connections {\n  Centralized {\n    connection: Connection,\n    // ...\n  },\n  Sentinel {\n    connection: Connection,\n    // ...\n  },\n  Clustered {\n    connections: HashMap<Server, Connection>,\n    cache: ClusterRouting,\n    // ...\n  }\n}\n\nimpl Connections {\n  pub fn get_connection_mut(&mut self, server: &Server) -> Option<&mut Connection> {\n    match self {\n      Connections::Clustered { ref mut connection } | Connections::Sentinel { ref mut connection } => {\n        connection\n      }\n      Connections::Clustered { connections, .. } => {\n        connections.get_mut(server)\n      }\n    }\n  }\n\n  pub async fn write(&mut self, command: Command) -> Result<(), Error> {\n    match self {\n      Connections::Centralized { connection } | Connections::Sentinel { connection } => {\n        connection.write(command).await\n      }\n      Connections::Clustered { connections, cache } => {\n        let server = match cache.get_server(command.first_key()) {\n          Some(server) => server,\n          None => return Err(Error::new(\n            ErrorKind::Routing,\n            format!(\"Failed to find server for hash slot {hash_slot}.\")\n          ))\n        };\n\n        if let Some(connection) = connections.get_mut(server) {\n          connection.write(command).await\n        } else {\n          Err(Error::new(ErrorKind::Routing, format!(\"Missing connection to {server}\")))\n        }\n      }\n    }\n  }\n\n  // ...\n}\n\npub struct Router {\n  pub connections: Connections,\n  pub retry_buffer: VecDeque<RouterCommand>,\n  #[cfg(feature = \"replicas\")]\n  pub replicas: HashMap<Server, Connection>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client and ClientInner Structs in Rust\nDESCRIPTION: Defines the Client and ClientInner structs used to manage shared state between the routing task and callers. Includes configuration, reconnection policy, and command channels.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct ClientInner {\n  pub config: Config,\n  pub reconnect_policy: ReconnectPolicy,\n  pub command_tx: ArcSwap<UnboundedSender<Command>>,\n  pub command_rx: ArcSwapOption<UnboundedReviever<Command>>,\n  // ...\n}\n\n#[derive(Clone)]\npub struct Client {\n  inner: Arc<ClientInner>\n}\n\nimpl Client {\n  pub fn new(config: Config, policy: ReconnectPolicy) -> Self {\n    let (tx, rx) = unbounded_channel();\n    Client {\n      inner: Arc::new(ClientInner {\n        config,\n        policy,\n        command_tx: ArcSwap::new(Arc::new(tx)),\n        command_rx: ArcSwapOption::new(Arc::new(Some(rx)))\n      })\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Router and Server Structs in Rust\nDESCRIPTION: Defines the Router and Server structs used for managing connections to Redis servers. The Router struct contains a HashMap of connections and a retry buffer for failed commands.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Hash)]\nstruct Server {\n  // note that `Str` is cheaply cloneable\n  pub host: Str,\n  pub port: u16\n}\n\nstruct Router {\n  pub connections: HashMap<Server, TcpStream>,\n  pub retry_buffer: VecDeque<Command>,\n  #[cfg(feature = \"replicas\")]\n  pub replicas: HashMap<Server, TcpStream>\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Integration Tests for MGET Command\nDESCRIPTION: Demonstrates how to write integration tests for the MGET command in the keys.rs test file, verifying that the command correctly retrieves multiple values from Redis.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/CONTRIBUTING.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub async fn should_mget_values(client: Client, _: Config) -> Result<(), RedisError> {\n  let expected: Vec<(&str, Value)> = vec![(\"a{1}\", 1.into()), (\"b{1}\", 2.into()), (\"c{1}\", 3.into())];\n  for (key, value) in expected.iter() {\n    let _: () = client.set(key, value.clone(), None, None, false).await?;\n  }\n  let values: Vec<i64> = client.mget(vec![\"a{1}\", \"b{1}\", \"c{1}\"]).await?;\n  assert_eq!(values, vec![1, 2, 3]);\n\n  Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Task in Rust\nDESCRIPTION: Shows the implementation of the router task, which manages connections and processes commands. The task runs in a loop, receiving commands and processing them asynchronously.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl Client {\n  pub fn connect(&self) -> JoinHandle<Result<(), Error>> {\n    let inner = self.inner.clone();\n\n    tokio::spawn(async move {\n      let mut router = Router::new();\n      create_connections(&inner, &mut router).await?;\n\n      while let Some(command) = inner.command_rx.recv().await? {\n        process_command(&inner, &mut router, command).await?;\n      }\n      Ok(())\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Client with Tokio for Concurrent Pipelining\nDESCRIPTION: This Rust code demonstrates how to implement a Redis client using Tokio for concurrent pipelining across tasks. It shows a TCP listener that accepts connections and processes them asynchronously, allowing multiple tasks to share a single Redis connection efficiently.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n  let listener = TcpListener::bind(\"127.0.0.1:8080\").await?;\n  let client = Builder::default_centralized().build()?;\n\n  loop {\n    let (socket, _) = listener.accept().await?;\n    process_socket(&client, socket);\n  }\n  Ok(())\n}\n\nasync fn process_socket(client: &Client, mut socket: TcpStream) {\n  let client = client.clone();\n  tokio::spawn(async move {\n    loop {\n      let key = read_key(&mut socket).await?;\n      let value: String = client.get(key).await?;\n      println!(\"Got: {value}\");\n    }\n  });\n}\n\nasync fn read_key(socket: &mut TcpStream) -> Result<String, Error> {\n  // read and parse the next frame from the socket\n  unimplemented!()\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Command Variant to RedisCommandKind Enum in Rust\nDESCRIPTION: Shows how to add a new MGET command variant to the RedisCommandKind enum, including the necessary implementations for debug string representation and command string conversion.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/CONTRIBUTING.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub enum RedisCommandKind {\n  // ...\n  Mget,\n  // ...\n}\n\nimpl RedisCommandKind {\n  // ..\n\n  pub fn to_str_debug(&self) -> &str {\n    match *self {\n      // ..\n      RedisCommandKind::Mget => \"MGET\",\n      // ..\n    }\n  }\n\n  // ..\n\n  pub fn cmd_str(&self) -> Str {\n    match *self {\n      // .. \n      RedisCommandKind::Mget => \"MGET\"\n      // ..\n    }\n  }\n\n  // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Private MGET Command Function in Rust\nDESCRIPTION: Demonstrates implementing the private function for the MGET command in the keys.rs file, showing both a detailed implementation and a shorthand version using helper functions.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/CONTRIBUTING.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub async fn mget<C: ClientLike>(client: &C, keys: MultipleKeys) -> Result<Value, RedisError> {\n  // maybe do some kind of validation \n  utils::check_empty_keys(&keys)?\n\n  let frame = utils::request_response(client, move || {\n    // time spent here will show up in traces in the `prepare_command` span\n    Ok((RedisCommandKind::Mget, keys.into_values()))\n  })\n    .await?\n\n  protocol_utils::frame_to_results(frame)\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub async fn mget<C: ClientLike>(client: &C, keys: MultipleKeys) -> Result<Value, RedisError> {\n  utils::check_empty_keys(&keys)?\n  args_values_cmd(client, keys.into_values()).await\n}\n```\n\n----------------------------------------\n\nTITLE: Adding FRED as a dependency in Cargo.toml\nDESCRIPTION: Shows how to include the FRED library in a Rust project by adding it to the Cargo.toml dependencies section. It includes both the standard dependency format and optional features for more functionality.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Cargo.toml\n[dependencies]\nfred = \"6.0\"\n\n# Or with features\nfred = { version = \"6.0\", features = [\"subscriber-client\", \"replicas\", \"metrics\", \"sentinel-client\", \"codecs\"] }\n```\n\n----------------------------------------\n\nTITLE: Creating Public Interface for MGET Command in KeysInterface Trait\nDESCRIPTION: Shows how to expose the MGET command through the public KeysInterface trait, which defines the method signature and documentation for the command.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/CONTRIBUTING.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// ...\n\npub trait KeysInterface: ClientLike {\n\n  // ...\n\n  /// Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value nil is returned.\n  ///\n  /// <https://redis.io/commands/mget>\n  fn mget<R, K>(&self, keys: K) -> impl Future<Output=RedisResult<R>> + Send\n  where\n    R: FromRedis,\n    K: Into<MultipleKeys> + Send,\n  {\n    async move {\n      into!(keys);\n      commands::keys::mget(self, keys).await?.convert()\n    }\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadAllFuture for Concurrent Connection Polling in Rust\nDESCRIPTION: This code defines the ReadAllFuture type that handles concurrent polling of multiple Redis server connections. It's designed to be cancel-safe when used in select contexts and collects response frames from all available connections.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n// a buffer containing response frames and the associated server identifier\ntype Responses = Vec<(Server, Option<Result<Resp3Frame, Error>>)>;\n\npub struct ReadAllFuture<'a, 'b> {\n  inner: &'a Arc<ClientInner>,\n  connections: &'b mut HashMap<Server, Connection>,\n}\n\nimpl Future for ReadAllFuture<'_, '_> {\n  type Output = Responses;\n\n  fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n    if self.connections.is_empty() {\n      // return pending because we know this will be interrupted by another future returning first, such \n      // as a command being received by the router, a reconnection attempt finishing, etc.\n      return Poll::Pending;\n    }\n\n    let _self = self.get_mut();\n    let mut out = Vec::new();\n    for (_, conn) in _self.connections.iter_mut() {\n      poll_connection(conn, cx, &mut out);\n    }\n\n    if out.is_empty() {\n      Poll::Pending\n    } else {\n      Poll::Ready(out)\n    }\n  }\n}\n\nfn poll_connection(conn: &mut Connection, cx: &mut Context<'_>, buf: &mut Responses) {\n  // check for response frames or tell the runtime to wake up later when one is received. the `server` is cloned \n  // because we need to mutably borrow the connection again after this, so we can't return a second immutable reference \n  // to a different field on that struct. hopefully one day partial borrowing will be supported, but for now we can \n  // rely on a `Server` being cheaply cloneable since the inner `bytes_utils::Str` is cheaply cloneable.\n  match Pin::new(&mut conn.transport).poll_next(cx) {\n    // indicates a frame has been received\n    Poll::Ready(Some(frame)) => {\n      buf.push((conn.server.clone(), Some(frame.map(|f| f.into_resp3()))));\n    }\n    // indicates the connection has closed\n    Poll::Ready(None) => {\n      buf.push((conn.server.clone(), None));\n    }\n    // indicates that no frames are ready\n    Poll::Pending => Poll::Pending\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Centralized and Clustered Environments\nDESCRIPTION: Shows how to register the MGET tests to run in both centralized and clustered Redis deployments using test macros that automatically test across different protocol modes.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/CONTRIBUTING.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmod keys {\n  // ..\n  centralized_test!(keys, should_mget_values);\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod keys {\n  // ..\n  cluster_test!(keys, should_mget_values);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing read_or_write Function for Redis Client in Rust\nDESCRIPTION: This function combines reading and writing logic in a select loop. It prioritizes reading inbound responses from servers and handles command processing, disconnections, and reconnection events.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nasync fn read_or_write(inner: &Arc<ClientInner>, router: &mut Router) -> Result<(), Error> {\n  let mut command_rx = inner.command_rx.swap(None);\n  let mut result = Ok(());\n\n  loop {\n    // note that the outer futures passed to both select branches do not reference any of the same types\n    tokio::select! {\n      // prefer reading inbound responses from servers\n      biased; \n      results = ReadAllFuture::new(router) => {\n        for (server, frame) in results.into_iter() {\n          match frame {\n            Some(Ok(frame)) => {\n              // note that is not async\n              process_response(inner, router, server, frame);\n            },\n            // the connection closed with an IO error\n            Some(Err(err)) => {\n              let pending = router.disconnect(server).await;\n              // put all the in-flight commands in the retry buffer\n              router.retry_buffer.extend(pending);\n              // defer the next reconnection attempt\n              inner.command_tx.load().send(RouterCommand::Reconnect(server));\n            },\n            // the connection closed gracefully. in practice this also often triggers a reconnection event.\n            None => router.disconnect(server).await\n          }\n        }\n      },\n      Some(command) = command_rx.recv() => {\n        // only fatal errors are returned in this context. most write failure cases are handled internally.\n        result = match command {\n          // if this fails it typically puts the command in the `retry_buffer`.\n          RouterCommand::Command(command) => router.write(command).await,\n          // note that at this point `Router` is no longer borrowed by another future in the select! call, so we can\n          // use a more sophisticated `reconnect_with_policy` implementation that simultaneously reads from sockets \n          // while sleeping before the next reconnection attempt.\n          RouterCommand::Reconnect(server) => reconnect_with_policy(inner, router, server).await,\n          RouterCommand::Pipeline(commands) => unimplemented!(),\n          RouterCommand::Transaction(commands) => unimplemented!(),\n        };\n        \n        if result.is_err() { break; }\n      }\n    }\n  }\n\n  // always put the old `rx` back in case this is called again\n  inner.command_rx.swap(Some(command_rx));\n  result\n}\n\nfn process_response(inner: &Arc<ClientInner>, router: &mut Router, server: Server, frame: Resp3Frame) {\n  if frame.is_pubsub() {\n    // do pubsub things\n    unimplemented!()\n  } else if let Some(conn) = router.connections.get_connection_mut(&server) {\n    let command = match conn.buffer.pop_front() {\n      Some(command) => command,\n      None => return Err(Error::new(ErrorKind::Protocol, \"Missing expected command.\"))\n    };\n\n    // respond to the caller\n    command.tx.send(frame);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reconnection Logic in Rust Redis Client\nDESCRIPTION: Shows the implementation of reconnection logic in the Redis client. The code handles reconnection attempts based on the provided reconnection policy, including backoff and retry mechanisms.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nasync fn process_command(inner: &Arc<ClientInner>, router: &mut Router, command: RouterCommand) -> Result<(), Error> {\n  match command {\n    RouterCommand::Reconnect(server) => {\n      reconnect_with_policy(inner, router, server).await\n    }\n    _ => unimplemented!()\n  }\n}\n\nasync fn reconnect_with_policy(inner: &Arc<ClientInner>, router: &mut Router, server: &Server) -> Result<(), Error> {\n  loop {\n    if let Err(err) = reconnect_once(inner, router, server).await {\n      // this also checks whether the max reconnection attempts has been reached\n      match inner.reconnect_policy.next_delay() {\n        Some(dur) => tokio::sleep(dur).await,\n        None => return Err(err)\n      };\n    } else {\n      // drain the `retry_buffer`, retrying all the commands that were in-flight when the connection closed\n      router.retry_failed_commands().await;\n      break;\n    }\n  }\n\n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RouterCommand Enum and Updated ClientInner Struct in Rust\nDESCRIPTION: Defines the RouterCommand enum to handle different types of commands, including reconnections and transactions. Updates the ClientInner struct to use RouterCommand instead of Command.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum RouterCommand {\n  Command(Command),\n  Reconnect(Server),\n  Transaction(Vec<Command>),\n  Pipeline(Vec<Command>),\n  // ...\n}\n\nstruct ClientInner {\n  pub config: Config,\n  pub reconnect_policy: ReconnectPolicy,\n  pub command_tx: ArcSwap<UnboundedSender<RouterCommand>>,\n  pub command_rx: ArcSwapOption<UnboundedReviever<RouterCommand>>,\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Redis Cluster Slot Information with CLUSTER SLOTS Command\nDESCRIPTION: This snippet shows the output of the CLUSTER SLOTS command, which provides information about the cluster's slot distribution and node configuration. It includes details such as slot ranges, IP addresses, ports, and node IDs for both primary and replica nodes.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_0\n\nLANGUAGE: redis\nCODE:\n```\n> CLUSTER SLOTS\n1) 1) (integer) 0\n   2) (integer) 5460\n   3) 1) \"127.0.0.1\"\n      2) (integer) 30001\n      3) \"09dbe9720cda62f7865eabc5fd8857c5d2678366\"\n      4) 1) hostname\n         2) \"host-1.redis.example.com\"\n   4) 1) \"127.0.0.1\"\n      2) (integer) 30004\n      3) \"821d8ca00d7ccf931ed3ffc7e3db0599d2271abf\"\n      4) 1) hostname\n         2) \"host-2.redis.example.com\"\n2) 1) (integer) 5461\n   2) (integer) 10922\n   3) 1) \"127.0.0.1\"\n      2) (integer) 30002\n      3) \"c9d93d9f2c0c524ff34cc11838c2003d8c29e013\"\n      4) 1) hostname\n         2) \"host-3.redis.example.com\"\n   4) 1) \"127.0.0.1\"\n      2) (integer) 30005\n      3) \"faadb3eb99009de4ab72ad6b6ed87634c7ee410f\"\n      4) 1) hostname\n         2) \"host-4.redis.example.com\"\n3) 1) (integer) 10923\n   2) (integer) 16383\n   3) 1) \"127.0.0.1\"\n      2) (integer) 30003\n      3) \"044ec91f325b7595e76dbcb18cc688b6a5b434a1\"\n      4) 1) hostname\n         2) \"host-5.redis.example.com\"\n   4) 1) \"127.0.0.1\"\n      2) (integer) 30006\n      3) \"58e6e48d41228013e5d9c1c37c5060693925e97e\"\n      4) 1) hostname\n         2) \"host-6.redis.example.com\"\n```\n\n----------------------------------------\n\nTITLE: Usage Instructions for Replica Consistency Testing Script in Rust\nDESCRIPTION: Defines the command-line interface for the replica_consistency script, including flags and options for configuring the test parameters such as concurrency, interval, and connection details.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/replica_consistency/README.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nRun a script that tests cluster consistency.\n\nUSAGE:\n    replica_consistency [FLAGS] [OPTIONS]\n\nFLAGS:\n        --help       Prints help information\n    -V, --version    Prints version information\n        --wait       Whether to send `WAIT 1 10` after each `SET` operation\n\nOPTIONS:\n    -a, --auth <STRING>           An optional authentication key or password. [default: ]\n    -c, --concurrency <NUMBER>    The number of concurrent set-get commands to set each `interval`. [default: 500]\n    -h, --host <STRING>           The hostname of the redis server. [default: 127.0.0.1]\n    -i, --interval <NUMBER>       The time to wait between commands in milliseconds. [default: 500]\n    -P, --pool <NUMBER>           The number of clients in the redis connection pool. [default: 1]\n    -p, --port <NUMBER>           The port for the redis server. [default: 6379]\n```\n\n----------------------------------------\n\nTITLE: Installing Fred Redis Client via Cargo\nDESCRIPTION: Shows how to add Fred as a dependency in a Rust project's Cargo.toml file, including basic and TLS features.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/clustered/README.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Default features\n[dependencies]\nfred = \"6.0\"\n\n# Default features + TLS support\n[dependencies]\nfred = { version = \"6.0\", features = [\"enable-tls\"] }\n```\n\n----------------------------------------\n\nTITLE: Benchmark Metrics Command-Line Usage in Plain Text\nDESCRIPTION: This snippet shows the command-line usage for the benchmark_metrics tool. It lists available flags, options, and subcommands, including parameters for configuring concurrency, pool size, and other benchmark settings.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/README.md#2025-04-19_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nUSAGE:\n    benchmark_metrics [FLAGS] [OPTIONS] [SUBCOMMAND]\n\nFLAGS:\n        --cluster    Whether to assume a clustered deployment.\n        --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -c, --concurrency <RANGE (X-Y)>    The number of concurrent tasks used to run commands. [default: 1-1000]\n        --concurrency-step <NUMBER>    The amount to increment the `concurrency` value on each test run. [default: 30]\n    -n, --commands <NUMBER>            The number of commands to run. [default: 10000]\n    -h, --host <STRING>                The hostname of the redis server. [default: 127.0.0.1]\n    -P, --pool <RANGE (X-Y)>           The number of clients in the redis connection pool. [default: 1-50]\n        --pool-step <NUMBER>           The amount to increment the `pool` value on each test run. [default: 2]\n    -p, --port <NUMBER>                The port for the redis server. [default: 6379]\n\nSUBCOMMANDS:\n    help           Prints this message or the help of the given subcommand(s)\n    no-pipeline    Run the test without pipelining.\n    pipeline       Run the test with pipelining.\n```\n\n----------------------------------------\n\nTITLE: Fred Benchmark CLI Usage\nDESCRIPTION: Command-line interface usage for the Fred benchmark tool. It shows various flags and options available for configuring the benchmark, including cluster mode, TLS, tracing, concurrency, and more.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark/README.md#2025-04-19_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nA benchmarking module based on the `redis-benchmark` tool included with Redis.\n\nUSAGE:\n    fred_benchmark [FLAGS] [OPTIONS]\n\nFLAGS:\n        --cluster     Whether to assume a clustered deployment.\n        --help        Prints help information\n    -q, --quiet       Only print the final req/sec measurement.\n        --replicas    Whether to use `GET` with replica nodes instead of `INCR` with primary nodes.\n    -t, --tls         Enable TLS via whichever build flag is provided.\n    -T, --tracing     Whether to enable tracing via a local Jeager instance. See tests/docker-compose.yml to start up a\n                      local Jaeger instance.\n    -V, --version     Prints version information\n\nOPTIONS:\n    -a, --auth <STRING>           The password/key to use. `REDIS_USERNAME` and `REDIS_PASSWORD` can also be used.\n        --bounded <NUMBER>        The size of the bounded mpsc channel used to route commands. [default: 0]\n    -c, --concurrency <NUMBER>    The number of Tokio tasks used to run commands. [default: 100]\n    -n, --commands <NUMBER>       The number of commands to run. [default: 100000]\n    -h, --host <STRING>           The hostname of the redis server. [default: 127.0.0.1]\n    -P, --pool <NUMBER>           The number of clients in the redis connection pool. [default: 1]\n    -p, --port <NUMBER>           The port for the redis server. [default: 6379]\n    -u, --unix-sock <PATH>        The path to a unix socket.\n```\n\n----------------------------------------\n\nTITLE: Running Fred Benchmark with Cluster Mode\nDESCRIPTION: Example command for running the Fred benchmark in cluster mode with specific parameters. It demonstrates how to use the benchmark with a clustered Redis deployment, high concurrency, and a custom connection pool size.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./run.sh --cluster -c 10000 -n 10000000 -P 15 -h redis-cluster-1 -p 30001 -a bar\n```\n\n----------------------------------------\n\nTITLE: Running Fred Benchmark with Replica Nodes\nDESCRIPTION: Example command for running the Fred benchmark using GET operations on replica nodes instead of INCR on primary nodes. This demonstrates how to benchmark read operations in a clustered environment.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark/README.md#2025-04-19_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./run.sh --cluster -c 10000 -n 10000000 -P 15 -h redis-cluster-1 -p 30001 -a bar --replicas\n```\n\n----------------------------------------\n\nTITLE: Running Benchmark Metrics with Custom Parameters in Bash\nDESCRIPTION: This command runs the benchmark tool with specific parameters to test performance across different concurrency levels and pool sizes. It targets a Redis cluster, performs 1 million operations, and varies the concurrency and pool size within specified ranges.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./run.sh -h redis-cluster-1 -p 30001 --cluster -n 1000000 -P 1-16 --pool-step 2 -c 50-10000 --concurrency-step 50 pipeline\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Benchmark Tests with Different Configurations in Bash\nDESCRIPTION: This bash script runs a series of benchmark tests with different configurations, including clustered and centralized deployments, with and without pipelining. It generates CSV output files for each configuration in the metrics folder.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./run.sh -h redis-cluster-1 -p 30001 --cluster -n 1000000 -P 1-20 --pool-step 2 -c 100-15000 --concurrency-step 100 pipeline > ./metrics/clustered/pipeline.csv \\\n  && ./run.sh -h redis-cluster-1 -p 30001 --cluster -n 1000000 -P 1-20 --pool-step 2 -c 100-15000 --concurrency-step 100 no-pipeline > ./metrics/clustered/no-pipeline.csv \\\n  && ./run.sh -h redis-main -p 6379 -n 1000000 -P 1-20 --pool-step 2 -c 100-15000 --concurrency-step 100 pipeline > ./metrics/centralized/pipeline.csv \\\n  && ./run.sh -h redis-main -p 6379 -n 1000000 -P 1-20 --pool-step 2 -c 100-15000 --concurrency-step 100 no-pipeline > ./metrics/centralized/no-pipeline.csv\n```\n\n----------------------------------------\n\nTITLE: Running the FRED test suite with Docker\nDESCRIPTION: Instructions for running the FRED test suite using Docker. This shows the typical command to use Docker to run Redis for testing the library implementation against a real Redis instance.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark_metrics/metrics/centralized/README.md#2025-04-19_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -p 6379:6379 -d redis\n```\n\n----------------------------------------\n\nTITLE: Spawning Reader Task for Redis Connection in Rust\nDESCRIPTION: This function spawns a new task to continuously read frames from a Redis connection. It demonstrates the earlier approach of using separate tasks for reading, which was used in versions 5.x - 9.x of the library. The function takes a shared client state, server information, and a TCP stream reader half.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/doc/design.md#2025-04-19_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nasync fn spawn_reader_task(inner: &Arc<ClientInner>, server: Server, reader: OwnedReadHalf) -> JoinHandle<Result<(), Error>> {\n  let inner = inner.clone();\n  // the router would then check the health of a reader by calling `is_finished` on the returned `JoinHandle`. \n  tokio::spawn(async move {\n    while let Some(frame) = reader.try_next().await? {\n      process_frame(inner, server, frame);\n    }\n\n    Ok(())\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Glommio Runtime in Fred.rs\nDESCRIPTION: Example of how to enable the Glommio runtime feature flag when building Fred.rs, which triggers the use of a Tokio compatibility layer for AsyncRead and AsyncWrite traits.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/src/runtime/README.md#2025-04-19_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n--features glommio\n```\n\n----------------------------------------\n\nTITLE: Referencing Glommio Example in Fred.rs\nDESCRIPTION: Link to a Glommio example implementation in the Fred.rs repository that demonstrates how to use Fred with the Glommio runtime.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/src/runtime/README.md#2025-04-19_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[Glommio Example](https://github.com/aembke/fred.rs/blob/main/examples/glommio.rs)\n```\n\n----------------------------------------\n\nTITLE: Running Fred Tests Example in Bash\nDESCRIPTION: Example bash commands for initializing the test environment and running tests with all features. This shows the basic workflow for running the test suite.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/tests/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd path/to/fred\n. ./tests/environ\n./tests/runners/all-features.sh\n```\n\n----------------------------------------\n\nTITLE: CLI Usage Description for inf_loop Script\nDESCRIPTION: Command-line interface documentation for the inf_loop script showing available flags and options. The script allows configuration of Redis host, port, interval between commands, pool size, and optional delays.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/inf_loop/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUSAGE:\n    inf_loop [FLAGS] [OPTIONS]\n\nFLAGS:\n        --cluster    Whether to use a clustered deployment.\n        --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -h, --host <STRING>        The hostname of the redis server. [default: 127.0.0.1]\n    -i, --interval <NUMBER>    The time to wait between INCR commands in milliseconds. [default: 1000]\n    -P, --pool <NUMBER>        The number of clients in the redis connection pool. [default: 1]\n    -p, --port <NUMBER>        The port for the redis server. [default: 6379]\n    -w, --wait <NUMBER>        Add a delay, in milliseconds, after connecting but before starting the INCR loop.\n                               [default: 0]\n```\n\n----------------------------------------\n\nTITLE: Docker Command for Running inf_loop with Cluster Configuration\nDESCRIPTION: Example command for running the inf_loop script within Docker, connecting to a Redis cluster. It specifies the cluster flag, a Redis cluster host, port, and authentication key.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/inf_loop/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./run.sh --cluster -h redis-cluster-1 -p 30001 -a key\n```\n\n----------------------------------------\n\nTITLE: Running Jaeger for Tracing in Docker\nDESCRIPTION: Command to start a local Jaeger instance using Docker Compose for tracing purposes. This is used when tracing features are enabled in the benchmark.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/benchmark/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose -f /path/to/fred/tests/docker/compose/jaeger.yml up\n```\n\n----------------------------------------\n\nTITLE: Executing Replica Consistency Test Script for Redis Cluster in Bash\nDESCRIPTION: Demonstrates how to run the replica_consistency script with specific parameters, including setting environment variables, changing directories, and providing connection details for a Redis cluster.\nSOURCE: https://github.com/aembke/fred.rs/blob/main/bin/replica_consistency/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd path/to/fred\nsource ./tests/environ\ncd bin/replica_consistency\nRUST_LOG=replica_consistency=info,fred=debug ./run.sh -a bar -h redis-cluster-1 -p 30001 -P 6 -i 500 -c 500\n```"
  }
]