[
  {
    "owner": "scalatra",
    "repo": "scalatra",
    "content": "TITLE: Creating a Simple Scalatra Servlet in Scala\nDESCRIPTION: This code snippet demonstrates how to create a basic Scalatra servlet that responds with \"Hello, world!\" when accessed at the root path (\"/\"). It extends `ScalatraServlet` and overrides the `get` method to define the response.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/README.markdown#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport org.scalatra._\n\nclass ScalatraExample extends ScalatraServlet {\n  get(\"/\") {\n    <h1>Hello, world!</h1>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Atmosphere Servlet Example Scala\nDESCRIPTION: Illustrates how to create an Atmosphere servlet in Scalatra for handling WebSocket and long-polling communication.  It defines a `receive` method to process different types of messages, including connection events, disconnections, text messages, and JSON messages.  The example demonstrates sending and broadcasting messages to connected clients.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.markdown#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass MyAtmoServlet {\n  def receive = {\n    case Connected =>\n    case Disconnected(disconnector, Some(error)) =>\n    case Error(Some(error)) =>\n    case TextMessage(text) => send(\"ECHO: \" + text)\n    case JsonMessage(json) => broadcast(json)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Atmosphere Servlet Example (Scalatra)\nDESCRIPTION: This snippet demonstrates a `MyAtmoServlet` class for handling real-time communication using the Atmosphere integration in Scalatra. It defines a `receive` method to handle different types of messages, including Connected, Disconnected, Error, TextMessage, and JsonMessage events. It showcases the use of websockets, long-polling, and server-side events.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.RC1.markdown#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass MyAtmoServlet {\n  def receive = {\n    case Connected =>\n    case Disconnected(disconnector, Some(error)) =>\n    case Error(Some(error)) =>\n    case TextMessage(text) => send(\"ECHO: \" + text)\n    case JsonMessage(json) => broadcast(json)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Multipart Form Data Request\nDESCRIPTION: This snippet defines an HTTP POST request with Content-Type set to multipart/form-data.  It includes multiple form fields: 'string', 'utf8-string', 'file' (with filename '1.txt'), 'file-none' (with empty filename), and an array of files 'file-two[]' (with filenames '2.txt' and '3.txt'). The boundary separates the different form fields.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/core/src/test/resources/org/scalatra/servlet/multipart_request.txt#_snippet_0\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST ${PATH} HTTP/1.0\nContent-Type: multipart/form-data; boundary=---------------------------3924013385056820061124200860\nContent-Length: 944\n\n-----------------------------3924013385056820061124200860\nContent-Disposition: form-data; name=\"string\"\n\nfoo\n-----------------------------3924013385056820061124200860\nContent-Disposition: form-data; name=\"utf8-string\"\n\nfÃ¶o\n-----------------------------3924013385056820061124200860\nContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\nContent-Type: text/plain\n\none\n\n-----------------------------3924013385056820061124200860\nContent-Disposition: form-data; name=\"file-none\"; filename=\"\"\nContent-Type: application/octet-stream\n\n\n-----------------------------3924013385056820061124200860\nContent-Disposition: form-data; name=\"file-two[]\"; filename=\"2.txt\"\nContent-Type: text/plain\n\ntwo\n\n-----------------------------3924013385056820061124200860\nContent-Disposition: form-data; name=\"file-two[]\"; filename=\"3.txt\"\nContent-Type: text/plain\n\nthree\n\n-----------------------------3924013385056820061124200860--\n```\n\n----------------------------------------\n\nTITLE: Command Data Binding Example Scala\nDESCRIPTION: Demonstrates how to define a command class using JacksonCommand for data binding in Scalatra.  It includes examples of field definitions with validation rules for various data types, such as strings and email addresses, using the binding syntax.  The validations are implemented using an infrastructure of type classes and scalaz validations.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.markdown#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass RegisterForm extends JacksonCommand { // you have to pick the json library of choice\n\n  val login: Field[String] = bind[String](\"login\").required.notBlank.minLength(6).validForFormat(\"\\\\w+\".r)\n\n  val name: Field[String] = bind[String](\"name\")\n\n  val email: Field[String] = bind[String](\"email\").required.notBlank.validEmail\n\n  val homepage: Field[String] = bind[String](\"homepage\").validUrl\n\n  val passwordConfirmation: FieldBinding = bind[String](\"passwordConfirmation\").required.notBlank\n\n  val password: FieldBinding = bind[String](\"password\").required.notBlank.validConfirmation(\"passwordConfirmation\", passwordConfirmation.value)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Databinding Command Example (Scalatra)\nDESCRIPTION: This snippet demonstrates a `RegisterForm` class extending `JacksonCommand` for data binding in Scalatra. It defines fields for login, name, email, homepage, passwordConfirmation, and password, with validations and constraints applied to each field. This is used for handling and validating form data within a Scalatra application.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.RC1.markdown#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass RegisterForm extends JacksonCommand { // you have to pick the json library of choice\n\n  val login: Field[String] = asString(\"login\").required.notBlank.minLength(6).validForFormat(\"\\\\w+\".r)\n\n  val name: Field[String] = asString(\"name\")\n\n  val email: Field[String] = asString(\"email\").required.notBlank.validEmail\n\n  val homepage: Field[String] = asString(\"homepage\").validUrl\n\n  val passwordConfirmation: FieldBinding = asString(\"passwordConfirmation\").required.notBlank\n\n  val password: FieldBinding = asString(\"password\").required.notBlank.validConfirmation(\"passwordConfirmation\", passwordConfirmation.value)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Swagger API Operation Definition Scala\nDESCRIPTION: Shows how to define a Swagger API operation outside of a route context and register it in a Scalatra route.  It demonstrates using `apiOperation` to define the operation's metadata, including summary and notes.  The operation is then associated with a GET route using the `operation` method.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.markdown#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval myApiOperation =\n  (apiOperation[MyClass](\"myApiMethodName\")\n    summary \"This operation does foo\"\n    notes \"when foo is red then all bars are green\")\n\nget(\"/my-api-operation\", operation(myApiOperation)) {\n  // do stuff here\n}\n```\n\n----------------------------------------\n\nTITLE: Swagger Command Example (Scalatra)\nDESCRIPTION: This snippet demonstrates how to use commands with Swagger in Scalatra. It defines a `MyCommand` class extending `JsonCommand` with fields for name, age, token, skip, and limit. The fields are configured with validations, descriptions, source information (headers, query parameters), and allowable values. The `get` route uses the `parameters[MyCommand]` to automatically generate Swagger documentation for the command parameters.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.RC1.markdown#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nget(\"/id\", endpoint(\"id\"), nickname(\"getById\"), parameters[MyCommand])\n\nclass MyCommand extends JsonCommand {\n  protected implicit val jsonFormats: Formats = DefaultFormats\n          \n  val name: Field[String] = asString(\"name\").notBlank\n\n  val age: Field[Int] = \"age\"\n\n  val token: Field[String] = (\n      asString(\"API-TOKEN\").notBlank\n        sourcedFrom ValueSource.Header \n        description \"The API token for this request\"\n        notes \"Invalid data kills cute innocent kittens\"\n        allowableValues \"123\")\n\n  val skip: Field[Int] = asInt(\"skip\").sourcedFrom(ValueSource.Query).description(\"The offset for this collection index\")\n          \n  val limit: Field[Int] = asType[Int](\"limit\").sourcedFrom(ValueSource.Query).withDefaultValue(20).description(\"the max number of items to return\")\n}\n```\n\n----------------------------------------\n\nTITLE: Swagger AllowableValues Definition Scala\nDESCRIPTION: Demonstrates how to define allowable values for Swagger API parameters using the `AllowableValues` class.  It showcases two ways of defining allowable values: as a list of specific values and as a range.  These values are passed as strings to the `AllowableValues` object.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.markdown#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// as List\nallowableValues = AllowableValues(1, 2, 3)\n\n// as range\nallowableValues = AllowableValues(0 to 1000)\n```\n\n----------------------------------------\n\nTITLE: Adding Scalatra Dependency (javax) in Scala\nDESCRIPTION: This snippet shows how to add the Scalatra dependency using javax in your Scala project. It adds a library dependency to your build file using the group ID \"org.scalatra\", the artifact ID \"scalatra-javax\", and the version \"3.1.+\".\nSOURCE: https://github.com/scalatra/scalatra/blob/main/README.markdown#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"org.scalatra\" %% \"scalatra-javax\" % \"3.1.+\"\n```\n\n----------------------------------------\n\nTITLE: Adding Scalatra Dependency (jakarta) in Scala\nDESCRIPTION: This snippet shows how to add the Scalatra dependency using jakarta in your Scala project. It adds a library dependency to your build file using the group ID \"org.scalatra\", the artifact ID \"scalatra-jakarta\", and the version \"3.1.+\".\nSOURCE: https://github.com/scalatra/scalatra/blob/main/README.markdown#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"org.scalatra\" %% \"scalatra-jakarta\" % \"3.1.+\"\n```\n\n----------------------------------------\n\nTITLE: Swagger AllowableValues Example (Scalatra)\nDESCRIPTION: This snippet shows how to define `AllowableValues` in Swagger using a list or a range. These allowable values are passed as strings in the `AllowableValues` object. It is used for documenting the valid values for API parameters in Swagger.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.2.0.RC1.markdown#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// as List\nallowableValues = AllowableValues(1, 2, 3)\n        \n// as range\nallowableValues = AllowableValues(0 to 1000)\n```\n\n----------------------------------------\n\nTITLE: Documenting Scala Code\nDESCRIPTION: This example demonstrates how to write Scaladoc comments for Scala code. It highlights the importance of explaining the purpose of a trait rather than simply describing what it is.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/CONTRIBUTING.markdown#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n/**\n * A trait representing a Foo\n */\ntrait Foo { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\n/**\n * A Foo is used for bar-ing a Baz\n */\ntrait Foo { ... }\n```\n\n----------------------------------------\n\nTITLE: Customizing Method Not Allowed Handler in Scalatra\nDESCRIPTION: This snippet demonstrates how to override the default `methodNotAllowed` handler in ScalatraFilter. By assigning `ScalatraKernel.sendMethodNotAllowed` to `doMethodNotAllowed`, the previous behavior, where the handler did not delegate to the filter chain, is restored. This customization allows for specific handling of method not allowed errors within the Scalatra application.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.0.4.markdown#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndoMethodNotAllowed = ScalatraKernel.sendMethodNotAllowed\n```\n\n----------------------------------------\n\nTITLE: Testing ScalatraKernel Mixins\nDESCRIPTION: This code illustrates a pattern for testing traits that are intended to be mixed into ScalatraKernel. It involves creating a test servlet that includes the trait and then writing a FunSuite to test the servlet's behavior.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/CONTRIBUTING.markdown#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// define a servlet mixing in your trait\nclass SomethingSupportTestServlet extends ScalatraServlet with SomethingSupport {\n  get(\"/foo\") {\n    ... use support methods\n  }\n\n  post(\"/bar\") {\n    ... use support methods\n  }\n}\n\n// define a FunSuite for the servlet as if this was a normal scalatra app\nclass FlashMapSupportTest extends ScalatraFunSuite with ShouldMatchers {\n  addServlet(classOf[SomethingSupportTestServlet], \"/*\")\n\n  test(\"should use the support method sensibly\") {\n    session {\n      post(\"/bar\") {\n        header(\"xxx\") should equal(null)\n        body should equal(\"bla bla\");\n      }\n\n      get(\"/foo\") {\n        header(\"yyy\") should equal(\"posted\")\n        body should equal(\"bla bla\");\n      }\n\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Route Transformer Hooks - Scalatra Core\nDESCRIPTION: This snippet demonstrates the breaking change in Scalatra's route transformer hooks.  The `swaggerMeta` function now requires an explicit `Route` parameter in its function definition. This change ensures proper type safety and enables access to the route information within the transformer function. This is necessary for correct metadata manipulation.\nSOURCE: https://github.com/scalatra/scalatra/blob/main/notes/2.3.0.RC1.markdown#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nprotected def swaggerMeta(s: Symbol, v: Any): RouteTransformer = { route =>\n    route.copy(metadata = route.metadata + (s -> v))\n  }\n```\n\nLANGUAGE: scala\nCODE:\n```\nprotected def swaggerMeta(s: Symbol, v: Any): RouteTransformer = { (route: Route) =>\n    route.copy(metadata = route.metadata + (s -> v))\n  }\n```"
  }
]