[
  {
    "owner": "phoenixframework",
    "repo": "phoenix",
    "content": "TITLE: Implementing a Basic Thermostat LiveView in Elixir\nDESCRIPTION: A simple example of a LiveView module that displays a temperature value and provides a button to increment it. It demonstrates the three core components of a LiveView: mount for initialization, render for display, and handle_event for user interaction.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/live_view.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.ThermostatLive do\n  use MyAppWeb, :live_view\n\n  def render(assigns) do\n    ~H\"\"\"\n    Current temperature: {@temperature}Â°F\n    <button phx-click=\"inc_temperature\">+</button>\n    \"\"\"\n  end\n\n  def mount(_params, _session, socket) do\n    temperature = 70 # Let's assume a fixed temperature for now\n    {:ok, assign(socket, :temperature, temperature)}\n  end\n\n  def handle_event(\"inc_temperature\", _params, socket) do\n    {:noreply, update(socket, :temperature, &(&1 + 1))}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Ecto Schema with Changesets in Phoenix\nDESCRIPTION: A complete Ecto schema definition for a User model with fields mapping to the database table, including a changeset function for validating and casting data during operations.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.User do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"users\" do\n    field :bio, :string\n    field :email, :string\n    field :name, :string\n    field :number_of_pets, :integer\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:name, :email, :bio, :number_of_pets])\n    |> validate_required([:name, :email, :bio, :number_of_pets])\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Phoenix Release\nDESCRIPTION: Commands to generate a secret key and set necessary environment variables for deploying a Phoenix application in production.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.secret\nREALLY_LONG_SECRET\n$ export SECRET_KEY_BASE=REALLY_LONG_SECRET\n$ export DATABASE_URL=ecto://USER:PASS@HOST/database\n```\n\n----------------------------------------\n\nTITLE: Basic Phoenix Controller Definition in Elixir\nDESCRIPTION: The basic structure of a Phoenix controller module with a home action that renders a template. It shows how controllers use the web module and define actions as functions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageController do\n  use HelloWeb, :controller\n\n  def home(conn, _params) do\n    render(conn, :home)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Authentication System with mix phx.gen.auth in Phoenix\nDESCRIPTION: Command to generate an authentication system using mix phx.gen.auth, creating an Accounts context with a User schema.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/mix_phx_gen_auth.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.auth Accounts User users\n\nAn authentication system can be created in two different ways:\n- Using Phoenix.LiveView (default)\n- Using Phoenix.Controller only\n\nDo you want to create a LiveView based authentication system? [Y/n] Y\n```\n\n----------------------------------------\n\nTITLE: Expanding ShoppingCart Context in Phoenix\nDESCRIPTION: This snippet adds new functions to the ShoppingCart context for managing carts and cart items, including getting, creating, and modifying carts.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_11\n\nLANGUAGE: diff\nCODE:\n```\n+  alias Hello.Catalog\n-  alias Hello.ShoppingCart.Cart\n+  alias Hello.ShoppingCart.{Cart, CartItem}\n   alias Hello.Accounts.Scope\n\n+  def get_cart(%Scope{} = scope) do\n+    Repo.one(\n+      from(c in Cart,\n+        where: c.user_id == ^scope.user.id,\n+        left_join: i in assoc(c, :items),\n+        left_join: p in assoc(i, :product),\n+        order_by: [asc: i.inserted_at],\n+        preload: [items: {i, product: p}]\n+      )\n+    )\n+  end\n\n   def create_cart(%Scope{} = scope, attrs \\\\ %{}) do\n     with {:ok, cart = %Cart{}} <-\n            %Cart{}\n            |> Cart.changeset(attrs, scope)\n            |> Repo.insert() do\n       broadcast(scope, {:created, cart})\n-      {:ok, cart}\n+      {:ok, get_cart(scope, cart.id)}\n     end\n   end\n+\n+  def add_item_to_cart(%Scope{} = scope, %Cart{} = cart, product_id) do\n+    true = cart.user_id == scope.user.id\n+    product = Catalog.get_product!(product_id)\n+\n+    %CartItem{quantity: 1, price_when_carted: product.price}\n+    |> CartItem.changeset(%{})\n+    |> Ecto.Changeset.put_assoc(:cart, cart)\n+    |> Ecto.Changeset.put_assoc(:product, product)\n+    |> Repo.insert(\n+      on_conflict: [inc: [quantity: 1]],\n+      conflict_target: [:cart_id, :product_id]\n+    )\n+  end\n+\n+  def remove_item_from_cart(%Scope{} = scope, %Cart{} = cart, product_id) do\n+    true = cart.user_id == scope.user.id\n+\n+    {1, _} =\n+      Repo.delete_all(\n+        from(i in CartItem,\n+          where: i.cart_id == ^cart.id,\n+          where: i.product_id == ^product_id\n+        )\n+      )\n+\n+    {:ok, get_cart(scope)}\n+  end\n```\n\n----------------------------------------\n\nTITLE: Implementing Order Completion in Phoenix\nDESCRIPTION: Function to complete an order from a shopping cart using Ecto.Multi for transaction management. Handles cart item conversion to order line items, price capture, and cart cleanup.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n  alias Hello.Orders.LineItem\n  alias Hello.ShoppingCart\n\n  def complete_order(%Scope{} = scope, %ShoppingCart.Cart{} = cart) do\n    true = cart.user_id == scope.user.id\n\n    line_items =\n      Enum.map(cart.items, fn item ->\n        %{product_id: item.product_id, price: item.product.price, quantity: item.quantity}\n      end)\n\n    order =\n      Ecto.Changeset.change(%Order{},\n        user_id: scope.user.id,\n        total_price: ShoppingCart.total_cart_price(cart),\n        line_items: line_items\n      )\n\n    Ecto.Multi.new()\n    |> Ecto.Multi.insert(:order, order)\n    |> Ecto.Multi.run(:prune_cart, fn _repo, _changes ->\n      ShoppingCart.prune_cart_items(scope, cart)\n    end)\n    |> Repo.transaction()\n    |> case do\n      {:ok, %{order: order}} ->\n        broadcast(scope, {:created, order})\n        {:ok, order}\n\n      {:error, name, value, _changes_so_far} ->\n        {:error, {name, value}}\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Complete Phoenix Deployment Script\nDESCRIPTION: A comprehensive script that combines all the necessary steps for deploying a Phoenix application to production. It includes getting dependencies, compiling the application, deploying assets, running database migrations, and starting the server.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n# Initial setup\n$ mix deps.get --only prod\n$ MIX_ENV=prod mix compile\n\n# Compile assets\n$ MIX_ENV=prod mix assets.deploy\n\n# Custom tasks (like DB migrations)\n$ MIX_ENV=prod mix ecto.migrate\n\n# Finally run the server\n$ PORT=4001 MIX_ENV=prod mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Creating a New Phoenix Application with mix phx.new\nDESCRIPTION: Command to bootstrap a new Phoenix application using the mix task. This generates the project structure and files needed for a Phoenix app named 'hello'.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/up_and_running.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.new hello\n```\n\n----------------------------------------\n\nTITLE: Setting Production Environment Variables for Phoenix Application\nDESCRIPTION: Commands for generating and setting essential environment variables for a Phoenix application in production. This includes generating a secret key base with phx.gen.secret and setting both the SECRET_KEY_BASE and DATABASE_URL environment variables.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.secret\nREALLY_LONG_SECRET\n$ export SECRET_KEY_BASE=REALLY_LONG_SECRET\n$ export DATABASE_URL=ecto://USER:PASS@HOST/database\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Routes with Resources Macro\nDESCRIPTION: Using the resources macro to create a full set of RESTful routes for a user resource.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/\", HelloWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :home\n  resources \"/users\", UserController\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Router GET Route Definition in Elixir\nDESCRIPTION: A Phoenix router route definition showing how to map a GET request to a controller action. This example maps the root path to the home action in PageController.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nget \"/\", PageController, :home\n```\n\n----------------------------------------\n\nTITLE: Implementing Product Controller in Phoenix\nDESCRIPTION: Controller implementation for handling product-related HTTP requests. Includes actions for listing, creating, and showing products while delegating business logic to the Catalog context.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ProductController do\n  use HelloWeb, :controller\n\n  alias Hello.Catalog\n  alias Hello.Catalog.Product\n\n  def index(conn, _params) do\n    products = Catalog.list_products()\n    render(conn, :index, products: products)\n  end\n\n  def new(conn, _params) do\n    changeset = Catalog.change_product(%Product{})\n    render(conn, :new, changeset: changeset)\n  end\n\n  def create(conn, %{\"product\" => product_params}) do\n    case Catalog.create_product(product_params) do\n      {:ok, product} ->\n        conn\n        |> put_flash(:info, \"Product created successfully.\")\n        |> redirect(to: ~p\"/products/#{product}\")\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n        render(conn, :new, changeset: changeset)\n    end\n  end\n\n  def show(conn, %{\"id\" => id}) do\n    product = Catalog.get_product!(id)\n    render(conn, :show, product: product)\n  end\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Atomic Page View Increment Implementation in Elixir\nDESCRIPTION: Implements an atomic page view counter using Ecto.Repo.update_all to prevent race conditions when incrementing view counts.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n  def inc_page_views(%Product{} = product) do\n    {1, [%Product{views: views}]} =\n      from(p in Product, where: p.id == ^product.id, select: [:views])\n      |> Repo.update_all(inc: [views: 1])\n\n    put_in(product.views, views)\n  end\n```\n\n----------------------------------------\n\nTITLE: Starting the Phoenix Server\nDESCRIPTION: Command to start the Phoenix server and make the application accessible at localhost:4000. The server listens for file changes and automatically recompiles.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/up_and_running.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.server\n[info] Running HelloWeb.Endpoint with Bandit 1.5.7 at 127.0.0.1:4000 (http)\n[info] Access HelloWeb.Endpoint at http://localhost:4000\n[watch] build finished, watching for changes...\n...\n```\n\n----------------------------------------\n\nTITLE: Basic GET Route Definition\nDESCRIPTION: A simple HTTP GET route definition that maps a root URL to a controller action.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nget \"/\", PageController, :home\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Changeset Function in Elixir\nDESCRIPTION: This snippet shows a basic changeset function that casts and validates user attributes. It uses cast/3 to specify allowed fields and validate_required/3 to ensure necessary fields are present.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndef changeset(user, attrs) do\n  user\n  |> cast(attrs, [:name, :email, :bio, :number_of_pets])\n  |> validate_required([:name, :email, :bio, :number_of_pets])\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Resources in Phoenix Router\nDESCRIPTION: Illustrates how to define nested resources in a Phoenix router, specifically showing a posts resource nested within a users resource to represent a many-to-one relationship.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nresources \"/users\", UserController do\n  resources \"/posts\", PostController\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Cart Update Action in Phoenix Controller\nDESCRIPTION: Adds an update action to the CartController to handle form submissions for updating the cart. It uses the ShoppingCart context to process the update and handles success and error cases.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndef update(conn, %{\"cart\" => cart_params}) do\n  case ShoppingCart.update_cart(conn.assigns.current_scope, conn.assigns.cart, cart_params) do\n    {:ok, _cart} ->\n      redirect(conn, to: ~p\"/cart\")\n\n    {:error, _changeset} ->\n      conn\n      |> put_flash(:error, \"There was an error updating your cart\")\n      |> redirect(to: ~p\"/cart\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Schema Generation Command in Phoenix\nDESCRIPTION: Using the mix phx.gen.schema task to generate a User schema with name, email, bio, and number_of_pets fields, which creates both the schema file and a migration file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.schema User users name:string email:string \\\nbio:string number_of_pets:integer\n\n* creating ./lib/hello/user.ex\n* creating priv/repo/migrations/20170523151118_create_users.exs\n\nRemember to update your repository by running migrations:\n\n   $ mix ecto.migrate\n```\n\n----------------------------------------\n\nTITLE: Connecting to Authenticated Phoenix Socket (JavaScript)\nDESCRIPTION: Establishes a connection to the Phoenix socket using the authentication token and joins a channel. This code should be run on the client-side.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nlet socket = new Socket(\"/socket\", {authToken: window.userToken})\nsocket.connect()\n\nlet channel = socket.channel(\"topic:subtopic\", {})\nchannel.join()\n  .receive(\"ok\", resp => { console.log(\"Joined successfully\", resp) })\n  .receive(\"error\", resp => { console.log(\"Unable to join\", resp) })\n\nexport default socket\n```\n\n----------------------------------------\n\nTITLE: Setting Docker CMD for Phoenix Application\nDESCRIPTION: Configures the Docker container to run the Phoenix application server. This command assumes the application is installed in the /app directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_8\n\nLANGUAGE: dockerfile\nCODE:\n```\nCMD [\"/app/bin/server\"]\n```\n\n----------------------------------------\n\nTITLE: Rendering JSON Response in Elixir\nDESCRIPTION: A controller action that renders a JSON response using the json/2 function. It takes a messenger parameter and returns it as part of a JSON object.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndef show(conn, %{\"messenger\" => messenger}) do\n  json(conn, %{id: messenger})\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing API Token Creation and Verification in Elixir\nDESCRIPTION: Functions added to the Accounts context for creating and verifying API tokens. create_user_api_token/1 generates a new token, while fetch_user_by_api_token/1 retrieves a user by their token.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/api_authentication.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n  ## API\n\n  @doc \"\"\"\n  Creates a new api token for a user.\n\n  The token returned must be saved somewhere safe.\n  This token cannot be recovered from the database.\n  \"\"\"\n  def create_user_api_token(user) do\n    {encoded_token, user_token} = UserToken.build_email_token(user, \"api-token\")\n    Repo.insert!(user_token)\n    encoded_token\n  end\n\n  @doc \"\"\"\n  Fetches the user by API token.\n  \"\"\"\n  def fetch_user_by_api_token(token) do\n    with {:ok, query} <- UserToken.verify_api_token_query(token),\n         %User{} = user <- Repo.one(query) do\n      {:ok, user}\n    else\n      _ -> :error\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Implementing Price Calculation Functions in Phoenix\nDESCRIPTION: Adds functions to the ShoppingCart context for calculating total item price and total cart price. These functions handle Decimal arithmetic for accurate currency calculations.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndef total_item_price(%CartItem{} = item) do\n  Decimal.mult(item.product.price, item.quantity)\nend\n\ndef total_cart_price(%Cart{} = cart) do\n  Enum.reduce(cart.items, 0, fn item, acc ->\n    item\n    |> total_item_price()\n    |> Decimal.add(acc)\n  end)\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing API Authentication Plug in Elixir\nDESCRIPTION: Plug function added to the UserAuth module to authenticate API requests. It checks for a valid Bearer token in the Authorization header and assigns the current user scope.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/api_authentication.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndef fetch_current_scope_for_api_user(conn, _opts) do\n  with [<<bearer::binary-size(6), \" \", token::binary>>] <-\n         get_req_header(conn, \"authorization\"),\n       true <- String.downcase(bearer) == \"bearer\",\n       {:ok, user} <- Accounts.fetch_user_by_api_token(token) do\n    assign(conn, :current_scope, Scope.for_user(user))\n  else\n    _ ->\n      conn\n      |> send_resp(:unauthorized, \"No access for you\")\n      |> halt()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Changeset Errors in FallbackController (Elixir)\nDESCRIPTION: This snippet shows how the FallbackController handles changeset errors by setting the HTTP status to unprocessable entity and rendering the error using ChangesetJSON view.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do\n    conn\n    |> put_status(:unprocessable_entity)\n    |> put_view(json: HelloWeb.ChangesetJSON)\n    |> render(:error, changeset: changeset)\n  end\n```\n\n----------------------------------------\n\nTITLE: Defining Database Repository in Phoenix Application\nDESCRIPTION: Shows the definition of the Hello.Repo module, which serves as the main interface to the database in the Phoenix application, using Ecto with a Postgres adapter.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/directory_structure.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Repo do\n  use Ecto.Repo,\n    otp_app: :hello,\n    adapter: Ecto.Adapters.Postgres\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a New Route in Phoenix Router (Elixir)\nDESCRIPTION: This snippet shows how to add a new route to the Phoenix router, mapping a GET request to /hello to the index action of HelloController.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/\", HelloWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :home\n  get \"/hello\", HelloController, :index\nend\n```\n\n----------------------------------------\n\nTITLE: Verifying User Token in Phoenix UserSocket (Elixir)\nDESCRIPTION: Implements token verification in the UserSocket's connect function. This ensures that only authenticated users can establish WebSocket connections.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndef connect(_params_, socket, connect_info) do\n  # max_age: 1209600 is equivalent to two weeks in seconds\n  case Phoenix.Token.verify(socket, \"user socket\", connect_info[:auth_token], max_age: 1209600) do\n    {:ok, user_id} ->\n      {:ok, assign(socket, :current_user, user_id)}\n    {:error, reason} ->\n      :error\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Shopping Cart Context in Phoenix\nDESCRIPTION: Using the mix phx.gen.context generator to create a new ShoppingCart context with a Cart schema. The generator automatically includes user_id field due to the scope setup.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.context ShoppingCart Cart carts\n\n* creating lib/hello/shopping_cart/cart.ex\n* creating priv/repo/migrations/20250205203128_create_carts.exs\n* creating lib/hello/shopping_cart.ex\n* injecting lib/hello/shopping_cart.ex\n* creating test/hello/shopping_cart_test.exs\n* injecting test/hello/shopping_cart_test.exs\n* creating test/support/fixtures/shopping_cart_fixtures.ex\n* injecting test/support/fixtures/shopping_cart_fixtures.ex\n\nRemember to update your repository by running migrations:\n\n    $ mix ecto.migrate\n```\n\n----------------------------------------\n\nTITLE: Complete HelloController with Render in Elixir\nDESCRIPTION: A complete controller module showing how to use the render/3 function to render a template with assigns. This passes the messenger parameter to the template.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloController do\n  use HelloWeb, :controller\n\n  def show(conn, %{\"messenger\" => messenger}) do\n    render(conn, :show, messenger: messenger)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: DataCase Module Structure for Database Testing\nDESCRIPTION: This module provides test helpers for working with database-backed models, including SQL Sandbox setup for transaction isolation between tests.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.DataCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      alias Hello.Repo\n\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n      import Hello.DataCase\n    end\n  end\n\n  setup tags do\n    Hello.DataCase.setup_sandbox(tags)\n    :ok\n  end\n\n  def setup_sandbox(tags) do\n    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(Hello.Repo, shared: not tags[:async])\n    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)\n  end\n\n  def errors_on(changeset) do\n    ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Verified Routes with ~p Sigil\nDESCRIPTION: Demonstrating the verified routes feature that provides compile-time checking of router paths.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule RouteExample do\n  use HelloWeb, :verified_routes\n\n  def example do\n    ~p\"/comments\"\n    ~p\"/unknown/123\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Phoenix with Express on macOS/Ubuntu\nDESCRIPTION: A single command to download and set up a new Phoenix application on macOS or Ubuntu. This command installs Erlang, Elixir, Phoenix, and automatically configures a database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/up_and_running.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ curl https://new.phoenixframework.org/myapp | sh\n```\n\n----------------------------------------\n\nTITLE: Implementing Catalog Context in Phoenix\nDESCRIPTION: Context module providing the public API for product catalog functionality. Implements product listing functionality using Ecto.Repo.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Catalog do\n  @moduledoc \"\"\"\n  The Catalog context.\n  \"\"\"\n\n  import Ecto.Query, warn: false\n  alias Hello.Repo\n\n  alias Hello.Catalog.Product\n\n  @doc \"\"\"\n  Returns the list of products.\n\n  ## Examples\n\n      iex> list_products()\n      [%Product{}, ...]\n\n  \"\"\"\n  def list_products do\n    Repo.all(Product)\n  end\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Module Plug for Locale Management\nDESCRIPTION: This code defines a module plug that sets a locale based on URL parameters or falls back to a default. It implements the required init/1 and call/2 functions. The plug validates locales against an allowed list and assigns the locale to the connection.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Plugs.Locale do\n  import Plug.Conn\n\n  @locales [\"en\", \"fr\", \"de\"]\n\n  def init(default), do: default\n\n  def call(%Plug.Conn{params: %{\"locale\" => loc}} = conn, _default) when loc in @locales do\n    assign(conn, :locale, loc)\n  end\n\n  def call(conn, default) do\n    assign(conn, :locale, default)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Phoenix Server in Detached Production Mode\nDESCRIPTION: Command for starting a Phoenix server in detached production mode so it continues running even if the terminal is closed. This uses Erlang's detached flag to keep the server running in the background.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ PORT=4001 MIX_ENV=prod elixir --erl \"-detached\" -S mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Safe String Interpolation in HEEx\nDESCRIPTION: Example of how HEEx safely handles HTML content in string interpolation to prevent HTML injection.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_7\n\nLANGUAGE: heex\nCODE:\n```\n{\"<b>Bold?</b>\"}\n```\n\n----------------------------------------\n\nTITLE: Organizing Routes with Authentication in Phoenix Router\nDESCRIPTION: This example demonstrates how to organize routes based on authentication requirements, separating public and authenticated routes into different scopes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\npipeline :browser do\n  ...\nend\n\npipeline :auth do\n  plug HelloWeb.Authentication\nend\n\nscope \"/\" do\n  pipe_through [:browser]\n\n  get \"/reviews\", PostController, :index\n  get \"/reviews/:id\", PostController, :show\nend\n\nscope \"/\" do\n  pipe_through [:browser, :auth]\n\n  get \"/reviews/new\", PostController, :new\n  post \"/reviews\", PostController, :create\nend\n```\n\n----------------------------------------\n\nTITLE: Dockerfile for Phoenix Application Deployment\nDESCRIPTION: A multi-stage Dockerfile for building and deploying a Phoenix application as a container, optimized for production use.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_7\n\nLANGUAGE: Dockerfile\nCODE:\n```\n# Find eligible builder and runner images on Docker Hub. We use Ubuntu/Debian\n# instead of Alpine to avoid DNS resolution issues in production.\n#\n# https://hub.docker.com/r/hexpm/elixir/tags?page=1&name=ubuntu\n# https://hub.docker.com/_/ubuntu?tab=tags\n#\n# This file is based on these images:\n#\n#   - https://hub.docker.com/r/hexpm/elixir/tags - for the build image\n#   - https://hub.docker.com/_/debian?tab=tags&page=1&name=bullseye-20230612-slim - for the release image\n#   - https://pkgs.org/ - resource for finding needed packages\n#   - Ex: hexpm/elixir:1.15.8-erlang-25.3.2.15-debian-bookworm-20241016-slim\n#\nARG ELIXIR_VERSION=1.15.8\nARG OTP_VERSION=25.3.2.15\nARG DEBIAN_VERSION=bookworm-20241016-slim\n\nARG BUILDER_IMAGE=\"hexpm/elixir:${ELIXIR_VERSION}-erlang-${OTP_VERSION}-debian-${DEBIAN_VERSION}\"\nARG RUNNER_IMAGE=\"debian:${DEBIAN_VERSION}\"\n\nFROM ${BUILDER_IMAGE} AS builder\n\n# install build dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends build-essential git \\\n    && rm -rf /var/lib/apt/lists/*\n\n# prepare build dir\nWORKDIR /app\n\n# install hex + rebar\nRUN mix local.hex --force && \\\n    mix local.rebar --force\n\n# set build ENV\nENV MIX_ENV=\"prod\"\n\n# install mix dependencies\nCOPY mix.exs mix.lock ./\nRUN mix deps.get --only $MIX_ENV\nRUN mkdir config\n\n# copy compile-time config files before we compile dependencies\n# to ensure any relevant config change will trigger the dependencies\n# to be re-compiled.\nCOPY config/config.exs config/${MIX_ENV}.exs config/\nRUN mix deps.compile\n\nCOPY priv priv\n\nCOPY lib lib\n\nCOPY assets assets\n\n# compile assets\nRUN mix assets.deploy\n\n# Compile the release\nRUN mix compile\n\n# Changes to config/runtime.exs don't require recompiling the code\nCOPY config/runtime.exs config/\n\nCOPY rel rel\nRUN mix release\n\n# start a new build stage so that the final image will only contain\n# the compiled release and other runtime necessities\nFROM ${RUNNER_IMAGE}\n\nRUN apt-get update && \\\n  apt-get install -y --no-install-recommends libstdc++6 openssl libncurses5 locales ca-certificates \\\n  && rm -rf /var/lib/apt/lists/*\n\n# Set the locale\nRUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen\n\nENV LANG=en_US.UTF-8\nENV LANGUAGE=en_US:en\nENV LC_ALL=en_US.UTF-8\n\nWORKDIR \"/app\"\nRUN chown nobody /app\n\n# set runner ENV\nENV MIX_ENV=\"prod\"\n\n# Only copy the final release from the build stage\nCOPY --from=builder --chown=nobody:root /app/_build/${MIX_ENV}/rel/my_app ./\n\nUSER nobody\n\n# If using an environment that doesn't automatically reap zombie processes, it is\n# advised to add an init process such as tini via `apt-get install`\n# above and adding an entrypoint. See https://github.com/krallin/tini for details\n```\n\n----------------------------------------\n\nTITLE: Defining Database Migration in Ecto\nDESCRIPTION: An Ecto migration that creates a users table with name, email, bio, and number_of_pets columns, along with automatic timestamp columns for tracking record creation and updates.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Repo.Migrations.CreateUsers do\n  use Ecto.Migration\n\n  def change do\n    create table(:users) do\n      add :name, :string\n      add :email, :string\n      add :bio, :string\n      add :number_of_pets, :integer\n\n      timestamps()\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Forcing SSL with X-Forwarded-Proto Header\nDESCRIPTION: Configuration for forcing all requests to use SSL by redirecting HTTP to HTTPS, using the X-Forwarded-Proto header to detect the protocol when behind a reverse proxy.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/using_ssl.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, MyAppWeb.Endpoint,\n  force_ssl: [rewrite_on: [:x_forwarded_proto]]\n```\n\n----------------------------------------\n\nTITLE: Configuring LiveView Routes in Phoenix Router\nDESCRIPTION: Shows how to set up a route for a LiveView in a Phoenix router. This connects the LiveView module to a specific URL path, making it accessible via browser requests.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/live_view.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.Router do\n  use MyAppWeb, :router\n\n  pipeline :browser do\n    ...\n  end\n\n  scope \"/\", MyAppWeb do\n    pipe_through :browser\n    ...\n\n    live \"/thermostat\", ThermostatLive\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Create Action in PostController\nDESCRIPTION: Implementation of the create action in a Phoenix controller that handles form submission with success and error paths for post creation.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndef create(conn, %{\"post\" => post_params}) do\n  case Blog.create_post(post_params) do\n    {:ok, post} ->\n      conn\n      |> put_flash(:info, \"Post created successfully.\")\n      |> redirect(to: ~p\"/posts/#{post}\")\n\n    {:error, %Ecto.Changeset{} = changeset} ->\n      render(conn, :new, changeset: changeset)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Presence with JavaScript Client\nDESCRIPTION: JavaScript implementation that connects to the Phoenix channel and handles presence events. It renders a list of online users with their connection counts whenever the presence state changes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Socket, Presence} from \"phoenix\"\n\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}})\nlet channel = socket.channel(\"room:lobby\", {name: window.location.search.split(\"=\")[1]})\nlet presence = new Presence(channel)\n\nfunction renderOnlineUsers(presence) {\n  let response = \"\"\n\n  presence.list((id, {metas: [first, ...rest]}) => {\n    let count = rest.length + 1\n    response += `<br>${id} (count: ${count})</br>`\n  })\n\n  document.querySelector(\"main\").innerHTML = response\n}\n\nsocket.connect()\n\npresence.onSync(() => renderOnlineUsers(presence))\n\nchannel.join()\n```\n\n----------------------------------------\n\nTITLE: Starting Phoenix Server with Generated Authentication System\nDESCRIPTION: Command to start the Phoenix server after generating the authentication system, allowing testing of new features.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/mix_phx_gen_auth.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Querying Users with Ecto in Elixir\nDESCRIPTION: Shows how to fetch all users from the database using Ecto's Repo.all/1 function. It demonstrates the SQL query generated and the returned results in the form of User structs.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\niex> Repo.all(User)\n[debug] QUERY OK source=\"users\" db=5.8ms queue=1.4ms idle=1672.0ms\nSELECT u0.\"id\", u0.\"bio\", u0.\"email\", u0.\"name\", u0.\"number_of_pets\", u0.\"inserted_at\", u0.\"updated_at\" FROM \"users\" AS u0 []\n[\n  %Hello.User{\n    __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">,\n    bio: nil,\n    email: \"user1@example.com\",\n    id: 1,\n    inserted_at: ~N[2021-02-25 01:58:55],\n    name: nil,\n    number_of_pets: nil,\n    updated_at: ~N[2021-02-25 01:58:55]\n  },\n  %Hello.User{\n    __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">,\n    bio: nil,\n    email: \"user2@example.com\",\n    id: 2,\n    inserted_at: ~N[2021-02-25 02:03:28],\n    name: nil,\n    number_of_pets: nil,\n    updated_at: ~N[2021-02-25 02:03:28]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing LiveView for Online Users in Elixir\nDESCRIPTION: Creates a LiveView module (HelloWeb.OnlineLive) to display and update the list of online users in real-time using Phoenix Presence.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.OnlineLive do\n  use HelloWeb, :live_view\n\n  def mount(params, _session, socket) do\n    socket = stream(socket, :presences, [])\n    socket =\n    if connected?(socket) do\n      HelloWeb.Presence.track_user(params[\"name\"], %{id: params[\"name\"]})\n      HelloWeb.Presence.subscribe()\n      stream(socket, :presences, HelloWeb.Presence.list_online_users())\n    else\n       socket\n    end\n\n    {:ok, socket}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <ul id=\"online_users\" phx-update=\"stream\">\n      <li :for={{dom_id, %{id: id, metas: metas}} <- @streams.presences} id={dom_id}>{id} ({length(metas)})</li>\n    </ul>\n    \"\"\"\n  end\n\n  def handle_info({HelloWeb.Presence, {:join, presence}}, socket) do\n    {:noreply, stream_insert(socket, :presences, presence)}\n  end\n\n  def handle_info({HelloWeb.Presence, {:leave, presence}}, socket) do\n    if presence.metas == [] do\n      {:noreply, stream_delete(socket, :presences, presence)}\n    else\n      {:noreply, stream_insert(socket, :presences, presence)}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Ecto Repo in Phoenix\nDESCRIPTION: Definition of the Hello.Repo module that uses Ecto.Repo with the PostgreSQL adapter, serving as the foundation for database operations in the Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Repo do\n  use Ecto.Repo,\n    otp_app: :hello,\n    adapter: Ecto.Adapters.Postgres\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Category Context in Phoenix\nDESCRIPTION: Creates a new Category context within the existing Catalog context using Phoenix generator commands. Generates schema, migration, and context functions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.context Catalog Category categories \\\ntitle:string:unique --no-scope\n```\n\n----------------------------------------\n\nTITLE: Implementing Presence in RoomChannel\nDESCRIPTION: Complete implementation of a RoomChannel that tracks user presence. It handles the join event, tracks users after joining, and pushes presence state to clients.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.RoomChannel do\n  use Phoenix.Channel\n  alias HelloWeb.Presence\n\n  def join(\"room:lobby\", %{\"name\" => name}, socket) do\n    send(self(), :after_join)\n    {:ok, assign(socket, :name, name)}\n  end\n\n  def handle_info(:after_join, socket) do\n    {:ok, _} =\n      Presence.track(socket, socket.assigns.name, %{\n        online_at: inspect(System.system_time(:second))\n      })\n\n    push(socket, \"presence_state\", Presence.list(socket))\n    {:noreply, socket}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Nested API Versioning with Scopes\nDESCRIPTION: Shows how to implement versioned API routes using nested scopes, with proper namespacing and alias prefixing.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/api\", HelloWeb.Api, as: :api do\n  pipe_through :api\n\n  scope \"/v1\", V1, as: :v1 do\n    resources \"/images\",  ImageController\n    resources \"/reviews\", ReviewController\n    resources \"/users\",   UserController\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Join Logic (Elixir)\nDESCRIPTION: Defines join logic for the RoomChannel, allowing connections to the lobby and rejecting unauthorized access to private rooms.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.RoomChannel do\n  use Phoenix.Channel\n\n  def join(\"room:lobby\", _message, socket) do\n    {:ok, socket}\n  end\n\n  def join(\"room:\" <> _private_room_id, _params, _socket) do\n    {:error, %{reason: \"unauthorized\"}}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Basic Phoenix Tests\nDESCRIPTION: Example of running Phoenix tests using mix test command showing test execution output\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix test\n....\n\nFinished in 0.09 seconds\n5 tests, 0 failures\n\nRandomized with seed 652656\n```\n\n----------------------------------------\n\nTITLE: Creating Chat UI Elements (HEEX)\nDESCRIPTION: Defines the HTML structure for the chat interface, including a messages container and input field.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_9\n\nLANGUAGE: heex\nCODE:\n```\n<div id=\"messages\" role=\"log\" aria-live=\"polite\"></div>\n<input id=\"chat-input\" type=\"text\">\n```\n\n----------------------------------------\n\nTITLE: Defining ChannelCase for Phoenix Channel Testing\nDESCRIPTION: Defines a ChannelCase module that sets up a case template for testing channels. It imports Phoenix.ChannelTest and sets up the SQL Sandbox for testing.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ChannelCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with channels\n      import Phoenix.ChannelTest\n      import HelloWeb.ChannelCase\n\n      # The default endpoint for testing\n      @endpoint HelloWeb.Endpoint\n    end\n  end\n\n  setup _tags do\n    Hello.DataCase.setup_sandbox(tags)\n    :ok\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Phoenix Application in Elixir\nDESCRIPTION: This snippet defines the configuration for a Phoenix application. It sets up the application name, ecto repos, and generators. It also configures the HTTP endpoint and database connection.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_umbrella/README.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# <%= @root_app_module %>\n```\n\n----------------------------------------\n\nTITLE: Combining Forward with Pipelines in Phoenix Router\nDESCRIPTION: This example demonstrates how to combine the forward macro with authentication pipelines to secure access to forwarded routes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  ...\n\n  scope \"/\" do\n    pipe_through [:authenticate_user, :ensure_admin]\n    forward \"/jobs\", BackgroundJob.Plug\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Establishing Socket Connection in JavaScript Client\nDESCRIPTION: Example of how to create a socket connection from a JavaScript client to a Phoenix server. This establishes the base connection before joining specific channels.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}})\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Assigns Directly to Render in Elixir\nDESCRIPTION: A controller action that passes multiple assigns directly to the render/3 function as a keyword list. This is an alternative to using the pipe operator with assign/3.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n  def show(conn, %{\"messenger\" => messenger}) do\n    render(conn, :show, messenger: messenger, receiver: \"Dweezil\")\n  end\n```\n\n----------------------------------------\n\nTITLE: Testing Index Action with ConnTest\nDESCRIPTION: Test for the index action that verifies a successful HTML response containing expected content using Phoenix.ConnTest helpers.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndescribe \"index\" do\n  test \"lists all posts\", %{conn: conn} do\n    conn = get(conn, ~p\"/posts\")\n    assert html_response(conn, 200) =~ \"Listing Posts\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Phoenix Router Structure\nDESCRIPTION: The default router configuration in a Phoenix application, showing pipeline definitions and a basic route.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {HelloWeb.Layouts, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  scope \"/\", HelloWeb do\n    pipe_through :browser\n\n    get \"/\", PageController, :home\n  end\n\n  # Other scopes may use custom stacks.\n  # scope \"/api\", HelloWeb do\n  #   pipe_through :api\n  # end\n\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Controller with Parameter Pattern Matching in Elixir\nDESCRIPTION: A controller action that demonstrates pattern matching on parameters to extract specific values. This example extracts a messenger parameter from the request params.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloController do\n  ...\n\n  def show(conn, %{\"messenger\" => messenger}) do\n    render(conn, :show, messenger: messenger)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing LiveView JavaScript Client\nDESCRIPTION: The required JavaScript configuration to connect LiveView clients to the server. This code establishes the WebSocket connection and ensures CSRF protection for all LiveView interactions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/live_view.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Socket} from \"phoenix\"\nimport {LiveSocket} from \"phoenix_live_view\"\n\nlet csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\")\nlet liveSocket = new LiveSocket(\"/live\", Socket, {params: {_csrf_token: csrfToken}})\nliveSocket.connect()\n```\n\n----------------------------------------\n\nTITLE: Adding a Plug to a Phoenix Controller\nDESCRIPTION: This code shows how to add a plug directly to a Phoenix controller. The Locale plug is added to the controller and will run for all actions in that controller.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageController do\n  use HelloWeb, :controller\n\n  plug HelloWeb.Plugs.Locale, \"en\"\n```\n\n----------------------------------------\n\nTITLE: Implementing User Scope in Elixir\nDESCRIPTION: Definition of the Accounts.Scope module that helps tie generated resources to users. This module creates a struct with a user field and provides a function to create a scope for a specific user.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Accounts.Scope do\n  ...\n  alias Hello.Accounts.User\n\n  defstruct user: nil\n\n  @doc \"\"\"\n  Creates a scope for the given user.\n\n  Returns nil if no user is given.\n  \"\"\"\n  def for_user(%User{} = user) do\n    %__MODULE__{user: user}\n  end\n\n  def for_user(nil), do: nil\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback Controller\nDESCRIPTION: Fallback controller for centralized error handling in Phoenix APIs\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.MyFallbackController do\n  use Phoenix.Controller\n\n  def call(conn, {:error, :not_found}) do\n    conn\n    |> put_status(:not_found)\n    |> put_view(json: HelloWeb.ErrorJSON)\n    |> render(:\"404\")\n  end\n\n  def call(conn, {:error, :unauthorized}) do\n    conn\n    |> put_status(403)\n    |> put_view(json: HelloWeb.ErrorJSON)\n    |> render(:\"403\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring API Routes in Phoenix Router\nDESCRIPTION: Setting up API routes in the router with appropriate scope and pipeline\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/api\", HelloWeb do\n  pipe_through :api\n  resources \"/urls\", UrlController, except: [:new, :edit]\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Table in Ecto Migration\nDESCRIPTION: Demonstrates how to implement the change/0 function to create a comments table with body, word_count, and timestamp columns using Ecto's migration DSL.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\n...\ndef change do\n  create table(:comments) do\n    add :body, :string\n    add :word_count, :integer\n    timestamps()\n  end\nend\n...\n```\n\n----------------------------------------\n\nTITLE: Installing Phoenix Application Generator\nDESCRIPTION: Command to install the Phoenix application generator using Mix, Elixir's build tool. This enables the creation of new Phoenix applications using the phx.new generator.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/installation.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix archive.install hex phx_new\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Interface for Product Catalog in Phoenix\nDESCRIPTION: Using the mix phx.gen.html generator to create the Catalog context with a Product schema, including controllers, templates and tests. The command specifies the schema fields with their types.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.html Catalog Product products title:string \\\ndescription:string price:decimal views:integer\n\n* creating lib/hello_web/controllers/product_controller.ex\n* creating lib/hello_web/controllers/product_html/edit.html.heex\n* creating lib/hello_web/controllers/product_html/index.html.heex\n* creating lib/hello_web/controllers/product_html/new.html.heex\n* creating lib/hello_web/controllers/product_html/show.html.heex\n* creating lib/hello_web/controllers/product_html/product_form.html.heex\n* creating lib/hello_web/controllers/product_html.ex\n* creating test/hello_web/controllers/product_controller_test.exs\n* creating lib/hello/catalog/product.ex\n* creating priv/repo/migrations/20250201185747_create_products.exs\n* creating lib/hello/catalog.ex\n* injecting lib/hello/catalog.ex\n* creating test/hello/catalog_test.exs\n* injecting test/hello/catalog_test.exs\n* creating test/support/fixtures/catalog_fixtures.ex\n* injecting test/support/fixtures/catalog_fixtures.ex\n\nAdd the resource to your browser scope in lib/hello_web/router.ex:\n\n    resources \"/products\", ProductController\n\nRemember to update your repository by running migrations:\n\n    $ mix ecto.migrate\n```\n\n----------------------------------------\n\nTITLE: Generating JSON API Structure with Phoenix\nDESCRIPTION: Using Phoenix generator to scaffold JSON API infrastructure for URL management\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nmix phx.gen.json Urls Url urls link:string title:string\n```\n\n----------------------------------------\n\nTITLE: Modifying the Product Migration in Phoenix\nDESCRIPTION: Customizing the generated migration file to add precision and constraints to the database columns. The changes include setting precision for the price decimal field and adding a default value with not-null constraint for views.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n  def change do\n    create table(:products) do\n      add :title, :string\n      add :description, :string\n-     add :price, :decimal\n+     add :price, :decimal, precision: 15, scale: 6, null: false\n-     add :views, :integer\n+     add :views, :integer, default: 0, null: false\n\n      timestamps()\n    end\n```\n\n----------------------------------------\n\nTITLE: Defining Scope Module for Authentication in Phoenix\nDESCRIPTION: Elixir code defining a Scope module for authentication, used to create scopes for users and store metadata.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/mix_phx_gen_auth.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.Scope do\n  # ...\n  alias MyApp.Accounts.User\n\n  defstruct user: nil\n\n  @doc \"\"\"\n  Creates a scope for the given user.\n\n  Returns nil if no user is given.\n  \"\"\"\n  def for_user(%User{} = user) do\n    %__MODULE__{user: user}\n  end\n\n  def for_user(nil), do: nil\nend\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Component in a HEEx Template\nDESCRIPTION: Updated template that uses the custom greet component, showing how to pass attributes to the component.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_4\n\nLANGUAGE: heex\nCODE:\n```\n<Layouts.app flash={@flash}>\n  <section>\n    <.greet messenger={@messenger} />\n  </section>\n</Layouts.app>\n```\n\n----------------------------------------\n\nTITLE: Updating Cart Schema Associations in Phoenix\nDESCRIPTION: This snippet shows the changes made to the cart schema in lib/hello/shopping_cart/cart.ex to associate a cart with its items and user.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n  schema \"carts\" do\n-   field :user_id, :id\n+   belongs_to :user, Hello.Accounts.User\n+   has_many :items, Hello.ShoppingCart.CartItem\n\n    timestamps()\n  end\n```\n\n----------------------------------------\n\nTITLE: Defining Browser and API Pipelines in Phoenix Router\nDESCRIPTION: This snippet shows the basic structure of a Phoenix router with browser and API pipelines defined. It includes route definitions for both web pages and API endpoints.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {HelloWeb.Layouts, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  scope \"/\", HelloWeb do\n    pipe_through :browser\n\n    get \"/\", PageController, :home\n  end\n\n  # Other scopes may use custom stacks.\n  scope \"/api\", HelloWeb do\n    pipe_through :api\n\n    resources \"/reviews\", ReviewController\n  end\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Index Action for JSON Controller in Phoenix\nDESCRIPTION: Elixir function implementing the index action for a JSON controller, fetching and rendering articles.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndef index(conn, _params) do\n  articles = News.list_articles()\n  render(conn, :index, articles: articles)\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling auth_token in Phoenix Endpoint (Elixir)\nDESCRIPTION: Configures the Phoenix Endpoint to enable token-based authentication for WebSocket connections. This is the first step in implementing token authentication for channels.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :hello\n\n  socket \"/socket\", HelloWeb.UserSocket,\n    websocket: true,\n    longpoll: false,\n    auth_token: true\n\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Adding a Module Plug to Phoenix Router\nDESCRIPTION: This code demonstrates how to add a module plug to a Phoenix router pipeline. The Locale plug is added to the :browser pipeline with a default value of \"en\" which will be used when no locale is specified in the request parameters.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {HelloWeb.LayoutView, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n    plug HelloWeb.Plugs.Locale, \"en\"\n  end\n  ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Views in Phoenix\nDESCRIPTION: Default implementation of ErrorHTML and ErrorJSON views for handling HTML and JSON error responses in Phoenix applications. Includes customizable render functions for different status codes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ErrorHTML do\n  use HelloWeb, :html\n\n  # If you want to customize your error pages,\n  # uncomment the embed_templates/1 call below\n  # and add pages to the error directory:\n  #\n  #   * lib/<%= @lib_web_name %>/controllers/error_html/404.html.heex\n  #   * lib/<%= @lib_web_name %>/controllers/error_html/500.html.heex\n  #\n  # embed_templates \"error_html/*\"\n\n  # The default is to render a plain text page based on\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def render(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend\n\ndefmodule HelloWeb.ErrorJSON do\n  # If you want to customize a particular status code,\n  # you may add your own clauses, such as:\n  #\n  # def render(\"500.json\", _assigns) do\n  #   %{errors: %{detail: \"Internal Server Error\"}}\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.json\" becomes\n  # \"Not Found\".\n  def render(template, _assigns) do\n    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Shorthand Conditional Rendering in HEEx\nDESCRIPTION: Example of the shorthand :if attribute for conditional rendering in HEEx templates, providing a more concise syntax.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_12\n\nLANGUAGE: heex\nCODE:\n```\n<div :if={@some_condition}>...</div>\n```\n\n----------------------------------------\n\nTITLE: Defining URL Changeset for Validation (Elixir)\nDESCRIPTION: This snippet shows the changeset function for the URL schema, which casts and validates the 'link' and 'title' attributes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n  @doc false\n  def changeset(url, attrs) do\n    url\n    |> cast(attrs, [:link, :title])\n    |> validate_required([:link, :title])\n  end\n```\n\n----------------------------------------\n\nTITLE: Using Action Fallback in Controller\nDESCRIPTION: Implementing controller with action fallback for simplified error handling\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.MyController do\n  use Phoenix.Controller\n\n  action_fallback HelloWeb.MyFallbackController\n\n  def show(conn, %{\"id\" => id}, current_user) do\n    with {:ok, post} <- fetch_post(id),\n         :ok <- authorize_user(current_user, :view, post) do\n      render(conn, :show, post: post)\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Cart Plug to Browser Pipeline in Phoenix Router\nDESCRIPTION: This snippet adds a new plug to fetch or create a cart for authenticated users in the browser pipeline of the Phoenix router.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {HelloWeb.LayoutView, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n    plug :fetch_current_scope_for_user\n+   plug :fetch_current_cart\n  end\n\n+ alias Hello.ShoppingCart\n+\n+ defp fetch_current_cart(%{assigns: %{current_scope: scope}} = conn, _opts) when not is_nil(scope) do\n+   if cart = ShoppingCart.get_cart(scope) do\n+     assign(conn, :cart, cart)\n+   else\n+     {:ok, new_cart} = ShoppingCart.create_cart(scope)\n+     assign(conn, :cart, new_cart)\n+   end\n+ end\n+\n+ defp fetch_current_cart(conn, _opts), do: conn\n```\n\n----------------------------------------\n\nTITLE: Initializing Socket Connection and Joining Channel (JavaScript)\nDESCRIPTION: Sets up the client-side socket connection and joins the lobby channel using the Phoenix JavaScript library.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nsocket.connect()\n\n// Now that you are connected, you can join channels with a topic:\nlet channel = socket.channel(\"room:lobby\", {})\nchannel.join()\n  .receive(\"ok\", resp => { console.log(\"Joined successfully\", resp) })\n  .receive(\"error\", resp => { console.log(\"Unable to join\", resp) })\n\nexport default socket\n```\n\n----------------------------------------\n\nTITLE: Implementing Telemetry Supervisor in Phoenix (Elixir)\nDESCRIPTION: Create a Telemetry supervisor module to manage Telemetry processes and define metrics for the application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/my_app_web/telemetry.ex\ndefmodule MyAppWeb.Telemetry do\n  use Supervisor\n  import Telemetry.Metrics\n\n  def start_link(arg) do\n    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)\n  end\n\n  def init(_arg) do\n    children = [\n      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}\n      # Add reporters as children of your supervision tree.\n      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\n\n  def metrics do\n    [\n      # Phoenix Metrics\n      summary(\"phoenix.endpoint.stop.duration\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.router_dispatch.stop.duration\",\n        tags: [:route],\n        unit: {:native, :millisecond}\n      ),\n      # VM Metrics\n      summary(\"vm.memory.total\", unit: {:byte, :kilobyte}),\n      summary(\"vm.total_run_queue_lengths.total\"),\n      summary(\"vm.total_run_queue_lengths.cpu\"),\n      summary(\"vm.total_run_queue_lengths.io\")\n    ]\n  end\n\n  defp periodic_measurements do\n    [\n      # A module, function and arguments to be invoked periodically.\n      # This function must call :telemetry.execute/3 and a metric must be added above.\n      # {MyApp, :count_users, []}\n    ]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Cart Controller in Phoenix\nDESCRIPTION: Defines a new CartController module with a show action to render the cart view. It uses the ShoppingCart context to generate a changeset for the cart.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.CartController do\n  use HelloWeb, :controller\n\n  alias Hello.ShoppingCart\n\n  def show(conn, _params) do\n    render(conn, :show, changeset: ShoppingCart.change_cart(conn.assigns.current_scope, conn.assigns.cart))\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering Changeset Errors as JSON (Elixir)\nDESCRIPTION: This snippet defines the ChangesetJSON module which renders changeset errors by traversing the errors and converting them to a JSON-friendly format.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ChangesetJSON do\n  @doc \"\"\"\n  Renders changeset errors.\n  \"\"\"\n  def error(%{changeset: changeset}) do\n    # When encoded, the changeset returns its errors\n    # as a JSON object. So we just pass it forward.\n    %{errors: Ecto.Changeset.traverse_errors(changeset, &translate_error/1)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Cart Routes to Phoenix Router\nDESCRIPTION: This snippet adds new routes for cart and cart item operations to the Phoenix router, requiring authenticated users.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_9\n\nLANGUAGE: diff\nCODE:\n```\n   scope \"/\", HelloWeb do\n     pipe_through :browser\n\n     get \"/\", PageController, :index\n     resources \"/products\", ProductController\n   end\n\n+  scope \"/\", HelloWeb do\n+    pipe_through [:browser, :require_authenticated_user]\n+\n+    resources \"/cart_items\", CartItemController, only: [:create, :delete]\n+\n+    get \"/cart\", CartController, :show\n+    put \"/cart\", CartController, :update\n+  end\n```\n\n----------------------------------------\n\nTITLE: Schema Changeset with Validations\nDESCRIPTION: Ecto changeset function that defines validations for a post schema, including required fields and minimum length constraints.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndef changeset(post, attrs) do\n  post\n  |> cast(attrs, [:title, :body])\n  |> validate_required([:title, :body])\n  |> validate_length(:title, min: 2)\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Database Queries\nDESCRIPTION: Example of implementing database queries that respect user scope\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/my_app/blog.ex\ndef list_posts(%Scope{} = scope) do\n  Repo.all(from post in Post, where: post.user_id == ^scope.user.id)\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback Controller in Phoenix\nDESCRIPTION: Elixir module implementing a fallback controller to handle error cases for JSON responses in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.FallbackController do\n  use HelloWeb, :controller\n\n  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do\n    conn\n    |> put_status(:unprocessable_entity)\n    |> put_view(json: HelloWeb.ChangesetJSON)\n    |> render(:error, changeset: changeset)\n  end\n\n  def call(conn, {:error, :not_found}) do\n    conn\n    |> put_status(:not_found)\n    |> put_view(html: HelloWeb.ErrorHTML, json: HelloWeb.ErrorJSON)\n    |> render(:\"404\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Phoenix Release Configuration\nDESCRIPTION: Using the Phoenix release generator to create the necessary scripts and configuration for deploying the application as a release.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.release\n==> my_app\n* creating rel/overlays/bin/server\n* creating rel/overlays/bin/server.bat\n* creating rel/overlays/bin/migrate\n* creating rel/overlays/bin/migrate.bat\n* creating lib/my_app/release.ex\n\nYour application is ready to be deployed in a release!\n\n    # To start your system\n    _build/dev/rel/my_app/bin/my_app start\n\n    # To start your system with the Phoenix server running\n    _build/dev/rel/my_app/bin/server\n\n    # To run migrations\n    _build/dev/rel/my_app/bin/migrate\n\nOnce the release is running:\n\n    # To connect to it remotely\n    _build/dev/rel/my_app/bin/my_app remote\n\n    # To stop it gracefully (you may also send SIGINT/SIGTERM)\n    _build/dev/rel/my_app/bin/my_app stop\n\nTo list all commands:\n\n    _build/dev/rel/my_app/bin/my_app\n```\n\n----------------------------------------\n\nTITLE: Configuring Socket Endpoints in Phoenix\nDESCRIPTION: Example of how to configure socket connections in a Phoenix application's Endpoint module. This snippet enables WebSocket connections while disabling long polling.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nsocket \"/socket\", HelloWeb.UserSocket,\n  websocket: true,\n  longpoll: false\n```\n\n----------------------------------------\n\nTITLE: Implementing Scope Fetch Plug\nDESCRIPTION: Browser pipeline configuration and plug implementation for fetching current user scope\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# route.ex\n...\npipeline :browser do\n  ...\n  plug :fetch_current_scope_for_user\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\n# user_auth.ex\ndef fetch_current_scope_for_user(conn, _opts) do\n  {user_token, conn} = ensure_user_token(conn)\n  user = user_token && Accounts.get_user_by_session_token(user_token)\n  assign(conn, :current_scope, Scope.for_user(user))\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Presence Helper Functions in Elixir\nDESCRIPTION: Defines helper functions in the HelloWeb.Presence module to list online users, track users, and subscribe to presence events.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n  def list_online_users(), do: list(\"online_users\") |> Enum.map(fn {_id, presence} -> presence end)\n\n  def track_user(name, params), do: track(self(), \"online_users\", name, params)\n\n  def subscribe(), do: Phoenix.PubSub.subscribe(Hello.PubSub, \"proxy:online_users\")\n```\n\n----------------------------------------\n\nTITLE: Handling Incoming Messages in Channel (Elixir)\nDESCRIPTION: Implements the handle_in callback in the RoomChannel to process incoming messages and broadcast them to all subscribers.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.RoomChannel do\n  use Phoenix.Channel\n\n  def join(\"room:lobby\", _message, socket) do\n    {:ok, socket}\n  end\n\n  def join(\"room:\" <> _private_room_id, _params, _socket) do\n    {:error, %{reason: \"unauthorized\"}}\n  end\n\n  def handle_in(\"new_msg\", %{\"body\" => body}, socket) do\n    broadcast!(socket, \"new_msg\", %{body: body})\n    {:noreply, socket}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Full URLs from Verified Routes in Elixir\nDESCRIPTION: Shows how to generate a full URL from a verified route using the url/1 function in Phoenix Framework. This function uses configuration parameters to construct the complete URL.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nurl(~p\"/users\")\n\"http://localhost:4000/users\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Upload Parser in Endpoint\nDESCRIPTION: Shows the configuration of Plug.Parsers in the Phoenix endpoint for handling file uploads.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/hello_web/endpoint.ex\nplug Plug.Parsers,\n  parsers: [:urlencoded, :multipart, :json],\n  pass: [\"*/*\"],\n  json_decoder: Phoenix.json_library()\n```\n\n----------------------------------------\n\nTITLE: Standard Conditional Rendering in HEEx\nDESCRIPTION: Example of the standard syntax for conditional rendering in HEEx templates using if blocks.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_11\n\nLANGUAGE: heex\nCODE:\n```\n<%= if @some_condition do %>\n  <div>...</div>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Adding API Authentication Plug to Router Pipeline in Elixir\nDESCRIPTION: Update to the API pipeline in the router to include the new API authentication plug.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/api_authentication.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n  pipeline :api do\n    plug :accepts, [\"json\"]\n    plug :fetch_current_scope_for_api_user\n  end\n```\n\n----------------------------------------\n\nTITLE: Setting Flash Messages with Redirect in Phoenix Controller (Elixir)\nDESCRIPTION: This snippet demonstrates how to set a flash message and perform a redirect in a Phoenix controller action. It sets an error message and redirects to a specific path.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\n  def home(conn, _params) do\n    conn\n    |> put_flash(:error, \"Let's pretend we have an error.\")\n    |> redirect(to: ~p\"/redirect_test\")\n  end\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Function Component in Phoenix\nDESCRIPTION: Full example of defining a custom function component that accepts attributes and renders a HEEx template with validation of required attributes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloHTML do\n  use HelloWeb, :html\n\n  embed_templates \"hello_html/*\"\n\n  attr :messenger, :string, required: true\n\n  def greet(assigns) do\n    ~H\"\"\"\n    <h2>Hello World, from {@messenger}!</h2>\n    \"\"\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Multiple Resources in Admin Scope\nDESCRIPTION: Demonstrates how to group multiple admin resources (images, reviews, users) under a single admin scope with proper namespacing.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/admin\", HelloWeb.Admin do\n  pipe_through :browser\n\n  resources \"/images\",  ImageController\n  resources \"/reviews\", ReviewController\n  resources \"/users\",   UserController\nend\n```\n\n----------------------------------------\n\nTITLE: Setting up Phoenix Channel Test\nDESCRIPTION: Sets up a test environment for a Phoenix Channel by creating a socket, subscribing to a channel, and joining it. Returns the socket for use in individual tests.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nsetup do\n  {:ok, _, socket} =\n    HelloWeb.UserSocket\n    |> socket(\"user_id\", %{some: :assign})\n    |> subscribe_and_join(HelloWeb.RoomChannel, \"room:lobby\")\n\n  %{socket: socket}\nend\n```\n\n----------------------------------------\n\nTITLE: Basic HEEx Template Structure in Phoenix\nDESCRIPTION: Example of a simple HEEx template that uses a layout component and displays a dynamic message from the assigns.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_0\n\nLANGUAGE: heex\nCODE:\n```\n<Layouts.app flash={@flash}>\n  <section>\n    <h2>Hello World, from {@messenger}!</h2>\n  </section>\n</Layouts.app>\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Migration Module for Phoenix Release\nDESCRIPTION: An Elixir module for running database migrations in a Phoenix release environment without depending on Mix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Release do\n  @app :my_app\n\n  def migrate do\n    load_app()\n\n    for repo <- repos() do\n      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))\n    end\n  end\n\n  def rollback(repo, version) do\n    load_app()\n    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))\n  end\n\n  defp repos do\n    Application.fetch_env!(@app, :ecto_repos)\n  end\n\n  defp load_app do\n    Application.ensure_loaded(@app)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Assigning User Token in Phoenix Connection (Elixir)\nDESCRIPTION: Implements a plug to assign a user token to the connection when a user is authenticated. This token will be used for channel authentication.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\npipeline :browser do\n  ...\n  plug OurAuth\n  plug :put_user_token\nend\n\ndefp put_user_token(conn, _) do\n  if current_user = conn.assigns[:current_user] do\n    token = Phoenix.Token.sign(conn, \"user socket\", current_user.id)\n    assign(conn, :user_token, token)\n  else\n    conn\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Phoenix Presence Module\nDESCRIPTION: Configuration code for the Phoenix Presence module, specifying the OTP app and PubSub server. This sets up the basic functionality for the Presence tracking system.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nuse Phoenix.Presence,\n  otp_app: :hello,\n  pubsub_server: Hello.PubSub\n```\n\n----------------------------------------\n\nTITLE: Defining Phoenix Endpoint Structure in Elixir\nDESCRIPTION: Shows the basic structure of a Phoenix endpoint, illustrating the use of various plugs for request processing.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :hello\n\n  plug Plug.Static, ...\n  plug Plug.RequestId\n  plug Plug.Telemetry, ...\n  plug Plug.Parsers, ...\n  plug Plug.MethodOverride\n  plug Plug.Head\n  plug Plug.Session, ...\n  plug HelloWeb.Router\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Phoenix Application Services in Elixir\nDESCRIPTION: Shows the definition of services that are part of the Phoenix application, including the database repository, PubSub system, and application endpoint.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/directory_structure.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nchildren = [\n  HelloWeb.Telemetry,\n  Hello.Repo,\n  {Phoenix.PubSub, name: Hello.PubSub},\n  HelloWeb.Endpoint\n]\n```\n\n----------------------------------------\n\nTITLE: Phoenix Error View Test\nDESCRIPTION: Example of testing Phoenix error views with async capability\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ErrorHTMLTest do\n  use HelloWeb.ConnCase, async: true\n\n  # Bring render_to_string/4 for testing custom views\n  import Phoenix.Template\n\n  test \"renders 404.html\" do\n    assert render_to_string(HelloWeb.ErrorHTML, \"404\", \"html\", []) == \"Not Found\"\n  end\n\n  test \"renders 500.html\" do\n    assert render_to_string(HelloWeb.ErrorHTML, \"500\", \"html\", []) == \"Internal Server Error\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Product Schema in Phoenix\nDESCRIPTION: Ecto schema definition for products with changeset validation logic. Defines database structure and validation rules for product entities.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Catalog.Product do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"products\" do\n    field :description, :string\n    field :price, :decimal\n    field :title, :string\n    field :views, :integer\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(product, attrs) do\n    product\n    |> cast(attrs, [:title, :description, :price, :views])\n    |> validate_required([:title, :description, :price, :views])\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Exception Definition in Phoenix\nDESCRIPTION: Implementation of a custom exception using defexception macro with optional message field\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.SomethingNotFoundError do\n  defexception [:message]\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing CartItemController in Phoenix\nDESCRIPTION: This snippet defines the CartItemController with create and delete actions for managing cart items in a Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.CartItemController do\n  use HelloWeb, :controller\n\n  alias Hello.ShoppingCart\n\n  def create(conn, %{\"product_id\" => product_id}) do\n    case ShoppingCart.add_item_to_cart(conn.assigns.current_scope, conn.assigns.cart, product_id) do\n      {:ok, _item} ->\n        conn\n        |> put_flash(:info, \"Item added to your cart\")\n        |> redirect(to: ~p\"/cart\")\n\n      {:error, _changeset} ->\n        conn\n        |> put_flash(:error, \"There was an error adding the item to your cart\")\n        |> redirect(to: ~p\"/cart\")\n    end\n  end\n\n  def delete(conn, %{\"id\" => product_id}) do\n    {:ok, _cart} = ShoppingCart.remove_item_from_cart(conn.assigns.current_scope, conn.assigns.cart, product_id)\n    redirect(conn, to: ~p\"/cart\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: File Upload Management Example\nDESCRIPTION: Demonstrates how to handle uploaded files by copying them to a media directory with unique names.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nif upload = product_params[\"photo\"] do\n  extension = Path.extname(upload.filename)\n  File.cp(upload.path, \"/media/#{product.id}-cover#{extension}\")\nend\n```\n\n----------------------------------------\n\nTITLE: Phoenix Database Configuration\nDESCRIPTION: Configuration for the database connection in a Phoenix application's development environment, specifying credentials, hostname, and connection pool settings.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n# Configure your database\nconfig :hello, Hello.Repo,\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\",\n  database: \"hello_dev\",\n  show_sensitive_data_on_connection_error: true,\n  pool_size: 10\n```\n\n----------------------------------------\n\nTITLE: Configuring UserSocket in Phoenix Endpoint (Elixir)\nDESCRIPTION: Adds a socket configuration to the Phoenix Endpoint module to enable WebSocket connections.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :hello\n\n  socket \"/socket\", HelloWeb.UserSocket,\n    websocket: true,\n    longpoll: false\n\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Flash Messages in Phoenix Controller (Elixir)\nDESCRIPTION: This snippet demonstrates how to set flash messages in a Phoenix controller action using put_flash/3. It sets an error message and renders the home page.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageController do\n  ...\n  def home(conn, _params) do\n    conn\n    |> put_flash(:error, \"Let's pretend we have an error.\")\n    |> render(:home)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Summary Metric for Ecto Query Time (Elixir)\nDESCRIPTION: Use Telemetry.Metrics to define a summary metric for Ecto query execution time.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nTelemetry.Metrics.summary(\"my_app.repo.query.query_time\",\n  unit: {:native, :millisecond}\n)\n```\n\n----------------------------------------\n\nTITLE: Actionable Error Implementation\nDESCRIPTION: Implementation of Plug.Exception protocol with custom actions for debugging and error handling\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefimpl Plug.Exception, for: HelloWeb.SomethingNotFoundError do\n  def status(_exception), do: 404\n\n  def actions(_exception) do\n    [\n      %{\n        label: \"Run seeds\",\n        handler: {Code, :eval_file, [\"priv/repo/seeds.exs\"]}\n      }\n    ]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Inspecting Upload Parameters in Controller\nDESCRIPTION: Shows how to inspect uploaded file parameters in a Phoenix controller action.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n...\n  def create(conn, %{\"product\" => product_params}) do\n    IO.inspect product_params\n...\n```\n\n----------------------------------------\n\nTITLE: Running Phoenix Server in Production Mode\nDESCRIPTION: Command for starting a Phoenix server in production mode by setting the PORT and MIX_ENV environment variables. This demonstrates how to run the server with the correct production configuration.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ PORT=4001 MIX_ENV=prod mix phx.server\n10:59:19.136 [info] Running MyAppWeb.Endpoint with Cowboy on http://example.com\n```\n\n----------------------------------------\n\nTITLE: Compiling Phoenix Application and Assets for Production\nDESCRIPTION: Commands to retrieve dependencies, compile the application code, and prepare assets for production deployment.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n# Initial setup\n$ mix deps.get --only prod\n$ MIX_ENV=prod mix compile\n\n# Compile assets\n$ MIX_ENV=prod mix assets.deploy\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL for Development Environment\nDESCRIPTION: Configuration example for enabling HTTPS in a Phoenix application's development environment using self-signed certificates generated with the phx.gen.cert mix task.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/using_ssl.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, MyAppWeb.Endpoint,\n  ...\n  https: [\n    port: 4001,\n    cipher_suite: :strong,\n    keyfile: \"priv/cert/selfsigned_key.pem\",\n    certfile: \"priv/cert/selfsigned.pem\"\n  ]\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL in Phoenix Application Environment\nDESCRIPTION: Example configuration for an HTTPS endpoint in a Phoenix application's runtime.exs file. Specifies port, cipher suite, and paths to SSL certificate files using environment variables.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/using_ssl.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nimport Config\n\nconfig :hello, HelloWeb.Endpoint,\n  http: [port: {:system, \"PORT\"}],\n  url: [host: \"example.com\"],\n  cache_static_manifest: \"priv/static/cache_manifest.json\",\n  https: [\n    port: 443,\n    cipher_suite: :strong,\n    otp_app: :hello,\n    keyfile: System.get_env(\"SOME_APP_SSL_KEY_PATH\"),\n    certfile: System.get_env(\"SOME_APP_SSL_CERT_PATH\"),\n    # OPTIONAL Key for intermediate certificates:\n    cacertfile: System.get_env(\"INTERMEDIATE_CERTFILE_PATH\")\n  ]\n```\n\n----------------------------------------\n\nTITLE: Handling Presence Updates in Elixir\nDESCRIPTION: Adds a handle_metas/4 callback to the HelloWeb.Presence module to handle user joins and leaves, broadcasting events to a proxy channel.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\n  def handle_metas(topic, %{joins: joins, leaves: leaves}, presences, state) do\n    for {user_id, presence} <- joins do\n      user_data = %{id: user_id, user: presence.user, metas: Map.fetch!(presences, user_id)}\n      msg = {__MODULE__, {:join, user_data}}\n      Phoenix.PubSub.local_broadcast(Hello.PubSub, \"proxy:#{topic}\", msg)\n    end\n\n    for {user_id, presence} <- leaves do\n      metas =\n        case Map.fetch(presences, user_id) do\n          {:ok, presence_metas} -> presence_metas\n          :error -> []\n        end\n\n      user_data = %{id: user_id, user: presence.user, metas: metas}\n      msg = {__MODULE__, {:leave, user_data}}\n      Phoenix.PubSub.local_broadcast(Hello.PubSub, \"proxy:#{topic}\", msg)\n    end\n\n    {:ok, state}\n  end\n```\n\n----------------------------------------\n\nTITLE: Generating Phoenix Presence Module\nDESCRIPTION: Command to generate a Presence module using Phoenix's presence generator. This creates the necessary module for tracking user presence across channels.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.presence\n```\n\n----------------------------------------\n\nTITLE: Implementing URL Controller Index Action\nDESCRIPTION: Basic controller action to fetch and render URLs as JSON\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n  def index(conn, _params) do\n    urls = Urls.list_urls()\n    render(conn, :index, urls: urls)\n  end\n```\n\n----------------------------------------\n\nTITLE: Rolling Back Migrations with mix ecto.rollback\nDESCRIPTION: Demonstrates rolling back the last migration using mix ecto.rollback, showing how it reverses the schema changes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_26\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.rollback\n[info] == Running Hello.Repo.Migrations.AddCommentsTable.change/0 backward\n[info] drop table comments\n[info] == Migrated in 0.0s\n```\n\n----------------------------------------\n\nTITLE: Improving Cart Items Migration in Elixir\nDESCRIPTION: Enhancing the generated migration for cart_items by adding precision to the price field, setting up proper foreign key constraints with delete_all strategy, and creating a unique index for cart_id and product_id.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n    create table(:cart_items) do\n-     add :price_when_carted, :decimal\n+     add :price_when_carted, :decimal, precision: 15, scale: 6, null: false\n      add :quantity, :integer\n-     add :cart_id, references(:carts, on_delete: :nothing)\n+     add :cart_id, references(:carts, on_delete: :delete_all)\n-     add :product_id, references(:products, on_delete: :nothing)\n+     add :product_id, references(:products, on_delete: :delete_all)\n\n      timestamps()\n    end\n\n-   create index(:cart_items, [:cart_id])\n    create index(:cart_items, [:product_id])\n+   create unique_index(:cart_items, [:cart_id, :product_id])\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL for Production Database in Elixir\nDESCRIPTION: Elixir configuration snippet to enable SSL with TLS 1.2 for the database connection when using a production Gigalixir database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nssl: true,\nallowed_tls_versions: [:\"tlsv1.2\"],\nssl_opts: [verify: :verify_none]\n```\n\n----------------------------------------\n\nTITLE: Refactoring Controller Action with Plugs in Phoenix (Elixir)\nDESCRIPTION: This code snippet demonstrates how to refactor the previous complex controller action using Plugs. It separates authentication, message fetching, and authorization into individual plugs, improving code organization and reusability.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.MessageController do\n  use HelloWeb, :controller\n\n  plug :authenticate\n  plug :fetch_message\n  plug :authorize_message\n\n  def show(conn, params) do\n    render(conn, :show, page: conn.assigns[:message])\n  end\n\n  defp authenticate(conn, _) do\n    case Authenticator.find_user(conn) do\n      {:ok, user} ->\n        assign(conn, :user, user)\n      :error ->\n        conn |> put_flash(:info, \"You must be logged in\") |> redirect(to: ~p\"/\") |> halt()\n    end\n  end\n\n  defp fetch_message(conn, _) do\n    case find_message(conn.params[\"id\"]) do\n      nil ->\n        conn |> put_flash(:info, \"That message wasn't found\") |> redirect(to: ~p\"/\") |> halt()\n      message ->\n        assign(conn, :message, message)\n    end\n  end\n\n  defp authorize_message(conn, _) do\n    if Authorizer.can_access?(conn.assigns[:user], conn.assigns[:message]) do\n      conn\n    else\n      conn |> put_flash(:info, \"You can't access that page\") |> redirect(to: ~p\"/\") |> halt()\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Channel Routes in UserSocket (Elixir)\nDESCRIPTION: Defines channel routes in the UserSocket module to direct messages to the appropriate channel handler.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.UserSocket do\n  use Phoenix.Socket\n\n  ## Channels\n  channel \"room:*\", HelloWeb.RoomChannel\n  ...\n```\n\n----------------------------------------\n\nTITLE: Creating a New Controller in Phoenix (Elixir)\nDESCRIPTION: This code defines a new HelloController with an index action that renders the index template.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloController do\n  use HelloWeb, :controller\n\n  def index(conn, _params) do\n    render(conn, :index)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Cart Update Function with Ecto.Multi in Phoenix\nDESCRIPTION: Defines an update_cart function in the ShoppingCart context that uses Ecto.Multi to handle complex update operations, including nested associations and removing items with zero quantity.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ndef update_cart(%Scope{} = scope, %Cart{} = cart, attrs) do\n  true = cart.user_id == scope.user.id\n\n  changeset =\n    cart\n    |> Cart.changeset(attrs, scope)\n    |> Ecto.Changeset.cast_assoc(:items, with: &CartItem.changeset/2)\n\n  Ecto.Multi.new()\n  |> Ecto.Multi.update(:cart, changeset)\n  |> Ecto.Multi.delete_all(:discarded_items, fn %{cart: cart} ->\n    from(i in CartItem, where: i.cart_id == ^cart.id and i.quantity == 0)\n  end)\n  |> Repo.transaction()\n  |> case do\n    {:ok, %{cart: cart}} ->\n      broadcast(scope, {:updated, cart})\n      {:ok, cart}\n\n    {:error, :cart, changeset, _changes_so_far} ->\n      {:error, changeset}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Phoenix Scope\nDESCRIPTION: Configuration for defining a basic user scope in Phoenix application with all required options including test fixtures and login helpers.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, :scopes,\n  user: [\n    default: true,\n    module: MyApp.Accounts.Scope,\n    assign_key: :current_scope,\n    access_path: [:user, :id],\n    schema_key: :user_id,\n    schema_type: :id,\n    schema_table: :users,\n    test_data_fixture: MyApp.AccountsFixtures,\n    test_login_helper: :register_and_log_in_user\n  ]\n```\n\n----------------------------------------\n\nTITLE: Handling Custom Events in Phoenix Channels\nDESCRIPTION: Elixir code snippet showing how to handle a custom 'report_emergency' event in a Phoenix Channel. It demonstrates the handle_in function with a payload.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_in(\"report_emergency\", payload, socket) do\n  MyApp.Emergencies.report(payload) # or whatever\n  {:reply, :ok, socket}\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Paths for Nested Routes in Elixir\nDESCRIPTION: Demonstrates how to generate paths for nested routes using interpolation in Phoenix Framework. It shows both direct ID interpolation and struct-based interpolation using the Phoenix.Param protocol.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nuser_id = 42\npost_id = 17\n~p\"/users/#{user_id}/posts/#{post_id}\"\n\"/users/42/posts/17\"\n\n~p\"/users/#{user}/posts/#{post}\"\n\"/users/42/posts/17\"\n```\n\n----------------------------------------\n\nTITLE: Controller with Renamed Action in Elixir\nDESCRIPTION: A Phoenix controller with a renamed action from home to index, demonstrating how actions can be renamed as long as corresponding router entries are updated.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageController do\n  ...\n\n  def index(conn, _params) do\n    render(conn, :home)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Channel Routes in Phoenix UserSocket\nDESCRIPTION: Example showing how to define channel routes in a Phoenix UserSocket module. The wildcard matcher allows routing messages to the same channel for different subtopics.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nchannel \"room:*\", HelloWeb.RoomChannel\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Layout in Phoenix Router\nDESCRIPTION: This snippet shows how to configure the root layout in the Phoenix router file. It sets the root layout to use the 'root' function from the HelloWeb.Layouts module.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\n  plug :put_root_layout, html: {HelloWeb.Layouts, :root}\n```\n\n----------------------------------------\n\nTITLE: Implementing Controller with Error Handling\nDESCRIPTION: Example controller implementation with error handling using with statement\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.MyController do\n  use Phoenix.Controller\n\n  def show(conn, %{\"id\" => id}, current_user) do\n    with {:ok, post} <- fetch_post(id),\n         :ok <- authorize_user(current_user, :view, post) do\n      render(conn, :show, post: post)\n    else\n      {:error, :not_found} ->\n        conn\n        |> put_status(:not_found)\n        |> put_view(html: HelloWeb.ErrorHTML, json: HelloWeb.ErrorJSON)\n        |> render(:\"404\")\n\n      {:error, :unauthorized} ->\n        conn\n        |> put_status(403)\n        |> put_view(html: HelloWeb.ErrorHTML, json: HelloWeb.ErrorJSON)\n        |> render(:\"403\")\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Show Action in Phoenix Controller\nDESCRIPTION: Shows how to implement a show action in a Phoenix controller, extracting a parameter from the request and passing it to the view.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndef show(conn, %{\"messenger\" => messenger}) do\n  render(conn, :show, messenger: messenger)\nend\n```\n\n----------------------------------------\n\nTITLE: Limiting Resource Routes with :only Option\nDESCRIPTION: Creating a read-only resource by limiting the generated routes to only index and show actions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nresources \"/posts\", PostController, only: [:index, :show]\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Resource with mix phx.gen.html Command\nDESCRIPTION: This command generates a complete HTML resource including controllers, views, templates, context, schema and tests for a Blog Post resource.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.html Blog Post posts title body:text\n```\n\n----------------------------------------\n\nTITLE: Handling Synchronous Reply in Phoenix Channel\nDESCRIPTION: Defines a handle_in/3 callback for the 'ping' event in a Phoenix Channel. It demonstrates how to send a synchronous reply to the client.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_in(\"ping\", payload, socket) do\n  {:reply, {:ok, payload}, socket}\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Function Plug in Elixir\nDESCRIPTION: This code defines a simple function plug that introspects and logs connection information (HTTP verb, host, and headers) before returning the connection unchanged. Function plugs must accept a connection and options as arguments and return a connection.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndef introspect(conn, _opts) do\n  IO.puts \"\"\"\n  Verb: #{inspect(conn.method)}\n  Host: #{inspect(conn.host)}\n  Headers: #{inspect(conn.req_headers)}\n  \"\"\"\n\n  conn\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Telemetry-Enabled GenServer in Elixir\nDESCRIPTION: A GenServer module that executes arbitrary functions and emits telemetry events for start, stop, and exception cases. It includes measurement of execution duration and system time.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.MyServer do\n  @moduledoc \"\"\"\n  An example GenServer that runs arbitrary functions and emits telemetry events when called.\n  \"\"\"\n  use GenServer\n\n  # A common prefix for :telemetry events\n  @prefix [:my_app, :my_server, :call]\n\n  def start_link(fun) do\n    GenServer.start_link(__MODULE__, fun, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Runs the function contained within this server.\n\n  ## Events\n\n  The following events may be emitted:\n\n    * `[:my_app, :my_server, :call, :start]` - Dispatched\n      immediately before invoking the function. This event\n      is always emitted.\n\n      * Measurement: `%{system_time: system_time}`\n\n      * Metadata: `%{}`\n\n    * `[:my_app, :my_server, :call, :stop]` - Dispatched\n      immediately after successfully invoking the function.\n\n      * Measurement: `%{duration: native_time}`\n\n      * Metadata: `%{}`\n\n    * `[:my_app, :my_server, :call, :exception]` - Dispatched\n      immediately after invoking the function, in the event\n      the function throws or raises.\n\n      * Measurement: `%{duration: native_time}`\n\n      * Metadata: `%{kind: kind, reason: reason, stacktrace: stacktrace}`\n  \"\"\"\n  def call!, do: GenServer.call(__MODULE__, :called)\n\n  @impl true\n  def init(fun) when is_function(fun, 0), do: {:ok, fun}\n\n  @impl true\n  def handle_call(:called, _from, fun) do\n    # Wrap the function invocation in a \"span\"\n    result = telemetry_span(fun)\n\n    {:reply, result, fun}\n  end\n\n  # Emits telemetry events related to invoking the function\n  defp telemetry_span(fun) do\n    start_time = emit_start()\n\n    try do\n      fun.()\n    catch\n      kind, reason ->\n        stacktrace = System.stacktrace()\n        duration = System.monotonic_time() - start_time\n        emit_exception(duration, kind, reason, stacktrace)\n        :erlang.raise(kind, reason, stacktrace)\n    else\n      result ->\n        duration = System.monotonic_time() - start_time\n        emit_stop(duration)\n        result\n    end\n  end\n\n  defp emit_start do\n    start_time_mono = System.monotonic_time()\n\n    :telemetry.execute(\n      @prefix ++ [:start],\n      %{system_time: System.system_time()},\n      %{}\n    )\n\n    start_time_mono\n  end\n\n  defp emit_stop(duration) do\n    :telemetry.execute(\n      @prefix ++ [:stop],\n      %{duration: duration},\n      %{}\n    )\n  end\n\n  defp emit_exception(duration, kind, reason, stacktrace) do\n    :telemetry.execute(\n      @prefix ++ [:exception],\n      %{duration: duration},\n      %{\n        kind: kind,\n        reason: reason,\n        stacktrace: stacktrace\n      }\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Delete Action in PostController\nDESCRIPTION: Implementation of the delete action in a Phoenix controller that fetches a post by ID, deletes it, and redirects to the index page.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndef delete(conn, %{\"id\" => id}) do\n  post = Blog.get_post!(id)\n  {:ok, _post} = Blog.delete_post(post)\n\n  conn\n  |> put_flash(:info, \"Post deleted successfully.\")\n  |> redirect(to: ~p\"/posts\")\nend\n```\n\n----------------------------------------\n\nTITLE: Preparing Phoenix Dependencies for Production\nDESCRIPTION: Commands for getting production dependencies and compiling the Phoenix application for the production environment. These steps are necessary before compiling assets and deploying the application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix deps.get --only prod\n$ MIX_ENV=prod mix compile\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Scope Module\nDESCRIPTION: Basic implementation of a custom scope module that manages session-based scoping with a simple struct and helper function.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Scope do\n  defstruct id: nil\n\n  def for_id(id) do\n    %MyApp.Scope{id: id}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Ecto Migrations in Phoenix\nDESCRIPTION: Using the mix ecto.migrate command to execute pending migrations, which creates the database tables defined in the migration files.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate\nCompiling 1 file (.ex)\nGenerated hello app\n\n[info] == Running Hello.Repo.Migrations.CreateUsers.change/0 forward\n\n[info] create table users\n\n[info] == Migrated in 0.0s\n```\n\n----------------------------------------\n\nTITLE: Using Verified Routes in Controller Redirects\nDESCRIPTION: Using verified routes for redirects in Phoenix controllers, with dynamic path parameters.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nredirect(conn, to: ~p\"/comments/#{comment}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Create Action for JSON Controller in Phoenix\nDESCRIPTION: Elixir function implementing the create action for a JSON controller, handling article creation and response.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndef create(conn, %{\"article\" => article_params}) do\n  with {:ok, %Article{} = article} <- News.create_article(article_params) do\n    conn\n    |> put_status(:created)\n    |> put_resp_header(\"location\", ~p\"/api/articles/#{article}\")\n    |> render(:show, article: article)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Phoenix Authentication Generator in Console\nDESCRIPTION: Using the mix phx.gen.auth generator to scaffold an authentication system for the Phoenix application, creating user registration and login functionality.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nmix phx.gen.auth Accounts User users\n\nAn authentication system can be created in two different ways:\n- Using Phoenix.LiveView (default)\n- Using Phoenix.Controller only\nDo you want to create a LiveView based authentication system? [Yn] n\n\n...\n* creating lib/hello/accounts/scope.ex\n...\n* injecting config/config.exs\n...\n\nPlease re-fetch your dependencies with the following command:\n\n    $ mix deps.get\n\nRemember to update your repository by running migrations:\n\n    $ mix ecto.migrate\n\nOnce you are ready, visit \"/users/register\"\nto create your account and then access \"/dev/mailbox\" to\nsee the account confirmation email.\n```\n\n----------------------------------------\n\nTITLE: Using Custom Admin Layout Component in Phoenix Template\nDESCRIPTION: This HEEX snippet demonstrates how to use a custom 'admin' layout component in a Phoenix template. It showcases the flexibility of creating and using different layouts for specific purposes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_17\n\nLANGUAGE: heex\nCODE:\n```\n<Layouts.admin flash={@flash}>\n  ...\n</Layouts.admin>\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON View for URLs\nDESCRIPTION: JSON view module for rendering URL data structures as JSON responses\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.UrlJSON do\n  alias Hello.Urls.Url\n\n  @doc \"\"\"\n  Renders a list of urls.\n  \"\"\"\n  def index(%{urls: urls}) do\n    %{data: for(url <- urls, do: data(url))}\n  end\n\n  @doc \"\"\"\n  Renders a single url.\n  \"\"\"\n  def show(%{url: url}) do\n    %{data: data(url)}\n  end\n\n  defp data(%Url{} = url) do\n    %{\n      id: url.id,\n      link: url.link,\n      title: url.title\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting an Invalid Changeset in Elixir IEx\nDESCRIPTION: This snippet demonstrates how to create a changeset with an empty User struct and empty parameters, then inspect its validity and errors in an IEx session.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\niex> changeset = User.changeset(%User{}, %{})\n#Ecto.Changeset<\n  action: nil,\n  changes: %{},\n  errors: [\n    name: {\"can't be blank\", [validation: :required]},\n    email: {\"can't be blank\", [validation: :required]},\n    bio: {\"can't be blank\", [validation: :required]},\n    number_of_pets: {\"can't be blank\", [validation: :required]}\n  ],\n  data: #Hello.User<>,\n  valid?: false\n>\n```\n\n----------------------------------------\n\nTITLE: Internal Path Redirect\nDESCRIPTION: Implementing a redirect to an internal application path.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  redirect(conn, to: ~p\"/redirect_test\")\nend\n```\n\n----------------------------------------\n\nTITLE: Dynamic Host Redirection with Force SSL\nDESCRIPTION: Configuration for forcing SSL with dynamic host redirection, which redirects to the host of the current request rather than a predefined host.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/using_ssl.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, MyAppWeb.Endpoint,\n  force_ssl: [rewrite_on: [:x_forwarded_proto], host: nil]\n```\n\n----------------------------------------\n\nTITLE: Order Controller Show Action\nDESCRIPTION: Phoenix controller action to display an order, including scope-based authorization.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n  def show(conn, %{\"id\" => id}) do\n    order = Orders.get_order!(conn.assigns.current_scope, id)\n    render(conn, :show, order: order)\n  end\n```\n\n----------------------------------------\n\nTITLE: Creating a Template File in Phoenix (HEEx)\nDESCRIPTION: This code creates a simple HEEx template file for the index action, displaying a greeting message.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_5\n\nLANGUAGE: heex\nCODE:\n```\n<section>\n  <h2>Hello World, from Phoenix!</h2>\n</section>\n```\n\n----------------------------------------\n\nTITLE: Deploying Phoenix Assets for Production\nDESCRIPTION: Command for compiling and digesting Phoenix assets for production using the assets.deploy mix task. This creates optimized and digested static files in the priv/static directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ MIX_ENV=prod mix assets.deploy\nCheck your digested files at \"priv/static\".\n```\n\n----------------------------------------\n\nTITLE: Sending a Heartbeat in Phoenix Channels\nDESCRIPTION: Example of a 'heartbeat' event message to maintain the WebSocket connection. It demonstrates the message format for the phoenix topic.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n[null, \"2\", \"phoenix\", \"heartbeat\", {}]\n```\n\n----------------------------------------\n\nTITLE: Looping in HEEx Templates\nDESCRIPTION: Example of using a for loop in a HEEx template to generate dynamic HTML content from a collection.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_6\n\nLANGUAGE: heex\nCODE:\n```\n<table>\n  <tr>\n    <th>Number</th>\n    <th>Power</th>\n  </tr>\n  <%= for number <- 1..10 do %>\n    <tr>\n      <td>{number}</td>\n      <td>{number * number}</td>\n    </tr>\n  <% end %>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Defining Phoenix Router Dispatch Metrics in Elixir\nDESCRIPTION: This code defines a summary metric for Phoenix router dispatch duration, grouped by route. It uses the phoenix.router_dispatch.stop event and specifies tags and unit options.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\ndef metrics do\n  [\n    ...metrics...\n    summary(\"phoenix.router_dispatch.stop.duration\",\n      tags: [:route],\n      unit: {:native, :millisecond}\n    )\n  ]\nend\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Resource with Phoenix Generator\nDESCRIPTION: Command to generate a complete HTML resource for posts including controllers, views, templates, and tests using the Phoenix mix task.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.html Blog Post posts title body:text\n```\n\n----------------------------------------\n\nTITLE: Generating Phoenix Channel for Presence\nDESCRIPTION: Command to generate a RoomChannel module using Phoenix's channel generator. This creates the channel needed for implementing Presence functionality.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.channel Room\n```\n\n----------------------------------------\n\nTITLE: Customizing Presence Data Fetch in Elixir\nDESCRIPTION: Implements a fetch/2 callback in the HelloWeb.Presence module to modify the shape of the presence data, adding an id and user map.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n  def fetch(_topic, presences) do\n    for {key, %{metas: [meta | metas]}} <- presences, into: %{} do\n      # user can be populated here from the database here we populate\n      # the name for demonstration purposes\n      {key, %{metas: [meta | metas], id: meta.id, user: %{name: meta.id}}}\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Updating Order Query with Preload\nDESCRIPTION: Modifying the get_order! function to preload line items and products\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n   def get_order!(%Scope{} = scope, id) do\n-    Repo.get_by!(Order, id: id, user_id: scope.user.id)\n+    Order\n+    |> Repo.get_by!(id: id, user_id: scope.user.id)\n+    |> Repo.preload([line_items: [:product]])\n   end\n```\n\n----------------------------------------\n\nTITLE: Modified Router GET Route Definition in Elixir\nDESCRIPTION: A Phoenix router route definition showing a modified route that maps the root path to an index action instead of home.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nget \"/\", PageController, :index\n```\n\n----------------------------------------\n\nTITLE: Implementing Product Creation in Catalog Context\nDESCRIPTION: Function for creating new products in the catalog context, utilizing Ecto changesets and database operations.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n  @doc \"\"\"\n  Creates a product.\n\n  ## Examples\n\n      iex> create_product(%{field: value})\n      {:ok, %Product{}}\n\n      iex> create_product(%{field: bad_value})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def create_product(attrs \\\\ %{}) do\n    %Product{}\n    |> Product.changeset(attrs)\n    |> Repo.insert()\n  end\n```\n\n----------------------------------------\n\nTITLE: Creating the Database for Phoenix Application\nDESCRIPTION: Command to create the PostgreSQL database for the Phoenix application using Ecto. This assumes PostgreSQL is configured with a 'postgres' user and password.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/up_and_running.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.create\nCompiling 13 files (.ex)\nGenerated hello app\nThe database for Hello.Repo has been created\n```\n\n----------------------------------------\n\nTITLE: Adding Format Validation to Changeset in Elixir\nDESCRIPTION: This snippet shows how to add format validation to the 'email' field in the changeset function, ensuring it contains the '@' symbol.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndef changeset(user, attrs) do\n  user\n  |> cast(attrs, [:name, :email, :bio, :number_of_pets])\n  |> validate_required([:name, :email, :bio, :number_of_pets])\n  |> validate_length(:bio, min: 2)\n  |> validate_length(:bio, max: 140)\n  |> validate_format(:email, ~r/@/)\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering in HEEx Templates\nDESCRIPTION: Example of how to use if/else conditionals within HEEx templates to render different content based on conditions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_5\n\nLANGUAGE: heex\nCODE:\n```\n<%= if some_condition? do %>\n  <p>Some condition is true for user: {@messenger}</p>\n<% else %>\n  <p>Some condition is false for user: {@messenger}</p>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Implementing Delete Action for JSON Controller in Phoenix\nDESCRIPTION: Elixir function implementing the delete action for a JSON controller, handling article deletion and response.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\ndef delete(conn, %{\"id\" => id}) do\n  article = News.get_article!(id)\n\n  with {:ok, %Article{}} <- News.delete_article(article) do\n    send_resp(conn, :no_content, \"\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Measurement Function in Elixir\nDESCRIPTION: This function implements a custom measurement for user count. It executes a Telemetry event with the total user count, which can be used in metrics definitions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp do\n  def measure_users do\n    :telemetry.execute([:my_app, :users], %{total: MyApp.users_count()}, %{})\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Esbuild Script\nDESCRIPTION: A comprehensive Node.js script for custom esbuild configuration with watch and deploy options.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst esbuild = require(\"esbuild\");\n\nconst args = process.argv.slice(2);\nconst watch = args.includes('--watch');\nconst deploy = args.includes('--deploy');\n\nconst loader = {\n  // Add loaders for images/fonts/etc, e.g. { '.svg': 'file' }\n};\n\nconst plugins = [\n  // Add and configure plugins here\n];\n\n// Define esbuild options\nlet opts = {\n  entryPoints: [\"js/app.js\"],\n  bundle: true,\n  logLevel: \"info\",\n  target: \"es2022\",\n  outdir: \"../priv/static/assets\",\n  external: [\"*.css\", \"fonts/*\", \"images/*\"],\n  nodePaths: [\"../deps\"],\n  loader: loader,\n  plugins: plugins,\n};\n\nif (deploy) {\n  opts = {\n    ...opts,\n    minify: true,\n  };\n}\n\nif (watch) {\n  opts = {\n    ...opts,\n    sourcemap: \"inline\",\n  };\n  esbuild\n    .context(opts)\n    .then((ctx) => {\n      ctx.watch();\n    })\n    .catch((_error) => {\n      process.exit(1);\n    });\n} else {\n  esbuild.build(opts);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ConsoleReporter to Telemetry Supervision Tree in Elixir\nDESCRIPTION: This snippet shows how to add the Telemetry.Metrics.ConsoleReporter to the list of children in the Telemetry supervision tree. This allows printing of events and metrics to the terminal for experimentation.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n{Telemetry.Metrics.ConsoleReporter, metrics: metrics()}\n```\n\n----------------------------------------\n\nTITLE: Testing Delete Action with Setup Function\nDESCRIPTION: Test for the delete action that creates a fixture post, verifies successful deletion with redirection, and confirms the post is no longer accessible.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\n  describe \"delete post\" do\n    setup [:create_post]\n\n    test \"deletes chosen post\", %{conn: conn, post: post} do\n      conn = delete(conn, ~p\"/posts/#{post}\")\n      assert redirected_to(conn) == ~p\"/posts\"\n\n      assert_error_sent 404, fn ->\n        get(conn, ~p\"/posts/#{post}\")\n      end\n    end\n  end\n\n  defp create_post(_) do\n    post = post_fixture()\n    %{post: post}\n  end\n```\n\n----------------------------------------\n\nTITLE: Defining Mailer Module in Phoenix Application\nDESCRIPTION: Shows the definition of the Hello.Mailer module, which serves as the main interface for delivering emails in the Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/directory_structure.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Mailer do\n  use Swoosh.Mailer, otp_app: :hello\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Create Action with Success and Failure Cases\nDESCRIPTION: Tests for the create action that verify both successful post creation with redirection and failure handling with re-rendering the form.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndescribe \"create post\" do\n  test \"redirects to show when data is valid\", %{conn: conn} do\n    conn = post(conn, ~p\"/posts\", post: @create_attrs)\n\n    assert %{id: id} = redirected_params(conn)\n    assert redirected_to(conn) == ~p\"/posts/#{id}\"\n\n    conn = get(conn, ~p\"/posts/#{id}\")\n    assert html_response(conn, 200) =~ \"Post #{id}\"\n  end\n\n  test \"renders errors when data is invalid\", %{conn: conn} do\n    conn = post(conn, ~p\"/posts\", post: @invalid_attrs)\n    assert html_response(conn, 200) =~ \"New Post\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Verified Routes with Query Strings in Elixir\nDESCRIPTION: Demonstrates how to create verified routes with query strings using the ~p sigil in Phoenix Framework. It shows both direct key-value pairs and dictionary-based approaches.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\n~p\"/users/17?admin=true&active=false\"\n\"/users/17?admin=true&active=false\"\n\n~p\"/users/17?#{[admin: true]}\"\n\"/users/17?admin=true\"\n```\n\n----------------------------------------\n\nTITLE: LiveView Scope Integration\nDESCRIPTION: Implementation of LiveView hooks for mounting current scope in LiveView components\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n# user_auth.ex\ndef on_mount(:mount_current_scope, _params, session, socket) do\n  {:cont, mount_current_scope(socket, session)}\nend\n\ndefp mount_current_scope(socket, session) do\n  Phoenix.Component.assign_new(socket, :current_scope, fn ->\n    user =\n      if user_token = session[\"user_token\"] do\n        Accounts.get_user_by_session_token(user_token)\n      end\n\n    Scope.for_user(user)\n  end)\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Authentication Pipeline in Phoenix Router\nDESCRIPTION: This example demonstrates how to create a custom authentication pipeline and use it in combination with the browser pipeline for specific routes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {HelloWeb.Layouts, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :auth do\n    plug HelloWeb.Authentication\n  end\n\n  scope \"/reviews\", HelloWeb do\n    pipe_through [:browser, :auth]\n\n    resources \"/\", ReviewController\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Cart Items with References in Phoenix\nDESCRIPTION: Creating a CartItem schema that references both carts and products tables using the --no-scope flag since carts are already scoped to users. Includes fields for tracking price and quantity.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.context ShoppingCart CartItem cart_items \\\ncart_id:references:carts product_id:references:products \\\nprice_when_carted:decimal quantity:integer --no-scope\n\nYou are generating into an existing context.\n...\nWould you like to proceed? [Yn] y\n* creating lib/hello/shopping_cart/cart_item.ex\n* creating priv/repo/migrations/20250205213410_create_cart_items.exs\n* injecting lib/hello/shopping_cart.ex\n* injecting test/hello/shopping_cart_test.exs\n* injecting test/support/fixtures/shopping_cart_fixtures.ex\n\nRemember to update your repository by running migrations:\n\n    $ mix ecto.migrate\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Fallback in Phoenix Controller\nDESCRIPTION: Elixir code snippet showing how to set up action fallback for handling error cases in a Phoenix controller.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\naction_fallback HelloWeb.FallbackController\n```\n\n----------------------------------------\n\nTITLE: Response with Content Type\nDESCRIPTION: Setting content type and sending a response.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  conn\n  |> put_resp_content_type(\"text/plain\")\n  |> send_resp(201, \"\")\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Create Action for JSON Controller in Phoenix\nDESCRIPTION: Elixir test case for the create action of a JSON controller, verifying successful article creation and response.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndescribe \"create article\" do\n  test \"renders article when data is valid\", %{conn: conn} do\n    conn = post(conn, ~p\"/articles\", article: @create_attrs)\n    assert %{\"id\" => id} = json_response(conn, 201)[\"data\"]\n\n    conn = get(conn, ~p\"/api/articles/#{id}\")\n\n    assert %{\n             \"id\" => ^id,\n             \"body\" => \"some body\",\n             \"title\" => \"some title\"\n           } = json_response(conn, 200)[\"data\"]\n  end\n```\n\n----------------------------------------\n\nTITLE: Configuring Static File Serving\nDESCRIPTION: Shows how to configure Plug.Static to serve uploaded files from a specific directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nplug Plug.Static, at: \"/uploads\", from: \"/media\"\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations in Phoenix Release\nDESCRIPTION: Command to run database migrations in a production environment using the release module without Mix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ _build/prod/rel/my_app/bin/my_app eval \"MyApp.Release.migrate\"\n```\n\n----------------------------------------\n\nTITLE: Updating CartItem Schema Associations and Validations in Phoenix\nDESCRIPTION: This snippet demonstrates the modifications made to the cart item schema in lib/hello/shopping_cart/cart_item.ex to establish associations with the cart and product, and add quantity validation.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n  schema \"cart_items\" do\n    field :price_when_carted, :decimal\n    field :quantity, :integer\n-   field :cart_id, :id\n-   field :product_id, :id\n\n+   belongs_to :cart, Hello.ShoppingCart.Cart\n+   belongs_to :product, Hello.Catalog.Product\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(cart_item, attrs) do\n    cart_item\n    |> cast(attrs, [:price_when_carted, :quantity])\n    |> validate_required([:price_when_carted, :quantity])\n+   |> validate_number(:quantity, greater_than_or_equal_to: 0, less_than: 100)\n  end\n```\n\n----------------------------------------\n\nTITLE: Adding Dynamic Route in Phoenix Router\nDESCRIPTION: Demonstrates how to add a new route with a dynamic parameter (:messenger) in the Phoenix router.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/\", HelloWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :home\n  get \"/hello\", HelloController, :index\n  get \"/hello/:messenger\", HelloController, :show\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Layout Module Structure in Phoenix\nDESCRIPTION: Example of how a Layouts module is defined in Phoenix, using the html helper and embedding templates from a specific directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Layouts do\n  use HelloWeb, :html\n\n  embed_templates \"layouts/*\"\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Length Validation to Changeset in Elixir\nDESCRIPTION: This snippet demonstrates how to add length validation to the 'bio' field in the changeset function, ensuring it's at least 2 characters long and no more than 140 characters.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndef changeset(user, attrs) do\n  user\n  |> cast(attrs, [:name, :email, :bio, :number_of_pets])\n  |> validate_required([:name, :email, :bio, :number_of_pets])\n  |> validate_length(:bio, min: 2)\n  |> validate_length(:bio, max: 140)\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Functions in Elixir with @doc Annotations\nDESCRIPTION: Example of how to write proper documentation for functions in Phoenix, focusing on the first paragraph as a summary that states what the function does. The example shows documenting a function that marks values as HTML safe.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n@doc \"\"\"\nMarks the given value as HTML safe.\n\"\"\"\ndef safe({:safe, value}), do: {:safe, value}\n```\n\n----------------------------------------\n\nTITLE: Adding 'Add to Cart' Button in Product Show Template\nDESCRIPTION: This snippet modifies the product show template to include an 'Add to cart' button, allowing users to add products to their cart.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n...\n     <.button href={~p\"/products/#{@product}/edit\"}>\n       Edit product\n     </.button>\n+    <.button href={~p\"/cart_items?product_id=#{@product.id}\"} method=\"post\">\n+      Add to cart\n+    </.button>\n...\n```\n\n----------------------------------------\n\nTITLE: Router Pipeline Configuration\nDESCRIPTION: Router configuration to accept multiple response formats.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\", \"json\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {HelloWeb.LayoutView, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n...\n```\n\n----------------------------------------\n\nTITLE: Extending ConnCase for Organization Scoping in Phoenix Tests\nDESCRIPTION: Extends the ConnCase module in test/support/conn_case.ex to include a helper function for registering and logging in a user with an organization scope for tests.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.ConnCase do\n  ...\n\n  def register_and_log_in_user_with_org(context) do\n    %{conn: conn, user: user, scope: scope} = register_and_log_in_user(context)\n    %{conn: conn, scope: MyApp.AccountsFixtures.organization_scope_fixture(scope)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Presence to Application Supervision Tree\nDESCRIPTION: Code snippet showing how to add the Presence module to the application's supervision tree in application.ex. This ensures that the Presence process is supervised properly.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nchildren = [\n  ...\n  HelloWeb.Presence,\n]\n```\n\n----------------------------------------\n\nTITLE: Installing and Setting Up Phoenix Dependencies\nDESCRIPTION: Command to install and setup dependencies for a Phoenix project.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_umbrella/apps/app_name_web/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmix setup\n```\n\n----------------------------------------\n\nTITLE: Implementing Index Action in PostController\nDESCRIPTION: Implementation of the index action in a Phoenix controller that fetches all posts and renders them in an index template.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndef index(conn, _params) do\n  posts = Blog.list_posts()\n  render(conn, :index, posts: posts)\nend\n```\n\n----------------------------------------\n\nTITLE: Direct Response Sending\nDESCRIPTION: Example of sending a direct response with status code and no content.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  send_resp(conn, 201, \"\")\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Phoenix Channel and Tests\nDESCRIPTION: Uses the mix phx.gen.channel command to generate a basic channel, its tests, and related files. It also prompts to create a socket handler if not found.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.channel Room\n* creating lib/hello_web/channels/room_channel.ex\n* creating test/hello_web/channels/room_channel_test.exs\n* creating test/support/channel_case.ex\n\nThe default socket handler - HelloWeb.UserSocket - was not found.\n\nDo you want to create it? [Yn]  \n* creating lib/hello_web/channels/user_socket.ex\n* creating assets/js/user_socket.js\n\nAdd the socket handler to your `lib/hello_web/endpoint.ex`, for example:\n\n    socket \"/socket\", HelloWeb.UserSocket,\n      websocket: true,\n      longpoll: false\n\nFor the front-end integration, you need to import the `user_socket.js`\nin your `assets/js/app.js` file:\n\n    import \"./user_socket.js\"\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Resource Routes in Phoenix Router\nDESCRIPTION: Elixir code snippet showing how to define routes for a JSON resource, excluding new and edit actions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nresources \"/articles\", ArticleController, except: [:new, :edit]\n```\n\n----------------------------------------\n\nTITLE: Intercepting Outgoing Events in Phoenix Channels (Elixir)\nDESCRIPTION: Demonstrates how to intercept specific outgoing events in Phoenix Channels and conditionally push them to clients based on user preferences. This example filters 'user_joined' events.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nintercept [\"user_joined\"]\n\ndef handle_out(\"user_joined\", msg, socket) do\n  if Accounts.ignoring_user?(socket.assigns[:user], msg.user_id) do\n    {:noreply, socket}\n  else\n    push(socket, \"user_joined\", msg)\n    {:noreply, socket}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Specific Tag in Phoenix\nDESCRIPTION: Demonstrates how to run only tests with a specific tag using the mix test command in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ mix test --only error_view_case\nIncluding tags: [:error_view_case]\nExcluding tags: [:test]\n\n...\n\nFinished in 0.1 seconds\n5 tests, 0 failures, 3 excluded\n\nRandomized with seed 125659\n```\n\n----------------------------------------\n\nTITLE: Plug Exception Protocol Implementation\nDESCRIPTION: Custom implementation of Plug.Exception protocol for handling specific status codes and actions for custom exceptions\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefimpl Plug.Exception, for: HelloWeb.SomethingNotFoundError do\n  def status(_exception), do: 404\n  def actions(_exception), do: []\nend\n```\n\n----------------------------------------\n\nTITLE: Setting up Database Configuration with SSL\nDESCRIPTION: Database configuration for Heroku Postgres with SSL enabled and pool size configuration\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :hello, Hello.Repo,\n  ssl: true,\n  url: database_url,\n  pool_size: String.to_integer(System.get_env(\"POOL_SIZE\") || \"10\")\n```\n\n----------------------------------------\n\nTITLE: Signing up for Gigalixir via CLI\nDESCRIPTION: Commands to create a Gigalixir account using the command-line interface, with options for standard or Google account signup.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir signup\n\n# or with a Google account\n$ gigalixir signup:google\n```\n\n----------------------------------------\n\nTITLE: Adding a Function Plug to Phoenix Endpoint\nDESCRIPTION: This code shows how to integrate a function plug into a Phoenix endpoint by adding it before the router. The example logs request information for every incoming HTTP request.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Endpoint do\n  ...\n\n  plug :introspect\n  plug HelloWeb.Router\n\n  def introspect(conn, _opts) do\n    IO.puts \"\"\"\n    Verb: #{inspect(conn.method)}\n    Host: #{inspect(conn.host)}\n    Headers: #{inspect(conn.req_headers)}\n    \"\"\"\n\n    conn\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Category Select to Product Form\nDESCRIPTION: Template modification to add a multiple select input for categories in the product form.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n  ...\n  <.input field={f[:views]} type=\"number\" label=\"Views\" />\n\n+ <.input field={f[:category_ids]} type=\"select\" multiple options={category_opts(@changeset)} />\n\n  <.button>Save Product</.button>\n```\n\n----------------------------------------\n\nTITLE: Setting Secrets on Fly.io\nDESCRIPTION: Command to set secret environment variables for the application on Fly.io.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ fly secrets set MY_SECRET_KEY=my_secret_value\n```\n\n----------------------------------------\n\nTITLE: Using Forward Macro in Phoenix Router\nDESCRIPTION: This snippet shows how to use the forward macro to delegate a path to a specific plug, useful for integrating separate web interfaces or applications.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_25\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  ...\n\n  scope \"/\", HelloWeb do\n    ...\n  end\n\n  forward \"/jobs\", BackgroundJob.Plug\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Tailwind Plugin for Remix Icon in JavaScript\nDESCRIPTION: This code creates a custom Tailwind plugin that traverses the Remix Icon dependency, reads SVG files, and generates CSS classes for each icon. It replaces the previous Heroicons implementation.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst plugin = require(\"tailwindcss/plugin\")\nconst fs = require(\"fs\")\nconst path = require(\"path\")\n\nmodule.exports = plugin(function({matchComponents, theme}) {\n  let baseDir = path.join(__dirname, \"../../deps/remixicons/icons\");\n  let values = {};\n  let icons = fs\n    .readdirSync(baseDir, { withFileTypes: true })\n    .filter((dirent) => dirent.isDirectory())\n    .map((dirent) => dirent.name);\n\n  icons.forEach((dir) => {\n    fs.readdirSync(path.join(baseDir, dir)).map((file) => {\n      let name = path.basename(file, \".svg\");\n      values[name] = { name, fullPath: path.join(baseDir, dir, file) };\n    });\n  });\n\n  matchComponents(\n    {\n      ri: ({ name, fullPath }) => {\n        let content = fs\n          .readFileSync(fullPath)\n          .toString()\n          .replace(/\\r?\\n|\\r/g, \"\");\n\n        return {\n          [`--ri-${name}`]: `url('data:image/svg+xml;utf8,${content}')`,\n          \"-webkit-mask\": `var(--ri-${name})`,\n          mask: `var(--ri-${name})`,\n          \"background-color\": \"currentColor\",\n          \"vertical-align\": \"middle\",\n          display: \"inline-block\",\n          width: theme(\"spacing.10\"),\n          height: theme(\"spacing.10\"),\n        };\n      },\n    },\n    { values },\n  );\n})\n```\n\n----------------------------------------\n\nTITLE: Scaling Fly.io Application Instances\nDESCRIPTION: Command to scale the number of application instances on Fly.io.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ fly scale count 2\n```\n\n----------------------------------------\n\nTITLE: Generating Category Select Options in Elixir\nDESCRIPTION: Function that generates select options for a multiple select input, handling existing category selections through changeset data.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n  def category_opts(changeset) do\n    existing_ids =\n      changeset\n      |> Ecto.Changeset.get_change(:categories, [])\n      |> Enum.map(& &1.data.id)\n\n    for cat <- Hello.Catalog.list_categories() do\n      [key: cat.title, value: cat.id, selected: cat.id in existing_ids]\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Defining Metrics for Custom Measurements in Elixir\nDESCRIPTION: This code defines metrics for custom measurements, including last_value metrics for user count and server stats, and summary and counter metrics for server calls.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndef metrics do\n  [\n    ...metrics...\n    # MyApp Metrics\n    last_value(\"my_app.users.total\"),\n    last_value(\"my_app.my_server.memory\", unit: :byte),\n    last_value(\"my_app.my_server.message_queue_len\")\n    summary(\"my_app.my_server.call.stop.duration\"),\n    counter(\"my_app.my_server.call.exception\")\n  ]\nend\n```\n\n----------------------------------------\n\nTITLE: Advanced Querying with Ecto's DSL in Elixir\nDESCRIPTION: Demonstrates more advanced querying capabilities using Ecto's Query DSL. It shows how to select specific fields, use conditions, and create custom result structures.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\niex> import Ecto.Query\nEcto.Query\n\niex> Repo.all(from u in User, select: u.email)\n[debug] QUERY OK source=\"users\" db=0.8ms queue=0.9ms idle=1634.0ms\nSELECT u0.\"email\" FROM \"users\" AS u0 []\n[\"user1@example.com\", \"user2@example.com\"]\n\niex> Repo.one(from u in User, where: ilike(u.email, \"%1%\"),\n                               select: count(u.id))\n[debug] QUERY OK source=\"users\" db=1.6ms SELECT count(u0.\"id\") FROM \"users\" AS u0 WHERE (u0.\"email\" ILIKE '%1%') []\n1\n\niex> Repo.all(from u in User, select: %{u.id => u.email})\n[debug] QUERY OK source=\"users\" db=0.9ms\nSELECT u0.\"id\", u0.\"email\" FROM \"users\" AS u0 []\n[\n  %{1 => \"user1@example.com\"},\n  %{2 => \"user2@example.com\"}\n]\n```\n\n----------------------------------------\n\nTITLE: Verifying Gigalixir Account\nDESCRIPTION: Command to verify your Gigalixir account information after logging in.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir account\n```\n\n----------------------------------------\n\nTITLE: Using App Layout Component in Phoenix Template\nDESCRIPTION: This HEEX snippet shows how to use the 'app' layout component in a Phoenix template. It passes the @flash assigns to the component for handling flash messages.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_16\n\nLANGUAGE: heex\nCODE:\n```\n<Layouts.app flash={@flash}>\n  ...\n</Layouts.app>\n```\n\n----------------------------------------\n\nTITLE: Passing User Token to JavaScript in Phoenix Layout (HEEX)\nDESCRIPTION: Injects the user authentication token into the JavaScript environment through a script tag in the Phoenix layout template.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_15\n\nLANGUAGE: heex\nCODE:\n```\n<script>window.userToken = \"<%= assigns[:user_token] %>\";</script>\n<script src={~p\"/assets/js/app.js\"}></script>\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Database Interaction Commands\nDESCRIPTION: Commands to connect to a PostgreSQL database and list the tables created by Phoenix migrations, showing the users table and related sequence.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ psql -U postgres\n\nType \"help\" for help.\n\npostgres=# \\connect hello_dev\nYou are now connected to database \"hello_dev\" as user \"postgres\".\nhello_dev=# \\d\n                List of relations\n Schema |       Name        |   Type   |  Owner\n--------+-------------------+----------+----------\n public | schema_migrations | table    | postgres\n public | users             | table    | postgres\n public | users_id_seq      | sequence | postgres\n(3 rows)\nhello_dev=# \\q\n```\n\n----------------------------------------\n\nTITLE: Generating a Migration in Phoenix with mix ecto.gen.migration\nDESCRIPTION: Shows how to generate a new migration file in Phoenix using the mix ecto.gen.migration task. The example creates a migration to add a comments table.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_19\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.gen.migration add_comments_table\n* creating priv/repo/migrations\n* creating priv/repo/migrations/20150318001628_add_comments_table.exs\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Metric for HTTP Requests (Elixir)\nDESCRIPTION: Use Telemetry.Metrics to define a counter metric for completed HTTP requests.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nTelemetry.Metrics.counter(\"phoenix.endpoint.stop.duration\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Multipart Form in Phoenix HEEX\nDESCRIPTION: Shows how to set up a multipart form in Phoenix using the CoreComponents form helper with the multipart attribute.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_0\n\nLANGUAGE: heex\nCODE:\n```\n<.form :let={f} for={@changeset} action={@action} multipart>\n...\n```\n\n----------------------------------------\n\nTITLE: Running Test by Line Number in Phoenix\nDESCRIPTION: Shows how to run a specific test by its line number, which ExUnit treats as a tag.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ mix test test/hello_web/controllers/error_html_test.exs:11\nIncluding tags: [line: \"11\"]\nExcluding tags: [:test]\n\n.\n\nFinished in 0.2 seconds\n2 tests, 0 failures, 1 excluded\n\nRandomized with seed 364723\n```\n\n----------------------------------------\n\nTITLE: Injecting Content in Root Layout Template\nDESCRIPTION: This HEEX snippet demonstrates where the rendered content is injected into the root layout template. The @inner_content assigns variable is used to place the content within the layout.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_15\n\nLANGUAGE: heex\nCODE:\n```\n{@inner_content}\n```\n\n----------------------------------------\n\nTITLE: JSON View Module Implementation\nDESCRIPTION: Implementation of a JSON view module for rendering JSON responses.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageJSON do\n  def home(_assigns) do\n    %{message: \"this is some JSON\"}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Elixir and Erlang Versions for Gigalixir\nDESCRIPTION: Commands to specify Elixir and Erlang versions for your Gigalixir deployment by creating an elixir_buildpack.config file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ echo 'elixir_version=1.17.2' > elixir_buildpack.config\n$ echo 'erlang_version=27.0' >> elixir_buildpack.config\n$ git add elixir_buildpack.config\n```\n\n----------------------------------------\n\nTITLE: Sending a Custom Event in Phoenix Channels\nDESCRIPTION: Example of sending a custom 'report_emergency' event to the 'miami:weather' channel. It shows the message format with a custom payload.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[null, \"3\", \"miami:weather\", \"report_emergency\", {\"category\": \"sharknado\"}]\n```\n\n----------------------------------------\n\nTITLE: Using Verified Routes in Heex Templates\nDESCRIPTION: Examples of using verified routes in Phoenix HTML templates with the link component.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_6\n\nLANGUAGE: heex\nCODE:\n```\n<.link href={~p\"/\"}>Welcome Page!</.link>\n<.link href={~p\"/comments\"}>View Comments</.link>\n```\n\n----------------------------------------\n\nTITLE: Configuring Organization Scope in Phoenix\nDESCRIPTION: Defines the configuration for organization scoping in the application's config/config.exs file. Specifies module, assign key, access path, route prefix, and other schema-related settings.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, :scopes,\n  user: [\n    ...\n  ],\n  organization: [\n    module: MyApp.Accounts.Scope,\n    assign_key: :current_scope,\n    access_path: [:organization, :id],\n    route_prefix: \"/orgs/:org\",\n    schema_key: :org_id,\n    schema_type: :id,\n    schema_table: :organizations,\n    test_data_fixture: MyApp.AccountsFixtures,\n    test_login_helper: :register_and_log_in_user_with_org\n  ]\n```\n\n----------------------------------------\n\nTITLE: Displaying Flash Messages in Phoenix Template (HEEx)\nDESCRIPTION: This snippet shows how to display flash messages in a Phoenix template using the flash_group component. It passes the @flash assign to the component.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_25\n\nLANGUAGE: heex\nCODE:\n```\n<.flash_group flash={@flash} />\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL Endpoint in Phoenix\nDESCRIPTION: Configuration for Phoenix endpoint to enable SSL and force HTTPS in production environment\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :scaffold, ScaffoldWeb.Endpoint,\n  url: [port: 443, scheme: \"https\"],\n  force_ssl: [rewrite_on: [:x_forwarded_proto]],\n```\n\n----------------------------------------\n\nTITLE: Basic Admin Scoped Route in Phoenix\nDESCRIPTION: Demonstrates how to create a basic admin scope with routes prefixed with /admin and controllers under the HelloWeb.Admin namespace. The scope uses the browser pipeline and defines review resources.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/admin\", HelloWeb.Admin do\n  pipe_through :browser\n\n  resources \"/reviews\", ReviewController\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Telemetry Supervisor to Application Supervision Tree (Elixir)\nDESCRIPTION: Add the Telemetry supervisor to the main application's supervision tree in the application.ex file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nchildren = [\n  MyAppWeb.Telemetry,\n  MyApp.Repo,\n  MyAppWeb.Endpoint,\n  ...\n]\n```\n\n----------------------------------------\n\nTITLE: Modifying Changeset Validations in Elixir\nDESCRIPTION: This snippet demonstrates how to modify the changeset function to make the 'number_of_pets' field optional by removing it from the validate_required list.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n|> validate_required([:name, :email, :bio])\n```\n\n----------------------------------------\n\nTITLE: HTML DOM Bindings for LiveView Events\nDESCRIPTION: Examples of HTML element attributes that bind browser events to LiveView server handlers. These bindings enable client-side events to be processed by the corresponding handle_event callbacks in the LiveView.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/live_view.md#2025-04-21_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<button phx-click=\"inc_temperature\">+</button>\n<form phx-submit=\"save\">...</form>\n<input phx-blur=\"validate\">\n```\n\n----------------------------------------\n\nTITLE: Defining Web Process for Heroku\nDESCRIPTION: Content of the 'Procfile' that tells Heroku how to start the Phoenix web server.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nweb: mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Implementing Chat Functionality (JavaScript)\nDESCRIPTION: Adds event listeners for sending messages and handling incoming messages in the client-side JavaScript.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nlet channel           = socket.channel(\"room:lobby\", {})\nlet chatInput         = document.querySelector(\"#chat-input\")\nlet messagesContainer = document.querySelector(\"#messages\")\n\nchatInput.addEventListener(\"keypress\", event => {\n  if(event.key === 'Enter'){\n    channel.push(\"new_msg\", {body: chatInput.value})\n    chatInput.value = \"\"\n  }\n})\n\nchannel.on(\"new_msg\", payload => {\n  let messageItem = document.createElement(\"p\")\n  messageItem.innerText = `[${Date()}] ${payload.body}`\n  messagesContainer.appendChild(messageItem)\n})\n\nchannel.join()\n  .receive(\"ok\", resp => { console.log(\"Joined successfully\", resp) })\n  .receive(\"error\", resp => { console.log(\"Unable to join\", resp) })\n\nexport default socket\n```\n\n----------------------------------------\n\nTITLE: Updating Product Show Template\nDESCRIPTION: Template modification to display associated categories in the product show view.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n<.list>\n  ...\n+ <:item title=\"Categories\">\n+   <ul>\n+     <li :for={cat <- @product.categories}>{cat.title}</li>\n+   </ul>\n+ </:item>\n</.list>\n```\n\n----------------------------------------\n\nTITLE: Logging into Gigalixir via CLI\nDESCRIPTION: Commands to log into a Gigalixir account using the command-line interface, with options for standard or Google account login.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir login\n\n# or with a Google account\n$ gigalixir login:google\n```\n\n----------------------------------------\n\nTITLE: Creating a new Phoenix application with MySQL\nDESCRIPTION: Use the `phx.new` command with the `--database mysql` flag to create a new Phoenix application configured for MySQL.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/swapping_databases.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.new hello_phoenix --database mysql\n```\n\n----------------------------------------\n\nTITLE: Handling Broadcast in Phoenix Channel\nDESCRIPTION: Defines a handle_in/3 callback for the 'shout' event in a Phoenix Channel. It demonstrates how to broadcast a message to all subscribers in the channel.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_in(\"shout\", payload, socket) do\n  broadcast(socket, \"shout\", payload)\n  {:noreply, socket}\nend\n```\n\n----------------------------------------\n\nTITLE: Creating HEEx Template for Show Action\nDESCRIPTION: Illustrates the creation of a HEEx template for the show action, demonstrating the use of layouts, content interpolation, and assigns.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_10\n\nLANGUAGE: heex\nCODE:\n```\n<Layouts.app flash={@flash}>\n  <section>\n    <h2>Hello World, from {@messenger}!</h2>\n  </section>\n</Layouts.app>\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository for Phoenix Project\nDESCRIPTION: Commands to initialize a Git repository, add all files, and make the initial commit for a Phoenix project before deploying to Heroku.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ git init\n$ git add .\n$ git commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Show Action in PostController\nDESCRIPTION: Implementation of the show action in a Phoenix controller that fetches a post by ID and renders it in a show template.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ndef show(conn, %{\"id\" => id}) do\n  post = Blog.get_post!(id)\n  render(conn, :show, post: post)\nend\n```\n\n----------------------------------------\n\nTITLE: LiveView Implementation with Scopes\nDESCRIPTION: Implementation of a LiveView module that utilizes scoping for data access and real-time updates\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.PostLive.Index do\n  use MyAppWeb, :live_view\n\n  alias MyApp.Blog\n\n  ...\n\n  @impl true\n  def mount(_params, _session, socket) do\n    Blog.subscribe_posts(socket.assigns.current_scope)\n\n    {:ok,\n     socket\n     |> assign(:page_title, \"Listing Posts\")\n     |> stream(:posts, Blog.list_posts(socket.assigns.current_scope))}\n  end\n\n  @impl true\n  def handle_event(\"delete\", %{\"id\" => id}, socket) do\n    post = Blog.get_post!(socket.assigns.current_scope, id)\n    {:ok, _} = Blog.delete_post(socket.assigns.current_scope, post)\n\n    {:noreply, stream_delete(socket, :posts, post)}\n  end\n\n  @impl true\n  def handle_info({type, %MyApp.Blog.Post{}}, socket)\n      when type in [:created, :updated, :deleted] do\n    {:noreply, stream(socket, :posts, Blog.list_posts(socket.assigns.current_scope), reset: true)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Heroku Container Stack Configuration\nDESCRIPTION: YAML configuration for Heroku container-based deployment with PostgreSQL addon and build settings\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nsetup:\n  addons:\n    - plan: heroku-postgresql\n      as: DATABASE\nbuild:\n  docker:\n    web: Dockerfile\n  config:\n    MIX_ENV: prod\n    SECRET_KEY_BASE: $SECRET_KEY_BASE\n    DATABASE_URL: $DATABASE_URL\n```\n\n----------------------------------------\n\nTITLE: Combined User and Admin Routes in Phoenix\nDESCRIPTION: Shows how to define both user-facing and admin routes for reviews, demonstrating route separation using scopes while maintaining distinct controllers for each context.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\nscope \"/\", HelloWeb do\n  pipe_through :browser\n\n  ...\n  resources \"/reviews\", ReviewController\nend\n\nscope \"/admin\", HelloWeb.Admin do\n  pipe_through :browser\n\n  resources \"/reviews\", ReviewController\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL for Free Tier Database in Elixir\nDESCRIPTION: Elixir configuration snippet to enable SSL for the database connection when using a free tier Gigalixir database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nssl: true,\nssl_opts: [\n  verify: :verify_none,\n  cacerts: :public_key.cacerts_get()\n]\n```\n\n----------------------------------------\n\nTITLE: Creating Fixtures for Organization Scoping in Phoenix Tests\nDESCRIPTION: Defines fixture functions in test/support/fixtures/accounts_fixtures.ex for creating organization scopes in tests. Includes a function to create an organization scope from a user scope.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.AccountsFixtures do\n  ...\n\n  def organization_scope_fixture(scope \\\\ user_scope_fixture()) do\n    org = organization_fixture(scope)\n    Scope.put_organization(scope, org)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Multiple Scopes with Same Path\nDESCRIPTION: Illustrates how to define multiple scopes with the same path prefix but different namespaces to handle different resources without conflicts.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  use Phoenix.Router\n  ...\n  scope \"/\", HelloWeb do\n    pipe_through :browser\n\n    resources \"/users\", UserController\n  end\n\n  scope \"/\", AnotherAppWeb do\n    pipe_through :browser\n\n    resources \"/posts\", PostController\n  end\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Authentication Scope with phx.gen.auth\nDESCRIPTION: Console command to generate authentication-related scope using Phoenix generator\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.auth Accounts User users\n```\n\n----------------------------------------\n\nTITLE: Defining LiveView Mount Duration Metric in Elixir\nDESCRIPTION: This snippet defines a summary metric for LiveView mount duration, grouped by view and connection status. It uses a custom tag_values function to extract and transform relevant metadata.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nsummary(\"phoenix.live_view.mount.stop.duration\",\n  unit: {:native, :millisecond},\n  tags: [:view, :connected?],\n  tag_values: &live_view_metric_tag_values/1\n)\n```\n\n----------------------------------------\n\nTITLE: Starting Phoenix Server\nDESCRIPTION: Commands to start the Phoenix endpoint either directly with Mix or within an IEx shell.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_single/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmix phx.server\n```\n\nLANGUAGE: bash\nCODE:\n```\niex -S mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Defining Periodic Measurements in Elixir\nDESCRIPTION: This code defines periodic measurements for a Phoenix application, including a custom measurement function and process info measurements. It's typically added to the Telemetry supervision tree.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndefp periodic_measurements do\n  [\n    {MyApp, :measure_users, []},\n    {:process_info,\n      event: [:my_app, :my_server],\n      name: MyApp.MyServer,\n      keys: [:message_queue_len, :memory]}\n  ]\nend\n```\n\n----------------------------------------\n\nTITLE: Cart Item Pruning Implementation\nDESCRIPTION: Function to remove all items from a shopping cart after order completion using Ecto.Query and Repo.delete_all.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n  def prune_cart_items(%Scope{} = scope, %Cart{} = cart) do\n    {_, _} = Repo.delete_all(from(i in CartItem, where: i.cart_id == ^cart.id))\n    {:ok, get_cart(scope)}\n  end\n```\n\n----------------------------------------\n\nTITLE: Using Detached Mode for Heroku Run Commands\nDESCRIPTION: Example of using the detached option with Heroku run commands to bypass connection timeout issues.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_15\n\nLANGUAGE: console\nCODE:\n```\nheroku run:detached \"POOL_SIZE=2 mix ecto.migrate\"\nRunning POOL_SIZE=2 mix ecto.migrate on mysterious-meadow-6277... done, run.8089 (Free)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Phoenix Channels WebSocket\nDESCRIPTION: Example of the WebSocket connection URL for Phoenix Channels. It includes the host, port, socket path, and version parameter for specifying the serializer.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[host]:[port]/mobile/websocket?vsn=2.0.0\n```\n\n----------------------------------------\n\nTITLE: Testing Delete Action for JSON Controller in Phoenix\nDESCRIPTION: Elixir test case for the delete action of a JSON controller, verifying successful article deletion and response.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\ndescribe \"delete article\" do\n  setup [:create_article]\n\n  test \"deletes chosen article\", %{conn: conn, article: article} do\n    conn = delete(conn, ~p\"/api/articles/#{article}\")\n    assert response(conn, 204)\n\n    assert_error_sent 404, fn ->\n      get(conn, ~p\"/api/articles/#{article}\")\n    end\n  end\nend\n\ndefp create_article(_) do\n  article = article_fixture()\n  %{article: article}\nend\n```\n\n----------------------------------------\n\nTITLE: Multiple Assigns Using Pipe Operator in Elixir\nDESCRIPTION: A controller action that demonstrates assigning multiple values to be passed to a template using the pipe operator. This chains assign/3 calls together.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n  def show(conn, %{\"messenger\" => messenger}) do\n    conn\n    |> assign(:messenger, messenger)\n    |> assign(:receiver, \"Dweezil\")\n    |> render(:show)\n  end\n```\n\n----------------------------------------\n\nTITLE: Using Ecto Mix Tasks in Elixir\nDESCRIPTION: Showcases the usage of Ecto Mix tasks for database management, specifically the ecto.create task for creating the database. It includes examples of successful execution and potential error scenarios.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\n$ mix ecto.create\nThe database for Hello.Repo has been created.\n\n$ mix ecto.create\n** (Mix) The database for Hello.Repo couldn't be created, reason given: psql: FATAL:  role \"postgres\" does not exist\n\n$ mix ecto.create\n** (Mix) The database for Hello.Repo couldn't be created, reason given: psql: FATAL:  role \"postgres\" is not permitted to log in\n\n$ mix ecto.create\n** (Mix) The database for Hello.Repo couldn't be created, reason given: ERROR:  permission denied to create database\n\n$ mix ecto.create\n** (Mix) The database for Hello.Repo couldn't be created, reason given: psql: FATAL:  password authentication failed for user \"postgres\"\n\n$ mix ecto.create -r OurCustom.Repo\nThe database for OurCustom.Repo has been created.\n```\n\n----------------------------------------\n\nTITLE: Phoenix Secure Browser Headers Update\nDESCRIPTION: Code snippet showing the content-security-policy header that is now set by default in put_secure_browser_headers to restrict embedding of applications and the use of <base> element to same origin.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n\"base-uri 'self'; frame-ancestors 'self';\"\n```\n\n----------------------------------------\n\nTITLE: Adding a Conditional Plug to a Phoenix Controller\nDESCRIPTION: This code demonstrates how to conditionally apply a plug to specific controller actions using the 'when action in' syntax. The Locale plug will only be applied when the controller executes the index action.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageController do\n  use HelloWeb, :controller\n\n  plug HelloWeb.Plugs.Locale, \"en\" when action in [:index]\n```\n\n----------------------------------------\n\nTITLE: Initializing Presence State in Elixir\nDESCRIPTION: Adds an init/1 callback to the HelloWeb.Presence module to initialize the presence state.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n  def init(_opts) do\n    {:ok, %{}}\n  end\n```\n\n----------------------------------------\n\nTITLE: Detailed Phoenix Channel Architecture Diagram (Plain Text)\nDESCRIPTION: A comprehensive diagram showing the detailed architecture of Phoenix Channels, including message routing between clients, channel servers, and PubSub mechanisms across both local and remote nodes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n                                 Channel   +-------------------------+      +--------+\n                                  route    | Sending Client, Topic 1 |      | Local  |\n                              +----------->|     Channel.Server      |----->| PubSub |--+\n+----------------+            |            +-------------------------+      +--------+  |\n| Sending Client |-Transport--+                                                  |      |\n+----------------+                         +-------------------------+           |      |\n                                           | Sending Client, Topic 2 |           |      |\n                                           |     Channel.Server      |           |      |\n                                           +-------------------------+           |      |\n                                                                                 |      |\n                                           +-------------------------+           |      |\n+----------------+                         | Browser Client, Topic 1 |           |      |\n| Browser Client |<-------Transport--------|     Channel.Server      |<----------+      |\n+----------------+                         +-------------------------+                  |\n                                                                                        |\n                                                                                        |\n                                                                                        |\n                                           +-------------------------+                  |\n+----------------+                         |  Phone Client, Topic 1  |                  |\n|  Phone Client  |<-------Transport--------|     Channel.Server      |<-+               |\n+----------------+                         +-------------------------+  |   +--------+  |\n                                                                        |   | Remote |  |\n                                           +-------------------------+  +---| PubSub |<-+\n+----------------+                         |  Watch Client, Topic 1  |  |   +--------+  |\n|  Watch Client  |<-------Transport--------|     Channel.Server      |<-+               |\n+----------------+                         +-------------------------+                  |\n                                                                                        |\n                                                                                        |\n                                           +-------------------------+      +--------+  |\n+----------------+                         |   IoT Client, Topic 1   |      | Remote |  |\n|   IoT Client   |<-------Transport--------|     Channel.Server      |<-----| PubSub |<-+\n+----------------+                         +-------------------------+      +--------+\n```\n\n----------------------------------------\n\nTITLE: Updating Product Schema with Category Association\nDESCRIPTION: Adds many-to-many relationship between Product and Category schemas using Ecto associations.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nmany_to_many :categories, Category, join_through: \"product_categories\", on_replace: :delete\n```\n\n----------------------------------------\n\nTITLE: Examining PostgreSQL Table Structure\nDESCRIPTION: Using the PostgreSQL \\d command to show the detailed structure of the users table, including column types and constraints created by the Ecto migration.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ psql\nhello_dev=# \\d users\nTable \"public.users\"\nColumn         |            Type             | Modifiers\n---------------+-----------------------------+----------------------------------------------------\nid             | bigint                      | not null default nextval('users_id_seq'::regclass)\nname           | character varying(255)      |\nemail          | character varying(255)      |\nbio            | character varying(255)      |\nnumber_of_pets | integer                     |\ninserted_at    | timestamp without time zone | not null\nupdated_at     | timestamp without time zone | not null\nIndexes:\n\"users_pkey\" PRIMARY KEY, btree (id)\n```\n\n----------------------------------------\n\nTITLE: Phoenix Channels Message Format\nDESCRIPTION: General format for messages sent from a client to a Phoenix Channel. It includes join reference, message reference, topic name, event name, and payload.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[join_reference, message_reference, topic_name, event_name, payload]\n```\n\n----------------------------------------\n\nTITLE: Modifying Orders Migration Schema\nDESCRIPTION: Database migration changes to add precision and scale to the total_price decimal field\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n  def change do\n    create table(:orders) do\n-     add :total_price, :decimal\n+     add :total_price, :decimal, precision: 15, scale: 6, null: false\n      add :user_id, references(:user, type: :id, on_delete: :delete_all)\n\n      timestamps()\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Installing Phoenix with Express on Windows PowerShell\nDESCRIPTION: A command to download and set up a new Phoenix application on Windows using PowerShell. This installs Erlang, Elixir, Phoenix, and automatically configures a database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/up_and_running.md#2025-04-21_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\n> curl.exe -fsSO https://new.phoenixframework.org/myapp.bat; .\\myapp.bat\n```\n\n----------------------------------------\n\nTITLE: Adding File Input Field in Phoenix Form\nDESCRIPTION: Demonstrates how to add a file input field to a Phoenix form using the CoreComponents input helper.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_1\n\nLANGUAGE: heex\nCODE:\n```\n...\n  <.input field={f[:photo]} type=\"file\" label=\"Photo\" />\n\n  <.button>Save Product</.button>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: Rendering Plain Text Response in Elixir\nDESCRIPTION: A controller action that renders a plain text response using the text/2 function. It extracts the messenger parameter and includes it in the response text.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndef show(conn, %{\"messenger\" => messenger}) do\n  text(conn, \"From messenger #{messenger}\")\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Distribution Metric for Ecto Query Queue Time (Elixir)\nDESCRIPTION: Use Telemetry.Metrics to define a distribution metric for Ecto query queue time.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nTelemetry.Metrics.distribution(\"my_app.repo.query.queue_time\",\n  unit: {:native, :millisecond}\n)\n```\n\n----------------------------------------\n\nTITLE: Running All Database Tests\nDESCRIPTION: Command to run all database tests after starting the databases with Docker Compose.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/integration_test/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mix test --include database\n```\n\n----------------------------------------\n\nTITLE: Updating Router with Order Routes\nDESCRIPTION: Adding order routes to the Phoenix router\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n  scope \"/\", HelloWeb do\n    pipe_through [:browser, :require_authenticated_user]\n\n    resources \"/cart_items\", CartItemController, only: [:create, :delete]\n\n    get \"/cart\", CartController, :show\n    put \"/cart\", CartController, :update\n\n+   resources \"/orders\", OrderController, only: [:create, :show]\n  end\n```\n\n----------------------------------------\n\nTITLE: Controller Action with Plug.Conn.assign in Elixir\nDESCRIPTION: A controller action that uses Plug.Conn.assign/3 to pass values to a template. This approach allows for a pipeline-style composition of assigns.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n  def show(conn, %{\"messenger\" => messenger}) do\n    conn\n    |> Plug.Conn.assign(:messenger, messenger)\n    |> render(:show)\n  end\n```\n\n----------------------------------------\n\nTITLE: Testing API Token Creation and Verification in Elixir\nDESCRIPTION: Test case for the create_user_api_token/1 and fetch_user_by_api_token/1 functions, verifying token creation and retrieval functionality.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/api_authentication.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n  describe \"create_user_api_token/1 and fetch_user_by_api_token/1\" do\n    test \"creates and fetches by token\" do\n      user = user_fixture()\n      token = Accounts.create_user_api_token(user)\n      assert Accounts.fetch_user_by_api_token(token) == {:ok, user}\n      assert Accounts.fetch_user_by_api_token(\"invalid\") == :error\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Using DataCase Asynchronously with SQL Sandbox\nDESCRIPTION: This code shows how to enable asynchronous tests with the SQL Sandbox by setting the async flag when using DataCase.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nuse Hello.DataCase, async: true\n```\n\n----------------------------------------\n\nTITLE: Installing Phoenix Framework Generator from Hex\nDESCRIPTION: Command to install the Phoenix Framework generator (`phx.new`) as a Mix archive from the Hex package manager. This allows you to generate new Phoenix web applications.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ mix archive.install hex phx_new\n```\n\n----------------------------------------\n\nTITLE: Starting Phoenix Application Partially in Custom Commands\nDESCRIPTION: Example code showing how to start a Phoenix application with only a subset of its processes for release commands.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefp start_app do\n  load_app()\n  Application.put_env(@app, :minimal, true)\n  Application.ensure_all_started(@app)\nend\n```\n\n----------------------------------------\n\nTITLE: Dynamic Attribute Interpolation in HEEx\nDESCRIPTION: Example of how to interpolate attribute values in HEEx templates, showing the correct syntax for attributes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_9\n\nLANGUAGE: heex\nCODE:\n```\n<div title=\"My div\" class={@class}>\n  <p>Hello {@username}</p>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Inserting Users with Ecto in Elixir\nDESCRIPTION: Demonstrates how to insert user records into the database using Ecto's Repo.insert/2 function. It shows the process of creating User structs and inserting them, along with the returned results and debug logs.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\niex> alias Hello.{Repo, User}\n[Hello.Repo, Hello.User]\n\niex> Repo.insert(%User{email: \"user1@example.com\"})\n[debug] QUERY OK db=6.5ms queue=0.5ms idle=1358.3ms\nINSERT INTO \"users\" (\"email\",\"inserted_at\",\"updated_at\") VALUES ($1,$2,$3) RETURNING \"id\" [\"user1@example.com\", ~N[2021-02-25 01:58:55], ~N[2021-02-25 01:58:55]]\n{:ok,\n %Hello.User{\n   __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">,\n   bio: nil,\n   email: \"user1@example.com\",\n   id: 1,\n   inserted_at: ~N[2021-02-25 01:58:55],\n   name: nil,\n   number_of_pets: nil,\n   updated_at: ~N[2021-02-25 01:58:55]\n }}\n\niex> Repo.insert(%User{email: \"user2@example.com\"})\n[debug] QUERY OK db=1.3ms idle=1402.7ms\nINSERT INTO \"users\" (\"email\",\"inserted_at\",\"updated_at\") VALUES ($1,$2,$3) RETURNING \"id\" [\"user2@example.com\", ~N[2021-02-25 02:03:28], ~N[2021-02-25 02:03:28]]\n{:ok,\n %Hello.User{\n   __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">,\n   bio: nil,\n   email: \"user2@example.com\",\n   id: 2,\n   inserted_at: ~N[2021-02-25 02:03:28],\n   name: nil,\n   number_of_pets: nil,\n   updated_at: ~N[2021-02-25 02:03:28]\n }}\n```\n\n----------------------------------------\n\nTITLE: Phoenix Controller Format Configuration\nDESCRIPTION: Default controller configuration showing supported formats in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\n  def controller do\n    quote do\n      use Phoenix.Controller,\n        formats: [:html, :json]\n      ...\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Importing Third-party JS Package with Relative Path\nDESCRIPTION: Demonstrates how to import a vendored JavaScript dependency using a relative path in app.js.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport topbar from \"../vendor/topbar\"\n```\n\n----------------------------------------\n\nTITLE: Telemetry Event Output Example\nDESCRIPTION: Example console output showing the telemetry event data including duration and metadata.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_21\n\nLANGUAGE: text\nCODE:\n```\n[Telemetry.Metrics.ConsoleReporter] Got new event!\nEvent name: my_app.my_server.call.stop\nAll measurements: %{duration: 4000}\nAll metadata: %{}\n\nMetric measurement: #Function<2.111777250/1 in Telemetry.Metrics.maybe_convert_measurement/2> (summary)\nWith value: 0.004 millisecond\nTag values: %{}\n\n\"Hello, world!\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Controller Action without Plugs in Phoenix (Elixir)\nDESCRIPTION: This code snippet shows a complex, nested implementation of a controller action for showing a message. It includes authentication, message retrieval, and authorization checks without using Plugs.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.MessageController do\n  use HelloWeb, :controller\n\n  def show(conn, params) do\n    case Authenticator.find_user(conn) do\n      {:ok, user} ->\n        case find_message(params[\"id\"]) do\n          nil ->\n            conn |> put_flash(:info, \"That message wasn't found\") |> redirect(to: ~p\"/\")\n          message ->\n            if Authorizer.can_access?(user, message) do\n              render(conn, :show, page: message)\n            else\n              conn |> put_flash(:info, \"You can't access that page\") |> redirect(to: ~p\"/\")\n            end\n        end\n      :error ->\n        conn |> put_flash(:info, \"You must be logged in\") |> redirect(to: ~p\"/\")\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Layout Component in Phoenix\nDESCRIPTION: The beginning of a function component definition for a layout in Phoenix, showing how components are defined with the ~H sigil.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n  def app(assigns) do\n    ~H\"\"\"\n    <header class=\"navbar px-4 sm:px-6 lg:px-8\">\n    ...\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies in Phoenix Framework\nDESCRIPTION: Command to install and set up dependencies for a Phoenix application using Mix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_single/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmix setup\n```\n\n----------------------------------------\n\nTITLE: Rendering Cart Template in Phoenix\nDESCRIPTION: Creates a HEEx template for displaying the cart contents, including a form for updating quantities and showing total prices. It uses Phoenix components and custom helper functions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_15\n\nLANGUAGE: heex\nCODE:\n```\n<.header>\n  My Cart\n  <:subtitle :if={@cart.items == []}>Your cart is empty</:subtitle>\n</.header>\n\n<div :if={@cart.items !== []}>\n  <.form :let={f} for={@changeset} action={~p\"/cart\"}>\n    <.inputs_for :let={%{data: item} = item_form} field={f[:items]}>\n      <.input field={item_form[:quantity]} type=\"number\" label={item.product.title} />\n      {currency_to_str(ShoppingCart.total_item_price(item))}\n    </.inputs_for>\n    <.button>Update cart</.button>\n  </.form>\n  <b>Total</b>: {currency_to_str(ShoppingCart.total_cart_price(@cart))}\n</div>\n\n<.button navigate={~p\"/products\"}>Back to products</.button>\n```\n\n----------------------------------------\n\nTITLE: Adding Scope Assignment to Router Pipeline\nDESCRIPTION: Router modification to include scope assignment in the browser pipeline using session-based identification.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\n   pipeline :browser do\n     plug :accepts, [\"html\"]\n     plug :fetch_session\n     plug :fetch_live_flash\n     plug :put_root_layout, html: {MyAppWeb.Layouts, :root}\n     plug :protect_from_forgery\n     plug :put_secure_browser_headers\n+    plug :assign_scope\n   end\n+\n+  defp assign_scope(conn, _opts) do\n+    if id = get_session(conn, :scope_id) do\n+      assign(conn, :current_scope, MyApp.Scope.for_id(id))\n+    else\n+      id = System.unique_integer()\n+\n+      conn\n+      |> put_session(:scope_id, id)\n+      |> assign(:current_scope, MyApp.Scope.for_id(id))\n+    end\n+  end\n```\n\n----------------------------------------\n\nTITLE: Using Absolute Paths for SSL Certificate Files\nDESCRIPTION: Example showing how to specify absolute paths to SSL certificate files when the otp_app configuration is not used.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/using_ssl.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nPath.expand(\"../../../some/path/to/ssl/key.pem\", __DIR__)\n```\n\n----------------------------------------\n\nTITLE: Displaying Phoenix.new Help Information (Console)\nDESCRIPTION: This console command shows how to view the help information for the phx.new mix task, which includes options for generating API-only applications.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ mix help phx.new\n```\n\n----------------------------------------\n\nTITLE: Using the Telemetry Server in IEx\nDESCRIPTION: Example of calling the telemetry-enabled server from an IEx session.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\niex> MyApp.MyServer.call!\n```\n\n----------------------------------------\n\nTITLE: Configuring Session-Based Scope\nDESCRIPTION: Configuration for session-based scope with custom schema settings and test helpers.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, :scopes,\n  session: [\n    default: true,\n    module: MyApp.Scope,\n    assign_key: :current_scope,\n    access_path: [:id],\n    schema_key: :session_id,\n    schema_type: :id,\n    schema_migration_type: :bigint,\n    schema_table: nil,\n    test_data_fixture: MyApp.ScopeFixtures,\n    test_login_helper: :put_scope_in_session\n  ]\n```\n\n----------------------------------------\n\nTITLE: Checking Changeset Validity and Errors in Elixir IEx\nDESCRIPTION: This snippet shows how to check if a changeset is valid and retrieve its errors in an IEx session.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\niex> changeset.valid?\nfalse\n\niex> changeset.errors\n[\n  name: {\"can't be blank\", [validation: :required]},\n  email: {\"can't be blank\", [validation: :required]},\n  bio: {\"can't be blank\", [validation: :required]},\n  number_of_pets: {\"can't be blank\", [validation: :required]}\n]\n```\n\n----------------------------------------\n\nTITLE: Displaying Locale Value in Phoenix Template\nDESCRIPTION: This HEEX template code shows how to access and display connection assigns set by a plug. The locale value (set by the Locale plug) is rendered in the page template using the @ syntax to access assigns.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/plug.md#2025-04-21_snippet_4\n\nLANGUAGE: heex\nCODE:\n```\n<p>Locale: {@locale}</p>\n```\n\n----------------------------------------\n\nTITLE: Custom 404 Template in Phoenix\nDESCRIPTION: HTML template for custom 404 error page including Phoenix styling and layout\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_2\n\nLANGUAGE: heex\nCODE:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n    <title>Welcome to Phoenix!</title>\n    <link rel=\"stylesheet\" href=\"/assets/css/app.css\"/>\n    <script defer type=\"text/javascript\" src=\"/assets/js/app.js\"></script>\n  </head>\n  <body>\n    <header>\n      <section class=\"container\">\n        <nav>\n          <ul>\n            <li><a href=\"https://hexdocs.pm/phoenix/overview.html\">Get Started</a></li>\n          </ul>\n        </nav>\n        <a href=\"https://phoenixframework.org/\" class=\"phx-logo\">\n          <img src=\"/images/logo.svg\" alt=\"Phoenix Framework Logo\"/>\n        </a>\n      </section>\n    </header>\n    <main class=\"container\">\n      <section class=\"phx-hero\">\n        <p>Sorry, the page you are looking for does not exist.</p>\n      </section>\n    </main>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Running Migrations with mix ecto.migrate\nDESCRIPTION: Shows the console output when running a migration with mix ecto.migrate, displaying the progress and completion of the migration process.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_22\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate\n[info] == Running Hello.Repo.Migrations.AddCommentsTable.change/0 forward\n[info] create table comments\n[info] == Migrated in 0.1s\n```\n\n----------------------------------------\n\nTITLE: Running Partitioned Tests in Phoenix\nDESCRIPTION: Shows how to run tests in partitions using environment variables and mix test command options.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ MIX_TEST_PARTITION=1 mix test --partitions 4\n$ MIX_TEST_PARTITION=2 mix test --partitions 4\n$ MIX_TEST_PARTITION=3 mix test --partitions 4\n$ MIX_TEST_PARTITION=4 mix test --partitions 4\n```\n\n----------------------------------------\n\nTITLE: Adding Validation to Post Schema Changeset\nDESCRIPTION: This code adds a validation to ensure that post titles are at least 2 characters long, demonstrating where schema validations should be placed.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndef changeset(post, attrs) do\n  post\n  |> cast(attrs, [:title, :body])\n  |> validate_required([:title, :body])\n  |> validate_length(:title, min: 2)\nend\n```\n\n----------------------------------------\n\nTITLE: Procfile Configuration for Named Node\nDESCRIPTION: Procfile configuration to run a named Elixir node for remote shell access\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_11\n\nLANGUAGE: text\nCODE:\n```\nweb: elixir --sname server -S mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Limited Resource Routes Output in Console\nDESCRIPTION: Console output showing the routes generated for a read-only resource limited with the :only option.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_10\n\nLANGUAGE: console\nCODE:\n```\nGET     /posts      HelloWeb.PostController :index\nGET     /posts/:id  HelloWeb.PostController :show\n```\n\n----------------------------------------\n\nTITLE: Generating Orders Context with Phoenix Generator\nDESCRIPTION: Console command to generate the Orders context with an Order schema containing total_price field\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.context Orders Order orders total_price:decimal\n```\n\n----------------------------------------\n\nTITLE: Custom Status Code Response\nDESCRIPTION: Setting a custom HTTP status code for the response.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  conn\n  |> put_status(202)\n  |> render(:home)\nend\n```\n\n----------------------------------------\n\nTITLE: Deploying to Gigalixir\nDESCRIPTION: Command to deploy your Phoenix application to Gigalixir using Git push.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ git push gigalixir\n```\n\n----------------------------------------\n\nTITLE: Resource Routes Output in Console\nDESCRIPTION: Console output showing all the RESTful routes generated by the resources macro.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n...\nGET     /users           HelloWeb.UserController :index\nGET     /users/:id/edit  HelloWeb.UserController :edit\nGET     /users/new       HelloWeb.UserController :new\nGET     /users/:id       HelloWeb.UserController :show\nPOST    /users           HelloWeb.UserController :create\nPATCH   /users/:id       HelloWeb.UserController :update\nPUT     /users/:id       HelloWeb.UserController :update\nDELETE  /users/:id       HelloWeb.UserController :delete\n...\n```\n\n----------------------------------------\n\nTITLE: Context Function Test for Creating Posts\nDESCRIPTION: This test verifies that the create_post/1 function in the Blog context correctly creates a post with valid attributes and returns the expected data structure.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ntest \"create_post/1 with valid data creates a post\" do\n  valid_attrs = %{body: \"some body\", title: \"some title\"}\n\n  assert {:ok, %Post{} = post} = Blog.create_post(valid_attrs)\n  assert post.body == \"some body\"\n  assert post.title == \"some title\"\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Distribution Metric for Request Duration (Elixir)\nDESCRIPTION: Use Telemetry.Metrics to define a distribution metric for HTTP request completion times.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nTelemetry.Metrics.distribution(\"phoenix.endpoint.stop.duration\")\n```\n\n----------------------------------------\n\nTITLE: Order Show Template Implementation\nDESCRIPTION: HEEx template for displaying order details including line items and total price.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_13\n\nLANGUAGE: heex\nCODE:\n```\n<.header>\n  Thank you for your order!\n  <:subtitle>\n     <strong>Email: </strong>{@current_scope.user.email}\n  </:subtitle>\n</.header>\n\n<.table id=\"items\" rows={@order.line_items}>\n  <:col :let={item} label=\"Title\">{item.product.title}</:col>\n  <:col :let={item} label=\"Quantity\">{item.quantity}</:col>\n  <:col :let={item} label=\"Price\">\n    {HelloWeb.CartHTML.currency_to_str(item.price)}\n  </:col>\n</.table>\n\n<strong>Total price:</strong>\n{HelloWeb.CartHTML.currency_to_str(@order.total_price)}\n\n<.button navigate={~p\"/products\"}>Back to products</.button>\n```\n\n----------------------------------------\n\nTITLE: Configuring Phoenix Dependency in Mix (Elixir)\nDESCRIPTION: Example of how the --dev flag configures the new project's :phoenix dependency as a relative path, pointing to the local Phoenix checkout.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefp deps do\n  [{:phoenix, path: \"../...\", override: true},\n```\n\n----------------------------------------\n\nTITLE: Adding Module Tag to ErrorHTMLTest in Elixir\nDESCRIPTION: Demonstrates how to add a module tag to a test module in Phoenix. This allows running all tests in this module with a specific tag.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ErrorHTMLTest do\n  use HelloWeb.ConnCase, async: true\n\n  @moduletag :error_view_case\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Synchronous Reply in Phoenix Channel\nDESCRIPTION: Tests a synchronous reply in a Phoenix Channel by pushing a 'ping' event and asserting the correct reply. This verifies the handle_in/3 callback for the 'ping' event.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ntest \"ping replies with status ok\", %{socket: socket} do\n  ref = push(socket, \"ping\", %{\"hello\" => \"there\"})\n  assert_reply ref, :ok, %{\"hello\" => \"there\"}\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Telemetry Dependencies in Phoenix (Elixir)\nDESCRIPTION: Add Telemetry-related packages to the project dependencies in the mix.exs file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n{\n  :telemetry_metrics, \"~> 1.0\"},\n  {:telemetry_poller, \"~> 1.0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Product Routes to Phoenix Router\nDESCRIPTION: Updating the router.ex file to add resources for ProductController, which creates RESTful routes for product management. This diff shows the exact change required in the browser scope.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n  scope \"/\", HelloWeb do\n    pipe_through :browser\n\n    get \"/\", PageController, :index\n+   resources \"/products\", ProductController\n  end\n```\n\n----------------------------------------\n\nTITLE: Rendering Raw HTML in HEEx\nDESCRIPTION: Example of how to render raw HTML content in a HEEx template, with a warning about security implications.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_8\n\nLANGUAGE: heex\nCODE:\n```\n{raw(\"<b>Bold?</b>\")}\n```\n\n----------------------------------------\n\nTITLE: JSON Response Example\nDESCRIPTION: An example of the JSON output from the json/2 function, showing how the messenger parameter is rendered as a JSON object with an id key.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\"id\": \"Frank\"}\n```\n\n----------------------------------------\n\nTITLE: Specifying Node.js Version for Phoenix Static Buildpack\nDESCRIPTION: Content of the 'phoenix_static_buildpack.config' file to specify the Node.js version for the Phoenix Static buildpack on Heroku.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n# Node.js version\nnode_version=10.20.1\n```\n\n----------------------------------------\n\nTITLE: Using Embedded Templates in Phoenix View (Elixir)\nDESCRIPTION: This snippet shows how to use embedded templates in a Phoenix view by specifying the directory containing the template files.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloHTML do\n  use HelloWeb, :html\n\n  embed_templates \"hello_html/*\"\nend\n```\n\n----------------------------------------\n\nTITLE: Importing NPM Package in Phoenix\nDESCRIPTION: Shows how to import an NPM package after installation in the assets directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport topbar from \"topbar\"\n```\n\n----------------------------------------\n\nTITLE: Launching Phoenix App on Fly.io\nDESCRIPTION: Command to initialize and deploy a Phoenix application on Fly.io.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ fly launch\n```\n\n----------------------------------------\n\nTITLE: Interpolating Multiple Attributes in HEEx\nDESCRIPTION: Example of how to interpolate multiple attributes at once using a keyword list or map in HEEx templates.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_10\n\nLANGUAGE: heex\nCODE:\n```\n<div title=\"My div\" {@many_attributes}>\n  <p>Hello {@username}</p>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Updating Order Schema Associations\nDESCRIPTION: Adding associations between Order and LineItem schemas including through relationships\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n  schema \"orders\" do\n    field :total_price, :decimal\n-   field :user_id, :id\n\n+   belongs_to :user, Hello.Accounts.User\n+   has_many :line_items, Hello.Orders.LineItem\n+   has_many :products, through: [:line_items, :product]\n\n    timestamps()\n  end\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Resource in Phoenix\nDESCRIPTION: Command to generate a JSON resource for articles in the News context using Phoenix generator.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.json News Article articles title body\n```\n\n----------------------------------------\n\nTITLE: Esbuild External Resources Configuration\nDESCRIPTION: Configuration for marking image and font resources as external in esbuild.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nargs: ~w(js/app.js --bundle --target=es2022 --outdir=../priv/static/assets/js --external:/fonts/* --external:/images/*)\n```\n\n----------------------------------------\n\nTITLE: Phoenix View Format Configuration\nDESCRIPTION: Explicit view module configuration for different formats in a controller.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nplug :put_view, html: HelloWeb.PageHTML, json: HelloWeb.PageJSON\n```\n\n----------------------------------------\n\nTITLE: Adding LiveView Route in Phoenix Router\nDESCRIPTION: Adds a route in the Phoenix router to access the OnlineLive LiveView component.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/presence.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n    live \"/online/:name\", OnlineLive, :index\n```\n\n----------------------------------------\n\nTITLE: Basic Phoenix Controller Test\nDESCRIPTION: Example of a basic controller test that verifies the root page response using ConnCase\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PageControllerTest do\n  use HelloWeb.ConnCase\n\n  test \"GET /\", %{conn: conn} do\n    conn = get(conn, ~p\"/\")\n    assert html_response(conn, 200) =~ \"Peace of mind from prototype to production\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Regions to Fly.io Application\nDESCRIPTION: Command to add a new region for deploying the application on Fly.io.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ fly regions add ewr\n```\n\n----------------------------------------\n\nTITLE: Building Phoenix Release for Production\nDESCRIPTION: Command to build a production release of the Phoenix application that can be deployed to a server.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/releases.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ MIX_ENV=prod mix release\nGenerated my_app app\n* assembling my_app-0.1.0 on MIX_ENV=prod\n* using config/runtime.exs to configure the release at runtime\n\nRelease created at _build/prod/rel/my_app!\n\n    # To start your system\n    _build/prod/rel/my_app/bin/my_app start\n\n...\n```\n\n----------------------------------------\n\nTITLE: Generating Scaffold with Tests in Phoenix\nDESCRIPTION: Demonstrates how to generate a complete scaffold including tests for a new resource in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.html Blog Post posts title body:text\n* creating lib/hello_web/controllers/post_controller.ex\n* creating lib/hello_web/controllers/post_html/edit.html.heex\n* creating lib/hello_web/controllers/post_html/index.html.heex\n* creating lib/hello_web/controllers/post_html/new.html.heex\n* creating lib/hello_web/controllers/post_html/show.html.heex\n* creating lib/hello_web/controllers/post_html/post_form.html.heex\n* creating lib/hello_web/controllers/post_html.ex\n* creating test/hello_web/controllers/post_controller_test.exs\n* creating lib/hello/blog/post.ex\n* creating priv/repo/migrations/20211001233016_create_posts.exs\n* creating lib/hello/blog.ex\n* injecting lib/hello/blog.ex\n* creating test/hello/blog_test.exs\n* injecting test/hello/blog_test.exs\n* creating test/support/fixtures/blog_fixtures.ex\n* injecting test/support/fixtures/blog_fixtures.ex\n```\n\n----------------------------------------\n\nTITLE: Phoenix Routes Listing Using mix phx.routes\nDESCRIPTION: Console output from mix phx.routes showing the routes generated for a basic Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.routes\nGET  /  HelloWeb.PageController :home\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Elixir Buildpack for Force Rebuilding Dependencies\nDESCRIPTION: Configuration setting for elixir_buildpack.config file to force Heroku to recompile all dependencies on each deploy, resolving stale dependency issues.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_13\n\nLANGUAGE: text\nCODE:\n```\nalways_rebuild=true\n```\n\n----------------------------------------\n\nTITLE: Seeding Categories Data\nDESCRIPTION: Creates initial category records in the database using the Catalog context.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nfor title <- [\"Home Improvement\", \"Power Tools\", \"Gardening\", \"Books\", \"Education\"] do\n  {:ok, _} = Hello.Catalog.create_category(%{title: title})\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Index Action for JSON Controller in Phoenix\nDESCRIPTION: Elixir test case for the index action of a JSON controller, verifying the response structure and status code.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndescribe \"index\" do\n  test \"lists all articles\", %{conn: conn} do\n    conn = get(conn, ~p\"/api/articles\")\n    assert json_response(conn, 200)[\"data\"] == []\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL credentials in config/dev.exs\nDESCRIPTION: Update the configuration in `config/dev.exs` to use MySQL credentials for the HelloPhoenix.Repo.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/swapping_databases.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :hello_phoenix, HelloPhoenix.Repo,\n  username: \"root\",\n  password: \"\",\n  database: \"hello_phoenix_dev\"\n```\n\n----------------------------------------\n\nTITLE: Nesting Pipelines in Phoenix Router\nDESCRIPTION: This snippet shows how to nest pipelines, allowing for more modular and reusable pipeline definitions in the Phoenix router.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\n  pipeline :auth do\n    plug :browser\n    plug :ensure_authenticated_user\n    plug :ensure_user_owns_review\n  end\n\n  scope \"/reviews\", HelloWeb do\n    pipe_through :auth\n\n    resources \"/\", ReviewController\n  end\n```\n\n----------------------------------------\n\nTITLE: Leaving a Phoenix Channel\nDESCRIPTION: Example of a 'phx_leave' event message to leave the 'miami:weather' channel. It shows the message format with an empty payload.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[null, \"1\", \"miami:weather\", \"phx_leave\", {}]\n```\n\n----------------------------------------\n\nTITLE: Deploying Updates to Fly.io\nDESCRIPTION: Command to deploy changes to the application on Fly.io.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ fly deploy\n```\n\n----------------------------------------\n\nTITLE: Shorthand Loop Rendering in HEEx\nDESCRIPTION: Example of the shorthand :for attribute for loop rendering in HEEx templates, showing how to iterate through a collection concisely.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/components.md#2025-04-21_snippet_13\n\nLANGUAGE: heex\nCODE:\n```\n<ul>\n  <li :for={item <- @items}>{item.name}</li>\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Implementing Scope Helpers in Phoenix\nDESCRIPTION: Defines helper functions in the Scope module for creating and manipulating scopes. Includes functions for creating scopes from users and organizations, and combining them.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.Scope do\n  alias MyApp.Accounts\n  alias MyApp.Accounts.{User, Organization}\n\n  defstruct user: nil, organization: nil\n\n  def for_user(%User{} = user) do\n    %__MODULE__{user: user}\n  end\n\n  def for_user(nil), do: nil\n\n  def put_organization(%__MODULE__{} = scope, %Organization{} = organization) do\n    %{scope | organization: organization}\n  end\n\n  def for(opts) when is_list(opts) do\n    cond do\n      opts[:user] && opts[:org] ->\n        user = user(opts[:user])\n        org = org(opts[:org])\n\n        user\n        |> for_user()\n        |> put_organization(org)\n\n      opts[:user] ->\n        user = user(opts[:user])\n        for_user(user)\n\n      opts[:org] ->\n        %__MODULE__{organization: org(opts[:org])}\n    end\n  end\n\n  defp user(id) when is_integer(id) do\n    Accounts.get_user!(id)\n  end\n\n  defp user(email) when is_binary(email) do\n    Accounts.get_user_by_email(email)\n  end\n\n  defp org(id) when is_integer(id) do\n    Accounts.get_organization!(id)\n  end\n\n  defp org(slug) when is_binary(slug) do\n    Accounts.get_organization_by_slug!(slug)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: PostController Test Module Structure\nDESCRIPTION: Basic structure of a Phoenix controller test module showing the use of ConnCase, fixture imports, and test data setup with module attributes.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.PostControllerTest do\n  use HelloWeb.ConnCase\n\n  import Hello.BlogFixtures\n\n  @create_attrs %{body: \"some body\", title: \"some title\"}\n  @update_attrs %{body: \"some updated body\", title: \"some updated title\"}\n  @invalid_attrs %{body: nil, title: nil}\n  \n  describe \"index\" do\n    test \"lists all posts\", %{conn: conn} do\n      conn = get(conn, ~p\"/posts\")\n      assert html_response(conn, 200) =~ \"Listing Posts\"\n    end\n  end\n\n  ...\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations in Phoenix\nDESCRIPTION: Executing the Ecto migration to apply the database schema changes. The console output shows the migration running successfully, creating the products table.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate\n14:09:02.260 [info] == Running 20250201185747 Hello.Repo.Migrations.CreateProducts.change/0 forward\n\n14:09:02.262 [info] create table products\n\n14:09:02.273 [info] == Migrated 20250201185747 in 0.0s\n```\n\n----------------------------------------\n\nTITLE: Configuring Phoenix Socket Transports in Endpoint.ex\nDESCRIPTION: Elixir code snippet showing the default configuration for Phoenix WebSocket and Long-Polling transports in the endpoint.ex file. This configuration enables both types of transports with session information.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nsocket \"/live\", Phoenix.LiveView.Socket,\n  websocket: [connect_info: [session: @session_options]],\n  longpoll: [connect_info: [session: @session_options]]\n```\n\n----------------------------------------\n\nTITLE: External URL Redirect\nDESCRIPTION: Implementing a redirect to an external URL.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  redirect(conn, external: \"https://elixir-lang.org/\")\nend\n```\n\n----------------------------------------\n\nTITLE: Displaying Phoenix Application Directory Structure\nDESCRIPTION: Shows the top-level directory structure of a newly generated Phoenix application using the mix phx.new command.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/directory_structure.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nâââ _build\nâââ assets\nâââ config\nâââ deps\nâââ lib\nâ   âââ hello\nâ   âââ hello.ex\nâ   âââ hello_web\nâ   âââ hello_web.ex\nâââ priv\nâââ test\n```\n\n----------------------------------------\n\nTITLE: Phoenix Controller Integration for Page Views\nDESCRIPTION: Updates the show action in a Phoenix controller to increment page views when displaying a product.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n  def show(conn, %{\"id\" => id}) do\n    product =\n      id\n      |> Catalog.get_product!()\n      |> Catalog.inc_page_views()\n\n    render(conn, :show, product: product)\n  end\n```\n\n----------------------------------------\n\nTITLE: Fetching Dependencies after Authentication System Generation in Phoenix\nDESCRIPTION: Command to fetch additional dependencies installed by the authentication generator in mix.exs.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/mix_phx_gen_auth.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix deps.get\n```\n\n----------------------------------------\n\nTITLE: Defining a View Module in Phoenix (Elixir)\nDESCRIPTION: This snippet creates a new HelloHTML view module, which is responsible for rendering templates.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloHTML do\n  use HelloWeb, :html\nend\n```\n\n----------------------------------------\n\nTITLE: Alternative Exception Definition with Status\nDESCRIPTION: Custom exception definition with built-in plug_status field for HTTP status code\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.SomethingNotFoundError do\n  defexception [:message, plug_status: 404]\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Phoenix Controller Action\nDESCRIPTION: Simple controller action that renders a home template.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  render(conn, :home)\nend\n```\n\n----------------------------------------\n\nTITLE: Extracting HTTP Method from Plug.Conn in Elixir\nDESCRIPTION: This function extracts the HTTP method from the Plug.Conn struct in the event metadata. It's used as a tag_values function for Telemetry metrics to group by both method and route.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndefp get_and_put_http_method(%{conn: %{method: method}} = metadata) do\n  Map.put(metadata, :method, method)\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring LiveSocket with Long-Poll Fallback in JavaScript\nDESCRIPTION: JavaScript code snippet showing the configuration of a Phoenix LiveSocket with a fallback to long-polling after a specified timeout. This code is typically found in the generated app.js file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nlet liveSocket = new LiveSocket(\"/live\", Socket, {\n  longPollFallbackMs: 2500,\n  params: {_csrf_token: csrfToken}\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Page View Increment Usage in Elixir\nDESCRIPTION: Shows the intended usage pattern for the page view increment function.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nproduct = Catalog.inc_page_views(product)\n```\n\n----------------------------------------\n\nTITLE: Updating LineItem Schema Associations\nDESCRIPTION: Adding belongs_to associations in the LineItem schema\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n  schema \"order_line_items\" do\n    field :price, :decimal\n    field :quantity, :integer\n-   field :order_id, :id\n-   field :product_id, :id\n\n+   belongs_to :order, Hello.Orders.Order\n+   belongs_to :product, Hello.Catalog.Product\n\n    timestamps()\n  end\n```\n\n----------------------------------------\n\nTITLE: Signing Up for Fly.io Account\nDESCRIPTION: Command to sign up for a Fly.io account using the CLI.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ fly auth signup\n```\n\n----------------------------------------\n\nTITLE: Checking Application Logs\nDESCRIPTION: Command to view the logs of your deployed Gigalixir application for monitoring and debugging.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_17\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir logs\n```\n\n----------------------------------------\n\nTITLE: Configuring Elixir and Erlang Versions for Heroku\nDESCRIPTION: Content of the 'elixir_buildpack.config' file specifying Elixir and Erlang versions, and a post-compile hook for asset deployment.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n# Elixir version\nelixir_version=1.15.0\n\n# Erlang version\n# https://github.com/HashNuke/heroku-buildpack-elixir-otp-builds/blob/master/otp-versions\nerlang_version=25.3\n\n# Invoke assets.deploy defined in your mix.exs to deploy assets with esbuild\n# Note we nuke the esbuild executable from the image\nhook_post_compile=\"eval mix assets.deploy && rm -f _build/esbuild*\"\n```\n\n----------------------------------------\n\nTITLE: Empty Migration Module Structure in Ecto\nDESCRIPTION: Shows the initial structure of a generated migration file with the change/0 function that handles both migrations and rollbacks.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Repo.Migrations.AddCommentsTable do\n  use Ecto.Migration\n\n  def change do\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Up Remote Console Access\nDESCRIPTION: Commands to add your SSH key and open a remote console to your Gigalixir application for administrative tasks.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_19\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir account:ssh_keys:add \"$(cat ~/.ssh/id_rsa.pub)\"\n$ gigalixir ps:remote_console\n```\n\n----------------------------------------\n\nTITLE: Alternative Error Testing Approach\nDESCRIPTION: An alternative way to test for a not found error by specifically asserting the expected exception type rather than the HTTP status code.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nassert_raise Ecto.NotFoundError, fn ->\n  get(conn, ~p\"/posts/#{post}\")\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Broadcast in Phoenix Channel\nDESCRIPTION: Tests a broadcast in a Phoenix Channel by pushing a 'shout' event and asserting that the message was broadcast to all subscribers in the channel.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_channels.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ntest \"shout broadcasts to room:lobby\", %{socket: socket} do\n  push(socket, \"shout\", %{\"hello\" => \"all\"})\n  assert_broadcast \"shout\", %{\"hello\" => \"all\"}\nend\n```\n\n----------------------------------------\n\nTITLE: Executing Telemetry Event in Phoenix (Elixir)\nDESCRIPTION: Example of how Plug.Telemetry executes a Telemetry event after each request in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n:telemetry.execute([:phoenix, :endpoint, :stop], %{duration: duration}, %{conn: conn})\n```\n\n----------------------------------------\n\nTITLE: Example Product Data in Phoenix Form\nDESCRIPTION: Sample product data that was entered into the form, showing the structure of a product entity with its fields and values. The views field shows the default value of 0 being applied.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nProduct created successfully.\n\nTitle: Metaprogramming Elixir\nDescription: Write Less Code, Get More Done (and Have Fun!)\nPrice: 15.000000\nViews: 0\n```\n\n----------------------------------------\n\nTITLE: Generating Scoped LiveView Resource\nDESCRIPTION: Command to generate a LiveView resource that will utilize scoping\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.live Blog Post posts title:string body:text\n```\n\n----------------------------------------\n\nTITLE: Starting Phoenix Server\nDESCRIPTION: Command to start the Phoenix endpoint and run the server.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_umbrella/apps/app_name_web/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmix phx.server\n```\n\n----------------------------------------\n\nTITLE: Excluding Resource Routes with :except Option\nDESCRIPTION: Creating a resource with all standard routes except the delete action.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nresources \"/comments\", CommentController, except: [:delete]\n```\n\n----------------------------------------\n\nTITLE: Router Redirect Configuration\nDESCRIPTION: Router configuration for handling redirects.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Router do\n  ...\n\n  scope \"/\", HelloWeb do\n    ...\n    get \"/\", PageController, :home\n    get \"/redirect_test\", PageController, :redirect_test\n    ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Phoenix Server in Interactive Shell\nDESCRIPTION: Command for starting a Phoenix server in production mode inside an interactive Elixir shell (IEx). This allows for interacting with the running application through the Elixir shell.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/deployment.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ PORT=4001 MIX_ENV=prod iex -S mix phx.server\n10:59:19.136 [info] Running MyAppWeb.Endpoint with Cowboy on http://example.com\n```\n\n----------------------------------------\n\nTITLE: Running Migrations up to a Specific Version\nDESCRIPTION: Shows how to run migrations up to a specific version using the --to option with mix ecto.migrate.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_25\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate --to 20150317170448\n```\n\n----------------------------------------\n\nTITLE: Schema-Specific Test for Post Validation\nDESCRIPTION: This test verifies that the Post schema correctly validates the minimum title length using the errors_on helper from DataCase.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Blog.PostTest do\n  use Hello.DataCase, async: true\n  alias Hello.Blog.Post\n\n  test \"title must be at least two characters long\" do\n    changeset = Post.changeset(%Post{}, %{title: \"I\"})\n    assert %{title: [\"should be at least 2 character(s)\"]} = errors_on(changeset)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing ConnCase Setup Helper\nDESCRIPTION: Setup helper function for test connections that initializes session with scope information.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAppWeb.ConnCase do\n  ...\n\n  def put_scope_in_session(%{conn: conn}) do\n    id = System.unique_integer()\n    scope = MyApp.ScopeFixtures.session_scope_fixture(id)\n\n    conn =\n      conn\n      |> Phoenix.ConnTest.init_test_session(%{})\n      |> Plug.Conn.put_session(:scope_id, id)\n\n    %{conn: conn, scope: scope}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Mounting Organization Scoping in Phoenix LiveView\nDESCRIPTION: Defines on_mount functions to assign organization to scope based on URL parameters. Handles cases where the organization slug is present or not in the URL.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndef on_mount(:assign_org_to_scope, %{\"org\" => slug}, _session, socket) do\n  socket =\n    case socket.assigns.current_scope do\n      %{organization: nil} = scope ->\n        org = MyApp.Accounts.get_organization_by_slug!(socket.assigns.current_scope, slug)\n        Phoenix.Component.assign(socket, :current_scope, Scope.put_organization(scope, org))\n\n      _ ->\n        socket\n    end\n\n  {:cont, socket}\nend\n\ndef on_mount(:assign_org_to_scope, _params, _session, socket), do: {:cont, socket}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Generated Authentication System in Phoenix\nDESCRIPTION: Command to run tests to ensure the newly generated authentication system works as expected.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/mix_phx_gen_auth.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ mix test\n```\n\n----------------------------------------\n\nTITLE: Verifying Database Creation\nDESCRIPTION: Command to verify that a database was successfully created for your application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir pg\n```\n\n----------------------------------------\n\nTITLE: Running Database-Specific Tests\nDESCRIPTION: Commands to run tests with specific database dependencies using tags.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/integration_test/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ mix test --include database:postgresql\n$ mix test --include database:mysql\n$ mix test --include database:mssql\n$ mix test --include database:sqlite3\n```\n\n----------------------------------------\n\nTITLE: Phoenix Endpoint Configuration\nDESCRIPTION: Configuration snippet showing how to disable debug errors in development environment for Phoenix endpoint\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/custom_error_pages.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nimport Config\n\nconfig :hello, HelloWeb.Endpoint,\n  ...,\n  debug_errors: false,\n  code_reloader: true,\n  ...\n```\n\n----------------------------------------\n\nTITLE: Creating an Inline Template in Phoenix View (Elixir)\nDESCRIPTION: This code defines an inline template using the ~H sigil within the HelloHTML view module.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.HelloHTML do\n  use HelloWeb, :html\n\n  def index(assigns) do\n    ~H\"\"\"\n    Hello!\n    \"\"\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Migrations for Authentication System in Phoenix\nDESCRIPTION: Command to run pending repository migrations after generating the authentication system.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/mix_phx_gen_auth.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate\n```\n\n----------------------------------------\n\nTITLE: Generating Product Categories Migration\nDESCRIPTION: Creates a migration file for the product_categories join table to establish many-to-many relationships.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.gen.migration create_product_categories\n```\n\n----------------------------------------\n\nTITLE: Phoenix Endpoint Watcher Configuration\nDESCRIPTION: Configuration for Phoenix endpoint watchers to use custom build script.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :hello, HelloWeb.Endpoint,\n  ...\n  watchers: [\n    node: [\"build.js\", \"--watch\", cd: Path.expand(\"../assets\", __DIR__)]\n  ],\n  ...\n```\n\n----------------------------------------\n\nTITLE: BlogTest Context Test Module Structure\nDESCRIPTION: This code shows the basic structure of a context test module, including setup, aliases, and test organization using describe blocks.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.BlogTest do\n  use Hello.DataCase\n\n  alias Hello.Blog\n\n  describe \"posts\" do\n    alias Hello.Blog.Post\n\n    import Hello.BlogFixtures\n\n    @invalid_attrs %{body: nil, title: nil}\n\n    test \"list_posts/0 returns all posts\" do\n      post = post_fixture()\n      assert Blog.list_posts() == [post]\n    end\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Listing Files with External Dependency Versions in Phoenix Framework\nDESCRIPTION: This code snippet lists the files that contain external dependency versions that need to be updated when releasing a new version of Phoenix Framework.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/RELEASE.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n  * `priv/templates/phx.gen.release/Docker.eex` (debian)\n  * `priv/templates/phx.gen.release/Docker.eex` (esbuild)\n```\n\n----------------------------------------\n\nTITLE: Updating dependencies in mix.exs for MySQL\nDESCRIPTION: Modify the `deps` function in `mix.exs` to replace Postgrex with MyXQL for MySQL support in an existing Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/swapping_databases.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloPhoenix.MixProject do\n  use Mix.Project\n\n  ...\n  # Specifies your project dependencies.\n  #\n  # Type `mix help deps` for examples and options.\n  defp deps do\n    [\n      {:phoenix, \"~> 1.4.0\"},\n      {:phoenix_ecto, \"~> 4.4\"},\n      {:ecto_sql, \"~> 3.10\"},\n      {:myxql, \">= 0.0.0\"},\n      ...\n    ]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running database migrations\nDESCRIPTION: Execute `mix ecto.migrate` to run any pending database migrations on the MySQL database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/swapping_databases.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate\n[info] == Running HelloPhoenix.Repo.Migrations.CreateUser.change/0 forward\n[info] create table users\n[info] == Migrated in 0.2s\n```\n\n----------------------------------------\n\nTITLE: Implementing Product Categories Migration\nDESCRIPTION: Defines the schema for product_categories join table with foreign keys and indexes for data integrity.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/in_context_relationships.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Hello.Repo.Migrations.CreateProductCategories do\n  use Ecto.Migration\n\n  def change do\n    create table(:product_categories, primary_key: false) do\n      add :product_id, references(:products, on_delete: :delete_all)\n      add :category_id, references(:categories, on_delete: :delete_all)\n    end\n\n    create index(:product_categories, [:product_id])\n    create unique_index(:product_categories, [:category_id, :product_id])\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Viewing schema_migrations Table in PostgreSQL\nDESCRIPTION: Shows a SQL query result of the schema_migrations table which tracks all migrations that have been applied to the database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_23\n\nLANGUAGE: console\nCODE:\n```\nhello_dev=# select * from schema_migrations;\nversion        |     inserted_at\n---------------+---------------------\n20250317170448 | 2025-03-17 21:07:26\n20250318001628 | 2025-03-18 01:45:00\n(2 rows)\n```\n\n----------------------------------------\n\nTITLE: Installing Phoenix Project on macOS/Ubuntu\nDESCRIPTION: Command to create a new Phoenix project named 'hello' using the Phoenix Express installation script on macOS or Ubuntu systems.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/contexts.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ curl https://new.phoenixframework.org/hello | sh\n```\n\n----------------------------------------\n\nTITLE: Joining a Phoenix Channel\nDESCRIPTION: Example of a 'phx_join' event message to join the 'miami:weather' channel. It demonstrates the message format with a sample payload.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/writing_a_channels_client.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\"0\", \"0\", \"miami:weather\", \"phx_join\", {\"some\": \"param\"}]\n```\n\n----------------------------------------\n\nTITLE: Checking Node Clustering in IEx\nDESCRIPTION: Elixir code to check the list of connected nodes in an IEx shell.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\niex(my-app-1234@fdaa:0:1da8:a7b:ac2:cdf6:c422:2)1> Node.list\n```\n\n----------------------------------------\n\nTITLE: Executing Telemetry Event in Ecto (Elixir)\nDESCRIPTION: Example of how Ecto.Repo executes a Telemetry event when the repository starts.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n:telemetry.execute([:ecto, :repo, :init], %{system_time: System.system_time()}, %{repo: repo, opts: opts})\n```\n\n----------------------------------------\n\nTITLE: Alternative Show Action with Full Params Access\nDESCRIPTION: Demonstrates an alternative implementation of the show action that provides access to the full params map.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/request_lifecycle.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ndef show(conn, %{\"messenger\" => messenger} = params) do\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Fetching new dependencies after configuration\nDESCRIPTION: Run `mix deps.get` to fetch the new MySQL dependency after updating the configuration.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/swapping_databases.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ mix deps.get\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Tag Exclusions in ExUnit\nDESCRIPTION: Shows how to configure ExUnit to exclude certain tags by default in the test helper file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nExUnit.start(exclude: [error_view_case: true])\n\nEcto.Adapters.SQL.Sandbox.mode(Hello.Repo, :manual)\n```\n\n----------------------------------------\n\nTITLE: Defining Summary Metric for Phoenix Endpoint Duration (Elixir)\nDESCRIPTION: Example of defining a summary metric for Phoenix endpoint duration in the Telemetry supervisor.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nsummary(\"phoenix.endpoint.stop.duration\",\n  unit: {:native, :millisecond}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating the MySQL database\nDESCRIPTION: Use the `mix ecto.create` command to create the MySQL database for the Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/swapping_databases.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.create\n```\n\n----------------------------------------\n\nTITLE: Order HTML View Module Definition\nDESCRIPTION: Phoenix view module setup for order templates using embedded templates.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.OrderHTML do\n  use HelloWeb, :html\n\n  embed_templates \"order_html/*\"\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing API Token Verification Query in Elixir\nDESCRIPTION: Function added to the UserToken module to verify API tokens. It checks if the token is valid and returns a query to fetch the associated user.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/api_authentication.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n  @doc \"\"\"\n  Checks if the API token is valid and returns its underlying lookup query.\n\n  The query returns the user found by the token, if any.\n\n  The given token is valid if it matches its hashed counterpart in the\n  database and the user email has not changed. This function also checks\n  if the token is being used within 365 days.\n  \"\"\"\n  def verify_api_token_query(token) do\n    case Base.url_decode64(token, padding: false) do\n      {:ok, decoded_token} ->\n        hashed_token = :crypto.hash(@hash_algorithm, decoded_token)\n\n        query =\n          from token in by_token_and_context_query(hashed_token, \"api-token\"),\n            join: user in assoc(token, :user),\n            where:\n              token.inserted_at > ago(^@api_token_validity_in_days, \"day\") and\n                token.sent_to == user.email,\n            select: user\n\n        {:ok, query}\n\n      :error ->\n        :error\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Specifying Node.js Version for Gigalixir\nDESCRIPTION: Commands to specify Node.js version for your Gigalixir deployment by creating a phoenix_static_buildpack.config file.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ echo 'node_version=22.7.0' > phoenix_static_buildpack.config\n$ git add elixir_buildpack.config phoenix_static_buildpack.config assets/package.json\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies for Remix Icon in Elixir Mix File\nDESCRIPTION: This snippet shows how to replace the Heroicons dependency with Remix Icon in the project's mix.exs file. It specifies the GitHub repository, version tag, and other compilation options.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n{:remixicons,\n  github: \"Remix-Design/RemixIcon\",\n  sparse: \"icons\",\n  tag: \"v4.6.0\",\n  app: false,\n  compile: false,\n  depth: 1},\n```\n\n----------------------------------------\n\nTITLE: Testing API Error Response with cURL (Console)\nDESCRIPTION: This console command demonstrates how to test the API's error handling by sending a POST request with invalid data, expecting a JSON response with validation errors.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/json_and_apis.md#2025-04-21_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n$ curl -iX POST http://localhost:4000/api/urls \\\n   -H 'Content-Type: application/json' \\\n   -d '{\"url\": {}}'\n\n{\"errors\": {\"link\": [\"can't be blank\"], \"title\": [\"can't be blank\"]}}\n```\n\n----------------------------------------\n\nTITLE: Running Basic Test Suite\nDESCRIPTION: Command to run the basic test suite without database dependencies.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/integration_test/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mix test\n```\n\n----------------------------------------\n\nTITLE: Displaying lib/hello_web Directory Structure\nDESCRIPTION: Shows the directory structure of the lib/hello_web directory, which contains web-related parts of the Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/directory_structure.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\nlib/hello_web\nâââ controllers\nâ   âââ page_controller.ex\nâ   âââ page_html.ex\nâ   âââ error_html.ex\nâ   âââ error_json.ex\nâ   âââ page_html\nâ       âââ home.html.heex\nâââ components\nâ   âââ core_components.ex\nâ   âââ layouts.ex\nâ   âââ layouts\nâ       âââ root.html.heex\nâââ endpoint.ex\nâââ gettext.ex\nâââ router.ex\nâââ telemetry.ex\n```\n\n----------------------------------------\n\nTITLE: Transforming LiveView Metric Tag Values in Elixir\nDESCRIPTION: These functions transform the metadata for LiveView metrics, extracting the view name and connection status, and converting them to more readable formats for display.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndefp live_view_metric_tag_values(metadata) do\n  metadata\n  |> Map.put(:view, inspect(metadata.socket.view))\n  |> Map.put(:connected?, get_connection_status(Phoenix.LiveView.connected?(metadata.socket)))\nend\n\ndefp get_connection_status(true), do: \"Connected\"\ndefp get_connection_status(false), do: \"Disconnected\"\n```\n\n----------------------------------------\n\nTITLE: Running Phoenix Tests with mix test\nDESCRIPTION: This console command runs all tests in a Phoenix application, showing the total number of tests and their status.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ mix test\n................\n\nFinished in 0.6 seconds\n21 tests, 0 failures\n\nRandomized with seed 638414\n```\n\n----------------------------------------\n\nTITLE: Updating a Local Fork from Upstream in Git\nDESCRIPTION: Bash commands for keeping your local repository in sync with the upstream Phoenix repository to ensure you're working with the latest code.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\ngit pull upstream main\ngit push\n```\n\n----------------------------------------\n\nTITLE: Implementing Order Controller\nDESCRIPTION: Creating the OrderController with create action to handle order completion\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.OrderController do\n  use HelloWeb, :controller\n\n  alias Hello.Orders\n\n  def create(conn, _) do\n    case Orders.complete_order(conn.assigns.current_scope, conn.assigns.cart) do\n      {:ok, order} ->\n        conn\n        |> put_flash(:info, \"Order created successfully.\")\n        |> redirect(to: ~p\"/orders/#{order}\")\n\n      {:error, _reason} ->\n        conn\n        |> put_flash(:error, \"There was an error processing your order\")\n        |> redirect(to: ~p\"/cart\")\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Logging into Fly.io Account\nDESCRIPTION: Command to log into an existing Fly.io account using the CLI.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ fly auth login\n```\n\n----------------------------------------\n\nTITLE: Ecto Debug Log Output\nDESCRIPTION: Shows the SQL query generated by Ecto for atomic page view updates.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/your_first_context.md#2025-04-21_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n[debug] QUERY OK source=\"products\" db=0.5ms idle=834.5ms\nUPDATE \"products\" AS p0 SET \"views\" = p0.\"views\" + $1 WHERE (p0.\"id\" = $2) RETURNING p0.\"views\" [1, 1]\n```\n\n----------------------------------------\n\nTITLE: Resource Routes without Delete Action Output\nDESCRIPTION: Console output showing the routes generated for a resource with the delete action excluded.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/routing.md#2025-04-21_snippet_11\n\nLANGUAGE: console\nCODE:\n```\nGET    /comments           HelloWeb.CommentController :index\nGET    /comments/:id/edit  HelloWeb.CommentController :edit\nGET    /comments/new       HelloWeb.CommentController :new\nGET    /comments/:id       HelloWeb.CommentController :show\nPOST   /comments           HelloWeb.CommentController :create\nPATCH  /comments/:id       HelloWeb.CommentController :update\nPUT    /comments/:id       HelloWeb.CommentController :update\n```\n\n----------------------------------------\n\nTITLE: Starting Databases with Docker Compose\nDESCRIPTION: Command to start all supported databases locally using Docker Compose.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/integration_test/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Initializing a Git Repository for Phoenix Project\nDESCRIPTION: Commands to initialize a Git repository for a Phoenix project before deploying to Gigalixir.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ git init\n$ git add .\n$ git commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: ConnCase Module Definition\nDESCRIPTION: Definition of ConnCase module that provides testing utilities for Phoenix controller tests\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ConnCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # The default endpoint for testing\n      @endpoint HelloWeb.Endpoint\n\n      use HelloWeb, :verified_routes\n\n      # Import conveniences for testing with connections\n      import Plug.Conn\n      import Phoenix.ConnTest\n      import HelloWeb.ConnCase\n    end\n  end\n  \n  setup tags do\n    Hello.DataCase.setup_sandbox(tags)\n    {:ok, conn: Phoenix.ConnTest.build_conn()}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Checking Environment Configuration\nDESCRIPTION: Command to verify that DATABASE_URL and POOL_SIZE environment variables were properly created.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir config\n```\n\n----------------------------------------\n\nTITLE: Generating Authentication Boilerplate with mix phx.gen.auth in Elixir\nDESCRIPTION: Command to generate authentication boilerplate using mix phx.gen.auth in a Phoenix application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/api_authentication.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.auth Accounts User users\n```\n\n----------------------------------------\n\nTITLE: XML Content Type Response\nDESCRIPTION: Example of rendering XML content with appropriate content type.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/controllers.md#2025-04-21_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\ndef home(conn, _params) do\n  conn\n  |> put_resp_content_type(\"text/xml\")\n  |> render(:home, content: some_xml_content)\nend\n```\n\n----------------------------------------\n\nTITLE: Changing to Project Directory\nDESCRIPTION: Command to navigate into the newly created Phoenix project directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/up_and_running.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ cd hello\n```\n\n----------------------------------------\n\nTITLE: Channel Message Flow Diagram (Plain Text)\nDESCRIPTION: A diagram showing how messages flow between clients, channel servers, and PubSub systems in a Phoenix Channels implementation. It illustrates the basic connection topology for real-time communication.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/real_time/channels.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n                                                                  +----------------+\n                                                     +--Topic X-->| Mobile Client  |\n                                                     |            +----------------+\n                              +-------------------+  |\n+----------------+            |                   |  |            +----------------+\n| Browser Client |--Topic X-->| Phoenix Server(s) |--+--Topic X-->| Desktop Client |\n+----------------+            |                   |  |            +----------------+\n                              +-------------------+  |\n                                                     |            +----------------+\n                                                     +--Topic X-->|   IoT Client   |\n                                                                  +----------------+\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Timeout\nDESCRIPTION: Phoenix endpoint configuration to handle WebSocket timeout for Heroku's 55-second timeout window\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :hello\n\n  socket \"/socket\", HelloWeb.UserSocket,\n    websocket: [timeout: 45_000]\n\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring npm Deploy Script for Phoenix Assets\nDESCRIPTION: JavaScript code snippet for the 'package.json' file to define a deploy script for Phoenix assets when using the Phoenix Static buildpack.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  ...\n  \"scripts\": {\n    \"deploy\": \"cd .. && mix assets.deploy && rm -f _build/esbuild*\"\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Database for Partitioning in Phoenix\nDESCRIPTION: Demonstrates how to set up the test database name to support test partitioning in Phoenix applications.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\ndatabase: \"hello_test#{System.get_env(\"MIX_TEST_PARTITION\")}\",\n```\n\n----------------------------------------\n\nTITLE: Defining Basic User Scope Structure\nDESCRIPTION: Implementation of a basic scope module that associates data with authenticated users\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.Scope do\n  alias MyApp.Accounts.User\n\n  defstruct user: nil\n\n  def for_user(%User{} = user) do\n    %__MODULE__{user: user}\n  end\n\n  def for_user(nil), do: nil\nend\n```\n\n----------------------------------------\n\nTITLE: Committing Version Configuration\nDESCRIPTION: Command to commit the version configuration files to Git before deployment.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ git commit -m \"Set versions\"\n```\n\n----------------------------------------\n\nTITLE: Adding Telemetry Server to Supervision Tree in Elixir\nDESCRIPTION: Configuration code to add the telemetry-enabled server to the application's supervision tree with an initial greeting function.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/telemetry.md#2025-04-21_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\nchildren = [\n  # Start a server that greets the world\n  {MyApp.MyServer, fn -> \"Hello, world!\" end},\n]\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations in Phoenix\nDESCRIPTION: Executing the ecto.migrate command to apply the migrations for creating carts and cart_items tables, showing the creation of tables and indexes with timestamps.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate\n\n16:59:51.941 [info] == Running 20250205203342 Hello.Repo.Migrations.CreateCarts.change/0 forward\n\n16:59:51.945 [info] create table carts\n\n16:59:51.952 [info] == Migrated 20250205203342 in 0.0s\n\n16:59:51.988 [info] == Running 20250205213410 Hello.Repo.Migrations.CreateCartItems.change/0 forward\n\n16:59:51.988 [info] create table cart_items\n\n16:59:52.000 [info] create index cart_items_product_id_index\n\n16:59:52.001 [info] create index cart_items_cart_id_product_id_index\n\n16:59:52.002 [info] == Migrated 20250205213410 in 0.0s\n```\n\n----------------------------------------\n\nTITLE: Rebasing a Topic Branch on Main\nDESCRIPTION: Bash commands for updating your topic branch by rebasing on the latest main branch from upstream, which keeps your changes current and resolves conflicts.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\ngit pull upstream main\ngit checkout <your-topic-branch>\ngit rebase main\n```\n\n----------------------------------------\n\nTITLE: Running Specific Number of Migrations with Step Option\nDESCRIPTION: Demonstrates running a specific number of pending migrations using the -n or --step option with mix ecto.migrate.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_24\n\nLANGUAGE: console\nCODE:\n```\n$ mix ecto.migrate -n 2\n[info] == Running Hello.Repo.Migrations.CreatePost.change/0 forward\n[info] create table posts\n[info] == Migrated in 0.0s\n[info] == Running Hello.Repo.Migrations.AddCommentsTable.change/0 forward\n[info] create table comments\n[info] == Migrated in 0.0s\n```\n\n----------------------------------------\n\nTITLE: Heroku Connection Timeout Error Example\nDESCRIPTION: Example of a connection timeout error when running Heroku commands, typically occurring when port 5000 is blocked by the internet provider.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_14\n\nLANGUAGE: console\nCODE:\n```\nheroku run \"POOL_SIZE=2 mix myapp.task\"\nRunning POOL_SIZE=2 mix myapp.task on mysterious-meadow-6277... !\nETIMEDOUT: connect ETIMEDOUT 50.19.103.36:5000\n```\n\n----------------------------------------\n\nTITLE: Adding Individual Test Tags in Elixir\nDESCRIPTION: Demonstrates how to add tags to individual tests within a test module in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ErrorHTMLTest do\n  use HelloWeb.ConnCase, async: true\n\n  @moduletag :error_view_case\n\n  # Bring render/4 and render_to_string/4 for testing custom views\n  import Phoenix.Template\n\n  @tag individual_test: \"yup\"\n  test \"renders 404.html\" do\n    assert render_to_string(HelloWeb.ErrorView, \"404\", \"html\", []) ==\n           \"Not Found\"\n  end\n\n  @tag individual_test: \"nope\"\n  test \"renders 500.html\" do\n    assert render_to_string(HelloWeb.ErrorView, \"500\", \"html\", []) ==\n           \"Internal Server Error\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a New Phoenix Application\nDESCRIPTION: Command to create a new Phoenix application using Mix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.new my_app\n```\n\n----------------------------------------\n\nTITLE: Modifying LineItems Migration Schema\nDESCRIPTION: Database migration changes to add precision and scale to the price decimal field in line items\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n  def change do\n    create table(:order_line_items) do\n-     add :price, :decimal\n+     add :price, :decimal, precision: 15, scale: 6, null: false\n      add :quantity, :integer\n      add :order_id, references(:orders, on_delete: :nothing)\n      add :product_id, references(:products, on_delete: :nothing)\n\n      timestamps()\n    end\n\n    create index(:order_line_items, [:order_id])\n    create index(:order_line_items, [:product_id])\n  end\n```\n\n----------------------------------------\n\nTITLE: Generating LineItem Context\nDESCRIPTION: Console command to generate the LineItem schema and context with price and quantity fields\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.context Orders LineItem order_line_items \\\nprice:decimal quantity:integer \\\norder_id:references:orders product_id:references:products --no-scope\n```\n\n----------------------------------------\n\nTITLE: Pushing a Topic Branch to a Fork\nDESCRIPTION: Bash command for pushing your topic branch to your fork on GitHub in preparation for creating a pull request.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit push origin <topic-branch-name>\n```\n\n----------------------------------------\n\nTITLE: CSS Background Image Reference\nDESCRIPTION: Example of referencing an external image file in CSS.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_3\n\nLANGUAGE: css\nCODE:\n```\nbody {\n  background-image: url(/images/bg.png);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Phoenix Static Buildpack to Heroku\nDESCRIPTION: Command to add the Phoenix Static buildpack to handle Node.js and npm for asset management in a Phoenix application on Heroku.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ heroku buildpacks:add https://github.com/gigalixir/gigalixir-buildpack-phoenix-static.git\n```\n\n----------------------------------------\n\nTITLE: Installing Phoenix Project on Windows\nDESCRIPTION: Command to create a new Phoenix project named 'hello' using the Phoenix Express installation script on Windows PowerShell.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/contexts.md#2025-04-21_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\n> curl.exe -fsSO https://new.phoenixframework.org/hello.bat; .\\hello.bat\n```\n\n----------------------------------------\n\nTITLE: Updating Icon Component for Remix Icon in Elixir\nDESCRIPTION: This snippet modifies the icon function in the core_components.ex file to work with Remix Icon. It changes the pattern matching to look for 'ri-' prefixes and updates the HTML structure for rendering icons.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n@doc \"\"\"\nRenders a [Remix Icon](https://remixicon.com).\n\nYou can customize the size and colors of the icons by\nsetting width, height, and background color classes.\n\n## Examples\n\n    <.icon name=\"ri-github-fill\" />\n    <.icon name=\"ri-github\" class=\"ml-1 w-3 h-3 animate-spin\" />\n\"\"\"\nattr :name, :string, required: true\nattr :class, :string, default: \"size-5\"\n\ndef icon(%{name: \"ri-\" <> _} = assigns) do\n  ~H\"\"\"\n  <i class={[@name, @class]} aria-hidden=\"true\"></i>\n  \"\"\"\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Phoenix Project from Source (Bash)\nDESCRIPTION: Steps to create a new Phoenix project using the latest source installer. This involves removing existing archives, cloning the repo, and running the phx.new Mix task.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd phoenix/installer\nmix phx.new dev_app --dev\n```\n\n----------------------------------------\n\nTITLE: Aliasing Scope Module in IEx Configuration\nDESCRIPTION: Shows how to alias the Scope module in the project's .iex.exs file for easier access in the interactive Elixir shell.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\nalias MyApp.Accounts.Scope\n```\n\n----------------------------------------\n\nTITLE: Defining JSON View Module in Phoenix\nDESCRIPTION: Elixir module defining functions to convert articles into JSON format for index and show actions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ArticleJSON do\n  alias Hello.News.Article\n\n  def index(%{articles: articles}) do\n    %{data: for(article <- articles, do: data(article))}\n  end\n\n  def show(%{article: article}) do\n    %{data: data(article)}\n  end\n\n  defp data(%Article{} = article) do\n    %{\n      id: article.id,\n      title: article.title,\n      body: article.body\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Debugging Heroku Compilation Error for Phoenix Dependencies\nDESCRIPTION: Example of a compilation error output when deploying to Heroku, typically caused by stale dependencies not being recompiled properly. The error specifically shows a failure in compiling the Postgrex dependency.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_12\n\nLANGUAGE: console\nCODE:\n```\nremote: == Compilation error on file lib/postgrex/connection.ex ==\nremote: could not compile dependency :postgrex, \"mix compile\" failed. You can recompile this dependency with \"mix deps.compile postgrex\", update it with \"mix deps.update postgrex\" or clean it with \"mix deps.clean postgrex\"\nremote: ** (CompileError) lib/postgrex/connection.ex:207: Postgrex.Connection.__struct__/0 is undefined, cannot expand struct Postgrex.Connection\nremote:     (elixir) src/elixir_map.erl:58: :elixir_map.translate_struct/4\nremote:     (stdlib) lists.erl:1353: :lists.mapfoldl/3\nremote:     (stdlib) lists.erl:1354: :lists.mapfoldl/3\nremote:\nremote:\nremote:  !     Push rejected, failed to compile elixir app\nremote:\nremote: Verifying deploy...\nremote:\nremote: !   Push rejected to mysterious-meadow-6277.\nremote:\nTo https://git.heroku.com/mysterious-meadow-6277.git\n```\n\n----------------------------------------\n\nTITLE: Creating Heroku Application with Elixir Buildpack\nDESCRIPTION: Command to create a new Heroku application using the Elixir buildpack, which provides basic Elixir support for the app.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/heroku.md#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ heroku create --buildpack hashnuke/elixir\n```\n\n----------------------------------------\n\nTITLE: Scope Configuration in Phoenix\nDESCRIPTION: Default scope configuration in Phoenix application\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\n# config/config.exs\nconfig :my_app, :scopes,\n  user: [\n    default: true,\n    ...\n  ]\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Existing Phoenix Framework Generator\nDESCRIPTION: Command to remove any previously installed versions of the Phoenix Framework generator before installing a new version. This prevents conflicts between different versions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ mix archive.uninstall phx_new\n```\n\n----------------------------------------\n\nTITLE: Documenting Modules in Elixir with @moduledoc Annotations\nDESCRIPTION: Example of how to write proper module documentation in Phoenix, demonstrating the convention of using the first paragraph as a concise summary of the module's purpose.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Phoenix.HTML do\n  @moduledoc \"\"\"\n  Conveniences for working HTML strings and templates.\n  ...\n  \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Gigalixir Application\nDESCRIPTION: Command to create a new application on Gigalixir with a custom name. The app name cannot be changed after creation.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir create -n \"your-app-name\"\n```\n\n----------------------------------------\n\nTITLE: Building Phoenix Framework (Bash)\nDESCRIPTION: Steps to build the Phoenix framework from source, including fetching dependencies and compiling the project.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmix deps.get\nmix compile\n```\n\n----------------------------------------\n\nTITLE: Upgrading Account and Creating a Production Database\nDESCRIPTION: Commands to upgrade your Gigalixir account to Standard Tier and provision a production-ready database.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir account:upgrade\n$ gigalixir pg:create\n```\n\n----------------------------------------\n\nTITLE: Adding JS Dependency via Mix\nDESCRIPTION: Example of adding a JavaScript dependency through Mix configuration.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/asset_management.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n{:topbar, github: \"buunguyen/topbar\", app: false, compile: false}\n```\n\n----------------------------------------\n\nTITLE: Displaying App Module Name in Elixir Template\nDESCRIPTION: An Elixir EEx template tag that displays the value of the @app_module variable, typically used in auto-generated project files from Phoenix framework.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_umbrella/apps/app_name/README.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n<%= @app_module %>\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Data for Create Action in Phoenix JSON Controller\nDESCRIPTION: Elixir test case verifying error handling when creating an article with invalid data in a JSON controller.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_controllers.md#2025-04-21_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ntest \"renders errors when data is invalid\", %{conn: conn} do\n  conn = post(conn, ~p\"/api/articles\", article: @invalid_attrs)\n  assert json_response(conn, 422)[\"errors\"] != %{}\nend\n```\n\n----------------------------------------\n\nTITLE: Cloning and Configuring a Git Fork for Phoenix Contribution\nDESCRIPTION: Bash commands for forking the Phoenix repository, cloning it locally, and configuring the upstream remote to prepare for contributions.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Clone your fork of the repo into the current directory\ngit clone https://github.com/<your-username>/phoenix\n\n# Navigate to the newly cloned directory\ncd phoenix\n\n# Assign the original repo to a remote called \"upstream\"\ngit remote add upstream https://github.com/phoenixframework/phoenix\n```\n\n----------------------------------------\n\nTITLE: Creating Scope Test Fixtures\nDESCRIPTION: Test fixture module implementation for creating test scopes with unique identifiers.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/authn_authz/scopes.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.ScopeFixtures do\n  alias MyApp.Scope\n\n  def session_scope_fixture(id \\\\ System.unique_integer()) do\n    %Scope{id: id}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations\nDESCRIPTION: Command to run database migrations on your deployed Gigalixir application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_16\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir ps:migrate\n```\n\n----------------------------------------\n\nTITLE: Generated HTML for File Input\nDESCRIPTION: Shows the rendered HTML output for the file input field using Phoenix CoreComponents.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/howto/file_uploads.md#2025-04-21_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<div>\n  <label for=\"product_photo\" class=\"block text-sm...\">Photo</label>\n  <input type=\"file\" name=\"product[photo]\" id=\"product_photo\" class=\"mt-2 block w-full...\">\n</div>\n```\n\n----------------------------------------\n\nTITLE: Creating a Changeset with Valid Parameters in Elixir IEx\nDESCRIPTION: This snippet shows how to create a changeset with valid parameters and extra keys, demonstrating that extra keys are stripped from the final changeset.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/ecto.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\niex> params = %{name: \"Joe Example\", email: \"joe@example.com\", bio: \"An example to all\", number_of_pets: 5, random_key: \"random value\"}\n%{\n  bio: \"An example to all\",\n  email: \"joe@example.com\",\n  name: \"Joe Example\",\n  number_of_pets: 5,\n  random_key: \"random value\"\n}\n\niex> changeset = User.changeset(%User{}, params)\n#Ecto.Changeset<\n  action: nil,\n  changes: %{\n    bio: \"An example to all\",\n    email: \"joe@example.com\",\n    name: \"Joe Example\",\n    number_of_pets: 5\n  },\n  errors: [],\n  data: #Hello.User<>,\n  valid?: true\n>\n```\n\n----------------------------------------\n\nTITLE: Provisioning a Free Database on Gigalixir\nDESCRIPTION: Command to create a free PostgreSQL database for your Gigalixir application.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir pg:create --free\n```\n\n----------------------------------------\n\nTITLE: Running Phoenix Tests\nDESCRIPTION: Bash command for running the Phoenix test suite to ensure your changes don't break existing functionality.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmix test\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Clustering\nDESCRIPTION: Environment variables to set in rel/env.ssh.eex for clustering Elixir nodes on Fly.io.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/fly.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nexport ERL_AFLAGS=\"-proto_dist inet6_tcp\"\nexport RELEASE_DISTRIBUTION=\"name\"\nexport RELEASE_NODE=\"${FLY_APP_NAME}-${FLY_IMAGE_REF##*-}@${FLY_PRIVATE_IP}\"\n\nexport ECTO_IPV6=\"true\"\nexport DNS_CLUSTER_QUERY=\"${FLY_APP_NAME}.internal\"\n```\n\n----------------------------------------\n\nTITLE: Adding Module Tag with Custom Value in Elixir\nDESCRIPTION: Shows how to add a module tag with a custom value to a test module in Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.ErrorHTMLTest do\n  use HelloWeb.ConnCase, async: true\n\n  @moduletag error_view_case: \"some_interesting_value\"\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Opening the Deployed Application\nDESCRIPTION: Command to open your deployed application in a web browser.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_18\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir open\n```\n\n----------------------------------------\n\nTITLE: Cart Template Complete Order Button Addition\nDESCRIPTION: Template modification to add a complete order button to the shopping cart view.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/more_examples.md#2025-04-21_snippet_14\n\nLANGUAGE: heex\nCODE:\n```\n  <.header>\n    My Cart\n   <:actions>\n     <.button href={~p\"/orders\"} method=\"post\">\n       Complete order\n     </.button>\n   </:actions>\n  </.header>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Mix\nDESCRIPTION: Command to install project dependencies using Mix package manager.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/integration_test/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mix deps.get\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Resource for Comments\nDESCRIPTION: This command would generate another resource in the same Blog context with a relationship to posts, demonstrating how contexts can group multiple schemas.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/testing/testing_contexts.md#2025-04-21_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.gen.html Blog Comment comments post_id:references:posts body:text\n```\n\n----------------------------------------\n\nTITLE: Configuring robots.txt for Phoenix Application with Disabled Crawler Blocking\nDESCRIPTION: This robots.txt file provides a template for controlling web crawler access to a Phoenix application. It includes commented-out directives that would block all crawlers from the entire site if uncommented. In its current state, the file doesn't restrict any crawler access.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/templates/phx_static/robots.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file\n#\n# To ban all spiders from the entire site uncomment the next two lines:\n# User-agent: *\n# Disallow: /\n```\n\n----------------------------------------\n\nTITLE: Checking Deployment Status\nDESCRIPTION: Command to check the status of your deployment and wait until the app is healthy.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/deployment/gigalixir.md#2025-04-21_snippet_15\n\nLANGUAGE: console\nCODE:\n```\n$ gigalixir ps\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Phoenix Framework Generator Locally\nDESCRIPTION: Commands to build and install the Phoenix Framework generator from source code. This sequence navigates to the installer directory and creates an archive in production mode before installing it.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/installer/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cd installer\n$ MIX_ENV=prod mix do archive.build, archive.install\n```\n\n----------------------------------------\n\nTITLE: Building Phoenix Documentation (Bash)\nDESCRIPTION: Commands to build the Phoenix framework documentation, including installing npm dependencies and running the mix docs task.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --prefix assets\nMIX_ENV=docs mix docs\n```\n\n----------------------------------------\n\nTITLE: Building Phoenix Installer (Bash)\nDESCRIPTION: Commands to build the Phoenix installer, including fetching dependencies, compiling, and creating an archive.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmix deps.get\nmix compile\nmix archive.build\n```\n\n----------------------------------------\n\nTITLE: Checking Elixir and Erlang Versions using Console\nDESCRIPTION: Command to verify the installed versions of Elixir and Erlang. Ensures that the system meets the minimum requirements of Elixir 1.15 and Erlang 24.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/introduction/installation.md#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nelixir -v\nErlang/OTP 24 [erts-12.0] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nElixir 1.15.0\n```\n\n----------------------------------------\n\nTITLE: Creating Cart View in Phoenix\nDESCRIPTION: Implements the CartHTML view module with a helper function for currency formatting. It also embeds templates from the cart_html directory.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/cross_context_boundaries.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule HelloWeb.CartHTML do\n  use HelloWeb, :html\n\n  alias Hello.ShoppingCart\n\n  embed_templates \"cart_html/*\"\n\n  def currency_to_str(%Decimal{} = val), do: \"$#{Decimal.round(val, 2)}\"\nend\n```\n\n----------------------------------------\n\nTITLE: Listing Files with Version Information in Phoenix Framework\nDESCRIPTION: This code snippet lists the files that need to be updated with the new version number when releasing a new version of Phoenix Framework.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/RELEASE.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n  * `CHANGELOG`\n  * `mix.exs`\n  * `installer/mix.exs`\n  * `package.json`\n  * `assets/package.json`\n```\n\n----------------------------------------\n\nTITLE: Creating a Topic Branch for Phoenix Development\nDESCRIPTION: Bash command for creating a new topic branch off of main to contain your feature, change, or fix when contributing to Phoenix.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b <topic-branch-name>\n```\n\n----------------------------------------\n\nTITLE: Creating Phoenix Project Using Mix\nDESCRIPTION: Alternative command to create a new Phoenix project named 'hello' using the mix phx.new generator command.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/guides/data_modelling/contexts.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ mix phx.new hello\n```\n\n----------------------------------------\n\nTITLE: Building Phoenix.js (Bash)\nDESCRIPTION: Steps to build the Phoenix.js component, involving changing to the assets directory and installing npm dependencies.\nSOURCE: https://github.com/phoenixframework/phoenix/blob/main/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd assets\nnpm install\n```"
  }
]