[
  {
    "owner": "pthom",
    "repo": "litgen",
    "content": "TITLE: Configuring and Running litgen Code Generation - Python\nDESCRIPTION: This Python snippet imports the litgen library, sets up several LitgenOptions to control how C++ code is converted to Python bindings and stubs, defines an example C++ code block as a string, and calls litgen_demo.demo to process the example. Dependencies include the 'litgen' library and its 'demo' submodule. Key options handle namespace-root exclusion, snake-case conversion, API marker customization, macro handling, and inclusion of non-API functions. The C++ code block showcases a namespace, various function and struct declarations, and a preprocessor macro to illustrate litgen's capabilities. Inputs consist of configuration options and the C++ code string; the main output is the display of generated bindings and Python stubs in the interactive notebook.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/01_05_05_online.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\n\n# This namespace will not be outputted as a python module\noptions.namespaces_root = [\"MyNamespace\"]\n# All functions, modules and namespaces names are converted to snake case\noptions.python_convert_to_snake_case = True\n# This is an API marker in the C++ code (for shared libraries code)\noptions.srcmlcpp_options.functions_api_prefixes = \"^MY_API$\"\n# Also create bindings for functions that do not have the API marker\noptions.fn_exclude_non_api = False\n# Optional comment that can be added to non API functions\noptions.fn_non_api_comment = \"\"\n# \"Box\" immutable functions parameter when they should be modifiable\noptions.fn_params_replace_modifiable_immutable_by_boxed__regex = r\".*\"\n# Which numeric and string preprocessor do we want to export\noptions.macro_define_include_by_name__regex = \"^MY_\"\n\ncode = \"\"\"\n// This namespace is not outputed as a submodule, since it is marked as Root (see options.namespaces_root)\nnamespace MyNamespace \n{\n    // Multiplies a list of double by a given factor, returns updated list\n    std::vector<double> MultiplyDoubles(const std::vector<double>& v, float k);\n\n    // changes the value of the bool parameter (passed by modifiable reference)\n    // (This function will use a BoxedBool in the python code, so that its value can be modified)\n    void SwitchBoolValue(bool &v);\n    \n    // Standalone comment blocs are also exported\n\n    // This function includes an API marker which will be ignored when generating the bindings\n    MY_API int MySubstract(int a, int b); // eol doc is also included in bindings doc\n\n    namespace MyMath // This namespace is not ignored and introduces a new python module\n    {\n        // div and mul: divide or multiply float numbers\n        // (This comment concerns the two grouped \n        // functions below, and will be exported as such)\n        float Div(float a, float b); // Divide\n        float Mul(float a, float b); // Multiply\n    }\n\n    // Stores Pixel coordinates\n    struct Pixel\n    {\n        // Coordinates\n        double x = 2., y = 3.;\n\n        // Draw a pixel\n        void Draw(Image& i);\n\n        private:\n        double _Norm(); // this will not be exported as it is private\n    };\n\n    // This macro value be exported, as it matches the regex macro_define_include_by_name__regex\n    #define MY_VALUE 123\n}\n\"\"\"\n\nlitgen_demo.demo(\n    options, code, show_cpp=False, show_pydef=True, height=80\n)\n```\n\n----------------------------------------\n\nTITLE: Generating C++ Bindings for Functions with litgen in Python\nDESCRIPTION: This snippet shows how to import the litgen package, instantiate LitgenOptions, define C++ function declarations including default parameters, and generate binding code and Python stub declarations using litgen.generate_code. It highlights that the output includes Python stub code for IDE support and pybind11 C++ binding code. The snippet requires the litgen Python package and a valid C++ code string as input, producing a structure containing stub_code, pydef_code, and glue_code as output.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_00_00_first_steps.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Import litgen\nimport litgen\n\n\n# Instantiate some options\noptions = litgen.LitgenOptions()\n# Code for which we will emit bindings\ncpp_code = \"\"\"\n    // Mathematic operations\n\n    // Adds two integers\n    int Add(int x, int y = 2);\n\n    int Sub(int x, int y = 2); // Substract two integers\n    \"\"\"\n# Run the generator\ngenerated_code = litgen.generate_code(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Generating litgen Bindings for a Single C++ Header (Python)\nDESCRIPTION: Python code extract demonstrating the use of `litgen.write_generated_code_for_file` to generate Python bindings. It takes configured options, a single input C++ header file, and paths for the output C++ binding definitions (`pydef`), Python stubs (`pyi`), and C++ glue code files.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/example_bindings/DasLib/Readme.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n    litgen.write_generated_code_for_file(\n        options,\n        input_cpp_header_file=input_cpp_header,               # in this case we will use the amalgamation header\n        output_cpp_pydef_file=output_cpp_pydef_file,\n        output_stub_pyi_file=output_stub_pyi_file,\n        output_cpp_glue_code_file=output_cpp_glue_code_file\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Litgen: Template Function Specialization (@overload)\nDESCRIPTION: This snippet shows how to use `fn_template_options` to specialize a template function for specific types (int and float). Litgen will then correctly generate the bindings and add an `@overload` decorator to the Python functions.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noptions.fn_template_options.add_specialization(\"^MaxValue$\", [\"int\", \"float\"], add_suffix_to_function_name=False)\n\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Generating Bindings for a Single File using LitGen\nDESCRIPTION: This Python snippet demonstrates how to use LitGen to generate bindings for a single C++ header file.  It uses the `litgen.write_generated_code_for_file` function, specifying input and output file paths. This function generates C++ pydef, glue code, and Python stub files.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/example_bindings/DasLib/Readme.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n    litgen.write_generated_code_for_file(\n        options,\n        input_cpp_header_file=input_cpp_header,               # in this case we will use the amalgamation header\n        output_cpp_pydef_file=output_cpp_pydef_file,\n        output_stub_pyi_file=output_stub_pyi_file,\n        output_cpp_glue_code_file=output_cpp_glue_code_file\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Layout Settings for Python and C++ Code Generation in Litgen\nDESCRIPTION: This class defines various options for customizing the layout and formatting of generated Python and C++ code using the Litgen tool. It includes parameters for indentation size, whether to use tabs, line length limits, and whether to run formatters like Black. The configuration also controls how original signatures and locations are displayed, as well as C++ indentation preferences.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/03_05_00_code_layout.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n################################################################################\n    #    <Layout settings for the generated python stub code>\n    ################################################################################\n    #    <show the original location and or signature of elements as a comment>\n    original_location_flag_show = False\n    # if showing location, how many parent folders shall be shown\n    # (if -1, show the full path)\n    original_location_nb_parent_folders = 0\n    # If True, the complete C++ original signature will be show as a comment in the python stub (pyi)\n    original_signature_flag_show = False\n    # Size of an indentation in the python stubs\n    python_indent_size = 4\n    python_ident_with_tabs: bool = False\n    # Insert as many empty lines in the python stub as found in the header file, keep comments layout, etc.\n    python_reproduce_cpp_layout: bool = True\n    # The generated code will try to adhere to this max length (if negative, this is ignored)\n    python_max_line_length = 80\n    # Strip (remove) empty comment lines\n    python_strip_empty_comment_lines: bool = False\n    # Run black formatter\n    python_run_black_formatter: bool = False\n    python_black_formatter_line_length: int = 88\n\n    ################################################################################\n    #    <Layout settings for the C++ generated pydef code>\n    ################################################################################\n    # Spacing option in C++ code\n    cpp_indent_size: int = 4\n    cpp_indent_with_tabs: bool = False\n\n```\n\n----------------------------------------\n\nTITLE: Binding a Simple Class or Struct with litgen_demo - Python\nDESCRIPTION: This example shows how to bind C++ classes and structs using litgen. It sets up options, constructs C++ code representing a class and a struct, and invokes 'litgen_demo.demo' to generate and display the bindings. Dependencies are litgen and litgen.demo.litgen_demo. Key parameters are 'options' and the C++ code string. Public members and methods are exposed; for structs a constructor with named parameters is generated. The effect is generation and display of stub and binding code.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_00_00_first_steps.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\ncpp_code = \"\"\"\nclass FooClass {\n    private:\n        int mPriv = 0;\n    public:\n        FooClass(int v);\n        int mPublic = 1;\n        void ShowInfo();\n};\n\nstruct FooStruc {\n    int a = 1;\n    void ShowInfo();\n};\n\"\"\"\n\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Extending Type Replacements for Custom C++ Types (Python)\nDESCRIPTION: Shows how to add custom regex-based type replacements so that user-defined template types are mapped to Python typing equivalents. Requires litgen and a configured options object. Adds a replacement to options.type_replacements for transforming MyPair<T1, T2> into Tuple[T1, T2]. Executes litgen_demo.demo with the updated options. Inputs: regex replacement rules, C++ code string. Output: improved Python bindings for custom types.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/04_05_00_names_translation.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.type_replacements.add_last_replacement(\n    r\"MyPair<(.*),\\s*(.*)>\", # this is a regex, with 2 captures\n    r\"Tuple[\\1, \\2]\"         # and this is the replacement\n)\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Importing litgen and Generating Bindings - Python\nDESCRIPTION: This snippet demonstrates importing the litgen package, instantiating litgen options, and generating bindings for a C++ code snippet. Dependencies include the litgen package. 'options' represents customizable generation options, and 'cpp_code' is a string containing the C++ source for which Python bindings and stubs will be generated. The expected output is a GeneratedCode object containing stub code (Python stubs), pydef code (pybind11 C++ binding code), and glue code if required.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_00_00_first_steps.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Import litgen\nimport litgen\n\n# Instantiate some options\noptions = litgen.LitgenOptions()\n# Code for which we will emit bindings\ncpp_code = \"\"\"\n    // Mathematic operations\n\n    // Adds two integers\n    int Add(int x, int y = 2);\n\n    int Sub(int x, int y = 2); // Substract two integers\n    \"\"\"\n# Run the generator\ngenerated_code = litgen.generate_code(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Making Enums Arithmetic in Python with litgen\nDESCRIPTION: Illustrates configuring litgen to treat a specific C++ `enum class` (`Foo`) as arithmetic in the generated Python bindings. This is achieved by setting the `enum_make_arithmetic__regex` option in `LitgenOptions` to match the enum name. This allows implicit conversion of enum members to their underlying integer values in Python. The `show_pydef=True` argument in `litgen_demo.demo` is used to display the generated Python definition.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_enums.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n    enum class Foo { A, B, C};\n\"\"\"\noptions = litgen.LitgenOptions()\noptions.enum_make_arithmetic__regex = \"^Foo$\"\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Litgen Demo with Snake Case Conversion\nDESCRIPTION: This snippet shows how litgen automatically converts CamelCase names to snake_case for functions, variables, and namespaces by default. It uses the C++ code snippet defined earlier and the default `LitgenOptions`.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/04_05_00_names_translation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport litgen\n\noptions = litgen.LitgenOptions()\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Binding Simple C++ Classes and Structs with litgen in Python\nDESCRIPTION: This snippet shows how to bind a simple C++ class and a struct using litgen by defining them as multiline strings assigned to cpp_code, setting up options, and using litgen_demo to generate and display the bindings. It demonstrates that public members and methods of classes are exposed, while structs expose constructors with named parameters. The snippet requires the litgen package and litgen_demo for visualization.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_00_00_first_steps.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\ncpp_code = \"\"\"\nclass FooClass {\n    private:\n        int mPriv = 0;\n    public:\n        FooClass(int v);\n        int mPublic = 1;\n        void ShowInfo();\n};\n\nstruct FooStruc {\n    int a = 1;\n    void ShowInfo();\n};\n\"\"\"\n\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Customizing Header Filtering Regex in litgen (Python)\nDESCRIPTION: Demonstrates how to customize header filtering in litgen. It initializes `LitgenOptions`, modifies the `srcmlcpp_options.header_filter_acceptable__regex` to include the `COMMON_OPTION` preprocessor directive alongside default header guards (`_H$`), and then runs the demo again to show that code within `#ifdef COMMON_OPTION` is now processed.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\n\n# the default value for header_filter_acceptable__regex was\n#     \"__cplusplus|_h_$|_h$|_H$|_H_$|hpp$|HPP$|hxx$|HXX$\"\n# (which includes support for common header guards)\n# Let's add support for COMMON_OPTION\noptions.srcmlcpp_options.header_filter_acceptable__regex = \"_H$|^COMMON_OPTION$\"\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Configuring litgen for Snake Case Conversion (Python)\nDESCRIPTION: Illustrates the default usage of litgen to convert C++ method and variable names (CamelCase) to snake_case in generated Python bindings. Requires litgen, litgen.demo, and a C++ code string as input. Outputs Python-styled bindings. No special option—relies on default settings.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/04_05_00_names_translation.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\n\noptions = litgen.LitgenOptions()\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Snake Case Conversion in litgen (Python)\nDESCRIPTION: Configures litgen to retain original C++ case formatting for names by setting the python_convert_to_snake_case option to False. Requires a LitgenOptions instance. After changing the flag, passes options and cpp_code to litgen_demo.demo. Inputs: C++ code string. Output: Python bindings with names unmodified from the C++ source.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/04_05_00_names_translation.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\noptions.python_convert_to_snake_case = False\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Example C++ pybind File Structure with litgen Markers\nDESCRIPTION: Showcases the structure of a `pybind11` C++ binding file (`pybind_DasLib.cpp`) generated by `litgen`. It includes necessary headers (`pybind11`, the original library header `DasLib.h`, and the glue code header `glue_code_DasLib.h`) and defines a function `py_init_module_das_lib` where the autogenerated binding code will be placed between the `<litgen_pydef>` markers.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/example_bindings/DasLib/Readme.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/pybind11.h>\n\n#include \"DasLib/DasLib.h\"\n#include \"glue_code_DasLib.h\"\n\nnamespace py = pybind11;\n\nvoid py_init_module_das_lib(py::module& m)\n{\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // <litgen_pydef> // Autogenerated code below! Do not edit!\n    // Code will be generated here...\n    // </litgen_pydef> // Autogenerated code end\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing C++ Code into CppElement Tree using srcmlcpp (Python)\nDESCRIPTION: This snippet shows how to use the srcmlcpp package to parse a string of C++ source code into a CppElement tree in Python. It demonstrates setting up parsing options, invoking the code_to_cpp_unit parser, and producing a tree structure usable for further inspection or manipulation. Prerequisites include installing the srcmlcpp Python package and ensuring the srcML command line tool is available. The input is a multi-line C++ code string; the output is a CppElement object tree representing the code's AST.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_00_00_cpp_intro.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ncode = \"\"\"\n// A Demo struct\nstruct Foo\n{\n    const int answer(int *v=nullptr); // Returns the answer\n};\n\"\"\"\n\n```\n\nLANGUAGE: Python\nCODE:\n```\nimport srcmlcpp\n\noptions = srcmlcpp.SrcmlcppOptions()\ncpp_unit = srcmlcpp.code_to_cpp_unit(options, code)\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Module (Python)\nDESCRIPTION: Demonstrates how to import the 'daft_lib' module, which contains the generated bindings for the DaftLib C++ library, and calls the `add` function.  This shows basic usage after a successful install.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport daft_lib\ndaft_lib.add(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Configuring macro name replacements in Litgen for macro export\nDESCRIPTION: This code demonstrates configuring Litgen options to include macros matching a regex pattern and applying a renaming rule to suppress a macro prefix. The renaming pattern uses a regex to match macros starting with \"MYLIB_\" and captures the suffix for renaming, resulting in cleaner variable names in the generated Python module.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/09_05_00_preprocessor.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.macro_define_include_by_name__regex = \"^MYLIB_\"\n# Suppress the \"MYLIB_\" prefix:\noptions.macro_name_replacements.add_first_replacement(r\"^MYLIB_([A-Z_]*)\", r\"\\1\")\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Example Python Script for Validating Litgen Generated Bindings\nDESCRIPTION: This Python script demonstrates the process of validating C++ code bindings generated by Litgen, including customization of binding options, specifying test code in Python, and running validation for different binding libraries such as nanobind. It sets up a testing environment that compiles C++ code, generates Python bindings, and runs Python tests to ensure correctness. The script depends on the 'litgen' package and the 'validate_bindings_compilation' module, utilizing options for binding customization.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/validate_bindings_compilation/Readme.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.validate_bindings_compilation.validate_bindings_compilation import validate_bindings_compilation\n\ndef main() -> None:\n    # Validates that the cpp code can be compiled into bindings and\n    # that the generated Python bindings work as expected.\n    # **This kind of test is slow**, do not use it extensively in CI.\n    # return\n    code = \"\"\"\n#include <vector>\n\nstd::vector<int> range(int i) {\n    std::vector<int> v;\n    for (int j = 0; j < i; j++) {\n        v.push_back(j);\n    }\n    return v;\n}\n\n    \"\"\"\n    python_test_code = \"\"\"\nimport validate_bindings_compilation\n\ndef test_validate_bindings_compilation() -> None:\n    c = validate_bindings_compilation.range(5)\n    assert c == [0, 1, 2, 3, 4]\n\"\"\"\n\n    # for bind_type in litgen.BindLibraryType:\n    for bind_type in [litgen.BindLibraryType.nanobind]:\n        options = litgen.LitgenOptions()\n        options.fn_params_replace_buffer_by_array__regex = r\".*\"\n        options.bind_library = bind_type\n        options.fn_params_adapt_mutable_param_with_default_value__regex = r\".*\"\n\n        success = validate_bindings_compilation(\n            cpp_code=code,\n            options=options,\n            remove_build_dir_on_success=False,\n            python_test_code=python_test_code,\n            show_logs=True,\n            python_module_name=\"validate_bindings_compilation\",\n            # work_dir=\"/Users/pascal/dvp/OpenSource/ImGuiWork/_Bundle/litgen/src/litgen/tests/internal/ppp\",\n            # enable_hack_code=True,\n        )\n        assert success\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n----------------------------------------\n\nTITLE: Conditionally Running Binding Autogeneration Script (CMake)\nDESCRIPTION: Defines a custom target `autogenerate_mylib` to execute a Python script (`autogenerate_mylib.py`) for generating binding code. This generation step is skipped if the `SKBUILD` variable is defined (e.g., during pip installation). It depends on the `Python_EXECUTABLE` variable being set and adds a dependency to ensure generation happens before the `mylib` library is built.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n####################################################\n# Regenerate bindings before building\n####################################################\nif (NOT SKBUILD) # Do not run autogenerate when running pip install\n    set(run_autogenerate ON)\nendif()\nif (run_autogenerate)\n    if (NOT DEFINED Python_EXECUTABLE)\n        message(FATAL_ERROR \"Python_EXECUTABLE not defined. litgen_find_pybind11 probably failed.\")\n    endif()\n    add_custom_target(\n        autogenerate_mylib ALL\n        COMMAND\n        ${Python_EXECUTABLE} ${CMAKE_CURRENT_LIST_DIR}/autogenerate_mylib.py no_generate_file_by_file\n        WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}\n    )\n    add_dependencies(mylib autogenerate_mylib)    # Make sure autogenerate is run before building the lib\nendif()\n```\n\n----------------------------------------\n\nTITLE: Preprocessing C++ Headers with Custom Function in Litgen Python\nDESCRIPTION: This snippet defines a custom preprocessing function 'preprocess_change_int' that replaces all occurrences of \"int\" with \"Int32\" in the C++ source code before code generation. The function is assigned to the 'code_preprocess_function' option in Litgen, and the demo function is run with the modified C++ code. Required dependencies: 'litgen', 'litgen.demo' module. Inputs: original C++ code string. Outputs: processed code as handled by Litgen. Limitation: preprocessing is done with a simple text replacement and may not cover complex cases.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/11_05_00_post_processing.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef preprocess_change_int(code: str) -> str:\n    return code.replace(\"int\", \"Int32\")  # This is a *very* dumb preprocessor\n\n\ncpp_code = \"\"\"\nint add(int, int b);\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.code_preprocess_function = preprocess_change_int\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Generated Python Binding Function Stub\nDESCRIPTION: A Python function stub generated by litgen that provides a documented interface to the corresponding C++ function. It includes inline comments derived from the original C++ signature for clarity and ease of use within Python IDEs, supporting type hints and documentation accessibility.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/00_00_intro.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Parameters stacks (current window)\n# IMGUI_API void          PushItemWidth(float item_width);        /* original C++ signature */\ndef push_item_width(item_width: float) -> None:\n    \"\"\"push width of items for common large \"item+label\" widgets. >0.0: width in pixels, <0.0 align xx pixels to the right of window (so -FLT_MIN always align width to the right side).\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Visualizing Generated Python Stubs and C++ Bindings using litgen Demo in Python\nDESCRIPTION: This snippet demonstrates usage of the litgen_demo helper from the litgen.demo module to visualize the outputs of generated bindings. It imports the demo facility and calls litgen_demo.demo with litgen options and C++ code, enabling display of original C++ code, Python stub declarations, and pybind11 binding code. This aids in understanding binding results but is not required for typical generation workflows.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_00_00_first_steps.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litgen.demo import litgen_demo\n\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n\n# Below, you will see:\n# - the original C++ code to the left\n# - stub_code (i.e. the python stubs) to the right\n# - pydef_code (i.e. the C++ binding code) at the bottom\n# In this case, the glue code is empty \n```\n\n----------------------------------------\n\nTITLE: Running litgen Demo with Default Filtering Options (Python)\nDESCRIPTION: Imports the `litgen` library and its demo module. It then initializes default `LitgenOptions` and runs the `litgen_demo.demo` function using the previously defined `cpp_code` to show the default behavior of header filtering, which typically excludes content within conditional compilation blocks not matching standard header guards.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Python Stub Example\nDESCRIPTION: This is a Python stub file generated by litgen, providing documentation and function signatures for the C++ bindings. It shows the expected input and output types, along with a docstring describing the function. This file enables IDE auto-completion and provides documentation to Python users.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/00_00_intro.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Parameters stacks (current window)\n# IMGUI_API void          PushItemWidth(float item_width);        /* original C++ signature */\ndef push_item_width(item_width: float) -> None:\n    \"\"\"push width of items for common large \"item+label\" widgets. >0.0: width in pixels, <0.0 align xx pixels to the right of window (so -FLT_MIN always align width to the right side).\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Litgen: Class Template Specialization\nDESCRIPTION: Shows how to use `class_template_options` to specialize the `ImVector` template class for specific types (`ImGuiConfig`, `float *`, `int32_t`). It also demonstrates how to emit a synonym (`ImVector_Int32 = ImVector_int`) in the Python stub.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\noptions.class_template_options.add_specialization(\n        \"ImVector\",  # which class do we want to specialize\n        [\"ImGuiConfig\", \"float *\", \"int32_t\"],  # for which types\n        [\"Int32=uint32_t\"]  # With which synonyms\n        )\n```\n\n----------------------------------------\n\nTITLE: Filtering Header Content based on Preprocessor Directives (litgen)\nDESCRIPTION: This snippet demonstrates how to filter header content based on preprocessor directives like `#ifdef` using litgen. It initializes `LitgenOptions` and uses a regular expression to define acceptable header filters, allowing for selective processing of code blocks based on preprocessor conditions. The `litgen_demo.demo` function is used to simulate the code generation process.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Litgen: Template Class Instantiation Demo\nDESCRIPTION: Demonstrates a complete example of template class instantiation with type replacements and specializations. It shows how litgen handles the generation of bindings for a class containing template members.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n\n    struct ImGuiConfig { /* implementation not shown here */ };\n\n    template<typename T>\n    struct ImVector\n    {\n        // Implementation not shown here\n    private:\n        T* data;\n    };\n\n    struct Foo\n    {\n        ImVector<ImGuiConfig> Configs; // This member will be added to the bindings\n        ImVector<int> IntValues;       // This member will be excluded from the bindings, since ImVector<int> is not published!\n    };\n\"\"\"\n\noptions = litgen.LitgenOptions()\noptions.type_replacements.add_last_replacement(r\"ImGui([A-Z][a-zA-Z0-9]*)\", r\"\\1\")  # Remove prefix ImGui from exposed type\noptions.class_template_options.add_specialization(\n    \"ImVector\",                             # which class do we want to specialize\n    [\"ImGuiConfig\", \"float *\", \"int32_t\"],  # for which types\n    [\"Int32=uint32_t\"],                     # With which synonyms\n)\nlitgen_demo.demo(options, cpp_code)\n\n# Note: the warnings below are normal, since we did not specialize ImVector<int> (they can be filtered out, see below)\n```\n\n----------------------------------------\n\nTITLE: Processing C++ Code and Handling litgen Warnings - Python\nDESCRIPTION: This snippet illustrates how to configure litgen options and generate code from a C++ header file, capturing any warnings that arise during the process. Dependencies include a valid litgen installation and the presence of the specified header file. The main input is the file path, and the output is generated code, along with warnings shown in the standard output.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/10_05_00_ignore_warnings.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\ngenerated_code = litgen.generate_code_for_file(options, \"10_05_10_sample_code.h\")\n\n```\n\n----------------------------------------\n\nTITLE: Generating amalgamation header for Hello ImGui in Python\nDESCRIPTION: Demonstrates how to use the AmalgamationOptions class to generate an amalgamation header for the Hello ImGui library. It specifies which headers to include and where to write the output file.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_10_amalgamation.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom codemanip import amalgamated_header\n\noptions = amalgamated_header.AmalgamationOptions()\noptions.base_dir = hello_imgui_src_dir                # The base directory of the headers\noptions.local_includes_startwith = \"hello_imgui/\"     # Only headers whose name begin with \"hello_imgui\" should be included\noptions.include_subdirs = [\"hello_imgui\"]             # Include only headers in the hello_imgui directory\noptions.main_header_file = \"hello_imgui.h\"            # The main header file\noptions.dst_amalgamated_header_file = PYDEF_DIR + \"/hello_imgui_amalgamation.h\"  # The destination file\n\namalgamated_header.write_amalgamate_header_file(options)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Preprocessing Function for litgen (Python)\nDESCRIPTION: Defines a Python function `preprocess_change_int` that takes a string (source code) as input and returns a modified string where all occurrences of \"int\" are replaced with \"Int32\". This function serves as a simple example of a custom code preprocessor for litgen.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef preprocess_change_int(code: str) -> str:\n    return code.replace(\"int\", \"Int32\")  # This is a *very* dumb preprocessor\n```\n\n----------------------------------------\n\nTITLE: Generating Bindings for Classic C Enum\nDESCRIPTION: This code snippet demonstrates how to use litgen to generate Python bindings for a classic C enum. It shows how litgen automatically removes prefixes from enum values (e.g., `Foo::Foo_a` becomes `Foo.a`), preserves comments, handles enum numbering, and allows setting macro values.  The `litgen_demo.demo` function is used to generate the bindings based on the provided C++ code and litgen options.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_enums.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n// Doc about Foo\n// On several lines\nenum Foo\n{\n    Foo_a, // This is a\n\n    // And this is b and c's comment\n    Foo_b,\n    Foo_c = MY_VALUE,\n\n    Foo_d = Foo_a | Foo_b + Foo_c, // And a computed value\n\n    Foo_e = 4,\n\n    Foo_count, // And this is count: by default this member is suppressed\n};\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.named_number_macros = {\"MY_VALUE\": 256}\n# options.enum_flag_skip_count = False # Uncomment this to generate a definition for Foo::Foo_count\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating litgen Code Layout Settings and Generation (Python)\nDESCRIPTION: This snippet demonstrates how to set layout-related options using the litgen library to control code generation for both Python and C++ outputs. It constructs an options object, configures indentation and formatting flags, specifies whether to show original signatures, and uses a demonstration function to generate and display code. Dependencies: 'litgen' and 'litgen.demo' modules. Key parameters include 'cpp_indent_with_tabs', 'cpp_indent_size', 'python_indent_size', 'python_run_black_formatter', and 'original_signature_flag_show'. Inputs: a C++ code string to convert; Outputs: generated code layouts, shown with specified settings. This code is intended for demonstration and prototyping purposes.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/03_05_00_code_layout.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\ncpp_code = \"\"\"\n    int add(int a, int b); // Adds two numbers\n\"\"\"\n\noptions.cpp_indent_with_tabs = True            # The C++ code will be indented with \noptions.cpp_indent_size = 1                    # one tab\n\noptions.python_indent_size = 2                 # The python code will be indented with 2 spaces\noptions.python_run_black_formatter = False     # (if black is disabled)\n\noptions.original_signature_flag_show = True    # We will show the original C++ signatures in the python stubs\n\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Generating an Amalgamated C++ Header using codemanip (Python)\nDESCRIPTION: Python function `make_amalgamated_header` that uses `codemanip.amalgamated_header` module to create a single, combined (amalgamated) C++ header file. It configures `AmalgamationOptions` specifying the base directory, include patterns, subdirectories, main header, and the destination file path, then calls `write_amalgamate_header_file`.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/example_bindings/DasLib/Readme.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom codemanip import amalgamated_header\n\ndef make_amalgamated_header():\n    \"\"\"Generates an amalgamated header file for DasLib in generated_code/DasLib_amalgamation/amalgamation.h\"\"\"\n    options = amalgamated_header.AmalgamationOptions()\n\n    options.base_dir = THIS_DIR + \"/cpp_sources\"\n    options.local_includes_startwith = \"DasLib/\"\n    options.include_subdirs = [\"DasLib\"]\n    options.main_header_file = \"DasLib.h\"\n    options.dst_amalgamated_header_file = THIS_DIR + \"/generated_code/DasLib_amalgamation/amalgamation.h\"\n\n    amalgamated_header.write_amalgamate_header_file(options)\n```\n\n----------------------------------------\n\nTITLE: Complete Litgen Namespace Configuration Example\nDESCRIPTION: A comprehensive example showing C++ code with multiple namespaces and Litgen configuration to handle them, including root namespace definition, namespace exclusion via regex patterns, and processing of multiple occurrences of the same namespace.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/08_05_00_namespaces.ipynb#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid FooRoot();  // A function in the root namespace\n\nnamespace details // This namespace should be excluded (see options.namespace_exclude__regex)\n{\n    void FooDetails();\n}\n\nnamespace // This anonymous namespace should be excluded\n{\n    void LocalFunction();\n}\n\n// This namespace should not be outputted as a submodule,\n// since it is present in options.namespaces_root \nnamespace Main\n{\n    // this is an inner namespace (this comment should become the namespace doc)\n    namespace Inner\n    {\n        void FooInner();\n    }\n\n    // This is a second occurrence of the same inner namespace\n    // The generated python module will merge these occurrences\n    // (and this comment will be ignored, since the Inner namespace already has a doc)\n    namespace Inner\n    {\n        void FooInner2();\n    }\n}\n```\n\nLANGUAGE: python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.namespaces_root = [\"Main\"]\n# options.namespace_exclude__regex = r\"[Ii]nternal|[Dd]etail\"  # this is the default!\noptions.python_run_black_formatter = True\n# options.python_convert_to_snake_case = False  # uncomment this in order to keep the original namespaces and functions names\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Demonstration of Applying Layout Options to Generate Python and C++ Code\nDESCRIPTION: This snippet shows how to instantiate the Litgen options, set specific formatting preferences such as indentation style and visibility of signatures, and then execute a demo function to generate code based on C++ input. It exemplifies configuring the tool to produce indented C++ with tabs and Python with custom indentation, along with the option to display original signatures.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/03_05_00_code_layout.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\ncpp_code = \"\"\"\n    int add(int a, int b); // Adds two numbers\n\"\"\"\n\noptions.cpp_indent_with_tabs = True            # The C++ code will be indented with \noptions.cpp_indent_size = 1                    # one tab\n\noptions.python_indent_size = 2                 # The python code will be indented with 2 spaces\noptions.python_run_black_formatter = False     # (if black is disabled)\n\noptions.original_signature_flag_show = True    # We will show the original C++ signatures in the python stubs\n\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Setting macro value for array size in Litgen options\nDESCRIPTION: This snippet illustrates configuring Litgen options to specify the numeric value of a macro that determines the size of an array member. By setting the macro value (e.g., 'MY_COUNT' to 256), Litgen can generate correct bindings for structures that depend on macro-defined sizes, such as static array members.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/09_05_00_preprocessor.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n#define MY_COUNT 256\n\nstruct Foo\n{\n    int values[MY_COUNT];\n};\n\"\"\"\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.named_number_macros[\"MY_COUNT\"] = 256\n\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Configuring litgen Generator Options for Handling Modifiable Immutable Parameters in Python\nDESCRIPTION: This snippet illustrates how to configure litgen to emit additional glue code when binding functions that modify parameters whose types are immutable in Python. By setting the regex option 'fn_params_replace_modifiable_immutable_by_boxed__regex' to a pattern matching all functions, the generator will adapt such parameters by using boxed types (e.g., BoxedBool) in Python bindings to allow modification. It requires setting the option before running the generator and providing appropriate C++ function declarations as input.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_00_00_first_steps.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\n# This a regex which specifies that we want to adapt all functions with boxed types when needed\noptions.fn_params_replace_modifiable_immutable_by_boxed__regex = r\".*\"\ncpp_code = \"\"\"\n    // changes the value of the bool parameter (passed by modifiable reference)\n    // (This function will use a BoxedBool in the python code, so that its value can be modified)\n    void SwitchBoolValue(bool &v);\n    \"\"\"\n# Run the generator\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Pybind11 Module Initialization in C++\nDESCRIPTION: This C++ snippet demonstrates how to initialize a pybind11 module using LitGen.  It includes necessary headers and defines a function `py_init_module_das_lib` to initialize the module with auto-generated code. The auto-generated code section is marked by specific comments.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/example_bindings/DasLib/Readme.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <pybind11/pybind11.h>\n\n#include \"DasLib/DasLib.h\"\n#include \"glue_code_DasLib.h\"\n\nnamespace py = pybind11;\n\nvoid py_init_module_das_lib(py::module& m)\n{\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // <litgen_pydef> // Autogenerated code below! Do not edit!\n    // Code will be generated here...\n    // </litgen_pydef> // Autogenerated code end\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n}\n\n```\n\n----------------------------------------\n\nTITLE: Preprocessing Header Code (litgen)\nDESCRIPTION: This snippet demonstrates how to preprocess header code using a custom function. The `code_preprocess_function` option is set to a function that replaces all occurrences of \"int\" with \"Int32\". This allows you to modify the source code before litgen processes it.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef preprocess_change_int(code: str) -> str:\n    return code.replace(\"int\", \"Int32\")  # This is a *very* dumb preprocessor\n\n\ncpp_code = \"\"\"\nint add(int, int b);\n\"\"\"\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.code_preprocess_function = preprocess_change_int\ngenerated_code = litgen.generate_code(options, cpp_code)\nlitgen_demo.show_cpp_code(generated_code.stub_code)\n```\n\n----------------------------------------\n\nTITLE: Defining Code Layout Options for Python Stub and C++ Pydef Generation (Python)\nDESCRIPTION: This snippet declares configuration variables controlling formatting and layout for generated Python stub files and C++ pydef code in litgen. It includes options for showing original code locations or signatures, adjusting indentation style/size, controlling comment layout, running code formatters such as black, and managing line length constraints. No external dependencies are required, but these options typically reside in a settings or options module that feeds into litgen’s code generation routines. The configuration supports both flexibility and adherence to project-specific conventions; set parameters before initiating code generation. Limitations: These are static assignments, not executable configuration within the snippet.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/03_05_00_code_layout.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n################################################################################\n#    <Layout settings for the generated python stub code>\n################################################################################\n#    <show the original location and or signature of elements as a comment>\noriginal_location_flag_show = False\n# if showing location, how many parent folders shall be shown\n# (if -1, show the full path)\noriginal_location_nb_parent_folders = 0\n# If True, the complete C++ original signature will be show as a comment in the python stub (pyi)\noriginal_signature_flag_show = False\n# Size of an indentation in the python stubs\npython_indent_size = 4\npython_ident_with_tabs: bool = False\n# Insert as many empty lines in the python stub as found in the header file, keep comments layout, etc.\npython_reproduce_cpp_layout: bool = True\n# The generated code will try to adhere to this max length (if negative, this is ignored)\npython_max_line_length = 80\n# Strip (remove) empty comment lines\npython_strip_empty_comment_lines: bool = False\n# Run black formatter\npython_run_black_formatter: bool = False\npython_black_formatter_line_length: int = 88\n\n################################################################################\n#    <Layout settings for the C++ generated pydef code>\n################################################################################\n# Spacing option in C++ code\ncpp_indent_size: int = 4\ncpp_indent_with_tabs: bool = False\n```\n\n----------------------------------------\n\nTITLE: Converting C++ Code to CppUnit with srcmlcpp\nDESCRIPTION: This snippet demonstrates how to convert C++ code represented as a string into a `CppUnit` object using `srcmlcpp`. The `code_to_cpp_unit` function is used with specified options to perform the conversion. The C++ code is parsed and represented in a structured format suitable for further analysis and transformation.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncode = \"\"\"\nint AddNumbers(const MyModule_Class& c);\n\"\"\"\n\nimport srcmlcpp\n\noptions = srcmlcpp.SrcmlcppOptions()\ncpp_unit = srcmlcpp.code_to_cpp_unit(options, code)\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Enum Classes using litgen in Python\nDESCRIPTION: Shows how litgen binds a C++ `enum class` named `Foo`. Similar to classic enums, it handles values defined via macros (`MY_VALUE`) configured in `LitgenOptions`, and computed enum values (`D`). The example uses `litgen_demo.demo` to generate and display the bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_enums.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n    enum class Foo\n    {\n        A,\n        B,\n        C = MY_VALUE,\n        D = A | B + C,\n        E = 4,\n        F\n    };\n\"\"\"\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.named_number_macros = {\"MY_VALUE\": 256}\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Basic Template Function Example (Unhandled)\nDESCRIPTION: A simple example showing how litgen will complain when encountering an unhandled template function.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_templates.ipynb#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T> T MaxValue(const std::vector<T>& values);\n```\n\nLANGUAGE: python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\ngenerated_code = litgen.generate_code(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Generating an Amalgamated Header with Codemanip\nDESCRIPTION: This Python snippet uses the `codemanip` library to generate an amalgamated header file from multiple C++ header files. It configures options like base directory, include prefixes, and destination file path. This creates a single header file that includes all necessary declarations.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/example_bindings/DasLib/Readme.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom codemanip import amalgamated_header\n\ndef make_amalgamated_header():\n    \"\"\"Generates an amalgamated header file for DasLib in generated_code/DasLib_amalgamation/amalgamation.h\"\"\"\n    options = amalgamated_header.AmalgamationOptions()\n\n    options.base_dir = THIS_DIR + \"/cpp_sources\"\n    options.local_includes_startwith = \"DasLib/\"\n    options.include_subdirs = [\"DasLib\"]\n    options.main_header_file = \"DasLib.h\"\n    options.dst_amalgamated_header_file = THIS_DIR + \"/generated_code/DasLib_amalgamation/amalgamation.h\"\n\n    amalgamated_header.write_amalgamate_header_file(options)\n\n```\n\n----------------------------------------\n\nTITLE: Example Python Stub File Structure with litgen Markers\nDESCRIPTION: Demonstrates the structure of a Python stub file (`.pyi`) generated by `litgen` (e.g., `das_lib.pyi`). It includes a `# type: ignore` directive and uses `<litgen_stub>` markers to indicate the section where autogenerated Python type hints and function signatures will be placed.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/example_bindings/DasLib/Readme.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# type: ignore\n\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n# <litgen_stub> // Autogenerated code below! Do not edit!\n# Code will be generated here...\n# </litgen_stub>\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n```\n\n----------------------------------------\n\nTITLE: C++ Template Function Definition\nDESCRIPTION: Defines a C++ template function `MaxValue` that returns the maximum value in a vector of type `T`. This example is used to demonstrate how litgen handles unhandled template functions.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T> T MaxValue(const std::vector<T>& values);\n```\n\n----------------------------------------\n\nTITLE: Configuring litgen to Process Functions with Specific API Prefix (Python)\nDESCRIPTION: Initializes `LitgenOptions` and sets the `srcmlcpp_options.functions_api_prefixes` attribute to \"MY_API\". This configures litgen to recognize `MY_API` as the marker for functions to be included in the generated bindings when processing the C++ code. The demo function is called to illustrate the result.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.functions_api_prefixes = \"MY_API\"\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Regenerating C++ Code from CppElement Tree using str_code (Python)\nDESCRIPTION: This snippet demonstrates accessing the str_code method of a CppElement object to regenerate C++ code from the AST in Python. It uses litgen_demo.show_cpp_code for display, typically preserving code structure and comments with slight differences from the original source. This requires the litgen package and a previously constructed CppElement object (cpp_unit). The input is a CppElement AST; the output is generated C++ code shown to the user.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_00_00_cpp_intro.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom litgen.demo import litgen_demo\n\nlitgen_demo.show_cpp_code(cpp_unit.str_code())\n\n```\n\n----------------------------------------\n\nTITLE: Applying source code transformations to C++ AST elements\nDESCRIPTION: Defines functions to modify function names to snake_case and convert type names starting with 'MyModule_' to include a namespace. Implements a visitor that applies these transformations to each relevant AST node during traversal, facilitating batch code refactoring.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_05_00_cpp_simple_transformations.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom srcmlcpp import CppFunctionDecl, CppType  # import the types we want to apply transformations to\nfrom codemanip import code_utils  # for to_snake_case\n\ndef change_function_to_snake_case(cpp_function: CppFunctionDecl):\n    \"\"\"Change a function name to snake_case\"\"\"\n    cpp_function.function_name = code_utils.to_snake_case(cpp_function.function_name)\n    cpp_function.cpp_element_comments.comment_on_previous_lines += \"Was changed to snake case!\"\n\n\ndef make_my_module_namespace(cpp_type: CppType):\n    \"\"\"If a type starts with MyModule_, replace it by MyModule::\"\"\"\n\n    def change_typename(typename: str):\n        if typename.startswith(\"MyModule_\"):\n            return typename.replace(\"MyModule_\", \"MyModule::\")\n        else:\n            return typename\n\n    cpp_type.typenames = [change_typename(typename) for typename in cpp_type.typenames]\n\n\ndef my_refactor_visitor(cpp_element: srcmlcpp.CppElement, event: srcmlcpp.CppElementsVisitorEvent, depth: int) -> None:\n    \"\"\"Our visitor will apply the transformation\"\"\"\n    if event == srcmlcpp.CppElementsVisitorEvent.OnElement:\n        if isinstance(cpp_element, CppFunctionDecl):\n            change_function_to_snake_case(cpp_element)\n        elif isinstance(cpp_element, CppType):\n            make_my_module_namespace(cpp_element)\n```\n\n----------------------------------------\n\nTITLE: Template Function with @overload Decorator\nDESCRIPTION: Example of specializing a template function for multiple types without adding a suffix to the function name. This will generate Python functions with @overload decorators.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_templates.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\noptions.fn_template_options.add_specialization(\"^MaxValue$\", [\"int\", \"float\"], add_suffix_to_function_name=False)\n\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Namespace and Class Structure Example (Python String Literal)\nDESCRIPTION: Defines a multi-line Python string literal representing a C++ namespace with a struct containing a method and a member variable. This string is intended as input to litgen for demonstrating name formatting behavior. No dependencies; standalone definition.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/04_05_00_names_translation.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\nnamespace MyNamespace\n{\n    struct MyClass\n    {\n        int AddNumber(int a, int b);\n\n        int MultiplierRatio = 4;\n    };\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Template Class Instantiation with Type Specialization\nDESCRIPTION: A comprehensive example showing how to instantiate template classes for specific types, with type name replacements and synonyms. Demonstrates how litgen handles template class members.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_templates.ipynb#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstruct ImGuiConfig { /* implementation not shown here */ };\n\ntemplate<typename T>\nstruct ImVector\n{\n    // Implementation not shown here\nprivate:\n    T* data;\n};\n\nstruct Foo\n{\n    ImVector<ImGuiConfig> Configs; // This member will be added to the bindings\n    ImVector<int> IntValues;       // This member will be excluded from the bindings, since ImVector<int> is not published!\n};\n```\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.type_replacements.add_last_replacement(r\"ImGui([A-Z][a-zA-Z0-9]*)\", r\"\\1\")  # Remove prefix ImGui from exposed type\noptions.class_template_options.add_specialization(\n    \"ImVector\",                             # which class do we want to specialize\n    [\"ImGuiConfig\", \"float *\", \"int32_t\"],  # for which types\n    [\"Int32=uint32_t\"],                     # With which synonyms\n)\nlitgen_demo.demo(options, cpp_code)\n\n# Note: the warnings below are normal, since we did not specialize ImVector<int> (they can be filtered out, see below)\n```\n\n----------------------------------------\n\nTITLE: C++ Template Class Definition\nDESCRIPTION: Defines a C++ template class `ImVector` and a struct `Foo` containing members of type `ImVector`. This code is used to demonstrate template class instantiation.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nstruct ImGuiConfig { /* implementation not shown here */ };\n\ntemplate<typename T>\nstruct ImVector\n{\n    // Implementation not shown here\nprivate:\n    T* data;\n};\n\nstruct Foo\n{\n    ImVector<ImGuiConfig> Configs; // This member will be added to the bindings\n    ImVector<int> IntValues;       // This member will be excluded from the bindings, since ImVector<int> is not published!\n};\n```\n\n----------------------------------------\n\nTITLE: Using Litgen with Numeric Macros in Python\nDESCRIPTION: This Python code snippet demonstrates how to use litgen when dealing with C++ code that utilizes macros to define array sizes. It defines C++ code, sets the value of the `MY_COUNT` macro within the `srcmlcpp_options`, and then uses `litgen_demo.demo` to generate bindings. This is essential for scenarios where litgen cannot automatically determine the value of macros used for sizing arrays or other data structures.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/09_05_00_preprocessor.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n#define MY_COUNT 256\n\nstruct Foo\n{\n    int values[MY_COUNT];\n};\n\"\"\"\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.named_number_macros[\"MY_COUNT\"] = 256\n\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Declaring C++ Function with Default Parameter Using Brace Initialization\nDESCRIPTION: Demonstrates a C++ function declaration with a default parameter using brace initialization (={}), which srcML misinterprets as a variable declaration rather than a function declaration. No external dependencies are required. The function 'Foo' accepts an integer 'v' defaulting to an empty initializer list. Use of brace initialization can lead to parsing issues and should be avoided when using srcML.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid Foo(int v = {} );\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Code as a Python String\nDESCRIPTION: Demonstrates defining a multi-line string variable in Python that contains C++ source code. This string includes comments, a struct definition (`Foo`), and a member function declaration (`answer`) with a default parameter value. This variable serves as input for the parsing process.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_00_00_cpp_intro.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncode = \"\"\"\n// A Demo struct\nstruct Foo\n{\n    const int answer(int *v=nullptr); // Returns the answer\n};\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Downloading and Displaying Litgen Options Python Source\nDESCRIPTION: This Python snippet uses external libraries to fetch the source code of the `litgen/options.py` file from a GitHub URL. It then utilizes a demo function to present this code, likely for documentation purposes. The snippet demonstrates how the contents of the options file are accessed and shown.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_03_00_options.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom codemanip import code_utils\nfrom litgen.demo import litgen_demo\n\nlitgen_options_code = code_utils.download_url_content(\n    \"https://raw.githubusercontent.com/pthom/litgen/main/src/litgen/options.py\"\n)\nlitgen_demo.show_python_code(litgen_options_code, title=\"litgen/options.py\")\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running litgen Demo in Python\nDESCRIPTION: This Python script demonstrates configuring litgen options for C++ code processing and then runs the `litgen_demo.demo` function to generate Python stubs (.pyi) and C++ bindings. It defines various options like root namespaces, case conversion rules, API markers, function parameter handling, and macro exporting rules, applied to an example C++ code string containing namespaces, functions, structs, comments, and macros.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/01_05_05_online.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\n\n# This namespace will not be outputted as a python module\noptions.namespaces_root = [\"MyNamespace\"]\n# All functions, modules and namespaces names are converted to snake case\noptions.python_convert_to_snake_case = True\n# This is an API marker in the C++ code (for shared libraries code)\noptions.srcmlcpp_options.functions_api_prefixes = \"^MY_API$\"\n# Also create bindings for functions that do not have the API marker\noptions.fn_exclude_non_api = False\n# Optional comment that can be added to non API functions\noptions.fn_non_api_comment = \"\"\n# \"Box\" immutable functions parameter when they should be modifiable\noptions.fn_params_replace_modifiable_immutable_by_boxed__regex = r\".*\"\n# Which numeric and string preprocessor do we want to export\noptions.macro_define_include_by_name__regex = \"^MY_\"\n\ncode = \"\"\"\n// This namespace is not outputed as a submodule, since it is marked as Root (see options.namespaces_root)\nnamespace MyNamespace \n{\n    // Multiplies a list of double by a given factor, returns updated list\n    std::vector<double> MultiplyDoubles(const std::vector<double>& v, float k);\n\n    // changes the value of the bool parameter (passed by modifiable reference)\n    // (This function will use a BoxedBool in the python code, so that its value can be modified)\n    void SwitchBoolValue(bool &v);\n    \n    // Standalone comment blocs are also exported\n\n    // This function includes an API marker which will be ignored when generating the bindings\n    MY_API int MySubstract(int a, int b); // eol doc is also included in bindings doc\n\n    namespace MyMath // This namespace is not ignored and introduces a new python module\n    {\n        // div and mul: divide or multiply float numbers\n        // (This comment concerns the two grouped \n        // functions below, and will be exported as such)\n        float Div(float a, float b); // Divide\n        float Mul(float a, float b); // Multiply\n    }\n\n    // Stores Pixel coordinates\n    struct Pixel\n    {\n        // Coordinates\n        double x = 2., y = 3.;\n\n        // Draw a pixel\n        void Draw(Image& i);\n\n        private:\n        double _Norm(); // this will not be exported as it is private\n    };\n\n    // This macro value be exported, as it matches the regex macro_define_include_by_name__regex\n    #define MY_VALUE 123\n}\n\"\"\"\n\nlitgen_demo.demo(\n    options, code, show_cpp=False, show_pydef=True, height=80\n)\n```\n\n----------------------------------------\n\nTITLE: Downloading and Displaying Srcmlcpp Options Python Source\nDESCRIPTION: This Python snippet fetches the source code of the `srcmlcpp/srcmlcpp_options.py` file from a specific GitHub URL. It then employs a demo function to display the retrieved code content. This showcases how the options for the underlying `srcmlcpp` library are accessed and presented within the documentation context.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_03_00_options.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlitgen_options_code = code_utils.download_url_content(\n    \"https://raw.githubusercontent.com/pthom/litgen/main/src/srcmlcpp/srcmlcpp_options.py\"\n)\nlitgen_demo.show_python_code(litgen_options_code, title=\"srcmlcpp/srcmlcpp_options.py\")\n```\n\n----------------------------------------\n\nTITLE: Defining Sample C++ Header for Preprocessing Example (Python/C++)\nDESCRIPTION: Defines a simple C++ code snippet stored in a Python string variable `cpp_code`. It contains a single function declaration `int add(int, int b);`. This code will be used as input to demonstrate the custom preprocessing function in litgen.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\nint add(int, int b);\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Sample C++ Header for Filtering Example (Python/C++)\nDESCRIPTION: Defines a C++ code snippet stored in a Python string variable `cpp_code`. This header includes functions within different preprocessor `#ifdef`/`#ifndef` blocks (`MY_HEADER_H`, `ARCANE_OPTION`, `COMMON_OPTION`) and serves as input for demonstrating litgen's header filtering capabilities.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n#ifndef MY_HEADER_H   // This is an inclusion guard, it should not be filtered out\n\nvoid Foo() {}\n\n#ifdef ARCANE_OPTION\n    // We are entering a zone that handle arcane options that should not be included in the bindings\n    void Foo2() {}\n#else\n    // this should also not be included in the bindings\n    void Foo3() {}\n#endif\n\n#ifdef COMMON_OPTION\n    // We are entering a zone for which we would like to publish bindings\n    void Foo4();\n#endif\n\n#endif // #ifndef MY_HEADER_H\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Generated Bindings in litgen_demo - Python\nDESCRIPTION: This snippet uses an auxiliary module 'litgen_demo' to demonstrate the generated binding code and stubs. It takes the previously instantiated options and C++ code strings, and displays the stub code (Python declarations), pydef code (C++ bindings using pybind11), and optionally glue code. The key dependency is 'litgen.demo.litgen_demo'. The expected input is valid litgen options and C++ code. No outputs are returned; instead, the effect is a display of corresponding code.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_00_00_first_steps.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom litgen.demo import litgen_demo\n\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n\n# Below, you will see:\n# - the original C++ code to the left\n# - stub_code (i.e. the python stubs) to the right\n# - pydef_code (i.e. the C++ binding code) at the bottom\n# In this case, the glue code is empty \n```\n\n----------------------------------------\n\nTITLE: Retrieving Original C++ Code from CppElement Tree (Verbatim)\nDESCRIPTION: Demonstrates retrieving the exact original C++ source code using the `str_code_verbatim()` method on a `CppElement` object. This method ignores any changes made to the Python object tree after parsing and reproduces the input code verbatim by utilizing the underlying srcML XML representation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_00_00_cpp_intro.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(cpp_unit.str_code_verbatim())\n```\n\n----------------------------------------\n\nTITLE: Parsing C++ Code with srcML - Default Parameter\nDESCRIPTION: This snippet demonstrates a parsing issue in srcML related to default parameter values in C++ functions. When a function's default parameter is initialized with `{}`, srcML might incorrectly parse it. However, using a numerical value like `0` results in correct parsing.  This snippet illustrates a potential pitfall during C++ code parsing.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid Foo(int v = {} );\n```\n\n----------------------------------------\n\nTITLE: Exporting Macros with Litgen in Python\nDESCRIPTION: This python code snippet demonstrates how to use litgen to export C++ macros to Python. It defines `cpp_code` containing the C++ macros, sets up `LitgenOptions` to include macros starting with \"MYLIB_\", removes the \"MYLIB_\" prefix from the macro names using regular expressions, and then uses `litgen_demo.demo` to generate the Python bindings. The `show_pydef=True` argument tells the demo to show the Python definitions.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/09_05_00_preprocessor.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n    #define MYLIB_VALUE 1\n    #define MYLIB_FLOAT 1.5\n    #define MYLIB_STRING \\\"abc\\\"\n    #define MYLIB_HEX_VALUE 0x00010009\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.macro_define_include_by_name__regex = \"^MYLIB_\"\n# Suppress the \\\"MYLIB_\\\" prefix:\noptions.macro_name_replacements.add_first_replacement(r\"^MYLIB_([A-Z_]*)\", r\"\\1\")\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: AmalgamationOptions API in Python\nDESCRIPTION: Defines the AmalgamationOptions dataclass and write_amalgamate_header_file function that controls how the amalgamation process works. It specifies which headers to include and where to write the output.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_10_amalgamation.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass AmalgamationOptions:\n    base_dir: str                     # The base directory of the headers\n    local_includes_startwith: str     # Only headers whose name begin with this string should be included\n    include_subdirs: list[str]        # Include only headers in these subdirectories\n\n    main_header_file: str             # The main header file\n    dst_amalgamated_header_file: str  # The destination file\n\ndef write_amalgamate_header_file(options: AmalgamationOptions) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Litgen Namespace Processing - Python\nDESCRIPTION: This code demonstrates the usage of the litgen library to generate Python stubs from a C++ code snippet. It showcases namespace handling, excluding details and anonymous namespaces, grouping occurrences of namespaces, and how snake_case conversion is applied.  The example uses `litgen_demo.demo()` and takes an `options` object (configured earlier) along with a C++ code string, producing Python stubs as output.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/08_05_00_namespaces.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n\n    void FooRoot();  // A function in the root namespace\n\n    namespace details // This namespace should be excluded (see options.namespace_exclude__regex)\n    {\n        void FooDetails();\n    }\n\n    namespace // This anonymous namespace should be excluded\n    {\n        void LocalFunction();\n    }\n\n    // This namespace should not be outputted as a submodule,\n    // since it is present in options.namespaces_root \n    namespace Main\n    {\n        // this is an inner namespace (this comment should become the namespace doc)\n        namespace Inner\n        {\n            void FooInner();\n        }\n\n        // This is a second occurrence of the same inner namespace\n        // The generated python module will merge these occurrences\n        // (and this comment will be ignored, since the Inner namespace already has a doc)\n        namespace Inner\n        {\n            void FooInner2();\n        }\n    }\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.namespaces_root = [\"Main\"]\n# options.namespace_exclude__regex = r\"[Ii]nternal|[Dd]etail\"  # this is the default!\noptions.python_run_black_formatter = True\n# options.python_convert_to_snake_case = False  # uncomment this in order to keep the original namespaces and functions names\nlitgen_demo.demo(options, cpp_code)\n\n```\n\n----------------------------------------\n\nTITLE: Python Binding of C++ Function with Inferred Return\nDESCRIPTION: This snippet illustrates the Python binding created from a C++ function with an inferred return type. The Python function has `Any` as its return type because the C++ compiler can determine the return type but this cannot be determined by srcML during the Python binding generation. There is no dependencies, the output code shows the exported code.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef my_pow(a: float, b: float) -> Any:\npass\n```\n\n----------------------------------------\n\nTITLE: Python Stub File\nDESCRIPTION: This Python stub snippet shows the structure of a `.pyi` file generated by LitGen for type hinting.  It includes a `# type: ignore` comment and uses markers to indicate auto-generated code sections. This file provides type information for Python code using the DasLib bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/example_bindings/DasLib/Readme.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# type: ignore\n\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n# <litgen_stub> // Autogenerated code below! Do not edit!\n# Code will be generated here...\n# </litgen_stub>\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n```\n\n----------------------------------------\n\nTITLE: Downloading and Displaying srcmlcpp/srcmlcpp_options.py in Python\nDESCRIPTION: This snippet downloads and displays the content of the `srcmlcpp/srcmlcpp_options.py` file, similar to the previous one. It fetches the file from a GitHub URL, using `code_utils.download_url_content`, and presents it using `litgen_demo.show_python_code`. This section demonstrates the use of srcmlcpp options. Dependencies include the `codemanip` and `litgen.demo` libraries. This retrieves the python file from the github repository.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_03_00_options.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n```python\nlitgen_options_code = code_utils.download_url_content(\n    \"https://raw.githubusercontent.com/pthom/litgen/main/src/srcmlcpp/srcmlcpp_options.py\"\n)\nlitgen_demo.show_python_code(litgen_options_code, title=\"srcmlcpp/srcmlcpp_options.py\")\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project and Nanobind Option\nDESCRIPTION: Sets the minimum required CMake version to 3.17, defines the project name as 'litgen', and sets the C++ standard to C++20. It introduces a boolean option `LITGEN_USE_NANOBIND`, defaulting to OFF, which can be overridden by the environment variable `LITGEN_USE_NANOBIND`. The chosen value is logged to the console.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.17)\nproject(litgen)\nset(CMAKE_CXX_STANDARD 20)\n\n\noption(LITGEN_USE_NANOBIND OFF)\nif (DEFINED ENV{LITGEN_USE_NANOBIND})\n    set(LITGEN_USE_NANOBIND $ENV{LITGEN_USE_NANOBIND})\nelse()\n    set(LITGEN_USE_NANOBIND OFF)\nendif()\nmessage(STATUS \"LITGEN_USE_NANOBIND: ${LITGEN_USE_NANOBIND}\")\n```\n\n----------------------------------------\n\nTITLE: Declaring C++ Function with Inferred Return Type\nDESCRIPTION: Demonstrates a C++ function with an inferred return type using 'auto' without arrow notation. While srcML exports this to Python, the actual return type is unknown, resulting in a generic 'Any' type in Python. This pattern requires no special dependencies, but may limit static type checking in Python.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nauto my_pow(double a, double b)\n```\n\n----------------------------------------\n\nTITLE: Declaring C++ Function with Default Parameter Using Integer Value\nDESCRIPTION: Shows a C++ function declaration where the default parameter is set using a standard integer literal (= 0), which srcML parses correctly as a function declaration. The function 'Foo' takes an integer 'v' defaulting to 0. No dependencies or special configuration are required. This pattern is recommended over brace initialization for compatibility with srcML.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid Foo(int v = 0 );\n```\n\n----------------------------------------\n\nTITLE: Defining and Building the Python Extension Module (CMake)\nDESCRIPTION: Configures the build of the Python extension module. It sets the Python wrapper module name (`lg_mylib`) and conditionally defines the native module name (`_lg_mylib_nanobind` or `_lg_mylib_pybind`) and corresponding source files based on `LITGEN_USE_NANOBIND`. It uses the appropriate CMake function (`nanobind_add_module` or `pybind11_add_module`) to create the module target and then calls `litgen_setup_module` for further configuration, linking against the C++ library (`bound_library`) and specifying stub file locations.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n#########################################################################\n# Build python module that provides bindings to the library implot\n#########################################################################\nset(python_wrapper_module_name lg_mylib) # This is the python wrapper around the native module\n\nif (LITGEN_USE_NANOBIND)\n    set(python_native_module_name _lg_mylib_nanobind) # native python module name\n    set(python_module_sources _pydef_nanobind/module.cpp _pydef_nanobind/nanobind_mylib.cpp) # native python module sources\n    nanobind_add_module(${python_native_module_name} ${python_module_sources})\nelse()\n    set(python_native_module_name _lg_mylib_pybind) # native python module name\n    set(python_module_sources _pydef_pybind11/module.cpp _pydef_pybind11/pybind_mylib.cpp) # native python module sources\n    pybind11_add_module(${python_native_module_name} ${python_module_sources})\nendif()\n\nlitgen_setup_module(\n    ${bound_library}\n    ${python_native_module_name}\n    ${python_wrapper_module_name}\n    ${CMAKE_CURRENT_LIST_DIR}/_stubs\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Package in Editable Mode (Bash)\nDESCRIPTION: Installs the package in editable mode using pip. The `-e` flag (or `--editable`) creates a symbolic link to the project directory in the Python environment, allowing changes to the C++ code to be reflected in Python without reinstalling the package. The `-v` flag enables verbose output.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npip install -v -e .  # -e stands for --editable, and -v stands for --verbose\n```\n\n----------------------------------------\n\nTITLE: Installing litgen Locally via pip (Bash)\nDESCRIPTION: Installs the 'litgen' Python package directly from its GitHub repository using the pip package manager. This command is necessary for setting up litgen locally to generate C++ bindings and Python stubs within a development environment or build system.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/01_05_00_install_or_online.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install \"litgen@git+https://github.com/pthom/litgen\"\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Definitions based on Binding Library (CMake)\nDESCRIPTION: Adds C++ preprocessor definitions based on whether nanobind or pybind11 is being used (controlled by `LITGEN_USE_NANOBIND`). It defines `BINDING_MULTIPLE_INHERITANCE` and `BINDINGS_WITH_PYBIND` if using pybind11, or `BINDINGS_WITH_NANOBIND` if using nanobind. These definitions enable conditional compilation within the C++ source code.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT LITGEN_USE_NANOBIND)\n    # pybind11 supports bindings for multiple inheritance, nanobind does not\n    add_compile_definitions(BINDING_MULTIPLE_INHERITANCE)\nendif()\n\n# used by bool bindings_with_nanobind() / bool bindings_with_pybind()\nif (NOT LITGEN_USE_NANOBIND)\n    add_compile_definitions(BINDINGS_WITH_PYBIND)\nelse()\n    add_compile_definitions(BINDINGS_WITH_NANOBIND)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Nanobind Environment Variable (Bash)\nDESCRIPTION: Sets the environment variable LITGEN_USE_NANOBIND to ON. This configuration option instructs litgen to use nanobind instead of pybind11 for generating the Python bindings. This allows the user to choose their preferred binding library.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport LITGEN_USE_NANOBIND=ON\n```\n\n----------------------------------------\n\nTITLE: Transforming C++ code into an AST using srcmlcpp\nDESCRIPTION: This snippet demonstrates parsing a C++ code string into a CppUnit object, which represents the syntax tree of the source code. This setup is essential for performing subsequent tree traversal and transformations.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_05_00_cpp_simple_transformations.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ncode = \"\"\"\nint AddNumbers(const MyModule_Class& c);\n\"\"\"\n\nimport srcmlcpp\n\noptions = srcmlcpp.SrcmlcppOptions()\ncpp_unit = srcmlcpp.code_to_cpp_unit(options, code)\n```\n\n----------------------------------------\n\nTITLE: Adding and Configuring the C++ Test Library (CMake)\nDESCRIPTION: Includes the `mylib/mylib_main` subdirectory to build the 'mylib' C++ library target. It then sets the CMake variable `bound_library` to 'mylib', identifying it as the library for which Python bindings should be created.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n####################################################\n# Build testrunner Bound C++ library\n####################################################\nadd_subdirectory(mylib/mylib_main)            # Will build the library mylib\nset(bound_library mylib)                      # The library for which we are building bindings\n```\n\n----------------------------------------\n\nTITLE: Adding Type Replacements in Litgen\nDESCRIPTION: This code configures `litgen` to replace the C++ type `MyPair<int, int>` with the Python type `Tuple[int, int]` using regular expressions. It adds a replacement rule to `options.type_replacements` and then runs the litgen demo.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/04_05_00_names_translation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.type_replacements.add_last_replacement(\n    r\"MyPair<(.*),\\s*(.*)>\", # this is a regex, with 2 captures\n    r\"Tuple[\\1, \\2]\"         # and this is the replacement\n)\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Building C++ Components with CMake (Bash)\nDESCRIPTION: Creates a build directory, configures the project using CMake from the parent directory, and compiles the project using Make. This typically builds C++ components and regenerates bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build && cd build\ncmake ..\nmake\n```\n\n----------------------------------------\n\nTITLE: Obtaining Verbatim Original C++ Code from CppElement Tree (Python)\nDESCRIPTION: This snippet retrieves the exact original C++ source code from a CppElement tree using the str_code_verbatim method and prints it. It operates by calling back into the srcml executable on the stored srcml XML representation, guaranteeing verbatim fidelity. Dependencies include srcmlcpp, a properly built CppElement tree (cpp_unit), and the srcML binary. The main input is the CppElement object; the output is the precise original C++ code as a string.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_00_00_cpp_intro.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nprint(cpp_unit.str_code_verbatim())\n\n```\n\n----------------------------------------\n\nTITLE: Example Main Header File Structure - C++\nDESCRIPTION: This C++ snippet shows an example structure of a main library header file (`hello_imgui.h`) that includes other public headers. It demonstrates how system headers and private includes are handled differently from the local library headers intended for amalgamation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_10_amalgamation.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#pragma once\n\n#if defined(__ANDROID__) && defined(HELLOIMGUI_USE_SDL2)\n// We need to include SDL, so that it can instantiate its main function under Android\n#include \"SDL.h\"   // This include should *not* be in the amalgamation header\n#endif\n\n#include \"hello_imgui/dpi_aware.h\"             // Only headers whose name begin with\n#include \"hello_imgui/hello_imgui_assets.h\"    // \"hello_imgui\" should be included\n#include \"hello_imgui/hello_imgui_error.h\"     // in the amalgamation header\n#include \"hello_imgui/hello_imgui_logger.h\"\n#include \"hello_imgui/image_from_asset.h\"\n#include \"hello_imgui/imgui_theme.h\"\n#include \"hello_imgui/hello_imgui_font.h\"\n#include \"hello_imgui/runner_params.h\"\n#include \"hello_imgui/hello_imgui_widgets.h\"\n\n#include <string>   // Other includes can be included as usual\n#include <cstddef>\n#include <cstdint>\n\n... (other includes)\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Namespace in Litgen\nDESCRIPTION: Setting options.namespaces_root to define namespaces that should not be outputted as submodules while still exporting their content.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/08_05_00_namespaces.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\noptions.namespaces_root = [\"Main\"]\n```\n\n----------------------------------------\n\nTITLE: Setting Root Namespaces in Litgen - Python\nDESCRIPTION: This snippet configures Litgen to treat the specified namespaces as root namespaces.  When a namespace is declared as a root namespace, Litgen does not emit it as a submodule.  The content of the root namespace is still exported, though. The example sets the \"Main\" namespace as the root namespace. This configuration is essential for controlling the structure of the generated Python modules.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/08_05_00_namespaces.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n     options.namespaces_root = [\"Main\"]\n\n```\n\n----------------------------------------\n\nTITLE: Installing Litgen integration_tests pip package via Docker and pip\nDESCRIPTION: Builds and installs the Litgen integration_tests pip package by invoking pip install with verbose output on the package source directory. This command is executed using the docker_run.py helper script to maintain containerized isolation, facilitating package integration testing.\nSOURCE: https://github.com/pthom/litgen/blob/main/ci_scripts/docker_ci/shell_recipes.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./docker_run.py exec  pip install -v dvp/sources/packages/litgen/integration_tests\n```\n\n----------------------------------------\n\nTITLE: Hello ImGui main header file example in C++\nDESCRIPTION: Shows the content of the hello_imgui.h main header file, which includes all other public API headers. This will be used as the starting point for the amalgamation process.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_10_amalgamation.md#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#pragma once\n\n#if defined(__ANDROID__) && defined(HELLOIMGUI_USE_SDL2)\n// We need to include SDL, so that it can instantiate its main function under Android\n#include \"SDL.h\"   // This include should *not* be in the amalgamation header\n#endif\n\n#include \"hello_imgui/dpi_aware.h\"             // Only headers whose name begin with\n#include \"hello_imgui/hello_imgui_assets.h\"    // \"hello_imgui\" should be included\n#include \"hello_imgui/hello_imgui_error.h\"     // in the amalgamation header\n#include \"hello_imgui/hello_imgui_logger.h\"\n#include \"hello_imgui/image_from_asset.h\"\n#include \"hello_imgui/imgui_theme.h\"\n#include \"hello_imgui/hello_imgui_font.h\"\n#include \"hello_imgui/runner_params.h\"\n#include \"hello_imgui/hello_imgui_widgets.h\"\n\n#include <string>   // Other includes can be included as usual\n#include <cstddef>\n#include <cstdint>\n\n... (other includes)\n```\n\n----------------------------------------\n\nTITLE: Installing Package from Source (Bash)\nDESCRIPTION: Clones the litgen_template repository, navigates into the directory, and installs the package using pip. The `-v` flag enables verbose output during the installation process, providing more detailed information about the installation steps.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pthom/litgen_template.git && cd litgen_template\npip install -v .\n```\n\n----------------------------------------\n\nTITLE: Example C++ Glue Code Header Structure with litgen Markers\nDESCRIPTION: Illustrates the structure of a C++ glue code header file (`glue_code_DasLib.h`) generated by `litgen`. This file typically includes standard libraries like `<string>` and contains a section marked by `<litgen_glue_code>` where autogenerated helper C++ code is inserted.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/example_bindings/DasLib/Readme.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <string>\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// <litgen_glue_code>  // Autogenerated code below! Do not edit!\n// Code will be generated here...\n// </litgen_glue_code> // Autogenerated code end\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n```\n\n----------------------------------------\n\nTITLE: Generated amalgamation header example in C++\nDESCRIPTION: Shows a snippet of the generated amalgamation header file, which combines all the relevant headers into a single file. It maintains the original include guards and comments for clarity.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_10_amalgamation.md#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// THIS FILE WAS GENERATED AUTOMATICALLY. DO NOT EDIT.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                       hello_imgui.h                                                                          //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined(__ANDROID__) && defined(HELLOIMGUI_USE_SDL2)\n// We need to include SDL, so that it can instantiate its main function under Android\n#include \"SDL.h\"\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                       hello_imgui/dpi_aware.h included by hello_imgui.h                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#include \"imgui.h\"\n\nnamespace HelloImGui\n{\n... (content of hello_imgui/dpi_aware.h)\n}\n... (other includes)\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment (Bash)\nDESCRIPTION: Creates a Python virtual environment named 'venv' using the 'python3' interpreter (requires version 3.10 or higher) and activates it in the current shell session.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv       # At least python 3.10\nsource venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Defining and Configuring the 'mylib' Static Library in CMake\nDESCRIPTION: This CMake code adds a static library target named `mylib` using `mylib.cpp` and `mylib.h` as source files. It configures public include directories to allow dependent targets to find headers located in the parent's parent directory and the current directory. Additionally, it checks if the build is on a Windows system (`WIN32`) and, if so, sets the `WINDOWS_EXPORT_ALL_SYMBOLS` property to `ON` to handle symbol visibility.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/mylib/mylib_main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(mylib STATIC mylib.cpp mylib.h)\ntarget_include_directories(mylib PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/../..\n    ${CMAKE_CURRENT_LIST_DIR}\n    )\n\n# Under windows, auto __declspec(dllexport)\nif (WIN32)\n    set_target_properties(mylib PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Tool\nDESCRIPTION: This snippet demonstrates the installation of the pre-commit tool using pip. It's a prerequisite for using pre-commit hooks for code quality checks before committing.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npip install pre-commit\n```\n\n----------------------------------------\n\nTITLE: Finding pybind11/nanobind and Python Dependencies (CMake)\nDESCRIPTION: Includes the `litgen_cmake/litgen_cmake.cmake` script which presumably contains helper functions. Depending on the `LITGEN_USE_NANOBIND` option, it calls either `litgen_find_nanobind()` or `litgen_find_pybind11()` to locate the required Python binding library (nanobind or pybind11) and associated Python installation.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n####################################################\n# Find pybind11 or nanobind (and find Python)\n####################################################\ninclude(litgen_cmake/litgen_cmake.cmake)\nif (LITGEN_USE_NANOBIND)\n    litgen_find_nanobind()\nelse()\n    litgen_find_pybind11()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Converting CppElement Tree back to C++ Code (Reflecting Modifications)\nDESCRIPTION: Shows how to generate C++ source code from a `CppElement` tree using the `str_code()` method. This output reflects any modifications made to the Python `CppElement` objects in the tree, though the formatting might differ slightly from the original. The example uses a hypothetical `litgen_demo.show_cpp_code` function for display.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_00_00_cpp_intro.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litgen.demo import litgen_demo\n\nlitgen_demo.show_cpp_code(cpp_unit.str_code())\n```\n\n----------------------------------------\n\nTITLE: Binding Classic C Enums using litgen in Python\nDESCRIPTION: Demonstrates binding a classic C `enum` named `Foo` using litgen. It highlights automatic prefix removal (`Foo_a` becomes `a`), comment preservation, handling of computed values (`Foo_d`), and using `named_number_macros` to define values like `MY_VALUE`. The `litgen_demo.demo` function is used to execute the binding generation process with specified options.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_enums.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n// Doc about Foo\n// On several lines\nenum Foo\n{\n    Foo_a, // This is a\n\n    // And this is b and c's comment\n    Foo_b,\n    Foo_c = MY_VALUE,\n\n    Foo_d = Foo_a | Foo_b + Foo_c, // And a computed value\n\n    Foo_e = 4,\n\n    Foo_count, // And this is count: by default this member is suppressed\n};\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.named_number_macros = {\"MY_VALUE\": 256}\n# options.enum_flag_skip_count = False # Uncomment this to generate a definition for Foo::Foo_count\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies (Bash)\nDESCRIPTION: Installs Python packages listed in the 'requirements-dev.txt' file into the active virtual environment using pip.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements-dev.txt\n```\n\n----------------------------------------\n\nTITLE: Running Project Checks and Tests (Bash)\nDESCRIPTION: Executes a shell script responsible for running various development checks, including mypy, black, ruff, and pytest.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./ci_scripts/devel/run_all_checks.sh\n```\n\n----------------------------------------\n\nTITLE: Defining a CppElement Visitor for Refactoring\nDESCRIPTION: This snippet defines a visitor function `my_refactor_visitor` that applies the previously defined transformations based on the type of `CppElement` encountered during traversal. If the element is a `CppFunctionDecl`, it transforms the function name to snake_case. If the element is a `CppType`, it adds the `MyModule::` namespace. It depends on the `CppFunctionDecl` and `CppType` classes.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef my_refactor_visitor(cpp_element: srcmlcpp.CppElement, event: srcmlcpp.CppElementsVisitorEvent, depth: int) -> None:\n    \"\"\"Our visitor will apply the transformation\"\"\"\n    if event == srcmlcpp.CppElementsVisitorEvent.OnElement:\n        if isinstance(cpp_element, CppFunctionDecl):\n            change_function_to_snake_case(cpp_element)\n        elif isinstance(cpp_element, CppType):\n            make_my_module_namespace(cpp_element)\n```\n\n----------------------------------------\n\nTITLE: Creating C++ Build Directory (Bash)\nDESCRIPTION: Creates a 'build' directory, navigates into it, and uses CMake to configure the project. This step is necessary for building the C++ library and the generated bindings. Subsequent `make` command will compile the changes.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build && cd build\ncmake ..\nmake # rebuild when you change the C++ code, and the changes will be reflected in python!\n```\n\n----------------------------------------\n\nTITLE: Python Stub for C++ Function with Inferred Return Type\nDESCRIPTION: Shows the automatically generated Python binding for a C++ function with an inferred return type. As the C++ return type is unknown, the Python stub return type defaults to 'Any'. Arguments are typed as floats, but the returned value is not type-safe. No additional dependencies are required.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef my_pow(a: float, b: float) -> Any:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Generating C++ PImpl Boilerplate from String using Python\nDESCRIPTION: This Python snippet demonstrates generating PImpl boilerplate code. It calls `pimpl_my_class.pimpl_my_code` with a C++ source code string (`cpp_code`) as input. If successful, it receives a result object containing the generated `header_code` and `glue_code`, which are then displayed using `litgen_demo.show_cpp_code`.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/unused_20_10_00_pimpl_my_class.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\npimpl_result = pimpl_my_class.pimpl_my_code(cpp_code)\n\nif pimpl_result is not None:\n    litgen_demo.show_cpp_code(pimpl_result.header_code, \"Header Code\")\n    litgen_demo.show_cpp_code(pimpl_result.glue_code, \"Glue Code (add this at the bottom of the C++ file)\")\n```\n\n----------------------------------------\n\nTITLE: C/C++ Header Code Sample with API Prefix\nDESCRIPTION: This is a C/C++ header code snippet demonstrating the use of API prefixes to denote whether a function should be exported in a shared library. The `MY_API` prefix indicates that the `add` function should be exported, while the `mul` function is considered private.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// This function has an API marker and is exported in a shared library\nMY_API int add(int, int b);\n\n// This function does not have an API marker, and is probably private\nint mul(int a, int b);\n```\n\n----------------------------------------\n\nTITLE: Installing Pyright\nDESCRIPTION: This command installs the pyright static type checker for Python. It's a prerequisite for type checking Python code.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\npip install pyright # install pyright (once)\n```\n\n----------------------------------------\n\nTITLE: Template Function with Suffix\nDESCRIPTION: Example of specializing a template function for multiple types with a suffix added to the function name, creating distinct Python functions.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_templates.ipynb#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T> voi LogValue(const std::string& label, const T& value);\n```\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.fn_template_options.add_specialization(\"^LogValue$\", [\"int\", \"float\"], add_suffix_to_function_name=True)\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Installing Pytest\nDESCRIPTION: This command installs the pytest testing framework. It's required to run Python tests using pytest.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\npip install pytest # install pytest (once)\n```\n\n----------------------------------------\n\nTITLE: Disabling Snake Case Conversion in Litgen\nDESCRIPTION: This code demonstrates how to disable the automatic snake_case conversion in litgen by setting `options.python_convert_to_snake_case` to `False`. It shows how to retain the original CamelCase naming in the generated Python bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/04_05_00_names_translation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\noptions.python_convert_to_snake_case = False\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Updating C++/Header Files with PImpl Boilerplate using Python\nDESCRIPTION: This Python snippet shows how to automatically insert generated PImpl code into existing C++ source and header files. It configures `PimplOptions` to define the suffix for PImpl classes. Then, it calls `pimpl_my_class.pimpl_my_file`, passing the paths to the C++ file (`cpp_file`) and header file (`header_file`). This function modifies the files by inserting the generated code between predefined markers. Finally, it displays the updated file contents.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/unused_20_10_00_pimpl_my_class.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom srcmlcpp_tools.pimpl_my_class import pimpl_my_file, PimplOptions\n\npimpl_options = PimplOptions()\npimpl_options.pimpl_suffixes = [\"PImpl\"]\n\npimpl_my_file(cpp_file, header_file)\n\nlitgen_demo.show_cpp_file(cpp_file)\nlitgen_demo.show_cpp_file(header_file)\n```\n\n----------------------------------------\n\nTITLE: Litgen Demo with Default Options\nDESCRIPTION: This snippet demonstrates how to use the `litgen_demo` function with default options to generate Python bindings for the provided C++ code.  It initializes `LitgenOptions` and passes it along with the `cpp_code` to `litgen_demo.demo`.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/04_05_00_names_translation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Litgen: Generate Code (Unhandled Template)\nDESCRIPTION: Demonstrates how to use litgen to generate code from a C++ code snippet containing an unhandled template function. Litgen will complain that the template function is unhandled.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n    template<typename T> T MaxValue(const std::vector<T>& values);\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\ngenerated_code = litgen.generate_code(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Adjusting Header Filter Options for Preprocessor Directives (litgen)\nDESCRIPTION: This snippet modifies the `header_filter_acceptable__regex` option to include a specific preprocessor definition (`COMMON_OPTION`). This allows litgen to process code blocks within `#ifdef COMMON_OPTION` directives. It demonstrates how to customize the filtering behavior to include specific sections of the header file in the binding generation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\n\n# the default value for header_filter_acceptable__regex was\n#     \"__cplusplus|_h_$|_h$|_H$|_H_$|hpp$|HPP$|hxx$|HXX$\"\n# (which includes support for common header guards)\n# Let's add support for COMMON_OPTION\noptions.srcmlcpp_options.header_filter_acceptable__regex = \"_H$|^COMMON_OPTION$\"\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Litgen: Suppress Template Class Warnings\nDESCRIPTION: Shows how to use `srcmlcpp_options.ignored_warning_parts` to suppress specific warnings from litgen concerning missing template specializations.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# tell litgen to ignore warnings that contain \"Excluding template type ImVector<int>\"\noptions.srcmlcpp_options.ignored_warning_parts.append(\"Excluding template type ImVector<int>\")\n# the following line emits a warning that is ignored\ngenerated_code = litgen.generate_code(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Generating litgen Bindings for Multiple C++ Headers (Python)\nDESCRIPTION: Python code extract showing how to use `litgen.write_generated_code_for_files` to generate bindings from multiple C++ source files. It accepts configured options, a list of input C++ header file paths, and paths for the output C++ binding definitions (`pydef`), Python stubs (`pyi`), and C++ glue code files.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/example_bindings/DasLib/Readme.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n    header_files = [\n        THIS_DIR + \"/cpp_sources/DasLib/DasLib.h\",\n        THIS_DIR + \"/cpp_sources/DasLib/DasLib_2.h\",\n    ]\n    litgen.write_generated_code_for_files(\n        options,\n        input_cpp_header_files=header_files,\n        output_cpp_pydef_file=output_cpp_pydef_file,\n        output_stub_pyi_file=output_stub_pyi_file,\n        output_cpp_glue_code_file=output_cpp_glue_code_file\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing Development Requirements (Bash)\nDESCRIPTION: Installs the development dependencies specified in the 'requirements-dev.txt' file using pip. These dependencies include litgen, pybind11 (or nanobind), pytest, black, and mypy, which are used for code generation, binding creation, testing, code formatting, and static type checking, respectively.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements-dev.txt\n```\n\n----------------------------------------\n\nTITLE: Configuring litgen to Include Non-API Functions with Comment (Python)\nDESCRIPTION: Configures litgen options to include functions even if they lack the specified API prefix. It sets `srcmlcpp_options.functions_api_prefixes` to \"MY_API\", disables exclusion of non-API functions (`fn_exclude_non_api = False`), and adds a specific comment (`fn_non_api_comment`) for these included non-API functions. The demo function shows the outcome.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.functions_api_prefixes = \"MY_API\"\noptions.fn_exclude_non_api = False\noptions.fn_non_api_comment = \"Private API!\"\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Processing C++ Code with Default Litgen Options (Python)\nDESCRIPTION: This code snippet processes the previously loaded C++ file using the default `litgen.LitgenOptions`. The `litgen.generate_code_for_file` function is called with the default options and the filename. This step is intended to demonstrate that processing this specific file with default settings results in warnings being emitted by `litgen`.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/10_05_00_ignore_warnings.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\ngenerated_code = litgen.generate_code_for_file(options, \"10_05_10_sample_code.h\")\n```\n\n----------------------------------------\n\nTITLE: C++ Code Snippet for Snake Case Demo\nDESCRIPTION: This C++ code defines a namespace, a struct, a method, and a variable to demonstrate how litgen handles snake_case conversion. It includes a namespace `MyNamespace`, a struct `MyClass`, a method `AddNumber`, and a variable `MultiplierRatio`.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/04_05_00_names_translation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\nnamespace MyNamespace\n{\n    struct MyClass\n    {\n        int AddNumber(int a, int b);\n\n        int MultiplierRatio = 4;\n    };\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing 'litgen' in Editable Mode (Bash)\nDESCRIPTION: Installs the 'litgen' project package in editable mode (-e) with verbose output (-v) using pip. This allows changes in the source code to be reflected immediately without reinstalling.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install -v -e .\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version and Project Definition\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.17 and defines the project name as 'litgen'. This is the initial setup required for any CMake project. There are no specific dependencies for these commands; they are core CMake functionalities. The expected output is the initialization of the CMake project with the specified version and name, ready for further configuration.\nSOURCE: https://github.com/pthom/litgen/blob/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.17)\n# This CmakeLists only build the integration tests for litgen\nproject(litgen)\n```\n\n----------------------------------------\n\nTITLE: Configuring Glue Code Generation with Regex - Python\nDESCRIPTION: This snippet demonstrates customizing litgen's code generation to emit additional 'glue code' when binding C++ functions with modifiable parameters that correspond to immutable types in Python. The option 'fn_params_replace_modifiable_immutable_by_boxed__regex' is set with a regex to specify which functions to adapt. Dependencies include litgen and litgen.demo.litgen_demo. The input is a C++ code string containing a function with a reference parameter. The output is the adapted Python binding code where parameters may be boxed types like BoxedBool.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_00_00_first_steps.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\n# This a regex which specifies that we want to adapt all functions with boxed types when needed\noptions.fn_params_replace_modifiable_immutable_by_boxed__regex = r\".*\"\ncpp_code = \"\"\"\n    // changes the value of the bool parameter (passed by modifiable reference)\n    // (This function will use a BoxedBool in the python code, so that its value can be modified)\n    void SwitchBoolValue(bool &v);\n    \"\"\"\n# Run the generator\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Installing required packages for srcML build on Ubuntu\nDESCRIPTION: Command to install the dependencies required to build srcML from source on Ubuntu systems. These packages are necessary for successful compilation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_20_00_install_srcml.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install libarchive-dev antlr libxml2-dev libxslt-dev libcurl4-openssl-dev\n```\n\n----------------------------------------\n\nTITLE: Making Enums Arithmetic\nDESCRIPTION: This example demonstrates how to use the `enum_make_arithmetic__regex` option to make a C++ `enum class` arithmetic in Python. This allows the enum to be converted to a number in Python. A regular expression is used to specify which enums should be treated as arithmetic.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_enums.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n    enum class Foo { A, B, C};\n\"\"\"\noptions = litgen.LitgenOptions()\noptions.enum_make_arithmetic__regex = \"^Foo$\"\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Adding Integration Tests Subdirectory to Build\nDESCRIPTION: This command adds the 'src/litgen/integration_tests' subdirectory to the build process. CMake will then recursively process the CMakeLists.txt file found in that subdirectory, configuring and building the integration tests. The prerequisite is that the subdirectory exists. The output is the inclusion of build instructions for the integration tests, so they get compiled as part of the project. There are no other parameters.\nSOURCE: https://github.com/pthom/litgen/blob/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(src/litgen/integration_tests)\n```\n\n----------------------------------------\n\nTITLE: Installing srcML from pre-compiled binaries on Ubuntu 20.04\nDESCRIPTION: Commands to download and install the srcML 1.0.0 Debian package on Ubuntu 20.04. This provides a quick installation method using pre-built binaries.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_20_00_install_srcml.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget http://131.123.42.38/lmcrs/v1.0.0/srcml_1.0.0-1_ubuntu20.04.deb\nsudo dpkg -i srcml_1.0.0-1_ubuntu20.04.deb\n```\n\n----------------------------------------\n\nTITLE: Available Integration Test Commands Using just Justfile Tool in Bash\nDESCRIPTION: This snippet lists the available commands in the justfile utility, which manages build and test workflows for the litgen integration tests. It includes targets for building and running tests using nanobind and pybind11 bindings, running static type checks with mypy, and executing pytest. This setup helps automate and standardize integration testing of generated Python binding modules for the C++ library.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/Readme.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n just -l\nAvailable recipes:\n    build_integration_tests_nanobind # Builds the integration tests for nanobind\n    build_integration_tests_pybind   # Builds the integration tests for pybind\n    default                          # List all available commands\n    integration_tests                # Runs all tests for pybind and nanobind (after building the integration tests)\n    integration_tests_nanobind       # Runs all tests for nanobind, after building the integration tests\n    integration_tests_pybind         # Runs all tests for pybind, after building the integration tests\n    mypy                             # Runs mypy on the top level folder (see mypy.ini)\n    pytest                           # Just runs pytest (requires that the integration tests have been built)\n```\n\n----------------------------------------\n\nTITLE: Installing srcML from Pre-Compiled Binaries using Bash\nDESCRIPTION: Downloads a pre-compiled srcML Debian package and installs it using dpkg on Ubuntu 20.04. Ensure you have appropriate permissions to run dpkg. Inputs include the Debian package URL, and the output is a system-wide installation of srcML. No other prerequisites beyond standard Ubuntu utilities are required.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_20_00_install_srcml.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget http://131.123.42.38/lmcrs/v1.0.0/srcml_1.0.0-1_ubuntu20.04.deb\nsudo dpkg -i srcml_1.0.0-1_ubuntu20.04.deb\n```\n\n----------------------------------------\n\nTITLE: Applying the Refactor Visitor and Printing Code\nDESCRIPTION: This snippet demonstrates how to apply the `my_refactor_visitor` to a `CppUnit` object using `visit_cpp_breadth_first`. It then prints the refactored code using `litgen_demo.show_cpp_code`.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Let's visit the code\ncpp_unit.visit_cpp_breadth_first(my_refactor_visitor)\n# And print the refactored code\nfrom litgen.demo import litgen_demo\n\nlitgen_demo.show_cpp_code(cpp_unit.str_code())\n```\n\n----------------------------------------\n\nTITLE: Activating Pre-commit Hooks\nDESCRIPTION: This bash command activates pre-commit hooks for a repository.  It installs the pre-commit hooks configured in the .pre-commit-config.yaml file.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Configuring PImpl Generation - Python\nDESCRIPTION: This Python snippet configures and executes the PImpl generation process. It imports necessary libraries like srcmlcpp and defines options for srcmlcpp and pimpl generation. It includes a sample C++ code block that will be transformed into a PImpl structure.  The generated header and glue code are then displayed.  The generated glue code is intended to be copied and pasted into the C++ source file.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/unused_20_15_00_pimpl_online.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nimport srcmlcpp\nfrom srcmlcpp_tools import pimpl_my_class\nfrom litgen.demo import litgen_demo\n\nsrcmlcpp_options = srcmlcpp.SrcmlcppOptions()\n# Optional: adjust srcmlcpp options if needed\n\npimpl_options = pimpl_my_class.PimplOptions()\npimpl_options.pimpl_suffixes = [\"PImpl\"]\n\ncpp_code = \"\"\"\n#include \\\"my_class.h\\\"\n\n#include <string>\n#include <future>\n\n// Some doc about the class, that you want to see in the header file\nclass MyClassPImpl\n{\n    //\n    // Some doc you also want to see in the header file\n    //\npublic:\n    // Construct an Instance\n    MyClassPImpl(const std::string& someParam)\n    {\n        // Some code you provide in the C++ file, but do not want to see in the header file\n    }\n\n    // Destructs the instance\n    // (this should not be published in the header, since the PImpl will generate its own unique_ptr destructor)\n    ~MyClassPImpl() { /* ... */ }\n\n    // Some method\n    bool SomeMethod() { /* ... */ return true; }\n\n    // Some public static method\n    static bool SomeStaticFunction() { /* ... */ return true;}\n\n\nprivate:\n    void SomePrivateMethod() { /* ... */ }\n\n    std::string mSomePrivateMember;\n    std::future<void> mAnoterPrivateMember;\n};\n\"\"\"\n\npimpl_result = pimpl_my_class.pimpl_my_code(cpp_code, pimpl_options, srcmlcpp_options)\n\n\nif pimpl_result is None:\n    print(\"Failed generated PImpl\")\nelse:\n    litgen_demo.show_cpp_code(pimpl_result.header_code, \"Header Code\")\n    litgen_demo.show_cpp_code(pimpl_result.glue_code, \"Glue Code (paste this in the C++ file)\")\n```\n```\n\n----------------------------------------\n\nTITLE: Generating C++ PImpl Code using Python and srcmlcpp\nDESCRIPTION: This Python script demonstrates the usage of the `pimpl_my_class` tool from `srcmlcpp_tools` to generate PImpl (Pointer to Implementation) code for a C++ class. It defines the source C++ code as a string, configures options for the PImpl generator and underlying srcml parser, executes the generation process, and displays the resulting C++ header code and implementation 'glue' code. The script requires the `srcmlcpp` and `litgen` libraries.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/unused_20_15_00_pimpl_online.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport srcmlcpp\nfrom srcmlcpp_tools import pimpl_my_class\nfrom litgen.demo import litgen_demo\n\nsrcmlcpp_options = srcmlcpp.SrcmlcppOptions()\n# Optional: adjust srcmlcpp options if needed\n\npimpl_options = pimpl_my_class.PimplOptions()\npimpl_options.pimpl_suffixes = [\"PImpl\"]\n\ncpp_code = \"\"\"\n#include \"my_class.h\"\n\n#include <string>\n#include <future>\n\n// Some doc about the class, that you want to see in the header file\nclass MyClassPImpl\n{\n    //\n    // Some doc you also want to see in the header file\n    //\npublic:\n    // Construct an Instance\n    MyClassPImpl(const std::string& someParam)\n    {\n        // Some code you provide in the C++ file, but do not want to see in the header file\n    }\n\n    // Destructs the instance\n    // (this should not be published in the header, since the PImpl will generate its own unique_ptr destructor)\n    ~MyClassPImpl() { /* ... */ }\n\n    // Some method\n    bool SomeMethod() { /* ... */ return true; }\n\n    // Some public static method\n    static bool SomeStaticFunction() { /* ... */ return true;}\n\n\nprivate:\n    void SomePrivateMethod() { /* ... */ }\n\n    std::string mSomePrivateMember;\n    std::future<void> mAnoterPrivateMember;\n};\n\"\"\"\n\npimpl_result = pimpl_my_class.pimpl_my_code(cpp_code, pimpl_options, srcmlcpp_options)\n\n\nif pimpl_result is None:\n    print(\"Failed generated PImpl\")\nelse:\n    litgen_demo.show_cpp_code(pimpl_result.header_code, \"Header Code\")\n    litgen_demo.show_cpp_code(pimpl_result.glue_code, \"Glue Code (paste this in the C++ file)\")\n```\n\n----------------------------------------\n\nTITLE: Installing Build Dependencies for srcML on Ubuntu using Bash\nDESCRIPTION: Installs all required development packages for building srcML from source on Ubuntu systems. Dependencies include libarchive-dev, antlr, libxml2-dev, libxslt-dev, and libcurl4-openssl-dev. This step must be performed before attempting to compile srcML from its source repository.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_20_00_install_srcml.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install libarchive-dev antlr libxml2-dev libxslt-dev libcurl4-openssl-dev\n```\n\n----------------------------------------\n\nTITLE: Executing Litgen Build and Tests in Docker\nDESCRIPTION: This command uses the `docker_run.py` script with the `exec` argument to run a specific command sequence inside the running Docker container. The sequence changes the current directory to `/dvp/sources` within the container and then executes the `ci_build_and_test.sh` script, which handles the project's build (including dependencies like srcml) and test execution. Requires the Docker container to be built and running, and `docker_run.py` to be present.\nSOURCE: https://github.com/pthom/litgen/blob/main/ci_scripts/docker_ci/Readme.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./docker_run.py exec \"cd /dvp/sources && ci_scripts/ci_build_and_test.sh\"\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy\nDESCRIPTION: This command installs the mypy static type checker for Python. It's a prerequisite for type checking Python code.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\npip install mypy  # install mypy (once)\n```\n\n----------------------------------------\n\nTITLE: Displaying Initial C++ PImpl Class Definition using Python\nDESCRIPTION: This Python snippet retrieves an example C++ code string representing a PImpl class implementation (`MyClassPImpl`) using `pimpl_my_class.demo_cpp_no_marker()`. It then utilizes `litgen_demo.show_cpp_code` to display this C++ code, setting the stage for demonstrating boilerplate generation.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/unused_20_10_00_pimpl_my_class.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom srcmlcpp_tools import pimpl_my_class\nfrom litgen.demo import litgen_demo\n\ncpp_code = pimpl_my_class.demo_cpp_no_marker()\nlitgen_demo.show_cpp_code(cpp_code, \"MyClassPImpl cpp file\")\n```\n\n----------------------------------------\n\nTITLE: Cloning and building srcML from source\nDESCRIPTION: Commands to clone a fork of srcML that fixes build issues, build it using CMake, and install it system-wide. This approach uses a specific branch that addresses compilation problems in the original repository.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_20_00_install_srcml.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pthom/srcML.git -b develop_fix_build\nmkdir -p build && cd build\ncmake ../srcML && make -j\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Running Mypy Type Checker\nDESCRIPTION: This command executes mypy to perform static type checking of the Python code.  It will use the mypy.ini file for configuration.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nmypy # each time you want to check your python code\n```\n\n----------------------------------------\n\nTITLE: Suppressing Template Class Warnings\nDESCRIPTION: Shows how to suppress warnings for missing template specializations by configuring the ignored_warning_parts option.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_templates.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# tell litgen to ignore warnings that contain \"Excluding template type ImVector<int>\"\noptions.srcmlcpp_options.ignored_warning_parts.append(\"Excluding template type ImVector<int>\")\n# the following line emits a warning that is ignored\ngenerated_code = litgen.generate_code(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Example GPLv3 Source File Header Comment (Plaintext)\nDESCRIPTION: Provides a template comment block recommended by the FSF for inclusion at the start of source files licensed under GPLv3. It includes placeholders for the program name, copyright notice, and the standard GPLv3 declaration and warranty disclaimer.\nSOURCE: https://github.com/pthom/litgen/blob/main/LICENSE.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n<one line to give the program's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n```\n\n----------------------------------------\n\nTITLE: Generating Bindings for C++ enum class\nDESCRIPTION: This snippet shows how to generate Python bindings for a C++ `enum class` using litgen. Similar to classic C enums, litgen handles the numbering and allows setting macro values. The `litgen_demo.demo` function processes the C++ code and litgen options to create the bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/07_05_00_enums.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n    enum class Foo\n    {\n        A,\n        B,\n        C = MY_VALUE,\n        D = A | B + C,\n        E = 4,\n        F\n    };\n\"\"\"\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.named_number_macros = {\"MY_VALUE\": 256}\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Formatting Python Code with Black\nDESCRIPTION: This command uses black to format Python code in the current directory. It's used for automated code formatting.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nblack .\n```\n\n----------------------------------------\n\nTITLE: Visiting C++ AST elements with a breadth-first traversal\nDESCRIPTION: Defines a visitor function to log information about each C++ element encountered during traversal. It uses 'visit_cpp_breadth_first' to traverse the AST and output element details, useful for analyzing or debugging code structures.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_05_00_cpp_simple_transformations.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef visitor_log_info(cpp_element: srcmlcpp.CppElement, event: srcmlcpp.CppElementsVisitorEvent, depth: int) -> None:\n    if event == srcmlcpp.CppElementsVisitorEvent.OnElement:\n        print(\"  \" * depth + cpp_element.short_cpp_element_info())\n\ncpp_unit.visit_cpp_breadth_first(visitor_log_info)\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks (Bash)\nDESCRIPTION: Installs pre-commit hooks for the current Git repository, enabling automated checks before commits.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Profiling Python Code with cProfile and snakeviz (Bash)\nDESCRIPTION: Installs the 'snakeviz' profiling visualization tool, runs a Python script ('your_test.py') under cProfile saving results to 'profile.prof', and then launches 'snakeviz' to visualize the profiling data.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install snakeviz\npython -m cProfile -o profile.prof your_test.py\nsnakeviz profile.prof\n```\n\n----------------------------------------\n\nTITLE: Exporting simple C++ macro defines to Python globals in Litgen\nDESCRIPTION: This snippet shows how to export simple macro definitions from C++ to Python globals by defining them and configuring options to include macros matching a regex. It uses Litgen options to export macros starting with \"MYLIB_\" and applies a renaming pattern to remove the prefix for cleaner Python variable names.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/09_05_00_preprocessor.ipynb#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#define MYLIB_VALUE 1\n#define MYLIB_FLOAT 1.5\n#define MYLIB_STRING \"abc\"\n#define MYLIB_HEX_VALUE 0x00010009\n```\n\n----------------------------------------\n\nTITLE: Suppressing Specific Litgen Warnings (Python)\nDESCRIPTION: This snippet shows how to configure `litgen` options to suppress specific warnings. By appending parts of the warning messages to `options.srcmlcpp_options.ignored_warning_parts`, these warnings are ignored during processing. After configuration, `generate_code_for_file` is called again, and the generated Python stub code (which should be free of the suppressed warnings) is displayed using `litgen_demo.show_python_code`. Requires `litgen` and `litgen.demo`.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/10_05_00_ignore_warnings.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.ignored_warning_parts.append(\"Can't use a function_decl as a param\")\noptions.srcmlcpp_options.ignored_warning_parts.append(\n    \"operators are supported only when implemented as a member functions\"\n)\noptions.srcmlcpp_options.ignored_warning_parts.append(\"Ignoring template function MyOperation\")\n\n# The next line does not emit warnings anymore\ngenerated_code = litgen.generate_code_for_file(options, \"10_05_10_sample_code.h\")\n\n# The generated code will include only what was correctly converted\nlitgen_demo.show_python_code(generated_code.stub_code)\n```\n\n----------------------------------------\n\nTITLE: Executing full CI test script using Docker and shell\nDESCRIPTION: Runs a continuous integration (CI) test by executing the ci_build_and_test.sh script located in the dvp/sources/ci_scripts directory through a Docker utility script. The command relies on the docker_run.py script to run containerized operations, ensuring consistency in the test environment.\nSOURCE: https://github.com/pthom/litgen/blob/main/ci_scripts/docker_ci/shell_recipes.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./docker_run.py exec  dvp/sources/ci_scripts/ci_build_and_test.sh\n```\n\n----------------------------------------\n\nTITLE: Suppressing Specific litgen Warnings When Generating Code - Python\nDESCRIPTION: This snippet shows how to explicitly suppress particular warnings emitted by litgen by appending warning substrings to the 'ignored_warning_parts' option. Requires litgen and an understanding of the warnings to be filtered. Inputs include a list of warning message substrings; output is code generation without the specified warnings. The snippet demonstrates both suppression and the display of the final generated Python code.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/10_05_00_ignore_warnings.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.ignored_warning_parts.append(\"Can't use a function_decl as a param\")\noptions.srcmlcpp_options.ignored_warning_parts.append(\n    \"operators are supported only when implemented as a member functions\"\n)\noptions.srcmlcpp_options.ignored_warning_parts.append(\"Ignoring template function MyOperation\")\n\n# The next line does not emit warnings anymore\ngenerated_code = litgen.generate_code_for_file(options, \"10_05_10_sample_code.h\")\n\n# The generated code will include only what was correctly converted\nlitgen_demo.show_python_code(generated_code.stub_code)\n\n```\n\n----------------------------------------\n\nTITLE: Generating PImpl Boilerplate Code from Source Code using Python\nDESCRIPTION: This snippet demonstrates how to generate header and glue code for a PImpl class using srcmlcpp_tools.pimpl_my_class.pimpl_my_code. It starts from a source code string, processes it, and outputs two code segments: one for the header and one for glue code to be added at the file bottom. Dependencies include the pimpl_my_class module and litgen_demo for displaying code. The inputs are the source code string, and outputs are the generated code segments.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/unused_20_10_00_pimpl_my_class.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npimpl_result = pimpl_my_class.pimpl_my_code(cpp_code)\n\nif pimpl_result is not None:\n    litgen_demo.show_cpp_code(pimpl_result.header_code, \"Header Code\")\n    litgen_demo.show_cpp_code(pimpl_result.glue_code, \"Glue Code (add this at the bottom of the C++ file)\")\n```\n\n----------------------------------------\n\nTITLE: Python Binding of C++ Function with Arrow Return\nDESCRIPTION: This Python code is generated from the C++ example above.  It shows the resulting Python binding.  It showcases the Python representation of a C++ function with an arrow return type.  The `double` return type in C++ gets correctly translated to `float` in Python.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef my_pow(a: float, b: float) -> float:\npass\n```\n\n----------------------------------------\n\nTITLE: Defining a custom header preprocessing function in Python for Litgen\nDESCRIPTION: This snippet implements a simple Python function to modify header code prior to generation by replacing 'int' with 'Int32'. It assigns this function to the 'code_preprocess_function' option within LitgenOptions, enabling automatic code transformation during processing.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/11_05_00_post_processing.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef preprocess_change_int(code: str) -> str:\n    return code.replace(\"int\", \"Int32\")  # This is a *very* dumb preprocessor\n\ncpp_code = \"\"\"  \nint add(int, int b);\n\"\"\"\n\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.code_preprocess_function = preprocess_change_int\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Creating Example C++/Header Files with PImpl Markers using Python\nDESCRIPTION: This Python snippet prepares example files for the file-based PImpl generation. It calls `pimpl_my_class.create_pimpl_example_files()` to generate a C++ source file and a header file, both containing specific markers (`<pimpl_glue_code>`, `<pimpl_header_code>`). The content of these newly created files is then displayed using `litgen_demo.show_cpp_file`.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/unused_20_10_00_pimpl_my_class.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom srcmlcpp_tools import pimpl_my_class\n\ncpp_file, header_file = pimpl_my_class.create_pimpl_example_files()\n\nlitgen_demo.show_cpp_file(cpp_file)\nlitgen_demo.show_cpp_file(header_file)\n```\n\n----------------------------------------\n\nTITLE: Declaring C++ Functions Mixing API Macro and Auto Return Type\nDESCRIPTION: Displays C++ function declarations utilizing both an API macro and the 'auto' return type, revealing a limitation where srcML cannot reliably parse such signatures. 'MY_API' is a typical export macro, and the functions demonstrate both omitted and arrow return type notation. Use of this pattern currently leads to parsing errors and is not supported by srcML.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nMY_API auto my_modulo(int a, int b)\nMY_API auto my_pow(double a, double b) -> double\n```\n\n----------------------------------------\n\nTITLE: Litgen: Template Function Specialization (Suffix)\nDESCRIPTION: Demonstrates how to use `fn_template_options` to specialize the `LogValue` template function for int and float types, and to give different names to the Python functions by adding a suffix.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n    template<typename T> voi LogValue(const std::string& label, const T& value);\n\"\"\"\noptions = litgen.LitgenOptions()\noptions.fn_template_options.add_specialization(\"^LogValue$\", [\"int\", \"float\"], add_suffix_to_function_name=True)\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Generating Bindings for Multiple Files using LitGen\nDESCRIPTION: This Python snippet demonstrates how to use LitGen to generate bindings for a collection of C++ header files. It specifies a list of input header files and calls the `litgen.write_generated_code_for_files` function. This function generates C++ pydef, glue code, and Python stub files for all the specified headers.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/example_bindings/DasLib/Readme.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n    header_files = [\n        THIS_DIR + \"/cpp_sources/DasLib/DasLib.h\",\n        THIS_DIR + \"/cpp_sources/DasLib/DasLib_2.h\",\n    ]\n    litgen.write_generated_code_for_files(\n        options,\n        input_cpp_header_files=header_files,\n        output_cpp_pydef_file=output_cpp_pydef_file,\n        output_stub_pyi_file=output_stub_pyi_file,\n        output_cpp_glue_code_file=output_cpp_glue_code_file\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Transforming Function Names to snake_case\nDESCRIPTION: This snippet defines a function `change_function_to_snake_case` that transforms a function name to snake_case using `code_utils.to_snake_case` from the `codemanip` library. It also adds a comment indicating that the function name was changed. It depends on the `CppFunctionDecl` class and the `code_utils` module.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom srcmlcpp import CppFunctionDecl, CppType  # import the types we want to apply transformations to\nfrom codemanip import code_utils  # for to_snake_case\n\n\ndef change_function_to_snake_case(cpp_function: CppFunctionDecl):\n    \"\"\"Change a function name to snake_case\"\"\"\n    cpp_function.function_name = code_utils.to_snake_case(cpp_function.function_name)\n    cpp_function.cpp_element_comments.comment_on_previous_lines += \"Was changed to snake case!\"\n```\n\n----------------------------------------\n\nTITLE: Automating PImpl Code Insertion into Existing Source Files\nDESCRIPTION: This snippet shows how to automate modifications in source files by inserting generated PImpl code between specified markers, using pimpl_my_file. It configures options with suffixes, calls the function to update the files, and displays their content after modification. Suitable for integrating PImpl boilerplate into large projects with minimal manual editing.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/unused_20_10_00_pimpl_my_class.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\npimpl_options = PimplOptions()\n pimpl_options.pimpl_suffixes = [\"PImpl\"]\n\npimpl_my_file(cpp_file, header_file)\n```\n\n----------------------------------------\n\nTITLE: Defining Sample C++ Header for API Prefix Example (Python/C++)\nDESCRIPTION: Defines a C++ code snippet stored in a Python string variable `cpp_code`. This header contains two function declarations: `add` with an `MY_API` prefix (indicating it should be exported) and `mul` without a prefix (likely private). This serves as input for demonstrating litgen's API prefix handling.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n// This function has an API marker and is exported in a shared library\nMY_API int add(int, int b);\n\n// This function does not have an API marker, and is probably private\nint mul(int a, int b);\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing post-processing functions for stub and pydef files in Python\nDESCRIPTION: This code defines two post-processing functions that prepend copyright comments to generated code for stub and pydef files. The functions use 'code_utils.unindent_code' to normalize indentation and then concatenate the comments with the original code. These functions are assigned to options for automatic invocation after code generation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/11_05_00_post_processing.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"  \nint AnswerToTheUltimateQuestionOfLife_TheUniverse_AndEverything() { return 42; }\n\"\"\"\n\nfrom codemanip import code_utils\n\ndef postprocess_stub(code: str) -> str:\n    return (\n        code_utils.unindent_code(\n            \"\"\"\n        # Copyright(c) 2023 - Pascal Thomet\n        #    Yes, I claim the copyright on this magnificent function.\n        #    ...At least, I tried...\n        \"\"\"\n        )\n        + code\n    )\n\ndef postprocess_pydef(code: str) -> str:\n    return (\n        code_utils.unindent_code(\n            \"\"\"\n        // Copyright(c) 2023 - Pascal Thomet\n        //    Yes, I claim the copyright on this magnificent function.\n        //    ...At least, I tried...\n        \"\"\"\n        )\n        + code\n    )\n\noptions = litgen.LitgenOptions()\noptions.postprocess_stub_function = postprocess_stub\noptions.postprocess_pydef_function = postprocess_pydef\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Postprocessing Generated Stub and Pydef Files in Litgen Python\nDESCRIPTION: This snippet shows how to define two postprocessing functions that prepend copyright headers to generated stub and pydef code files. The 'postprocess_stub' and 'postprocess_pydef' functions use 'code_utils.unindent_code' to format the copyright notice and concatenate it with the generated code. These functions are then assigned to the relevant Litgen options and used in the demo. Dependencies: 'litgen', 'code_utils' from 'codemanip', 'litgen_demo'. Inputs: generated code string. Outputs: code string with header prepended. Constraints: example uses static text and assumes code manipulating utility is available.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/11_05_00_post_processing.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\nint AnswerToTheUltimateQuestionOfLife_TheUniverse_AndEverything() { return 42; }\n\"\"\"\n\n\nfrom codemanip import code_utils\n\n\ndef postprocess_stub(code: str) -> str:\n    return (\n        code_utils.unindent_code(\n            \"\"\"\n        # Copyright(c) 2023 - Pascal Thomet\n        #    Yes, I claim the copyright on this magnificent function.\n        #    ...At least, I tried...\n        \"\"\"\n        )\n        + code\n    )\n\n\ndef postprocess_pydef(code: str) -> str:\n    return (\n        code_utils.unindent_code(\n            \"\"\"\n        // Copyright(c) 2023 - Pascal Thomet\n        //    Yes, I claim the copyright on this magnificent function.\n        //    ...At least, I tried...\n        \"\"\"\n        )\n        + code\n    )\n\n\noptions = litgen.LitgenOptions()\noptions.postprocess_stub_function = postprocess_stub\noptions.postprocess_pydef_function = postprocess_pydef\nlitgen_demo.demo(options, cpp_code, show_pydef=True)\n```\n\n----------------------------------------\n\nTITLE: Cloning, Building, and Installing srcML from Source using Bash\nDESCRIPTION: Clones a specific development branch of the srcML repository from GitHub, configures a build directory, compiles the source code using cmake and make, and installs the resulting binaries. Requires git, cmake, make, and previously installed dependencies. Output is a working srcML installation on the local system.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_20_00_install_srcml.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pthom/srcML.git -b develop_fix_build\nmkdir -p build && cd build\ncmake ../srcML && make -j\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Glue Code Header in C++\nDESCRIPTION: This C++ header snippet represents the structure of the glue code file generated by LitGen. It includes necessary headers like `<string>` and contains auto-generated code sections. These sections are clearly marked with comments to distinguish them from manually added code.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/example_bindings/DasLib/Readme.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <string>\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// <litgen_glue_code>  // Autogenerated code below! Do not edit!\n// Code will be generated here...\n// </litgen_glue_code> // Autogenerated code end\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n```\n\n----------------------------------------\n\nTITLE: Downloading and Displaying litgen/options.py in Python\nDESCRIPTION: This snippet downloads the content of the `litgen/options.py` file from a GitHub URL and displays it using a demo function. The `code_utils.download_url_content` function retrieves the file content, and `litgen_demo.show_python_code` displays it with a title. Requires the `codemanip` and `litgen.demo` libraries. It downloads the python file from the github repository.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_03_00_options.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nfrom codemanip import code_utils\nfrom litgen.demo import litgen_demo\n\nlitgen_options_code = code_utils.download_url_content(\n    \"https://raw.githubusercontent.com/pthom/litgen/main/src/litgen/options.py\"\n)\nlitgen_demo.show_python_code(litgen_options_code, title=\"litgen/options.py\")\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Preprocessing Function in litgen (Python)\nDESCRIPTION: Initializes `LitgenOptions` and assigns the previously defined `preprocess_change_int` function to the `srcmlcpp_options.code_preprocess_function` option. It then calls `litgen.generate_code` with these options and the sample C++ code, demonstrating how the preprocessing function modifies the code before generation. The resulting generated stub code is displayed.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_00_headers.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.code_preprocess_function = preprocess_change_int\ngenerated_code = litgen.generate_code(options, cpp_code)\nlitgen_demo.show_cpp_code(generated_code.stub_code)\n```\n\n----------------------------------------\n\nTITLE: Adding Namespace to C++ Types\nDESCRIPTION: This snippet defines a function `make_my_module_namespace` that adds a namespace `MyModule::` to types whose names start with `MyModule_`. It iterates through the typenames of the provided `CppType` object and replaces the prefix. It depends on the `CppType` class.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef make_my_module_namespace(cpp_type: CppType):\n    \"\"\"If a type starts with MyModule_, replace it by MyModule::\"\"\"\n\n    def change_typename(typename: str):\n        if typename.startswith(\"MyModule_\"):\n            return typename.replace(\"MyModule_\", \"MyModule::\")\n        else:\n            return typename\n\n    cpp_type.typenames = [change_typename(typename) for typename in cpp_type.typenames]\n```\n\n----------------------------------------\n\nTITLE: Defining API Prefixes for Function Export (litgen)\nDESCRIPTION: This snippet shows how to define API prefixes using the `functions_api_prefixes` option. By setting this option, litgen will only generate bindings for functions that have the specified API prefix (e.g., `MY_API`). This allows you to control which functions are exported in a shared library.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.functions_api_prefixes = \"MY_API\"\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Using write_amalgamate_header_file Utility - Python\nDESCRIPTION: This Python snippet demonstrates how to use the `write_amalgamate_header_file` function. It imports the necessary module, creates an `AmalgamationOptions` object, sets its properties with specific values for the Hello ImGui example, and calls the function to generate the amalgamated header.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_10_amalgamation.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom codemanip import amalgamated_header\n\noptions = amalgamated_header.AmalgamationOptions()\noptions.base_dir = hello_imgui_src_dir                # The base directory of the headers\noptions.local_includes_startwith = \"hello_imgui/\"     # Only headers whose name begin with \"hello_imgui\" should be included\noptions.include_subdirs = [\"hello_imgui\"]             # Include only headers in the hello_imgui directory\noptions.main_header_file = \"hello_imgui.h\"            # The main header file\noptions.dst_amalgamated_header_file = PYDEF_DIR + \"/hello_imgui_amalgamation.h\"  # The destination file\n\namalgamated_header.write_amalgamate_header_file(options)\n```\n\n----------------------------------------\n\nTITLE: Example GPLv3 Interactive Program Startup Notice (Plaintext)\nDESCRIPTION: Shows a sample short notice for interactive programs licensed under GPLv3 to display upon startup. It includes placeholders for the program name, copyright, warranty disclaimer notice, and reference to license conditions (using hypothetical 'show w' and 'show c' commands).\nSOURCE: https://github.com/pthom/litgen/blob/main/LICENSE.txt#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n<program>  Copyright (C) <year>  <name of author>\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n```\n\n----------------------------------------\n\nTITLE: Generated C++ Binding Code\nDESCRIPTION: A C++ binding snippet created by litgen that connects the Python stub to the actual C++ function, enabling calls from Python to C++ via pybind11. It specifies function name, the C++ function being wrapped, function arguments, and the inline documentation for each binding.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/00_00_intro.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"push_item_width\",\n    ImGui::PushItemWidth,\n    py::arg(\"item_width\"),\n    \"push width of items for common large \\\"item+label\\\" widgets. >0.0: width in pixels, <0.0 align xx pixels to the right of window (so -FLT_MIN always align width to the right side).\");\n```\n\n----------------------------------------\n\nTITLE: Setting Numeric Macro Value with Litgen in Python\nDESCRIPTION: This python code snippet sets a numeric macro value for litgen to use. It defines a C++ struct with an array whose size is determined by a macro.  The `options.srcmlcpp_options.named_number_macros` dictionary is used to tell litgen the value of the `MY_COUNT` macro. This is necessary for litgen to properly generate the binding code for the array.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/09_05_00_preprocessor.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n    options.srcmlcpp_options.named_number_macros[\"MY_COUNT\"] = 256\n```\n\n----------------------------------------\n\nTITLE: Parsing C++ Code into a CppElement Tree using srcmlcpp\nDESCRIPTION: Illustrates how to use the `srcmlcpp` library to parse a C++ code string into a `CppElement` object tree. It involves importing the library, initializing `SrcmlcppOptions`, and calling `code_to_cpp_unit` with the options and the code string. The resulting `cpp_unit` variable holds the Python object tree representing the C++ AST.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_00_00_cpp_intro.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport srcmlcpp\n\noptions = srcmlcpp.SrcmlcppOptions()\ncpp_unit = srcmlcpp.code_to_cpp_unit(options, code)\n```\n\n----------------------------------------\n\nTITLE: Converting C++ Code with litgen (Python)\nDESCRIPTION: Demonstrates using litgen to convert provided C++ code into Python bindings. Requires the litgen and litgen.demo modules. Instantiates LitgenOptions and uses litgen_demo.demo to process the cpp_code string. Inputs: options instance, C++ code string. Output: generated Python bindings. Assumes default type replacement configuration.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/04_05_00_names_translation.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\noptions = litgen.LitgenOptions()\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Exporting Non-API Functions with Comments (litgen)\nDESCRIPTION: This snippet demonstrates how to export functions without an API prefix and adds a comment indicating that they are private APIs.  It sets `fn_exclude_non_api` to `False` to include non-API functions and sets `fn_non_api_comment` to add a descriptive comment to the generated code.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\noptions = litgen.LitgenOptions()\noptions.srcmlcpp_options.functions_api_prefixes = \"MY_API\"\noptions.fn_exclude_non_api = False\noptions.fn_non_api_comment = \"Private API!\"\nlitgen_demo.demo(options, cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Bindings for litgen Integration Tests Using Bash\nDESCRIPTION: This Bash snippet demonstrates how to install the 'lg-mylib' pip package, which is the Python binding library generated by litgen for the native C++ library 'mylib'. It supports both editable installs (with the '-e' flag) for development purposes and regular installs. The command assumes the user is in the appropriate directory containing the setup files.\nSOURCE: https://github.com/pthom/litgen/blob/main/src/litgen/integration_tests/Readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install [-e] .\n```\n\n----------------------------------------\n\nTITLE: Python Binding with Arrow Return - Example\nDESCRIPTION: This code shows how C++ functions with arrow return type notation are exported to Python. The return type is correctly preserved in the Python binding.  The original C++ function definition includes the return type specified using `-> double`. This illustrates how arrow return types are translated into Python.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nauto my_pow(double a, double b) -> double\n```\n\n----------------------------------------\n\nTITLE: Hello ImGui directory structure example\nDESCRIPTION: Shows the directory structure of the Hello ImGui library, which is used as an example for creating an amalgamation header. It illustrates the organization of header files and internal components.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_10_amalgamation.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nsrc\n├── CMakeLists.txt\n├── hello_imgui\n│     ├── CMakeLists.txt\n│     ├── app_window_params.h\n│     ├── hello_imgui.h           -->  ( hello_imgui.h is the main header, included by users\n│     ├── imgui_window_params.h          it \"#include\" all other public API headers )\n│     ├── ... (other headers)\n│     │\n│     ├── internal\n│     │     ├── borderless_movable.cpp\n│     │     ├── borderless_movable.h\n│     │     ├── clock_seconds.cpp\n│     │     ├── clock_seconds.h\n│     │     ├── ... (other headers and c++ files)\n│     │     ├── ... (not part of the public API)\n```\n\n----------------------------------------\n\nTITLE: C++ Bindings Example\nDESCRIPTION: This C++ code snippet demonstrates the actual bindings generated by litgen using pybind11. It defines a Python function that calls the C++ function `ImGui::PushItemWidth`. The snippet includes argument parsing and a docstring that is exposed to Python, enhancing the usability of the bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/00_00_intro.md#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"push_item_width\",\n    ImGui::PushItemWidth,\n    py::arg(\"item_width\"),\n    \"push width of items for common large \\\"item+label\\\" widgets. >0.0: width in pixels, <0.0 align xx pixels to the right of window (so -FLT_MIN always align width to the right side).\");\n```\n\n----------------------------------------\n\nTITLE: Python Stub for C++ Function with Arrow Return Type\nDESCRIPTION: Presents the Python binding stub automatically generated for a C++ function with explicit arrow return type. The function 'my_pow' accepts two floats and returns a float, reflecting a precise translation from C++ types to Python annotations. No manual annotations required; the mapping is handled by the binding generator.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef my_pow(a: float, b: float) -> float:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Building the Litgen Docker Container\nDESCRIPTION: This command executes the `docker_run.py` script with the `build` argument. It is used to construct a Docker image containing all the necessary dependencies and environment setup required for the 'litgen' project. Assumes `docker_run.py` exists and is executable in the current directory.\nSOURCE: https://github.com/pthom/litgen/blob/main/ci_scripts/docker_ci/Readme.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./docker_run.py build\n```\n\n----------------------------------------\n\nTITLE: Declaring C++ Function with Arrow Return Type Notation\nDESCRIPTION: Illustrates a C++ function using arrow return type notation, which srcML and Python bindings handle correctly, exporting explicit return types to the Python stub. The function 'my_pow' takes two double arguments and returns a double. No additional dependencies needed. This pattern ensures accurate type annotation in generated Python bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/12_05_00_srcml_issues.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nauto my_pow(double a, double b) -> double\n```\n\n----------------------------------------\n\nTITLE: C++ Code with API Markers - Parsing Warning\nDESCRIPTION: This snippet highlights an incompatibility between API markers and the `auto` return type in C++ functions when using srcML. Functions mixing these features will not be parsed correctly. The code defines two functions using `MY_API` to mark the API but the `auto` return type causes problems. No explicit dependencies, only a srcML parser is needed.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n    MY_API auto my_modulo(int a, int b)\n    MY_API auto my_pow(double a, double b) -> double\n```\n\n----------------------------------------\n\nTITLE: Running Litgen Code Generation (Bash)\nDESCRIPTION: Executes the 'autogenerate_bindings.py' script using python. This script uses litgen to generate the C++ binding code and Python stubs based on the C++ library's header files. The generated code is placed in the '_pydef_pybind11/' or '_pydef_nanobind/' and '_stubs/' directories.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython tools/autogenerate_bindings.py\n```\n\n----------------------------------------\n\nTITLE: Python Binding with Inferred Return - Example\nDESCRIPTION: This snippet demonstrates how C++ functions with inferred return types are handled during the export to Python. Inferred return types are marked as `Any` in Python. The example shows a simple function which return type is inferred from the return value.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nauto my_pow(double a, double b)\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment (Bash)\nDESCRIPTION: Creates a Python virtual environment named 'venv' and activates it. This isolates the project's dependencies from the system's global Python environment. Using virtual environments is a recommended practice to manage dependencies and avoid conflicts between projects.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv\nsource venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Defining Struct with Macro-Defined Array Size in C++\nDESCRIPTION: This C++ code snippet defines a struct `Foo` containing an array `values` whose size is determined by the preprocessor macro `MY_COUNT`. Litgen requires the value of `MY_COUNT` to be explicitly provided to correctly handle the array size during binding generation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/09_05_00_preprocessor.ipynb#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#define MY_COUNT 256\n\nstruct Foo\n{\n    int values[MY_COUNT];\n};\n```\n\n----------------------------------------\n\nTITLE: C++ Function Signature Example\nDESCRIPTION: This example shows a C++ function signature that litgen can process to generate Python bindings. It includes comments describing the function's purpose and parameters. This code serves as input for litgen to create documented bindings.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/00_00_intro.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// Parameters stacks (current window)\nIMGUI_API void          PushItemWidth(float item_width); // push width of items for common large \"item+label\" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Function Signature Example (Python String Literal)\nDESCRIPTION: Declares a Python string containing a C++ function signature featuring a template class and a standard vector. This string represents the C++ source code to be processed by litgen for binding generation. No dependencies; the string is a standalone representation intended as input for subsequent code generation steps.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/04_05_00_names_translation.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ncpp_code = \"\"\"\n    MyPair<int, int> GetMinMax(std::vector<int>& values);\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: C++ Code Snippet for Litgen Demo\nDESCRIPTION: This C++ code defines a template class `MyPair` and a function `GetMinMax` that uses it. It's used as input for the litgen demo to demonstrate type replacements.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/04_05_00_names_translation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncpp_code = \"\"\"\n    MyPair<int, int> GetMinMax(std::vector<int>& values);\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: C/C++ Header Code Sample with Conditional Compilation\nDESCRIPTION: This is a C/C++ header code snippet demonstrating the use of preprocessor directives for conditional compilation. It includes an inclusion guard and different code blocks that are enabled or disabled based on the `ARCANE_OPTION` and `COMMON_OPTION` preprocessor definitions.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_00_headers.ipynb#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#ifndef MY_HEADER_H   // This is an inclusion guard, it should not be filtered out\n\nvoid Foo() {}\n\n#ifdef ARCANE_OPTION\n    // We are entering a zone that handle arcane options that should not be included in the bindings\n    void Foo2() {}\n#else\n    // this should also not be included in the bindings\n    void Foo3() {}\n#endif\n\n#ifdef COMMON_OPTION\n    // We are entering a zone for which we would like to publish bindings\n    void Foo4();\n#endif\n\n#endif // #ifndef MY_HEADER_H\n```\n\n----------------------------------------\n\nTITLE: C++ Template Function Definition (LogValue)\nDESCRIPTION: Defines a C++ template function `LogValue` that takes a label and a value of type `T`. This example demonstrates how to export template functions with a suffix.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T> voi LogValue(const std::string& label, const T& value);\n```\n\n----------------------------------------\n\nTITLE: Printing Original C++ Code\nDESCRIPTION: This snippet shows how to print the original source code of the `CppUnit` object using the `str_code_verbatim` method and displays it using litgen_demo.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nlitgen_demo.show_cpp_code(cpp_unit.str_code_verbatim())\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Macros in C++\nDESCRIPTION: This code snippet shows simple preprocessor defines that can be exported as global variables to Python using litgen. It includes examples of integer, float, string, and hexadecimal values. These simple defines can be directly extracted by litgen based on naming patterns.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/09_05_00_preprocessor.ipynb#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n    #define MYLIB_VALUE 1\n    #define MYLIB_FLOAT 1.5\n    #define MYLIB_STRING \"abc\"\n    #define MYLIB_HEX_VALUE 0x00010009\n```\n\n----------------------------------------\n\nTITLE: Litgen: Type Replacement\nDESCRIPTION: Sets up a type name replacement using `type_replacements` to expose `ImGuiConfig` as `Config` in Python. This removes the `ImGui` prefix.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/07_05_00_templates.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\noptions.type_replacements.add_last_replacement(r\"ImGui([A-Z][a-zA-Z0-9]*)\", r\"\\1\")\n```\n\n----------------------------------------\n\nTITLE: Running Pytest\nDESCRIPTION: This command executes all tests in the project using the pytest framework. It relies on pytest.ini configuration and tests in the 'tests' folder.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\npytest # each time you want to run your python tests\n```\n\n----------------------------------------\n\nTITLE: Creating Example C++ and Header Files for PImpl Integration\nDESCRIPTION: This code creates sample C++ and header files with embedded markers for inserting generated PImpl code. The function create_pimpl_example_files() returns these files, which can then be displayed or manipulated. It simplifies the process of setting up initial files for PImpl boilerplate integration in a codebase.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/unused_20_10_00_pimpl_my_class.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ncpp_file, header_file = pimpl_my_class.create_pimpl_example_files()\n\nlitgen_demo.show_cpp_file(cpp_file)\nlitgen_demo.show_cpp_file(header_file)\n```\n\n----------------------------------------\n\nTITLE: C++ Code Parsing - Correct Function Declaration\nDESCRIPTION: This snippet shows the correct parsing of a C++ function declaration with a default parameter.  It contrasts the correct parsing with the incorrect parsing observed in the previous snippet.  The function is declared with a default value of 0. No specific dependencies are needed for this example, it serves as a clarifying example.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/12_05_00_srcml_issues.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid Foo(int v = 0 );\n```\n\n----------------------------------------\n\nTITLE: Example Generated Amalgamation Header - C++\nDESCRIPTION: This C++ snippet shows the expected structure of the generated amalgamation header file (`hello_imgui_amalgamation.h`). It includes comments indicating automatic generation and sections for each included header file, incorporating their content directly.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_10_amalgamation.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// THIS FILE WAS GENERATED AUTOMATICALLY. DO NOT EDIT.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                       hello_imgui.h                                                                          //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined(__ANDROID__) && defined(HELLOIMGUI_USE_SDL2)\n// We need to include SDL, so that it can instantiate its main function under Android\n#include \"SDL.h\"\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                       hello_imgui/dpi_aware.h included by hello_imgui.h                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#include \"imgui.h\"\n\nnamespace HelloImGui\n{\n... (content of hello_imgui/dpi_aware.h)\n}\n... (other includes)\n```\n\n----------------------------------------\n\nTITLE: Importing the amalgamated_header module in Python\nDESCRIPTION: Shows how to import the amalgamated_header module from codemanip to access the amalgamation functionality in Litgen.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/02_05_10_amalgamation.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom codemanip import amalgamated_header\n```\n\n----------------------------------------\n\nTITLE: Installing Litgen with pip\nDESCRIPTION: Command to install litgen from GitHub repository using pip. This allows for local installation and integration with your build process for generating C++ bindings and Python stubs.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/01_05_00_install_or_online.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install \"litgen@git+https://github.com/pthom/litgen\"\n```\n\n----------------------------------------\n\nTITLE: Running Pyright Type Checker\nDESCRIPTION: This command runs the pyright type checker. It validates Python code against static type hints using the pyrightconfig.json file for configuration.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\npyright # each time you want to check your python code\n```\n\n----------------------------------------\n\nTITLE: Visiting CppElement Tree with Breadth-First Traversal\nDESCRIPTION: This snippet shows how to visit a `CppElement` tree using breadth-first traversal. A visitor function (`visitor_log_info`) is defined to process each element. In this example, it logs the short info of each element visited. The `visit_cpp_breadth_first` method of the `CppUnit` object is then called to start the traversal using the custom visitor function.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_05_00_cpp_simple_transformations.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef visitor_log_info(cpp_element: srcmlcpp.CppElement, event: srcmlcpp.CppElementsVisitorEvent, depth: int) -> None:\n    if event == srcmlcpp.CppElementsVisitorEvent.OnElement:\n        print(\"  \" * depth + cpp_element.short_cpp_element_info())\n\n\ncpp_unit.visit_cpp_breadth_first(visitor_log_info)\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Linter and Formatter\nDESCRIPTION: This command runs ruff to check and format python code in the current directory. It utilizes the ruff tool, assuming it is installed.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nruff .\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff\nDESCRIPTION: This command installs the ruff linter and code formatter. It's a prerequisite to using ruff for code quality checks and formatting.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npip install ruff # install ruff (once)\n```\n\n----------------------------------------\n\nTITLE: Installing Black\nDESCRIPTION: This command installs the black code formatter. It's a prerequisite to formatting Python code according to Black's style.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/litgen_template/README.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\npip install black # install black (once)\n```\n\n----------------------------------------\n\nTITLE: Installing a Package from TestPyPI using Pip (Shell)\nDESCRIPTION: This command uses Pip to install the 'srcmlcpp' package. The '-i' flag directs Pip to use the specified index URL (TestPyPI's simple index) instead of the default PyPI index, allowing installation of packages hosted on TestPyPI.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/pypi_publish.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install -i https://test.pypi.org/simple/ srcmlcpp\n```\n\n----------------------------------------\n\nTITLE: Publishing a Package to TestPyPI using Poetry (Shell)\nDESCRIPTION: This command uses Poetry to build and upload the current Python package to the TestPyPI repository previously configured under the alias 'test-pypi'. The '-r' flag specifies the target repository.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/pypi_publish.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npoetry publish -r test-pypi\n```\n\n----------------------------------------\n\nTITLE: Configuring Poetry for TestPyPI Publishing (Shell)\nDESCRIPTION: These commands configure the Poetry tool to interact with the TestPyPI repository. The first command sets the URL for the 'test-pypi' repository alias. The second command associates a PyPI API token (starting with 'pypi-AgENdGV...') with the 'test-pypi' repository for authentication during publishing.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/pypi_publish.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npoetry config repositories.test-pypi https://test.pypi.org/legacy/\n```\n\nLANGUAGE: shell\nCODE:\n```\npoetry config pypi-token.test-pypi pypi-AgENdGV...\n```\n\n----------------------------------------\n\nTITLE: Installing Integration Test Library in Editable Mode (Bash)\nDESCRIPTION: Navigates into the integration tests directory, installs its package in editable mode (-e) with verbose output (-v) using pip, and returns to the previous directory.\nSOURCE: https://github.com/pthom/litgen/blob/main/Build.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd src/litgen/integration_tests\npip install -v -e .\ncd -\n```\n\n----------------------------------------\n\nTITLE: Loading and Displaying C++ Code (Python)\nDESCRIPTION: This snippet demonstrates loading the content of a specific C++ header file (`10_05_10_sample_code.h`) into a Python string. It then uses `litgen_demo.show_cpp_code` to display the code, which is useful for inspecting the source before processing. This requires the `litgen` library and its demo module.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/10_05_00_ignore_warnings.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\nwith open(\"10_05_10_sample_code.h\") as f:\n    cpp_code = f.read()\n\nlitgen_demo.show_cpp_code(cpp_code)\n```\n\n----------------------------------------\n\nTITLE: Loading and Displaying C++ Code with litgen - Python\nDESCRIPTION: This snippet demonstrates how to load the contents of a C++ header file (e.g., '10_05_10_sample_code.h') and display its source code using litgen's demo utilities. It requires the 'litgen' library and access to the demo submodule. The input is a filename, and the output is the code shown via a litgen utility function.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/10_05_00_ignore_warnings.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport litgen\nfrom litgen.demo import litgen_demo\n\nwith open(\"10_05_10_sample_code.h\") as f:\n    cpp_code = f.read()\n\nlitgen_demo.show_cpp_code(cpp_code)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Amalgamation Options and Utility Function - Python\nDESCRIPTION: This snippet defines the `AmalgamationOptions` dataclass, which holds configuration for generating the amalgamation header, and the signature for the `write_amalgamate_header_file` function that performs the generation. It details the parameters required for the process, such as base directory, include filters, source, and destination file paths.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/02_05_10_amalgamation.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n@dataclass\nclass AmalgamationOptions:\n    base_dir: str                     # The base directory of the headers\n    local_includes_startwith: str     # Only headers whose name begin with this string should be included\n    include_subdirs: list[str]        # Include only headers in these subdirectories\n\n    main_header_file: str             # The main header file\n    dst_amalgamated_header_file: str  # The destination file\n\ndef write_amalgamate_header_file(options: AmalgamationOptions) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Installing Build Dependencies for srcML on macOS using Bash\nDESCRIPTION: Uses Homebrew to install the antlr2 and boost libraries required for building srcML from source on macOS. This command assumes Homebrew is already installed. Ensure internet connectivity to fetch the packages.\nSOURCE: https://github.com/pthom/litgen/blob/main/docs/litgen_book/_sources/20_20_00_install_srcml.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install antlr2 boost\n```\n\n----------------------------------------\n\nTITLE: Installing required packages for srcML build on macOS\nDESCRIPTION: Command to install the dependencies required to build srcML from source on macOS using Homebrew. These packages are necessary for successful compilation.\nSOURCE: https://github.com/pthom/litgen/blob/main/litgen-book/20_20_00_install_srcml.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install antlr2 boost\n```"
  }
]