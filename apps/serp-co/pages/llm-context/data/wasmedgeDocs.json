[
  {
    "owner": "wasmedge",
    "repo": "docs",
    "content": "TITLE: Complete WasmEdge Execution Example in C\nDESCRIPTION: A complete example demonstrating how to execute a Fibonacci WASM module using WasmEdge C API. It shows the full workflow: creating contexts, loading, validating, instantiating the module, listing exported functions, and executing the 'fib' function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /*\n   * Create the configure context. This step is not necessary because we didn't\n   * adjust any setting.\n   */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /*\n   * Create the statistics context. This step is not necessary if the statistics\n   * in runtime is not needed.\n   */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /*\n   * Create the store context. The store context is the object to link the\n   * modules for imports and exports.\n   */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /*\n   * Create the executor context. The configure context and the statistics\n   * context can be NULL.\n   */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /*\n   * Load the WASM file or the compiled-WASM file and convert into the AST\n   * module context.\n   */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /*\n   * If the list length is larger than the buffer length, the overflowed data\n   * will be discarded.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function `fib` not found.\\n\");\n    return 1;\n  }\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Module Instantiation and Execution\nDESCRIPTION: Comprehensive example showing how to load, validate, and instantiate a WebAssembly module in WasmEdge. Includes module registration, function execution, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* Create VM and load module */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* ... Module loading and execution code ... */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ModuleInstanceDelete(LibInstCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Detailed WasmEdge VM Lifecycle Management in Go\nDESCRIPTION: Step-by-step implementation of WebAssembly module loading, validation, instantiation, and execution using WasmEdge VM. Demonstrates complete control over the VM lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  // Developers can load, validate, and instantiate another WASM module\n  // to replace the instantiated one. In this case, the old module will\n  // be cleared, but the registered modules are still kept.\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  // Developers can execute functions repeatedly after instantiation.\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Host Function Integration with WebAssembly in WasmEdge\nDESCRIPTION: A complete example that demonstrates creating a VM context, defining a host function, creating an import object, adding the host function to the import object, and registering it with the VM. This shows the full workflow of host function integration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n  };\n\n  /* Create the import object. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\n  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\n  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);\n```\n\n----------------------------------------\n\nTITLE: Manual Instantiation and Asynchronous Execution of WASM Functions with WasmEdge C API\nDESCRIPTION: This C code snippet demonstrates how to manually load, validate, instantiate, and asynchronously execute a WebAssembly function using the WasmEdge C API. It provides a step-by-step approach for more control over the execution process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBytes()` API, or from `WasmEdge_ASTModuleContext`\n   * object with the `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete WasmEdge Execution Example in C\nDESCRIPTION: A comprehensive example demonstrating the step-by-step process of loading, validating, instantiating, and executing a Fibonacci calculator WASM module. It includes creating all necessary contexts, listing exported functions, invoking the 'fib' function, and properly deallocating resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /*\n   * Create the configure context. This step is not necessary because we didn't\n   * adjust any setting.\n   */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /*\n   * Create the statistics context. This step is not necessary if the statistics\n   * in runtime is not needed.\n   */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /*\n   * Create the store context. The store context is the object to link the\n   * modules for imports and exports.\n   */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /*\n   * Create the executor context. The configure context and the statistics\n   * context can be NULL.\n   */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /*\n   * Load the WASM file or the compiled-WASM file and convert into the AST\n   * module context.\n   */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /*\n   * If the list length is larger than the buffer length, the overflowed data\n   * will be discarded.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function `fib` not found.\\n\");\n    return 1;\n  }\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Runtime on Linux/MacOS\nDESCRIPTION: This command downloads and executes the WasmEdge installation script, which sets up the runtime environment on generic Linux and MacOS platforms. It requires `git` and `curl` to be installed on the system. This script is typically the first step in setting up the WasmEdge environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Executing WASM with WasmEdge in Go\nDESCRIPTION: This Go code snippet showcases the complete process of loading, validating, instantiating, and executing a WASM module using WasmEdge. It covers setting logging levels, creating configuration, loader, validator, executor, and store objects, loading the WASM file, validating the module, instantiating the module, invoking a function, and releasing resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\n\"package main\n\nimport (\n  \\\"fmt\\\"\n\n  \\\"github.com/second-state/WasmEdge-go/wasmedge\\\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n  var mod *wasmedge.Module\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\\\"fibonacci.wasm\\\")\n  if err != nil {\n    fmt.Println(\\\"Load WASM from file FAILED:\\\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\\\"Validation FAILED:\\\", err.Error())\n    return\n  }\n  // Instantiate the WASM module and get the output module instance.\n  mod, err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\\\"Instantiation FAILED:\\\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := mod.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\\\"Exported function name:\\\", fname)\n  }\n\n  // Invoke the WASM function.\n  funcinst := mod.FindFunction(\\\"fib\\\")\n  if funcinst == nil {\n    fmt.Println(\\\"Run FAILED: Function name `fib` not found\\\")\n    return\n  }\n  res, err = executor.Invoke(store, funcinst, int32(30))\n  if err == nil {\n    fmt.Println(\\\"Get fibonacci[30]:\\\", res[0].(int32))\n  } else {\n    fmt.Println(\\\"Run FAILED:\\\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n  mod.Release()\n}\"\n```\n\n----------------------------------------\n\nTITLE: Host Data with Finalizer in WasmEdge Module Instance\nDESCRIPTION: Example of creating a module instance with custom host data and a finalizer. This demonstrates how to pass structured data to host functions and properly manage memory when the module is destroyed, which is useful for implementing plugins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_85\n\nLANGUAGE: c\nCODE:\n```\n/* Struct definition. */\ntypedef struct Point {\n  int X;\n  int Y;\n} Point;\n\n/* Host function body definition. */\nWasmEdge_Result Print(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  Point *P = (Point *)In;\n  printf(\"Point: (%d, %d)\\n\", P->X, P->Y);\n  return WasmEdge_Result_Success;\n}\n\n/* Finalizer definition. */\nvoid PointFinalizer(void *Data) {\n  if (Data) {\n    free((Point *)Data);\n  }\n}\n\n/* Create a module instance with host data and its finalizer. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nPoint *Data = (Point *)malloc(sizeof(Point));\nData->X = 5;\nData->Y = -5;\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);\n/*\n* When the `HostModCxt` being destroyed, the finalizer will be invoked and the\n* `Data` will be its argument.\n*/\nWasmEdge_StringDelete(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Manually Instantiate and Run WASM Functions with WasmEdge\nDESCRIPTION: This snippet explains how to manually load, validate, instantiate, and execute a WebAssembly function. Each phase is handled separately, allowing more control over the WASM execution process. Important phases include loading and validating the WASM module, and creating instances using WasmEdge context management functions. The snippet handles input parameters for the Fibonacci function and demonstrates comprehensive error handling and result retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\\n#include <stdio.h>\\nint main() {\\n  /* Create the configure context and add the WASI support. */\\n  /* This step is not necessary unless you need the WASI support. */\\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\\n                                         WasmEdge_HostRegistration_Wasi);\\n  /* The configure and store context to the VM creation can be NULL. */\\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\\n\\n  /* The parameters and returns arrays. */\\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};\\n  WasmEdge_Value Returns[1];\\n  /* Function name. */\\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\\\"fib\\\");\\n  /* Result. */\\n  WasmEdge_Result Res;\\n\\n  /* Step 1: Load WASM file. */\\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \\\"fibonacci.wasm\\\");\\n  /*\\n   * Developers can load the WASM binary from buffer with the\\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\\n   * `WasmEdge_ASTModuleContext` object with the\\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\\n   */\\n  if (!WasmEdge_ResultOK(Res)) {\\n    printf(\\\"Loading phase failed: %s\\\\n\\\", WasmEdge_ResultGetMessage(Res));\\n    return 1;\\n  }\\n  /* Step 2: Validate the WASM module. */\\n  Res = WasmEdge_VMValidate(VMCxt);\\n  if (!WasmEdge_ResultOK(Res)) {\\n    printf(\\\"Validation phase failed: %s\\\\n\\\", WasmEdge_ResultGetMessage(Res));\\n    return 1;\\n  }\\n  /* Step 3: Instantiate the WASM module. */\\n  Res = WasmEdge_VMInstantiate(VMCxt);\\n  /*\\n   * Developers can load, validate, and instantiate another WASM module to\\n   * replace the instantiated one. In this case, the old module will be\\n   * cleared, but the registered modules are still kept.\\n   */\\n  if (!WasmEdge_ResultOK(Res)) {\\n    printf(\\\"Instantiation phase failed: %s\\\\n\\\",\\n           WasmEdge_ResultGetMessage(Res));\\n    return 1;\\n  }\\n  /*\\n   * Step 4: Execute WASM functions. You can execute functions repeatedly\\n   * after instantiation.\\n   */\\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\\n  if (WasmEdge_ResultOK(Res)) {\\n    printf(\\\"Get the result: %d\\\\n\\\", WasmEdge_ValueGetI32(Returns[0]));\\n  } else {\\n    printf(\\\"Execution phase failed: %s\\\\n\\\", WasmEdge_ResultGetMessage(Res));\\n  }\\n\\n  /* Resources deallocations. */\\n  WasmEdge_VMDelete(VMCxt);\\n  WasmEdge_ConfigureDelete(ConfCxt);\\n  WasmEdge_StringDelete(FuncName);\\n  return 0;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Runtime CLI Tool Implementation\nDESCRIPTION: Implementation of the WasmEdge runtime CLI tool using C API, equivalent to 'wasmedge run' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_89\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing File I/O Operations in Rust for WASI\nDESCRIPTION: This Rust code demonstrates file operations in a WASI environment using the std::fs module. It includes functions for creating, reading, and deleting files, with error handling for file operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs;\nuse std::fs::File;\nuse std::io::{Write, Read};\n\npub fn create_file(path: &str, content: &str) {\n  let mut output = File::create(path).unwrap();\n  output.write_all(content.as_bytes()).unwrap();\n}\n\npub fn read_file(path: &str) -> String {\n  let mut f = File::open(path).unwrap();\n  let mut s = String::new();\n  match f.read_to_string(&mut s) {\n    Ok(_) => s,\n    Err(e) => e.to_string(),\n  }\n}\n\npub fn del_file(path: &str) {\n  fs::remove_file(path).expect(\"Unable to delete\");\n}\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge-Go Package\nDESCRIPTION: Commands to get and build the WasmEdge-Go package in a Go project\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\ngo build\n```\n\n----------------------------------------\n\nTITLE: Loading and Executing WASM Module in C with WasmEdge\nDESCRIPTION: This code demonstrates how to load a WASM file, validate it, instantiate the module, list exported functions, and invoke a specific function using the WasmEdge C API. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /*\n   * Create the configure context. This step is not necessary because we didn't\n   * adjust any setting.\n   */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /*\n   * Create the statistics context. This step is not necessary if the statistics\n   * in runtime is not needed.\n   */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /*\n   * Create the store context. The store context is the object to link the\n   * modules for imports and exports.\n   */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /*\n   * Create the executor context. The configure context and the statistics\n   * context can be NULL.\n   */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /*\n   * Load the WASM file or the compiled-WASM file and convert into the AST\n   * module context.\n   */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /*\n   * If the list length is larger than the buffer length, the overflowed data\n   * will be discarded.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function `fib` not found.\\n\");\n    return 1;\n  }\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Functions with WasmEdge in Golang\nDESCRIPTION: This snippet shows how to use the WasmEdge Golang SDK to execute WebAssembly functions. It demonstrates setting up the VM, loading a WASM module, and calling various functions using wasmedge-bindgen.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportObject(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:.\"},  // The mapping preopens\n  )\n\n  // Load and validate the wasm\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n\n  // Instantiate the bindgen and vm\n  bg := bindgen.Instantiate(vm)\n\n  // Execute various functions\n  res, err := bg.Execute(\"create_line\", \"{\\\"x\\\":2.5,\\\"y\\\":7.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", res[0].(string))\n  }\n\n  // ... more function calls ...\n\n  bg.Release()\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Go Host Application for WebAssembly Execution\nDESCRIPTION: Go program that uses WasmEdge SDK to execute the WebAssembly module. It configures the WASI environment and runs the WebAssembly file with proper argument passing and environment setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/app.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n\n  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)\n  conf.AddConfig(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:.\"},  // The mapping directories\n  )\n\n  // Instantiate wasm. _start refers to the main() function\n  vm.RunWasmFile(os.Args[1], \"_start\")\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Host Module in WasmEdge\nDESCRIPTION: This snippet shows how to register a host module in a WasmEdge VM. It creates a new `VM` object, creates a `WasiModule` object, registers the module with the VM, and then releases both objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\n```go\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)\n\nres := vm.RegisterModule(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n```\n\n----------------------------------------\n\nTITLE: Complete Example of WebAssembly Host Function Integration in WasmEdge C API\nDESCRIPTION: This comprehensive example demonstrates creating a VM context, defining a host function, registering it in a module instance, and executing a WebAssembly function that calls the host function. It shows the complete workflow of host function integration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                   const WasmEdge_CallingFrameContext *CallFrameCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                   0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                   /* Type section */\n                   0x01, 0x07, 0x01,\n                   /* function type {i32, i32} -> {i32} */\n                   0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                   /* Import section */\n                   0x02, 0x13, 0x01,\n                   /* module name: \"extern\" */\n                   0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                   /* extern name: \"func-add\" */\n                   0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                   /* import desc: func 0 */\n                   0x00, 0x00,\n                   /* Function section */\n                   0x03, 0x02, 0x01, 0x00,\n                   /* Export section */\n                   0x07, 0x0A, 0x01,\n                   /* export name: \"addTwo\" */\n                   0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                   /* export desc: func 0 */\n                   0x00, 0x01,\n                   /* Code section */\n                   0x0A, 0x0A, 0x01,\n                   /* code body */\n                   0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                       WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                             WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly with WasmEdge C API\nDESCRIPTION: This snippet demonstrates the complete process of loading, validating, instantiating, and executing a WebAssembly module using the WasmEdge C API. It includes error handling, listing exported functions, and invoking a specific function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /* Create the store context. The store context is the WASM runtime structure core. */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /* Create the executor context. The configure context and the statistics context can be NULL. */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */\n  uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Memory Instances (C)\nDESCRIPTION: Demonstrates the creation of memory instances, setting and getting data, growing memory pages, and proper cleanup. It includes examples of handling out-of-bounds access errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\nWasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(MemTypeCxt);\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\n\nuint8_t Buf[256];\nBuf[0] = 0xAA; Buf[1] = 0xBB; Buf[2] = 0xCC;\nWasmEdge_Result Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions in Go for WebAssembly\nDESCRIPTION: Example of implementing a host function in Go that can be called from WebAssembly. This shows how to create a module with a host function, register it to a VM, and execute a WebAssembly function that calls the host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_75\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: List Exported Functions with WasmEdge in Go\nDESCRIPTION: This code lists the exported function names and function types of a WASM module instantiated in WasmEdge.  It loads, validates, and instantiates the module, and then retrieves the lists of function names and types using vm.GetFunctionList(). The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an HTTP Server in JavaScript\nDESCRIPTION: JavaScript code for creating an HTTP server using Node.js-compatible APIs. The server listens on port 8001 and echoes back request data with an 'echo:' prefix.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createServer, request, fetch } from 'http';\n\ncreateServer((req, resp) => {\n  req.on('data', (body) => {\n    resp.write('echo:');\n    resp.end(body);\n  });\n}).listen(8001, () => {\n  print('listen 8001 ...\\n');\n});\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Functions from Go using WasmEdge\nDESCRIPTION: This Go code demonstrates how to load and execute WebAssembly functions using the WasmEdge runtime. It sets up the WasmEdge VM, loads the WASM file, and calls various functions with different parameter types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/function.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  // Expected Args[0]: program name (./bindgen_funcs)\n  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))\n\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n  // Instantiate the bindgen and vm\n  bg := bindgen.New(vm)\n  bg.Instantiate()\n\n  // Run bindgen functions\n  var res []interface{}\n  var err error\n  // create_line: array, array, array -> array (inputs are JSON stringified)\n  res, _, err = bg.Execute(\"create_line\", \"{\\\"x\\\":1.5,\\\"y\\\":3.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- create_line FAILED\")\n  }\n  // say: array -> array\n  res, _, err = bg.Execute(\"say\", \"bindgen funcs test\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- say:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- say FAILED\")\n  }\n  // obfusticate: array -> array\n  res, _, err = bg.Execute(\"obfusticate\", \"A quick brown fox jumps over the lazy dog\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- obfusticate:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- obfusticate FAILED\")\n  }\n  // lowest_common_multiple: i32, i32 -> i32\n  res, _, err = bg.Execute(\"lowest_common_multiple\", int32(123), int32(2))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple FAILED\")\n  }\n  // sha3_digest: array -> array\n  res, _, err = bg.Execute(\"sha3_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- sha3_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- sha3_digest FAILED\")\n  }\n  // keccak_digest: array -> array\n  res, _, err = bg.Execute(\"keccak_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- keccak_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- keccak_digest FAILED\")\n  }\n\n  bg.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly with Host Functions in WasmEdge C API\nDESCRIPTION: This code demonstrates integrating a WebAssembly module with host functions in WasmEdge. It creates a VM context, defines a custom module with a host function implementation, and executes a WebAssembly function from an in-memory buffer. The example shows parameter passing and result retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_83\n\nLANGUAGE: c\nCODE:\n```\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Import section */\n                    0x02, 0x13, 0x01,\n                    /* module name: \"extern\" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: \"func-add\" */\n                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x0A, 0x01,\n                    /* export name: \"addTwo\" */\n                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x0A, 0x01,\n                    /* code body */\n                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* The external data object: an integer. */\n  int32_t Data;\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                   WasmEdge_ValTypeGenI32()};\n  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from memory. */\n  WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));\n  /*\n   * Note: `WasmEdge_VMRunWasmFromBuffer()` will be deprecated in the future.\n   * We recommand developers to use `WasmEdge_VMRunWasmFromBytes()` instead.\n   */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName,\n                                                    Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  printf(\"Data value: %d\\n\", Data);\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Instantiation and Execution\nDESCRIPTION: Detailed Go implementation showing step-by-step WASM module loading, validation, instantiation, and execution using WasmEdge VM. Calculates the 25th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Function-based Go Program with WasmEdge\nDESCRIPTION: Commands to compile a Go function to WebAssembly using TinyGo and running it in WasmEdge's reactor mode, which allows calling specific functions with parameters from the command line.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/go/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntinygo build -o fib.wasm -target wasi main.go\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --reactor fib.wasm fibArray 10\n34\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions\nDESCRIPTION: Example showing how to list exported functions from a WASM module including their names and function types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Host Function in Golang for WasmEdge\nDESCRIPTION: A Go implementation showing how to create a VM object, define a host function for adding two integers, register it as an import module, and execute a WebAssembly program that uses this function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_67\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Instantiating and Running WASM Functions in Go with WasmEdge\nDESCRIPTION: Demonstrates a manual setup for running WASM functions in Go using WasmEdge. Steps include loading a WASM file, validating and instantiating the module, and executing asynchronously. The code also includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_46\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript TensorFlow Lite Image Classification Example\nDESCRIPTION: A JavaScript example that uses the WASI-NN API to load a TensorFlow Lite model for food image classification. It reads an image, processes it through the model, and outputs the recognized food item with confidence score.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/tensorflow.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Image } from 'image';\nimport * as fs from 'fs';\nimport { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';\n\nlet img = new Image(__dirname + '/food.jpg');\nlet img_rgb = img.to_rgb().resize(192, 192);\nlet rgb_pix = img_rgb.pixels();\n\nlet data = fs.readFileSync(\n  __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite',\n);\nlet graph = new NnGraph([data.buffer], 'tensorflowlite', 'cpu');\nlet context = new NnContext(graph);\ncontext.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);\ncontext.compute();\n\nlet output_view = new Uint8Array(2024);\ncontext.getOutput(0, output_view.buffer);\n\nlet max = 0;\nlet max_idx = 0;\nfor (var i in output_view) {\n  let v = output_view[i];\n  if (v > max) {\n    max = v;\n    max_idx = i;\n  }\n}\n\nlet label_file = fs.readFileSync(\n  __dirname + '/aiy_food_V1_labelmap.txt',\n  'utf-8',\n);\nlet lables = label_file.split(/\\r?\\n/);\n\nlet label = lables[max_idx];\n\nprint('label:');\nprint(label);\nprint('confidence:');\nprint(max / 255);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Runner in C\nDESCRIPTION: Example code demonstrating how to run a WebAssembly file using the WasmEdge C API. Shows configuration setup, VM creation, function execution, and resource cleanup. Takes a fibonacci.wasm file as input and executes the 'fib' function with parameter 32.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int Argc, const char* Argv[]) {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Compiler CLI Tool in C\nDESCRIPTION: This snippet shows how to use the WasmEdge C API to invoke the WasmEdge compiler CLI tool. It replicates the functionality of the 'wasmedge compile' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_93\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge AOT Compiler in C\nDESCRIPTION: Example code showing how to use the WasmEdge AOT (Ahead-Of-Time) compiler to compile WebAssembly files. Demonstrates compiler context creation, compilation process, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int Argc, const char* Argv[]) {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Instantiating and Running WebAssembly Functions with WasmEdge\nDESCRIPTION: Go code showing how to manually load, validate, instantiate, and execute a WebAssembly module using the WasmEdge Go SDK. It demonstrates a step-by-step approach to running WebAssembly functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  // Developers can load, validate, and instantiate another WASM module\n  // to replace the instantiated one. In this case, the old module will\n  // be cleared, but the registered modules are still kept.\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  // Developers can execute functions repeatedly after instantiation.\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Running WASM Functions Step-by-Step from C\nDESCRIPTION: This C program illustrates how to run the Fibonacci function using step-by-step VM context APIs. It involves loading, validating, and instantiating the WASM module before execution, handling possible errors at each step.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };\n  WasmEdge_Value Returns[1];\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Execute WASM functions. */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: VM Creation with Configure and Store Contexts in C\nDESCRIPTION: C code example showing how to create a WasmEdge VM context with custom configure and store contexts. It demonstrates the proper creation, retrieval of internal contexts, and resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/*\n * The VM context already contains the statistics context and can be retrieved\n * by this API.\n */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by\n * VM APIs should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing an Add Host Function in Go\nDESCRIPTION: Demonstrates how to implement a host function that adds two 32-bit integers. This function follows the required signature and can be used as a host function in WasmEdge-go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function in C\nDESCRIPTION: Demonstrates the implementation of a simple 'add' host function that takes two i32 parameters, adds them, and returns the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_73\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n   * Params: {i32, i32}\n   * Returns: {i32}\n   * Developers should take care about the function type.\n   */\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Rust WebAssembly Functions from Go\nDESCRIPTION: This Go code demonstrates how to load a WebAssembly module, allocate memory for string parameters, call the 'greet' function, and handle the returned string. It showcases memory management and data conversion between Go and WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"strings\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  subject := \"WasmEdge\"\n  lengthOfSubject := len(subject)\n\n  // Allocate memory for the subject, and get a pointer to it.\n  // Include a byte for the NULL terminator we add below.\n  allocateResult, _ := vm.Execute(\"allocate\", int32(lengthOfSubject + 1))\n  inputPointer := allocateResult[0].(int32)\n\n  // Write the subject into the memory.\n  mod := vm.GetActiveModule()\n  mem := mod.FindMemory(\"memory\")\n  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))\n  copy(memData, subject)\n\n  // C-string terminates by NULL.\n  memData[lengthOfSubject] = 0\n\n  // Run the `greet` function. Given the pointer to the subject.\n  greetResult, _ := vm.Execute(\"greet\", inputPointer)\n  outputPointer := greetResult[0].(int32)\n\n  pageSize := mem.GetPageSize()\n  // Read the result of the `greet` function.\n  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))\n  nth := 0\n  var output strings.Builder\n\n  for {\n    if memData[int(outputPointer) + nth] == 0 {\n      break\n    }\n\n    output.WriteByte(memData[int(outputPointer) + nth])\n    nth++\n  }\n\n  lengthOfOutput := nth\n\n  fmt.Println(output.String())\n\n  // Deallocate the subject, and the output.\n  vm.Execute(\"deallocate\", inputPointer, int32(lengthOfSubject+1))\n  vm.Execute(\"deallocate\", outputPointer, int32(lengthOfOutput+1))\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Host Function Integration Example\nDESCRIPTION: Full example showing host function implementation, VM creation, and module integration in C.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n  uint8_t WASM[] = { /* ... WASM binary ... */ };\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\n  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\n  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);\n```\n\n----------------------------------------\n\nTITLE: Executing WASM with WasmEdge in Go\nDESCRIPTION: Demonstrates how to load, validate, instantiate, and execute a WASM module using WasmEdge's Go API. It includes configuration, statistics tracking, and function invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n  var mod *wasmedge.Module\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  // Instantiate the WASM module and get the output module instance.\n  mod, err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := mod.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  // Invoke the WASM function.\n  funcinst := mod.FindFunction(\"fib\")\n  if funcinst == nil {\n    fmt.Println(\"Run FAILED: Function name `fib` not found\")\n    return\n  }\n  res, err = executor.Invoke(funcinst, int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run FAILED:\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n  mod.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Functions from Go using WasmEdge\nDESCRIPTION: This Go code demonstrates how to load a WebAssembly module, instantiate it using WasmEdge, and execute the bindgen functions defined in the Rust code. It shows how to pass parameters and handle return values for various function signatures.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/bindgen.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  // Expected Args[0]: program name (./bindgen_funcs)\n  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))\n\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n  // Instantiate the bindgen and vm\n  bg := bindgen.New(vm)\n  bg.Instantiate()\n\n  // Run bindgen functions\n  var res []interface{}\n  var err error\n  // create_line: array, array, array -> array (inputs are JSON stringified)\n  res, _, err = bg.Execute(\"create_line\", \"{\\\"x\\\":1.5,\\\"y\\\":3.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- create_line FAILED\")\n  }\n  // say: array -> array\n  res, _, err = bg.Execute(\"say\", \"bindgen funcs test\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- say:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- say FAILED\")\n  }\n  // obfusticate: array -> array\n  res, _, err = bg.Execute(\"obfusticate\", \"A quick brown fox jumps over the lazy dog\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- obfusticate:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- obfusticate FAILED\")\n  }\n  // lowest_common_multiple: i32, i32 -> i32\n  res, _, err = bg.Execute(\"lowest_common_multiple\", int32(123), int32(2))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple FAILED\")\n  }\n  // sha3_digest: array -> array\n  res, _, err = bg.Execute(\"sha3_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- sha3_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- sha3_digest FAILED\")\n  }\n  // keccak_digest: array -> array\n  res, _, err = bg.Execute(\"keccak_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- keccak_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- keccak_digest FAILED\")\n  }\n\n  bg.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Manual WASM Instantiation and Execution in C\nDESCRIPTION: This bash snippet demonstrates how to compile the C code that manually instantiates and asynchronously executes a WebAssembly function, and then run the resulting executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 121393\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAssembly Proposals with WasmEdge in Go\nDESCRIPTION: This snippet shows how to configure the WasmEdge environment by adding or removing WebAssembly proposals using the wasmedge.Configure object in Go. It demonstrates enabling and disabling specific proposals, with a function to check existing configurations. The WasmEdge Go SDK is a necessary dependency.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\n// By default, the following proposals have turned on initially:\n// * IMPORT_EXPORT_MUT_GLOBALS\n// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS\n// * SIGN_EXTENSION_OPERATORS\n// * MULTI_VALUE\n// * BULK_MEMORY_OPERATIONS\n// * REFERENCE_TYPES\n// * SIMD\n// For the current WasmEdge version, the following proposals are supported:\n// * TAIL_CALL\n// * MULTI_MEMORIES\n// * THREADS\n// * EXTENDED_CONST\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n// The `is_bulkmem` will be `true`.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Quick WasmEdge Function Execution in Go\nDESCRIPTION: Go implementation demonstrating rapid WebAssembly function execution using WasmEdge VM. Includes VM configuration, WASI support, and function execution with error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_29\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading llama-simple.wasm\nDESCRIPTION: This command downloads the pre-compiled `llama-simple.wasm` file from the LlamaEdge GitHub releases page. This WASM file contains a simplified example application ready to be executed by WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Download the compiled simple inference wasm\ncurl -LO https://github.com/second-state/llamaedge/releases/latest/download/llama-simple.wasm\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Execution in Go\nDESCRIPTION: Go code showing step-by-step manual execution of a WebAssembly module using the WasmEdge VM object. It demonstrates loading, validating, instantiating, and executing a WASM function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  // Developers can load, validate, and instantiate another WASM module\n  // to replace the instantiated one. In this case, the old module will\n  // be cleared, but the registered modules are still kept.\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  // Developers can execute functions repeatedly after instantiation.\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WASM Function Execution with WasmEdge VM API in C\nDESCRIPTION: C code example showing the detailed execution process of a WebAssembly module using WasmEdge VM API. It demonstrates the full lifecycle including loading, validation, instantiation, and function execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * Step 4: Execute WASM functions. You can execute functions repeatedly\n   * after instantiation.\n   */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Calling TinyGo Functions from Go using WasmEdge\nDESCRIPTION: This Go code demonstrates how to use the WasmEdge Go SDK to load and execute a WebAssembly module compiled from TinyGo.  It allocates memory in the WasmEdge VM, calls the `fibArray` and `fibArrayReturnMemory` functions, retrieves the resulting Fibonacci sequences from memory, and then frees the allocated memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"unsafe\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  n := int32(10)\n\n  p, err := vm.Execute(\"malloc\", n)\n  if err != nil {\n    fmt.Println(\"malloc failed:\", err)\n  }\n\n  fib, err := vm.Execute(\"fibArray\", n, p[0])\n  if err != nil {\n    fmt.Println(\"fibArray failed:\", err)\n  } else {\n    fmt.Println(\"fibArray() returned:\", fib[0])\n    fmt.Printf(\"fibArray memory at: %p\\n\", unsafe.Pointer((uintptr)(p[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))\n      if err == nil && fibArray != nil {\n        fmt.Println(\"fibArray:\", fibArray)\n      }\n    }\n  }\n\n  fibP, err := vm.Execute(\"fibArrayReturnMemory\", n)\n  if err != nil {\n    fmt.Println(\"fibArrayReturnMemory failed:\", err)\n  } else {\n    fmt.Printf(\"fibArrayReturnMemory memory at: %p\\n\", unsafe.Pointer((uintptr)(fibP[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))\n      if err == nil && fibArrayReturnMemory != nil {\n        fmt.Println(\"fibArrayReturnMemory:\", fibArrayReturnMemory)\n      }\n    }\n  }\n\n  _, err = vm.Execute(\"free\", p...)\n  if err != nil {\n    fmt.Println(\"free failed:\", err)\n  }\n\n  exitcode := wasi.WasiGetExitCode()\n  if exitcode != 0 {\n    fmt.Println(\"Go: Running wasm failed, exit code:\", exitcode)\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Status\nDESCRIPTION: Command to verify that the Kubernetes cluster is running properly by querying cluster information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo cluster/kubectl.sh cluster-info\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function in C\nDESCRIPTION: Example implementation of an 'add' host function that adds two i32 values. This function demonstrates how to retrieve input parameters and set return values using the WasmEdge API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_75\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n   * Params: {i32, i32}\n   * Returns: {i32}\n   * Developers should take care about the function type.\n   */\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Module Instances in WasmEdge\nDESCRIPTION: Demonstrates how to list exported functions from a module instance and find specific exported functions by name. Module instances are created by instantiating WASM modules and developers are responsible for managing their lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Instantiate a WASM module via the executor context and get the `ModCxt`\n * as the output module instance.\n */\n\n/* Try to list the exported instance of the instantiated WASM module. */\n/* Take the function instances for example here. */\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data\n * will be discarded.\n */\nuint32_t RealFuncNum =\n    WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\n/* Try to find the exported instance of the instantiated WASM module. */\n/* Take the function instances for example here. */\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt =\n    WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n/* `FuncCxt` will be `NULL` if the function not found. */\n/*\n * The returned instance is owned by the module instance context and should\n * __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C\nDESCRIPTION: Defines the function signature for host functions in WasmEdge. Host functions should follow this signature to be compatible with the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions Step-by-Step with WasmEdge VM in Go\nDESCRIPTION: Detailed example of using the WasmEdge VM object to load, validate, instantiate, and execute a WASM module step-by-step. This demonstrates finer control over the WebAssembly execution process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_31\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  // Developers can load, validate, and instantiate another WASM module\n  // to replace the instantiated one. In this case, the old module will\n  // be cleared, but the registered modules are still kept.\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  // Developers can execute functions repeatedly after instantiation.\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Axum HTTP Server Implementation\nDESCRIPTION: Main implementation of an HTTP server using axum framework with route handlers for / and /echo endpoints\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() {\n    // build our application with a route\n    let app = Router::new()\n        .route(\"/\", get(help))\n        .route(\"/echo\", post(echo));\n\n    // run it\n    let addr = \"0.0.0.0:8080\";\n    let tcp_listener = TcpListener::bind(addr).await.unwrap();\n    println!(\"listening on {}\", addr);\n    axum::Server::from_tcp(tcp_listener.into_std().unwrap())\n        .unwrap()\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WebAssembly Execution Using WasmEdge VM API in C\nDESCRIPTION: C code showing a detailed process of loading, validating, instantiating, and executing a WebAssembly module using the WasmEdge VM API. It demonstrates the manual steps involved in running a WASM function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to replace the\n   * instantiated one. In this case, the old module will be cleared, but the registered\n   * modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Function Step-by-Step in C\nDESCRIPTION: Complete example showing how to load, validate, instantiate and execute a WASM function using WasmEdge C API. The code demonstrates working with various WasmEdge contexts and executing a Fibonacci calculation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /* Create the store context. The store context is the WASM runtime structure core. */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /* Create the executor context. The configure context and the statistics context can be NULL. */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */\n  uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM with WasmEdge Go SDK\nDESCRIPTION: This code demonstrates how to use the WasmEdge Go SDK to load, validate, instantiate, and execute a WASM module. It includes setting up the configuration, statistics, and store objects, as well as using the loader, validator, and executor.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n  var mod *wasmedge.Module\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  // Instantiate the WASM module and get the output module instance.\n  mod, err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := mod.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  // Invoke the WASM function.\n  funcinst := mod.FindFunction(\"fib\")\n  if funcinst == nil {\n    fmt.Println(\"Run FAILED: Function name `fib` not found\")\n    return\n  }\n  res, err = executor.Invoke(store, funcinst, int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run FAILED:\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n  mod.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Return Values in WasmEdge (C)\nDESCRIPTION: This snippet shows how to retrieve the return values from an asynchronous execution using `WasmEdge_AsyncGet()`.  This function blocks until the execution completes. It fills the provided buffer (`Buf`) with the return values. The size of the buffer (`BUF_LEN`) must be sufficient to hold all return values. The `WasmEdge_Async` object is then deleted using `WasmEdge_AsyncDelete()` to free resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM Context\nDESCRIPTION: This example demonstrates how to register host modules into a WasmEdge VM context. It creates a WASI module instance and registers it with the VM. The code also emphasizes the importance of proper memory management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\n```\n\n----------------------------------------\n\nTITLE: Creating TensorFlow-Lite Session in WasmEdge\nDESCRIPTION: This Rust snippet outlines the creation of a TFLiteSession using a model buffer, which is essential for running TensorFlow-Lite models in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// The mod_buf is a vec<u8> which contains the model data.\nlet mut session = wasmedge_tensorflow_interface::TFLiteSession::new(&mod_buf);\n```\n\n----------------------------------------\n\nTITLE: Get Function Type from WasmEdge VM in Go\nDESCRIPTION: This code snippet retrieves the function type of a function named \"fib\" from a WasmEdge VM instance. It assumes a WASM module is already instantiated in the VM. It illustrates how to use the `GetFunctionType` API. The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nfunctype := vm.GetFunctionType(\"fib\")\n// Developers can get the function types of functions in the registered modules via the\n// `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.\n// If the function is not found, these APIs will return `nil`.\n// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Quick WASM Function Execution in Go\nDESCRIPTION: Go implementation showing how to quickly execute a WASM function using WasmEdge VM with minimal setup. Demonstrates calculating the 21st Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules with WasmEdge C API\nDESCRIPTION: This comprehensive example demonstrates registering a WASM module, executing a function from the registered module, and handling the results. It includes error checking and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n   * name \"mod\". As the same as host functions, other modules can import the\n   * function `\"mod\" \"fib\"`.\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                     Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Asynchronous WASM Function Execution\nDESCRIPTION: Detailed example showing step-by-step WASM function execution including loading, validation, instantiation, and asynchronous execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Imports and Exports from AST Module in C\nDESCRIPTION: This snippet demonstrates how to query the imports and exports of an AST Module context. It shows how to retrieve the list of import and export types, and iterate through them for further processing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/*\n * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be\n * accessed.\n */\n```\n\n----------------------------------------\n\nTITLE: Complete WASM Module Execution Example in C\nDESCRIPTION: Comprehensive example showing the complete workflow of loading, validating, instantiating and executing a WASM module using WasmEdge C API. Demonstrates context creation, function lookup, parameter passing, and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_Result Res;\n\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* ... rest of the code ... */\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function and VM Creation in C\nDESCRIPTION: Provides a complete example of implementing a host function, creating a VM context, and setting up a module for execution in WasmEdge. This demonstrates the full process of integrating host functions with WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function in Go\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_69\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Fibonacci WASM Module with WasmEdge C API\nDESCRIPTION: Comprehensive example showing how to load, validate, instantiate and execute a WASM module containing a Fibonacci function. Demonstrates proper context management and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_Result Res;\n\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Rest of the code... */\n```\n\n----------------------------------------\n\nTITLE: Complete WasmEdge Example with Host Function\nDESCRIPTION: This complete example demonstrates creating a VM, registering a host function in a module instance, and executing a WASM function. The host function adds two integers, and the WASM module calls this host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                       const WasmEdge_CallingFrameContext *CallFrameCxt,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Import section */\n                    0x02, 0x13, 0x01,\n                    /* module name: \"extern\" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: \"func-add\" */\n                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x0A, 0x01,\n                    /* export name: \"addTwo\" */\n                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x0A, 0x01,\n                    /* code body */\n                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete WasmEdge Host Function Integration Example\nDESCRIPTION: A complete example of using WasmEdge C API to create a host function, register it with a module instance, and execute a WebAssembly function that calls the host function. It demonstrates the full lifecycle from VM creation to execution and cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                     const WasmEdge_CallingFrameContext *CallFrameCxt,\n                     const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                     0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                     /* Type section */\n                     0x01, 0x07, 0x01,\n                     /* function type {i32, i32} -> {i32} */\n                     0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                     /* Import section */\n                     0x02, 0x13, 0x01,\n                     /* module name: \"extern\" */\n                     0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                     /* extern name: \"func-add\" */\n                     0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                     /* import desc: func 0 */\n                     0x00, 0x00,\n                     /* Function section */\n                     0x03, 0x02, 0x01, 0x00,\n                     /* Export section */\n                     0x07, 0x0A, 0x01,\n                     /* export name: \"addTwo\" */\n                     0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                     /* export desc: func 0 */\n                     0x00, 0x01,\n                     /* Code section */\n                     0x0A, 0x0A, 0x01,\n                     /* code body */\n                     0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Rapid WASM Function Execution in Go\nDESCRIPTION: Go code demonstrating how to quickly execute a WebAssembly function using the WasmEdge Go SDK. It sets up a VM, runs the Fibonacci function from a WASM file, and prints the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module as Named Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate and register an AST module as a named Module instance using the Executor context. Includes creation of statistics, executor, and store contexts, followed by module registration with error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step Execution of WebAssembly Function with WasmEdge VM in C\nDESCRIPTION: This C code shows how to execute a WebAssembly function step-by-step using the WasmEdge VM context. It demonstrates loading, validating, instantiating, and executing a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to replace the\n   * instantiated one. In this case, the old module will be cleared, but the registered\n   * modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading LLaMA Model and Creating Execution Context in Rust\nDESCRIPTION: This snippet demonstrates loading a LLaMA model using the wasi-nn API and creating an execution context. It uses the GraphBuilder to load the model and initialize the execution context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// load the model to wasi-nn\n     let graph =\n        wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, wasi_nn::ExecutionTarget::AUTO)\n            .build_from_cache(&model_name)\n            .expect(\"Failed to load the model\");\n\n // initialize the execution context\n    let mut context = graph\n        .init_execution_context()\n        .expect(\"Failed to init context\");\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge AOT Compiler CLI in Go\nDESCRIPTION: Example of triggering the WasmEdge AOT Compiler CLI tool programmatically through the Go SDK. Uses the RunWasmEdgeAOTCompilerCLI function to pass command line arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_29\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader Context\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge Loader context to load WebAssembly modules from files or buffers. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Running WASM Function from C - Rapid Execution\nDESCRIPTION: This C program demonstrates how to run the Fibonacci function defined in the WASM file from an external file. It sets up the VM context, prepares parameters and invokes the 'fib' function, then retrieves and prints the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support and Retrieving Module Instances in C\nDESCRIPTION: This snippet demonstrates how to configure WASI support for a WasmEdge VM, create the VM context, and retrieve built-in registered module instances. It also shows how to initialize the WASI module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the built-in registered module instances\n * from the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding configuration is not set\n * when creating the VM context.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                      WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Module with WasmEdge C++ SDK in AOT Mode\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C++ SDK in AOT (Ahead-of-Time) compilation mode. It creates a VM context in AOT mode, loads a WebAssembly module from a file, and executes a function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c++/intro.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\nint main(int argc, const char* argv[]) {\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  wasmedge_configure_context* conf_cxt = wasmedge_configure_create();\n  wasmedge_configure_add_host_registration(conf_cxt, WASMEDGE_HOST_REGISTRATION_WASI);\n\n  // Create the VM context in AOT mode.\n  wasmedge_vm_context* vm_cxt = wasmedge_vm_create_aot(conf_cxt, NULL);\n\n  // The parameters and returns arrays.\n  wasmedge_value params[1] = { wasmedge_value_gen_i32(32) };\n  wasmedge_value returns[1];\n  // Function name.\n  wasmedge_string func_name = wasmedge_string_create_by_cstring(\"fib\");\n  // Run the WASM function from file.\n  wasmedge_result res = wasmedge_vm_run_wasm_from_file(vm_cxt, argv[1], func_name, params, 1, returns, 1);\n\n  if (wasmedge_result_ok(res)) {\n    printf(\"Get result: %d\\n\", wasmedge_value_get_i32(returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", wasmedge_result_get_message(res));\n  }\n\n  // Resources deallocations.\n  wasmedge_vm_delete(vm_cxt);\n  wasmedge_configure_delete(conf_cxt);\n  wasmedge_string_delete(func_name);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering a Host Module with WasmEdge C API\nDESCRIPTION: Creates a host module with a custom function implementation that adds two integers. This module will be registered with the WasmEdge VM for WebAssembly modules to import and use.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_75\n\nLANGUAGE: c\nCODE:\n```\n/* The external data object: an integer. */\nint32_t Data;\n\n/* Create the module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\nWasmEdge_StringDelete(HostFuncName);\n\nWasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WebAssembly Execution with WasmEdge VM\nDESCRIPTION: C code demonstrating manual WebAssembly execution by explicitly performing each step: loading, validating, instantiating, and executing. This approach provides more control over the execution process and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * Step 4: Execute WASM functions. You can execute functions repeatedly\n   * after instantiation.\n   */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering WasmEdge Host Module with External Function\nDESCRIPTION: Creates a module instance with the name 'extern', defines a host function with two i32 parameters and one i32 return value, and registers this function as 'func-add' in the module. This function will be called from the WebAssembly code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_79\n\nLANGUAGE: c\nCODE:\n```\n/* The external data object: an integer. */\nint32_t Data;\n\n/* Create the module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\nWasmEdge_StringDelete(HostFuncName);\n\nWasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Compiler CLI Tool API in C\nDESCRIPTION: Example of using WasmEdge_Driver_Compiler() API to run the WasmEdge AOT compiler programmatically, which is equivalent to the 'wasmedge compile' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_92\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete WasmEdge Host Function Implementation Example\nDESCRIPTION: This complete example demonstrates creating a host function in C, registering it with a WasmEdge module, and executing a WebAssembly function that calls this host function. It shows the full workflow including VM creation, function registration, and parameter passing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_81\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                      0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                      /* Type section */\n                      0x01, 0x07, 0x01,\n                      /* function type {i32, i32} -> {i32} */\n                      0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                      /* Import section */\n                      0x02, 0x13, 0x01,\n                      /* module name: \"extern\" */\n                      0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                      /* extern name: \"func-add\" */\n                      0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                      /* import desc: func 0 */\n                      0x00, 0x00,\n                      /* Function section */\n                      0x03, 0x02, 0x01, 0x00,\n                      /* Export section */\n                      0x07, 0x0A, 0x01,\n                      /* export name: \"addTwo\" */\n                      0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                      /* export desc: func 0 */\n                      0x00, 0x01,\n                      /* Code section */\n                      0x0A, 0x0A, 0x01,\n                      /* code body */\n                      0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                   WasmEdge_ValTypeGenI32()};\n  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                               WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from memory. */\n  WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));\n  /*\n   * Note: `WasmEdge_VMRunWasmFromBuffer()` will be deprecated in the future.\n   * We recommand developers to use `WasmEdge_VMRunWasmFromBytes()` instead.\n   */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName,\n                                                    Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Go Host Application for WebAssembly Execution\nDESCRIPTION: This Go code demonstrates how to load and execute WebAssembly functions using the WasmEdge runtime. It initializes the VM, loads the WASM file, and calls various bindgen functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/function.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  // Expected Args[0]: program name (./bindgen_funcs)\n  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))\n\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n  // Instantiate the bindgen and vm\n  bg := bindgen.New(vm)\n  bg.Instantiate()\n\n  // Run bindgen functions\n  var res []interface{}\n  var err error\n  // create_line: array, array, array -> array (inputs are JSON stringified)\n  res, _, err = bg.Execute(\"create_line\", \"{\\\"x\\\":1.5,\\\"y\\\":3.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- create_line FAILED\")\n  }\n  // say: array -> array\n  res, _, err = bg.Execute(\"say\", \"bindgen funcs test\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- say:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- say FAILED\")\n  }\n  // obfusticate: array -> array\n  res, _, err = bg.Execute(\"obfusticate\", \"A quick brown fox jumps over the lazy dog\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- obfusticate:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- obfusticate FAILED\")\n  }\n  // lowest_common_multiple: i32, i32 -> i32\n  res, _, err = bg.Execute(\"lowest_common_multiple\", int32(123), int32(2))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple FAILED\")\n  }\n  // sha3_digest: array -> array\n  res, _, err = bg.Execute(\"sha3_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- sha3_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- sha3_digest FAILED\")\n  }\n  // keccak_digest: array -> array\n  res, _, err = bg.Execute(\"keccak_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- keccak_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- keccak_digest FAILED\")\n  }\n\n  bg.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: This comprehensive example shows how to register a WASM module, execute a function from the registered module, and handle the results. It includes error checking and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBytes()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n   * name \"mod\". As the same as host functions, other modules can import the\n   * function `\"mod\" \"fib\"`.\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                     Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Host Data with WasmEdge Host Functions in Go\nDESCRIPTION: Example demonstrating how to share data between Go and WebAssembly functions by passing an external data object to a host function. The host function can read and modify this data during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_71\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Also set the result to the data.\n  *data.(*int32) = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // The additional data to set into the host function.\n  var data int32 = 0\n\n  // Create the module instance with the module name \"extern\".\n  modinst := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\n  functype.Release()\n  modinst.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(modinst)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  fmt.Println(\"Data value:\", data)\n\n  modinst.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Module Instance with Host Functions in C\nDESCRIPTION: Demonstrates how to create a module instance and add host functions, memory, table, and global instances to it for use in WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_77\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge AOT Compiler in Bash\nDESCRIPTION: This snippet shows the command to compile the AOT compiler example and the expected output when running it. The output displays the compilation process stages including verification, optimization, and code generation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_73\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n```\n\n----------------------------------------\n\nTITLE: Executing WASM with WasmEdge in Go\nDESCRIPTION: Demonstrates the step-by-step process of loading, validating, instantiating, and executing a WASM module using WasmEdge in Go. It includes configuration setup, statistics tracking, and function invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n  var mod *wasmedge.Module\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  // Instantiate the WASM module and get the output module instance.\n  mod, err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := mod.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  // Invoke the WASM function.\n  funcinst := mod.FindFunction(\"fib\")\n  if funcinst == nil {\n    fmt.Println(\"Run FAILED: Function name `fib` not found\")\n    return\n  }\n  res, err = executor.Invoke(funcinst, int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run FAILED:\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n  mod.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions in WasmEdge\nDESCRIPTION: Complete example demonstrating how to load a WASM module and list its exported functions, including function name retrieval and type information handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions in WasmEdge Go SDK\nDESCRIPTION: Complete example showing how to implement a host function in Go, create a module with the function, and register it with a WasmEdge VM. It executes a WebAssembly module that calls the host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_70\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Complete WasmEdge C API Example with Host Function\nDESCRIPTION: Complete example demonstrating how to create a host function, register it with a module instance, and execute a WebAssembly function that calls the host function. The example shows the full lifecycle of module creation and execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_76\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                   const WasmEdge_CallingFrameContext *CallFrameCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                   0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                   /* Type section */\n                   0x01, 0x07, 0x01,\n                   /* function type {i32, i32} -> {i32} */\n                   0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                   /* Import section */\n                   0x02, 0x13, 0x01,\n                   /* module name: \"extern\" */\n                   0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                   /* extern name: \"func-add\" */\n                   0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                   /* import desc: func 0 */\n                   0x00, 0x00,\n                   /* Function section */\n                   0x03, 0x02, 0x01, 0x00,\n                   /* Export section */\n                   0x07, 0x0A, 0x01,\n                   /* export name: \"addTwo\" */\n                   0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                   /* export desc: func 0 */\n                   0x00, 0x01,\n                   /* Code section */\n                   0x0A, 0x0A, 0x01,\n                   /* code body */\n                   0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                             WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Complete example showing how to register a WASM module, execute a function from the registered module with parameters, and handle the returned results. This demonstrates a full workflow using the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n  */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n  * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module name \"mod\".\n  * As the same as host functions, other modules can import the function `\"mod\" \"fib\"`.\n  */\n\n  /*\n  * Execute WASM functions in registered modules.\n  * Unlike the execution of functions, the registered functions can be invoked without\n  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.\n  * Developers can also invoke the host functions directly with this API.\n  */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WASM Function Execution in Go\nDESCRIPTION: Detailed example showing manual WebAssembly execution process including loading, validation, instantiation, and execution steps using the WasmEdge VM object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  res, err = vm.Execute(\"fib\", uint32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Asynchronous WASM Function Execution in C\nDESCRIPTION: Demonstrates how to asynchronously execute a WebAssembly function using WasmEdge_VMAsyncRunWasmFromFile. The example loads and runs a Fibonacci calculation function from a WASM file, handling VM context creation, parameter passing, and result retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Rapid Execution of WASM Function with WasmEdge VM API in C\nDESCRIPTION: C code example demonstrating how to quickly execute a WebAssembly function from a file using the WasmEdge VM API. It creates a VM context, executes the Fibonacci function with an input parameter of 5, and processes the return value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRunWasmFromASTModule()` API.\n   */\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Listing and Finding Exported Instances in Module Instance (C)\nDESCRIPTION: Demonstrates how to list exported instances (e.g., functions) from a Module instance and find specific exported instances by name. It also shows proper memory management for strings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum =\n    WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt =\n    WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Using Instruction Counter for Performance Profiling in C\nDESCRIPTION: This snippet demonstrates how to create a statistics context for tracking the number of executed instructions and calculating instructions per second for performance profiling of WebAssembly functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating a JavaScript Object with Properties in Rust\nDESCRIPTION: Rust code that creates a JavaScript object with data properties and a function method, then registers it in the global scope of the JavaScript interpreter.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet mut obj = ctx.new_object();\nobj.set(\"a\", 1.into());\nobj.set(\"b\", ctx.new_string(\"abc\").into());\n\nlet f = ctx.new_function::<ObjectFn>(\"anything\");\nobj.set(\"f\", f.into());\n\nctx.get_global().set(\"test_obj\", obj.into());\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Execution in WasmEdge\nDESCRIPTION: This Go code snippet demonstrates asynchronously running a WASM function from a file using the WasmEdge Go SDK. It creates a VM, asynchronously runs the WASM function, retrieves the results, and handles potential errors. The code utilizes the `AsyncRunWasmFile` method to execute the WASM function and the `GetResult` method to obtain the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Rapidly Run WASM Functions from C\nDESCRIPTION: This C code snippet shows how to rapidly execute a predefined WASM function using the WASM Edge runtime. It includes setting up configuration and VM contexts, preparing parameters, and displaying the return result after execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };\n  WasmEdge_Value Returns[1];\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Fibonacci WebAssembly Implementation\nDESCRIPTION: WebAssembly module that implements a recursive Fibonacci number calculator function. Exports a 'fib' function that takes an i32 parameter and returns an i32 result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_27\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Complete Go Program Using WasmEdge with Custom Error Codes\nDESCRIPTION: A full Go program demonstrating how to create a VM, register a host function with custom error handling, and execute a WebAssembly module. It shows the use of user-defined error codes in host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x05, 0x01,\n    /* function type {i32} -> {} */\n    0x60, 0x01, 0x7F, 0x00,\n    /* Import section */\n    0x02, 0x0F, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x08, 0x01,\n    /* export name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x08, 0x01,\n    /* code body */\n    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})\n  hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"trap\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  _, err := vm.RunWasmBuffer(wasmbuf, \"trap\", uint32(5566))\n  if err != nil {\n    fmt.Println(\"Get the error code:\", err.GetCode())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function with WasmEdge C API\nDESCRIPTION: Demonstrates creating a host function that adds two integers, registering it with WasmEdge VM, and executing a WebAssembly module that calls this function\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/library.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting and Processing LLaMA Inference Output in Rust\nDESCRIPTION: This snippet demonstrates how to extract the output from the LLaMA model inference, handle potential UTF-8 encoding issues, and prepare the result for display. It uses a buffer to retrieve the output and converts it to a string.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n  let mut output_buffer = vec![0u8; *CTX_SIZE.get().unwrap()];\n    let mut output_size = context\n        .get_output(0, &mut output_buffer)\n        .expect(\"Failed to get output tensor\");\n    output_size = std::cmp::min(*CTX_SIZE.get().unwrap(), output_size);\n    let output = String::from_utf8_lossy(&output_buffer[..output_size]).to_string();\n\nprintln!(\"\\nprompt: {}\", &prompt);\nprintln!(\"\\noutput: {}\", output);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Cost Table Management in C\nDESCRIPTION: Shows how to set up and manage a cost table for WebAssembly instruction execution tracking. Includes setting instruction costs, establishing cost limits, and retrieving total execution costs. The example demonstrates cost allocation for specific bytecode instructions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/*\n * Developers can set the costs of each instruction. The value not\n * covered will be 0.\n */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go for WasmEdge\nDESCRIPTION: The function signature definition for implementing host functions in WasmEdge using Go. Host functions receive data, calling frame, and parameters, and return results along with an execution status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: Instantiating WASM Modules with Executor in Go\nDESCRIPTION: Shows how to instantiate a WASM module using the Executor. It covers creating necessary objects like Statistics, Executor, and Store, then instantiating the WASM module from an AST object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Instantiate the WASM module.\nerr := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plug-ins\nDESCRIPTION: Shows how to load WasmEdge plug-ins from default paths and create a VM with WASI configuration. Demonstrates checking for registered modules including built-in WASI and plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\n// Load the plug-ins in the default paths first.\nwasmedge.LoadPluginDefaultPaths()\n\n// Create the VM object with the WASI configuration.\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.\n// This API will return `NULL` if the module instance not found.\n\n// The `wasimodule` will not be `nil` because the configuration was set.\nwasimodule := vm.GetRegisteredModule(\"wasi_snapshot_preview1\")\n\n// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.\nwasinnmodule := vm.GetRegisteredModule(\"wasi_ephemeral_nn\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in C\nDESCRIPTION: Shows how to register an existing Module instance with exported module name into the store context. Includes creation of host module instance and registration process with error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Module Instance List and Find Example (C)\nDESCRIPTION: Shows how to list exported instances and find specific instances from a WASM module after instantiation. Demonstrates working with function instances, including listing function names and finding functions by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step Asynchronous WebAssembly Execution in C\nDESCRIPTION: Shows manual instantiation and asynchronous execution of WebAssembly functions using WasmEdge C API. Includes steps for loading, validation, instantiation, and execution with error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using External References in WASM - WebAssembly\nDESCRIPTION: This snippet defines a WebAssembly module that passes externref to host functions, allowing access to external references within WASM. It demonstrates creating a function type that includes an externref and provides an example of a WASM function that calls a host function using externref.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_3\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param externref i32 i32) (result i32)))\n  (import \"extern_module\" \"func_mul\" (func $func_mul (type $t0)))\n  (func $call_mul (export \"call_mul\") (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)\n    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))\n  )\n  (memory $memory (export \"memory\") 1))\n```\n\n----------------------------------------\n\nTITLE: Validating WASM with WasmEdge Validator\nDESCRIPTION: This Go snippet shows how to validate a WASM module using the WasmEdge `Validator` object.  It involves creating a validator with a configuration object and validating an Abstract Syntax Tree (AST) representation of the WASM module. Error handling is included to manage potential validation failures. The validator object should be released after validation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\n\"// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\\\"Validation FAILED:\\\", err.Error())\n}\n\nvalidator.Release()\"\n```\n\n----------------------------------------\n\nTITLE: Calling TinyGo WebAssembly Functions from Go\nDESCRIPTION: This Go code demonstrates how to load a WebAssembly module compiled from TinyGo, allocate memory for string parameters, call the 'greet' function, and handle the returned string. It showcases memory management and data conversion between Go and WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"encoding/binary\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  subject := \"WasmEdge\"\n  lengthOfSubject := len(subject)\n\n  // Allocate memory for the subject, and get a pointer to it.\n  // Include a byte for the NULL terminator we add below.\n  allocateResult, _ := vm.Execute(\"malloc\", int32(lengthOfSubject+1))\n  inputPointer := allocateResult[0].(int32)\n\n  // Write the subject into the memory.\n  mod := vm.GetActiveModule()\n  mem := mod.FindMemory(\"memory\")\n  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))\n  copy(memData, subject)\n\n  // C-string terminates by NULL.\n  memData[lengthOfSubject] = 0\n\n  // Run the `greet` function. Given the pointer to the subject.\n  greetResult, _ := vm.Execute(\"greet\", inputPointer)\n  outputPointer := greetResult[0].(int32)\n\n  memData, _ = mem.GetData(uint(outputPointer), 8)\n  resultPointer := binary.LittleEndian.Uint32(memData[:4])\n  resultLength := binary.LittleEndian.Uint32(memData[4:])\n\n  // Read the result of the `greet` function.\n  memData, _ = mem.GetData(uint(resultPointer), uint(resultLength))\n  fmt.Println(string(memData))\n\n  // Deallocate the subject, and the output.\n  vm.Execute(\"free\", inputPointer)\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Execution with WasmEdge in Go\nDESCRIPTION: This code demonstrates step-by-step execution of a WASM function using WasmEdge's VM context APIs. It loads, validates, and instantiates a WASM module, then asynchronously executes the 'fib' function. The code depends on the WasmEdge Go SDK. Error handling is included for each step.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,\n  // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application\nDESCRIPTION: Commands for building and running a Go application that uses the WasmEdge SDK. This includes installing the WasmEdge Go module, building the application, and executing it to demonstrate the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_59\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Host Function Implementation with Data Access\nDESCRIPTION: Example of implementing a host function in C that can access external data passed to the function context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM\nDESCRIPTION: Demonstrates how to enable WASI support in a WasmEdge VM configuration and retrieve the WASI module instance. It shows configuration creation, adding WASI registration, creating a VM, and initializing WASI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ModuleInstanceContext *WasiModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions with WasmEdge C API\nDESCRIPTION: Demonstrates the step-by-step process of loading, validating, instantiating, and executing a WASM module using WasmEdge C API. It includes creating necessary contexts, handling errors, and cleaning up resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /*\n   * Create the configure context. This step is not necessary because we didn't\n   * adjust any setting.\n   */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /*\n   * Create the statistics context. This step is not necessary if the statistics\n   * in runtime is not needed.\n   */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /*\n   * Create the store context. The store context is the object to link the\n   * modules for imports and exports.\n   */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /*\n   * Create the executor context. The configure context and the statistics\n   * context can be NULL.\n   */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /*\n   * Load the WASM file or the compiled-WASM file and convert into the AST\n   * module context.\n   */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /*\n   * If the list length is larger than the buffer length, the overflowed data\n   * will be discarded.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function `fib` not found.\\n\");\n    return 1;\n  }\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Instantiation and Execution\nDESCRIPTION: Shows step-by-step process of loading, validating, instantiating and executing a WASM module asynchronously using WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Using YAML to Deploy WebAssembly-based HTTP Service in Kubernetes\nDESCRIPTION: This YAML snippet defines a Pod configuration for an HTTP service built using WebAssembly. It sets up a container with networking support and specifies the command to run the WebAssembly image. Dependencies include Kubernetes and a valid image in Docker Hub.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: http-server\n  namespace: default\n  annotations:\n    module.wasm.image/variant: compat-smart\nspec:\n  hostNetwork: true\n  containers:\n    - name: http-server\n      image: wasmedge/example-wasi-http:latest\n      command: ['/http_server.wasm']\n      ports:\n        - containerPort: 1234\n          protocol: TCP\n      livenessProbe:\n        tcpSocket:\n          port: 1234\n        initialDelaySeconds: 3\n        periodSeconds: 30\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Host Function with Error Handling\nDESCRIPTION: Full Go example demonstrating host function implementation, WebAssembly module loading, and error handling with custom error codes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_65\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x05, 0x01,\n    /* function type {i32} -> {} */\n    0x60, 0x01, 0x7F, 0x00,\n    /* Import section */\n    0x02, 0x0F, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x08, 0x01,\n    /* export name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x08, 0x01,\n    /* code body */\n    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})\n  hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"trap\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  _, err := vm.RunWasmBuffer(wasmbuf, \"trap\", uint32(5566))\n  if err != nil {\n    fmt.Println(\"Get the error code:\", err.GetCode())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Store Management in Go\nDESCRIPTION: These code snippets demonstrate how to work with the Store object in WasmEdge. The first snippet creates a VM and retrieves the owned Store. The second snippet creates a Store object explicitly and passes it to the VM. The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nstore := vm.GetStore()\n// The object should __NOT__ be deleted by calling `(*Store).Release`.\nvm.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvm := wasmedge.NewVMWithStore(store)\n\nstoremock := vm.GetStore()\n// The internal store context of the `store` and the `storemock` are the same.\n\nvm.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Modules with WasmEdge Loader\nDESCRIPTION: Example showing how to use the Loader context to load WASM modules from files and buffers. Includes proper resource management and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\nuint32_t FileSize = ...;\n\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ASTModuleDelete(ASTCxt);\n/* Rest of the code... */\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Module with Host Function in Go\nDESCRIPTION: This example demonstrates how to create a VM, register a host function, and execute a WebAssembly module that calls the host function. It uses a simple add function implemented as a host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_78\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASI Module in WasmEdge Go\nDESCRIPTION: Demonstrates how to create and initialize a WASI module instance in WasmEdge Go. It shows setting up WASI with arguments, environment variables, and preopens, registering it with a VM, and retrieving the exit code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_65\n\nLANGUAGE: go\nCODE:\n```\nwasiobj := wasmedge.NewWasiModule(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:\"}, // The mapping preopens\n)\n\n// Register the WASI into the VM object.\nvm := wasmedge.NewVM()\nvm.RegisterImport(wasiobj)\n\n// ... Execute some WASM functions.\n\n// Get the WASI exit code.\nexitcode := wasiobj.WasiGetExitCode()\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous HTTP PUT Request with JSON in JavaScript\nDESCRIPTION: JavaScript code demonstrating an asynchronous HTTP PUT request with JSON data. This example shows how to set content headers and send JSON-formatted data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nasync function test_fetch_put() {\n  try {\n    let r = await fetch('http://httpbin.org/put', {\n      method: 'put',\n      body: JSON.stringify({ a: 1 }),\n      headers: { 'Context-type': 'application/json' },\n    });\n    print('test_fetch_put\\n', await r.text());\n  } catch (e) {\n    print(e);\n  }\n}\ntest_fetch_put();\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in C\nDESCRIPTION: Shows how to query the imports and exports of an AST Module context. This includes creating buffers for import and export types, listing the imports and exports, and iterating through the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/*\n * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be\n * accessed.\n */\n```\n\n----------------------------------------\n\nTITLE: Retrieving WASI Exit Code in WasmEdge Go SDK\nDESCRIPTION: Code snippet showing how to register WASI import module into a VM, execute WASM functions and retrieve the WASI exit code. This is useful for handling WebAssembly programs that use WASI for system interface operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_66\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nvm.RegisterImport(wasiobj)\n\n// ... Execute some WASM functions.\n\n// Get the WASI exit code.\nexitcode := wasiobj.WasiGetExitCode()\n// The `exitcode` will be 0 if the WASI function \"_start\" execution has no error.\n// Otherwise, it will return with the related exit code.\n\nvm.Release()\n// The import objects should be deleted.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Constructing Module Instance with Host Instances in Go for WasmEdge\nDESCRIPTION: Shows how to create a Module instance and add Function, Table, Memory, and Global instances to it. This allows for the creation of custom modules with host-defined components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_76\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the module instance with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nmod.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the module instance with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nmod.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the module instance with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nmod.AddGlobal(\"global\", hostglob)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Using the WasmEdge AOT Compiler from C API\nDESCRIPTION: Demonstrates how to use the WasmEdge Ahead-of-Time (AOT) compiler from C code. The example compiles a WebAssembly file to an optimized binary format for faster execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_83\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\",\n                               \"fibonacci-aot.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React 18 SSR Server with Streaming\nDESCRIPTION: Sets up a non-blocking HTTP server that implements React 18 streaming SSR functionality. It includes data provider setup, static asset handling, and stream pipe implementation for HTML rendering.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { createServer } from 'http';\nimport * as std from 'std';\n\nimport App from './component/App.js';\nimport { DataProvider } from './component/data.js';\n\nlet assets = {\n  'main.js': '/main.js',\n  'main.css': '/main.css',\n};\n\nconst css = std.loadFile('./public/main.css');\n\nfunction createServerData() {\n  let done = false;\n  let promise = null;\n  return {\n    read() {\n      if (done) {\n        return;\n      }\n      if (promise) {\n        throw promise;\n      }\n      promise = new Promise((resolve) => {\n        setTimeout(() => {\n          done = true;\n          promise = null;\n          resolve();\n        }, 2000);\n      });\n      throw promise;\n    },\n  };\n}\n\ncreateServer((req, res) => {\n  print(req.url);\n  if (req.url == '/main.css') {\n    res.setHeader('Content-Type', 'text/css; charset=utf-8');\n    res.end(css);\n  } else if (req.url == '/favicon.ico') {\n    res.end();\n  } else {\n    res.setHeader('Content-type', 'text/html');\n\n    res.on('error', (e) => {\n      print('res error', e);\n    });\n    let data = createServerData();\n    print('createServerData');\n\n    const stream = renderToPipeableStream(\n      <DataProvider data={data}>\n        <App assets={assets} />\n      </DataProvider>,\n      {\n        onShellReady: () => {\n          stream.pipe(res);\n        },\n        onShellError: (e) => {\n          print('onShellError:', e);\n        },\n      },\n    );\n  }\n}).listen(8002, () => {\n  print('listen 8002...');\n});\n```\n\n----------------------------------------\n\nTITLE: AI Inference Function in Rust\nDESCRIPTION: Rust code for a serverless function that performs image classification using TensorFlow. It reads image data, resizes it, runs AI inference, and outputs the classification result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn main() {\n  // Step 1: Load the TFLite model\n  let model_data: &[u8] = include_bytes!(\"models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite\");\n  let labels = include_str!(\"models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt\");\n\n  // Step 2: Read image from STDIN\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  // Step 3: Resize the input image for the tensorflow model\n  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);\n\n  // Step 4: AI inference\n  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);\n  session.add_input(\"input\", &flat_img, &[1, 224, 224, 3])\n         .run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Reshape_1\");\n\n  // Step 5: Find the food label that responds to the highest probability in res_vec\n  // ... ...\n  let mut label_lines = labels.lines();\n  for _i in 0..max_index {\n    label_lines.next();\n  }\n\n  // Step 6: Generate the output text\n  let class_name = label_lines.next().unwrap().to_string();\n  if max_value > 50 {\n    println!(\"It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture\", confidence.to_string(), class_name, class_name);\n  } else {\n    println!(\"It does not appears to be any food item in the picture.\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing and Finding Exported Functions in Module Instance (C)\nDESCRIPTION: Demonstrates how to list exported functions from a module instance and find a specific function by name. It shows proper memory management for string buffers and handling of returned instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum =\n    WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt =\n    WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Compiling and running a WASM application with AoT optimization\nDESCRIPTION: Commands to compile a WASM application using the AoT (Ahead-of-Time) compiler for better performance, and then run the optimized version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedgec hello.wasm hello_aot.wasm\n$ wasmedge hello_aot.wasm\nHello WasmEdge!\n```\n\n----------------------------------------\n\nTITLE: Calling WebAssembly Functions from Go using WasmEdge\nDESCRIPTION: This Go code demonstrates how to load a WebAssembly module, instantiate it using WasmEdge, and call the bindgen functions defined in the Rust code. It handles various data types and prints the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/bindgen.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  // Expected Args[0]: program name (./bindgen_funcs)\n  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))\n\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n  // Instantiate the bindgen and vm\n  bg := bindgen.New(vm)\n  bg.Instantiate()\n\n  // Run bindgen functions\n  var res []interface{}\n  var err error\n  // create_line: array, array, array -> array (inputs are JSON stringified)\n  res, _, err = bg.Execute(\"create_line\", \"{\\\"x\\\":1.5,\\\"y\\\":3.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- create_line FAILED\")\n  }\n  // say: array -> array\n  res, _, err = bg.Execute(\"say\", \"bindgen funcs test\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- say:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- say FAILED\")\n  }\n  // obfusticate: array -> array\n  res, _, err = bg.Execute(\"obfusticate\", \"A quick brown fox jumps over the lazy dog\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- obfusticate:\", res[0].(string))\n  } else {\n    fmt.Println(\"Run bindgen -- obfusticate FAILED\")\n  }\n  // lowest_common_multiple: i32, i32 -> i32\n  res, _, err = bg.Execute(\"lowest_common_multiple\", int32(123), int32(2))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple FAILED\")\n  }\n  // sha3_digest: array -> array\n  res, _, err = bg.Execute(\"sha3_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- sha3_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- sha3_digest FAILED\")\n  }\n  // keccak_digest: array -> array\n  res, _, err = bg.Execute(\"keccak_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- keccak_digest:\", res[0].([]byte))\n  } else {\n    fmt.Println(\"Run bindgen -- keccak_digest FAILED\")\n  }\n\n  bg.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Instantiation and Execution in WasmEdge\nDESCRIPTION: This Go code snippet illustrates how to manually instantiate and asynchronously execute a WASM function using the WasmEdge Go SDK. It involves loading the WASM file, validating it, instantiating the module, asynchronously executing the function, and retrieving the results. The code uses `LoadWasmFile`, `Validate`, `Instantiate`, and `AsyncExecute` methods.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,\n  // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge Global Instances in C\nDESCRIPTION: Demonstrates the complete lifecycle of a WasmEdge global instance, including creation of global types, instantiation, value manipulation, and cleanup. Shows how to set and get values, check types, and handle global instance properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n/* Create the global type with value type and mutation. */\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValTypeGenI64(), WasmEdge_Mutability_Var);\n/* Create the global instance with value and global type. */\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n/* Delete the global type. */\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nconst WasmEdge_GlobalTypeContext *GotGlobTypeCxt =\n    WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n/*\n * The `GotGlobTypeCxt` got from global instance is owned by the `HostGlobal`\n * and should __NOT__ be destroyed.\n */\nWasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GotGlobTypeCxt);\nbool IsTypeF64 = WasmEdge_ValTypeIsI64(ValType);\n/* `ValType` will be `TRUE`. */\nenum WasmEdge_Mutability ValMut =\n    WasmEdge_GlobalTypeGetMutability(GotGlobTypeCxt);\n/* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\nRes = WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n/*\n * Set the value u64(888) to the global.\n * This function will return error if the value type mismatched or\n * the global mutability is `WasmEdge_Mutability_Const`.\n */\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n/* Get the value (888 now) of the global context. */\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Using Host Data with WasmEdge Host Functions\nDESCRIPTION: An extended example showing how to pass external data to host functions in WasmEdge, demonstrating data sharing between the host Go application and the WebAssembly execution environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_69\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Also set the result to the data.\n  *data.(*int32) = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // The additional data to set into the host function.\n  var data int32 = 0\n\n  // Create the module instance with the module name \"extern\".\n  modinst := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\n  functype.Release()\n  modinst.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(modinst)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  fmt.Println(\"Data value:\", data)\n\n  modinst.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Command-Line Arguments for LLaMA Inference in Rust\nDESCRIPTION: This snippet sets up command-line argument parsing for a LLaMA model inference program. It defines arguments for the prompt, model alias, and context size, using the clap crate for argument handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), String> {\n    let matches = Command::new(\"Simple LLM inference\")\n        .arg(\n            Arg::new(\"prompt\")\n                .short('p')\n                .long(\"prompt\")\n                .value_name(\"PROMPT\")\n                .help(\"Sets the prompt.\")\n                .required(true),\n        )\n        .arg(\n            Arg::new(\"model_alias\")\n                .short('m')\n                .long(\"model-alias\")\n                .value_name(\"ALIAS\")\n                .help(\"Sets the model alias\")\n                .default_value(\"default\"),\n        )\n        .arg(\n            Arg::new(\"ctx_size\")\n                .short('c')\n                .long(\"ctx-size\")\n                .value_parser(clap::value_parser!(u32))\n                .value_name(\"CTX_SIZE\")\n                .help(\"Sets the prompt context size\")\n                .default_value(DEFAULT_CTX_SIZE),\n        )\n        .get_matches();\n\n    // model alias\n    let model_name = matches\n        .get_one::<String>(\"model_alias\")\n        .unwrap()\n        .to_string();\n\n    // prompt context size\n    let ctx_size = matches.get_one::<u32>(\"ctx_size\").unwrap();\n    CTX_SIZE\n        .set(*ctx_size as usize)\n        .expect(\"Fail to parse prompt context size\");\n\n    // prompt\n    let prompt = matches.get_one::<String>(\"prompt\").unwrap().to_string();\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI Support in WasmEdge\nDESCRIPTION: Creates and configures a WasmEdge VM instance with WASI support, retrieving the module instance after configuration. It demonstrates initializing the WASI module and ensuring proper deletion of contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the built-in registered module instances\n * from the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding configuration is not set\n * when creating the VM context.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                         WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering Host Module Instance in WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to create a host module instance with a function, set up its type signature, and register it with the VM. It creates a module named 'extern' with a function 'func-add' that will be imported by the WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\n/* Create the module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\nWasmEdge_StringDelete(HostFuncName);\n\nWasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASI Module in Go for WasmEdge\nDESCRIPTION: Demonstrates how to create and initialize a WASI module instance, register it with a VM, execute WASM functions, and retrieve the WASI exit code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_77\n\nLANGUAGE: go\nCODE:\n```\nwasiobj := wasmedge.NewWasiModule(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:\"}, // The mapping preopens\n)\n\n// Register the WASI into the VM object.\nvm := wasmedge.NewVM()\nvm.RegisterImport(wasiobj)\n\n// ... Execute some WASM functions.\n\n// Get the WASI exit code.\nexitcode := wasiobj.WasiGetExitCode()\n```\n\n----------------------------------------\n\nTITLE: Interacting with WebAssembly using Go and WasmEdge\nDESCRIPTION: This Go code demonstrates how to use the WasmEdge SDK to load and execute WebAssembly functions. It calls the 'allocate', 'fib_array', and 'fib_array_return_memory' functions from the WebAssembly module, and handles memory management and data retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"unsafe\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  n := int32(10)\n\n  p, err := vm.Execute(\"allocate\", 4 * n)\n  if err != nil {\n    fmt.Println(\"allocate failed:\", err)\n  }\n\n  fib, err := vm.Execute(\"fib_array\", n, p[0])\n  if err != nil {\n    fmt.Println(\"fib_rray failed:\", err)\n  } else {\n    fmt.Println(\"fib_array() returned:\", fib[0])\n    fmt.Printf(\"fib_array memory at: %p\\n\", unsafe.Pointer((uintptr)(p[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))\n      if err == nil && fibArray != nil {\n        fmt.Println(\"fibArray:\", fibArray)\n      }\n    }\n  }\n\n  fibP, err := vm.Execute(\"fib_array_return_memory\", n)\n  if err != nil {\n    fmt.Println(\"fib_array_return_memory failed:\", err)\n  } else {\n    fmt.Printf(\"fib_array_return_memory memory at: %p\\n\", unsafe.Pointer((uintptr)(fibP[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))\n      if err == nil && fibArrayReturnMemory != nil {\n        fmt.Println(\"fibArrayReturnMemory:\", fibArrayReturnMemory)\n      }\n    }\n  }\n\n  _, err = vm.Execute(\"deallocate\", p[0].(int32), 4 * n)\n  if err != nil {\n    fmt.Println(\"free failed:\", err)\n  }\n\n\n  exitcode := wasi.WasiGetExitCode()\n  if exitcode != 0 {\n    fmt.Println(\"Go: Running wasm failed, exit code:\", exitcode)\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module Instance in Go\nDESCRIPTION: Example of instantiating and registering an AST object as a named Module instance using the Executor and Store objects. Includes creation of statistics, executor, and store objects with proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, res := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Using Store to Manage Modules in Go\nDESCRIPTION: This snippet explains how to utilize the Store object for managing the state of global variables in WebAssembly programs. It includes registering modules and querying registered modules by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_65\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n\n// ...\n// Register a WASM module via the executor object.\n// ...\n\n// Try to list the registered WASM modules.\nmodnames := store.ListModule()\n// ...\n\n// Find named module by name.\nmod := store.FindModule(\"module\")\n// If the module with name not found, the `mod` will be `nil`.\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Running WASM Functions with WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to asynchronously execute a WebAssembly function from a file using the WasmEdge C API. It creates a VM context, sets up parameters, runs the function, and retrieves the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBytes()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Execution in C\nDESCRIPTION: Demonstrates how to asynchronously execute a Fibonacci function from a WASM file using WasmEdge C API. Creates a VM context, runs the function asynchronously, waits for completion, and retrieves results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Instantiate and Run WASM Functions\nDESCRIPTION: This C code snippet illustrates a step-by-step approach to executing a WASM function. It includes loading the WASM module, validating it, instantiating the module, and then executing the function with parameters. It captures the output or errors during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };\n  WasmEdge_Value Returns[1];\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  WasmEdge_Result Res;\n\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Quick WASM Function Execution with WasmEdge VM\nDESCRIPTION: Go implementation showing rapid execution of a WASM function using WasmEdge VM with WASI configuration. Demonstrates calculating the 21st Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_29\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: VM Creation and Context Management in WasmEdge\nDESCRIPTION: This snippet highlights the creation of a VM instance with a configure and store context in WasmEdge, necessary for managing WebAssembly executions. It involves setting up contexts for configuration and statistics tracking, illustrating how these are integrated into a VM context for accurate execution management. The snippet explains allocations and deallocations, while emphasizing the proper handling and lifecycle management of store contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\\n/* The caller should guarantee the life cycle if the store context. */\\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\\n/*\\n * The VM context already contains the statistics context and can be retrieved\\n * by this API.\\n */\\n/*\\n * Note that the retrieved store and statistics contexts from the VM contexts by\\n * VM APIs should __NOT__ be destroyed and owned by the VM contexts.\\n */\\nWasmEdge_VMDelete(VMCxt);\\nWasmEdge_StoreDelete(StoreCxt);\\nWasmEdge_ConfigureDelete(ConfCxt);\\n\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Shows how to execute functions from a registered WebAssembly module, specifically calculating the 25th Fibonacci number from a registered fibonacci.wasm module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  // Register the WASM module from file into VM with the module name \"mod\".\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n  // The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n  // name \"mod\". As the same as host functions, other modules can import the\n  // function `\"mod\" \"fib\"`.\n\n  // Execute WASM functions in registered modules.\n  // Unlike the execution of functions, the registered functions can be\n  // invoked without `(*VM).Instantiate` because the WASM module was\n  // instantiated when registering.\n  // Developers can also invoke the host functions directly with this API.\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compilation Example in C\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge Ahead-of-Time (AOT) compiler through the C API. It creates a compiler context, compiles a WASM file to a shared library format, and handles any errors that might occur during compilation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\", \"fibonacci.wasm.so\");\n  if (!WasmEdge_ResultOK(Res)) {\n      printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n      return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Function with WasmEdge Go SDK\nDESCRIPTION: Demonstrates the step-by-step process of loading, validating, instantiating, and executing a WASM function using WasmEdge Go SDK components. It includes configuration, statistics tracking, and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n  var mod *wasmedge.Module\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  // Instantiate the WASM module and get the output module instance.\n  mod, err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := mod.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  // Invoke the WASM function.\n  funcinst := mod.FindFunction(\"fib\")\n  if funcinst == nil {\n    fmt.Println(\"Run FAILED: Function name `fib` not found\")\n    return\n  }\n  res, err = executor.Invoke(store, funcinst, int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run FAILED:\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n  mod.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Native Library Interface for WasmEdge in Kotlin\nDESCRIPTION: This Kotlin code defines a NativeLib class that serves as an interface to the C shared library containing WasmEdge functions. It loads the native library and provides a method to execute WebAssembly Fibonacci calculations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/apk.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nclass NativeLib(ctx : Context) {\n  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int\n\n  companion object {\n    init {\n      System.loadLibrary(\"wasmedge_lib\")\n    }\n  }\n\n  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(\"fibonacci.wasm\").readBytes()\n\n  fun wasmFibonacci(idx : Int) : Int{\n    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Step-by-Step Asynchronous WASM Execution in C\nDESCRIPTION: Shows a detailed step-by-step process for loading, validating, instantiating, and asynchronously executing a WebAssembly module. This approach provides more control over the execution process and includes error handling for each step.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Host Function - WasmEdge C\nDESCRIPTION: Defines a host function `Add` in C that adds two integers and returns the result. This function utilizes types from the WasmEdge API to perform operations and return a success status. Dependencies include the `<wasmedge/wasmedge.h>` header for type and function definitions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n\n/* This function can add 2 i32 values and return the result. */\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  */\n\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Client Handler in JavaScript\nDESCRIPTION: JavaScript function that handles each TCP client connection. It reads data from the client, prints it, and echoes it back with an 'echo:' prefix.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nasync function handle_client(cs) {\n  print('server accept:', cs.peer());\n  try {\n    while (true) {\n      let d = await cs.read();\n      if (d == undefined || d.byteLength <= 0) {\n        break;\n      }\n      let s = new TextDecoder().decode(d);\n      print('server recv:', s);\n      cs.write('echo:' + s);\n    }\n  } catch (e) {\n    print('server handle_client error:', e);\n  }\n  print('server: conn close');\n}\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in Go\nDESCRIPTION: Shows how to query the imports and exports of an AST object before instantiation. This allows inspection of the module's interface to ensure all dependencies are satisfied.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\nast := ...\n// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.\n\n// List the imports.\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\n// List the exports.\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering and Executing WASM Modules\nDESCRIPTION: Describes the registration of WASM modules into WasmEdge VM and executing functions from these modules. It includes error handling and demonstrates how parameters and return values are managed in C.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBytes()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBytes()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n   * name \"mod\". As the same as host functions, other modules can import the\n   * function \"mod\" \"fib\".\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                       Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Passing and Managing a Class via ExternRef in C++\nDESCRIPTION: This snippet illustrates passing a C++ class instance to a WASM module via externref. It includes defining a simple class with an add method, passing the object to WasmEdge, and using a host function to retrieve and operate on the object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nclass AddClass {\npublic:\n  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }\n};\n\nAddClass AC;\n\nWasmEdge_Value P[3], R[1];\nP[0] = WasmEdge_ValueGenExternRef(&AC);\nP[1] = WasmEdge_ValueGenI32(1234);\nP[2] = WasmEdge_ValueGenI32(5678);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"call_add\");\nWasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  std::cout << \"Result : \" << WasmEdge_ValueGetI32(R[0]) << std::endl;\n} else {\n  return EXIT_FAILURE;\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nWasmEdge_Result ExternAdd(void *, const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32, i32} -> {i32}\n  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);\n  AddClass &Obj = *reinterpret_cast<AddClass *>(Ptr);\n  uint32_t C =\n      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Patching Cargo.toml for reqwest in WasmEdge\nDESCRIPTION: This toml snippet demonstrates how to patch the dependency crates in Cargo.toml for using reqwest in WasmEdge. Specific git branches are used to ensure compatibility with WasmEdge's socket API. Additionally, dependencies for reqwest and tokio are configured with appropriate versions and features.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\nreqwest = { git = \"https://github.com/second-state/wasi_reqwest.git\", branch = \"0.11.x\" }\n\n[dependencies]\nreqwest = { version = \"0.11\", default-features = false, features = [\"rustls-tls\"] }\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\"] }\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP requests in Rust\nDESCRIPTION: This Rust code handles incoming HTTP requests. It reads data from the TCP stream, parses the request using the `parsed` crate, extracts the path and query parameters, and calls the appropriate response handler. It also handles potential errors during parsing and request processing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::response;\nuse anyhow::Result;\nuse parsed::http::Response;\nuse std::io::Read;\nuse wasmedge_wasi_socket::{SocketAddr, TcpStream};\n\npub fn handle_req(stream: &mut TcpStream, addr: SocketAddr) -> Result<(Response, Option<Vec<u8>>)> {\n    let mut buf = [0u8; 1024];\n    let mut received_data: Vec<u8> = Vec::new();\n\n    loop {\n        let n = stream.read(&mut buf)?;\n        received_data.extend_from_slice(&buf[..n]);\n        if n < 1024 {\n            break;\n        }\n    }\n\n    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {\n        Ok(s) => s.into(),\n        Err(_) => return Ok((response::bad_request(), None)),\n    };\n\n    let req = match parsed::http::parse_http_request(&mut bs) {\n        Some(req) => req,\n        None => return Ok((response::bad_request(), None)),\n    };\n\n    println!(\"{:?} request: {:?} {:?}\", addr, req.method, req.path);\n\n    let mut path_split = req.path.split(\"?\");\n    let path = path_split.next().unwrap_or(\"/\");\n    let query_str = path_split.next().unwrap_or(\"\");\n    let query = querystring::querify(&query_str);\n    let mut init_count: Option<u32> = None;\n    for (k, v) in query {\n        if k.eq(\"init\") {\n            match v.parse::<u32>() {\n                Ok(v) => init_count = Some(v),\n                Err(_) => return Ok((response::bad_request(), None)),\n            }\n        }\n    }\n\n    let (res, binary) = if path.starts_with(\"/static\") {\n        response::file(&path)\n    } else {\n        // render page\n        response::ssr(&path, init_count)\n    }\n    .unwrap_or_else(|_| response::internal_error());\n\n    Ok((res, binary))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly with WasmEdge C API\nDESCRIPTION: This snippet demonstrates the complete process of loading, validating, instantiating, and executing a WebAssembly module using the WasmEdge C API. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /* Create the store context. The store context is the object to link the modules for imports and exports. */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /* Create the executor context. The configure context and the statistics context can be NULL. */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */\n  uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function `fib` not found.\\n\");\n    return 1;\n  }\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Host Function and WASM Execution in C\nDESCRIPTION: This C code demonstrates how to create a WasmEdge VM context, define a host function, register it with a module instance, and execute a WASM module from a buffer. The WASM module calls the host function to add two numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/library.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Import section */\n                    0x02, 0x13, 0x01,\n                    /* module name: \"extern\" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: \"func-add\" */\n                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x0A, 0x01,\n                    /* export name: \"addTwo\" */\n                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x0A, 0x01,\n                    /* code body */\n                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};\n  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Optimization Levels and Output Formats in WasmEdge-Go\nDESCRIPTION: Defines constants for setting AOT compiler optimization levels (from O0 to Oz) and output formats (Native or Wasm). These options control the balance between compilation speed, execution performance, and code size when compiling WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_77\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go for WasmEdge\nDESCRIPTION: Defines the function signature for host functions in WasmEdge. The function takes a data interface, a calling frame, and parameters, and returns a slice of interfaces and a Result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_71\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: WasmEdge VM Initialization and Module Execution\nDESCRIPTION: Shows how to create a VM context, define a WebAssembly module with a hardcoded byte array, register a host module, and execute a WebAssembly function\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/library.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header and module definition */};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n\n  /* Function type and instance creation */\n  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};\n  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n\n  /* Register host module and execute WASM function */\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  /* Resource cleanup */\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator\nDESCRIPTION: Example demonstrating module validation using the Validator context before instantiation. Shows proper error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions from WASM Module in WasmEdge (C)\nDESCRIPTION: Full example demonstrating how to load a WASM file, instantiate it, and list all exported functions. The code retrieves function names and their corresponding types from the instantiated module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing WasmEdge Strings with C API\nDESCRIPTION: This C code shows how to compare two `WasmEdge_String` objects for equality using the `WasmEdge_StringIsEqual()` function. It demonstrates creating strings from both C strings and buffers, then comparing them. The allocated string object created via `WasmEdge_StringCreateByBuffer` is properly deleted.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n\"const char CStr[] = \\\"abcd\\\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\"\n```\n\n----------------------------------------\n\nTITLE: Running WASM Functions with WasmEdge C API\nDESCRIPTION: Example demonstrating how to execute a WebAssembly function using WasmEdge C API, including parameter passing and result handling. Shows function execution with integer parameters and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };\nWasmEdge_Value Returns[1];\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n  VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CRUD Operations with PostgreSQL\nDESCRIPTION: Main function demonstrating database connection setup and CRUD operations using tokio-postgres API with async/await pattern.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/postgres_driver.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<(), Error> {\n    // Connect to the database.\n    let (client, connection) = tokio_postgres::connect(&*get_url(), NoTls).await?;\n\n    // The connection object performs the actual communication with the database,\n    // so spawn it off to run on its own.\n    tokio::spawn(async move {\n        if let Err(e) = connection.await {\n            eprintln!(\"connection error: {}\", e);\n        }\n    });\n\n    client.execute(\"CREATE TABLE IF NOT EXISTS orders (order_id INT, production_id INT, quantity INT, amount REAL, shipping REAL, tax REAL, shipping_address VARCHAR(256));\", &[]).await?;\n\n    let orders = vec![\n        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(\"Mataderos 2312\")),\n        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(\"1234 NW Bobcat\")),\n        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(\"20 Havelock\")),\n        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(\"224 Pandan Loop\")),\n        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(\"No.10 Jalan Besar\")),\n    ];\n\n    for order in orders.iter() {\n        client.execute(\n            \"INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address) VALUES ($1, $2, $3, $4, $5, $6, $7)\",\n            &[&order.order_id, &order.production_id, &order.quantity, &order.amount, &order.shipping, &order.tax, &order.shipping_address]\n        ).await?;\n    }\n\n    let rows = client.query(\"SELECT * FROM orders;\", &[]).await?;\n    for row in rows.iter() {\n        let order_id : i32 = row.get(0);\n        println!(\"order_id {}\", order_id);\n\n        let production_id : i32 = row.get(1);\n        println!(\"production_id {}\", production_id);\n\n        let quantity : i32 = row.get(2);\n        println!(\"quantity {}\", quantity);\n\n        let amount : f32 = row.get(3);\n        println!(\"amount {}\", amount);\n\n        let shipping : f32 = row.get(4);\n        println!(\"shipping {}\", shipping);\n\n        let tax : f32 = row.get(5);\n        println!(\"tax {}\", tax);\n\n        let shipping_address : &str = row.get(6);\n        println!(\"shipping_address {}\", shipping_address);\n    }\n\n    client.execute(\"DELETE FROM orders;\", &[]).await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: AWS Lambda Handler Function for WebAssembly Execution\nDESCRIPTION: AWS Lambda handler function that processes HTTP events, extracts the request body, runs the WebAssembly function, and returns a properly formatted response with CORS headers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nexports.handler = async function (event, context) {\n  var typedArray = new Uint8Array(\n    event.body.match(/[\\da-f]{2}/gi).map(function (h) {\n      return parseInt(h, 16);\n    }),\n  );\n  let buf = await _runWasm(typedArray);\n  return {\n    statusCode: 200,\n    headers: {\n      'Access-Control-Allow-Headers':\n        'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods':\n        'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT',\n    },\n    body: buf.toString('hex'),\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Go Project for WasmEdge Execution\nDESCRIPTION: Bash commands to create a new Go project directory, initialize the module, and prepare for WasmEdge execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Files in Go\nDESCRIPTION: A snippet that demonstrates how to load WASM files using the Loader object, supporting both file and buffer inputs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions in WasmEdge\nDESCRIPTION: This Go code snippet shows how to list exported WASM functions after a WASM module has been instantiated within a WasmEdge VM. It retrieves the function names and their corresponding types, printing the function names. It uses the `GetFunctionList` method to get the names and types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_46\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Module with WasmEdge C++ SDK\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C++ SDK to create a VM context, load a WebAssembly module from a file, and execute a function. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c++/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <iostream>\n\nint main(int argc, char** argv) {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext* conf_cxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(conf_cxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext* vm_cxt = WasmEdge_VMCreate(conf_cxt, nullptr);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value params[1] = { WasmEdge_ValueGenI32(40) };\n  WasmEdge_Value returns[1];\n  /* Function name. */\n  WasmEdge_String func_name = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result res = WasmEdge_VMRunWasmFromFile(vm_cxt, argv[1], func_name, params, 1, returns, 1);\n\n  if (WasmEdge_ResultOK(res)) {\n    std::cout << \"Get result: \" << WasmEdge_ValueGetI32(returns[0]) << std::endl;\n  } else {\n    std::cout << \"Error message: \" << WasmEdge_ResultGetMessage(res) << std::endl;\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(vm_cxt);\n  WasmEdge_ConfigureDelete(conf_cxt);\n  WasmEdge_StringDelete(func_name);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing VM Components (Loader, Validator, Executor) in WasmEdge (C)\nDESCRIPTION: Shows how to access the internal components of a VM context, including the Loader, Validator, and Executor. These components should not be manually deleted as they are owned by the VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Direct Asynchronous WebAssembly Function Execution in C\nDESCRIPTION: Demonstrates how to asynchronously execute a WebAssembly function (Fibonacci calculation) using WasmEdge C API. The code shows VM context creation, async function execution, and result handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bindgen Functions in Rust for WebAssembly\nDESCRIPTION: This Rust code defines several functions using the wasmedge_bindgen macro to enable complex parameter passing between Go and WebAssembly. It includes operations on custom structs, string manipulation, and cryptographic functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/bindgen.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse num_integer::lcm;\nuse serde::{Deserialize, Serialize};\nuse sha3::{Digest, Keccak256, Sha3_256};\n#[allow(unused_imports)]\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: f32,\n    y: f32,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n    points: Vec<Point>,\n    valid: bool,\n    length: f32,\n    desc: String,\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> String {\n    let point1: Point = serde_json::from_str(&p1).unwrap();\n    let point2: Point = serde_json::from_str(&p2).unwrap();\n    let length = ((point1.x - point2.x) * (point1.x - point2.x)\n        + (point1.y - point2.y) * (point1.y - point2.y))\n        .sqrt();\n\n    let valid = if length == 0.0 { false } else { true };\n\n    let line = Line {\n        points: vec![point1, point2],\n        valid: valid,\n        length: length,\n        desc: desc,\n    };\n\n    return serde_json::to_string(&line).unwrap();\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> String {\n    let r = String::from(\"hello \");\n    return r + &s;\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> String {\n    (&s).chars()\n        .map(|c| match c {\n            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,\n            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,\n            _ => c,\n        })\n        .collect()\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> i32 {\n    let r = lcm(a, b);\n    return r;\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {\n    return Sha3_256::digest(&v).as_slice().to_vec();\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {\n    return Keccak256::digest(&s).as_slice().to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance with Components in WasmEdge C API\nDESCRIPTION: This code demonstrates creating a module instance with the name 'module' and adding function, table, memory, and global instances to it. The snippet shows the full lifecycle from creation to cleanup, emphasizing proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_78\n\nLANGUAGE: c\nCODE:\n```\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\n/*\n * Developers can also use the WasmEdge_ModuleInstanceCreateWithData() to\n * create the module instance with the data and its finalizer. It will be\n * introduced later.\n */\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                 WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n    WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n\n/* Create and add a global instance into the module instance. */\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module\n * instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Server in JavaScript\nDESCRIPTION: JavaScript code demonstrating how to create an HTTP server that listens on port 8001 using Node.js compatible APIs. The server echoes back any incoming request with a prefix.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createServer, request, fetch } from 'http';\n\ncreateServer((req, resp) => {\n  req.on('data', (body) => {\n    resp.write('echo:');\n    resp.end(body);\n  });\n}).listen(8001, () => {\n  print('listen 8001 ...\\n');\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing String Handling in TinyGo for WebAssembly\nDESCRIPTION: This TinyGo code defines a 'greet' function that takes a pointer to a string, constructs the string, and returns a greeting message. It demonstrates how to handle string data in WebAssembly using TinyGo, including memory pointer manipulation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"strings\"\n  \"unsafe\"\n)\n\nfunc main() {}\n\n//export greet\nfunc greet(subject *int32) *int32 {\n  nth := 0\n  var subjectStr strings.Builder\n  pointer := uintptr(unsafe.Pointer(subject))\n  for {\n    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))\n    if s == 0 {\n      break\n    }\n\n    subjectStr.WriteByte(byte(s))\n    nth++\n  }\n\n  output := []byte(\"Hello, \" + subjectStr.String() + \"!\")\n\n  r := make([]int32, 2)\n  r[0] = int32(uintptr(unsafe.Pointer(&(output[0]))))\n  r[1] = int32(len(output))\n\n  return &r[0]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance with Host Function in C\nDESCRIPTION: Creates a module instance with a host function for adding two integers. Demonstrates registering a host function, creating function types, and adding the function to the module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_76\n\nLANGUAGE: c\nCODE:\n```\n/* Create the module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\nWasmEdge_StringDelete(HostFuncName);\n```\n\n----------------------------------------\n\nTITLE: Validating a WASM Module in Go\nDESCRIPTION: This snippet illustrates how to validate a WASM module after loading it to ensure it is well-formed before instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_46\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions in WasmEdge C API\nDESCRIPTION: Complete example showing how to load a WASM module, instantiate it, and list all its exported functions. The program retrieves function names and types from the VM context after instantiating a fibonacci module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAssembly Proposals in WasmEdge\nDESCRIPTION: Demonstrates how to add, remove, and check WebAssembly proposals in the WasmEdge configuration context. It shows the default enabled proposals and how to modify them.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Interfacing With WebAssembly in Go\nDESCRIPTION: This Go application demonstrates how to interact with the WasmEdge VM. It sets up WASI, calls Rust functions for Fibonacci calculations, and manages raw memory pointers effectively. The Go program also handles memory allocation and deallocation through interaction with Rust functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"unsafe\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\":.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  n := int32(10)\n\n  p, err := vm.Execute(\"allocate\", 4 * n)\n  if err != nil {\n    fmt.Println(\"allocate failed:\", err)\n  }\n\n  fib, err := vm.Execute(\"fib_array\", n, p[0])\n  if err != nil {\n    fmt.Println(\"fib_array failed:\", err)\n  } else {\n    fmt.Println(\"fib_array() returned:\", fib[0])\n    fmt.Printf(\"fib_array memory at: %p\\n\", unsafe.Pointer((uintptr)(p[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))\n      if err == nil && fibArray != nil {\n        fmt.Println(\"fibArray:\", fibArray)\n      }\n    }\n  }\n\n  fibP, err := vm.Execute(\"fib_array_return_memory\", n)\n  if err != nil {\n    fmt.Println(\"fib_array_return_memory failed:\", err)\n  } else {\n    fmt.Printf(\"fib_array_return_memory memory at: %p\\n\", unsafe.Pointer((uintptr)(fibP[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))\n      if err == nil && fibArrayReturnMemory != nil {\n        fmt.Println(\"fibArrayReturnMemory:\", fibArrayReturnMemory)\n      }\n    }\n  }\n\n  _, err = vm.Execute(\"deallocate\", p[0].(int32), 4 * n)\n  if err != nil {\n    fmt.Println(\"free failed:\", err)\n  }\n\n\n  exitcode := wasi.WasiGetExitCode()\n  if exitcode != 0 {\n    fmt.Println(\"Go: Running wasm failed, exit code:\", exitcode)\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Modules with WasmEdge Loader\nDESCRIPTION: Example showing how to use the WasmEdge Loader context to load WASM modules from files or buffers. Demonstrates proper resource management and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules into WasmEdge VM\nDESCRIPTION: Shows how to create and register host modules into a WasmEdge VM context, ensuring the proper deletion of module instances after use. It highlights error handling and module instance availability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\n```\n\n----------------------------------------\n\nTITLE: Linking WASM Modules with WasmEdge Executor Context in C\nDESCRIPTION: This C code demonstrates how to link two WASM modules, `lib.wasm` and `test.wasm`, using the WasmEdge executor context. It loads, validates, and instantiates the `lib.wasm` module with the name \"math\" before loading and instantiating the `test.wasm` module. Subsequently, it invokes functions from the `test.wasm` module and prints the results. The code requires the `wasmedge` library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* Create the contexts. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n  /* Load and register the `lib.wasm` with the module name \"math\". */\n  WasmEdge_ASTModuleContext *LibASTCxt = NULL;\n  WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, \"lib.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Load lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validate lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,\n                                  ModuleName);\n  WasmEdge_StringDelete(ModuleName);\n  WasmEdge_ASTModuleDelete(LibASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiate lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Load and instantiate the `test.wasm`. */\n  WasmEdge_ASTModuleContext *TestASTCxt = NULL;\n  WasmEdge_ModuleInstanceContext *TestInstCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &TestASTCxt, \"test.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Load test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_ValidatorValidate(ValidCxt, TestASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validate test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res =\n      WasmEdge_ExecutorInstantiate(ExecCxt, &TestInstCxt, StoreCxt, TestASTCxt);\n  WasmEdge_ASTModuleDelete(TestASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiate test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Invoke the functions. */\n  /* Invoke the \"add_and_square\" to calculate (123 + 456)^2 */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add_and_square\");\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);\n  WasmEdge_StringDelete(FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function 'add_and_square' not found.\\n\");\n    return -1;\n  }\n  Params[0] = WasmEdge_ValueGenI32(123);\n  Params[1] = WasmEdge_ValueGenI32(456);\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '(%d + %d)^2' result: %d\\n\", 123, 456,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'add_and_square' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n  /* Invoke the \"sum_of_squares\" to calculate (77^2 + 88^2) */\n  FuncName = WasmEdge_StringCreateByCString(\"sum_of_squares\");\n  FuncCxt = WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);\n  WasmEdge_StringDelete(FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function 'sum_of_squares' not found.\\n\");\n    return -1;\n  }\n  Params[0] = WasmEdge_ValueGenI32(77);\n  Params[1] = WasmEdge_ValueGenI32(88);\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '%d^2 + %d^2' result: %d\\n\", 77, 88,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'sum_of_squares' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_ModuleInstanceDelete(LibInstCxt);\n  WasmEdge_ModuleInstanceDelete(TestInstCxt);\n  return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Performing an Asynchronous HTTP GET Request with hyper\nDESCRIPTION: Demonstrates using the hyper library to perform an asynchronous HTTP GET request, returning the response data as a string. The function utilizes the Client from hyper and processes the stream of data received incrementally.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nasync fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {\n    let client = Client::new();\n    let mut res = client.get(url).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!(\"{}\", String::from_utf8_lossy(&resp_data));\n```\n\n----------------------------------------\n\nTITLE: Creating a JavaScript Function API in Rust\nDESCRIPTION: Rust code that defines a function that can be incorporated into JavaScript as an API. It implements the JsFn trait to handle function calls from JavaScript.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn run_rust_function(ctx: &mut Context) {\n\n  struct HelloFn;\n  impl JsFn for HelloFn {\n    fn call(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {\n      println!(\"hello from rust\");\n      println!(\"argv={:?}\", argv);\n      JsValue::UnDefined\n    }\n  }\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Anonymous Module Instance in C\nDESCRIPTION: Demonstrates instantiation of an AST module into an anonymous Module instance. Shows context creation, instantiation process, and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Function Context for Host Function in C\nDESCRIPTION: Demonstrates how to create a Function context with a host function body and function type. This process involves defining parameter and return types, creating a function type, and then creating the function instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_76\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                  WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost\n * measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/*\n * If the function instance is __NOT__ added into a module instance context,\n * it should be deleted.\n */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Function Execution in C\nDESCRIPTION: This C++ code implements the native method for executing WebAssembly Fibonacci calculations using the WasmEdge C SDK. It sets up the WasmEdge VM, loads the WebAssembly module, and executes the specified function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/apk.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nextern \"C\" JNIEXPORT jint JNICALL\nJava_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(\n    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {\n  jsize buffer_size = env->GetArrayLength(image_bytes);\n  jbyte *buffer = env->GetByteArrayElements(image_bytes, nullptr);\n\n  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);\n\n  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);\n\n  const WasmEdge_String &func_name = WasmEdge_StringCreateByCString(\"fib\");\n  std::array<WasmEdge_Value, 1> params{WasmEdge_ValueGenI32(idx)};\n  std::array<WasmEdge_Value, 1> ret_val{};\n\n  const WasmEdge_Result &res = WasmEdge_VMRunWasmFromBuffer(\n      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),\n      params.size(), ret_val.data(), ret_val.size());\n\n  WasmEdge_VMDelete(vm_ctx);\n  WasmEdge_ConfigureDelete(conf);\n  WasmEdge_StringDelete(func_name);\n\n  env->ReleaseByteArrayElements(image_bytes, buffer, 0);\n  if (!WasmEdge_ResultOK(res)) {\n    return -1;\n  }\n  return WasmEdge_ValueGetI32(ret_val[0]);\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Handler Implementation\nDESCRIPTION: Request handler implementation that parses HTTP requests and manages response generation based on request path and query parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::response;\nuse anyhow::Result;\nuse parsed::http::Response;\nuse std::io::Read;\nuse wasmedge_wasi_socket::{SocketAddr, TcpStream};\n\npub fn handle_req(stream: &mut TcpStream, addr: SocketAddr) -> Result<(Response, Option<Vec<u8>>)> {\n    let mut buf = [0u8; 1024];\n    let mut received_data: Vec<u8> = Vec::new();\n\n    loop {\n        let n = stream.read(&mut buf)?;\n        received_data.extend_from_slice(&buf[..n]);\n        if n < 1024 {\n            break;\n        }\n    }\n\n    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {\n        Ok(s) => s.into(),\n        Err(_) => return Ok((response::bad_request(), None)),\n    };\n\n    let req = match parsed::http::parse_http_request(&mut bs) {\n        Some(req) => req,\n        None => return Ok((response::bad_request(), None)),\n    };\n\n    println!(\"{:?} request: {:?} {:?}\", addr, req.method, req.path);\n\n    let mut path_split = req.path.split(\"?\");\n    let path = path_split.next().unwrap_or(\"/\");\n    let query_str = path_split.next().unwrap_or(\"\");\n    let query = querystring::querify(&query_str);\n    let mut init_count: Option<u32> = None;\n    for (k, v) in query {\n        if k.eq(\"init\") {\n            match v.parse::<u32>() {\n                Ok(v) => init_count = Some(v),\n                Err(_) => return Ok((response::bad_request(), None)),\n            }\n        }\n    }\n\n    let (res, binary) = if path.starts_with(\"/static\") {\n        response::file(&path)\n    } else {\n        response::ssr(&path, init_count)\n    }\n    .unwrap_or_else(|_| response::internal_error());\n\n    Ok((res, binary))\n}\n```\n\n----------------------------------------\n\nTITLE: Linking and Executing WASM Modules with WasmEdge in C\nDESCRIPTION: This C program demonstrates loading two WASM modules ('lib.wasm' and 'test.wasm'), linking them together, and executing functions from the 'test' module that depend on the 'lib' module. It uses the WasmEdge API to handle WASM operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* Create the contexts. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n  /* Load and register the `lib.wasm` with the module name \"math\". */\n  WasmEdge_ASTModuleContext *LibASTCxt = NULL;\n  WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, \"lib.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Load lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validate lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,\n                                  ModuleName);\n  WasmEdge_StringDelete(ModuleName);\n  WasmEdge_ASTModuleDelete(LibASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiate lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Load and instantiate the `test.wasm`. */\n  WasmEdge_ASTModuleContext *TestASTCxt = NULL;\n  WasmEdge_ModuleInstanceContext *TestInstCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &TestASTCxt, \"test.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Load test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_ValidatorValidate(ValidCxt, TestASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validate test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res =\n      WasmEdge_ExecutorInstantiate(ExecCxt, &TestInstCxt, StoreCxt, TestASTCxt);\n  WasmEdge_ASTModuleDelete(TestASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiate test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Invoke the functions. */\n  /* Invoke the \"add_and_square\" to calculate (123 + 456)^2 */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add_and_square\");\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);\n  WasmEdge_StringDelete(FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function 'add_and_square' not found.\\n\");\n    return -1;\n  }\n  Params[0] = WasmEdge_ValueGenI32(123);\n  Params[1] = WasmEdge_ValueGenI32(456);\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '(%d + %d)^2' result: %d\\n\", 123, 456,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'add_and_square' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n  /* Invoke the \"sum_of_squares\" to calculate (77^2 + 88^2) */\n  FuncName = WasmEdge_StringCreateByCString(\"sum_of_squares\");\n  FuncCxt = WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);\n  WasmEdge_StringDelete(FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function 'sum_of_squares' not found.\\n\");\n    return -1;\n  }\n  Params[0] = WasmEdge_ValueGenI32(77);\n  Params[1] = WasmEdge_ValueGenI32(88);\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '%d^2 + %d^2' result: %d\\n\", 77, 88,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'sum_of_squares' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_ModuleInstanceDelete(LibInstCxt);\n  WasmEdge_ModuleInstanceDelete(TestInstCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Module Instance Exports in Go\nDESCRIPTION: Demonstrates how to list and find exported instances from a WebAssembly module instance. Shows retrieving function names and looking up specific functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\nfuncnames := mod.ListFunction()\n\nfuncinst := mod.FindFunction(\"fib\")\n// `funcinst` will be `nil` if the function not found.\n// The returned instance is owned by the module instance and should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Handling String Parameters in Rust WebAssembly Function\nDESCRIPTION: This Rust code defines functions for allocating memory, deallocating memory, and greeting a subject. It demonstrates how to handle string parameters in WebAssembly, including memory management and string conversion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ffi::{CStr, CString};\nuse std::mem;\nuse std::os::raw::{c_char, c_void};\n\n#[no_mangle]\npub extern fn allocate(size: usize) -> *mut c_void {\n  let mut buffer = Vec::with_capacity(size);\n  let pointer = buffer.as_mut_ptr();\n  mem::forget(buffer);\n\n  pointer as *mut c_void\n}\n\n#[no_mangle]\npub extern fn deallocate(pointer: *mut c_void, capacity: usize) {\n  unsafe {\n    let _ = Vec::from_raw_parts(pointer, 0, capacity);\n  }\n}\n\n#[no_mangle]\npub extern fn greet(subject: *mut c_char) -> *mut c_char {\n  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };\n  let mut output = b\"Hello, \".to_vec();\n  output.extend(&subject);\n  output.extend(&[b'!']);\n\n  unsafe { CString::from_vec_unchecked(output) }.into_raw()\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly with WasmEdge C API\nDESCRIPTION: Demonstrates how to compile a WASM file to AOT format using WasmEdge C API. Creates configuration and compiler contexts, compiles the file, and handles cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_87\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\",\n                                 \"fibonacci-aot.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance with Host Data and Finalizer in C\nDESCRIPTION: Shows how to create a module instance with host data and a finalizer function. Useful for implementing plug-ins and managing resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_78\n\nLANGUAGE: c\nCODE:\n```\n/* Create a module instance with host data and its finalizer. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nPoint *Data = (Point *)malloc(sizeof(Point));\nData->X = 5;\nData->Y = -5;\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);\n/*\n* When the `HostModCxt` being destroyed, the finalizer will be invoked and the\n* `Data` will be its argument.\n*/\nWasmEdge_StringDelete(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge - C\nDESCRIPTION: Explains the process of registering host modules into a WasmEdge store or VM context, allowing their import into WebAssembly modules. It includes checking registration results and managing the lifecycle of contexts used.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Register the module instance into the store. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Host module registration failed: %s\\n\",\n         WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/*\n * Developers can register the host module into a VM context by the\n * `WasmEdge_VMRegisterModuleFromImport()` API.\n */\n/*\n * The owner of the host module will not be changed. Developers can register\n * the host module into several VMs or stores.\n */\n\n/* Although being registered, the host module should be destroyed. */\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with Shared Data in WasmEdge\nDESCRIPTION: Example showing how to share data between a Go application and WebAssembly modules using host functions. This technique allows the host function to modify external state that the Go program can access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_70\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Also set the result to the data.\n  *data.(*int32) = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // The additional data to set into the host function.\n  var data int32 = 0\n\n  // Create the module instance with the module name \"extern\".\n  modinst := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\n  functype.Release()\n  modinst.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(modinst)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  fmt.Println(\"Data value:\", data)\n\n  modinst.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function in Go for WasmEdge\nDESCRIPTION: Implements a host function named 'host_add' that adds two i32 values. It demonstrates parameter handling and return value preparation in WasmEdge host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM\nDESCRIPTION: Demonstrates how to enable WASI support when creating a WasmEdge VM context, and how to retrieve and initialize the WASI module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the built-in registered module instances\n * from the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding configuration is not set\n * when creating the VM context.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                      WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge VM Creation Examples\nDESCRIPTION: Different ways to create WasmEdge VM instances with various configurations and store objects. Demonstrates VM initialization with different combinations of Configure and Store objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Parsing Command Line Arguments in Rust\nDESCRIPTION: Rust code for parsing command line arguments using the Command struct to extract prompt, model alias, and context size parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), String> {\n    let matches = Command::new(\"Simple LLM inference\")\n        .arg(\n            Arg::new(\"prompt\")\n                .short('p')\n                .long(\"prompt\")\n                .value_name(\"PROMPT\")\n                .help(\"Sets the prompt.\")\n                .required(true),\n        )\n        .arg(\n            Arg::new(\"model_alias\")\n                .short('m')\n                .long(\"model-alias\")\n                .value_name(\"ALIAS\")\n                .help(\"Sets the model alias\")\n                .default_value(\"default\"),\n        )\n        .arg(\n            Arg::new(\"ctx_size\")\n                .short('c')\n                .long(\"ctx-size\")\n                .value_parser(clap::value_parser!(u32))\n                .value_name(\"CTX_SIZE\")\n                .help(\"Sets the prompt context size\")\n                .default_value(DEFAULT_CTX_SIZE),\n        )\n        .get_matches();\n\n    // model alias\n    let model_name = matches\n        .get_one::<String>(\"model_alias\")\n        .unwrap()\n        .to_string();\n\n    // prompt context size\n    let ctx_size = matches.get_one::<u32>(\"ctx_size\").unwrap();\n    CTX_SIZE\n        .set(*ctx_size as usize)\n        .expect(\"Fail to parse prompt context size\");\n\n    // prompt\n    let prompt = matches.get_one::<String>(\"prompt\").unwrap().to_string();\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WASM Execution with Loader and Executor in Go\nDESCRIPTION: This example demonstrates executing WASM functions step-by-step by utilizing the Loader, Validator, Executor, and Store objects from the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  // Instantiate the WASM module into the Store object.\n  err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := store.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  // Invoke the WASM function.\n  res, err = executor.Invoke(store, \"fib\", int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Populating Import Object with Instances in WasmEdge\nDESCRIPTION: Example showing how to create an import object and add function, table, memory, and global instances to it. Each instance is created with its specific type and then added to the import object with an export name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create the import object. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the import object. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {.HasMax = true, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ImportObjectAddTable(ImpObj, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {.HasMax = true, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ImportObjectAddMemory(ImpObj, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n\n/* Create and add a global instance into the import object. */\nWasmEdge_GlobalTypeContext *HostGType =\n  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ImportObjectAddGlobal(ImpObj, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The import objects should be deleted.\n * Developers should __NOT__ destroy the instances added into the import object contexts.\n */\nWasmEdge_ImportObjectDelete(ImpObj);\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WASM Execution Example\nDESCRIPTION: Complete example demonstrating step-by-step WASM execution using Loader, Validator, Executor, and Store objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogDebugLevel()\n  conf := wasmedge.NewConfigure()\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  stat := wasmedge.NewStatistics()\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  funcnames := store.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  res, err = executor.Invoke(store, \"fib\", int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering WASI and WasmEdge Process Modules in Go\nDESCRIPTION: Example showing how to create and register WASI and WasmEdge Process module instances in a WasmEdge VM. It demonstrates initializing the modules with arguments, environment variables, preopens, and allowed commands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_68\n\nLANGUAGE: go\nCODE:\n```\nwasiobj := wasmedge.NewWasiModule(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:.\"},  // The mapping preopens\n)\nprocobj := wasmedge.NewWasmEdgeProcessModule(\n  []string{\"ls\", \"echo\"}, // The allowed commands\n  false,                  // Not to allow all commands\n)\n\n// Register the WASI and WasmEdge_Process into the VM object.\nvm := wasmedge.NewVM()\nvm.RegisterImport(wasiobj)\nvm.RegisterImport(procobj)\n\n// ... Execute some WASM functions.\n\n// Get the WASI exit code.\nexitcode := wasiobj.WasiGetExitCode()\n// The `exitcode` will be 0 if the WASI function \"_start\" execution has no error.\n// Otherwise, it will return with the related exit code.\n\nvm.Release()\n// The import objects should be deleted.\nwasiobj.Release()\nprocobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Number Generation in Rust for WebAssembly\nDESCRIPTION: This Rust code demonstrates how to generate random numbers and byte arrays using the 'rand' crate in a WebAssembly environment. It includes functions for generating a random i32 and a vector of random bytes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse rand::prelude::*;\n\npub fn get_random_i32() -> i32 {\n  let x: i32 = random();\n  return x;\n}\n\npub fn get_random_bytes() -> Vec<u8> {\n  let mut rng = thread_rng();\n  let mut arr = [0u8; 128];\n  rng.fill(&mut arr[..]);\n  return arr.to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP requests with hyper in Rust\nDESCRIPTION: This Rust function `echo` handles incoming HTTP requests and provides different responses based on the method and URI path. It serves instructions at `/`, echoes the request body at `/echo`, reverses the body at `/echo/reversed`, and returns a 404 Not Found error for other routes. It uses the `hyper` crate for handling HTTP requests and responses.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nasync fn echo(req: Request<Body>) -> Result<Response<Body>, hyper::Error> {\n    match (req.method(), req.uri().path()) {\n        // Serve some instructions at /\n        (&Method::GET, \"/\") => Ok(Response::new(Body::from(\n            \"Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`\",\n        ))),\n\n        // Simply echo the body back to the client.\n        (&Method::POST, \"/echo\") => Ok(Response::new(req.into_body())),\n\n        (&Method::POST, \"/echo/reversed\") => {\n            let whole_body = hyper::body::to_bytes(req.into_body()).await?;\n\n            let reversed_body = whole_body.iter().rev().cloned().collect::<Vec<u8>>();\n            Ok(Response::new(Body::from(reversed_body)))\n        }\n\n        // Return the 404 Not Found for other routes.\n        _ => {\n            let mut not_found = Response::default();\n            *not_found.status_mut() = StatusCode::NOT_FOUND;\n            Ok(not_found)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Host Function Implementation\nDESCRIPTION: Implementation of a host function in C that can be called from WebAssembly. Demonstrates parameter handling, result generation, and data object manipulation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Host Function with External Data Access in WasmEdge C API\nDESCRIPTION: This example demonstrates how to create a host function that can access external host data. The host function receives input parameters from WebAssembly, performs a calculation, and updates both the WebAssembly return value and the external host data with the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_73\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                   const WasmEdge_CallingFrameContext *CallFrameCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Step-by-Step WasmEdge Example\nDESCRIPTION: Bash commands for compiling and running the step-by-step C implementation, showing the calculation of the 10th Fibonacci number (89).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 89\n```\n\n----------------------------------------\n\nTITLE: Implementing Go Host Application for WasmEdge TensorFlow Inference\nDESCRIPTION: Go application that instantiates a WasmEdge runtime with TensorFlow extension, loads the WebAssembly module, and executes the inference function by passing image data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/ai.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  fmt.Println(\"Go: Args:\", os.Args)\n  // Expected Args[0]: program name (./mobilenet)\n  // Expected Args[1]: wasm file (rust_mobilenet_lib.wasm)\n  // Expected Args[2]: input image name (grace_hopper.jpg)\n\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Set Tensorflow not to print debug info\n  os.Setenv(\"TF_CPP_MIN_LOG_LEVEL\", \"3\")\n  os.Setenv(\"TF_CPP_MIN_VLOG_LEVEL\", \"3\")\n\n  // Load WasmEdge-image and WasmEdge-tensorflow from default path\n  wasmedge.LoadPluginDefaultPaths()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n\n  // Load and validate the wasm\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n\n  // Instantiate the bindgen and vm\n  bg := bindgen.New(vm)\n  bg.Instantiate()\n\n  img, _ := ioutil.ReadFile(os.Args[2])\n  if res, _, err := bg.Execute(\"infer\", img); err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(res[0].(string))\n  }\n\n  bg.Release()\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cost Table and Limits in WasmEdge Statistics\nDESCRIPTION: Example showing how to set a cost table and cost limit for WebAssembly execution. This allows limiting resource usage by assigning costs to different WebAssembly instructions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0,\n}\n// Developers can set the costs of each instruction. The value not covered will be 0.\n\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\n\n// ... After running the WASM functions with the `Statistics` object\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Global Instances in C\nDESCRIPTION: This code demonstrates the complete lifecycle of a WasmEdge global instance, including creation with an initial value, type handling, value manipulation, and proper cleanup. It shows how to create a mutable global with an I64 value type, check its properties, update its value, and finally clean up resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_73\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n   /* Create the global type with value type and mutation. */\n   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n       WasmEdge_ValTypeGenI64(), WasmEdge_Mutability_Var);\n   /* Create the global instance with value and global type. */\n   WasmEdge_GlobalInstanceContext *HostGlobal =\n       WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n   /* Delete the global type. */\n   WasmEdge_GlobalTypeDelete(GlobTypeCxt);\n   WasmEdge_Result Res;\n\n   const WasmEdge_GlobalTypeContext *GotGlobTypeCxt =\n       WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n   /*\n    * The `GotGlobTypeCxt` got from global instance is owned by the `HostGlobal`\n    * and should __NOT__ be destroyed.\n    */\n   WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GotGlobTypeCxt);\n   bool IsTypeF64 = WasmEdge_ValTypeIsI64(ValType);\n   /* `ValType` will be `TRUE`. */\n   enum WasmEdge_Mutability ValMut =\n       WasmEdge_GlobalTypeGetMutability(GotGlobTypeCxt);\n   /* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\n   Res = WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n   /*\n    * Set the value u64(888) to the global.\n    * This function will return error if the value type mismatched or\n    * the global mutability is `WasmEdge_Mutability_Const`.\n    */\n   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n   /* Get the value (888 now) of the global context. */\n\n   WasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Advanced Asynchronous WASM Function Execution in Go\nDESCRIPTION: Shows step-by-step manual instantiation and asynchronous execution of WASM functions. Includes module loading, validation, instantiation and execution steps.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Using the WasmEdge Validator in Go\nDESCRIPTION: This snippet shows how to use the WasmEdge Validator to validate WASM modules before instantiation. It demonstrates creating a validator with configuration and validating an AST object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plugins in C\nDESCRIPTION: Shows how to load WasmEdge plugins from default paths or a specific path, list loaded plugins, and create module instances from a plugin. Uses the WASI-Crypto plugin as an example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_86\n\nLANGUAGE: C\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n\n/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Function with Host Parameters\nDESCRIPTION: Example showing how to execute a WASM function by passing parameters and receiving return values using the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };\nWasmEdge_Value Returns[1];\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n  VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Async WASM Execution with Timeout in Go\nDESCRIPTION: Shows how to handle asynchronous execution with timeout settings and cancellation handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Function Object with Host Function in Go for WasmEdge\nDESCRIPTION: Shows how to create a Function object in WasmEdge using a host function and function type. The function type is defined with input and output types, and the Function object is created with the type and host function body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_73\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an module instance object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Package.json Configuration\nDESCRIPTION: NPM package configuration specifying dependencies and build scripts for the project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/npm.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dependencies\": {\n    \"mathjs\": \"^9.5.1\",\n    \"md5\": \"^2.3.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.16.5\",\n    \"@babel/preset-env\": \"^7.16.5\",\n    \"@babel/preset-react\": \"^7.16.5\",\n    \"@rollup/plugin-babel\": \"^5.3.0\",\n    \"@rollup/plugin-commonjs\": \"^21.0.1\",\n    \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n    \"@rollup/plugin-replace\": \"^3.0.0\",\n    \"rollup\": \"^2.60.1\",\n    \"rollup-plugin-babel\": \"^4.4.0\",\n    \"rollup-plugin-node-builtins\": \"^2.1.2\",\n    \"rollup-plugin-node-globals\": \"^1.4.0\",\n    \"rollup-plugin-async\": \"^1.2.0\"\n  },\n  \"scripts\": {\n    \"build\": \"rollup -c rollup.config.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions Rapidly with WasmEdge VM in Go\nDESCRIPTION: Example of creating a WasmEdge VM instance, loading a WASM file, and executing a function rapidly. This demonstrates how to run a Fibonacci function defined in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Addition Host Function Implementation in C\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns their sum.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n     /*\n     * Params: {i32, i32}\n     * Returns: {i32}\n     * Developers should take care about the function type.\n     */\n     /* Retrieve the value 1. */\n     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n     /* Retrieve the value 2. */\n     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n     /* Output value 1 is Val1 + Val2. */\n     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n     /* Return the status of success. */\n     return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: This example demonstrates how to execute functions within registered WASM modules using the WasmEdge Go SDK. It registers the Fibonacci WASM module and calls its 'fib' function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  // Register the WASM module from file into VM with the module name \"mod\".\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n  // The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n  // name \"mod\". As the same as host functions, other modules can import the\n  // function `\"mod\" \"fib\"`.\n\n  // Execute WASM functions in registered modules.\n  // Unlike the execution of functions, the registered functions can be\n  // invoked without `(*VM).Instantiate` because the WASM module was\n  // instantiated when registering.\n  // Developers can also invoke the host functions directly with this API.\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Go Implementation Example\nDESCRIPTION: Full example showing host function implementation, VM creation, and WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  res := params[0].(int32) + params[1].(int32)\n  returns := make([]interface{}, 1)\n  returns[0] = res\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  vm := wasmedge.NewVM()\n  impobj := wasmedge.NewImportObject(\"extern\")\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impobj.AddFunction(\"func-add\", hostfunc)\n  vm.RegisterImport(impobj)\n  // ... WASM execution code ...\n  impobj.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating WasmEdge VM Instances with Different Configurations in Go\nDESCRIPTION: Examples of creating WasmEdge VM instances with various configurations, including default settings, custom configurations, and specified stores. This demonstrates the flexibility in VM initialization.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Example in Bash\nDESCRIPTION: Commands for compiling the C example with GCC and running the resulting executable. The output demonstrates successful execution of the Fibonacci function with the 18th Fibonacci number (4181).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Creating and Populating Import Object in WasmEdge-go\nDESCRIPTION: Demonstrates how to create an ImportObject in WasmEdge-go and add various instances (Function, Table, Memory, Global) to it. This object can be used to provide host functionality to WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\n// Create the import object with the module name \"module\".\nimpobj := wasmedge.NewImportObject(\"module\")\n\n// Create and add a function instance into the import object with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nimpobj.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the import object with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nimpobj.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the import object with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nimpobj.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the import object with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nimpobj.AddGlobal(\"global\", hostglob)\n\n// The import objects should be released.\n// Developers should __NOT__ release the instances added into the import object objects.\nimpobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Running WASM Functions Manually with WasmEdge VM Context in C\nDESCRIPTION: This C code shows how to manually instantiate and run WASM functions step-by-step using the WasmEdge VM context. It demonstrates the process of loading, validating, instantiating, and executing a Fibonacci WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBytes()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * Step 4: Execute WASM functions. You can execute functions repeatedly\n   * after instantiation.\n   */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Host Functions with Data in WasmEdge (C)\nDESCRIPTION: This snippet demonstrates how to create a host function that accepts and uses host data in WasmEdge. It includes the function body definition, host data declaration, and function instance creation. The host function prints the passed double value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result PrintData(void *Data,\n                          const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {} -> {} */\n  printf(\"Data: %lf\\n\", *(double *)Data);\n  return WasmEdge_Result_Success;\n}\n\n/* The host data. */\ndouble Number = 0.0f;\n\n/* Create a function type: {} -> {}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(NULL, 0, NULL, 0);\n/* Create a function context with the function type and host function body. */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, &PrintData, (void *)(&Number), 0);\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Information in C\nDESCRIPTION: Illustrates how to query import and export information from an AST Module context. It lists import and export types, demonstrating the use of buffer-based APIs for efficient data retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\nuint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\nuint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Memory Instances in Go\nDESCRIPTION: Shows how to create a memory instance with a specified page limit, set and get byte data at specific offsets, check the page size, and grow the memory. Includes error handling for operations exceeding memory bounds.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Using Specialized Module Instances in WasmEdge (WASI and Process)\nDESCRIPTION: Example showing how to create and use specialized module instances like WASI and WasmEdge_Process, and register them with a VM context for execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt = WasmEdge_ModuleInstanceCreateWASI( /* ... ignored */ );\nWasmEdge_ModuleInstanceContext *ProcModCxt = WasmEdge_ModuleInstanceCreateWasmEdgeProcess( /* ... ignored */ );\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\nWasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\nWasmEdge_ModuleInstanceDelete(ProcModCxt);\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plugins\nDESCRIPTION: Shows how to load WasmEdge plugins from default paths and retrieve registered module instances, including both built-in and plugin modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the registered modules in the VM context,\n * includes the built-in WASI and the plug-ins.\n */\n/*\n * This API will return `NULL` if the module instance not found.\n */\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/*\n * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n * installed, because the VM context will mock and register the host\n * modules.\n */\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge VM and Loading WASM Module in Go\nDESCRIPTION: This snippet shows how to set up the WasmEdge VM, load a WASM file, and instantiate it using the bindgen library. It includes configuration of WASI and error logging.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/embed-wasm-apps-go.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n\n  // Instantiate the bindgen and vm\n  bg := bindgen.Instantiate(vm)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions with WasmEdge VM API\nDESCRIPTION: C code demonstrating how to execute a WebAssembly function directly using the WasmEdge_VMRunWasmFromFile API. This example configures a VM with WASI support, loads a Fibonacci WASM file, and executes the 'fib' function with parameter 5.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRunWasmFromASTModule()` API.\n   */\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Redis Connection and Data Operations in Rust\nDESCRIPTION: Main program demonstrating Redis connection setup, writing current timestamp, and reading it back using async/await pattern with tokio runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/redis_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<()> {\n    // connect to redis\n    let client = redis::Client::open(&*get_url()).unwrap();\n    let mut con = client.get_multiplexed_async_connection().await.unwrap();\n\n    let time = format!(\"{}\", chrono::Utc::now());\n    // throw away the result, just make sure it does not fail\n    let _: () = con.set(\"current_time\", time).await.unwrap();\n\n    // read back the key and return it.  Because the return value\n    // from the function is a result for String, this will automatically\n    // convert into one.\n    let value: String = con.get(\"current_time\").await.unwrap();\n    println!(\"Successfully GET `time`: {}\", value);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a JavaScript Object API in Rust\nDESCRIPTION: Rust code defining a function that can be used as a method on a JavaScript object. It implements the JsFn trait and processes both function arguments and the 'this' context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn rust_new_object_and_js_call(ctx: &mut Context) {\n  struct ObjectFn;\n  impl JsFn for ObjectFn {\n    fn call(_ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue {\n      println!(\"hello from rust\");\n      println!(\"argv={:?}\", argv);\n      if let JsValue::Object(obj) = this_val {\n        let obj_map = obj.to_map();\n        println!(\"this={:#?}\", obj_map);\n      }\n      JsValue::UnDefined\n    }\n  }\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Module Instances - WasmEdge C\nDESCRIPTION: Details how to create a WasmEdge module instance and add various host instances like functions, tables, memories, and globals. It ensures proper naming and export management, moving the ownership of instances to the module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String HostName = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_ModuleInstanceContext *HostMod =\n    WasmEdge_ModuleInstanceCreate(HostName);\nWasmEdge_StringDelete(HostName);\n```\n\nLANGUAGE: c\nCODE:\n```\n/* Add the host function created above with the export name \"add\". */\nHostName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\nWasmEdge_StringDelete(HostName);\n\n/* Add the table created above with the export name \"table\". */\nHostName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostMod, HostName, HostTable);\nWasmEdge_StringDelete(HostName);\n\n/* Add the memory created above with the export name \"memory\". */\nHostName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostMod, HostName, HostMemory);\nWasmEdge_StringDelete(HostName);\n\n/* Add the global created above with the export name \"global_i32\". */\nHostName = WasmEdge_StringCreateByCString(\"global_i32\");\nWasmEdge_ModuleInstanceAddGlobal(HostMod, HostName, HostGlobal);\nWasmEdge_StringDelete(HostName);\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Module in C for WasmEdge\nDESCRIPTION: This C code implements host functions to be used with WasmEdge. It includes setting up functions like `ExternSquare`, `ExternAdd`, and `ExternMul`, which are registered into the WasmEdge runtime. These host functions interact with WebAssembly instances by handling `externref` values, enabling operations like addition, multiplication, and squaring. Ensure WasmEdge SDK and necessary headers are installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n\n#include <stdio.h>\n\nuint32_t SquareFunc(uint32_t A) { return A * A; }\nuint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }\nuint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }\n\n// Host function to call `SquareFunc` by external reference\nWasmEdge_Result ExternSquare(void *Data,\n                             const WasmEdge_CallingFrameContext *CallFrameCxt,\n                             const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32} -> {i32}\n  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n\n// Host function to call `AddFunc` by external reference\nWasmEdge_Result ExternAdd(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32, i32} -> {i32}\n  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n\n// Host function to call `ExternMul` by external reference\nWasmEdge_Result ExternMul(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32, i32} -> {i32}\n  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n\n// Helper function to create the \"extern_module\" module instance.\nWasmEdge_ModuleInstanceContext *CreateExternModule() {\n  WasmEdge_String HostName;\n  WasmEdge_FunctionTypeContext *HostFType = NULL;\n  WasmEdge_FunctionInstanceContext *HostFunc = NULL;\n  WasmEdge_ValType P[3], R[1];\n\n  HostName = WasmEdge_StringCreateByCString(\"extern_module\");\n  WasmEdge_ModuleInstanceContext *HostMod =\n      WasmEdge_ModuleInstanceCreate(HostName);\n  WasmEdge_StringDelete(HostName);\n\n  // Add host function \"functor_square\": {externref, i32} -> {i32}\n  P[0] = WasmEdge_ValTypeGenExternRef();\n  P[1] = WasmEdge_ValTypeGenI32();\n  R[0] = WasmEdge_ValTypeGenI32();\n  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);\n  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  HostName = WasmEdge_StringCreateByCString(\"functor_square\");\n  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\n  WasmEdge_StringDelete(HostName);\n\n  // Add host function \"class_add\": {externref, i32, i32} -> {i32}\n  P[2] = WasmEdge_ValTypeGenI32();\n  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);\n  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  HostName = WasmEdge_StringCreateByCString(\"class_add\");\n  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\n  WasmEdge_StringDelete(HostName);\n\n  // Add host function \"func_mul\": {externref, i32, i32} -> {i32}\n  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);\n  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  HostName = WasmEdge_StringCreateByCString(\"func_mul\");\n  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\n  WasmEdge_StringDelete(HostName);\n\n  return HostMod;\n}\n\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n  WasmEdge_ModuleInstanceContext *HostMod = CreateExternModule();\n  WasmEdge_Value P[3], R[1];\n  WasmEdge_String FuncName;\n  WasmEdge_Result Res;\n\n  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Host module instance registration failed\\n\");\n    return EXIT_FAILURE;\n  }\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"funcs.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM file loading failed\\n\");\n    return EXIT_FAILURE;\n  }\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM validation failed\\n\");\n    return EXIT_FAILURE;\n  }\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM instantiation failed\\n\");\n    return EXIT_FAILURE;\n  }\n\n  // Test 1: call add -- 1234 + 5678\n  P[0] = WasmEdge_ValueGenExternRef(AddFunc);\n  P[1] = WasmEdge_ValueGenI32(1234);\n  P[2] = WasmEdge_ValueGenI32(5678);\n  FuncName = WasmEdge_StringCreateByCString(\"call_add\");\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Test 1 -- `call_add` -- 1234 + 5678 = %d\\n\",\n           WasmEdge_ValueGetI32(R[0]));\n  } else {\n    printf(\"Test 1 -- `call_add` -- 1234 + 5678 -- failed\\n\");\n    return EXIT_FAILURE;\n  }\n\n  // Test 2: call mul -- 789 * 4321\n  P[0] = WasmEdge_ValueGenExternRef(MulFunc);\n  P[1] = WasmEdge_ValueGenI32(789);\n  P[2] = WasmEdge_ValueGenI32(4321);\n  FuncName = WasmEdge_StringCreateByCString(\"call_mul\");\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Test 2 -- `call_mul` -- 789 * 4321 = %d\\n\",\n           WasmEdge_ValueGetI32(R[0]));\n  } else {\n    printf(\"Test 2 -- `call_mul` -- 789 * 4321 -- failed\\n\");\n    return EXIT_FAILURE;\n  }\n\n  // Test 3: call square -- 8256^2\n  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);\n  P[1] = WasmEdge_ValueGenI32(8256);\n  FuncName = WasmEdge_StringCreateByCString(\"call_square\");\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Test 3 -- `call_mul` -- 8256 ^ 2 = %d\\n\",\n           WasmEdge_ValueGetI32(R[0]));\n  } else {\n    printf(\"Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\\n\");\n    return EXIT_FAILURE;\n  }\n\n  return EXIT_SUCCESS;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with External Data in WasmEdge\nDESCRIPTION: Complete C implementation showing how to set up a WasmEdge VM with a host function that has access to external data. The example demonstrates registering a module with a host function that performs addition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                     const WasmEdge_CallingFrameContext *CallFrameCxt,\n                     const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                     0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                     /* Type section */\n                     0x01, 0x07, 0x01,\n                     /* function type {i32, i32} -> {i32} */\n                     0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                     /* Import section */\n                     0x02, 0x13, 0x01,\n                     /* module name: \"extern\" */\n                     0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                     /* extern name: \"func-add\" */\n                     0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                     /* import desc: func 0 */\n                     0x00, 0x00,\n                     /* Function section */\n                     0x03, 0x02, 0x01, 0x00,\n                     /* Export section */\n                     0x07, 0x0A, 0x01,\n                     /* export name: \"addTwo\" */\n                     0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                     /* export desc: func 0 */\n                     0x00, 0x01,\n                     /* Code section */\n                     0x0A, 0x0A, 0x01,\n                     /* code body */\n                     0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* The external data object: an integer. */\n  int32_t Data;\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                         WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                               WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  printf(\"Data value: %d\\n\", Data);\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Plug-ins and Registering Host Modules in WasmEdge C\nDESCRIPTION: This snippet shows how to load plug-ins from default paths in the WasmEdge environment, create a configuration context for the WASI host module, and demonstrate the registration and retrieval of modules from the VM context, including mock registrations for uninstalled plugins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the registered modules in the VM context,\n * includes the built-in WASI and the plug-ins.\n */\n/*\n * This API will return `NULL` if the module instance not found.\n */\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/*\n * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n * installed, because the VM context will mock and register the host\n * modules.\n */\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Basic Asynchronous WASM Function Execution\nDESCRIPTION: Example demonstrating how to asynchronously execute a WASM function using WasmEdge-go SDK. Shows loading and running a Fibonacci calculation from a WASM file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function with Data Access in WasmEdge C\nDESCRIPTION: Example showing how to create a host function that accesses host data. The function prints a double value passed as host data and demonstrates proper type creation and function instance initialization.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result PrintData(void *Data,\n                          const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {} -> {} */\n  printf(\"Data: %lf\\n\", *(double *)Data);\n  return WasmEdge_Result_Success;\n}\n\n/* The host data. */\ndouble Number = 0.0f;\n\n/* Create a function type: {} -> {}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(NULL, 0, NULL, 0);\n/* Create a function context with the function type and host function body. */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, &PrintData, (void *)(&Number), 0);\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAssembly Proposals and Host Registrations\nDESCRIPTION: Demonstrates how to create a configuration object, add or remove proposals, and manage host registrations for WasmEdge runtime\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Passing and Handling a Functor via ExternRef in C++\nDESCRIPTION: This code demonstrates passing a C++ functor to a WASM module as an externref using the WasmEdge C++ API. A functor struct is defined, passed to the WASM instance, and operated upon using a host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nstruct SquareStruct {\n  uint32_t operator()(uint32_t Val) const { return Val * Val; }\n};\n\nSquareStruct SS;\n\nWasmEdge_Value P[2], R[1];\nP[0] = WasmEdge_ValueGenExternRef(&SS);\nP[1] = WasmEdge_ValueGenI32(1024);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"call_square\");\nWasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  std::cout << \"Result : \" << WasmEdge_ValueGetI32(R[0]) << std::endl;\n} else {\n  return EXIT_FAILURE;\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nWasmEdge_Result ExternSquare(void *, const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32, i32} -> {i32}\n  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);\n  SquareStruct &Obj = *reinterpret_cast<SquareStruct *>(Ptr);\n  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Instantiating WASM Modules from Buffer in WasmEdge\nDESCRIPTION: This code snippet shows how to register a WASM module from a buffer, instantiate another WASM module from a file, and execute functions from both modules using the WasmEdge VM context. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* The `lib.wasm` buffer example. */\n  /* Developers can also load the buffer from file. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Function section */\n                    0x03, 0x03, 0x02, 0x00, 0x00,\n                    /* Export section */\n                    0x07, 0x0D, 0x02,\n                    /* export function: \"add\" */\n                    0x03, 0x61, 0x64, 0x64, 0x00, 0x00,\n                    /* export function: \"mul\" */\n                    0x03, 0x6D, 0x75, 0x6C, 0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x11, 0x02,\n                    /* \"add\" code body */\n                    0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6A, 0x0B,\n                    /* \"mul\" code body */\n                    0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6C, 0x0B};\n\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* Register the `lib.wasm` from the buffer with the module name \"math\". */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_VMRegisterModuleFromBuffer(VMCxt, ModuleName, WASM,\n                                            sizeof(WASM));\n  WasmEdge_StringDelete(ModuleName);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Register lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Instantiate the `test.wasm`. */\n  /*\n   * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to\n   * instantiate and execute quickly.\n   */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"test.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Load test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Validate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Instantiate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Invoke the functions. */\n  /* Invoke the \"add_and_square\" to calculate (123 + 456)^2 */\n  WasmEdge_String FuncName =\n      WasmEdge_StringCreateByCString(\"add_and_square\");\n  Params[0] = WasmEdge_ValueGenI32(123);\n  Params[1] = WasmEdge_ValueGenI32(456);\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '(%d + %d)^2' result: %d\\n\", 123, 456,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'add_and_square' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n  /* Invoke the \"sum_of_squares\" to calculate (77^2 + 88^2) */\n  FuncName = WasmEdge_StringCreateByCString(\"sum_of_squares\");\n  Params[0] = WasmEdge_ValueGenI32(77);\n  Params[1] = WasmEdge_ValueGenI32(88);\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '%d^2 + %d^2' result: %d\\n\", 77, 88,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'sum_of_squares' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a WASM file in WasmEdge\nDESCRIPTION: This snippet shows how to register a WASM file in a WasmEdge VM. It creates a new `VM` object, registers the WASM file with a module name, and then releases the VM object. The function `RegisterWasmFile` takes the module name and the file path as arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\n```go\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  // The result status should be checked. The error will occur if the\n  // WASM module instantiation failed or the module name conflicts.\n\n  vm.Release()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Executing WASM with ExternRef using WasmEdge C API\nDESCRIPTION: This C code shows how to set up a WasmEdge VM, load a WASM module, and execute a function that uses externref as a parameter.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *HostMod = /* Ignored ... */;\nWasmEdge_Value P[3], R[1];\nWasmEdge_String FuncName;\nWasmEdge_Result Res;\n\nRes = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Import object registration failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMLoadWasmFromFile(VMCxt, \"funcs.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM file loading failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMValidate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM validation failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMInstantiate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed\\n\");\n  return EXIT_FAILURE;\n}\n\nP[0] = WasmEdge_ValueGenExternRef(AddFunc);\nP[1] = WasmEdge_ValueGenI32(1234);\nP[2] = WasmEdge_ValueGenI32(5678);\nFuncName = WasmEdge_StringCreateByCString(\"call_add\");\nRes = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Run -- `call_add` -- 1234 + 5678 = %d\\n\",\n          WasmEdge_ValueGetI32(R[0]));\n} else {\n  printf(\"Run -- `call_add` -- 1234 + 5678 -- failed\\n\");\n  return EXIT_FAILURE;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function in C\nDESCRIPTION: Demonstrates the implementation of an 'add' host function that takes two i32 parameters and returns their sum. This function can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  * Developers should take care about the function type.\n  */\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Function\nDESCRIPTION: Example of accessing memory instance from calling frame context in a host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%lu]: %lu\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Instantiation in C\nDESCRIPTION: C implementation showing step-by-step WASM module loading, validation, instantiation, and execution using WasmEdge VM Context. This example computes the 10th Fibonacci number using a more detailed approach.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Execute WASM functions */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in C\nDESCRIPTION: This code snippet shows how to register an existing Module instance into the store, exporting its module name. It's useful for registering host function modules for linking. The snippet includes creating necessary contexts and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the\n * module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in WasmEdge\nDESCRIPTION: Shows how to register an existing Module instance with exported module name into the store for linking. Useful when working with host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Host Function Usage in WasmEdge-go\nDESCRIPTION: A full example demonstrating how to create a VM, define a host function, create an import object, and execute a WebAssembly module using the host function in WasmEdge-go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the import object with the module name \"extern\".\n  impobj := wasmedge.NewImportObject(\"extern\")\n\n  // Create and add a function instance into the import object with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impobj.AddFunction(\"func-add\", hostfunc)\n\n  // Register the import object into VM.\n  vm.RegisterImport(impobj)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impobj.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module as a Named Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate and register an AST module context into the Store context as a named Module instance using the Executor API. This allows the module to be exported with a given name and linked when instantiating other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/*\n * Register the WASM module into the store with the export module name\n * \"mod\".\n */\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Embedding a Full WASI Program in Golang with WasmEdge\nDESCRIPTION: This example demonstrates how to embed a standalone WASI WebAssembly application into a Golang program using WasmEdge. It sets up the VM, configures WASI, and executes the main function of the WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n\n  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)\n  conf.AddConfig(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportObject(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:.\"},  // The mapping directories\n  )\n\n  // Instantiate and run WASM \"_start\" function, which refers to the main() function\n  vm.RunWasmFile(os.Args[1], \"_start\")\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader Context in C\nDESCRIPTION: Example demonstrating how to use the WasmEdge Loader context to load WebAssembly modules from files or memory buffers. The Loader supports both standard WASM and compiled-WASM from the WasmEdge AOT Compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Manual WASM Function Instantiation and Execution\nDESCRIPTION: Shows step-by-step process of loading, validating, instantiating, and executing a WASM module asynchronously using VM context APIs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting with Timeout for Asynchronous Execution in WasmEdge\nDESCRIPTION: Shows how to wait for an asynchronous execution with a time limit and handle timeout scenarios. The code demonstrates using WasmEdge_AsyncWaitFor to limit waiting time and provides handling for both successful completion and timeouts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge QuickJS Server for React SSR\nDESCRIPTION: JavaScript code for the server that renders the React app and handles HTTP requests. It uses WasmEdge, React, and custom WASI modules for networking and file operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport * as std from 'std';\nimport * as http from 'wasi_http';\nimport * as net from 'wasi_net';\n\nimport App from '../src/App.js';\n\nasync function handle_client(cs) {\n  print('open:', cs.peer());\n  let buffer = new http.Buffer();\n\n  while (true) {\n    try {\n      let d = await cs.read();\n      if (d == undefined || d.byteLength <= 0) {\n        return;\n      }\n      buffer.append(d);\n      let req = buffer.parseRequest();\n      if (req instanceof http.WasiRequest) {\n        handle_req(cs, req);\n        break;\n      }\n    } catch (e) {\n      print(e);\n    }\n  }\n  print('end:', cs.peer());\n}\n\nfunction enlargeArray(oldArr, newLength) {\n  let newArr = new Uint8Array(newLength);\n  oldArr && newArr.set(oldArr, 0);\n  return newArr;\n}\n\nasync function handle_req(s, req) {\n  print('uri:', req.uri);\n\n  let resp = new http.WasiResponse();\n  let content = '';\n  if (req.uri == '/') {\n    const app = ReactDOMServer.renderToString(<App />);\n    content = std.loadFile('./build/index.html');\n    content = content.replace(\n      '<div id=\"root\"></div>',\n      `<div id=\"root\">${app}</div>`,\n    );\n  } else {\n    let chunk = 1000; // Chunk size of each reading\n    let length = 0; // The whole length of the file\n    let byteArray = null; // File content as Uint8Array\n\n    // Read file into byteArray by chunk\n    let file = std.open('./build' + req.uri, 'r');\n    while (true) {\n      byteArray = enlargeArray(byteArray, length + chunk);\n      let readLen = file.read(byteArray.buffer, length, chunk);\n      length += readLen;\n      if (readLen < chunk) {\n        break;\n      }\n    }\n    content = byteArray.slice(0, length).buffer;\n    file.close();\n  }\n  let contentType = 'text/html; charset=utf-8';\n  if (req.uri.endsWith('.css')) {\n    contentType = 'text/css; charset=utf-8';\n  } else if (req.uri.endsWith('.js')) {\n    contentType = 'text/javascript; charset=utf-8';\n  } else if (req.uri.endsWith('.json')) {\n    contentType = 'text/json; charset=utf-8';\n  } else if (req.uri.endsWith('.ico')) {\n    contentType = 'image/vnd.microsoft.icon';\n  } else if (req.uri.endsWith('.png')) {\n    contentType = 'image/png';\n  }\n  resp.headers = {\n    'Content-Type': contentType,\n  };\n\n  let r = resp.encode(content);\n  s.write(r);\n}\n\nasync function server_start() {\n  print('listen 8002...');\n  try {\n    let s = new net.WasiTcpServer(8002);\n    for (var i = 0; ; i++) {\n      let cs = await s.accept();\n      handle_client(cs);\n    }\n  } catch (e) {\n    print(e);\n  }\n}\n\nserver_start();\n```\n\n----------------------------------------\n\nTITLE: Using Host Data with WasmEdge Host Functions in Go\nDESCRIPTION: Example demonstrating how to use external data with host functions in WasmEdge. This shows passing a reference to a Go variable that can be modified by the host function when called from WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_77\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Also set the result to the data.\n  *data.(*int32) = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // The additional data to set into the host function.\n  var data int32 = 0\n\n  // Create the module instance with the module name \"extern\".\n  modinst := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\n  functype.Release()\n  modinst.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(modinst)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  fmt.Println(\"Data value:\", data)\n\n  modinst.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding JavaScript in Rust Program\nDESCRIPTION: Rust code that evaluates JavaScript code in a QuickJS context. It creates a Context object and runs a simple JavaScript print statement.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn js_hello(ctx: &mut Context) {\n    println!(\"\\n<----run_simple_js---->\");\n    let code = r#\"print('hello quickjs')\"#;\n    let r = ctx.eval_global_str(code);\n    println!(\"return value:{:?}\", r);\n}\n\n... ...\n\nfn main() {\n    let mut ctx = Context::new();\n    js_hello(&mut ctx);\n    ... ...\n}\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Host Data Example\nDESCRIPTION: This example shows how to use host data with WasmEdge functions. A pointer to external data is passed to the function instance creation, allowing the host function to access and modify this data during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_75\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                       const WasmEdge_CallingFrameContext *CallFrameCxt,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing AST Module to WASM Binary in C\nDESCRIPTION: Demonstrates how to serialize an AST Module back into WASM binary format using the Loader context, with proper error handling and resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\nWasmEdbe_Bytes Bytes;\nRes = WasmEdge_LoaderSerializeASTModule(LoadCxt, ASTCxt, &Bytes);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Serialization failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\nWasmEdge_BytesDelete(Bytes);\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Function Using WasmEdge VM API in C\nDESCRIPTION: C code demonstrating how to use the WasmEdge VM API to load and execute a WebAssembly function from a file. It sets up the VM context, runs the 'fib' function with an input of 5, and prints the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.\n   */\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Function from Buffer in WasmEdge\nDESCRIPTION: Calls the 'addTwo' function from the WebAssembly binary buffer with parameters 1234 and 5678. The function returns the sum of these values after processing through the imported host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_80\n\nLANGUAGE: c\nCODE:\n```\n/* The parameters and returns arrays. */\nWasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                            WasmEdge_ValueGenI32(5678)};\nWasmEdge_Value Returns[1];\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n/* Run the WASM function from buffer. */\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nprintf(\"Data value: %d\\n\", Data);\n\n/* Resources deallocations. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StringDelete(FuncName);\nWasmEdge_ModuleInstanceDelete(HostModCxt);\nreturn 0;\n```\n\n----------------------------------------\n\nTITLE: Managing Table Instances in WasmEdge Go\nDESCRIPTION: Shows how to create, manipulate and manage table instances including setting limits, accessing data, and growing table size. Demonstrates error handling for out of bounds access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI in WasmEdge\nDESCRIPTION: This snippet shows how to configure a WasmEdge VM to use WASI. It creates a new `Configure` object with the `wasmedge.WASI` option, creates a `VM` with that configuration, retrieves the WASI import module, initializes WASI, and then releases the VM and configuration objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\n```go\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasimodule := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasimodule.InitWasi(/* ... ignored */)\n\nvm.Release()\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASI Module Instance in C\nDESCRIPTION: Shows how to create a WASI module instance, register it with a VM context, and retrieve the exit code after execution using WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_81\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in C\nDESCRIPTION: Shows how to query and work with imports and exports from an AST Module context, including buffer management and iteration through import/export types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n}\n\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\n```\n\n----------------------------------------\n\nTITLE: Registering and Calling a Rust Function from JavaScript\nDESCRIPTION: Rust code showing how to add a Rust function to the JavaScript interpreter, name it as 'hi()' in the JavaScript API, and call it from JavaScript code with arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn run_rust_function(ctx: &mut Context) {\n  ...\n\n  let f = ctx.new_function::<HelloFn>(\"hello\");\n  ctx.get_global().set(\"hi\", f.into());\n  let code = r#\"hi(1,2,3)\"#;\n  let r = ctx.eval_global_str(code);\n  println!(\"return value:{:?}\", r);\n}\n\n... ...\n\nfn main() {\n    let mut ctx = Context::new();\n    run_rust_function(&mut ctx);\n    ... ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering Host Module with ExternRef Functions in C\nDESCRIPTION: This C code demonstrates how to create a module instance, add host functions that use externref, and register it with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String HostName = WasmEdge_StringCreateByCString(\"extern_module\");\nWasmEdge_ModuleInstanceContext *HostMod =\n    WasmEdge_ModuleInstanceCreate(HostName);\nWasmEdge_StringDelete(HostName);\n\nWasmEdge_ValType P[3], R[1];\nP[0] = WasmEdge_ValTypeGenExternRef();\nP[1] = WasmEdge_ValTypeGenI32();\nP[2] = WasmEdge_ValTypeGenI32();\nR[0] = WasmEdge_ValTypeGenI32();\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(P, 3, R, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nHostName = WasmEdge_StringCreateByCString(\"func_mul\");\nWasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\nWasmEdge_StringDelete(HostName);\n```\n\n----------------------------------------\n\nTITLE: Manual Instantiation and Asynchronous Execution of WASM Functions in C\nDESCRIPTION: This snippet demonstrates a step-by-step approach to load, validate, instantiate, and asynchronously execute a WASM module using the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBytes()` API, or from `WasmEdge_ASTModuleContext`\n   * object with the `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Module with Host Function in C\nDESCRIPTION: Creates a WasmEdge VM context, loads a WASM module from a byte array, registers a host function, and executes a WASM function. The host function adds two integers and stores the result in external data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_84\n\nLANGUAGE: C\nCODE:\n```\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {...};\n\n  /* The external data object: an integer. */\n  int32_t Data;\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                   WasmEdge_ValTypeGenI32()};\n  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from memory. */\n  WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName,\n                                                    Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  printf(\"Data value: %d\\n\", Data);\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Execution Results in WasmEdge-Go\nDESCRIPTION: Demonstrates error handling and result processing from WasmEdge-Go function executions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\nres, err = vm.Execute(...) // Ignore the detail of parameters.\n// Assume that `res, err` are the return values for executing a function with `vm`.\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n  category := err.GetErrorCategory()\n  // The `category` will be `wasmedge.ErrCategory_WASM`.\n}\n\nuserdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)\n// Generate the user-defined error with code.\ncode := userdef_err.GetCode()\n// The `Code` will be 123456.\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Global Instances (C)\nDESCRIPTION: Demonstrates the creation of Global instances, setting and getting values, and retrieving global types. It also shows how to handle different value types and mutability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nenum WasmEdge_Mutability ValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions Step-by-Step with WasmEdge Go SDK\nDESCRIPTION: Go code showing how to execute WebAssembly functions manually step-by-step using the WasmEdge Go SDK. It demonstrates loading, validating, instantiating, and executing a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Functions from Module using Go\nDESCRIPTION: This snippet describes the process of invoking functions from the registered or instantiated Module instance using the Executor. Developers can retrieve exported Function instances for invocation after module registration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_63\n\nLANGUAGE: go\nCODE:\n```\n// More details and specific code for invoking functions can be found in the documentation.\n// Please refer to the relevant sections about Module instances and Promise APIs.\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM\nDESCRIPTION: Shows how to enable WASI (WebAssembly System Interface) support in a WasmEdge VM configuration and retrieve the built-in registered module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the built-in registered module instances from the VM object.\n// This API will return `nil` if the corresponding configuration is not set when creating the VM object.\nwasiconf := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasiconf.InitWasi(/* ... ignored */)\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Executing Math Functions in WasmEdge VM\nDESCRIPTION: Demonstrates executing WebAssembly math functions 'add_and_square' and 'sum_of_squares' using the WasmEdge VM. Shows function invocation, parameter passing, and result handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add_and_square\");\nParams[0] = WasmEdge_ValueGenI32(123);\nParams[1] = WasmEdge_ValueGenI32(456);\nRes = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the '(%d + %d)^2' result: %d\\n\", 123, 456,\n         WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Execute 'add_and_square' error: %s\\n\",\n         WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Table Instances in Go\nDESCRIPTION: Demonstrates creating a table instance with a specified type and limit, retrieving its type information, setting and getting data, checking the table size, and growing the table. Includes error handling for operations exceeding bounds.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Global Instances in Go\nDESCRIPTION: Demonstrates creating a global instance with a specified type and initial value, retrieving its type information and mutability, getting and setting values. Shows proper resource management with Release() calls.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Qdrant Vector Database Operations Example\nDESCRIPTION: Complete example demonstrating vector database operations including creating collections, upserting points, searching vectors, and deleting points using the qdrant_rest_client.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/qdrant_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    let client = qdrant::Qdrant::new();\n    // Create a collection with 10-dimensional vectors\n    let r = client.create_collection(\"my_test\", 4).await;\n    println!(\"Create collection result is {:?}\", r);\n\n    let mut points = Vec::<Point>::new();\n    points.push(Point {\n        id: PointId::Num(1),\n        vector: vec![0.05, 0.61, 0.76, 0.74],\n        payload: json!({\"city\": \"Berlin\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(2),\n        vector: vec![0.19, 0.81, 0.75, 0.11],\n        payload: json!({\"city\": \"London\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(3),\n        vector: vec![0.36, 0.55, 0.47, 0.94],\n        payload: json!({\"city\": \"Moscow\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(4),\n        vector: vec![0.18, 0.01, 0.85, 0.80],\n        payload: json!({\"city\": \"New York\"})\n            .as_object()\n            .map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(5),\n        vector: vec![0.24, 0.18, 0.22, 0.44],\n        payload: json!({\"city\": \"Beijing\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(6),\n        vector: vec![0.35, 0.08, 0.11, 0.44],\n        payload: json!({\"city\": \"Mumbai\"}).as_object().map(|m| m.to_owned()),\n    });\n\n    let r = client.upsert_points(\"my_test\", points).await;\n    println!(\"Upsert points result is {:?}\", r);\n\n    println!(\n        \"The collection size is {}\",\n        client.collection_info(\"my_test\").await\n    );\n\n    let p = client.get_point(\"my_test\", 2).await;\n    println!(\"The second point is {:?}\", p);\n\n    let ps = client.get_points(\"my_test\", vec![1, 2, 3, 4, 5, 6]).await;\n    println!(\"The 1-6 points are {:?}\", ps);\n\n    let q = vec![0.2, 0.1, 0.9, 0.7];\n    let r = client.search_points(\"my_test\", q, 2, None).await;\n    println!(\"Search result points are {:?}\", r);\n\n    let r = client.delete_points(\"my_test\", vec![1, 4]).await;\n    println!(\"Delete points result is {:?}\", r);\n\n    println!(\n        \"The collection size is {}\",\n        client.collection_info(\"my_test\").await\n    );\n\n    let q = vec![0.2, 0.1, 0.9, 0.7];\n    let r = client.search_points(\"my_test\", q, 2, None).await;\n    println!(\"Search result points are {:?}\", r);\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Table Instance Management in Go\nDESCRIPTION: Demonstrates table instance creation, data manipulation, and size management in WasmEdge. Includes examples of setting/getting data and growing table size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_68\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Constructing a Module Instance with Host Instances in WasmEdge\nDESCRIPTION: Complete example of creating a module instance and adding function, table, memory, and global instances with their export names, demonstrating proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n\n/* Create and add a global instance into the module instance. */\nWasmEdge_GlobalTypeContext *HostGType =\n  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Calling TinyGo WebAssembly Function from Go\nDESCRIPTION: This Go code demonstrates how to call a TinyGo-based WebAssembly function that handles string parameters. It shows memory allocation, data copying, function execution, and memory deallocation using the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"encoding/binary\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  subject := \"WasmEdge\"\n  lengthOfSubject := len(subject)\n\n  // Allocate memory for the subject, and get a pointer to it.\n  // Include a byte for the NULL terminator we add below.\n  allocateResult, _ := vm.Execute(\"malloc\", int32(lengthOfSubject+1))\n  inputPointer := allocateResult[0].(int32)\n\n  // Write the subject into the memory.\n  mod := vm.GetActiveModule()\n  mem := mod.FindMemory(\"memory\")\n  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))\n  copy(memData, subject)\n\n  // C-string terminates by NULL.\n  memData[lengthOfSubject] = 0\n\n  // Run the `greet` function. Given the pointer to the subject.\n  greetResult, _ := vm.Execute(\"greet\", inputPointer)\n  outputPointer := greetResult[0].(int32)\n\n  memData, _ = mem.GetData(uint(outputPointer), 8)\n  resultPointer := binary.LittleEndian.Uint32(memData[:4])\n  resultLength := binary.LittleEndian.Uint32(memData[4:])\n\n  // Read the result of the `greet` function.\n  memData, _ = mem.GetData(uint(resultPointer), uint(resultLength))\n  fmt.Println(string(memData))\n\n  // Deallocate the subject, and the output.\n  vm.Execute(\"free\", inputPointer)\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Loading and Retrieving Plug-ins in WasmEdge C API\nDESCRIPTION: This code snippet shows how to load WasmEdge plug-ins from default paths, create a VM context with WASI configuration, and retrieve registered modules including built-in WASI and plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the registered modules in the VM context,\n * includes the built-in WASI and the plug-ins.\n */\n/*\n * This API will return `NULL` if the module instance not found.\n */\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/*\n * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n * installed, because the VM context will mock and register the host\n * modules.\n */\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Instance with Host Function in WasmEdge\nDESCRIPTION: Shows how to create a function type context, define a host function with appropriate parameter and return types, and create a function instance in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                     WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost\n * measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/*\n * If the function instance is __NOT__ added into a module instance context,\n * it should be deleted.\n */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge VM\nDESCRIPTION: Demonstrates how to register a WASM module from a file into a WasmEdge VM context with a specified module name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing Memory Access in Host Function\nDESCRIPTION: Example of accessing memory instance from calling frame context in a host function implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /* Get the 0th memory instance of the module of the top frame on the stack. */\n  /*\n   * Noticed that the `MemCxt` will be `NULL` if there's no memory instance in\n   * the module instance on the top frame.\n   */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plugins in C\nDESCRIPTION: Demonstrates loading WasmEdge plugins from default paths, listing loaded plugins, and creating module instances from plugins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_79\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n```\n\n----------------------------------------\n\nTITLE: Using a Rust-created Object in JavaScript\nDESCRIPTION: JavaScript code that accesses and uses a JavaScript object created in Rust. It prints object properties and calls the object's method with arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nlet code = r#\"\n  print('test_obj keys=',Object.keys(test_obj))\n  print('test_obj.a=',test_obj.a)\n  print('test_obj.b=',test_obj.b)\n  test_obj.f(1,2,3,\\\"hi\\\")\n\"#;\n\nctx.eval_global_str(code);\n```\n\n----------------------------------------\n\nTITLE: Finding a Specific WasmEdge Plugin by Name\nDESCRIPTION: Example of finding a plugin by name after loading plugins from default paths. This allows accessing specific plugin functionality, such as the WASI-crypto plugin in this example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_87\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n```\n\n----------------------------------------\n\nTITLE: C Host Module Implementation for External References\nDESCRIPTION: C implementation of host functions and module registration for handling external references in WasmEdge. Includes functions for arithmetic operations and helper functions for creating and managing the external module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n\n#include <stdio.h>\n\nuint32_t SquareFunc(uint32_t A) { return A * A; }\nuint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }\nuint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }\n\n// Host function to call `SquareFunc` by external reference\nWasmEdge_Result ExternSquare(void *Data,\n                             const WasmEdge_CallingFrameContext *CallFrameCxt,\n                             const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32} -> {i32}\n  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n\n// Host function to call `AddFunc` by external reference\nWasmEdge_Result ExternAdd(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32, i32} -> {i32}\n  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n\n// Host function to call `ExternMul` by external reference\nWasmEdge_Result ExternMul(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  // Function type: {externref, i32, i32} -> {i32}\n  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Active Module in WasmEdge\nDESCRIPTION: Demonstrates how to retrieve the active module instance from the VM context after WASM module instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Accessing WebAssembly Memory in Host Functions\nDESCRIPTION: Demonstrates how to use the calling frame context to access WebAssembly memory from a host function, including retrieving memory instances and reading data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /*\n   * Get the 0-th memory instance of the module instance of the top frame on\n   * stack.\n   */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%lu]: %lu\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions\nDESCRIPTION: Example of accessing WebAssembly memory from a host function using the calling frame.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_64\n\nLANGUAGE: go\nCODE:\n```\nfunc LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // Function type: {i32} -> {}\n  offset := params[0].(int32)\n\n  // Get the 0th memory instance of the module of the top frame on the stack.\n  mem := callframe.GetMemoryByIndex(0)\n\n  data, err := mem.GetData(uint(offset), 4)\n  if err != nil {\n    return nil, err\n  }\n  fmt.Println(\"u32 at memory[{}]: {}\", offset, binary.LittleEndian.Uint32(data))\n  return nil, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Table Instance Operations in Go\nDESCRIPTION: Demonstrates creation and manipulation of table instances, including setting data, getting data, and growing table size with proper error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Using Value Types with Function and Table Types in WasmEdge-Go v0.14.0\nDESCRIPTION: Illustrates the updated approach for creating function types and table types using the new ValType struct in WasmEdge-Go version 0.14.0. It shows how to create and check value types for function parameters, return values, and table references.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i64, funcref} -> {f32}\nfunctype := wasmedge.NewFunctionType(\n    []*wasmedge.ValType{\n        wasmedge.NewValTypeI32(),\n        wasmedge.NewValTypeI64(),\n        wasmedge.NewValTypeFuncRef(),\n    },\n    []*wasmedge.ValType{\n        wasmedge.NewValTypeF32,\n    })\n\n// Get the parameter types\nvar ptypes []*wasmedge.ValType = functype.GetParameters()\nif ptypes[0].IsI32() {\n    // This will be true here.\n    // ...\n} \nfunctype.Release()\n\n// Create a table type: {min: 1}, externref\nlim := wasmedge.NewLimit(1)\ntabtype := wasmedge.NewTableType(wasmedge.NewValTypeExternRef(), lim)\n\n// Get the reference type\nif tabtype.GetRefType().IsExternRef() {\n    // This will be true here.\n    // ...\n}\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Table Instance Management in WasmEdge\nDESCRIPTION: Demonstrates creation and manipulation of table instances, including setting/getting data and growing table size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);\nWasmEdge_TableTypeDelete(TabTypeCxt);\n/* Additional table operations... */\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance using Go\nDESCRIPTION: This snippet showcases how to register an existing Module instance into the store and export its module name using the Executor API. It is particularly focused on modules created for host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Create a module instance for host functions.\nmod := wasmedge.NewModule(\"mod\")\n// ...\n// Create and add the host functions, tables, memories, and globals into the module instance.\n// ...\n\n// Register the module instance into store with the exported module name.\n// The export module name is in the module instance already.\nres := executor.RegisterImport(store, mod)\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\n// ...\n\n// Resources deallocations.\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Addition Host Function in Go for WasmEdge\nDESCRIPTION: Demonstrates the implementation of a host function that adds two 32-bit integers. The function follows the required signature and returns the result as an interface slice.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_72\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with ExternRef - C\nDESCRIPTION: This C code shows how to implement a host function that uses externref to access a function pointer. The host function retrieves the externref, casts it to a function pointer, and calls the pointed function. It also demonstrates adding host functions to a WasmEdge module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/* Function to pass as function pointer. */\nuint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }\n\n/* Host function to call the function by external reference as a function pointer */\nWasmEdge_Result ExternMul(void *, const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {externref, i32, i32} -> {i32} */\n  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;\n  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\nLANGUAGE: c\nCODE:\n```\n/* Create a module instance. */\nWasmEdge_String HostName = WasmEdge_StringCreateByCString(\"extern_module\");\nWasmEdge_ModuleInstanceContext *HostMod =\n    WasmEdge_ModuleInstanceCreate(HostName);\nWasmEdge_StringDelete(HostName);\n\n/* Create a function instance and add to the module instance. */\nWasmEdge_ValType P[3], R[1];\nP[0] = WasmEdge_ValTypeGenExternRef();\nP[1] = WasmEdge_ValTypeGenI32();\nP[2] = WasmEdge_ValTypeGenI32();\nR[0] = WasmEdge_ValTypeGenI32();\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(P, 3, R, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nHostName = WasmEdge_StringCreateByCString(\"func_mul\");\nWasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\nWasmEdge_StringDelete(HostName);\n```\n\n----------------------------------------\n\nTITLE: Memory Instance Management (C)\nDESCRIPTION: Illustrates memory instance creation and management, including data access, memory growth, and page size operations. Shows how to work with memory limits and handle memory access errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Binding Rust Function to WasmEdge\nDESCRIPTION: This Rust code snippet demonstrates the use of the `#[wasmedge-bindgen]` macro to bind a Rust function that takes a string and returns a vector of bytes. The function concatenates 'hello ' with the input string and returns it as a byte vector. This function will be compiled into WASM, transforming the input and output to be compliant with simple WASM data types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/bindgen.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\"use wasmedge_bindgen::*;\\nuse wasmedge_bindgen_macro::*;\\n\\n#[wasmedge_bindgen]\\npub fn say(s: String) -> Result<Vec<u8>, String> {\\n  let r = String::from(\\\"hello \\\"\");\\n  return Ok((r + s.as_str()).as_bytes().to_vec());\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Invoking WasmEdge AOT Compiler CLI from Go\nDESCRIPTION: Shows how to use the RunWasmEdgeAOTCompilerCLI function to invoke the WasmEdge AOT compiler (equivalent to 'wasmedge compile' command) from a Go application. This allows ahead-of-time compilation of WebAssembly modules directly from Go code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_79\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP POST Request Using Reqwest\nDESCRIPTION: Example of making an HTTP POST request using the reqwest library in Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    let client = reqwest::Client::new();\n\n    let res = client\n        .post(\"http://eu.httpbin.org/post\")\n        .body(\"msg=WasmEdge\")\n        .send()\n        .await?;\n    let body = res.text().await?;\n\n    println!(\"POST: {}\", body);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge QuickJS Server for React SSR\nDESCRIPTION: JavaScript code for a server that renders React components server-side using WasmEdge and QuickJS. It handles HTTP requests, renders the React app, and serves static files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport * as std from 'std';\nimport * as http from 'wasi_http';\nimport * as net from 'wasi_net';\n\nimport App from '../src/App.js';\n\nasync function handle_client(cs) {\n  print('open:', cs.peer());\n  let buffer = new http.Buffer();\n\n  while (true) {\n    try {\n      let d = await cs.read();\n      if (d == undefined || d.byteLength <= 0) {\n        return;\n      }\n      buffer.append(d);\n      let req = buffer.parseRequest();\n      if (req instanceof http.WasiRequest) {\n        handle_req(cs, req);\n        break;\n      }\n    } catch (e) {\n      print(e);\n    }\n  }\n  print('end:', cs.peer());\n}\n\nfunction enlargeArray(oldArr, newLength) {\n  let newArr = new Uint8Array(newLength);\n  oldArr && newArr.set(oldArr, 0);\n  return newArr;\n}\n\nasync function handle_req(s, req) {\n  print('uri:', req.uri);\n\n  let resp = new http.WasiResponse();\n  let content = '';\n  if (req.uri == '/') {\n    const app = ReactDOMServer.renderToString(<App />);\n    content = std.loadFile('./build/index.html');\n    content = content.replace(\n      '<div id=\"root\"></div>',\n      `<div id=\"root\">${app}</div>`,\n    );\n  } else {\n    let chunk = 1000; // Chunk size of each reading\n    let length = 0; // The whole length of the file\n    let byteArray = null; // File content as Uint8Array\n\n    // Read file into byteArray by chunk\n    let file = std.open('./build' + req.uri, 'r');\n    while (true) {\n      byteArray = enlargeArray(byteArray, length + chunk);\n      let readLen = file.read(byteArray.buffer, length, chunk);\n      length += readLen;\n      if (readLen < chunk) {\n        break;\n      }\n    }\n    content = byteArray.slice(0, length).buffer;\n    file.close();\n  }\n  let contentType = 'text/html; charset=utf-8';\n  if (req.uri.endsWith('.css')) {\n    contentType = 'text/css; charset=utf-8';\n  } else if (req.uri.endsWith('.js')) {\n    contentType = 'text/javascript; charset=utf-8';\n  } else if (req.uri.endsWith('.json')) {\n    contentType = 'text/json; charset=utf-8';\n  } else if (req.uri.endsWith('.ico')) {\n    contentType = 'image/vnd.microsoft.icon';\n  } else if (req.uri.endsWith('.png')) {\n    contentType = 'image/png';\n  }\n  resp.headers = {\n    'Content-Type': contentType,\n  };\n\n  let r = resp.encode(content);\n  s.write(r);\n}\n\nasync function server_start() {\n  print('listen 8002...');\n  try {\n    let s = new net.WasiTcpServer(8002);\n    for (var i = 0; ; i++) {\n      let cs = await s.accept();\n      handle_client(cs);\n    }\n  } catch (e) {\n    print(e);\n  }\n}\n\nserver_start();\n```\n\n----------------------------------------\n\nTITLE: Implementing Memory Management and Fibonacci Functions in Rust for WebAssembly\nDESCRIPTION: This Rust code defines functions for memory allocation, deallocation, and Fibonacci sequence generation. It includes two main functions: 'fib_array' which takes a pointer and fills it with a Fibonacci sequence, and 'fib_array_return_memory' which returns a pointer to a Fibonacci sequence.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem;\nuse std::os::raw::{c_void, c_int};\n\n#[no_mangle]\npub extern fn allocate(size: usize) -> *mut c_void {\n  let mut buffer = Vec::with_capacity(size);\n  let pointer = buffer.as_mut_ptr();\n  mem::forget(buffer);\n\n  pointer as *mut c_void\n}\n\n#[no_mangle]\npub extern fn deallocate(pointer: *mut c_void, capacity: usize) {\n  unsafe {\n    let _ = Vec::from_raw_parts(pointer, 0, capacity);\n  }\n}\n\n#[no_mangle]\npub extern fn fib_array(n: i32, p: *mut c_int) -> i32 {\n  unsafe {\n    let mut arr = Vec::<i32>::from_raw_parts(p, 0, (4*n) as usize);\n    for i in 0..n {\n      if i < 2 {\n        arr.push(i);\n      } else {\n        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);\n      }\n    }\n    let r = arr[(n - 1) as usize];\n    mem::forget(arr);\n    r\n  }\n}\n\n#[no_mangle]\npub extern fn fib_array_return_memory(n: i32) -> *mut c_int {\n  let mut arr = Vec::with_capacity((4 * n) as usize);\n  let pointer = arr.as_mut_ptr();\n  for i in 0..n {\n    if i < 2 {\n      arr.push(i);\n    } else {\n      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);\n    }\n  }\n  mem::forget(arr);\n  pointer\n}\n```\n\n----------------------------------------\n\nTITLE: Digital Signatures with Ed25519 in Rust using WASI-Crypto\nDESCRIPTION: This example shows how to generate an Ed25519 key pair, sign a message, and verify the signature using the WASI-crypto API in Rust. It showcases `SignatureKeyPair::generate`, `kp.sign`, and `kp.publickey()?.signature_verify`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasicrypto.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet pk = SignaturePublicKey::from_raw(\"Ed25519\", &[0; 32])?;\n\nlet kp = SignatureKeyPair::generate(\"Ed25519\")?;\nlet signature = kp.sign(\"hello\")?;\n\nkp.publickey()?.signature_verify(\"hello\", &signature)?;\n```\n\n----------------------------------------\n\nTITLE: Quick WASM Function Execution in Go\nDESCRIPTION: Example demonstrating rapid execution of WebAssembly functions using WasmEdge VM. Shows configuration setup, VM creation, and function execution with error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_31\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types in WasmEdge C API\nDESCRIPTION: Shows how to retrieve a function type by its name from a VM context. The function type can be used to examine the function's signature including parameters and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Using a Rust-implemented JavaScript Class\nDESCRIPTION: Rust code that initializes a Rust module as a JavaScript module and runs JavaScript code that imports and uses the module to create Point objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_quickjs::*;\nfn main() {\n  let mut ctx = Context::new();\n  point::init_point_module(&mut ctx);\n\n  let code = r#\"\n    import('point').then((point)=>{\n    let p0 = new point.Point(1,2)\n    print(\\\"js->\\\",p0.x,p0.y)\n    p0.pprint()\n    try{\n      let p = new point.Point()\n      print(\\\"js-> p:\\\",p)\n      print(\\\"js->\\\",p.x,p.y)\n      p.x=2\n      p.pprint()\n    } catch(e) {\n      print(\\\"An error has been caught\\\");\n      print(e)\n    }\n    })\n  \"#;\n\n  ctx.eval_global_str(code);\n  ctx.promise_loop_poll();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering an Import Object in WasmEdge Go SDK\nDESCRIPTION: This code snippet demonstrates how to create an import object with a custom host function, register it with a WasmEdge VM, and execute a WebAssembly function that calls the imported function. It includes function type definition and result handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_64\n\nLANGUAGE: go\nCODE:\n```\n// The additional data to set into the host function.\nvar data int32 = 0\n\n// Create the import object with the module name \"extern\".\nimpobj := wasmedge.NewImportObject(\"extern\")\n\n// Create and add a function instance into the import object with export name \"func-add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\nfunctype.Release()\nimpobj.AddFunction(\"func-add\", hostfunc)\n\n// Register the import object into VM.\nvm.RegisterImport(impobj)\n\nres, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\nif err == nil {\n  fmt.Println(\"Get the result:\", res[0].(int32))\n} else {\n  fmt.Println(\"Error message:\", err.Error())\n}\nfmt.Println(\"Data value:\", data)\n\nimpobj.Release()\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge VM Store Context Management\nDESCRIPTION: These Go code snippets illustrate how to manage the Store context within a WasmEdge VM.  The first snippet shows the scenario where the VM owns the Store and it should not be released separately. The second snippet demonstrates how to create a VM with a pre-existing Store, where the developer is responsible for managing the Store's lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nstore := vm.GetStore()\n// The object should __NOT__ be deleted by calling `(*Store).Release`.\nvm.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvm := wasmedge.NewVMWithStore(store)\n\nstoremock := vm.GetStore()\n// The internal store context of the `store` and the `storemock` are the same.\n\nvm.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge Store Context in C\nDESCRIPTION: This snippet demonstrates how to create a WasmEdge Store context, list registered WASM modules, and find a named module. It includes error handling and proper memory management for module names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Native Integration in C\nDESCRIPTION: C code demonstrating how to initialize WasmEdge VM, register modules, and execute WASM functions using the WasmEdge C API with TensorFlow Lite and image processing capabilities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/ndk.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <wasmedge/wasmedge-image.h>\n#include <wasmedge/wasmedge-tensorflowlite.h>\n\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n  /*\n   * argv[0]: ./a.out\n   * argv[1]: WASM file\n   * argv[2]: tflite model file\n   * argv[3]: image file\n   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n   */\n\n  /* Create the VM context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n  WasmEdge_ConfigureDelete(ConfCxt);\n\n  /* Create the image and TFLite import objects. */\n  WasmEdge_ModuleInstanceContext *ImageImpObj = WasmEdge_Image_ModuleInstanceCreate();\n  WasmEdge_ModuleInstanceContext *TFLiteImpObj = WasmEdge_TensorflowLite_ModuleInstanceCreate();\n  WasmEdge_ModuleInstanceContext *TFDummyImpObj = WasmEdge_Tensorflow_ModuleInstanceCreateDummy();\n\n  /* Register into VM. */\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);\n\n  /* Init WASI. */\n  const char *Preopens[] = {\".:.\"};\n  const char *Args[] = {argv[1], argv[2], argv[3]};\n  WasmEdge_ModuleInstanceContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_ModuleInstanceInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);\n\n  /* Run WASM file. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"_start\");\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);\n  WasmEdge_StringDelete(FuncName);\n\n  /* Check the result. */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Run WASM failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  WasmEdge_ModuleInstanceDelete(ImageImpObj);\n  WasmEdge_ModuleInstanceDelete(TFLiteImpObj);\n  WasmEdge_ModuleInstanceDelete(TFDummyImpObj);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Registering AST as Module using Go\nDESCRIPTION: This code snippet demonstrates how to instantiate and register an AST object as a named Module instance using the Executor APIs. It highlights the creation of the statistics and executor objects before registering a loaded WASM AST into the Store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Register the loaded WASM `ast` into store with the export module name \"mod\".\nmod, res := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\n// ...\n\n// Resources deallocations.\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types by Name in C\nDESCRIPTION: Demonstrates retrieving function type information by function name from the VM context. This allows inspection of parameter and return types for WASM functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function in Go\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module Instance in Go\nDESCRIPTION: Shows how to instantiate and register an AST object as a named Module instance using the Executor. Creates necessary objects like Statistics and Store, performs the registration, and handles cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, res := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Function Context Creation in C\nDESCRIPTION: Example of creating a function context with a host function body and function type definition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                         WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost\n * measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/*\n * If the function instance is __NOT__ added into a module instance context,\n * it should be deleted.\n */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Implementing TensorFlow Lite Inference in Rust with WasmEdge\nDESCRIPTION: Rust function for image classification using WasmEdge TensorFlow Lite plug-in and wasmedge_bindgen for parameter passing. It loads an image, processes it, and runs inference using a TensorFlow Lite model.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/ai.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasmedge_bindgen]\nfn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {\n  let img = image::load_from_memory(&image_data).unwrap().to_rgb8();\n  let flat_img = image::imageops::thumbnail(&img, 192, 192);\n\n  let model_data: &[u8] = include_bytes!(\"lite-model_aiy_vision_classifier_food_V1_1.tflite\");\n  let labels = include_str!(\"aiy_food_V1_labelmap.txt\");\n\n  let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(model_data);\n  session.add_input(\"input\", &flat_img).run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Softmax\");\n  ... ...\n}\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in WasmEdge-go\nDESCRIPTION: Shows how to analyze a loaded WASM module's structure by listing its imports and exports. This helps determine what a module provides and what it requires from the host environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\nast := ...\n// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.\n\n// List the imports.\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\n// List the exports.\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Serializing AST Module to WASM Binary in C\nDESCRIPTION: Demonstrates how to serialize an AST Module context back into a WASM binary format using the Loader context. Includes serialization process and proper handling of the resulting byte array.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\nWasmEdge_LoaderContext *LoadCxt = ...;\n/* Assume that a loader context is created with configuration. */\n\nWasmEdbe_Bytes Bytes;\n/* Serialize the AST module back into WASM binary format. */\nRes = WasmEdge_LoaderSerializeASTModule(LoadCxt, ASTCxt, &Bytes);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Serialization failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\n/* The output WasmEdge_Bytes should be destroyed. */\nWasmEdge_BytesDelete(Bytes);\n```\n\n----------------------------------------\n\nTITLE: Using Externref in WASM Module with WasmEdge\nDESCRIPTION: This WASM module defines functions that import host functions with `externref` parameters, allowing interactions between WASM and host environment. It requires a host module with functions like `functor_square`, `class_add`, and `func_mul`. The module exports functions such as `call_add`, `call_mul`, and `call_square` to perform operations using host references.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_0\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param externref i32) (result i32)))\n  (type $t1 (func (param externref i32 i32) (result i32)))\n  (type $t2 (func (param externref externref i32 i32) (result i32)))\n  (import \"extern_module\" \"functor_square\" (func $functor_square (type $t0)))\n  (import \"extern_module\" \"class_add\" (func $class_add (type $t1)))\n  (import \"extern_module\" \"func_mul\" (func $func_mul (type $t1)))\n  (func $call_add (export \"call_add\") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)\n    (call $class_add\n      (local.get $p0)\n      (local.get $p1)\n      (local.get $p2)))\n  (func $call_mul (export \"call_mul\") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)\n    (call $func_mul\n      (local.get $p0)\n      (local.get $p1)\n      (local.get $p2)))\n  (func $call_square (export \"call_square\") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)\n    (call $functor_square\n      (local.get $p0)\n      (local.get $p1)))\n  (func $call_add_square (export \"call_add_square\") (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)\n    (call $functor_square\n      (local.get $p1)\n      (call $class_add\n        (local.get $p0)\n        (local.get $p2)\n        (local.get $p3))))\n  (memory $memory (export \"memory\") 1))\n```\n\n----------------------------------------\n\nTITLE: JavaScript Handler for AWS Lambda Using WasmEdge with TensorFlow\nDESCRIPTION: JavaScript code for an AWS Lambda handler that uses WasmEdge runtime with TensorFlow Lite support. The code spawns a WasmEdge process, runs the compiled WebAssembly module as a shared object, and passes the uploaded image data via standard input. The response from the WebAssembly program is collected and returned.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nfunction _runWasm(reqBody) {\n  return new Promise(resolve => {\n    const wasmedge = spawn(\n      path.join(__dirname, 'wasmedge-tensorflow-lite'),\n      [path.join(__dirname, 'classify.so')],\n      {env: {'LD_LIBRARY_PATH': __dirname}}\n    );\n\n    let d = [];\n    wasmedge.stdout.on('data', (data) => {\n      d.push(data);\n    });\n\n    wasmedge.on('close', (code) => {\n      resolve(d.join(''));\n    });\n\n    wasmedge.stdin.write(reqBody);\n    wasmedge.stdin.end('');\n  });\n}\n\nexports.handler = ... // _runWasm(reqBody) is called in the handler\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions\nDESCRIPTION: Example C code demonstrating implementation of host functions for adding and subtracting integers in a WasmEdge plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n\n/* The host function definitions. */\n\n/* The host function to add 2 int32_t numbers. */\nWasmEdge_Result HostFuncAdd(void *Data,\n                            const WasmEdge_CallingFrameContext *CallFrameCxt,\n                            const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* The host function to sub 2 int32_t numbers. */\nWasmEdge_Result HostFuncSub(void *Data,\n                            const WasmEdge_CallingFrameContext *CallFrameCxt,\n                            const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 - Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Function and Handling Results in WasmEdge C API\nDESCRIPTION: This snippet shows how to prepare function parameters, execute a WASM function from a buffer, and handle the result. It calls the 'addTwo' function from the WASM module with parameters 1234 and 5678, then processes the return value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\n/* The parameters and returns arrays. */\nWasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };\nWasmEdge_Value Returns[1];\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n/* Run the WASM function from buffer. */\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n  VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\n/* Resources deallocations. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StringDelete(FuncName);\nWasmEdge_ModuleInstanceDelete(HostModCxt);\nreturn 0;\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Execution of WASM Functions in WasmEdge\nDESCRIPTION: Illustrates asynchronous execution of WASM functions using the WasmEdge VM API. It covers creating an async task, waiting for completion, and retrieving results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator Context\nDESCRIPTION: Shows how to use the WasmEdge Validator context to validate WASM modules before instantiation. It includes error handling and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Instantiating an AST Module to an Anonymous Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate a WebAssembly AST module into an anonymous Module instance using the Executor API. This is necessary before invoking functions from the module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Calling TinyGo Functions from Go with WasmEdge\nDESCRIPTION: This Go code utilizes the WasmEdge SDK to load and execute a WebAssembly module compiled from TinyGo.  It calls `malloc` to allocate memory, then calls `fibArray` and `fibArrayReturnMemory` to generate Fibonacci sequences. The code then retrieves the generated data from the WasmEdge VM memory and frees the allocated memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"unsafe\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  n := int32(10)\n\n  p, err := vm.Execute(\"malloc\", n)\n  if err != nil {\n    fmt.Println(\"malloc failed:\", err)\n  }\n\n  fib, err := vm.Execute(\"fibArray\", n, p[0])\n  if err != nil {\n    fmt.Println(\"fibArray failed:\", err)\n  } else {\n    fmt.Println(\"fibArray() returned:\", fib[0])\n    fmt.Printf(\"fibArray memory at: %p\\n\", unsafe.Pointer((uintptr)(p[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))\n      if err == nil && fibArray != nil {\n        fmt.Println(\"fibArray:\", fibArray)\n      }\n    }\n  }\n\n  fibP, err := vm.Execute(\"fibArrayReturnMemory\", n)\n  if err != nil {\n    fmt.Println(\"fibArrayReturnMemory failed:\", err)\n  } else {\n    fmt.Printf(\"fibArrayReturnMemory memory at: %p\\n\", unsafe.Pointer((uintptr)(fibP[0].(int32))))\n    mod := vm.GetActiveModule()\n    mem := mod.FindMemory(\"memory\")\n    if mem != nil {\n      // int32 occupies 4 bytes\n      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))\n      if err == nil && fibArrayReturnMemory != nil {\n        fmt.Println(\"fibArrayReturnMemory:\", fibArrayReturnMemory)\n      }\n    }\n  }\n\n  _, err = vm.Execute(\"free\", p...)\n  if err != nil {\n    fmt.Println(\"free failed:\", err)\n  }\n\n  exitcode := wasi.WasiGetExitCode()\n  if exitcode != 0 {\n    fmt.Println(\"Go: Running wasm failed, exit code:\", exitcode)\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Instance Management in WasmEdge\nDESCRIPTION: Shows how to create and manage memory instances, including data access and page size management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\n/* Additional memory operations... */\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Runtime CLI Tool in C\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C API to invoke the WasmEdge runtime CLI tool. It replicates the functionality of the 'wasmedge run' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_92\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Functions in Rust with wasmedge_bindgen\nDESCRIPTION: This Rust code defines several functions using the wasmedge_bindgen macro to handle complex data types and operations. It includes functions for creating geometric objects, string manipulation, mathematical operations, and cryptographic hashing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/function.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse num_integer::lcm;\nuse serde::{Deserialize, Serialize};\nuse sha3::{Digest, Keccak256, Sha3_256};\n#[allow(unused_imports)]\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: f32,\n    y: f32,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n    points: Vec<Point>,\n    valid: bool,\n    length: f32,\n    desc: String,\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> String {\n    let point1: Point = serde_json::from_str(&p1).unwrap();\n    let point2: Point = serde_json::from_str(&p2).unwrap();\n    let length = ((point1.x - point2.x) * (point1.x - point2.x)\n        + (point1.y - point2.y) * (point1.y - point2.y))\n        .sqrt();\n\n    let valid = if length == 0.0 { false } else { true };\n\n    let line = Line {\n        points: vec![point1, point2],\n        valid: valid,\n        length: length,\n        desc: desc,\n    };\n\n    return serde_json::to_string(&line).unwrap();\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> String {\n    let r = String::from(\"hello \");\n    return r + &s;\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> String {\n    (&s).chars()\n        .map(|c| match c {\n            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,\n            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,\n            _ => c,\n        })\n        .collect()\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> i32 {\n    let r = lcm(a, b);\n    return r;\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {\n    return Sha3_256::digest(&v).as_slice().to_vec();\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {\n    return Keccak256::digest(&s).as_slice().to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Store Context Management in WasmEdge C\nDESCRIPTION: These C snippets demonstrate how to manage Store contexts in WasmEdge. Developers can create a VM context with or without a Store context, which is necessary for keeping runtime module information. The lifecycle of the Store context should be handled appropriately if created externally. Dependencies include the WasmEdge library. This setup is used when developers need access to runtime instances and manage the context lifecycle manually.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\\nWasmEdge_VMDelete(VMCxt);\\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple HTTP Client in Rust for WasmEdge\nDESCRIPTION: Rust code for a basic HTTP client that can perform GET and POST requests using the wasmedge_http_req crate. It demonstrates how to send requests, handle responses, and print status codes, headers, and body content.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/client.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_http_req::request;\n\nfn main() {\n  let mut writer = Vec::new(); //container for body of a response\n  let res = request::get(\"http://127.0.0.1:1234/get\", &mut writer).unwrap();\n\n  println!(\"GET\");\n  println!(\"Status: {} {}\", res.status_code(), res.reason());\n  println!(\"Headers {}\", res.headers());\n  println!(\"{}\", String::from_utf8_lossy(&writer));\n\n  let mut writer = Vec::new(); //container for body of a response\n  const BODY: &[u8; 27] = b\"field1=value1&field2=value2\";\n  // let res = request::post(\"https://httpbin.org/post\", BODY, &mut writer).unwrap();\n  // no https , no dns\n  let res = request::post(\"http://127.0.0.1:1234/post\", BODY, &mut writer).unwrap();\n\n  println!(\"POST\");\n  println!(\"Status: {} {}\", res.status_code(), res.reason());\n  println!(\"Headers {}\", res.headers());\n  println!(\"{}\", String::from_utf8_lossy(&writer));\n}\n```\n\n----------------------------------------\n\nTITLE: Host Registrations in VM Context - C\nDESCRIPTION: This snippet demonstrates the creation of a configuration context for the VM and how to manage host registrations for WASI support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n    WasmEdge_HostRegistration_Wasi = 0\n};\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step Async WASM Execution in C\nDESCRIPTION: Shows manual step-by-step WASM module loading, validation, instantiation, and asynchronous execution using WasmEdge C API. Includes error handling for each phase.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing VM Components in WasmEdge Using Go\nDESCRIPTION: Illustrates how to access internal components like `Loader`, `Validator`, and `Executor` in a WasmEdge VM from Go. These components are retrieved for extended operations but should not be released manually by the developer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\nloader := vm.GetLoader()\n// Developers should __NOT__ call the `(*Loader).Release` function of the returned object.\nvalidator := vm.GetValidator()\n// Developers should __NOT__ call the `(*Validator).Release` function of the returned object.\nexecutor := vm.GetExecutor()\n// Developers should __NOT__ call the `(*Executor).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Functions with Go Bindgen\nDESCRIPTION: Go code demonstrating how to use wasmedge-bindgen to execute WebAssembly functions. Shows initialization of WasmEdge VM, loading WASM module, and calling various bound functions with different parameter types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportObject(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n  bg := bindgen.Instantiate(vm)\n  // Function calls...\n  bg.Release()\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Memory Instance in WasmEdge C API\nDESCRIPTION: This code snippet demonstrates how to create a memory type with specified limits, create a memory instance, and add it to a module instance. It shows memory size configuration with minimum and maximum page limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n    WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASI Module Instance in WasmEdge\nDESCRIPTION: This snippet shows how to create a WASI module instance, register it with a VM context, and retrieve the exit code after execution. It demonstrates the pattern for using specialized module instances in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_79\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals - C\nDESCRIPTION: This snippet defines the WasmEdge proposals enum and shows how to create a configuration context, add and remove proposals, and check if certain proposals are enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n    WasmEdge_Proposal_ImportExportMutGlobals = 0,\n    WasmEdge_Proposal_NonTrapFloatToIntConversions,\n    WasmEdge_Proposal_SignExtensionOperators,\n    WasmEdge_Proposal_MultiValue,\n    WasmEdge_Proposal_BulkMemoryOperations,\n    WasmEdge_Proposal_ReferenceTypes,\n    WasmEdge_Proposal_SIMD,\n    WasmEdge_Proposal_TailCall,\n    WasmEdge_Proposal_MultiMemories,\n    WasmEdge_Proposal_Annotations,\n    WasmEdge_Proposal_Memory64,\n    WasmEdge_Proposal_ExceptionHandling,\n    WasmEdge_Proposal_ExtendedConst,\n    WasmEdge_Proposal_Threads,\n    WasmEdge_Proposal_FunctionReferences\n};\n```\n\nLANGUAGE: c\nCODE:\n```\n/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n *\n * For the current WasmEdge version, the following proposals are supported\n * (turned off by default) additionally:\n * * Tail-call\n * * Multiple memories\n * * Extended-const\n * * Threads\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge Strings\nDESCRIPTION: Demonstrates creating WasmEdge_String objects from C strings and buffers, including proper memory management with deletion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Managing Store Object in Go\nDESCRIPTION: Demonstrates the usage of Store object for managing WebAssembly runtime state, including listing registered modules and finding named modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_55\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n\nmodnames := store.ListModule()\n\nmod := store.FindModule(\"module\")\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: The snippet describes configuring AOT compiler options like optimization levels and output formats using WasmEdge, useful for performance tuning of compiled WebAssembly. It requires the WasmEdge Go SDK to function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_23\n\nLANGUAGE: Go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\nLANGUAGE: Go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the optimization level is O3.\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n// By default, the output format is universal WASM.\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n// By default, the dump IR is `false`.\nconf.SetCompilerDumpIR(true)\n// By default, the generic binary is `false`.\nconf.SetCompilerGenericBinary(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing a TCP Client in JavaScript\nDESCRIPTION: JavaScript function that creates a TCP client connection to the server, sends a message, and receives the echoed response. It uses WasmEdge's WasiTcpConn API for the connection.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nasync function connect_test() {\n  try {\n    let ss = await net.WasiTcpConn.connect('127.0.0.1:8000');\n    ss.write('hello');\n    let msg = (await ss.read()) || '';\n    print('client recv:', new TextDecoder().decode(msg));\n  } catch (e) {\n    print('client catch:', e);\n  } finally {\n    nextTick(() => {\n      exit(0);\n    });\n  }\n}\n\nconnect_test();\n```\n\n----------------------------------------\n\nTITLE: Accessing WasmEdge Components from VM\nDESCRIPTION: This Go code snippet demonstrates how to access the individual components of a WasmEdge VM: the Loader, Validator, and Executor. It gets these components directly from the VM instance. Note that the user should not release those instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\nloader := vm.GetLoader()\n// Developers should __NOT__ call the `(*Loader).Release` function of the returned object.\nvalidator := vm.GetValidator()\n// Developers should __NOT__ call the `(*Validator).Release` function of the returned object.\nexecutor := vm.GetExecutor()\n// Developers should __NOT__ call the `(*Executor).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function using CallingFrame in WasmEdge Go\nDESCRIPTION: Shows how to use the CallingFrame object to access memory in a host function. It retrieves a memory instance and reads data from it, demonstrating memory interaction in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"encoding/binary\"\n  \"fmt\"\n)\n\n// Host function body definition.\nfunc LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // Function type: {i32} -> {}\n  offset := params[0].(int32)\n\n  // Get the 0th memory instance of the module of the top frame on the stack.\n  mem := callframe.GetMemoryByIndex(0)\n\n  data, err := mem.GetData(uint(offset), 4)\n  if err != nil {\n    return nil, err\n  }\n  fmt.Println(\"u32 at memory[{}]: {}\", offset, binary.LittleEndian.Uint32(data))\n  return nil, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge Version Information\nDESCRIPTION: This C code snippet demonstrates how to retrieve and print the WasmEdge version and its components (major, minor, patch). It utilizes the `WasmEdge_VersionGet()`, `WasmEdge_VersionGetMajor()`, `WasmEdge_VersionGetMinor()`, and `WasmEdge_VersionGetPatch()` functions from the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n\"#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\"\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge VM\nDESCRIPTION: Demonstrates how to register a WASM module with an exported module name using the WasmEdge VM API. It includes creating a VM context, registering a module from a file, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing Registered WASM Function\nDESCRIPTION: This snippet shows how to execute a registered WASM function in a WasmEdge VM. It creates a new `VM` object, registers the WASM file with a module name, executes the function with specified arguments, and then releases the VM object. The `ExecuteRegistered` function takes the module name, function name, and function arguments as arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\n```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  // Register the WASM module from file into VM with the module name \"mod\".\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n  // The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n  // name \"mod\". As the same as host functions, other modules can import the\n  // function `\"mod\" \"fib\"`.\n\n  // Execute WASM functions in registered modules.\n  // Unlike the execution of functions, the registered functions can be\n  // invoked without `(*VM).Instantiate` because the WASM module was\n  // instantiated when registering.\n  // Developers can also invoke the host functions directly with this API.\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Working with Function Instances in WasmEdge Go\nDESCRIPTION: Shows how to retrieve a function type from a function object. This is useful for working with host functions in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_64\n\nLANGUAGE: go\nCODE:\n```\nfuncobj := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the module instance should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n\n// For the function object creation, please refer to the `Host Function` guide.\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Table Type Context in C\nDESCRIPTION: Shows how to create a Table Type context with specific limits and reference type, and how to query information from it. This is used for table instance creation and information retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Table Instances (C)\nDESCRIPTION: Illustrates the creation of table instances, setting and getting data, growing the table, and proper cleanup. It also demonstrates error handling for out-of-bounds access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(TabTypeCxt);\nWasmEdge_TableTypeDelete(TabTypeCxt);\n\nWasmEdge_Value Data = WasmEdge_ValueGenFuncRef(5);\nWasmEdge_Result Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in C\nDESCRIPTION: Shows how to register an existing Module instance into the Store context, exporting its module name. This is useful for registering host function modules for linking. Includes context creation, module registration, and resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the\n * module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Instantiating Anonymous Module Instance in Go\nDESCRIPTION: Shows how to instantiate a WASM module as an anonymous Module instance. Includes setup of required objects and error handling for the instantiation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_53\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, err := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Import Object with Host Function in Go\nDESCRIPTION: Demonstrates how to create an import object with a host function in Go using WasmEdge SDK. The code shows initialization of function types, creating host functions with data context, and registering the import object with a VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\n// The additional data to set into the host function.\nvar data int32 = 0\n\n// Create the import object with the module name \"extern\".\nimpobj := wasmedge.NewImportObject(\"extern\")\n\n// Create and add a function instance into the import object with export name \"func-add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\nfunctype.Release()\nimpobj.AddFunction(\"func-add\", hostfunc)\n\n// Register the import object into VM.\nvm.RegisterImport(impobj)\n\nres, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\nif err == nil {\n  fmt.Println(\"Get the result:\", res[0].(int32))\n} else {\n  fmt.Println(\"Error message:\", err.Error())\n}\nfmt.Println(\"Data value:\", data)\n\nimpobj.Release()\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Timed Async Execution with Cancellation in C\nDESCRIPTION: Shows how to wait for an asynchronous execution with a time limit, and optionally cancel the execution if it exceeds the specified duration\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge VM Context in C\nDESCRIPTION: C code demonstrating the creation and management of WasmEdge VM context, including configuration, store, and statistics contexts. It shows how to create, retrieve, and properly delete these contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/* The VM context already contains the statistics context and can be retrieved by this API. */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs\n * should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Exporting Functions in WebAssembly Library Module\nDESCRIPTION: This WebAssembly module exports two functions: 'add' for adding two numbers and 'mul' for multiplying two numbers. These functions can be imported by other WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_0\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (func (export \"add\") (param i32 i32) (result i32)\n    ;; Function to add 2 numbers and exported as \"add\".\n    (i32.add (local.get 0) (local.get 1))\n  )\n  (func (export \"mul\") (param i32 i32) (result i32)\n    ;; Function to mul 2 number and exported as \"mul\".\n    (i32.mul (local.get 0) (local.get 1))\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions in WASM Using WasmEdge in Go\nDESCRIPTION: Shows how to list exported functions from a loaded and instantiated WASM module in Go using WasmEdge. It involves loading and validating a WASM file, followed by obtaining function names and types for invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous HTTP POST Request in JavaScript\nDESCRIPTION: JavaScript code demonstrating an asynchronous HTTP POST request using the fetch API. This example shows how to send data in the request body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nasync function test_fetch_post() {\n  try {\n    let r = await fetch('http://httpbin.org/post', {\n      method: 'post',\n      body: 'post_body',\n    });\n    print('test_fetch_post\\n', await r.text());\n  } catch (e) {\n    print(e);\n  }\n}\ntest_fetch_post();\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Loader Context Usage\nDESCRIPTION: Example demonstrating the use of Loader context to load WASM modules from files or buffers. Shows proper context creation, loading operations, and cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\nuint32_t FileSize = ...;\n\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Main TCP Server Implementation\nDESCRIPTION: Main server implementation using WasmEdge WASI socket for TCP connection handling and request processing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::Write;\nuse wasmedge_wasi_socket::{Shutdown, TcpListener};\n\nmod handler;\nmod mime;\nmod response;\n\nfn main() {\n    let server = TcpListener::bind(\"127.0.0.1:3000\", false).unwrap();\n    println!(\"Server listening on 127.0.0.1:3000\");\n\n    loop {\n        let (mut stream, addr) = server.accept(0).unwrap();\n        println!(\"Accepted connection from {}\", addr);\n        match handler::handle_req(&mut stream, addr) {\n            Ok((res, binary)) => {\n                let res: String = res.into();\n                let bytes = res.as_bytes();\n                stream.write_all(bytes).unwrap();\n                if let Some(binary) = binary {\n                    stream.write_all(&binary).unwrap();\n                }\n            }\n            Err(e) => {\n                println!(\"Error: {:?}\", e);\n            }\n        };\n        stream.shutdown(Shutdown::Both).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Example of registering host modules into a VM context using WASI object. Shows creation, registration, and cleanup of host module objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ImportObjectContext *WasiObject =\n  WasmEdge_ImportObjectCreateWASI( /* ... ignored ... */ );\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObject);\n/* The result status should be checked. */\nWasmEdge_ImportObjectDelete(WasiObject);\n/* The created import objects should be deleted. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Instantiating Anonymous Module in Go\nDESCRIPTION: Shows how to instantiate a WASM module as an anonymous Module instance. Creates required objects and performs instantiation after ensuring imports are registered.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, err := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Table Instance Management (C)\nDESCRIPTION: Shows how to create and manage table instances, including setting/getting data, growing table size, and checking table properties. Demonstrates table type creation and reference handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nconst WasmEdge_TableTypeContext *GotTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\nWasmEdge_ValType RefType = WasmEdge_TableTypeGetRefType(GotGlobTypeCxt);\nbool IsTypeFuncRef = WasmEdge_ValTypeIsFuncRef(RefType);\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Cloning and Building Mediapipe Application Bash\nDESCRIPTION: The snippet shows how to clone a demo project and build an inference application using Mediapipe object detection in Rust. It highlights the use of Cargo for building the project with specific target settings and subsequently compiling it into WebAssembly format using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/juntao/demo-object-detection\ncd demo-object-detection/\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\nwasmedge compile target/wasm32-wasip1/release/demo-object-detection.wasm demo-object-detection.wasm\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Modules with WasmEdge Loader\nDESCRIPTION: Demonstrates how to use the WasmEdge Loader to load WASM modules from files or buffers, supporting both WASM and compiled-WASM formats.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions using WasmEdge in C\nDESCRIPTION: This code snippet provides a method to list exported WASM functions after instantiation using WasmEdge. The example demonstrates how to load and validate a WASM module, then retrieve and print all exported function names. Developers must ensure buffer sizes are sufficient when capturing data. Dependencies include WasmEdge libraries, and the focus is on acquiring function metadata for runtime analysis.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\\n#include <stdio.h>\\nint main() {\\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\\n\\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\\n  WasmEdge_VMValidate(VMCxt);\\n  WasmEdge_VMInstantiate(VMCxt);\\n\\n  /* List the exported functions. */\\n  /* Get the number of exported functions. */\\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\\n  /* Create the name buffers and the function type buffers. */\\n  const uint32_t BUF_LEN = 256;\\n  WasmEdge_String FuncNames[BUF_LEN];\\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\\n  /*\\n   * Get the export function list.\\n   * If the function list length is larger than the buffer length, the overflowed data will be discarded.\\n   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.\\n   */\\n  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\\n\\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\\n    char Buf[BUF_LEN];\\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\\n    /*\\n     * The function names should be __NOT__ destroyed.\\n     * The returned function type contexts should __NOT__ be destroyed.\\n     */\\n  }\\n  return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Instantiation and Asynchronous Execution in WasmEdge VM\nDESCRIPTION: Demonstrates step-by-step manual instantiation and asynchronous execution of WASM functions using the WasmEdge VM API. It covers loading, validating, instantiating, and executing a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Example of registering host modules into a WasmEdge VM object, including WASI host modules. Shows proper resource management with Release() calls.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)\n\nres := vm.RegisterModule(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in C\nDESCRIPTION: This C code snippet illustrates how to limit the page size of memory instances in WasmEdge.  It retrieves the default maximum memory page size, sets a new maximum, and retrieves the updated maximum. This configuration is effective in the Executor and VM contexts. Exceeding the limit during WASM execution will cause the page growing to fail.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/*\n * Limit the memory size of each memory instance with not larger than 1024\n * pages (64 MiB).\n */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly with WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C API to load, validate, instantiate, and execute a WebAssembly module. It includes creating necessary contexts, loading a WASM file, validating the module, instantiating it, and invoking a function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /* Create the store context. The store context is the object to link the modules for imports and exports. */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /* Create the executor context. The configure context and the statistics context can be NULL. */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */\n  uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf(\"Function `fib` not found.\\n\");\n    return 1;\n  }\n  /* Invoke the WASM function. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Module to AST Context in WasmEdge\nDESCRIPTION: This code snippet demonstrates loading a WASM module into an AST context, registering it with the VM, and then instantiating and executing functions from another WASM module. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* Assume that the `lib.wasm` has loaded first. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n  WasmEdge_ASTModuleContext *LibASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, \"lib.wasm\");\n  WasmEdge_LoaderDelete(LoadCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Load lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* Register the loaded AST context with the module name \"math\". */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res =\n      WasmEdge_VMRegisterModuleFromASTModule(VMCxt, ModuleName, LibASTCxt);\n  WasmEdge_StringDelete(ModuleName);\n  WasmEdge_ASTModuleDelete(LibASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Register lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Instantiate the `test.wasm`. */\n  /*\n   * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to\n   * instantiate and execute quickly.\n   */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"test.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Load test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Validate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Instantiate test.wasm error: %s\\n\",\n```\n\n----------------------------------------\n\nTITLE: Instantiating WASM Modules with Executor in WasmEdge-go\nDESCRIPTION: Demonstrates how to instantiate a WASM module using the Executor. This prepares the module for execution by creating instances of its functions, memories, tables, and globals in the store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Instantiate the WASM module.\nerr := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating VM Objects with Different Configurations in Go\nDESCRIPTION: Go code demonstrating various ways to create VM objects using different combinations of Configure and Store objects in the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Mediapipe Object Detector in Rust\nDESCRIPTION: Rust code snippet demonstrating how to create an object detector instance using the Mediapipe-rs library and a TensorFlow Lite model.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet model_data: &[u8] = include_bytes!(\"mobilenetv2_ssd_256_uint8.tflite\");\nlet detector = ObjectDetectorBuilder::new()\n        .max_results(2)\n        .build_from_buffer(model_data)?\n```\n\n----------------------------------------\n\nTITLE: Implementing an Addition Host Function in Go\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns their sum. This demonstrates parameter handling and return value construction.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Statistics Options in WasmEdge\nDESCRIPTION: This snippet covers enabling and configuring statistics options in WasmEdge for instruction and cost metrics during WebAssembly execution. It requires WasmEdge Go SDK and is effective in VM and Compiler contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_24\n\nLANGUAGE: Go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsInstructionCounting(true)\n// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsTimeMeasuring(true)\n// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsCostMeasuring(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Usage\nDESCRIPTION: Demonstrates how to use the WasmEdge AOT compiler to compile WASM files to native format for better performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  WasmEdge_Result Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\", \"fibonacci.wasm.so\");\n  if (!WasmEdge_ResultOK(Res)) {\n      printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n      return 1;\n  }\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Host Data in WebAssembly Function Calls with C\nDESCRIPTION: Illustrates how to set external data for a host function and access it within the function body when called from WebAssembly using WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_83\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n```\n\n----------------------------------------\n\nTITLE: Registering and Instantiating an AST Module in C\nDESCRIPTION: Demonstrates how to create an executor context, instantiate an AST module, and register it as a named Module instance in the Store context. The exported module can then be linked when instantiating other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/*\n * Register the WASM module into the store with the export module name\n * \"mod\".\n */\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Plug-in Host Functions and Modules in C++\nDESCRIPTION: C++ code defining the structure of a WasmEdge plug-in, including host functions, modules, and environment classes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#pragma once\n\n#include \"plugin/plugin.h\"\n\n#include <cstdint>\n#include <string>\n\nnamespace WasmEdge {\nnamespace Host {\n\n// The environment class. For the register object.\nclass WasmEdgePluginTestEnv {\npublic:\n  WasmEdgePluginTestEnv() noexcept = default;\n\n  static Plugin::PluginRegister Register;\n};\n\n// The host function base template class. For inheriting the environment class\n// reference.\ntemplate <typename T>\nclass WasmEdgePluginTestFunc : public Runtime::HostFunction<T> {\npublic:\n  WasmEdgePluginTestFunc(WasmEdgePluginTestEnv &HostEnv)\n      : Runtime::HostFunction<T>(0), Env(HostEnv) {}\n\nprotected:\n  WasmEdgePluginTestEnv &Env;\n};\n\n// The host function to add 2 int32_t numbers.\nclass WasmEdgePluginTestFuncAdd\n    : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncAdd> {\npublic:\n  WasmEdgePluginTestFuncAdd(WasmEdgePluginTestEnv &HostEnv)\n      : WasmEdgePluginTestFunc(HostEnv) {}\n  Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {\n    return A + B;\n  }\n};\n\n// The host function to sub 2 int32_t numbers.\nclass WasmEdgePluginTestFuncSub\n    : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncSub> {\npublic:\n  WasmEdgePluginTestFuncSub(WasmEdgePluginTestEnv &HostEnv)\n      : WasmEdgePluginTestFunc(HostEnv) {}\n  Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {\n    return A - B;\n  }\n};\n\n// The host module class. There can be several modules in a plug-in.\nclass WasmEdgePluginTestModule : public Runtime::Instance::ModuleInstance {\npublic:\n  WasmEdgePluginTestModule()\n      : Runtime::Instance::ModuleInstance(\"wasmedge_plugintest_cpp_module\") {\n    addHostFunc(\"add\", std::make_unique<WasmEdgePluginTestFuncAdd>(Env));\n    addHostFunc(\"sub\", std::make_unique<WasmEdgePluginTestFuncSub>(Env));\n  }\n\n  WasmEdgePluginTestEnv &getEnv() { return Env; }\n\nprivate:\n  WasmEdgePluginTestEnv Env;\n};\n\n} // namespace Host\n} // namespace WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Creating Host Function Instance in WasmEdge\nDESCRIPTION: This snippet demonstrates creating a function type context, function instance, and adding it to a module instance. The function takes two i32 parameters and returns one i32 value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                         WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step Asynchronous WASM Execution with WasmEdge C API\nDESCRIPTION: This code demonstrates a manual approach to asynchronously execute WebAssembly functions using the WasmEdge C API. It explicitly handles loading, validation, instantiation, and execution phases separately, calculating the 25th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  /*\n   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to replace the\n   * instantiated one. In this case, the old module will be cleared, but the registered\n   * modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instance Exports in C\nDESCRIPTION: Demonstrates how to list and find exported instances from a WASM module instance. Shows functions for listing export length, getting export names, and finding specific exported functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum =\n    WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt =\n    WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout for Asynchronous Execution in WasmEdge C API\nDESCRIPTION: Shows how to set a time limit for an asynchronous execution, check execution status, and handle both completion and timeout cases including cancellation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances (WasmEdge-Go >= v0.10.0)\nDESCRIPTION: This snippet demonstrates how to retrieve exported instances of named and anonymous modules in WasmEdge-Go version v0.10.0 and later.  It loads a WASM file, registers a named module, instantiates an anonymous module, and then retrieves functions from both using the module instances returned by `Register` and `Instantiate`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\n// Create the store object. The store is the object to link the modules for imports and exports.\nstore := wasmedge.NewStore()\n// Error.\nvar err error\n// AST object.\nvar ast *wasmedge.AST\n// Module instances.\nvar namedmod *wasmedge.Module\nvar anonymousmod *wasmedge.Module\n\n// Create the loader object.\nloader := wasmedge.NewLoader()\n// Create the validator object.\nvalidator := wasmedge.NewValidator()\n// Create the executor object.\nexecutor := wasmedge.NewExecutor()\n\n// Load the WASM file or the compiled-WASM file and convert into the AST object.\nast, err = loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n  return\n}\n// Validate the WASM module.\nerr = validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n  return\n}\n// Example: register and instantiate the WASM module with the module name \"module_fib\".\nnamedmod, err = executor.Register(store, ast, \"module_fib\")\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n// Example: Instantiate the WASM module and get the output module instance.\nanonymousmod, err = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n\n// Now, developers can retrieve the exported instances from the module instances.\n// Take the exported functions as example. This WASM exports the function \"fib\".\n// Find the function \"fib\" from the instantiated anonymous module.\nfunc1 := anonymousmod.FindFunction(\"fib\")\n// Find the function \"fib\" from the registered module \"module_fib\".\nfunc2 := namedmod.FindFunction(\"fib\")\n// Or developers can get the named module instance from the store:\ngotmod := store.FindModule(\"module_fib\")\nfunc3 := gotmod.FindFunction(\"fib\")\n\nnamedmod.Release()\nanonymousmod.Release()\nast.Release()\nstore.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Function with WasmEdge VM\nDESCRIPTION: Executes a WebAssembly function named 'addTwo' from a binary module loaded into memory. The function is called with two integer parameters and returns a single integer result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_76\n\nLANGUAGE: c\nCODE:\n```\n/* The parameters and returns arrays. */\nWasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                            WasmEdge_ValueGenI32(5678)};\nWasmEdge_Value Returns[1];\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n/* Run the WASM function from buffer. */\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nprintf(\"Data value: %d\\n\", Data);\n\n/* Resources deallocations. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StringDelete(FuncName);\nWasmEdge_ModuleInstanceDelete(HostModCxt);\nreturn 0;\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Registering AST Module in C\nDESCRIPTION: This snippet demonstrates how to instantiate and register an AST module as a named Module instance in the Store context using the Executor APIs. It shows the complete workflow including creating necessary contexts, registering the module with a name, and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\n/*\n* ...\n* Assume that the `ASTCxt` is the output AST module context from the loader context\n* and has passed the validation.\n* Assume that the `ConfCxt` is the configure context.\n*/\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/* Create the executor context. The configure and the statistics contexts can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/* Create the store context. The store context is the object to link the modules for imports and exports. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Register the WASM module into the store with the export module name \"mod\". */\nRes = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-NN Support in WasmEdge VM\nDESCRIPTION: Illustrates how to enable WASI-NN support in a WasmEdge VM configuration. It covers creating a configuration, adding WASI-NN registration, creating a VM, and retrieving the WASI-NN module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */\nWasmEdge_ModuleInstanceContext *NNModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Go Integration with YoMo and WasmEdge\nDESCRIPTION: Go code for integrating YoMo with WasmEdge runtime to execute the WebAssembly image classification function\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"crypto/sha1\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n  \"sync/atomic\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n  \"github.com/yomorun/yomo\"\n)\n\nvar (\n  counter uint64\n)\n\nconst ImageDataKey = 0x10\n\nfunc main() {\n  // Connect to Zipper service\n  sfn := yomo.NewStreamFunction(\"image-recognition\", yomo.WithZipperAddr(\"localhost:9900\"))\n  defer sfn.Close()\n\n  // set only monitoring data\n  sfn.SetObserveDataID(ImageDataKey)\n\n  // set handler\n  sfn.SetHandler(Handler)\n\n  // start\n  err := sfn.Connect()\n  if err != nil {\n    log.Print(\" Connect to zipper failure: \", err)\n    os.Exit(1)\n  }\n\n  select {}\n}\n\n// Handler processes the data in the stream\nfunc Handler(img []byte) (byte, []byte) {\n  // Initialize WasmEdge's VM\n  vmConf, vm := initVM()\n  bg := bindgen.Instantiate(vm)\n  defer bg.Release()\n  defer vm.Release()\n  defer vmConf.Release()\n\n  // recognize the image\n  res, err := bg.Execute(\"infer\", img)\n  if err == nil {\n    fmt.Println(\"GO: Run bindgen -- infer:\", string(res))\n  } else {\n    fmt.Println(\"GO: Run bindgen -- infer FAILED\")\n  }\n\n  // print logs\n  hash := genSha1(img)\n  log.Printf(\" received image-%d hash %v, img_size=%d \\n\", atomic.AddUint64(&counter, 1), hash, len(img))\n\n  return 0x11, nil\n}\n\n// genSha1 generate the hash value of the image\nfunc genSha1(buf []byte) string {\n  h := sha1.New()\n  h.Write(buf)\n  return fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\n// initVM initialize WasmEdge's VM\nfunc initVM() (*wasmedge.Configure, *wasmedge.VM) {\n  wasmedge.SetLogErrorLevel()\n  // Set Tensorflow not to print debug info\n  os.Setenv(\"TF_CPP_MIN_LOG_LEVEL\", \"3\")\n  os.Setenv(\"TF_CPP_MIN_VLOG_LEVEL\", \"3\")\n\n  // Create configure\n  vmConf := wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  vm := wasmedge.NewVMWithConfig(vmConf)\n\n  // Init WASI\n  var wasi = vm.GetImportObject(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping directories\n  )\n\n  // Register WasmEdge-tensorflow and WasmEdge-image\n  var tfobj = wasmedge.NewTensorflowImportObject()\n  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()\n  vm.RegisterImport(tfobj)\n  vm.RegisterImport(tfliteobj)\n  var imgobj = wasmedge.NewImageImportObject()\n  vm.RegisterImport(imgobj)\n\n  // Instantiate wasm\n  vm.LoadWasmFile(\"rust_mobilenet_food_lib.so\")\n  vm.Validate()\n\n  return vmConf, vm\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Array Functions in TinyGo\nDESCRIPTION: This TinyGo code defines two functions: `fibArray`, which accepts an integer array and populates it with a Fibonacci sequence, and `fibArrayReturnMemory`, which allocates and returns a pointer to a new array containing the Fibonacci sequence. Both functions are exported for use in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"unsafe\"\n)\n\nfunc main() {\n  println(\"in main\")\n  n := int32(10)\n  arr := make([]int32, n)\n  arrP := &arr[0]\n  fmt.Printf(\"call fibArray(%d, %p) = %d\\n\", n, arrP, fibArray(n, arrP))\n  fmt.Printf(\"call fibArrayReturnMemory(%d) return %p\\n\", n, fibArrayReturnMemory(n))\n}\n\n// export fibArray\nfunc fibArray(n int32, p *int32) int32 {\n  arr := unsafe.Slice(p, n)\n  for i := int32(0); i < n; i++ {\n    switch {\n    case i < 2:\n      arr[i] = i\n    default:\n      arr[i] = arr[i-1] + arr[i-2]\n    }\n  }\n  return arr[n-1]\n}\n\n// export fibArrayReturnMemory\nfunc fibArrayReturnMemory(n int32) *int32 {\n  arr := make([]int32, n)\n  for i := int32(0); i < n; i++ {\n    switch {\n    case i < 2:\n      arr[i] = i\n    default:\n      arr[i] = arr[i-1] + arr[i-2]\n    }\n  }\n  return &arr[0]\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Running WASM Functions in C with WasmEdge\nDESCRIPTION: This snippet demonstrates how to asynchronously execute a WebAssembly function using the WasmEdge C API. It loads a WASM file, creates a VM context, runs the function asynchronously, and retrieves the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBytes()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Execution in C\nDESCRIPTION: Demonstrates how to asynchronously execute a Fibonacci function from a WASM file using WasmEdge C API. Shows initialization, async execution, and result handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function using Calling Frame Context in C\nDESCRIPTION: Demonstrates how to use the calling frame context to access memory instances within a host function, allowing read/write operations on WebAssembly memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_75\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                             const WasmEdge_CallingFrameContext *CallFrameCxt,\n                             const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /*\n   * Get the 0-th memory instance of the module instance of the top frame on\n   * stack.\n   */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%lu]: %lu\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function with ImportObject (WasmEdge-Go < v0.10.0)\nDESCRIPTION: This snippet demonstrates how to define a host function and register it using an `ImportObject` in WasmEdge-Go versions prior to v0.10.0. It defines a simple addition function, creates an `ImportObject`, adds the function to the object, and then releases the `ImportObject`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// ...\n\n// Create an import object with the module name \"module\".\nimpobj := wasmedge.NewImportObject(\"module\")\n\n// Create and add a function instance into the import object with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n// The third parameter is the pointer to the additional data object.\n// Developers should guarantee the life cycle of the data, and it can be `nil`\n// if the external data is not needed.\nfunctype.Release()\nimpobj.AddFunction(\"add\", hostfunc)\n\n// The import object should be released.\n// Developers should __NOT__ release the instances added into the import objects.\nimpobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing userspace program for eBPF operations in C\nDESCRIPTION: Core process of a userspace program compiled to WebAssembly. It uses wasm_bpf APIs to open, load, and attach the BPF program, and poll data from the ring buffer. It demonstrates handling of BPF skeletons and ring buffer operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/bpf.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Load and verify BPF application */\n    skel = bootstrap_bpf__open();\n    if (!skel) {\n        fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n        return 1;\n    }\n\n    /* Parameterize BPF code with minimum duration parameter */\n    skel->rodata->min_duration_ns = env.min_duration_ms * 1000000ULL;\n\n    /* Load & verify BPF programs */\n    err = bootstrap_bpf__load(skel);\n    if (err) {\n        fprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n        goto cleanup;\n    }\n\n    /* Attach tracepoints */\n    err = bootstrap_bpf__attach(skel);\n    if (err) {\n        fprintf(stderr, \"Failed to attach BPF skeleton\\n\");\n        goto cleanup;\n    }\n\n    /* Set up ring buffer polling */\n    rb = bpf_buffer__open(skel->maps.rb, handle_event, NULL);\n    if (!rb) {\n        err = -1;\n        fprintf(stderr, \"Failed to create ring buffer\\n\");\n        goto cleanup;\n    }\n    /* Process events */\n    printf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n           \"PPID\", \"FILENAME/EXIT CODE\");\n    while (!exiting) {\n        // poll buffer\n        err = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n        /* Ctrl-C will cause -EINTR */\n        if (err == -EINTR) {\n            err = 0;\n            break;\n        }\n        if (err < 0) {\n            printf(\"Error polling perf buffer: %d\\n\", err);\n            break;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge VM\nDESCRIPTION: This snippet shows how to register a WebAssembly module from a file into a WasmEdge VM context. It demonstrates naming the module and handling potential errors during registration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering Modules with Executor in WasmEdge-go\nDESCRIPTION: Shows how to register WASM modules and import objects into a store using the Executor. This creates the necessary runtime environment for executing WebAssembly modules with proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Register the loaded WASM `ast` into store with the export module name \"mod\".\nres := executor.RegisterModule(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\n// Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.\nimpobj := ...\nerr = executor.RegisterImport(store, impobj)\nif err != nil {\n  fmt.Println(\"Import object registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nimpobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using MemoryType in WasmEdge Go SDK\nDESCRIPTION: Shows how to create and use MemoryType objects for defining memory instances in WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator\nDESCRIPTION: Shows how to use the WasmEdge Validator to validate WASM modules before instantiation, ensuring their correctness.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Adding Instances to Host Module\nDESCRIPTION: Example of adding function, table, memory and global instances to a host module with export names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Add the host function created above with the export name \"add\". */\nHostName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);\nWasmEdge_StringDelete(HostName);\n\n/* Add the table created above with the export name \"table\". */\nHostName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostMod, HostName, HostTable);\nWasmEdge_StringDelete(HostName);\n\n/* Add the memory created above with the export name \"memory\". */\nHostName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostMod, HostName, HostMemory);\nWasmEdge_StringDelete(HostName);\n\n/* Add the global created above with the export name \"global_i32\". */\nHostName = WasmEdge_StringCreateByCString(\"global_i32\");\nWasmEdge_ModuleInstanceAddGlobal(HostMod, HostName, HostGlobal);\nWasmEdge_StringDelete(HostName);\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Function with WasmEdge C++ SDK in AOT Mode\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C++ SDK in AOT (Ahead-of-Time) compilation mode. It creates a VM context in AOT mode, executes a WebAssembly function from a file, and handles the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c++/intro.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\nint main(int argc, const char* argv[]) {\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  wasmedge_configure_context* conf_cxt = wasmedge_configure_create();\n  wasmedge_configure_add_host_registration(conf_cxt, WASMEDGE_HOST_REGISTRATION_WASI);\n\n  // Create the VM context in AOT mode.\n  wasmedge_vm_context* vm_cxt = wasmedge_vm_create_aot(conf_cxt, NULL);\n\n  // The parameters and returns arrays.\n  wasmedge_value params[1] = { wasmedge_value_gen_i32(32) };\n  wasmedge_value returns[1];\n  // Function name.\n  wasmedge_string func_name = wasmedge_string_create_by_cstring(\"fib\");\n  // Run the WASM function from file.\n  wasmedge_result res = wasmedge_vm_run_wasm_from_file(vm_cxt, argv[1], func_name, params, 1, returns, 1);\n\n  if (wasmedge_result_ok(res)) {\n    printf(\"Get result: %d\\n\", wasmedge_value_get_i32(returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", wasmedge_result_get_message(res));\n  }\n\n  // Resources deallocations.\n  wasmedge_vm_delete(vm_cxt);\n  wasmedge_configure_delete(conf_cxt);\n  wasmedge_string_delete(func_name);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Limit Structures in Go\nDESCRIPTION: Demonstrates how to create and use Limit structures for representing minimum and maximum values, including shared memory support for thread proposals.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\nLANGUAGE: go\nCODE:\n```\nlim3 := wasmedge.NewLimitShared(20)\nfmt.Println(lim3.HasMax())\n// Will print `false`.\nfmt.Println(lim3.IsShared())\n// Will print `true`.\nfmt.Println(lim3.GetMin())\n// Will print `20`.\n\nlim4 := wasmedge.NewLimitSharedWithMax(30, 40)\nfmt.Println(lim4.HasMax())\n// Will print `true`.\nfmt.Println(lim4.IsShared())\n// Will print `true`.\nfmt.Println(lim4.GetMin())\n// Will print `30`.\nfmt.Println(lim4.GetMax())\n// Will print `40`.\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance with Host Functions\nDESCRIPTION: Example of constructing a module instance with various host instance types including functions, tables, memory, and globals.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_72\n\nLANGUAGE: go\nCODE:\n```\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the module instance with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nmod.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the module instance with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nmod.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the module instance with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nmod.AddGlobal(\"global\", hostglob)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading Model and Performing Inference (Rust)\nDESCRIPTION: Loads the PyTorch model using the `wasi_nn::GraphBuilder`, initializes the execution context, sets the input tensor, performs the computation, and retrieves the output tensor.  The `wasi_nn::GraphEncoding::Pytorch` and `wasi_nn::ExecutionTarget::CPU` specify the backend and execution target, respectively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// load model\nlet graph = wasi_nn::GraphBuilder::new(\n    wasi_nn::GraphEncoding::Pytorch,\n    wasi_nn::ExecutionTarget::CPU,\n).build_from_files([model_bin_name]).unwrap();\nlet mut context = graph.init_execution_context().unwrap();\n\n// Load a tensor that precisely matches the graph input tensor\nlet tensor_data = image_to_tensor(image_name.to_string(), 224, 224);\ncontext.set_input(0, wasi_nn::TensorType::F32, &[1, 3, 224, 224], &tensor_data).unwrap();\n\n// Execute the inference.\ncontext.compute().unwrap();\n\n// Retrieve the output.\nlet mut output_buffer = vec![0f32; 1000];\ncontext.get_output(0, &mut output_buffer).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instruction Count in C\nDESCRIPTION: This C code demonstrates how to retrieve the instruction count and instructions per second (IPS) from a `WasmEdge_StatisticsContext`. The `Statistics` context is used to collect runtime statistics during WASM execution. Before using statistics, the statistics configuration must be set.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Connecting to MySQL Database (Rust)\nDESCRIPTION: This Rust code snippet demonstrates how to connect to a MySQL database using the `mysql_async` crate. It creates a customized connection pool with specified constraints and TLS options if enabled via the `DATABASE_SSL` environment variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    // Below we create a customized connection pool\n    let opts = Opts::from_url(&*get_url()).unwrap();\n    let mut builder = OptsBuilder::from_opts(opts);\n    if std::env::var(\"DATABASE_SSL\").is_ok() {\n        builder = builder.ssl_opts(SslOpts::default());\n    }\n    // The connection pool will have a min of 5 and max of 10 connections.\n    let constraints = PoolConstraints::new(5, 10).unwrap();\n    let pool_opts = PoolOpts::default().with_constraints(constraints);\n\n    let pool = Pool::new(builder.pool_opts(pool_opts));\n    let mut conn = pool.get_conn().await.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances from Store Context in WasmEdge Pre-0.9.1\nDESCRIPTION: Demonstrates how to load a WASM module, register it with a name, instantiate it, and retrieve exported function instances from the store context in WasmEdge versions before 0.9.1. The example uses the fibonacci.wasm module and finds the exported fib function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\n/* Create the store context. The store context holds the instances. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n/* Create the executor context. The configure context and the statistics context can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Validate the WASM module. */\nRes = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: register and instantiate the WASM module with the module name \"module_fib\". */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module_fib\");\nRes = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: Instantiate the WASM module into the store context. */\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* Now, developers can retrieve the exported instances from the store. */\n/* Take the exported functions as example. This WASM exports the function \"fib\". */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FoundFuncCxt;\n/* Find the function \"fib\" from the instantiated anonymous module. */\nFoundFuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);\n/* Find the function \"fib\" from the registered module \"module_fib\". */\nModName = WasmEdge_StringCreateByCString(\"module_fib\");\nFoundFuncCxt = WasmEdge_StoreFindFunctionRegistered(StoreCxt, ModName, FuncName);\nWasmEdge_StringDelete(ModName);\nWasmEdge_StringDelete(FuncName);\n\nWasmEdge_ASTModuleDelete(ASTCxt);\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ValidatorDelete(ValidCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances from Module (WasmEdge-Go v0.10.0+)\nDESCRIPTION: This code shows the updated approach for instantiating modules and retrieving exported functions in WasmEdge-Go v0.10.0 and later. It uses Module instances to manage both named and anonymous modules and demonstrates various ways to access the exported functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\n// Create the store object. The store is the object to link the modules for imports and exports.\nstore := wasmedge.NewStore()\n// Error.\nvar err error\n// AST object.\nvar ast *wasmedge.AST\n// Module instances.\nvar namedmod *wasmedge.Module\nvar anonymousmod *wasmedge.Module\n\n// Create the loader object.\nloader := wasmedge.NewLoader()\n// Create the validator object.\nvalidator := wasmedge.NewValidator()\n// Create the executor object.\nexecutor := wasmedge.NewExecutor()\n\n// Load the WASM file or the compiled-WASM file and convert into the AST object.\nast, err = loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n  return\n}\n// Validate the WASM module.\nerr = validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n  return\n}\n// Example: register and instantiate the WASM module with the module name \"module_fib\".\nnamedmod, err = executor.Register(store, ast, \"module_fib\")\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n// Example: Instantiate the WASM module and get the output module instance.\nanonymousmod, err = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n\n// Now, developers can retrieve the exported instances from the module instances.\n// Take the exported functions as example. This WASM exports the function \"fib\".\n// Find the function \"fib\" from the instantiated anonymous module.\nfunc1 := anonymousmod.FindFunction(\"fib\")\n// Find the function \"fib\" from the registered module \"module_fib\".\nfunc2 := namedmod.FindFunction(\"fib\")\n// Or developers can get the named module instance from the store:\ngotmod := store.FindModule(\"module_fib\")\nfunc3 := gotmod.FindFunction(\"fib\")\n\nnamedmod.Release()\nanonymousmod.Release()\nast.Release()\nstore.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\n```\n\n----------------------------------------\n\nTITLE: Instantiating Modules with Executor in C\nDESCRIPTION: Shows how to instantiate a WASM module using the Executor context. It creates necessary contexts and instantiates the module, checking for errors in the process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge Host Registrations in C\nDESCRIPTION: This C code demonstrates how to configure host registrations, specifically WASI, within the WasmEdge runtime.  It creates a `WasmEdge_ConfigureContext`, checks if WASI is enabled, adds the WASI host registration, and then checks again to confirm it's enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                       WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Managing Memory Instances in Go\nDESCRIPTION: Shows how to create and manipulate memory instances including setting data, retrieving data, and managing memory pages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Host Function Type Definition in C\nDESCRIPTION: Definition of the host function signature type used for implementing custom host functions in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Getting WASM Function Types in WasmEdge\nDESCRIPTION: This Go code snippet demonstrates how to retrieve the function type of a specific function within a WasmEdge VM. It retrieves the `FunctionType` object associated with the given function name.  The important thing to note is that the return `FunctionType` object should not be released.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nfunctype := vm.GetFunctionType(\"fib\")\n// Developers can get the function types of functions in the registered modules via the\n// `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.\n// If the function is not found, these APIs will return `nil`.\n// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance with Host Data and Finalizer in C\nDESCRIPTION: Demonstrates how to create a module instance with host data and a finalizer function. This allows setting custom data that will be cleaned up when the module instance is destroyed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_85\n\nLANGUAGE: C\nCODE:\n```\n/* Struct definition. */\ntypedef struct Point {\n  int X;\n  int Y;\n} Point;\n\n/* Host function body definition. */\nWasmEdge_Result Print(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  Point *P = (Point *)In;\n  printf(\"Point: (%d, %d)\\n\", P->X, P->Y);\n  return WasmEdge_Result_Success;\n}\n\n/* Finalizer definition. */\nvoid PointFinalizer(void *Data) {\n  if (Data) {\n    free((Point *)Data);\n  }\n}\n\n/* Create a module instance with host data and its finalizer. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nPoint *Data = (Point *)malloc(sizeof(Point));\nData->X = 5;\nData->Y = -5;\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);\n/*\n* When the `HostModCxt` being destroyed, the finalizer will be invoked and the\n* `Data` will be its argument.\n*/\nWasmEdge_StringDelete(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Optimizing WasmEdge Performance with AOT Compilation\nDESCRIPTION: Commands to improve WebAssembly execution performance by using WasmEdge's Ahead-of-Time (AOT) compilation. This compiles the WebAssembly bytecode to native code before execution for better performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/go/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile hello.wasm hello.wasm\n\n$ wasmedge hello.wasm\nHello TinyGo from WasmEdge!\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile fib.wasm fib.wasm\n\n$ wasmedge --reactor fib.wasm fibArray 10\n34\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Compiler CLI Tool\nDESCRIPTION: Example showing how to use the WasmEdge_Driver_Compiler() API to implement the compiler CLI functionality, equivalent to the 'wasmedge compile' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_83\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Programs\nDESCRIPTION: Shell commands demonstrating how to compile and execute the WasmEdge runner and compiler examples, including performance comparison between interpreter and AOT modes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/intro.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test_wasmedge.c -lwasmedge -o test_wasmedge\n$ ./test_wasmedge fibonacci.wasm\nGet result: 3524578\n```\n\n----------------------------------------\n\nTITLE: Host Data Example in WasmEdge-go\nDESCRIPTION: Demonstrates how to use external data with host functions in WasmEdge-go. This example shows how to set and access an external data object in the function body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_63\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Also set the result to the data.\n  *data.(*int32) = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the import object with the module name \"extern\".\n  impobj := wasmedge.NewImportObject(\"extern\")\n\n  // Create and add a function instance into the import object with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostdata := int32(0)\n  hostfunc := wasmedge.NewFunction(functype, host_add, &hostdata, 0)\n  functype.Release()\n  impobj.AddFunction(\"func-add\", hostfunc)\n\n  // Register the import object into VM.\n  vm.RegisterImport(impobj)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n    fmt.Println(\"Data value:\", hostdata)\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impobj.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up HTTP Server for React SSR Streaming in JavaScript\nDESCRIPTION: This code sets up a non-blocking HTTP server using Node.js APIs and implements React server-side rendering with streaming. It renders the LazyHome component and pipes the rendered stream to the HTTP response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { createServer } from 'http';\n\nimport LazyHome from './component/LazyHome.jsx';\n\ncreateServer((req, res) => {\n  res.setHeader('Content-type', 'text/html; charset=utf-8');\n  renderToPipeableStream(<LazyHome />).pipe(res);\n}).listen(8001, () => {\n  print('listen 8001...');\n});\n```\n\n----------------------------------------\n\nTITLE: Memory Instance Operations in Go\nDESCRIPTION: Shows memory instance management including creation, data setting/getting, and page size manipulation with proper error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader in Go\nDESCRIPTION: Demonstrates how to use the WasmEdge Loader to load WASM modules from files or buffers. It shows the creation of a Loader object with custom configuration and loading WASM from both file and buffer sources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Handler Implementation\nDESCRIPTION: Response handler implementation for generating HTTP responses, including static file serving and server-side rendering functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::mime::MimeType;\nuse anyhow::Result;\nuse parsed::http::{Header, Response};\nuse std::fs::{read};\nuse std::path::Path;\nuse isomorphic_app::App;\n\nconst HTML_PLACEHOLDER: &str = \"#HTML_INSERTED_HERE_BY_SERVER#\";\nconst STATE_PLACEHOLDER: &str = \"#INITIAL_STATE_JSON#\";\n\npub fn ssr(path: &str, init: Option<u32>) -> Result<(Response, Option<Vec<u8>>)> {\n    let html = format!(\"{}\", include_str!(\"./index.html\"));\n\n    let app = App::new(init.unwrap_or(1001), path.to_string());\n    let state = app.store.borrow();\n\n    let html = html.replace(HTML_PLACEHOLDER, &app.render().to_string());\n    let html = html.replace(STATE_PLACEHOLDER, &state.to_json());\n\n    Ok((Response {\n        protocol: \"HTTP/1.0\".to_string(),\n        code: 200,\n        message: \"OK\".to_string(),\n        headers: vec![\n            Header {\n                name: \"content-type\".to_string(),\n                value: MimeType::from_ext(\"html\").get(),\n            },\n            Header {\n                name: \"content-length\".to_string(),\n                value: html.len().to_string(),\n            },\n        ],\n        content: html.into_bytes(),\n    }, None))\n}\n\npub fn file(path: &str) -> Result<(Response, Option<Vec<u8>>)> {\n    let path = Path::new(&path);\n    if path.exists() {\n        let content_type: MimeType = match path.extension() {\n            Some(ext) => MimeType::from_ext(ext.to_str().get_or_insert(\"\")),\n            None => MimeType::from_ext(\"\"),\n        };\n        let content = read(path)?;\n\n        Ok((Response {\n            protocol: \"HTTP/1.0\".to_string(),\n            code: 200,\n            message: \"OK\".to_string(),\n            headers: vec![\n                Header {\n                    name: \"content-type\".to_string(),\n                    value: content_type.get(),\n                },\n                Header {\n                    name: \"content-length\".to_string(),\n                    value: content.len().to_string(),\n                },\n            ],\n            content: vec![],\n        }, Some(content)))\n    } else {\n        Ok((Response {\n            protocol: \"HTTP/1.0\".to_string(),\n            code: 404,\n            message: \"Not Found\".to_string(),\n            headers: vec![],\n            content: vec![],\n        }, None))\n    }\n}\n\npub fn bad_request() -> Response {\n    Response {\n        protocol: \"HTTP/1.0\".to_string(),\n        code: 400,\n        message: \"Bad Request\".to_string(),\n        headers: vec![],\n        content: vec![],\n    }\n}\n\npub fn internal_error() -> (Response, Option<Vec<u8>>) {\n    (Response {\n        protocol: \"HTTP/1.0\".to_owned(),\n        code: 500,\n        message: \"Internal Server Error\".to_owned(),\n        headers: vec![],\n        content: vec![],\n    }, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Asynchronous WASM Function Execution in Go\nDESCRIPTION: Demonstrates how to asynchronously execute a WASM function using WasmEdge Go API. Shows initialization, execution and result handling for a Fibonacci calculation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST to Anonymous Module using Go\nDESCRIPTION: This snippet illustrates how to instantiate an AST object into an anonymous Module instance. Prior to instantiation, it emphasizes the importance of ensuring all necessary imports are registered into the Store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Instantiate the WASM module.\nmod, err := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Initializing WASM Limits in Go\nDESCRIPTION: Demonstrates creation and usage of WASM Limit structures for both standard and shared memory configurations. Shows how to create limits with and without maximum values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\n----------------------------------------\n\nTITLE: Managing Global Instances in Go\nDESCRIPTION: Demonstrates creation and manipulation of global instances including setting values and managing global types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_55\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading Plug-ins for WasmEdge\nDESCRIPTION: Demonstrates loading plug-ins in WasmEdge, configuring the VM, and retrieving registered modules. It ensures the appropriate handling of cases where required plug-ins are not installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the registered modules in the VM context,\n * includes the built-in WASI and the plug-ins.\n */\n/*\n * This API will return `NULL` if the module instance not found.\n */\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/*\n * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n * installed, because the VM context will mock and register the host\n * modules.\n */\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Using Statistics in WasmEdge for Performance Profiling\nDESCRIPTION: Example showing how to create and use a Statistics object to count instructions and measure execution performance in WasmEdge. This can be used to profile WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n// ... After running the WASM functions with the `Statistics` object\n\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-go with Multiple Extensions\nDESCRIPTION: Illustrates how to build WasmEdge-go with multiple extensions (Image and TensorFlow) enabled simultaneously.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/intro.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image,tensorflow\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with Module (v0.10.0+)\nDESCRIPTION: This code shows how to define and register host functions in WasmEdge-Go v0.10.0 and later. Instead of using ImportObject, it uses the Module structure to create and manage host functions that can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// ...\n\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n// The third parameter is the pointer to the additional data object.\n// Developers should guarantee the life cycle of the data, and it can be `nil`\n// if the external data is not needed.\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge VM Context in C\nDESCRIPTION: This C code snippet demonstrates how to create a WasmEdge VM context with custom configuration and store contexts. It also shows how to retrieve the statistics context and properly manage the resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/*\n * The VM context already contains the statistics context and can be retrieved\n * by this API.\n */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by\n * VM APIs should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing Global Instances in WasmEdge Go\nDESCRIPTION: Shows how to create and manipulate global instances, including setting and getting values, and working with global types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_67\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Import Types in Go\nDESCRIPTION: Demonstrates how to handle import type contexts and extract information from AST modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Cost Table in WasmEdge Statistics\nDESCRIPTION: This snippet in Go demonstrates setting up a cost table for instruction cost accumulation in WasmEdge, enabling cost-limited execution. It integrates with statistical analysis via WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nstat := wasmedge.NewStatistics()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0,\n}\n// Developers can set the costs of each instruction. The value not covered will be 0.\n\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\n\n// ... After running the WASM functions with the `Statistics` object\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Passing STL Objects to WASM Functions in WasmEdge\nDESCRIPTION: Example of passing C++ STL objects (std::cout and std::string) as externref values to a WebAssembly function. This demonstrates how to create externref values from C++ objects and execute a WASM function with these references.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nstd::string PrintStr(\"Hello world!\");\nWasmEdge_Value P[2], R[1];\nP[0] = WasmEdge_ValueGenExternRef(&std::cout);\nP[1] = WasmEdge_ValueGenExternRef(&PrintStr);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"call_ostream_str\");\nWasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);\n// Will print \"Hello world!\" to stdout.\nWasmEdge_StringDelete(FuncName);\nif (!WasmEdge_ResultOK(Res)) {\n  return EXIT_FAILURE;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a VM Context for WASM Execution\nDESCRIPTION: This C code snippet demonstrates how to create a VM context with configuration and store contexts. It shows the initialization of various contexts and highlights the importance of managing the lifecycle of these contexts correctly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator in Go\nDESCRIPTION: Shows how to use the WasmEdge Validator to validate WASM modules before instantiation. It demonstrates creating a Validator object with custom configuration and validating an AST object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies in Cargo.toml\nDESCRIPTION: Dependency configuration for the WasmEdge web server project, including required crates for WASI socket, HTTP parsing, and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasmedge_wasi_socket = \"0\"\nquerystring = \"1.1.0\"\nparsed = { version = \"0.3\", features = [\"http\"] }\nanyhow = \"1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nisomorphic-app = { path = \"../app\" }\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Example with Import Function\nDESCRIPTION: Example WebAssembly module (in WAT format) that imports an external function named 'func-add' and exports a function 'addTwo' that uses the imported function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_75\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Validator Context Usage\nDESCRIPTION: Example showing how to validate a WASM module using the Validator context before instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating a WasmEdge Function Object with Host Function and Type\nDESCRIPTION: Code snippet showing how to create a function object in WasmEdge by defining its type signature and associating it with a host function implementation. The function type defines input and output parameter types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an module instance object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM\nDESCRIPTION: Demonstrates how to enable WASI support in a WasmEdge VM configuration and initialize WASI settings. Shows retrieving the built-in WASI module instance from the VM object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the built-in registered module instances from the VM object.\n// This API will return `nil` if the corresponding configuration is not set when creating the VM object.\nwasiconf := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasiconf.InitWasi(/* ... ignored */)\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering WASI and WasmEdge Process Modules in Go\nDESCRIPTION: Example showing how to initialize and register WASI and WasmEdge Process modules in a WasmEdge VM instance. This snippet demonstrates creating module instances, registering them to the VM, and retrieving the WASI exit code after execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_73\n\nLANGUAGE: go\nCODE:\n```\nwasiobj := wasmedge.NewWasiModule(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:\"}, // The mapping preopens\n)\nprocobj := wasmedge.NewWasmEdgeProcessModule(\n  []string{\"ls\", \"echo\"}, // The allowed commands\n  false,                  // Not to allow all commands\n)\n\n// Register the WASI and WasmEdge_Process into the VM object.\nvm := wasmedge.NewVM()\nvm.RegisterImport(wasiobj)\nvm.RegisterImport(procobj)\n\n// ... Execute some WASM functions.\n\n// Get the WASI exit code.\nexitcode := wasiobj.WasiGetExitCode()\n// The `exitcode` will be 0 if the WASI function \"_start\" execution has no error.\n// Otherwise, it will return with the related exit code.\n\nvm.Release()\n// The import objects should be deleted.\nwasiobj.Release()\nprocobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application with Custom Error Codes\nDESCRIPTION: Commands to build and run a Go application using the WasmEdge SDK, showing the output with user-defined error codes. This demonstrates how to install dependencies and execute the application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_63\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\n$ go build\n$ ./wasmedge_test\n[2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be\n[2022-08-26 15:06:40.384] [error]     When executing function name: \"trap\"\nGet the error code: 5566\n```\n\n----------------------------------------\n\nTITLE: Defining axum HTTP server with Rust\nDESCRIPTION: This Rust code defines an axum-based HTTP server that listens on `0.0.0.0:8080` and handles requests to the `/` and `/echo` endpoints. It uses the `tokio` runtime and axum's routing capabilities to direct requests to the appropriate handler functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() {\n    // build our application with a route\n    let app = Router::new()\n        .route(\"/\", get(help))\n        .route(\"/echo\", post(echo));\n\n    // run it\n    let addr = \"0.0.0.0:8080\";\n    let tcp_listener = TcpListener::bind(addr).await.unwrap();\n    println!(\"listening on {}\", addr);\n    axum::Server::from_tcp(tcp_listener.into_std().unwrap())\n        .unwrap()\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Hyper Echo Server Implementation\nDESCRIPTION: Implementation of an HTTP server using hyper framework with route handlers for /, /echo, and /echo/reversed endpoints\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nasync fn echo(req: Request<Body>) -> Result<Response<Body>, hyper::Error> {\n    match (req.method(), req.uri().path()) {\n        // Serve some instructions at /\n        (&Method::GET, \"/\") => Ok(Response::new(Body::from(\n            \"Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`\",\n        ))),\n\n        // Simply echo the body back to the client.\n        (&Method::POST, \"/echo\") => Ok(Response::new(req.into_body())),\n\n        (&Method::POST, \"/echo/reversed\") => {\n            let whole_body = hyper::body::to_bytes(req.into_body()).await?;\n\n            let reversed_body = whole_body.iter().rev().cloned().collect::<Vec<u8>>();\n            Ok(Response::new(Body::from(reversed_body)))\n        }\n\n        // Return the 404 Not Found for other routes.\n        _ => {\n            let mut not_found = Response::default();\n            *not_found.status_mut() = StatusCode::NOT_FOUND;\n            Ok(not_found)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy-Loaded React Component for SSR in JavaScript\nDESCRIPTION: This code defines a React component 'LazyHome' that lazy-loads an inner page component after a 2-second delay. It demonstrates the use of React.Suspense and lazy loading for server-side rendering.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { Suspense } from 'react';\nimport * as LazyPage from './LazyPage.jsx';\n\nasync function sleep(ms) {\n  return new Promise((r, _) => {\n    setTimeout(() => r(), ms);\n  });\n}\n\nasync function loadLazyPage() {\n  await sleep(2000);\n  return LazyPage;\n}\n\nclass LazyHome extends React.Component {\n  render() {\n    let LazyPage1 = React.lazy(() => loadLazyPage());\n    return (\n      <html lang=\"en\">\n        <head>\n          <meta charSet=\"utf-8\" />\n          <title>Title</title>\n        </head>\n        <body>\n          <div>\n            <div> This is LazyHome </div>\n            <Suspense fallback={<div> loading... </div>}>\n              <LazyPage1 />\n            </Suspense>\n          </div>\n        </body>\n      </html>\n    );\n  }\n}\n\nexport default LazyHome;\n```\n\n----------------------------------------\n\nTITLE: Storing VM with Default Store in Go\nDESCRIPTION: This snippet demonstrates how to create a WASM VM instance without explicitly assigning a Store. The VM takes ownership of the Store and manages its lifecycle automatically.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nstore := vm.GetStore()\n// The object should __NOT__ be deleted by calling `(*Store).Release`.\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Working with Reference Types in WasmEdge\nDESCRIPTION: Examples of creating and using FuncRef and ExternRef reference types\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar funccxt *wasmedge.Function = ... // Create or get function object.\nfuncref := wasmedge.NewFuncRef(funccxt)\n// Create a `FuncRef` with the function object.\n\nnum := 1234\n// `num` is a `int`.\nexternref := wasmedge.NewExternRef(&num)\n// Create an `ExternRef` which reference to the `num`.\nnum = 5678\n// Modify the `num` to 5678.\nnumref := externref.GetRef().(*int)\n// Get the original reference from the `ExternRef`.\nfmt.Println(*numref)\n// Will print `5678`.\nnumref.Release()\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Result Status with C API\nDESCRIPTION: This C code demonstrates how to work with `WasmEdge_Result` objects to check the execution status of WasmEdge operations. It showcases functions to check if a result is successful, get the result code, retrieve the result message, and determine the error category.  It also shows how to generate a user-defined result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n\"WasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be \\\"success\\\". */\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_WASM. */\n\nRes = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);\n/* Generate the user-defined result with code. */\nCode = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 123. */\nCategory = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions for WasmEdge Plug-in\nDESCRIPTION: C implementation of two host functions that will be exposed by the plug-in: HostFuncAdd and HostFuncSub, which add and subtract two int32_t numbers respectively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n\n/* The host function definitions. */\n\n/* The host function to add 2 int32_t numbers. */\nWasmEdge_Result HostFuncAdd(void *Data,\n                            const WasmEdge_CallingFrameContext *CallFrameCxt,\n                            const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* The host function to sub 2 int32_t numbers. */\nWasmEdge_Result HostFuncSub(void *Data,\n                            const WasmEdge_CallingFrameContext *CallFrameCxt,\n                            const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 - Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling WasmEdge_Process Support in Go\nDESCRIPTION: This code demonstrates how to enable the WasmEdge_Process interface for the Rust process interface in a VM configuration and initialize it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nprocmodule := vm.GetImportModule(wasmedge.WasmEdge_PROCESS)\n// Initialize the WasmEdge_Process.\nprocmodule.InitWasmEdgeProcess(/* ... ignored */)\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Host Function\nDESCRIPTION: Example implementation of a host function that adds two 32-bit integers and returns their sum.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n\n/* This function can add 2 i32 values and return the result. */\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  */\n\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution with Timeout in WasmEdge-go\nDESCRIPTION: Shows how to wait for asynchronous WebAssembly execution with a timeout. Demonstrates handling both completion and timeout scenarios, including cancellation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for HTTP Server WebAssembly Application\nDESCRIPTION: Configuration for a Docker container running a WebAssembly-based HTTP server using WasmEdge. This setup allows the WebAssembly application to listen for and respond to HTTP requests through the container.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_2\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-runtime:0.10.1\nADD http_server.wasm /\nCMD [\"wasmedge\", \"--dir\", \".:/\", \"/http_server.wasm\"]\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST Module to Anonymous Module Instance in C\nDESCRIPTION: This snippet illustrates how to instantiate an AST module into an anonymous Module instance. It includes creating necessary contexts, instantiating the module, and proper resource management. This step is required before function invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Memory Instances in C\nDESCRIPTION: Demonstrates memory instance creation, setting and retrieving data, and growing the memory size. The example shows how to work with linear memory, set and get data at specific offsets, and handle memory growth operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 5};\n/* Create the memory type with limit. The memory page size is 64KiB. */\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);\n/* Create the memory instance with memory type. */\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);\n/* Delete the memory type. */\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\n/* Set the data[0:2] to the memory[4096:4098]. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\n/* `PageSize` will be 1. */\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n/* Grow the page size of 2, the page size of the memory instance will be 3. */\n/*\n * This will get an \"out of bounds memory access\" error because\n * the page size (3 + 3) will reach the memory limit(5):\n *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);\n */\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Statistics from WasmEdge VM in Go\nDESCRIPTION: This code snippet demonstrates how to retrieve statistics from a WasmEdge VM using the `wasmedge.Statistics` object in Go.  It shows how to get the instruction count and instructions per second (IPS) after running a WASM function. The statistics object must be initialized and properly configured.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\n```go\n   stat := wasmedge.NewStatistics()\n   // ... After running the WASM functions with the `Statistics` object\n\n   count := stat.GetInstrCount()\n   ips := stat.GetInstrPerSecond()\n   stat.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Global Instance Management in WasmEdge\nDESCRIPTION: Demonstrates creation and manipulation of global instances, including value setting and type information retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n/* Additional global operations... */\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Storing VM with Custom Store in Go\nDESCRIPTION: A sample demonstrating how to create a VM instance with a custom Store, ensuring the Store remains valid until the VM has released its resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvm := wasmedge.NewVMWithStore(store)\n\nstoremock := vm.GetStore()\n// The internal store context of the `store` and the `storemock` are the same.\n\nvm.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plug-ins\nDESCRIPTION: Demonstrates how to load WasmEdge plug-ins from default paths and access registered modules, including both available and mocked modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\n// Load the plug-ins in the default paths first.\nwasmedge.LoadPluginDefaultPaths()\n\n// Create the VM object with the WASI configuration.\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.\n// This API will return `NULL` if the module instance not found.\n\n// The `wasimodule` will not be `nil` because the configuration was set.\nwasimodule := vm.GetRegisteredModule(\"wasi_snapshot_preview1\")\n\n// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.\nwasinnmodule := vm.GetRegisteredModule(\"wasi_ephemeral_nn\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Active Module Instance in WasmEdge (C)\nDESCRIPTION: Shows how to get the active module instance after WASM instantiation. This allows access to the module's exports and other properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Object Detection Model Rust\nDESCRIPTION: This snippet shows the initialization of an object detector in Rust using the builder pattern provided by the 'mediapipe-rs' crate. It builds an object detector from a TensorFlow Lite model buffer and performs inference on an input image to generate detection results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet model_data: &[u8] = include_bytes!(\"mobilenetv2_ssd_256_uint8.tflite\");\nlet detector = ObjectDetectorBuilder::new()\n        .max_results(2)\n        .build_from_buffer(model_data)?;\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet mut input_img = image::open(img_path)?;\nlet detection_result = detector.detect(&input_img)?;\nprintln!(\"{}\", detection_result);\n```\n\n----------------------------------------\n\nTITLE: Module Instance Operations in Go\nDESCRIPTION: Demonstrates how to list and find exported instances from a WASM module instance. Shows operations for retrieving function instances from the module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_66\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Instantiate a WASM module via the executor object and get the `mod` as the output module instance.\n// ...\n\n// List the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := mod.ListFunction()\n\n// Try to find the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncinst := mod.FindFunction(\"fib\")\n// `funcinst` will be `nil` if the function not found.\n// The returned instance is owned by the module instance and should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Loading Plugins and Managing Host Modules in WasmEdge with Go\nDESCRIPTION: This snippet shows how to load plugins from default paths into a WasmEdge VM. It creates a VM with the WASI configuration, retrieves registered modules, and demonstrates how it handles the absence of certain plugins by mocking host modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\nwasimodule := vm.GetRegisteredModule(\"wasi_snapshot_preview1\")\nwasinnmodule := vm.GetRegisteredModule(\"wasi_ephemeral_nn\")\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Instantiating WASM Module in WasmEdge 0.9.1 (C)\nDESCRIPTION: Example of instantiating a WASM module using the Executor API in WasmEdge version 0.9.1. This method instantiates an anonymous module instance handled by the Store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt;\n/*\n * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Complete example showing registration and execution of functions from a WASM module in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n  */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n  * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module name \"mod\".\n  * As the same as host functions, other modules can import the function `\"mod\" \"fib\"`.\n  */\n\n  /*\n  * Execute WASM functions in registered modules.\n  * Unlike the execution of functions, the registered functions can be invoked without\n  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.\n  * Developers can also invoke the host functions directly with this API.\n  */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Instance Management in WasmEdge C API\nDESCRIPTION: Shows memory instance operations including creation, data setting/getting, and page size management. Includes examples of memory access and growth operations with error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 5};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Creating VM Context with Store in C\nDESCRIPTION: This snippet shows how to create a VM context with an explicitly provided Store context, ensuring the proper lifecycle management of both contexts before deletion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing WasmEdge with Gas Limit\nDESCRIPTION: Demonstrates how to run a WebAssembly module using WasmEdge CLI with gas limiting enabled. It shows examples of executing with sufficient and insufficient gas limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --enable-all-statistics --gas-limit 20425 hello.wasm\n```\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --enable-all-statistics --gas-limit 20 hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Memory Instances in Go\nDESCRIPTION: Shows how to create and work with memory instances in WasmEdge. Demonstrates setting and getting memory data, checking page sizes, growing memory pages, and includes proper error handling examples.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Using wasmedge compile and wasmedge in Docker\nDESCRIPTION: Example demonstrating how to pull the slim WasmEdge Docker image, compile a WebAssembly module to AOT format, and execute it using the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/docker-slim.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/slim:{{ wasmedge_version }}\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm\n[2022-07-07 08:15:49.154] [info] compile start\n[2022-07-07 08:15:49.163] [info] verify start\n[2022-07-07 08:15:49.169] [info] optimize start\n[2022-07-07 08:15:49.808] [info] codegen start\n[2022-07-07 08:15:50.419] [info] output start\n[2022-07-07 08:15:50.421] [info] compile done\n[2022-07-07 08:15:50.422] [info] output start\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world\nhello\nworld\n```\n\n----------------------------------------\n\nTITLE: Managing Store Object in Go\nDESCRIPTION: Demonstrates usage of the Store object for managing module registration and retrieval, including listing registered modules and finding named modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n\nmodnames := store.ListModule()\n\nmod := store.FindModule(\"module\")\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: HTTPS Request Using Hyper\nDESCRIPTION: Example of making an HTTPS request using hyper with rustls in Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nasync fn fetch_https_url(url: hyper::Uri) -> Result<()> {\n    let https = wasmedge_hyper_rustls::connector::new_https_connector(\n        wasmedge_rustls_api::ClientConfig::default(),\n    );\n    let client = Client::builder().build::<_, hyper::Body>(https);\n    let res = client.get(url).await?;\n\n    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();\n    println!(\"{}\", String::from_utf8(body.into()).unwrap());\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an Existing Module Instance in Go\nDESCRIPTION: Shows how to register an existing Module instance with host functions into the Store. This allows the module to be exported with its name and used for linking by other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Create a module instance for host functions.\nmod := wasmedge.NewModule(\"mod\")\n// ...\n// Create and add the host functions, tables, memories, and globals into the module instance.\n// ...\n\n// Register the module instance into store with the exported module name.\n// The export module name is in the module instance already.\nres := executor.RegisterImport(store, mod)\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\n// ...\n\n// Resources deallocations.\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Pod Configuration for WebAssembly HTTP Service in Kubernetes\nDESCRIPTION: Kubernetes YAML configuration for running a WebAssembly-based HTTP service in a pod. The configuration specifies host network usage, container image, ports, and liveness probe settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: http-server\n  namespace: default\n  annotations:\n    module.wasm.image/variant: compat-smart\nspec:\n  hostNetwork: true\n  containers:\n    - name: http-server\n      image: wasmedge/example-wasi-http:latest\n      command: ['/http_server.wasm']\n      ports:\n        - containerPort: 1234\n          protocol: TCP\n      livenessProbe:\n        tcpSocket:\n          port: 1234\n        initialDelaySeconds: 3\n        periodSeconds: 30\n```\n\n----------------------------------------\n\nTITLE: Function Type Retrieval in WasmEdge\nDESCRIPTION: Shows how to retrieve function types by name from an instantiated WASM module in the VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Table Instances in Go\nDESCRIPTION: Demonstrates creating, accessing, and modifying table instances in WasmEdge. Shows how to create table types, set and get table data, check sizes, and grow tables with appropriate error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Optimization Levels in Go for WasmEdge\nDESCRIPTION: This code snippet defines constants for various compiler optimization levels in WasmEdge. It includes options ranging from disabling optimizations (O0) to optimizing for fast execution (O3) or small code size (Oz).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_81\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Function Instance to Module Instance in WasmEdge C API\nDESCRIPTION: This code demonstrates how to create a function type, function instance, and add it to a module instance in WasmEdge. It defines parameter and return types, creates a function instance with a callback handler, and registers it with the module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                         WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Forcing Interpreter Mode in WasmEdge\nDESCRIPTION: This snippet demonstrates how to forcibly execute a WebAssembly file in interpreter mode by configuring the WasmEdge settings accordingly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* By default, The `IsForceInterp` will be `FALSE`. */\nWasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);\nIsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* The `IsForceInterp` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Loading and Instantiating WASM Module\nDESCRIPTION: This code snippet demonstrates how to load, validate, and instantiate a WASM module in a given VM context. It handles errors for each stage of the process, ensuring the WASM file is correctly loaded.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"stl.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM file loading failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMValidate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM validation failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMInstantiate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed\\n\");\n  return EXIT_FAILURE;\n}\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Function Implementation in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format (WAT) implementation of a recursive Fibonacci number calculator that exports a 'fib' function taking a single integer parameter and returning the calculated Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_28\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing SHA-256 Hashing in WASI-Crypto\nDESCRIPTION: Example of using the hash function to generate a SHA-256 hash of a test string. The function returns a 32-byte vector containing the hash result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasicrypto.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// hash \"test\" by SHA-256\nlet hash : Vec<u8> = Hash::hash(\"SHA-256\", b\"test\", 32, None)?;\nassert_eq!(hash.len(), 32);\n```\n\n----------------------------------------\n\nTITLE: Managing Host Registrations for VM Contexts in C\nDESCRIPTION: This snippet defines the host registrations necessary for the VM context, particularly the `WASI` support. It illustrates how to check if a registration is present and how to add it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n    WasmEdge_HostRegistration_Wasi = 0\n};\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Memory Page and Interpreter Mode Configuration\nDESCRIPTION: Shows how to configure maximum memory pages and force interpreter mode in WasmEdge runtime\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\npagesize := conf.GetMaxMemoryPage()\nconf.SetMaxMemoryPage(1234)\nconf.SetForceInterpreter(true)\nis_forceinterp := conf.IsForceInterpreter()\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Demonstrates how to create a WASI host module as an import object and register it into a VM context. After registration, the host functions in the module can be called from WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ImportObjectContext *WasiObject =\n  WasmEdge_ImportObjectCreateWASI( /* ... ignored ... */ );\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObject);\n/* The result status should be checked. */\nWasmEdge_ImportObjectDelete(WasiObject);\n/* The created import objects should be deleted. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance with Export Name in C\nDESCRIPTION: Shows how to register an already created Module instance into the store with its exported module name. This is useful when creating a Module instance for host functions that need to be registered for linking with other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the\n * module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Querying Imports and Exports from an AST Module in C\nDESCRIPTION: Shows how to query the imports and exports of a WebAssembly AST Module context. This allows inspection of a module's interface before instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/*\n * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be\n * accessed.\n */\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions\nDESCRIPTION: Example program demonstrating how to list exported functions from a WASM module, including function name retrieval and handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Add Host Function in C for WasmEdge\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns their sum. The function retrieves input parameters, performs the addition, and sets the output value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  * Developers should take care about the function type.\n  */\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Module with Host Instances in Go\nDESCRIPTION: Example of creating a WasmEdge module instance with custom host functions, tables, memory, and globals, all properly exported for use in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_67\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the module instance with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nmod.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the module instance with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nmod.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the module instance with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nmod.AddGlobal(\"global\", hostglob)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Module with WasmEdge C API\nDESCRIPTION: This snippet demonstrates creating a WasmEdge VM context, defining a host function, registering a module, and executing a WebAssembly function from a binary buffer. It shows how to pass parameters and retrieve results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_73\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n/* The WASM module buffer. */\nuint8_t WASM[] = {\n  /* WASM header */\n  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n  /* Type section */\n  0x01, 0x07, 0x01,\n  /* function type {i32, i32} -> {i32} */\n  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n  /* Import section */\n  0x02, 0x13, 0x01,\n  /* module name: \"extern\" */\n  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n  /* extern name: \"func-add\" */\n  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n  /* import desc: func 0 */\n  0x00, 0x00,\n  /* Function section */\n  0x03, 0x02, 0x01, 0x00,\n  /* Export section */\n  0x07, 0x0A, 0x01,\n  /* export name: \"addTwo\" */\n  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n  /* export desc: func 0 */\n  0x00, 0x01,\n  /* Code section */\n  0x0A, 0x0A, 0x01,\n  /* code body */\n  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n};\n\n/* Create the module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\nWasmEdge_StringDelete(HostFuncName);\n\nWasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n/* The parameters and returns arrays. */\nWasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };\nWasmEdge_Value Returns[1];\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n/* Run the WASM function from buffer. */\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n  VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\n/* Resources deallocations. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StringDelete(FuncName);\nWasmEdge_ModuleInstanceDelete(HostModCxt);\nreturn 0;\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: This code demonstrates how to register host modules into a WasmEdge VM object, using the WASI module as an example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)\n\nres := vm.RegisterModule(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with ExternRef in C\nDESCRIPTION: This C code defines host functions that handle externref, including a multiplication function and its wrapper for use with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nuint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }\n\nWasmEdge_Result ExternMul(void *, const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);\n  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;\n  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Store and Module Instances in C\nDESCRIPTION: Demonstrates how to create a Store context, list registered WASM modules, and find modules by name. The code shows Store creation, module listing with buffer handling, and module lookup functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering Specialized Module Instances in WasmEdge VM\nDESCRIPTION: This code shows how to create specialized module instances like WASI and WasmEdgeProcess and register them with a VM context. After execution, it retrieves the WASI exit code and properly cleans up resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_ModuleInstanceContext *ProcModCxt =\n    WasmEdge_ModuleInstanceCreateWasmEdgeProcess(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\nWasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\nWasmEdge_ModuleInstanceDelete(ProcModCxt);\n```\n\n----------------------------------------\n\nTITLE: Global Instance Management in WasmEdge C API\nDESCRIPTION: Demonstrates global instance operations including creation, value setting/getting, and type information retrieval. Shows how to work with different value types and mutability settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nenum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Async Execution with Timeout and Cancellation\nDESCRIPTION: Shows how to wait for an asynchronous execution with a time limit, and optionally cancel the execution if it exceeds the specified duration. Demonstrates handling interruptible execution in AOT mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Implementing Ed25519 Digital Signatures in WASI-Crypto\nDESCRIPTION: Example showing how to create key pairs, generate signatures, and verify them using the Ed25519 signature scheme.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasicrypto.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet pk = SignaturePublicKey::from_raw(\"Ed25519\", &[0; 32])?;\n\nlet kp = SignatureKeyPair::generate(\"Ed25519\")?;\nlet signature = kp.sign(\"hello\")?;\n\nkp.publickey()?.signature_verify(\"hello\", &signature)?;\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plugins\nDESCRIPTION: Code demonstrating how to list available modules in a plugin and create a module instance from it. This allows using host module functionality provided by plugins in WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_76\n\nLANGUAGE: go\nCODE:\n```\n// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.\n\n// List the available host modules in the plug-in.\nmodules := plugincrypto.ListModule()\nfor _, name := range modules {\n  fmt.Println(\"Available module: \", name)\n}\n// Will print here for the WASI-Crypto plug-in here:\n//   wasi_ephemeral_crypto_asymmetric_common\n//   wasi_ephemeral_crypto_common\n//   wasi_ephemeral_crypto_kx\n//   wasi_ephemeral_crypto_signatures\n//   wasi_ephemeral_crypto_symmetric\n\n// Create a module instance from the plug-in by the module name.\nmodinst := plugincrypto.CreateModule(\"wasi_ephemeral_crypto_common\")\n\nmodinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating a Module Instance with Host Functions\nDESCRIPTION: Shows how to create a host function and begin constructing a module instance with exported functions in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plugin\nDESCRIPTION: How to list available host modules in a plugin and create a specific module instance. The example uses the WASI-crypto plugin to demonstrate the process of instantiating modules from a plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_88\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/*\n * Will print here for the WASI-Crypto plug-in here:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: Demonstrates how to configure various options for the Ahead-of-Time compiler in WasmEdge, including optimization level, output format, debugging options, and interruptibility for execution control.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n/* Set this option to `TRUE` to support the interruptible execution in AOT mode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plugin\nDESCRIPTION: Demonstrates how to list available modules in a plugin and create module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/* Will print here for the WASI-Crypto plug-in here:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Rapid WASM Function Execution in C\nDESCRIPTION: C implementation demonstrating how to quickly execute a WASM function using WasmEdge VM Context. The example loads and runs the Fibonacci calculator from a WASM file, computing the 5th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WASM from file/buffer with WasmEdge Loader\nDESCRIPTION: This Go snippet demonstrates how to load a WASM module from a file or a buffer using the WasmEdge `Loader` object.  It showcases creating a loader with a configuration object and handling potential errors during the loading process. The AST object should be released after loading.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\n\"var buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\\\"fibonacci.wasm\\\")\nif err != nil {\n  fmt.Println(\\\"Load WASM from file FAILED:\\\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\\\"Load WASM from buffer FAILED:\\\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\"\n```\n\n----------------------------------------\n\nTITLE: Complete script to build and run the application\nDESCRIPTION: This bash script automates the entire build and run process for the isomorphic web application. It navigates to the `client` directory, builds the WebAssembly code, then navigates to the `server-wasmedge` directory and runs the server using `cargo run`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\ncd $(dirname $0)\n\ncd ./client\n\n./build-wasm.sh\n\ncd ../server-wasmedge\n\nOUTPUT_CSS=\"$(pwd)/../client/build/app.css\" cargo run -p isomorphic-server-wasmedge\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous HTTP POST Request with Fetch\nDESCRIPTION: JavaScript code showing how to perform an asynchronous HTTP POST request using fetch API. The example sends a POST request with a text body to httpbin.org.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nasync function test_fetch_post() {\n  try {\n    let r = await fetch('http://httpbin.org/post', {\n      method: 'post',\n      body: 'post_body',\n    });\n    print('test_fetch_post\\n', await r.text());\n  } catch (e) {\n    print(e);\n  }\n}\ntest_fetch_post();\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in Go\nDESCRIPTION: Demonstrates how to register an existing Module instance into the store with an exported module name. Shows setup of executor and store objects along with module instance creation for host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod := wasmedge.NewModule(\"mod\")\n\nres := executor.RegisterImport(store, mod)\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge VM\nDESCRIPTION: Demonstrates how to register a WASM module with an exported module name in a WasmEdge VM. It shows creating a VM, creating a module name, and registering a WASM module from a file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly with WasmEdge AOT Compiler in C\nDESCRIPTION: Shows how to use the WasmEdge AOT compiler to compile a WebAssembly file for faster execution. Includes creating compiler context, compiling, and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_80\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* ... Adjust settings in the configure context. */\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create the compiler context. The configure context can be NULL. */\nWasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n/* Compile the WASM file with input and output paths. */\nRes = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\",\n                               \"fibonacci-aot.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return 1;\n}\n\nWasmEdge_CompilerDelete(CompilerCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Using Host Data in WebAssembly Execution with Go\nDESCRIPTION: This example shows how to pass external data to a host function in WebAssembly execution. It demonstrates setting and accessing host data in the function body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_79\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Also set the result to the data.\n  *data.(*int32) = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // The additional data to set into the host function.\n  var data int32 = 0\n\n  // Create the module instance with the module name \"extern\".\n  modinst := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)\n  functype.Release()\n  modinst.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(modinst)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  fmt.Println(\"Data value:\", data)\n\n  modinst.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an Existing Module Instance with Export Name in C\nDESCRIPTION: Shows how to register an existing Module instance (typically containing host functions) into the Store context with its export name. This is useful when creating custom host function modules for use in WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the\n * module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Handling Global Type Context in C\nDESCRIPTION: Shows creation and usage of Global Type context for managing WASM global instances with specific value types and mutability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Constructing Module Instance with Host Instances in WasmEdge Go\nDESCRIPTION: Shows how to create a module instance with various host instances including functions, tables, memory, and globals in WasmEdge Go. It demonstrates adding these instances to a module and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_64\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the module instance with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nmod.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the module instance with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nmod.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the module instance with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nmod.AddGlobal(\"global\", hostglob)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring hyper project dependencies in Cargo.toml\nDESCRIPTION: This configuration file patch and dependencies section specifies the necessary crates and their versions for building a hyper HTTP server in WasmEdge. It includes patches for `tokio`, `socket2`, and `hyper` to ensure compatibility with the WasmEdge environment, along with dependencies on `hyper` and `tokio`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\nhyper = { version = \"0.14\", features = [\"full\"]}\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\", \"io-util\"]}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in C\nDESCRIPTION: Demonstrates how to create a Function Type context, set parameter and return types, and query information from it. This is used for function creation and type checking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I64};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen =\n    WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen =\n    WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Function from Buffer in C\nDESCRIPTION: Demonstrates running a WebAssembly function from a buffer using the WasmEdge VM. Includes setting up parameters, calling the function, and handling the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_77\n\nLANGUAGE: c\nCODE:\n```\n/* The parameters and returns arrays. */\nWasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                                WasmEdge_ValueGenI32(5678)};\nWasmEdge_Value Returns[1];\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n/* Run the WASM function from buffer. */\nWasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nprintf(\"Data value: %d\\n\", Data);\n```\n\n----------------------------------------\n\nTITLE: Defining a Host Function Signature in Go\nDESCRIPTION: The required function signature for implementing host functions in WasmEdge. Host functions must implement this signature to be used as imports in WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: Working with Store Context in C\nDESCRIPTION: This snippet demonstrates how to use the Store context to list registered WASM modules and find named modules. The Store provides global state management for WasmEdge programs and maintains module registrations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/* If the list length is larger than the buffer length, the overflowed data will be discarded. */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Registering Host Module in WasmEdge 0.10.0 (C)\nDESCRIPTION: Example of creating and registering a host module using WasmEdge_ModuleInstanceContext in WasmEdge version 0.10.0. The caller is responsible for managing the created module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n/* Create the module instance with the export module name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Add the host functions, tables, memories, and globals into the module instance.\n */\n/* The module instance context has already contained the export module name. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Module instance registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Instance Management in Go\nDESCRIPTION: Shows memory instance creation and manipulation in WasmEdge, including setting/getting data and managing memory pages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_69\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating an Instruction Counter in Go\nDESCRIPTION: This snippet demonstrates how to create an instruction counter to track performance while executing WASM functions. It retrieves various performance metrics after executing functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n// ... After running the WASM functions with the `Statistics` object\n\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Global Instance in WasmEdge C API\nDESCRIPTION: This code snippet shows how to create a global type with specified value type and mutability, create a global instance with an initial value, and add it to a module instance. It demonstrates setting up a mutable i32 global variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\n/* Create and add a global instance into the module instance. */\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module\n * instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Accessing Arguments and Environment Variables - Rust\nDESCRIPTION: This Rust code shows how to access command-line arguments and environment variables within a WebAssembly module. The `print_env` function iterates through environment variables using `env::vars()` and prints each key-value pair. It also iterates through command-line arguments using `env::args()` and prints each argument. This functionality is enabled through the WASI environment provided by WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n\"use std::env;\\n\\npub fn print_env() {\\n  println!(\\\"The env vars are as follows.\\\");\\n  for (key, value) in env::vars() {\\n    println!(\\\"{}: {}\\\", key, value);\\n  }\\n\\n  println!(\\\"The args are as follows.\\\");\\n  for argument in env::args() {\\n    println!(\\\"{}\\\", argument);\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals in Configuration Context\nDESCRIPTION: Example of adding, removing, and checking WebAssembly proposals in the WasmEdge configuration context\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Listing Registered Modules in Store Context in C\nDESCRIPTION: Illustrates how to list registered WASM modules in a Store context. It demonstrates the use of buffer-based APIs to efficiently retrieve module names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* ... Register a WASM module via the executor context. */\n\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n```\n\n----------------------------------------\n\nTITLE: VM Creation with Different Configurations\nDESCRIPTION: Go code demonstrating various ways to create a WasmEdge VM instance with different combinations of Configure and Store objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Passing a Class as ExternRef in C++\nDESCRIPTION: This C++ code demonstrates how to pass a class instance as externref to a WASM function and handle it in a host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nclass AddClass {\npublic:\n  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }\n};\n\nAddClass AC;\n\nWasmEdge_Value P[3], R[1];\nP[0] = WasmEdge_ValueGenExternRef(&AC);\nP[1] = WasmEdge_ValueGenI32(1234);\nP[2] = WasmEdge_ValueGenI32(5678);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"call_add\");\nWasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  std::cout << \"Result : \" << WasmEdge_ValueGetI32(R[0]) std::endl;\n} else {\n  return EXIT_FAILURE;\n}\n\nWasmEdge_Result ExternAdd(void *, const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);\n  AddClass &Obj = *reinterpret_cast<AddClass *>(Ptr);\n  uint32_t C =\n      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Running JavaScript AI Inference in WasmEdge\nDESCRIPTION: Executes a JavaScript program for AI inference using TensorFlow Lite model within the WasmEdge runtime. Requires WasmEdge with WASI-NN and TensorFlow Lite dependencies installed. It recognizes the food item and outputs the label and confidence level.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs_nn.wasm example_js/tensorflow_lite_demo/wasi_nn_main.js\nlabel:\nHot dog\nconfidence:\n0.8941176470588236\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge CLI Tools in Go\nDESCRIPTION: This snippet shows how developers can execute WasmEdge CLI tools directly from Go using the WasmEdge Go SDK. The APIs accept the same arguments as the command line interface for running the tools.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: This example illustrates how to register host modules, specifically a WASI module, into a WasmEdge VM context. It emphasizes the importance of managing the lifecycle of created module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Registrations in WasmEdge\nDESCRIPTION: In this snippet, a new configuration context is created for managing host registrations, specifically for the WASI environment. The code checks the initial state of the host registration and adds it if necessary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n    WasmEdge_HostRegistration_Wasi = 0\n};\n\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Example with External Function Import\nDESCRIPTION: This WebAssembly module defines a function type for adding two integers, imports an external addition function, and exports an 'addTwo' function that calls the imported function with the provided parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_80\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Addition Function\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposals in C\nDESCRIPTION: This snippet defines an enumeration of WebAssembly proposals that can be configured for use within the WasmEdge context. Developers can modify the proposal settings using the configuration context that they create.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n    WasmEdge_Proposal_ImportExportMutGlobals = 0,\n    WasmEdge_Proposal_NonTrapFloatToIntConversions,\n    WasmEdge_Proposal_SignExtensionOperators,\n    WasmEdge_Proposal_MultiValue,\n    WasmEdge_Proposal_BulkMemoryOperations,\n    WasmEdge_Proposal_ReferenceTypes,\n    WasmEdge_Proposal_SIMD,\n    WasmEdge_Proposal_TailCall,\n    WasmEdge_Proposal_ExtendedConst,\n    WasmEdge_Proposal_FunctionReferences,\n    WasmEdge_Proposal_GC,\n    WasmEdge_Proposal_MultiMemories,\n    WasmEdge_Proposal_Threads,\n    WasmEdge_Proposal_RelaxSIMD,\n    WasmEdge_Proposal_Annotations,\n    WasmEdge_Proposal_Memory64,\n    WasmEdge_Proposal_ExceptionHandling,\n    WasmEdge_Proposal_Component,\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options - C\nDESCRIPTION: This snippet defines the enums for AOT compiler optimization levels and output formats, and shows how to set these options within a configuration context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n    // Disable as many optimizations as possible.\n    WasmEdge_CompilerOptimizationLevel_O0 = 0,\n    // Optimize quickly without destroying debuggability.\n    WasmEdge_CompilerOptimizationLevel_O1,\n    // Optimize for fast execution as much as possible without triggering\n    // significant incremental compile time or code size growth.\n    WasmEdge_CompilerOptimizationLevel_O2,\n    // Optimize for fast execution as much as possible.\n    WasmEdge_CompilerOptimizationLevel_O3,\n    // Optimize for small code size as much as possible without triggering\n    // significant incremental compile time or execution time slowdowns.\n    WasmEdge_CompilerOptimizationLevel_Os,\n    // Optimize for small code size as much as possible.\n    WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n    // Native dynamic library format.\n    WasmEdge_CompilerOutputFormat_Native = 0,\n    // WebAssembly with AOT compiled codes in custom section.\n    WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n /* Set this option to `TRUE` to support the interruptible execution in AOT\n mode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions from Store in Go\nDESCRIPTION: Shows how to list the exported functions of an instantiated WASM module using the Store object. It creates a Store, assumes a module is instantiated, then lists and prints the names of exported functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_46\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n// ...\n// Instantiate a WASM module via the `*wasmedge.Executor` object.\n// ...\n\n// Try to list the exported functions of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := store.ListFunction()\nfor _, name := range funcnames {\n  fmt.Println(\"Exported function name:\", name)\n}\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in C\nDESCRIPTION: This code shows how to register an existing Module instance into the Store with exporting the module name. This pattern is useful when creating Module instances for host functions that need to be linked from WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\n/*\n* ...\n* Assume that the `ASTCxt` is the output AST module context from the loader context\n* and has passed the validation.\n* Assume that the `ConfCxt` is the configure context.\n*/\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/* Create the executor context. The configure and the statistics contexts can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/* Create the store context. The store context is the object to link the modules for imports and exports. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Client Handler in JavaScript\nDESCRIPTION: JavaScript code implementing the client handler function for a TCP server. This function reads data from client connections, processes it, and sends a response back.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nasync function handle_client(cs) {\n  print('server accept:', cs.peer());\n  try {\n    while (true) {\n      let d = await cs.read();\n      if (d == undefined || d.byteLength <= 0) {\n        break;\n      }\n      let s = new TextDecoder().decode(d);\n      print('server recv:', s);\n      cs.write('echo:' + s);\n    }\n  } catch (e) {\n    print('server handle_client error:', e);\n  }\n  print('server: conn close');\n}\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step WASM Execution in Go\nDESCRIPTION: Detailed Go implementation showing manual steps for loading, validating, instantiating and executing WASM functions using WasmEdge VM. Calculates the 25th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_31\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n  var err error\n  var res []interface{}\n\n  // Step 1: Load WASM file.\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Execute WASM functions. Parameters: (funcname, args...)\n  res, err = vm.Execute(\"fib\", uint32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge VM (Go)\nDESCRIPTION: Demonstrates how to register a WASM module from a file into a WasmEdge VM with a specified module name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  // The result status should be checked. The error will occur if the\n  // WASM module instantiation failed or the module name conflicts.\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Global Instances in WasmEdge Go\nDESCRIPTION: This snippet demonstrates how to create, access, and modify global instances in WasmEdge. It shows creating globals with specific types and mutability, setting and getting values, and accessing global type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Invocation in Go\nDESCRIPTION: Demonstrates how to use the new AsyncInvoke() method of the wasmedge.Executor to execute a WASM function asynchronously in Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n(wasmedge.Executor).AsyncInvoke()\n```\n\n----------------------------------------\n\nTITLE: Implementing User-Defined Error Codes in Host Functions\nDESCRIPTION: Complete example of implementing a host function that returns user-defined error codes, registering it with a WebAssembly module, and executing the function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Trap(void *Data,\n                     const WasmEdge_CallingFrameContext *CallFrameCxt,\n                     const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val = WasmEdge_ValueGetI32(In[0]);\n  /* Return the error code from the param[0]. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x05, 0x01,\n                    /* function type {i32} -> {} */\n                    0x60, 0x01, 0x7F, 0x00,\n                    /* Import section */\n                    0x02, 0x0F, 0x01,\n                    /* module name: \"extern\" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: \"trap\" */\n                    0x04, 0x74, 0x72, 0x61, 0x70,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x08, 0x01,\n                    /* export name: \"trap\" */\n                    0x04, 0x74, 0x72, 0x61, 0x70,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x08, 0x01,\n                    /* code body */\n                    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"trap\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"trap\");\n  /* Run the WASM function from buffer. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 1, NULL, 0);\n\n  /* Get the result code and print. */\n  printf(\"Get the error code: %u\\n\", WasmEdge_ResultGetCode(Res));\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Illustrates how to create and register a host module (WASI in this example) in a WasmEdge VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge Statistics Counter in C\nDESCRIPTION: Demonstrates how to create, use and manage a statistics context for counting WebAssembly instructions and measuring instruction execution speed. Shows creation, retrieval of instruction count and instructions per second, and proper cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions - v0.11.0+\nDESCRIPTION: Updated memory access pattern for v0.11.0+ using CallingFrameContext, supporting multiple memories and recursive invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /* Get the 0th memory instance of the module of the top frame on the stack. */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Running WASM Functions with WasmEdge C API\nDESCRIPTION: This code demonstrates how to asynchronously execute a WebAssembly function from a file using the WasmEdge C API. It loads a Fibonacci calculator function, executes it with input parameter 20, and retrieves the result after waiting for execution to complete.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs\n   * to wait for the asynchronous execution. These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Function Context for Host Function in C\nDESCRIPTION: Shows how to create a function context for a host function, including defining the function type and creating the function instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                  WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost\n * measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/*\n * If the function instance is __NOT__ added into a module instance context,\n * it should be deleted.\n */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Function Instance Operations in Go\nDESCRIPTION: Shows how to work with function instances in WasmEdge, including retrieving function types from function objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_67\n\nLANGUAGE: go\nCODE:\n```\nfuncobj := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the module instance should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n\n// For the function object creation, please refer to the `Host Function` guide.\n```\n\n----------------------------------------\n\nTITLE: OpenVINO Model Loading and Inference in Rust\nDESCRIPTION: Rust code demonstrating how to load an OpenVINO model, set input tensor data, and perform inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/openvino.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// load model\nlet graph = GraphBuilder::new(\n    GraphEncoding::Openvino,\n    ExecutionTarget::CPU\n).build_from_files([model_xml_path, model_bin_path])?;\nlet mut context = graph.init_execution_context()?;\n\n// Load a tensor that precisely matches the graph input tensor\nlet input_dims = vec![1, 3, 224, 224];\nlet tensor_data = image_to_tensor(image_name.to_string(), 224, 224);\ncontext.set_input(0, TensorType::F32, &input_dims, tensor_data)?;\n\n// Execute the inference.\ncontext.compute()?;\n\n// Retrieve the output.\nlet mut output_buffer = vec![0f32; 1001];\nlet size_in_bytes = context.get_output(0, &mut output_buffer)?;\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Module from File in WasmEdge\nDESCRIPTION: Demonstrates loading and linking a WASM module from a file using WasmEdge_VMRegisterModuleFromFile. The code shows initialization, module registration, function execution and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* Register the `lib.wasm` from file with the module name \"math\". */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModuleName, \"lib.wasm\");\n  WasmEdge_StringDelete(ModuleName);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Register lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Rest of implementation... */\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-NN Support in WasmEdge Go\nDESCRIPTION: This code shows how to enable WASI-NN (Neural Network) proposal support in a WasmEdge VM configuration. This requires that the dependencies and prerequisites for WASI-NN are satisfied.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WasiNN)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nnnmodule := vm.GetImportModule(wasmedge.WasiNN)\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugin from Specific Path\nDESCRIPTION: Shows how to load a WasmEdge plugin from a specific file system path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadFromPath(\"PATH_TO_PLUGIN/plugin.so\");\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Global Instances in Go\nDESCRIPTION: Demonstrates creating and using global instances in WasmEdge. Shows setting up global types with value types and mutations, setting and getting global values, and accessing global type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing TensorFlow-based Image Classification in Rust\nDESCRIPTION: Rust function that uses WasmEdge TensorFlow API to perform image classification. It reads image data from STDIN, processes it through a TensorFlow Lite model, and outputs the classification result to STDOUT.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn main() {\n  // Step 1: Load the TFLite model\n  let model_data: &[u8] = include_bytes!(\"models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite\");\n  let labels = include_str!(\"models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt\");\n\n  // Step 2: Read image from STDIN\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  // Step 3: Resize the input image for the tensorflow model\n  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);\n\n  // Step 4: AI inference\n  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);\n  session.add_input(\"input\", &flat_img, &[1, 224, 224, 3])\n         .run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Reshape_1\");\n\n  // Step 5: Find the food label that responds to the highest probability in res_vec\n  // ... ...\n  let mut label_lines = labels.lines();\n  for _i in 0..max_index {\n    label_lines.next();\n  }\n\n  // Step 6: Generate the output text\n  let class_name = label_lines.next().unwrap().to_string();\n  if max_value > 50 {\n    println!(\"It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture\", confidence.to_string(), class_name, class_name);\n  } else {\n    println!(\"It does not appears to be any food item in the picture.\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling ExportType in WasmEdge Go SDK\nDESCRIPTION: Shows how to work with ExportType objects to retrieve information about exported items in WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Managing Module Instances in Go\nDESCRIPTION: Demonstrates how to list and find exported instances from a WasmEdge module instance. The snippet shows listing function names and finding a specific function by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Instantiate a WASM module via the executor object and get the `mod` as the output module instance.\n// ...\n\n// List the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := mod.ListFunction()\n\n// Try to find the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncinst := mod.FindFunction(\"fib\")\n// `funcinst` will be `nil` if the function not found.\n// The returned instance is owned by the module instance and should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: This code snippet defines enumerations for AOT compiler optimization levels and output formats, alongside an example of configuring the compiler behavior within a WasmEdge context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n    // Disable as many optimizations as possible.\n    WasmEdge_CompilerOptimizationLevel_O0 = 0,\n    // Optimize quickly without destroying debuggability.\n    WasmEdge_CompilerOptimizationLevel_O1,\n    // Optimize for fast execution as much as possible without triggering\n    // significant incremental compile time or code size growth.\n    WasmEdge_CompilerOptimizationLevel_O2,\n    // Optimize for fast execution as much as possible.\n    WasmEdge_CompilerOptimizationLevel_O3,\n    // Optimize for small code size as much as possible without triggering\n    // significant incremental compile time or execution time slowdowns.\n    WasmEdge_CompilerOptimizationLevel_Os,\n    // Optimize for small code size as much as possible.\n    WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n    // Native dynamic library format.\n    WasmEdge_CompilerOutputFormat_Native = 0,\n    // WebAssembly with AOT compiled codes in custom section.\n    WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in C\nDESCRIPTION: Demonstrates the creation and usage of a Function Type context, including setting parameter and return types, and retrieving type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Using Specified Module Instances in WasmEdge C API\nDESCRIPTION: Illustrates how to create and use specified module instances such as WASI and WasmEdge_Process. These module instances can be registered into Store or VM contexts for use in WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt = WasmEdge_ModuleInstanceCreateWASI( /* ... ignored */ );\nWasmEdge_ModuleInstanceContext *ProcModCxt = WasmEdge_ModuleInstanceCreateWasmEdgeProcess( /* ... ignored */ );\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\nWasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\nWasmEdge_ModuleInstanceDelete(ProcModCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Unified CLI Tool\nDESCRIPTION: Example showing how to use the WasmEdge_Driver_UniTool() API to implement the unified CLI functionality, combining both runtime and AOT compiler features.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_84\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge unified tool. */\n  /* (Within both runtime and AOT compiler) */\n  return WasmEdge_Driver_UniTool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Timeouts with Async Execution in WasmEdge Go API\nDESCRIPTION: Shows how to set timeouts when waiting for asynchronous function execution in WasmEdge. Demonstrates handling both completed execution and timeout conditions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Specialized Import Objects (WASI and WasmEdge Process)\nDESCRIPTION: Example of creating specialized import objects for WASI and WasmEdge Process, registering them into a VM context, and handling the WASI exit code. These specialized import objects provide environment-specific functionality to WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ImportObjectContext *WasiObj = WasmEdge_ImportObjectCreateWASI( /* ... ignored */ );\nWasmEdge_ImportObjectContext *ProcObj = WasmEdge_ImportObjectCreateWasmEdgeProcess( /* ... ignored */ );\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObj);\nWasmEdge_VMRegisterModuleFromImport(VMCxt, ProcObj);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ImportObjectWASIGetExitCode(WasiObj);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The import objects should be deleted. */\nWasmEdge_ImportObjectDelete(WasiObj);\nWasmEdge_ImportObjectDelete(ProcObj);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C Example\nDESCRIPTION: Command to compile and run the previous C example using GCC with the WasmEdge library. The output demonstrates the successful execution of the WebAssembly function that adds two numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_84\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Querying the Database (Rust)\nDESCRIPTION: This Rust code snippet queries all records from the `orders` table. It maps the result set to a vector of `Order` objects and prints the number of loaded orders and the order data to the console using `dbg!`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n    // query data\n    let loaded_orders = \"SELECT * FROM orders\"\n        .with(())\n        .map(\n            &mut conn,\n            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {\n                Order::new(\n                    order_id,\n                    production_id,\n                    quantity,\n                    amount,\n                    shipping,\n                    tax,\n                    shipping_address,\n                )\n            },\n        )\n        .await?;\n    dbg!(loaded_orders.len());\n    dbg!(loaded_orders);\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution in WasmEdge (C)\nDESCRIPTION: This snippet demonstrates how to wait for an asynchronous WasmEdge execution to finish. It shows the basic usage of `WasmEdge_AsyncWait()` to block until the execution completes, followed by deleting the `WasmEdge_Async` object. The `WasmEdge_AsyncDelete()` function must be called to release the allocated resources for the asynchronous execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance with Host Functions\nDESCRIPTION: Example of constructing a module instance with various host function implementations and instance types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_65\n\nLANGUAGE: go\nCODE:\n```\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the module instance with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nmod.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the module instance with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nmod.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the module instance with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nmod.AddGlobal(\"global\", hostglob)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: VM Creation with Configure and Store Contexts\nDESCRIPTION: Example demonstrating the creation of a WasmEdge VM Context with Configure and Store contexts, including proper resource management and statistics context retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/*\n * The VM context already contains the statistics context and can be retrieved\n * by this API.\n */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by\n * VM APIs should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Setting and Using Cost Table in C\nDESCRIPTION: This C code demonstrates how to set a cost table and a cost limit in a `WasmEdge_StatisticsContext`. The cost table assigns costs to different WASM instructions. If a cost limit is set, execution will stop immediately and return an error when it exceeds the cost limit.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/*\n * Developers can set the costs of each instruction. The value not\n * covered will be 0.\n */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASI Module Instance in WasmEdge C API\nDESCRIPTION: Creating a WASI module instance, registering it with a VM context, and retrieving the exit code after execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt =\n   WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n* The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n* Otherwise, it will return with the related exit code.\n*/\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Context Lifecycles in Go\nDESCRIPTION: Shows the proper way to create and release WasmEdge contexts. Resources should be released when no longer needed to prevent memory leaks.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\nconf := wasmedge.NewConfigure()\n// Release the `conf` immediately.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Programs\nDESCRIPTION: Shell commands for compiling C programs using the WasmEdge library and executing the resulting binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the '(123 + 456)^2' result: 335241\nGet the '77^2 + 88^2' result: 13673\n```\n\n----------------------------------------\n\nTITLE: Creating Table Instance in WasmEdge\nDESCRIPTION: This snippet shows how to create a table type context, table instance, and add it to a module instance with a specified limit configuration. The table uses FuncRef reference type with a min size of 10 and max size of 20.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TableLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Table Type Context in WasmEdge\nDESCRIPTION: Example of creating a Table Type context with an external reference type and specific limits, then retrieving and validating the stored type information. Table Type contexts are used for Table instance creation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenExternRef(), TabLim);\n\nWasmEdge_ValType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nbool IsTypeExternRef = WasmEdge_ValTypeIsExternRef(GotRefType);\n/* `IsTypeExternRef` will be `TRUE`. */\nbool IsTypeRef = WasmEdge_ValTypeIsRef(GotRefType);\n/* `IsTypeRef` will be `TRUE`. */\nbool IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(GotRefType);\n/* `IsTypeNullableRef` will be `TRUE`. */\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n/* `GotTabLim` will be the same value as `TabLim`. */\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing an Addition Host Function in WasmEdge with Go\nDESCRIPTION: Example of implementing an 'add' host function that takes two i32 parameters, adds them, and returns the result. The function follows the required host function signature pattern.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Instance Management in C\nDESCRIPTION: Shows how to create and manage memory instances including setting data, growing memory pages, and handling memory limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\nWasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(MemTypeCxt);\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Executing TensorFlow Lite Model in Rust\nDESCRIPTION: This code snippet handles loading, computing, and retrieving output from a TensorFlow Lite model in Rust using the WasmEdge API. The setup includes dependencies on WasmEdge libraries and image preprocessing tools.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// load model\nlet weights = fs::read(model_bin_name)?;\nlet graph = GraphBuilder::new(\nGraphEncoding::TensorflowLite,\nExecutionTarget::CPU,\n).build_from_bytes(&[&weights])?;\nlet mut ctx = graph.init_execution_context()?;\n\n// Load a tensor that precisely matches the graph input tensor\nlet tensor_data = image_to_tensor(image_name.to_string(), 224, 224);\nctx.set_input(0, TensorType::U8, &[1, 224, 224, 3], &tensor_data)?;\n\n// Execute the inference.\nctx.compute().unwrap();\n\n// Retrieve the output.\nlet mut output_buffer = vec![0u8; imagenet_classes::AIY_BIRDS_V1.len()];\n_ = ctx.get_output(0, &mut output_buffer)?;\n```\n\n----------------------------------------\n\nTITLE: Handling User-Defined Error Codes in WasmEdge Go Host Functions\nDESCRIPTION: Demonstrates how to use user-defined error codes in WasmEdge Go host functions. It includes creating a WASM module, defining a host function, and handling custom error codes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_63\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x05, 0x01,\n    /* function type {i32} -> {} */\n    0x60, 0x01, 0x7F, 0x00,\n    /* Import section */\n    0x02, 0x0F, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x08, 0x01,\n    /* export name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x08, 0x01,\n    /* code body */\n    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})\n  hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"trap\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  _, err := vm.RunWasmBuffer(wasmbuf, \"trap\", uint32(5566))\n  if err != nil {\n    fmt.Println(\"Get the error code:\", err.GetCode())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Memory Instances in WasmEdge Go\nDESCRIPTION: Demonstrates the creation and manipulation of memory instances, including setting and getting data, growing the memory, and handling errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_66\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Hashing with SHA-256 in Rust using WASI-Crypto\nDESCRIPTION: This code demonstrates how to perform SHA-256 hashing using the WASI-crypto API in Rust. It hashes the string \"test\" and verifies that the resulting hash has a length of 32 bytes. It depends on the wasi-crypto crate.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasicrypto.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// hash \\\"test\\\" by SHA-256\nlet hash : Vec<u8> = Hash::hash(\"SHA-256\", b\"test\", 32, None)?;\nassert_eq!(hash.len(), 32);\n```\n\n----------------------------------------\n\nTITLE: Host Registration Configuration in C\nDESCRIPTION: Shows how to configure host registrations in WasmEdge, particularly for WASI support configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Enabling WASI Host Registration in WasmEdge\nDESCRIPTION: This Go code snippet demonstrates how to enable WASI host registrations in the WasmEdge environment using the 'Configure' object. WASI support is essential for executing WebAssembly with system interface capabilities. Dependencies include the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\nconst (WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi))\n```\n\nLANGUAGE: Go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.WASI)\nconf.AddConfig(wasmedge.WASI)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Cost Table Configuration in C\nDESCRIPTION: Shows how to set up a cost table for instruction weighting and cost limiting in WasmEdge. The example includes defining instruction costs, setting the cost table, and implementing a cost limit for execution control.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/*\n * Developers can set the costs of each instruction. The value not\n * covered will be 0.\n */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: Example showing how to set AOT compiler options including optimization level, output format, IR dumping, and generic binary generation. These settings are effective in Compiler contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the optimization level is O3.\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n// By default, the output format is universal WASM.\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n// By default, the dump IR is `false`.\nconf.SetCompilerDumpIR(true)\n// By default, the generic binary is `false`.\nconf.SetCompilerGenericBinary(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Module Instance Operations in Go\nDESCRIPTION: Demonstrates how to list and find exported instances from a WASM module instance. Shows retrieval of function instances and handling module exports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\n// List the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := mod.ListFunction()\n\n// Try to find the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncinst := mod.FindFunction(\"fib\")\n// `funcinst` will be `nil` if the function not found.\n// The returned instance is owned by the module instance and should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Enabling Interpreter Mode in WasmEdge with Go\nDESCRIPTION: This snippet describes how to enforce interpreter mode execution for WASM files in WasmEdge using Go. This option can be turned on or off through the wasmedge.Configure object. The WasmEdge Go SDK is a dependency for this operation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\nis_forceinterp := conf.IsForceInterpreter()\n// By default, the `is_forceinterp` will be `false`.\nconf.SetForceInterpreter(true)\nis_forceinterp = conf.IsForceInterpreter()\n/* The `is_forceinterp` will be `true`. */\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Calling Rust-compiled WebAssembly Function\nDESCRIPTION: Shows how to compile a Rust program to WebAssembly and call its exported function using WasmEdge CLI in reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --reactor add.wasm add 2 2\n```\n\n----------------------------------------\n\nTITLE: Creating ES6 Module with Async Function and Variable Exports\nDESCRIPTION: ES6 module that defines and exports an async function and a variable. This demonstrates how to create asynchronous module functions that can be imported by other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/es6.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport async function hello() {\n  console.log('hello from module_def_async.js');\n  return 'module_def_async.js : return value';\n}\n\nexport var something = 'async thing';\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions in Registered Modules\nDESCRIPTION: Shows how to register a WASM module, execute a function from the registered module, and handle the results in a WasmEdge VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n   * name \"mod\". As the same as host functions, other modules can import the\n   * function `\"mod\" \"fib\"`.\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                     Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in C\nDESCRIPTION: Demonstrates how to create a Function Type context, set parameter and return types, and query information from it. This is used for function creation and type checking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I64};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen =\n    WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen =\n    WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Working with FunctionType in WasmEdge Go API\nDESCRIPTION: Demonstrates creating and using FunctionType objects to define parameter and return types for WASM functions. Shows how to retrieve type information from function definitions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Building and Running the WebAssembly Application\nDESCRIPTION: These bash commands demonstrate how to build the Go application with the WasmEdge Go SDK and run it to execute the WebAssembly functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/function.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n\n./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Result Status\nDESCRIPTION: This C code demonstrates how to check the status of a `WasmEdge_Result` object using `WasmEdge_ResultOK`, `WasmEdge_ResultGetCode`, and `WasmEdge_ResultGetMessage`. It shows how to determine if an operation was successful and how to retrieve the result code and message. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be \"success\". */\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Global Instances in C\nDESCRIPTION: Demonstrates global instance creation, setting and retrieving values. The example shows how to work with global variables in WebAssembly, including mutable and immutable globals, and how to access their types and values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n/* Create the global type with value type and mutation. */\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\n/* Create the global instance with value and global type. */\nWasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n/* Delete the global type. */\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `ValType` will be `WasmEdge_ValType_I64`. */\nenum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n/*\n * Set the value u64(888) to the global.\n * This function will do nothing if the value type mismatched or\n * the global mutability is `WasmEdge_Mutability_Const`.\n */\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n/* Get the value (888 now) of the global context. */\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plug-ins in Go\nDESCRIPTION: This snippet demonstrates how to load WasmEdge plug-ins from default paths or specific locations, list available plug-ins, and create module instances from plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_80\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\nwasmedge.LoadPluginFromPath(\"PATH_TO_PLUGIN/plugin.so\")\n\npluginnames := wasmedge.ListPlugins()\nfor _, name := range pluginnames {\n  fmt.Println(\"Loaded plug-in name: \", name)\n}\n\n// Assume that wasi_crypto plug-in is installed in the default plug-in path.\nwasmedge.LoadPluginDefaultPaths()\nplugincrypto := wasmedge.FindPlugin(\"wasi_crypto\")\n\n// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.\n\n// List the available host modules in the plug-in.\nmodules := plugincrypto.ListModule()\nfor _, name := range modules {\n  fmt.Println(\"Available module: \", name)\n}\n\n// Create a module instance from the plug-in by the module name.\nmodinst := plugincrypto.CreateModule(\"wasi_ephemeral_crypto_common\")\n\nmodinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Memory Limits in Go\nDESCRIPTION: Shows how to create and work with shared memory limits in WASM, including creation with and without maximum values and checking shared status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nlim3 := wasmedge.NewLimitShared(20)\nfmt.Println(lim3.HasMax())\n// Will print `false`.\nfmt.Println(lim3.IsShared())\n// Will print `true`.\nfmt.Println(lim3.GetMin())\n// Will print `20`.\n\nlim4 := wasmedge.NewLimitSharedWithMax(30, 40)\nfmt.Println(lim4.HasMax())\n// Will print `true`.\nfmt.Println(lim4.IsShared())\n// Will print `true`.\nfmt.Println(lim4.GetMin())\n// Will print `30`.\nfmt.Println(lim4.GetMax())\n// Will print `40`.\n```\n\n----------------------------------------\n\nTITLE: AOT Compilation and Inference (Bash)\nDESCRIPTION: AOT (Ahead-Of-Time) compiles the WASM file for improved performance using `wasmedge compile`. The compiled WASM file (`out.wasm`) is then executed using the `wasmedge` command with the model and input image.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm\nwasmedge --dir .:. out.wasm mobilenet.pt input.jpg\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Table Instances in C\nDESCRIPTION: Demonstrates table instance creation, setting and retrieving data, and growing the table size. The example shows how to handle function references in a table and includes bounds checking examples.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\n/* Create the table type with limit and the `FuncRef` element type. */\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\n/* Create the table instance with table type. */\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);\n/* Delete the table type. */\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\n/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `RefType` will be `WasmEdge_RefType_FuncRef`. */\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\n/* Set the function index 5 to the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);\n */\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n/* Get the FuncRef value of the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);\n */\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\n/* `Size` will be 10. */\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n/* Grow the table size of 6, the table size will be 16. */\n/*\n * This will get an \"out of bounds table access\" error because\n * the size (16 + 6) will reach the table limit(20):\n *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);\n */\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM (Go)\nDESCRIPTION: Illustrates how to register host modules, such as WASI, into a WasmEdge VM object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)\n\nres := vm.RegisterModule(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Functions with wasmedge-bindgen\nDESCRIPTION: Example Rust code showing several functions annotated with wasmedge_bindgen macro. These functions demonstrate handling complex parameters and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/wasm-app-in-rust.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\nuse num_integer::lcm;\nuse sha3::{Digest, Sha3_256, Keccak256};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n  x: f32,\n  y: f32\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n  points: Vec<Point>,\n  valid: bool,\n  length: f32,\n  desc: String\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> Result<Vec<u8>, String> {\n  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();\n  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();\n  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();\n\n  let valid = if length == 0.0 { false } else { true };\n\n  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };\n\n  return Ok(serde_json::to_vec(&line).unwrap());\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> Result<Vec<u8>, String> {\n  let r = String::from(\"hello \");\n  return Ok((r + s.as_str()).as_bytes().to_vec());\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> Result<Vec<u8>, String> {\n  let r: String = (&s).chars().map(|c| {\n    match c {\n      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,\n      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,\n      _ => c\n    }\n  }).collect();\n  Ok(r.as_bytes().to_vec())\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> Result<Vec<u8>, String> {\n  let r = lcm(a, b);\n  return Ok(r.to_string().as_bytes().to_vec());\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Result<Vec<u8>, String> {\n  return Ok(Sha3_256::digest(&v).as_slice().to_vec());\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Result<Vec<u8>, String> {\n  return Ok(Keccak256::digest(&s).as_slice().to_vec());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Output Formats in WasmEdge Go SDK\nDESCRIPTION: Constants defining the available output formats for the WasmEdge AOT compiler. Supports generating native dynamic libraries or WebAssembly with AOT compiled code in custom sections.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_80\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating VM Context with Configuration and Store\nDESCRIPTION: This code snippet demonstrates how to create a VM context with both a configuration context and a store context in the WasmEdge SDK. It highlights the importance of managing the lifecycle of the store context appropriately.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/* The VM context already contains the statistics context and can be retrieved by this API. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Building a Non-Blocking HTTP Client with WasmEdge Rust\nDESCRIPTION: This code illustrates the implementation of a non-blocking HTTP client in Rust. It opens two TCP connections simultaneously and utilizes non-blocking I/O to read from each connection concurrently. Dependencies include the httparse crate and wasmedge_wasi_socket crate.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/socket_networking/client.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse httparse::{Response, EMPTY_HEADER};\nuse std::io::{self, Read, Write};\nuse std::str::from_utf8;\nuse wasmedge_wasi_socket::TcpStream;\n\nfn main() {\n    let req = \"GET / HTTP/1.0\\n\\n\";\n    let mut first_connection = TcpStream::connect(\"127.0.0.1:80\").unwrap();\n    first_connection.set_nonblocking(true).unwrap();\n    first_connection.write_all(req.as_bytes()).unwrap();\n\n    let mut second_connection = TcpStream::connect(\"127.0.0.1:80\").unwrap();\n    second_connection.set_nonblocking(true).unwrap();\n    second_connection.write_all(req.as_bytes()).unwrap();\n\n    let mut first_buf = vec![0; 4096];\n    let mut first_bytes_read = 0;\n    let mut second_buf = vec![0; 4096];\n    let mut second_bytes_read = 0;\n\n    loop {\n        let mut first_complete = false;\n        let mut second_complete = false;\n        if !first_complete {\n            match read_data(&mut first_connection, &mut first_buf, first_bytes_read) {\n                Ok((bytes_read, false)) => {\n                    first_bytes_read = bytes_read;\n                }\n                Ok((bytes_read, true)) => {\n                    println!(\"First connection completed\");\n                    if bytes_read != 0 {\n                        parse_data(&first_buf, bytes_read);\n                    }\n                    first_complete = true;\n                }\n                Err(e) => {\n                    println!(\"First connection error: {}\", e);\n                    first_complete = true;\n                }\n            }\n        }\n        if !second_complete {\n            match read_data(&mut second_connection, &mut second_buf, second_bytes_read) {\n                Ok((bytes_read, false)) => {\n                    second_bytes_read = bytes_read;\n                }\n                Ok((bytes_read, true)) => {\n                    println!(\"Second connection completed\");\n                    if bytes_read != 0 {\n                        parse_data(&second_buf, bytes_read);\n                    }\n                    second_complete = true;\n                }\n                Err(e) => {\n                    println!(\"Second connection error: {}\", e);\n                    second_complete = true;\n                }\n            }\n        }\n        if first_complete && second_complete {\n            break;\n        }\n    }\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge_wasi_socket\ncd wasmedge_wasi_socket/nonblock_http_client/\n\n# Build the Rust Code\ncargo build --target wasm32-wasip1 --release\n# Use the AoT compiler for better performance\nwasmedge compile target/wasm32-wasip1/release/nonblock_http_client.wasm nonblock_http_client.wasm\n\n# Run the example\nwasmedge nonblock_http_client.wasm\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals Configuration\nDESCRIPTION: Example of adding, removing, and checking WebAssembly proposals in a WasmEdge Configure object. Shows how to create a configuration with specific proposals enabled or disabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\n// By default, the following proposals have turned on initially:\n// * IMPORT_EXPORT_MUT_GLOBALS\n// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS\n// * SIGN_EXTENSION_OPERATORS\n// * MULTI_VALUE\n// * BULK_MEMORY_OPERATIONS\n// * REFERENCE_TYPES\n// * SIMD\n// For the current WasmEdge version, the following proposals are supported:\n// * TAIL_CALL\n// * MULTI_MEMORIES\n// * THREADS\n// * EXTENDED_CONST\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n// The `is_bulkmem` will be `true`.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Host Data Example with WebAssembly Module\nDESCRIPTION: Example of using host data with a WebAssembly module. The host function can access external data through a pointer passed during function creation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_77\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                   const WasmEdge_CallingFrameContext *CallFrameCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                   0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                   /* Type section */\n                   0x01, 0x07, 0x01,\n                   /* function type {i32, i32} -> {i32} */}\n```\n\n----------------------------------------\n\nTITLE: Getting Results from Async Execution in WasmEdge Go API\nDESCRIPTION: Demonstrates how to retrieve results from asynchronous function execution in WasmEdge. Shows blocking until execution completes and handling returned values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Table Instance Management in C\nDESCRIPTION: Demonstrates creation and manipulation of table instances including setting limits, accessing data, and growing table size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(TabTypeCxt);\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Global Instances in WasmEdge\nDESCRIPTION: Demonstrates how to create and work with Global instances, including setting/getting values and retrieving global type information. Global instances store values accessible by both WASM modules and host applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n/* Create the global type with value type and mutation. */\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\n/* Create the global instance with value and global type. */\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n/* Delete the global type. */\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal`\n * and should __NOT__ be destroyed. */\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `ValType` will be `WasmEdge_ValType_I64`. */\nenum WasmEdge_Mutability ValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n/*\n * Set the value u64(888) to the global.\n * This function will do nothing if the value type mismatched or\n * the global mutability is `WasmEdge_Mutability_Const`.\n */\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n/* Get the value (888 now) of the global context. */\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Installing and Building WasmEdge-go Package\nDESCRIPTION: Installs the WasmEdge-go package and builds it in the Go project directory, specifying the version to match WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/intro.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\ngo build\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules with Exported Names\nDESCRIPTION: This example shows how to register a WASM module with an exported module name in the WasmEdge VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  // The result status should be checked. The error will occur if the\n  // WASM module instantiation failed or the module name conflicts.\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for Simple WebAssembly Application with WasmEdge\nDESCRIPTION: Dockerfile configuration to run a simple WebAssembly application using the WasmEdge runtime in a slim Docker container. It uses wasmedge/slim-runtime as the base image and runs a WASI example program with directory mapping.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_0\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-runtime:0.10.1\nADD wasi_example_main.wasm /\nCMD [\"wasmedge\", \"--dir\", \".:/\", \"/wasi_example_main.wasm\"]\n```\n\n----------------------------------------\n\nTITLE: Host Function Type Definition in C\nDESCRIPTION: Defines the function signature type for host functions in WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Creating Function Type and Context in Go\nDESCRIPTION: Example of creating a WasmEdge function type and context for host functions with proper memory management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_63\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an module instance object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader Context to Parse WASM Modules\nDESCRIPTION: Demonstrates how to use the WasmEdge Loader context to parse WASM modules from files or buffers. It shows error handling and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Listing and Getting Registered Modules in WasmEdge C API\nDESCRIPTION: Shows how to list all registered modules in a VM context and retrieve a specific registered module (such as WASI) by name. Useful for accessing host-provided modules and their functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `VMCxt` is created.\n */\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the registered module names in the VM context. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Information in Go\nDESCRIPTION: Example of querying imports and exports from an AST object. Shows how to list and iterate through module imports and exports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Module from Buffer in WasmEdge\nDESCRIPTION: Shows how to load and link a WASM module from a memory buffer using WasmEdge_VMRegisterModuleFromBuffer. Includes buffer initialization and module registration process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* The `lib.wasm` buffer example. */\n  uint8_t WASM[] = {0x00, 0x61, 0x73, 0x6D, /* ... */};\n\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* Register from buffer */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_VMRegisterModuleFromBuffer(VMCxt, ModuleName, WASM, sizeof(WASM));\n\n  /* Rest of implementation... */\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Global Instance Management in Go\nDESCRIPTION: Demonstrates global instance creation and value manipulation in WasmEdge, including setting/getting values and working with global types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_70\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in C\nDESCRIPTION: This C code snippet demonstrates how to configure various AOT compiler options in WasmEdge. It sets the optimization level, output format, enables dumping IR, enables generic binary generation, and enables interruptible execution in AOT mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`. */\n/* Set this option to `TRUE` to support the interruptible execution in AOT\nmode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Module Instance Management in WasmEdge C API\nDESCRIPTION: Demonstrates how to list and find exported instances from a WasmEdge module instance. Shows usage of functions to list exported functions and find specific functions by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Creating WasmEdge VM Instances with Different Configurations\nDESCRIPTION: Go code demonstrating various ways to create WasmEdge VM instances with different configurations and store objects. It shows how to use default settings or specify custom configure and store objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Wrapping Strings with the C API\nDESCRIPTION: This C code snippet demonstrates how to wrap a C string into a `WasmEdge_String` object using `WasmEdge_StringWrap`.  It's crucial to note that the `WasmEdge_String` object created using `WasmEdge_StringWrap` does not own the underlying buffer, and the caller is responsible for managing the lifetime of the C string.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n\"const char CStr[] = \\\"test\\\";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */\"\n```\n\n----------------------------------------\n\nTITLE: Listing Registered Modules in Store in Go\nDESCRIPTION: Shows how to list the names of registered WASM modules using the Store object. It creates a Store, assumes modules are registered, then lists and prints the names of the registered modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n// ...\n// Instantiate a WASM module via the `*wasmedge.Executor` object.\n// ...\n\n// Try to list the registered WASM modules.\nmodnames := store.ListModule()\nfor _, name := range modnames {\n  fmt.Println(\"Registered module names:\", name)\n}\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating WASI Module Instance in WasmEdge\nDESCRIPTION: This code demonstrates creating a WASI module instance, registering it with a VM context, and retrieving the exit code. WASI module instance provides the WebAssembly System Interface functionality for interacting with the host system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_73\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\n```\n\n----------------------------------------\n\nTITLE: Limiting Maximum Memory Pages in Go\nDESCRIPTION: This snippet allows developers to set a limit on the maximum number of memory pages for the `Executor` and `VM` objects. It guides through the process of retrieving and setting memory page sizes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\npagesize := conf.GetMaxMemoryPage()\n// By default, the maximum memory page size in each memory instances is 65536.\nconf.SetMaxMemoryPage(1234)\npagesize := conf.GetMaxMemoryPage()\n// `pagesize` will be 1234.\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing HKDF Key Derivation in WASI-Crypto\nDESCRIPTION: Example demonstrating the use of HKDF (HMAC-based Key Derivation Function) to generate and expand cryptographic keys using SHA-512.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasicrypto.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet key = HkdfKey::generate(\"HKDF-EXTRACT/SHA-512\")?;\nlet prk = Hkdf::new(\"HKDF-EXPAND/SHA-512\", &key, Some(b\"salt\"))?;\nlet derived_key = prk.expand(\"info\", 100)?;\nassert_eq!(derived_key.len(), 100);\n```\n\n----------------------------------------\n\nTITLE: Function Type Context Usage in C\nDESCRIPTION: Demonstrates creation and manipulation of Function Type context for managing WASM function signatures. Shows how to create function types with parameters and return values, and query their properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Function Type Context\nDESCRIPTION: Shows how to create and manipulate function type contexts, including setting parameter and return value types, and retrieving type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating VM with Custom Store Context in WasmEdge (C)\nDESCRIPTION: Shows how to create a VM context with a custom Store context. When using a custom Store, developers must manage its lifecycle separately from the VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Table Instance in WasmEdge C API\nDESCRIPTION: Creating a table instance with FuncRef type and limits, then adding it to a module instance. The table has a minimum size of 10 references and a maximum of 20.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TableLimit = {\n   .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n   WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n   WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n```\n\n----------------------------------------\n\nTITLE: Non-blocking Connection Handler in Rust\nDESCRIPTION: Asynchronous connection handler function that processes incoming data from TCP connections\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/server.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn handle_connection_read(connection: &mut TcpStream) -> io::Result<bool> {\n    let mut connection_closed = false;\n    let mut received_buff = [0u8; 2048];\n\n    let mut received_data = Vec::with_capacity(2048);\n    loop {\n        match connection.read(&mut received_buff) {\n            Ok(0) => {\n                connection_closed = true;\n                break;\n            }\n            Ok(n) => {\n                received_data.extend_from_slice(&received_buff[0..n]);\n            }\n            Err(ref err) if would_block(err) => break,\n            Err(ref err) if interrupted(err) => continue,\n            Err(err) => return Err(err),\n        }\n    }\n\n    if !received_data.is_empty() {\n        if let Ok(str_buf) = std::str::from_utf8(&received_data) {\n            println!(\"Received data: {}\", str_buf.trim_end());\n        } else {\n            println!(\"Received (none UTF-8) data: {:?}\", received_data);\n        }\n    }\n\n    if connection_closed {\n        return Ok(true);\n    }\n\n    Ok(false)\n}\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Export Types in Go\nDESCRIPTION: Demonstrates handling export type contexts for accessing WebAssembly module export information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Modules with WasmEdge Loader in Go\nDESCRIPTION: Demonstrates how to use the WasmEdge Loader to load WASM modules from files or buffers. It shows configuration options and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from a WasmEdge Plugin\nDESCRIPTION: Lists available host modules in a plugin and creates a module instance from one of them. This demonstrates how to use the capabilities provided by a WasmEdge plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_87\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/*\n * Will print here for the WASI-Crypto plug-in here:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct for Database Table (Rust)\nDESCRIPTION: This snippet defines a Rust struct named `Order` to represent the structure of the `orders` table in the PostgreSQL database.  It includes fields such as `order_id`, `production_id`, `quantity`, `amount`, `shipping`, `tax`, and `shipping_address`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/postgres_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Order {\n    order_id: i32,\n    production_id: i32,\n    quantity: i32,\n    amount: f32,\n    shipping: f32,\n    tax: f32,\n    shipping_address: String,\n}\n\nimpl Order {\n    fn new(\n        order_id: i32,\n        production_id: i32,\n        quantity: i32,\n        amount: f32,\n        shipping: f32,\n        tax: f32,\n        shipping_address: String,\n    ) -> Self {\n        Self {\n            order_id,\n            production_id,\n            quantity,\n            amount,\n            shipping,\n            tax,\n            shipping_address,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Statistics Context for Instruction Counting in WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to create a Statistics context to track instruction execution counts and performance metrics in WasmEdge, including getting instruction count and instructions per second after execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module Instance in Go\nDESCRIPTION: Demonstrates how to instantiate and register an AST object as a named Module instance using the Executor and Store objects. Includes creation of statistics, executor, and store objects with proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_46\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, res := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge Go SDK\nDESCRIPTION: Go code showing how to register host modules (import objects) into a VM instance using the WasmEdge Go SDK, specifically demonstrating the registration of a WASI host module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)\n\nres := vm.RegisterImport(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating VM Context without Store in C\nDESCRIPTION: This snippet demonstrates how to create a VM context that allocates and owns a Store context automatically, and the proper deletion of the VM context without requiring deletion of the Store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Handling User-Defined Error Codes in Host Functions for WasmEdge\nDESCRIPTION: Illustrates how to use user-defined error codes in host functions and retrieve them in the main program. The example includes a simple WASM module and a Go program that executes it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_75\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x05, 0x01,\n    /* function type {i32} -> {} */\n    0x60, 0x01, 0x7F, 0x00,\n    /* Import section */\n    0x02, 0x0F, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x08, 0x01,\n    /* export name: \"trap\" */\n    0x04, 0x74, 0x72, 0x61, 0x70,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x08, 0x01,\n    /* code body */\n    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})\n  hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"trap\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  _, err := vm.RunWasmBuffer(wasmbuf, \"trap\", uint32(5566))\n  if err != nil {\n    fmt.Println(\"Get the error code:\", err.GetCode())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Function Context Creation\nDESCRIPTION: Shows how to create a function context with host function body and function type in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\nWasmEdge_FunctionTypeDelete(HostType);\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Implementing File Reader in Rust for WebAssembly\nDESCRIPTION: A Rust program that reads lines from a file and provides interactive line access through STDIN. The program takes a filename as an argument, reads its contents into memory, and allows users to request specific lines by number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/app.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs::File;\nuse std::io::{self, BufRead};\n\nfn main() {\n  // Get the argv.\n  let args: Vec<String> = env::args().collect();\n  if args.len() <= 1 {\n    println!(\"Rust: ERROR - No input file name.\");\n    return;\n  }\n\n  // Open the file.\n  println!(\"Rust: Opening input file \\\"{}\\\"\", args[1]);\n  let file = match File::open(&args[1]) {\n    Err(why) => {\n      println!(\"Rust: ERROR - Open file \\\"{}\\\" failed: {}\", args[1], why);\n      return;\n    },\n    Ok(file) => file,\n  };\n\n  // Read lines.\n  let reader = io::BufReader::new(file);\n  let mut texts:Vec<String> = Vec::new();\n  for line in reader.lines() {\n    if let Ok(text) = line {\n      texts.push(text);\n    }\n  }\n  println!(\"Rust: Read input file \\\"{}\\\" succeeded.\", args[1]);\n\n  // Get stdin to print lines.\n  println!(\"Rust: Please input the line number to print the line of file.\");\n  let stdin = io::stdin();\n  for line in stdin.lock().lines() {\n    let input = line.unwrap();\n    match input.parse::<usize>() {\n      Ok(n) => if n > 0 && n <= texts.len() {\n        println!(\"{}\", texts[n - 1]);\n      } else {\n        println!(\"Rust: ERROR - Line \\\"{}\\\" is out of range.\", n);\n      },\n      Err(e) => println!(\"Rust: ERROR - Input \\\"{}\\\" is not an integer: {}\", input, e),\n    }\n  }\n  println!(\"Rust: Process end.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Shows how to execute functions in registered WASM modules using the WasmEdge VM API. It covers registering a module, preparing parameters, executing a function, and handling the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n   * name \"mod\". As the same as host functions, other modules can import the\n   * function `\"mod\" \"fib\"`.\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                     Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Reference Types using C API\nDESCRIPTION: This C code demonstrates how to generate and manipulate `WasmEdge_Value` objects for reference types (`funcref` and `externref`). It shows how to create null references, get function instances, and create references to data, as well as retrieving the referenced values using functions like `WasmEdge_ValueGenNullRef()`, `WasmEdge_ValueIsNullRef()`, `WasmEdge_ValueGetExternRef()`, `WasmEdge_ValueGenFuncRef()`, and `WasmEdge_ValueGetFuncRef()`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n\"WasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\n/* Generate a externref to NULL. */\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\n/* The `IsNull` will be `TRUE`. */\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `NULL`. */\n\n/* Get the function instance by creation or from module instance. */\nconst WasmEdge_FunctionInstanceContext *FuncCxt = ...;\n/* Generate a funcref with the given function instance context. */\nVal = WasmEdge_ValueGenFuncRef(FuncCxt);\nconst WasmEdge_FunctionInstanceContext *GotFuncCxt =\n    WasmEdge_ValueGetFuncRef(Val);\n/* The `GotFuncCxt` will be the same as `FuncCxt`. */\n\n/* Generate a externref to `Num`. */\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `&Num`. */\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \\\"10\\\" */\nNum += 55;\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \\\"65\\\" */\"\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-Crypto Dependencies in Rust\nDESCRIPTION: Cargo.toml configuration for including the WASI-crypto binding dependency in a Rust project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasicrypto.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasi-crypto = \"0.1.5\"\n```\n\n----------------------------------------\n\nTITLE: Using NPM Modules in JavaScript\nDESCRIPTION: Example of importing and using third-party NPM modules (md5 and mathjs) in JavaScript code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/npm.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst md5 = require('md5');\nconsole.log('md5(message)=', md5('message'));\n\nconst { sqrt } = require('mathjs');\nconsole.log('sqrt(-4)=', sqrt(-4).toString());\n```\n\n----------------------------------------\n\nTITLE: Handling Reference Types in WasmEdge C API\nDESCRIPTION: This snippet illustrates how to work with reference types (funcref and externref) using the WasmEdge C API, including creating null references and external references.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\n/* Generate a externref to NULL. */\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\n/* The `IsNull` will be `TRUE`. */\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `NULL`. */\n\n/* Get the function instance by creation or from module instance. */\nconst WasmEdge_FunctionInstanceContext *FuncCxt = ...;\n/* Generate a funcref with the given function instance context. */\nVal = WasmEdge_ValueGenFuncRef(FuncCxt);\nconst WasmEdge_FunctionInstanceContext *GotFuncCxt =\n    WasmEdge_ValueGetFuncRef(Val);\n/* The `GotFuncCxt` will be the same as `FuncCxt`. */\n\n/* Generate a externref to `Num`. */\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `&Num`. */\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \"10\" */\nNum += 55;\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \"65\" */\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Shows how to register host modules into a WasmEdge VM context. It demonstrates creating a VM, creating a WASI module instance, and registering it with the VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n  WasmEdge_ModuleInstanceCreateWASI( /* ... ignored ... */ );\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/* The created module instances should be deleted by the developers when the VM deallocation. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Global Instance in WasmEdge\nDESCRIPTION: This snippet demonstrates creating a global type context, global instance with an initial i32 value, and adding it to a module instance. The global is mutable (var) with an initial value of 666.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions\nDESCRIPTION: Example of accessing memory from a host function using the calling frame context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                             const WasmEdge_CallingFrameContext *CallFrameCxt,\n                             const WasmEdge_Value *In, WasmEdge_Value *Out) {\n    uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n    uint32_t Num = 0;\n    WasmEdge_MemoryInstanceContext *MemCxt =\n        WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n    WasmEdge_Result Res =\n        WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n    if (WasmEdge_ResultOK(Res)) {\n      printf(\"u32 at memory[%lu]: %lu\\n\", Offset, Num);\n    } else {\n      return Res;\n    }\n    return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Import Type Context in C\nDESCRIPTION: Shows how to use an Import Type context in WasmEdge to retrieve information about imports from an AST Module. It demonstrates querying external types, module names, and specific type contexts based on the external type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/*\n * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the\n * result of loading a WASM file.\n */\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\n/*\n * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,\n * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or\n * `WasmEdge_ExternalType_Global`.\n */\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\n/*\n * The `ModName` and `ExtName` should not be destroyed and the string\n * buffers are binded into the `ASTCxt`.\n */\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the\n * `FuncTypeCxt` will be NULL.\n */\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`\n * will be NULL.\n */\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plug-ins\nDESCRIPTION: Demonstrates how to list available modules in a plug-in and create a module instance from it. The example uses the WASI-Crypto plug-in to create a module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_82\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/*\n * Will print here for the WASI-Crypto plug-in here:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Getting Return Value Length in WasmEdge (C)\nDESCRIPTION: This code demonstrates how to obtain the length of the return value list from an asynchronous execution using `WasmEdge_AsyncGetReturnsLength()`. This function blocks until the execution completes. The returned length can be used to allocate a buffer for retrieving the return values. It returns 0 if the execution failed.  The allocated `WasmEdge_Async` must be deleted by calling `WasmEdge_AsyncDelete()`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Path\nDESCRIPTION: API for loading WasmEdge plugins from specified paths or default locations. If no path is provided, it checks environment variables and standard installation directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl PluginManager\npub fn load(path: Option<&Path>) -> WasmEdgeResult<()>\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge with Go\nDESCRIPTION: This snippet demonstrates configuring various AOT (Ahead of Time) compiler options in WasmEdge using Go. It includes optimization levels and output format customization. This example assumes the presence of the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the optimization level is O3.\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n// By default, the output format is universal WASM.\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n// By default, the dump IR is `false`.\nconf.SetCompilerDumpIR(true)\n// By default, the generic binary is `false`.\nconf.SetCompilerGenericBinary(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI Pre-registration in WasmEdge VM\nDESCRIPTION: Demonstrates how to enable WASI support in WasmEdge by configuring the VM context with the WASI host registration, retrieving the pre-registered import object, and initializing WASI functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration import objects from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ImportObjectContext *WasiObject =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering Modules with Executor in C\nDESCRIPTION: Demonstrates how to register WASM modules and import objects using the Executor context. It creates necessary contexts, registers a WASM module with a name, and registers an import object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nRes = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_ImportObjectContext *ImpCxt = ...;\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Import object registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\nWasmEdge_ImportObjectDelete(ImpCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plug-ins (Go)\nDESCRIPTION: Shows how to load WasmEdge plug-ins from default paths and retrieve registered modules in the VM, including built-in WASI and plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\n// Load the plug-ins in the default paths first.\nwasmedge.LoadPluginDefaultPaths()\n\n// Create the VM object with the WASI configuration.\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.\n// This API will return `NULL` if the module instance not found.\n\n// The `wasimodule` will not be `nil` because the configuration was set.\nwasimodule := vm.GetRegisteredModule(\"wasi_snapshot_preview1\")\n\n// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.\nwasinnmodule := vm.GetRegisteredModule(\"wasi_ephemeral_nn\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Host Tables, Memories, and Globals - WasmEdge C\nDESCRIPTION: Shows how to create host tables, memories, and global instances with specific properties and register them into the WasmEdge runtime. The example covers creating type contexts and instance contexts, setting limits, and cleaning up resources after use.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Create a host table exported as \"table\". */\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\n\n/* Create a host memory exported as \"memory\". */\nWasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\n\n/* Create a host global exported as \"global_i32\" and initialized as `666`. */\nWasmEdge_GlobalTypeContext *HostGType =\n    WasmEdge_GlobalTypeCreate(WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Const);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\n```\n\n----------------------------------------\n\nTITLE: Implementing String Handling in Rust for WebAssembly\nDESCRIPTION: This Rust code defines functions for allocating memory, deallocating memory, and greeting a subject. It demonstrates how to handle string data in WebAssembly, including memory management and C-style string conversion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ffi::{CStr, CString};\nuse std::mem;\nuse std::os::raw::{c_char, c_void};\n\n#[no_mangle]\npub extern fn allocate(size: usize) -> *mut c_void {\n  let mut buffer = Vec::with_capacity(size);\n  let pointer = buffer.as_mut_ptr();\n  mem::forget(buffer);\n\n  pointer as *mut c_void\n}\n\n#[no_mangle]\npub extern fn deallocate(pointer: *mut c_void, capacity: usize) {\n  unsafe {\n    let _ = Vec::from_raw_parts(pointer, 0, capacity);\n  }\n}\n\n#[no_mangle]\npub extern fn greet(subject: *mut c_char) -> *mut c_char {\n  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };\n  let mut output = b\"Hello, \".to_vec();\n  output.extend(&subject);\n  output.extend(&[b'!']);\n\n  unsafe { CString::from_vec_unchecked(output) }.into_raw()\n}\n```\n\n----------------------------------------\n\nTITLE: eBPF Host Functions Interface\nDESCRIPTION: C function declarations for the eBPF host functions provided by the plugin, including map operations and program management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/ebpf.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/// lookup a bpf map fd by name.\ni32 wasm_bpf_map_fd_by_name(u64 obj, u32 name);\n/// detach and close a bpf program.\ni32 wasm_close_bpf_object(u64 obj);\n/// CO-RE load a bpf object into the kernel.\nu64 wasm_load_bpf_object(u32 obj_buf, u32 obj_buf_sz);\n/// attach a bpf program to a kernel hook.\ni32 wasm_attach_bpf_program(u64 obj, u32 name,\n                            u32 attach_target);\n/// poll a bpf buffer, and call a wasm callback indicated by sample_func.\n/// the first time to call this function will open and create a bpf buffer.\ni32 wasm_bpf_buffer_poll(u64 program, i32 fd, u32 sample_func,\n                         u32 ctx, u32 data, i32 max_size,\n                         i32 timeout_ms);\n/// lookup, update, delete, and get_next_key operations on a bpf map.\ni32 wasm_bpf_map_operate(u64 fd, i32 cmd, u32 key, u32 value,\n                         u32 next_key, u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using GlobalType in WasmEdge Go SDK\nDESCRIPTION: Demonstrates the creation and usage of GlobalType objects for defining global variables in WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Time-Limited Execution with Cancellation in WasmEdge C API\nDESCRIPTION: Shows how to wait for asynchronous execution with a time limit, check if it completed, and handle both success and timeout scenarios. For interruptible AOT execution, developers must configure the compiler appropriately.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Proposal Configuration in C\nDESCRIPTION: Demonstrates managing WebAssembly proposals in WasmEdge configuration. Shows how to enable and disable specific proposals.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Exported Function List Implementation\nDESCRIPTION: Example implementation showing how to load a WASM module and list its exported functions using WasmEdge Go API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Store Management in WasmEdge VM\nDESCRIPTION: Demonstrates how to create and manage Store objects within a WasmEdge VM instance. Shows both automatic and manual store management approaches.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nstore := vm.GetStore()\n// The object should __NOT__ be deleted by calling `(*Store).Release`.\nvm.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvm := wasmedge.NewVMWithStore(store)\n\nstoremock := vm.GetStore()\n// The internal store context of the `store` and the `storemock` are the same.\n\nvm.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Waiting with Timeout and Cancelling in WasmEdge\nDESCRIPTION: This code shows how to wait for asynchronous execution with a timeout using `WasmEdge_AsyncWaitFor`. If the timeout expires, the execution can be cancelled using `WasmEdge_AsyncCancel`. `WasmEdge_ConfigureCompilerSetInterruptible()` should be set to `TRUE` in configure context for interruptible AOT execution. After cancellation, an error code `WasmEdge_ErrCode_Interrupted` will be returned.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Simple Hello World Application in Rust for WasmEdge\nDESCRIPTION: A basic standalone Rust application that prints 'Hello WasmEdge!' to the console. This demonstrates the simplest possible WasmEdge application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let s : &str = \"Hello WasmEdge!\";\n  println!(\"{}\", s);\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Complete example showing how to execute functions from registered WASM modules. Includes module registration, function execution, and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n  */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n  * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module name \"mod\".\n  * As the same as host functions, other modules can import the function `\"mod\" \"fib\"`.\n  */\n\n  /*\n  * Execute WASM functions in registered modules.\n  * Unlike the execution of functions, the registered functions can be invoked without\n  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.\n  * Developers can also invoke the host functions directly with this API.\n  */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Specific Plug-ins from Path in Go\nDESCRIPTION: This snippet illustrates loading a specific WasmEdge plug-in from a defined path using the `LoadPluginFromPath` method. It allows developers to specify the exact location of the plug-in they wish to load.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginFromPath(\"PATH_TO_PLUGIN/plugin.so\")\n```\n\n----------------------------------------\n\nTITLE: AOT Compiler Options Configuration\nDESCRIPTION: Defines compiler optimization levels and output formats, and demonstrates how to configure AOT compiler settings\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n)\n\nconf := wasmedge.NewConfigure()\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Functions in WebAssembly Entering Module\nDESCRIPTION: This WebAssembly module imports the 'add' and 'mul' functions from the library module and uses them to create two new exported functions: 'add_and_square' and 'sum_of_squares'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_1\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $type0 (func (param i32 i32)(result i32)))\n  ;; Import the \"add\" function which calculate \"a + b\".\n  (import \"math\" \"add\" (func $math-add (type $type0)))\n  ;; Import the \"mul\" function which calculate \"a * b\".\n  (import \"math\" \"mul\" (func $math-mul (type $type0)))\n  (func (export \"add_and_square\") (param i32 i32) (result i32)\n    ;; Function to add 2 numbers and square it ((a + b)^2).\n    ;; Exported as \"add_and_square\".\n    (call $math-mul\n      (call $math-add (local.get 0) (local.get 1))\n      (call $math-add (local.get 0) (local.get 1))\n    )\n  )\n  (func (export \"sum_of_squares\") (param i32 i32) (result i32)\n    ;; Function to calculate the sum of squares (a^2 + b^2).\n    ;; Exported as \"sum_of_squares\".\n    (call $math-add\n      (call $math-mul (local.get 0) (local.get 0))\n      (call $math-mul (local.get 1) (local.get 1))\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Validator Context in C\nDESCRIPTION: Example showing how to use the WasmEdge Validator context to validate a WebAssembly module before instantiation. Validation is a required step to ensure the module meets WebAssembly specifications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Setting Cost Table for Instructions in C\nDESCRIPTION: This snippet illustrates how to create a cost table for instructions and set it within the statistics context to control execution limits based on estimated costs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n    0, 0,\n    10, /* 0x02: Block */\n    11, /* 0x03: Loop */\n    12, /* 0x04: If */\n    12, /* 0x05: Else */\n    0, 0, 0, 0, 0, 0,\n    20, /* 0x0C: Br */\n    21, /* 0x0D: Br_if */\n    22, /* 0x0E: Br_table */\n    0\n};\n/*\n * Developers can set the costs of each instruction. The value not\n * covered will be 0.\n */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Statistics Context in C\nDESCRIPTION: This snippet demonstrates the process of creating a WasmEdge_StatisticsContext for profiling WASM performance by counting instructions executed. It retrieves counts and instructions per second after WASM execution. Requires WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining Plug-in and Module Descriptors for WasmEdge\nDESCRIPTION: C code that defines the descriptors for the plug-in and its module. These descriptors contain metadata like name, description, version, and function pointers for creating instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/* The module descriptor array. There can be multiple modules in a plug-in. */\nstatic WasmEdge_ModuleDescriptor ModuleDesc[] = {{\n    /*\n     * Module name. This is the name for searching and creating the module\n     * instance context by the `WasmEdge_PluginCreateModule()` API.\n     */\n    .Name = \"wasmedge_plugintest_c_module\",\n    /* Module description. */\n    .Description = \"This is for the plugin tests in WasmEdge C API.\",\n    /* Creation function pointer. */\n    .Create = CreateTestModule,\n}};\n\n/* The plug-in descriptor */\nstatic WasmEdge_PluginDescriptor Desc[] = {{\n    /*\n     * Plug-in name. This is the name for searching the plug-in context by the\n     * `WasmEdge_PluginFind()` API.\n     */\n    .Name = \"wasmedge_plugintest_c\",\n    /* Plug-in description. */\n    .Description = \"\",\n    /* Plug-in API version. */\n    .APIVersion = WasmEdge_Plugin_CurrentAPIVersion,\n    /* Plug-in version. Developers can define the version of this plug-in. */\n    .Version =\n        {\n            .Major = 0,\n            .Minor = 1,\n            .Patch = 0,\n            .Build = 0,\n        },\n    /* Module count in this plug-in. */\n    .ModuleCount = 1,\n    /* Plug-in option description count in this plug-in (Work in progress). */\n    .ProgramOptionCount = 0,\n    /* Pointer to the module description array. */\n    .ModuleDescriptions = ModuleDesc,\n    /* Pointer to the plug-in option description array (Work in progress). */\n    .ProgramOptions = NULL,\n}};\n```\n\n----------------------------------------\n\nTITLE: Registering Modules with Executor in Go\nDESCRIPTION: Demonstrates how to register WASM modules and import objects into a Store using the Executor. It covers creating necessary objects, registering a WASM AST, and registering an import object for host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Register the loaded WASM `ast` into store with the export module name \"mod\".\nres := executor.RegisterModule(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\n// Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.\nimpobj := ...\nerr = executor.RegisterImport(store, impobj)\nif err != nil {\n  fmt.Println(\"Import object registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nimpobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Get Components from WasmEdge VM in Go\nDESCRIPTION: This code snippet retrieves the Loader, Validator, and Executor objects from a WasmEdge VM. These components are used internally by the VM, and this code demonstrates how to access them directly. The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\nloader := vm.GetLoader()\n// Developers should __NOT__ call the `(*Loader).Release` function of the returned object.\nvalidator := vm.GetValidator()\n// Developers should __NOT__ call the `(*Validator).Release` function of the returned object.\nexecutor := vm.GetExecutor()\n// Developers should __NOT__ call the `(*Executor).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Creating Host Function Instance\nDESCRIPTION: Example of creating a function instance with type context for adding to a host module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n  * Create a function context with the function type and host function body.\n  * The `Cost` parameter can be 0 if developers do not need the cost\n  * measuring.\n  */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n  * The third parameter is the pointer to the additional data.\n  * Developers should guarantee the life cycle of the data, and it can be NULL if the external data is not needed.\n  */\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Plug-ins and Error Messages in Go\nDESCRIPTION: This snippet demonstrates how to handle scenarios where a required plug-in is not installed. It includes initializing the VM context and attempting to retrieve module instances, showcasing how WasmEdge manages missing plug-ins with built-in mock implementations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// Load the plug-ins in the default paths first.\nwasmedge.LoadPluginDefaultPaths()\n\n// Create the VM object with the WASI configuration.\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.\n// This API will return `NULL` if the module instance not found.\n// The `wasimodule` will not be `nil` because the configuration was set.\nwasimodule := vm.GetRegisteredModule(\"wasi_snapshot_preview1\")\n\n// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.\nwasinnmodule := vm.GetRegisteredModule(\"wasi_ephemeral_nn\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version using C API\nDESCRIPTION: Demonstrates how to retrieve and print the WasmEdge version and its components using the C API functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Implementation in WebAssembly Text Format\nDESCRIPTION: WebAssembly module that implements a recursive Fibonacci number calculator function exported as 'fib'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_28\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Loading and Using WasmEdge Plug-ins\nDESCRIPTION: This code shows how to load WasmEdge plug-ins from default paths, create a VM with WASI configuration, and retrieve registered module instances including built-in WASI and plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the registered modules in the VM context,\n * includes the built-in WASI and the plug-ins.\n */\n/*\n * This API will return `NULL` if the module instance not found.\n */\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/*\n * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n * installed, because the VM context will mock and register the host\n * modules.\n */\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring Cost Table and Limits in WasmEdge\nDESCRIPTION: Example showing how to set instruction cost weights and cost limits for execution. This allows limiting execution based on accumulated instruction costs and can terminate execution when the cost limit is exceeded.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_29\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0,\n}\n// Developers can set the costs of each instruction. The value not covered will be 0.\n\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\n\n// ... After running the WASM functions with the `Statistics` object\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types by Name in WasmEdge (C)\nDESCRIPTION: Demonstrates how to retrieve a function type by name from an instantiated WASM module. This allows inspection of function signatures without invoking them.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function Using Calling Frame in Go for WasmEdge\nDESCRIPTION: Demonstrates how to use the CallingFrame object to access memory in a host function. The function retrieves a 32-bit unsigned integer from memory at a specified offset.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_74\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"encoding/binary\"\n  \"fmt\"\n)\n\n// Host function body definition.\nfunc LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // Function type: {i32} -> {}\n  offset := params[0].(int32)\n\n  // Get the 0th memory instance of the module of the top frame on the stack.\n  mem := callframe.GetMemoryByIndex(0)\n\n  data, err := mem.GetData(uint(offset), 4)\n  if err != nil {\n    return nil, err\n  }\n  fmt.Println(\"u32 at memory[{}]: {}\", offset, binary.LittleEndian.Uint32(data))\n  return nil, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Table Type Context in C\nDESCRIPTION: Shows how to create a Table Type context with a specified reference type and limit, and retrieve information from it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Lambda Handler Function - JavaScript\nDESCRIPTION: AWS Lambda handler function that processes incoming requests, manages CORS headers, and returns the processed image data\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexports.handler = async function (event, context) {\n  var typedArray = new Uint8Array(\n    event.body.match(/[\\da-f]{2}/gi).map(function (h) {\n      return parseInt(h, 16);\n    }),\n  );\n  let buf = await _runWasm(typedArray);\n  return {\n    statusCode: 200,\n    headers: {\n      'Access-Control-Allow-Headers':\n        'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods':\n        'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT',\n    },\n    body: buf.toString('hex'),\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Working with MemoryType in WasmEdge Go API\nDESCRIPTION: Demonstrates creating and using MemoryType objects for defining WASM memory instances with specific limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Types using WasmEdge VM Context in C\nDESCRIPTION: This snippet demonstrates how to retrieve the function types of instantiated WASM modules using the WasmEdge VM context. After ensuring a WASM module is instantiated, you can find function type information by name. This can be useful for analyzing functions in runtime. If the function is not found, the API returns NULL. Developers should not destroy returned function type contexts. Dependencies include the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\n/*\\n * ...\\n * Assume that a WASM module is instantiated in `VMCxt`.\\n */\\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\\nconst WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);\\n/*\\n * Developers can get the function types of functions in the registered modules\\n * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.\\n * If the function is not found, these APIs will return `NULL`.\\n * The returned function type contexts should __NOT__ be destroyed.\\n */\\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Command Line Arguments Processing in Rust\nDESCRIPTION: Rust code snippet showing how to read and process command line arguments for model and image file names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet args: Vec<String> = env::args().collect();\nlet model_bin_name: &str = &args[1]; // File name for the TFLite model\nlet image_name: &str = &args[2]; // File name for the input image\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions\nDESCRIPTION: Example program demonstrating how to load a WASM module and list its exported functions using the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a React Component with Lazy Loading - JavaScript\nDESCRIPTION: This snippet defines a React component, LazyHome, which utilizes React's lazy loading feature to asynchronously load a child component after a delay. The sleep function simulates a loading delay before the LazyPage component is rendered.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { Suspense } from 'react';\nimport * as LazyPage from './LazyPage.jsx';\n\nasync function sleep(ms) {\n  return new Promise((r, _) => {\n    setTimeout(() => r(), ms);\n  });\n}\n\nasync function loadLazyPage() {\n  await sleep(2000);\n  return LazyPage;\n}\n\nclass LazyHome extends React.Component {\n  render() {\n    let LazyPage1 = React.lazy(() => loadLazyPage());\n    return (\n      <html lang=\"en\">\n        <head>\n          <meta charSet=\"utf-8\" />\n          <title>Title</title>\n        </head>\n        <body>\n          <div>\n            <div> This is LazyHome </div>\n            <Suspense fallback={<div> loading... </div>}>\n              <LazyPage1 />\n            </Suspense>\n          </div>\n        </body>\n      </html>\n    );\n  }\n}\n\nexport default LazyHome;\n```\n\n----------------------------------------\n\nTITLE: Creating Memory Instance in WasmEdge\nDESCRIPTION: This code creates a memory type context, memory instance, and adds it to a module instance with specified memory limits. The memory has a minimum size of 1 page and maximum size of 2 pages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemoryLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n    WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n```\n\n----------------------------------------\n\nTITLE: Managing Table Instances in WasmEdge Go\nDESCRIPTION: Illustrates the creation and manipulation of table instances, including setting and getting data, growing the table, and handling errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_65\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Querying Imports and Exports from an AST Module in C\nDESCRIPTION: Shows how to query the imports and exports of an AST Module context. This allows developers to inspect module requirements and available functions before instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/*\n * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be\n * accessed.\n */\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module in WasmEdge Executor\nDESCRIPTION: Demonstrates how to instantiate and register an AST module as a named Module instance using the Executor context. Creates necessary contexts and handles resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nRes = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Registering an AST Module as a Named Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate and register a WebAssembly AST module into a Store context as a named Module instance using the Executor API. The module can be linked when instantiating other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/*\n * Register the WASM module into the store with the export module name\n * \"mod\".\n */\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing Fibonacci WASM Function using WasmEdge in C\nDESCRIPTION: This C code snippet executes a WebAssembly function that calculates the Fibonacci sequence using WasmEdge VM context. Key dependencies include the WasmEdge library and a compiled WASM file named 'fibonacci.wasm'. The code sets up the VM, runs the designated Fibonacci function with integer input, and handles the result. Execution requires handling of basic WasmEdge contexts, and results in printing the calculated Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\\n#include <wasmedge/wasmedge.h>\\nint main() {\\n  /* Create the configure context and add the WASI support. */\\n  /* This step is not necessary unless you need WASI support. */\\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\\n                                         WasmEdge_HostRegistration_Wasi);\\n  /* The configure and store context to the VM creation can be NULL. */\\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\\n\\n  /* The parameters and returns arrays. */\\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};\\n  WasmEdge_Value Returns[1];\\n  /* Function name. */\\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\\\"fib\\\");\\n  /* Run the WASM function from file. */\\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(\\n      VMCxt, \\\"fibonacci.wasm\\\", FuncName, Params, 1, Returns, 1);\\n  /*\\n   * Developers can run the WASM binary from buffer with the\\n   * `WasmEdge_VMRunWasmFromBuffer()` API, or from\\n   * `WasmEdge_ASTModuleContext` object with the\\n   * `WasmEdge_VMRunWasmFromASTModule()` API.\\n   */\\n\\n  if (WasmEdge_ResultOK(Res)) {\\n    printf(\\\"Get the result: %d\\\\n\\\", WasmEdge_ValueGetI32(Returns[0]));\\n  } else {\\n    printf(\\\"Error message: %s\\\\n\\\", WasmEdge_ResultGetMessage(Res));\\n  }\\n\\n  /* Resources deallocations. */\\n  WasmEdge_VMDelete(VMCxt);\\n  WasmEdge_ConfigureDelete(ConfCxt);\\n  WasmEdge_StringDelete(FuncName);\\n  return 0;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Using Instruction Counter in WasmEdge Statistics with Go\nDESCRIPTION: This snippet explains how to use the instruction counter provided by the WasmEdge Statistics object in Go. It profiles WASM performance by counting instructions executed per second. This operation needs the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n// ... After running the WASM functions with the `Statistics` object\n\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge Go\nDESCRIPTION: This snippet shows how to register a WASM module with an exported module name in WasmEdge using Go. It demonstrates creating a VM instance and registering a WASM file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  // The result status should be checked. The error will occur if the\n  // WASM module instantiation failed or the module name conflicts.\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge Go SDK\nDESCRIPTION: Go code showing how to enable WASI (WebAssembly System Interface) support in a VM instance using the WasmEdge Go SDK, including retrieving and initializing the WASI import object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasiconf := conf.GetImportObject(wasmedge.WASI)\n// Initialize the WASI.\nwasiconf.InitWasi(/* ... ignored */)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge QuickJS from Source\nDESCRIPTION: Commands to clone and build the WasmEdge QuickJS runtime from source code\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# get the source code\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n\n# Build the QuickJS JavaScript interpreter\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Building and running the WasmEdge Go project\nDESCRIPTION: This snippet shows how to build and run the WasmEdge Go project, including getting the WasmEdge Go package.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposal Constants in Go\nDESCRIPTION: Constants representing WebAssembly proposals that can be enabled or disabled in WasmEdge. Each constant corresponds to a specific WebAssembly feature that may affect the runtime behavior.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)\n  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)\n  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n  EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)\n  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)\n  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n)\n```\n\n----------------------------------------\n\nTITLE: Running Go Application with Host Data Example\nDESCRIPTION: Commands to build and run the extended WasmEdge Golang example that demonstrates host data sharing between the Go application and WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_70\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge VM Context in C\nDESCRIPTION: This C code snippet demonstrates how to create a WasmEdge VM context with custom configuration and store contexts, retrieve statistics, and properly manage resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/* The VM context already contains the statistics context and can be retrieved by this API. */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs\n * should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Working with Import Type Context in C\nDESCRIPTION: Demonstrates querying and handling Import Type context for accessing WASM module import information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Go Dependency and Running Executable\nDESCRIPTION: Builds and runs a Go project that utilizes WasmEdge for WASM execution. First, it fetches the specific version of the WasmEdge Go library. Then, it builds the project and runs the compiled executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Creating Function Object with Host Function in WasmEdge Go\nDESCRIPTION: Demonstrates how to create a Function object in WasmEdge Go SDK. It includes creating a function type, instantiating the function with a host function body, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an module instance object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Exported Instances from Module in Go\nDESCRIPTION: Demonstrates how to list and find exported instances, specifically function instances, from a module instance after instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_63\n\nLANGUAGE: go\nCODE:\n```\n// List the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := mod.ListFunction()\n\n// Try to find the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncinst := mod.FindFunction(\"fib\")\n// `funcinst` will be `nil` if the function not found.\n// The returned instance is owned by the module instance and should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Managing Asynchronous Execution in WasmEdge Go\nDESCRIPTION: Demonstrates handling asynchronous execution results and timeout management in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Unified CLI Tool Implementation\nDESCRIPTION: Implementation of the unified WasmEdge CLI tool using C API, combining both runtime and compiler functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_91\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge unified tool. */\n  /* (Within both runtime and AOT compiler) */\n  return WasmEdge_Driver_UniTool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator\nDESCRIPTION: Example demonstrating how to validate a WASM module using the WasmEdge Validator context before instantiation. Shows proper error handling and resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly to Shared Library in Bash\nDESCRIPTION: Shows how to compile a WebAssembly file 'fibonacci.wasm' into a shared library 'fibonacci_aot.so' on Linux using the WasmEdge compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile fibonacci.wasm fibonacci_aot.so # On Linux.\n```\n\n----------------------------------------\n\nTITLE: Enabling Interpreter Mode in WasmEdge\nDESCRIPTION: This code snippet explains how to force the execution of WASM files or AOT compiled WASM files in interpreter mode using WasmEdge configuration. It highlights toggling the force-interpreter mode setting, relying on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_22\n\nLANGUAGE: Go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\nis_forceinterp := conf.IsForceInterpreter()\n// By default, the `is_forceinterp` will be `false`.\nconf.SetForceInterpreter(true)\nis_forceinterp = conf.IsForceInterpreter()\n/* The `is_forceinterp` will be `true`. */\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly to AOT Format with WasmEdge\nDESCRIPTION: Demonstrates how to use the WasmEdge AOT (ahead-of-time) compiler to compile a WASM file into a compiled format for faster execution. The AOT compiled file can be executed in the same way as the original WASM file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_88\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\",\n                               \"fibonacci-aot.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Default Paths\nDESCRIPTION: Demonstrates how to load WasmEdge plugins from default system paths using the plugin loading API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function using Calling Frame Context in C\nDESCRIPTION: Shows how to use the WasmEdge_CallingFrameContext to access the memory instance of the module instance on the top of the calling stack. This allows host functions to read and write data in the WebAssembly memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_77\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                             const WasmEdge_CallingFrameContext *CallFrameCxt,\n                             const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /*\n   * Get the 0-th memory instance of the module instance of the top frame on\n   * stack.\n   */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%lu]: %lu\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading JPEG Image into RGB32F\nDESCRIPTION: This Rust example loads and resizes a JPEG image to RGB32F format, capturing its pixel data into a 224x224 normalized floating-point vector for TensorFlow model compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet mut file_img = File::open(\"sample.jpg\").unwrap();\nlet mut img_buf = Vec::new();\nfile_img.read_to_end(&mut img_buf).unwrap();\nlet flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb32f(&img_buf, 224, 224);\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in WasmEdge\nDESCRIPTION: Example demonstrating how to enable instruction counting, cost measuring, and time measuring in WasmEdge. These settings affect both runtime and AOT compiler behavior in VM, Executor, and Compiler objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsInstructionCounting(true)\n// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsTimeMeasuring(true)\n// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsCostMeasuring(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge Results\nDESCRIPTION: Demonstrates handling WasmEdge_Result objects including success checking, error code retrieval, and custom result generation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be \"success\". */\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_WASM. */\n\nRes = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);\n/* Generate the user-defined result with code. */\nCode = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 123. */\nCategory = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */\n```\n\n----------------------------------------\n\nTITLE: Lambda Function Dockerfile Configuration\nDESCRIPTION: Dockerfile for packaging the WebAssembly function and its dependencies for AWS Lambda deployment. Uses the AWS Lambda Node.js base image.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_4\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM public.ecr.aws/lambda/nodejs:14\n\n# Change directory to /var/task\nWORKDIR /var/task\n\nRUN yum update -y && yum install -y curl tar gzip\n\n# Bundle and pre-compile the wasm files\nCOPY *.wasm ./\nCOPY pre.sh ./\nRUN chmod +x pre.sh\nRUN ./pre.sh\n\n# Bundle the JS files\nCOPY *.js ./\n\nCMD [ \"hello.handler\" ]\n```\n\n----------------------------------------\n\nTITLE: Table Instance Management in WasmEdge C API\nDESCRIPTION: Demonstrates creation and manipulation of table instances including setting data, growing table size, and accessing table elements. Shows error handling for out-of-bounds access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Input Validation in a WasmEdge Plugin Function\nDESCRIPTION: Example of input validation in a WasmEdge plugin function. This C function checks that the input parameters are of the expected type (I32) before processing them, which is essential for plugin security.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/best_practice.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                     const WasmEdge_Value *In, WasmEdge_Value *Out) {\n   if (In[0].Type != WasmEdge_ValType_I32 || In[1].Type != WasmEdge_ValType_I32) {\n   return WasmEdge_Result_Error;\n   }\n   // Rest of the function...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Pre-registration in WasmEdge\nDESCRIPTION: Demonstrates how to enable WASI support in WasmEdge VM by configuring and initializing the WASI module through the configuration context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                         WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions in C\nDESCRIPTION: This snippet illustrates how to load a WASM module from a file, validate it, instantiate it, and list its exported functions along with their names and information, demonstrating memory management with function types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the overflowed data will be discarded.\n   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Return Value Length from Asynchronous Execution in WasmEdge C API\nDESCRIPTION: Demonstrates how to get the length of return values from an asynchronous execution using WasmEdge_AsyncGetReturnsLength(). This function blocks until execution completes and returns the length to help allocate appropriate buffer size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using TableType in WasmEdge-go\nDESCRIPTION: Demonstrates how to create and use TableType objects that define WebAssembly table instances with reference types and limits. Shows how to retrieve table properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Validator Context in C\nDESCRIPTION: Example demonstrating the validation of a WebAssembly module using the WasmEdge Validator context. This step is required before module instantiation to ensure the WASM module meets specification requirements.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposals in C\nDESCRIPTION: This snippet defines an enumeration for WebAssembly proposals that can be toggled in the Configure context. Developers can add or remove proposals as needed for their application's requirements. It also shows how to check if specific proposals have been enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n    WasmEdge_Proposal_ImportExportMutGlobals = 0,\n    WasmEdge_Proposal_NonTrapFloatToIntConversions,\n    WasmEdge_Proposal_SignExtensionOperators,\n    WasmEdge_Proposal_MultiValue,\n    WasmEdge_Proposal_BulkMemoryOperations,\n    WasmEdge_Proposal_ReferenceTypes,\n    WasmEdge_Proposal_SIMD,\n    WasmEdge_Proposal_TailCall,\n    WasmEdge_Proposal_MultiMemories,\n    WasmEdge_Proposal_Annotations,\n    WasmEdge_Proposal_Memory64,\n    WasmEdge_Proposal_ExceptionHandling,\n    WasmEdge_Proposal_ExtendedConst,\n    WasmEdge_Proposal_Threads,\n    WasmEdge_Proposal_FunctionReferences\n};\n```\n\nLANGUAGE: c\nCODE:\n```\n/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n *\n * For the current WasmEdge version, the following proposals are supported\n * (turned off by default) additionally:\n * * Tail-call\n * * Multiple memories\n * * Extended-const\n * * Threads\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Function Type and Context\nDESCRIPTION: Example of creating a WasmEdge function type and context with parameter/return types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_55\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge_Process Support in WasmEdge VM\nDESCRIPTION: Shows how to enable WasmEdge_Process support in a WasmEdge VM configuration. It includes creating a configuration, adding WasmEdge_Process registration, creating a VM, and initializing the WasmEdge_Process module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */\nWasmEdge_ModuleInstanceContext *ProcModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);\n/* Initialize the WasmEdge_Process. */\nWasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Host Registrations for VM Configuration in Go\nDESCRIPTION: This snippet configures the host registrations for the VM context, enabling support for WASI or WasmEdge process. It shows how to instantiate and configure this in the `Configure` object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n  WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)\n)\n\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.WASI)\nconf.AddConfig(wasmedge.WASI)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing Store and Module Instances in Go\nDESCRIPTION: Demonstrates working with the Store context, including listing registered modules and finding named modules. The Store provides module exporting and importing capabilities when instantiating WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n\n// ...\n// Register a WASM module via the executor object.\n// ...\n\n// Try to list the registered WASM modules.\nmodnames := store.ListModule()\n// ...\n\n// Find named module by name.\nmod := store.FindModule(\"module\")\n// If the module with name not found, the `mod` will be `nil`.\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Invoking WasmEdge Unified CLI from Go\nDESCRIPTION: Demonstrates how to use the RunWasmEdgeUnifiedCLI function to invoke the unified WasmEdge CLI tool from a Go application. This provides access to all WasmEdge commands and subcommands through a single interface.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_80\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeUnifiedCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating VM Instances with Different Configurations in WasmEdge Go SDK\nDESCRIPTION: Go code demonstrating various ways to create VM instances using the WasmEdge Go SDK, including with default settings, specific configurations, and custom stores.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_29\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Setting up a WasmEdge Go project\nDESCRIPTION: This snippet shows how to create a new Go project for using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Inference Execution with OpenVINO in Rust\nDESCRIPTION: Demonstrates loading a model, converting an input image to tensor data, and executing inference in Rust using the OpenVINO backend. Expected output is a tensor array of inference results. Dependencies include wasi-nn and OpenVINO.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// load model\nlet graph = GraphBuilder::new(\n    GraphEncoding::Openvino,\n    ExecutionTarget::CPU\n).build_from_files([model_xml_path, model_bin_path])?;\nlet mut context = graph.init_execution_context()?;\n\n// Load a tensor that precisely matches the graph input tensor\nlet input_dims = vec![1, 3, 224, 224];\nlet tensor_data = image_to_tensor(image_name.to_string(), 224, 224);\ncontext.set_input(0, TensorType::F32, &input_dims, tensor_data)?;\n\n// Execute the inference.\ncontext.compute()?;\n\n// Retrieve the output.\nlet mut output_buffer = vec![0f32; 1001];\nlet size_in_bytes = context.get_output(0, &mut output_buffer)?;\n```\n\n----------------------------------------\n\nTITLE: Using Statistics for Instruction Counting in Go\nDESCRIPTION: Example of creating a Statistics object and retrieving instruction counts and instruction per second metrics after executing WebAssembly code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n// ... After running the WASM functions with the `Statistics` object\n\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Value Type Handling\nDESCRIPTION: Examples of working with different WasmEdge value types including integers, floats, and reference types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n```\n\n----------------------------------------\n\nTITLE: Working with Reference Types in WasmEdge-go\nDESCRIPTION: Shows how to create FuncRef and ExternRef values, which are part of the WebAssembly Reference-Types proposal. Demonstrates referencing Go variables and accessing the original reference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfuncref := wasmedge.NewFuncRef(10)\n// Create a `FuncRef` with function index 10.\n\nnum := 1234\n// `num` is a `int`.\nexternref := wasmedge.NewExternRef(&num)\n// Create an `ExternRef` which reference to the `num`.\nnum = 5678\n// Modify the `num` to 5678.\nnumref := externref.GetRef().(*int)\n// Get the original reference from the `ExternRef`.\nfmt.Println(*numref)\n// Will print `5678`.\nnumref.Release()\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Global Instances in C\nDESCRIPTION: Demonstrates the creation of a global instance, setting and getting values, and working with global types. It covers both mutable and immutable globals, as well as retrieving type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n/* Create the global type with value type and mutation. */\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\n/* Create the global instance with value and global type. */\nWasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n/* Delete the global type. */\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `ValType` will be `WasmEdge_ValType_I64`. */\nenum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n/*\n * Set the value u64(888) to the global.\n * This function will do nothing if the value type mismatched or\n * the global mutability is `WasmEdge_Mutability_Const`.\n */\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n/* Get the value (888 now) of the global context. */\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Store Context in C\nDESCRIPTION: This code snippet demonstrates how to create a WasmEdge Store context, list registered WASM modules, and find a named module. It includes operations for creating the Store, retrieving the number of modules, listing module names, and finding a specific module by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST to Module in Go WasmEdge Executor\nDESCRIPTION: Demonstrates instantiating a WASM AST object into an anonymous Module instance. The imports should be registered in the Store before instantiation for proper linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, err := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Function Implementation in WebAssembly\nDESCRIPTION: WebAssembly module that implements a recursive Fibonacci number calculator. The module exports a 'fib' function that takes an integer parameter and returns the corresponding Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_35\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Module in WAT Format\nDESCRIPTION: A WebAssembly Text Format (WAT) example that defines a module with an imported function 'func-add' and exports an 'addTwo' function that calls the imported function with its parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_66\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration - Post v0.10.0\nDESCRIPTION: Updated host module registration using Module instance in v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nimpmod := wasmedge.NewModule(\"module\")\nerr := executor.RegisterImport(store, impmod)\nif err != nil {\n  fmt.Println(\"Module instance registration FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Using Export Type Context in C\nDESCRIPTION: Demonstrates how to use an Export Type context to retrieve information about exported modules, including external type and name. This is used for querying export information from an AST Module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals in WasmEdge Configuration (C)\nDESCRIPTION: This C code configures WebAssembly proposals in the WasmEdge context, enabling or disabling specific proposals using the Configure context. Dependencies: WasmEdge C library. Outputs: Proposal configuration status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  WasmEdge_Proposal_MultiValue,\n  WasmEdge_Proposal_BulkMemoryOperations,\n  WasmEdge_Proposal_ReferenceTypes,\n  WasmEdge_Proposal_SIMD,\n  WasmEdge_Proposal_TailCall,\n  WasmEdge_Proposal_MultiMemories,\n  WasmEdge_Proposal_Annotations,\n  WasmEdge_Proposal_Memory64,\n  WasmEdge_Proposal_ExceptionHandling,\n  WasmEdge_Proposal_ExtendedConst,\n  WasmEdge_Proposal_Threads,\n  WasmEdge_Proposal_FunctionReferences\n};\n```\n\nLANGUAGE: c\nCODE:\n```\n/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n *\n * For the current WasmEdge version, the following proposals are supported\n * (turned of by default) additionally:\n * * Tail-call\n * * Multiple memories\n * * Extended-const\n * * Threads\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Reading Command Line Arguments in Rust\nDESCRIPTION: Rust code snippet to read command line arguments for model and image file names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet args: Vec<String> = env::args().collect();\nlet model_bin_name: &str = &args[1]; // File name for the PyTorch model\nlet image_name: &str = &args[2]; // File name for the input image\n```\n\n----------------------------------------\n\nTITLE: Working with Memory Type Context in C\nDESCRIPTION: Demonstrates creation and management of Memory Type context for WASM memory instances with specified limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Table Instance in WasmEdge C API\nDESCRIPTION: This code snippet shows how to create a table type with specified limits, create a table instance, and add it to a module instance. It demonstrates setting table size limits and reference type configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handling in Host Function in C\nDESCRIPTION: Shows how to implement and use custom error codes in host functions, allowing for more detailed error reporting from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_76\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Trap(void *Data,\n                       const WasmEdge_CallingFrameContext *CallFrameCxt,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val = WasmEdge_ValueGetI32(In[0]);\n  /* Return the error code from the param[0]. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Global Instances in WasmEdge Go\nDESCRIPTION: Shows how to create and manage global instances including type creation, value setting/getting, and proper cleanup. Demonstrates handling of different value types and mutability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using TableType in WasmEdge Go SDK\nDESCRIPTION: Demonstrates the creation and usage of TableType objects for defining table instances in WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Working with Function Instances in Go\nDESCRIPTION: Shows how to work with function instances including retrieving function types from function objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\nfuncobj := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the module instance should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Creating Function Instance with Host Function in C\nDESCRIPTION: Shows how to create a Function instance context with a host function body and function type. This process is necessary for registering host functions that can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/* If the function instance is not added into a module instance context, it should be deleted. */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application\nDESCRIPTION: Bash commands to get the WasmEdge Go SDK, build the Go application, and run it to calculate the 21st Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n$ go build\n$ ./wasmedge_test\nGet fibonacci[21]: 17711\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Table Instances in WasmEdge Go\nDESCRIPTION: This snippet demonstrates how to create, access, and modify table instances in WasmEdge. It shows creating a table with limits, setting and getting reference data, growing the table size, and handling potential errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_56\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Specialized Import Objects in WasmEdge-go\nDESCRIPTION: Shows how to create and use specialized import objects for WASI and WasmEdge_Process in WasmEdge-go. These objects provide specific functionality and can be registered with VM or Store objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\nwasiobj := wasmedge.NewWasiImportObject(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:\"}, // The mapping preopens\n)\nprocobj := wasmedge.NewWasmEdgeProcessImportObject(\n  []string{\"ls\", \"echo\"}, // The allowed commands\n  false,                  // Not to allow all commands\n)\n\n// Register the WASI and WasmEdge_Process into the VM object.\nvm := wasmedge.NewVM()\nvm.RegisterImport(wasiobj)\nvm.RegisterImport(procobj)\n\n// ... Execute some WASM functions.\n\n// Get the WASI exit code.\nexitcode := wasiobj.WasiGetExitCode()\n// The `exitcode` will be 0 if the WASI function \"_start\" execution has no error.\n// Otherwise, it will return with the related exit code.\n\nvm.Release()\n// The import objects should be deleted.\nwasiobj.Release()\nprocobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Constructing Module Instance with Host Instances in C\nDESCRIPTION: Demonstrates how to create a Module instance and add Function, Memory, Table, and Global instances to it. This process allows for the creation of custom modules with host-defined functionalities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n\n/* Create and add a global instance into the module instance. */\nWasmEdge_GlobalTypeContext *HostGType =\n  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge VM State Diagram\nDESCRIPTION: ASCII diagram showing the different states and transitions of a WasmEdge VM object during its lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_31\n\nLANGUAGE: text\nCODE:\n```\n                         |========================|\n                |------->|      VM: Initiated     |\n                |        |========================|\n                |                    |\n                |                 LoadWasm\n                |                    |\n                |                    v\n                |        |========================|\n                |--------|       VM: Loaded       |<-------|\n                |        |========================|        |\n                |              |            ^              |\n                |         Validate          |              |\n            Cleanup            |          LoadWasm         |\n                |              v            |            LoadWasm\n                |        |========================|        |\n                |--------|      VM: Validated     |        |\n                |        |========================|        |\n                |              |            ^              |\n                |      Instantiate          |              |\n                |              |          RegisterModule   |\n                |              v            |              |\n                |        |========================|        |\n                |--------|    VM: Instantiated    |--------|\n                         |========================|\n                               |            ^\n                               |            |\n                               --------------\n                  Instantiate, Execute, ExecuteRegistered,\n                  ExecuteBindgen, ExecuteBindgenRegistered\n```\n\n----------------------------------------\n\nTITLE: Using Unified WasmEdge CLI in C\nDESCRIPTION: Shows how to use the WasmEdge_Driver_UniTool() API to run the unified WasmEdge CLI tool from within C code. This provides the same functionality as the standalone 'wasmedge' tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge unified tool. */\n  /* (Within both runtime and AOT compiler) */\n  return WasmEdge_Driver_UniTool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Output Formats in WasmEdge Go SDK\nDESCRIPTION: This code defines constants for compiler output formats in WasmEdge. It supports two formats: Native (dynamic library format) and Wasm (WebAssembly with AOT compiled code in custom sections). These constants map to the corresponding C API enumeration values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_74\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Shared Library Format in Bash\nDESCRIPTION: Shows how to compile a WebAssembly file to a shared library format and then execute it using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile app.wasm app_aot.so\nwasmedge app_aot.so\n```\n\n----------------------------------------\n\nTITLE: Implementing a Non-blocking HTTP Client in Rust for WasmEdge\nDESCRIPTION: Rust code for a non-blocking HTTP client that can handle multiple connections concurrently. It demonstrates how to set up non-blocking TCP streams, send requests, and process responses asynchronously using a loop to check for incoming data on multiple connections.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/client.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse httparse::{Response, EMPTY_HEADER};\nuse std::io::{self, Read, Write};\nuse std::str::from_utf8;\nuse wasmedge_wasi_socket::TcpStream;\n\nfn main() {\n    let req = \"GET / HTTP/1.0\\n\\n\";\n    let mut first_connection = TcpStream::connect(\"127.0.0.1:80\").unwrap();\n    first_connection.set_nonblocking(true).unwrap();\n    first_connection.write_all(req.as_bytes()).unwrap();\n\n    let mut second_connection = TcpStream::connect(\"127.0.0.1:80\").unwrap();\n    second_connection.set_nonblocking(true).unwrap();\n    second_connection.write_all(req.as_bytes()).unwrap();\n\n    let mut first_buf = vec![0; 4096];\n    let mut first_bytes_read = 0;\n    let mut second_buf = vec![0; 4096];\n    let mut second_bytes_read = 0;\n\n    loop {\n        let mut first_complete = false;\n        let mut second_complete = false;\n        if !first_complete {\n            match read_data(&mut first_connection, &mut first_buf, first_bytes_read) {\n                Ok((bytes_read, false)) => {\n                    first_bytes_read = bytes_read;\n                }\n                Ok((bytes_read, true)) => {\n                    println!(\"First connection completed\");\n                    if bytes_read != 0 {\n                        parse_data(&first_buf, bytes_read);\n                    }\n                    first_complete = true;\n                }\n                Err(e) => {\n                    println!(\"First connection error: {}\", e);\n                    first_complete = true;\n                }\n            }\n        }\n        if !second_complete {\n            match read_data(&mut second_connection, &mut second_buf, second_bytes_read) {\n                Ok((bytes_read, false)) => {\n                    second_bytes_read = bytes_read;\n                }\n                Ok((bytes_read, true)) => {\n                    println!(\"Second connection completed\");\n                    if bytes_read != 0 {\n                        parse_data(&second_buf, bytes_read);\n                    }\n                    second_complete = true;\n                }\n                Err(e) => {\n                    println!(\"Second connection error: {}\", e);\n                    second_complete = true;\n                }\n            }\n        }\n        if first_complete && second_complete {\n            break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete JavaScript Class in Rust\nDESCRIPTION: Comprehensive Rust module that implements a JavaScript 'Point' class with constructor, getters, setters, and methods. Shows how to register a Rust implementation as a JavaScript module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nmod point {\n  use wasmedge_quickjs::*;\n\n  #[derive(Debug)]\n  struct Point(i32, i32);\n\n  struct PointDef;\n\n  impl JsClassDef<Point> for PointDef {\n    const CLASS_NAME: &'static str = \"Point\\0\";\n    const CONSTRUCTOR_ARGC: u8 = 2;\n\n    fn constructor(_: &mut Context, argv: &[JsValue]) -> Option<Point> {\n      println!(\"rust-> new Point {:?}\", argv);\n      let x = argv.get(0);\n      let y = argv.get(1);\n      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {\n        Some(Point(*x, *y))\n      } else {\n        None\n      }\n    }\n\n    fn proto_init(p: &mut JsClassProto<Point, PointDef>) {\n      struct X;\n      impl JsClassGetterSetter<Point> for X {\n        const NAME: &'static str = \"x\\0\";\n\n        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {\n          println!(\"rust-> get x\");\n          this_val.0.into()\n        }\n\n        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {\n          println!(\"rust-> set x:{:?}\", val);\n          if let JsValue::Int(x) = val {\n            this_val.0 = x\n          }\n        }\n      }\n\n      struct Y;\n      impl JsClassGetterSetter<Point> for Y {\n        const NAME: &'static str = \"y\\0\";\n\n        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {\n          println!(\"rust-> get y\");\n          this_val.1.into()\n        }\n\n        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {\n          println!(\"rust-> set y:{:?}\", val);\n          if let JsValue::Int(y) = val {\n            this_val.1 = y\n          }\n        }\n      }\n\n      struct FnPrint;\n      impl JsMethod<Point> for FnPrint {\n        const NAME: &'static str = \"pprint\\0\";\n        const LEN: u8 = 0;\n\n        fn call(_: &mut Context, this_val: &mut Point, _argv: &[JsValue]) -> JsValue {\n          println!(\"rust-> pprint: {:?}\", this_val);\n          JsValue::Int(1)\n        }\n      }\n\n      p.add_getter_setter(X);\n      p.add_getter_setter(Y);\n      p.add_function(FnPrint);\n    }\n  }\n\n  struct PointModule;\n  impl ModuleInit for PointModule {\n    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {\n      m.add_export(\"Point\\0\", PointDef::class_value(ctx));\n    }\n  }\n\n  pub fn init_point_module(ctx: &mut Context) {\n    ctx.register_class(PointDef);\n    ctx.register_module(\"point\\0\", PointModule, &[\"Point\\0\"]);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module with External References\nDESCRIPTION: WASM module that imports host functions taking externref parameters and implements functions to call them. The module includes functions for addition, multiplication, and square operations using external references.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_0\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param externref i32) (result i32)))\n  (type $t1 (func (param externref i32 i32) (result i32)))\n  (type $t2 (func (param externref externref i32 i32) (result i32)))\n  (import \"extern_module\" \"functor_square\" (func $functor_square (type $t0)))\n  (import \"extern_module\" \"class_add\" (func $class_add (type $t1)))\n  (import \"extern_module\" \"func_mul\" (func $func_mul (type $t1)))\n  (func $call_add (export \"call_add\") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)\n    (call $class_add\n      (local.get $p0)\n      (local.get $p1)\n      (local.get $p2)))\n  (func $call_mul (export \"call_mul\") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)\n    (call $func_mul\n      (local.get $p0)\n      (local.get $p1)\n      (local.get $p2)))\n  (func $call_square (export \"call_square\") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)\n    (call $functor_square\n      (local.get $p0)\n      (local.get $p1)))\n  (func $call_add_square (export \"call_add_square\") (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)\n    (call $functor_square\n      (local.get $p1)\n      (call $class_add\n        (local.get $p0)\n        (local.get $p2)\n        (local.get $p3))))\n  (memory $memory (export \"memory\") 1))\n```\n\n----------------------------------------\n\nTITLE: Creating Function Context for Host Function in WasmEdge\nDESCRIPTION: This code demonstrates how to create a function type specifying parameter and return types, and then create a function instance with a host function implementation. The function type defines a signature with two i32 parameters and one i32 return value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\n/* Create a function type: {i32, i32} -> {i32}. */\nHostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\n\n/* If the function instance is not added into an import object context, it should be deleted. */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Run WASI HTTP service in Kubernetes\nDESCRIPTION: This snippet deploys a WebAssembly-based HTTP service from Docker Hub to the Kubernetes cluster as a container. It utilizes kubectl to create a pod with the specified image and annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}'\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Table Type Context in C\nDESCRIPTION: Shows how to create a Table Type context with specific limits and reference type, and how to query information from it. This is used for table instance creation and information retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Working with V128 SIMD Values\nDESCRIPTION: Example showing how to create and access V128 values for SIMD operations\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Global Instances in WasmEdge\nDESCRIPTION: This code demonstrates how to create, manipulate, and destroy a global instance in WasmEdge. It covers creating a global type with value type and mutability, setting and getting global values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n/* Create the global type with value type and mutation. */\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\n/* Create the global instance with value and global type. */\nWasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n/* Delete the global type. */\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `ValType` will be `WasmEdge_ValType_I64`. */\nenum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n/*\n * Set the value u64(888) to the global.\n * This function will do nothing if the value type mismatched or\n * the global mutability is `WasmEdge_Mutability_Const`.\n */\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n/* Get the value (888 now) of the global context. */\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Unified CLI Tool in C\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C API to invoke the unified WasmEdge CLI tool. It replicates the functionality of the 'wasmedge' command, which includes both runtime and AOT compiler capabilities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_94\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge unified tool. */\n  /* (Within both runtime and AOT compiler) */\n  return WasmEdge_Driver_UniTool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Host Command using WasmEdge Process Interface in Rust\nDESCRIPTION: This code demonstrates how to use the WasmEdge Process Interface in Rust to execute a host command (http_proxy in this case). It shows how to create a new Command, add arguments, provide input via STDIN, and capture the output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/command.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut cmd = Command::new(\"http_proxy\");\n\ncmd.arg(\"post\")\n   .arg(\"https://api.sendgrid.com/v3/mail/send\")\n   .arg(auth_header);\ncmd.stdin_u8vec(payload.to_string().as_bytes());\n\nlet out = cmd.output();\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader Context\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge Loader context to load WebAssembly modules from files or buffers. It includes error handling and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing Asynchronous Execution in WasmEdge C API\nDESCRIPTION: Demonstrates how to wait for asynchronous execution to complete. This code shows the basic pattern for using WasmEdge_AsyncWait to block until an asynchronous function execution is finished.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Printing to STDOUT - Rust\nDESCRIPTION: This Rust code demonstrates how to print to standard output (`STDOUT`) from a WebAssembly module using the `println!` macro. The `echo` function takes a string as input, prints it to the console, and then returns the same string. The output will be visible in the console where the WasmEdge runtime is executed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\"pub fn echo(content: &str) -> String {\\n  println!(\\\"Printed from wasi: {}\\\", content);\\n  return content.to_string();\\n}\"\n```\n\n----------------------------------------\n\nTITLE: MySQL Database Connection Setup\nDESCRIPTION: Rust code for establishing a connection pool to MySQL database with optional SSL support\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n    // Below we create a customized connection pool\n    let opts = Opts::from_url(&*get_url()).unwrap();\n    let mut builder = OptsBuilder::from_opts(opts);\n    if std::env::var(\"DATABASE_SSL\").is_ok() {\n        builder = builder.ssl_opts(SslOpts::default());\n    }\n    // The connection pool will have a min of 5 and max of 10 connections.\n    let constraints = PoolConstraints::new(5, 10).unwrap();\n    let pool_opts = PoolOpts::default().with_constraints(constraints);\n\n    let pool = Pool::new(builder.pool_opts(pool_opts));\n    let mut conn = pool.get_conn().await.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Registering an Existing Module Instance in C\nDESCRIPTION: Shows how to register an existing Module instance into the Store context by exporting its module name. This is useful when creating a Module instance for host functions that need to be registered for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"host-module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the\n * module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Working with Store Context in WasmEdge C API\nDESCRIPTION: Demonstrates how to use the Store context to manage global state in WebAssembly. It provides examples of listing registered modules and finding a specific named module from the Store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Client in JavaScript\nDESCRIPTION: JavaScript code demonstrating how to create a TCP client using WasmEdge's WasiTcpConn API. The client connects to the server on localhost:8000, sends a message, and processes the response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nasync function connect_test() {\n  try {\n    let ss = await net.WasiTcpConn.connect('127.0.0.1:8000');\n    ss.write('hello');\n    let msg = (await ss.read()) || '';\n    print('client recv:', new TextDecoder().decode(msg));\n  } catch (e) {\n    print('client catch:', e);\n  } finally {\n    nextTick(() => {\n      exit(0);\n    });\n  }\n}\n\nconnect_test();\n```\n\n----------------------------------------\n\nTITLE: Implementing an Addition Host Function in C for WasmEdge\nDESCRIPTION: Example implementation of an \"add\" host function that takes two i32 values, adds them together, and returns the result as an i32 value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  * Developers should take care about the function type.\n  */\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Instance Tracing and Function List Export in Go\nDESCRIPTION: Demonstrates how to list exported functions and trace instances in a WASM module. Includes module loading, validation and function metadata retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_40\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Function Instance in WasmEdge C API\nDESCRIPTION: Creating a function instance with two i32 parameters and one i32 return value. The function is then added to a module instance with a name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                     WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n   WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n   WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n* The third parameter is the pointer to the additional data object.\n* Developers should guarantee the life cycle of the data, and it can be\n* `NULL` if the external data is not needed.\n*/\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the WasmEdge Fibonacci Example\nDESCRIPTION: Bash commands for compiling the C code with WasmEdge library and executing the resulting binary. The output demonstrates the successful calculation of the 5th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 8\n```\n\n----------------------------------------\n\nTITLE: Creating and Using FunctionType in WasmEdge Go SDK\nDESCRIPTION: Shows how to create a FunctionType object, set parameter and return types, and retrieve type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing Memory Instances in WasmEdge Go\nDESCRIPTION: Demonstrates memory instance management including creation, data access, and page size manipulation. Shows proper error handling for out of bounds access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_55\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Non-Blocking HTTP Server in Node.js - JavaScript\nDESCRIPTION: This snippet creates a non-blocking HTTP server that serves the LazyHome React component as HTML content. It uses the renderToPipeableStream API from React to send chunks of the rendered HTML response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { createServer } from 'http';\n\nimport LazyHome from './component/LazyHome.jsx';\n\ncreateServer((req, res) => {\n  res.setHeader('Content-type', 'text/html; charset=utf-8');\n  renderToPipeableStream(<LazyHome />).pipe(res);\n}).listen(8001, () => {\n  print('listen 8001...');\n});\n```\n\n----------------------------------------\n\nTITLE: JavaScript Handler for WebAssembly Execution in AWS Lambda\nDESCRIPTION: JavaScript code that loads and executes a WebAssembly function in AWS Lambda. It spawns a WasmEdge process to run the compiled WebAssembly module and handles the input/output data flow.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nfunction _runWasm(reqBody) {\n  return new Promise((resolve) => {\n    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [\n      path.join(__dirname, 'grayscale.so'),\n    ]);\n\n    let d = [];\n    wasmedge.stdout.on('data', (data) => {\n      d.push(data);\n    });\n\n    wasmedge.on('close', (code) => {\n      let buf = Buffer.concat(d);\n      resolve(buf);\n    });\n\n    wasmedge.stdin.write(reqBody);\n    wasmedge.stdin.end('');\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Export Type Context in C\nDESCRIPTION: Shows how to work with Export Type context for accessing WASM module export information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: Getting Active Module in C\nDESCRIPTION: This snippet shows how to retrieve the active module instance owned by the VM context after the WASM module is instantiated, providing access to module-specific functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nconst WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge CLI Tool in Go\nDESCRIPTION: Example of triggering the WasmEdge CLI tool programmatically through the Go SDK. Uses the RunWasmEdgeCLI function to pass command line arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available WasmEdge Plug-ins\nDESCRIPTION: Code to list all loaded WasmEdge plug-ins in the current environment. This displays both the count and names of available plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_80\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Numbers - Rust\nDESCRIPTION: This Rust code demonstrates how to generate random numbers within a WebAssembly environment using the `rand` crate. The `get_random_i32` function returns a random i32 value, and the `get_random_bytes` function returns a vector of 128 random bytes. When compiled for the `wasm32-wasip1` target, these functions will make WASI calls to obtain randomness from the host operating system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n\"use rand::prelude::*;\\n\\npub fn get_random_i32() -> i32 {\\n  let x: i32 = random();\\n  return x;\\n}\\n\\npub fn get_random_bytes() -> Vec<u8> {\\n  let mut rng = thread_rng();\\n  let mut arr = [0u8; 128];\\n  rng.fill(&mut arr[..]);\\n  return arr.to_vec();\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Using Import Type Context in C\nDESCRIPTION: Example of using Import Type context to retrieve import information from an AST Module, showing how to get external types and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_TagTypeContext *TagTypeCxt =\n    WasmEdge_ImportTypeGetTagType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Getting Return Values from Asynchronous Execution in WasmEdge\nDESCRIPTION: This snippet shows how to retrieve the return values from an asynchronous execution using the `WasmEdge_AsyncGet` API.  It blocks until the execution completes, then fills the provided buffer with the return values. The `BUF_LEN` constant defines the size of the buffer. `WasmEdge_Result` contains the result of execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting WasmEdge Strings\nDESCRIPTION: This C code shows how to create `WasmEdge_String` objects from a C string and a buffer, and how to delete them using `WasmEdge_StringCreateByCString`, `WasmEdge_StringCreateByBuffer`, and `WasmEdge_StringDelete`. The code emphasizes the importance of deleting the created strings to avoid memory leaks. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Finding Function Instances in Store in WasmEdge-go\nDESCRIPTION: Shows how to find and retrieve specific function instances by name from the Store. This is useful for accessing exported functions from instantiated WASM modules for invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n// ...\n// Instantiate a WASM module via the `*wasmedge.Executor` object.\n// ...\n\n// Try to find the exported functions of the instantiated WASM module.\n// Take the function instances for example here.\nfuncobj := store.FindFunction(\"fib\")\n// `funcobj` will be `nil` if the function not found.\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: WASM Module Registration - Post v0.10.0\nDESCRIPTION: Updated module registration using the new Register() API in v0.10.0, including proper module instance cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST\nmod, err := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n}\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Instantiating Anonymous Module in WasmEdge\nDESCRIPTION: Demonstrates instantiation of an AST module into an anonymous Module instance. Includes context creation and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Global Type Context in C\nDESCRIPTION: Demonstrates the creation of a Global Type context with a specific value type and mutability, and how to query information from it. This is used for global instance creation and type checking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Instantiating Modules with WasmEdge Executor in C\nDESCRIPTION: Shows how to instantiate a WASM module using the WasmEdge Executor API. It creates necessary contexts and instantiates the module in the Store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Memory Instances in WasmEdge Go\nDESCRIPTION: This snippet demonstrates how to create, access, and modify memory instances in WasmEdge. It shows creating memory with limits, setting and getting data at specific offsets, growing memory pages, and handling potential errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(1, 5)\n// Create the memory type with limit. The memory page size is 64KiB.\nmemtype := wasmedge.NewMemoryType(lim)\n// Create the memory instance with memory type.\nmeminst := wasmedge.NewMemory(memtype)\n// Delete the memory type.\nmemtype.Release()\n\ndata := []byte(\"A quick brown fox jumps over the lazy dog\")\nerr := meminst.SetData(data, 0x1000, 10)\n// Set the data[0:9] to the memory[4096:4105].\n\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   err = meminst.SetData(data, 0xFFFF, 10)\n\nvar gotdata []byte\ngotdata, err = meminst.GetData(0x1000, 10)\n// Get the memory[4096:4105]. The `gotdata` will be `[]byte(\"A quick br\").\n// The following line will get an \"out of bounds memory access\" error\n// because [65535:65544] is out of 1 page size (65536):\n//   gotdata, err = meminst.Getdata(0xFFFF, 10)\n\npagesize := meminst.GetPageSize()\n// `pagesize` will be 1.\nerr = meminst.GrowPage(2)\n// Grow the page size of 2, the page size of the memory instance will be 3.\n\n// The following line will get an \"out of bounds memory access\" error\n// because the size (3 + 3) will reach the memory limit (5):\n//   err = meminst.GetPageSize(3)\n\nmeminst.Release()\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Execution Results in WasmEdge Go SDK\nDESCRIPTION: Demonstrates how to handle results from asynchronous executions, including blocking for results and using timeouts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing Store Context in Go\nDESCRIPTION: Shows how to use the Store object to manage WASM runtime state, including listing registered modules and finding modules by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_53\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n\nmodnames := store.ListModule()\n\nmod := store.FindModule(\"module\")\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing Table Instances in Go\nDESCRIPTION: Demonstrates creation and manipulation of table instances including setting limits, accessing data, and growing table size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_53\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimitWithMax(10, 20)\n// Create the table type with limit and the `FuncRef` element type.\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)\n// Create the table instance with table type.\ntabinst := wasmedge.NewTable(tabtype)\n// Delete the table type.\ntabtype.Release()\n\ngottabtype := tabinst.GetTableType()\n// The `gottabtype` got from table instance is owned by the `tabinst`\n// and should __NOT__ be released.\nreftype := gottabtype.GetRefType()\n// The `reftype` will be `wasmedge.RefType_FuncRef`.\n\nvar gotdata interface{}\ndata := wasmedge.NewFuncRef(5)\nerr := tabinst.SetData(data, 3)\n// Set the function index 5 to the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   err = tabinst.SetData(data, 13)\n\ngotdata, err = tabinst.GetData(3)\n// Get the FuncRef value of the table[3].\n\n// The following line will get an \"out of bounds table access\" error\n// because the position (13) is out of the table size (10):\n//   gotdata, err = tabinst.GetData(13)\n\ntabsize := tabinst.GetSize()\n// `tabsize` will be 10.\nerr = tabinst.Grow(6)\n// Grow the table size of 6, the table size will be 16.\n\n// The following line will get an \"out of bounds table access\" error\n// because the size (16 + 6) will reach the table limit (20):\n//   err = tabinst.Grow(6)\n\ntabinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Step-by-Step Asynchronous WASM Function Execution in C\nDESCRIPTION: Shows manual instantiation and asynchronous execution of a WebAssembly module using step-by-step VM context APIs. The example includes loading, validation, instantiation, and execution phases for calculating the 25th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Pre-registration in WasmEdge\nDESCRIPTION: Demonstrates how to enable and configure WASI support in WasmEdge VM context. Shows creation of configuration, adding WASI host registration, and initializing WASI module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ModuleInstanceContext *WasiModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Context Lifecycles\nDESCRIPTION: Example demonstrating context creation and proper resource release\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\nconf := wasmedge.NewConfigure()\n// Release the `conf` immediately.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WASM Example\nDESCRIPTION: Commands to compile the C code with WasmEdge library and execute the resulting binary to calculate the 18th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_57\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Validator Context\nDESCRIPTION: This snippet shows how to use the WasmEdge Validator context to validate a WebAssembly module. It includes error handling and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Store Context in C\nDESCRIPTION: This snippet demonstrates how to create a WasmEdge Store context, list registered modules, and find modules by name. It shows the complete lifecycle of working with the Store, including creation, module enumeration, and module lookup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Image Processing Function Implementation - Rust\nDESCRIPTION: Rust program that reads image data from STDIN, converts it to grayscale, and outputs the processed image to STDOUT. Uses the image crate for image manipulation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse hex;\nuse std::io::{self, Read};\nuse image::{ImageOutputFormat, ImageFormat};\n\nfn main() {\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();\n  let img = image::load_from_memory(&buf).unwrap();\n  let filtered = img.grayscale();\n  let mut buf = vec![];\n  match image_format_detected {\n    ImageFormat::Gif => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();\n    },\n    _ => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();\n    },\n  };\n  io::stdout().write_all(&buf).unwrap();\n  io::stdout().flush().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Memory Instance in WasmEdge C API\nDESCRIPTION: Creating a memory instance with limits, then adding it to a module instance. The memory has a minimum size of 1 page and a maximum of 2 pages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemoryLimit = {\n   .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n   WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n   WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n```\n\n----------------------------------------\n\nTITLE: Updating Records (Rust)\nDESCRIPTION: This Rust snippet updates the `shipping_address` for records in the `orders` table where the `order_id` is 2. After the update, it requeries the table and outputs the updated information using `dbg!`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n    // update some data\n    r\"UPDATE orders\n    SET shipping_address = '8366 Elizabeth St.'\n    WHERE order_id = 2;\"\n        .ignore(&mut conn)\n        .await?;\n    // query data\n    let loaded_orders = \"SELECT * FROM orders\"\n        .with(())\n        .map(\n            &mut conn,\n            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {\n                Order::new(\n                    order_id,\n                    production_id,\n                    quantity,\n                    amount,\n                    shipping,\n                    tax,\n                    shipping_address,\n                )\n            },\n        )\n        .await?;\n    dbg!(loaded_orders.len());\n    dbg!(loaded_orders);\n```\n\n----------------------------------------\n\nTITLE: Setting up a new Go project\nDESCRIPTION: This snippet demonstrates how to create a new Go project and initialize it using `go mod init`. This is a prerequisite for using Go modules and managing dependencies.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\n\"mkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with ImportObject (Pre-v0.10.0)\nDESCRIPTION: This code demonstrates how to define and register host functions in WasmEdge-Go before version 0.10.0. It uses the ImportObject structure to create and manage host functions that can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// ...\n\n// Create an import object with the module name \"module\".\nimpobj := wasmedge.NewImportObject(\"module\")\n\n// Create and add a function instance into the import object with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n// The third parameter is the pointer to the additional data object.\n// Developers should guarantee the life cycle of the data, and it can be `nil`\n// if the external data is not needed.\nfunctype.Release()\nimpobj.AddFunction(\"add\", hostfunc)\n\n// The import object should be released.\n// Developers should __NOT__ release the instances added into the import objects.\nimpobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASI Module Instance in WasmEdge C API\nDESCRIPTION: This code snippet demonstrates how to create a WASI module instance, register it with a WasmEdge VM, run the WebAssembly module, and obtain the exit code. It shows the pattern for host environment integration via WASI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *WasiModCxt =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\n```\n\n----------------------------------------\n\nTITLE: Instruction Counter Example in C\nDESCRIPTION: Demonstrates how to create a statistics context, retrieve instruction counts and performance metrics, and properly clean up resources. The example shows basic usage of the WasmEdge statistics API for instruction counting.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals Configuration in Go\nDESCRIPTION: Example of creating a configuration object and manipulating WebAssembly proposal settings, enabling or disabling specific proposals for the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\n// By default, the following proposals have turned on initially:\n// * IMPORT_EXPORT_MUT_GLOBALS\n// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS\n// * SIGN_EXTENSION_OPERATORS\n// * MULTI_VALUE\n// * BULK_MEMORY_OPERATIONS\n// * REFERENCE_TYPES\n// * SIMD\n// For the current WasmEdge version, the following proposals are supported:\n// * TAIL_CALL\n// * MULTI_MEMORIES\n// * THREADS\n// * EXTENDED_CONST\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n// The `is_bulkmem` will be `true`.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Handling Async WASM Execution Results in Go\nDESCRIPTION: Demonstrates how to handle asynchronous execution results in WASM, including result retrieval and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Working with ImportType in WasmEdge Go API\nDESCRIPTION: Demonstrates how to use ImportType objects to inspect module imports from AST modules. Shows retrieving external type, module name, and external name information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Global Types in Go\nDESCRIPTION: Shows creation and management of global type contexts for WASM instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Type from Function Instance (C)\nDESCRIPTION: Shows how to retrieve the Function Type context from a Function Instance context. The retrieved Function Type is owned by the Function Instance and should not be manually destroyed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Global Type Context in WasmEdge\nDESCRIPTION: Example of creating a Global Type context with a specified value type (F64) and mutability, then retrieving and validating the type information. Global Type contexts are used for Global instance creation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValTypeGenF64(), WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nbool IsTypeF64 = WasmEdge_ValTypeIsF64(GotValType);\n/* `IsTypeF64` will be `TRUE`. */\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `GotValMut` will be WasmEdge_Mutability_Var. */\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing Module Instances with the Store Context in C\nDESCRIPTION: Demonstrates how to use the Store context to list registered WebAssembly modules and find named modules. The Store maintains the global state that can be manipulated by WebAssembly programs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Host Function Type Definition in C\nDESCRIPTION: Defines the function signature for WasmEdge host functions that can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n  void *Data,\n  WasmEdge_MemoryInstanceContext *MemCxt,\n  const WasmEdge_Value *Params,\n  WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Non-blocking HTTP Server Main Loop in Rust\nDESCRIPTION: Main event loop implementation for a non-blocking HTTP server that handles multiple concurrent connections\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/server.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> std::io::Result<()> {\n    let mut connects = Connects::new();\n    let server = TcpListener::bind(\"127.0.0.1:1234\", true)?;\n    connects.add(NetConn::Server(server));\n\n    loop {\n        let subs = connects_to_subscriptions(&connects);\n        let events = poll::poll(&subs)?;\n\n        for event in events {\n            let conn_id = event.userdata as usize;\n            match connects.get_mut(conn_id) {\n                Some(NetConn::Server(server)) => match event.event_type {\n                    poll::EventType::Timeout => unreachable!(),\n                    poll::EventType::Error(e) => {\n                        return Err(e);\n                    }\n                    poll::EventType::Read => {\n                        let (mut tcp_client, addr) = server.accept(true)?;\n                        println!(\"accept from {}\", addr);\n\n                        match tcp_client.write(DATA) {\n                            Ok(n) if n < DATA.len() => {\n                                println!(\n                                    \"write hello error: {}\",\n                                    io::Error::from(io::ErrorKind::WriteZero)\n                                );\n                                continue;\n                            }\n                            Ok(_) => {}\n                            Err(ref err) if would_block(err) => {}\n                            Err(ref err) if interrupted(err) => {}\n                            Err(err) => {\n                                println!(\"write hello error: {}\", err);\n                                continue;\n                            }\n                        }\n\n                        let id = connects.add(NetConn::Client(tcp_client));\n                        println!(\"add conn[{}]\", id);\n                    }\n                    poll::EventType::Write => unreachable!(),\n                },\n                Some(NetConn::Client(client)) => {\n                    match event.event_type {\n                        poll::EventType::Timeout => {\n                            unreachable!()\n                        }\n                        poll::EventType::Error(e) => {\n                            println!(\"tcp_client[{}] recv a io error: {}\", conn_id, e);\n                            connects.remove(conn_id);\n                        }\n                        poll::EventType::Read => match handle_connection_read(client) {\n                            Ok(true) => {\n                                println!(\"tcp_client[{}] is closed\", conn_id);\n                                connects.remove(conn_id);\n                            }\n                            Err(e) => {\n                                println!(\"tcp_client[{}] recv a io error: {}\", conn_id, e);\n                                connects.remove(conn_id);\n                            }\n                            _ => {}\n                        },\n                        poll::EventType::Write => unreachable!(),\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading and Instantiating WASM Module in WasmEdge\nDESCRIPTION: Code for loading a WebAssembly module from a file, validating it, and instantiating it in a WasmEdge VM context. This is a prerequisite step before calling functions in the WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"stl.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM file loading failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMValidate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM validation failed\\n\");\n  return EXIT_FAILURE;\n}\nRes = WasmEdge_VMInstantiate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed\\n\");\n  return EXIT_FAILURE;\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Project\nDESCRIPTION: Commands to build and run the WasmEdge Go project, demonstrating the execution of the Fibonacci function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n$ go build\n$ ./wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Memory Instance to Module Instance in WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to create a memory type with specific limits, instantiate a memory instance, and register it with a module instance in WasmEdge. It defines memory limits, creates a memory type and instance, and adds it to the module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemoryLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n    WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for Tokio Support\nDESCRIPTION: Cargo configuration entries to set default target and required feature flags for Tokio support in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"wasm32-wasip1\"\nrustflags = [\"--cfg\", \"wasmedge\", \"--cfg\", \"tokio_unstable\"]\n```\n\n----------------------------------------\n\nTITLE: Querying MySQL Database\nDESCRIPTION: Rust code for querying and mapping MySQL database records to Order structs\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n    // query data\n    let loaded_orders = \"SELECT * FROM orders\"\n        .with(())\n        .map(\n            &mut conn,\n            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {\n                Order::new(\n                    order_id,\n                    production_id,\n                    quantity,\n                    amount,\n                    shipping,\n                    tax,\n                    shipping_address,\n                )\n            },\n        )\n        .await?;\n    dbg!(loaded_orders.len());\n    dbg!(loaded_orders);\n```\n\n----------------------------------------\n\nTITLE: Building with WasmEdge-Go Extensions\nDESCRIPTION: Demonstrates how to build with various WasmEdge-Go extensions like TensorFlow and Image processing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags tensorflow\n```\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags tensorflowlite\n```\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image\n```\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image,tensorflow\n```\n\n----------------------------------------\n\nTITLE: Creating Function Type and Context in WasmEdge\nDESCRIPTION: Example of creating a WasmEdge function type and context with specific parameter and return types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_70\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an module instance object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Memory Type Context\nDESCRIPTION: Shows how to work with memory type contexts in WASM, including creation and limit management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Generating and Accessing Numerical Values with C API\nDESCRIPTION: This C code shows how to generate `WasmEdge_Value` objects for different number types (i32, i64, f32, f64) and retrieve their values. It utilizes functions like `WasmEdge_ValueGenI32()`, `WasmEdge_ValueGetI32()`, `WasmEdge_ValueGenI64()`, `WasmEdge_ValueGetI64()`, `WasmEdge_ValueGenF32()`, `WasmEdge_ValueGetF32()`, `WasmEdge_ValueGenF64()`, and `WasmEdge_ValueGetF64()` from the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n\"WasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \\\"123456\\\" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \\\"1234567890123\\\" */\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \\\"123.456001\\\" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \\\"123456.1234567890\\\" */\"\n```\n\n----------------------------------------\n\nTITLE: Invoking WasmEdge Runtime CLI from Go\nDESCRIPTION: Demonstrates how to use the RunWasmEdgeCLI function to invoke the WasmEdge runtime (equivalent to 'wasmedge run' command) from a Go application. The function accepts command line arguments to pass to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_78\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Working with ExportType in WasmEdge Go API\nDESCRIPTION: Shows how to use ExportType objects to inspect module exports from AST modules. Demonstrates retrieving external type and name information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Installing GGML Plugin for WasmEdge\nDESCRIPTION: Commands to install the GGML plugin for WasmEdge and verify its dependencies. This plugin is required for running neural network models in WebAssembly applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml\n\n# Make sure all your plugin dependencies is good\n> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Instances in Store in WasmEdge-go\nDESCRIPTION: Demonstrates how to list exported function names from an instantiated WASM module using the Store API. This allows discovery of available functions after module instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n// ...\n// Instantiate a WASM module via the `*wasmedge.Executor` object.\n// ...\n\n// Try to list the exported functions of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := store.ListFunction()\nfor _, name := range funcnames {\n  fmt.Println(\"Exported function name:\", name)\n}\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Function Type Context in C\nDESCRIPTION: Example of creating and manipulating a Function Type context with parameter and return types, demonstrating parameter list creation and type information retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                 WasmEdge_ValTypeGenI64()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenFuncRef()};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nWasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-Crypto Pre-registration\nDESCRIPTION: Shows how to enable WASI-Crypto proposal support with multiple crypto-related configurations in WasmEdge VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* The WASI-Crypto related configures are suggested to turn on together. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */\nWasmEdge_ModuleInstanceContext *CryptoCommonModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals in WasmEdge Configuration\nDESCRIPTION: Example of creating a configuration object and managing WebAssembly proposals. Shows how to add, remove, and check for specific proposals in a WasmEdge configuration object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n// The `is_bulkmem` will be `true`.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing Store Context in WasmEdge VM\nDESCRIPTION: Demonstrates creating and managing Store contexts within a VM context, showing both automatic and manual Store context lifecycle management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in C\nDESCRIPTION: This snippet shows how to query the imports and exports of an AST Module context. This is useful for examining module interfaces before instantiation to ensure all required imports are available.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/* If the list length is larger than the buffer length, the overflowed data will be discarded. */\nuint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/* If the list length is larger than the buffer length, the overflowed data will be discarded. */\nuint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */\n```\n\n----------------------------------------\n\nTITLE: Performing an Asynchronous HTTP POST Request with hyper\nDESCRIPTION: This Rust code shows how to execute an asynchronous HTTP POST operation using the hyper library. It involves building a POST request with a specified body and processing the response to output the returned data as a string.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nasync fn post_url_return_str (url: hyper::Uri, post_body: &'static [u8]) -> Result<()> {\n    let client = Client::new();\n    let req = Request::builder()\n        .method(Method::POST)\n        .uri(url)\n        .body(Body::from(post_body))?;\n    let mut res = client.request(req).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!(\"{}\", String::from_utf8_lossy(&resp_data));\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Validating WebAssembly Modules with WasmEdge Validator\nDESCRIPTION: This snippet shows how to use the WasmEdge Validator context to validate a WebAssembly module before instantiation. It includes error handling and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Getting Async Execution Return Value Length\nDESCRIPTION: Demonstrates how to retrieve the length of return values from an asynchronous execution using WasmEdge_AsyncGetReturnsLength() API. Helps in creating appropriate buffers for result retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in WasmEdge\nDESCRIPTION: Demonstrates how to enable various statistics collection mechanisms in WasmEdge, including instruction counting, cost measuring, and time measuring for both runtime and AOT compilation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the instruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Type from Function Instance in WasmEdge\nDESCRIPTION: This snippet demonstrates how to retrieve a function type from a function instance context. The function type is owned by the function context and should not be deleted separately.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n/* Retrieve the function instance from the store context. */\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */\n```\n\n----------------------------------------\n\nTITLE: Handling MIME types in Rust\nDESCRIPTION: This Rust code defines a `MimeType` struct and associated methods for determining the MIME type based on a file extension. The `from_ext` method maps common file extensions (e.g., html, css, js) to their corresponding MIME types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub struct MimeType {\n    pub r#type: String,\n}\n\nimpl MimeType {\n    pub fn new(r#type: &str) -> Self {\n        MimeType {\n            r#type: r#type.to_string(),\n        }\n    }\n\n    pub fn from_ext(ext: &str) -> Self {\n        match ext {\n            \"html\" => MimeType::new(\"text/html\"),\n            \"css\" => MimeType::new(\"text/css\"),\n            \"map\" => MimeType::new(\"application/json\"),\n            \"js\" => MimeType::new(\"application/javascript\"),\n            \"json\" => MimeType::new(\"application/json\"),\n            \"svg\" => MimeType::new(\"image/svg+xml\"),\n            \"wasm\" => MimeType::new(\"application/wasm\"),\n            _ => MimeType::new(\"text/plain\"),\n        }\n    }\n\n    pub fn get(self) -> String {\n        self.r#type\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Nginx Configuration for Rust WASM Module\nDESCRIPTION: Nginx configuration file that sets up the WASM virtual machine, loads the Rust WASM module, and configures HTTP server settings for custom response injection\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/wasm-nginx.md#2025-04-21_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\nworker_processes  1;\n\nerror_log  /tmp/error.log warn;\n\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    wasm_vm wasmedge;\n    init_by_lua_block {\n        local wasm = require(\"resty.proxy-wasm\")\n        package.loaded.plugin = assert(wasm.load(\"fault_injection\",\n            \"/path/to/fault-injection/target/wasm32-wasip1/debug/fault_injection.wasm\"))\n    }\n    server {\n        listen 1980;\n        location / {\n            content_by_lua_block {\n                local wasm = require(\"resty.proxy-wasm\")\n                local ctx = assert(wasm.on_configure(package.loaded.plugin,\n                    '{\"http_status\": 403, \"body\": \"powered by wasm-nginx-module\"}'))\n                assert(wasm.on_http_request_headers(ctx))\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances from Store (WasmEdge-Go pre-v0.10.0)\nDESCRIPTION: This code demonstrates how to load a WASM file, validate it, register/instantiate it in a store, and retrieve exported function instances from both named and anonymous modules. This approach is used in WasmEdge-Go versions before v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n// Create the store object. The store object holds the instances.\nstore := wasmedge.NewStore()\n// Error.\nvar err error\n// AST object.\nvar ast *wasmedge.AST\n\n// Create the loader object.\nloader := wasmedge.NewLoader()\n// Create the validator object.\nvalidator := wasmedge.NewValidator()\n// Create the executor object.\nexecutor := wasmedge.NewExecutor()\n\n// Load the WASM file or the compiled-WASM file and convert into the AST object.\nast, err = loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n  return\n}\n// Validate the WASM module.\nerr = validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n  return\n}\n// Example: register and instantiate the WASM module with the module name \"module_fib\".\nerr = executor.RegisterModule(store, ast, \"module_fib\")\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n// Example: Instantiate the WASM module into the Store object.\nerr = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n\n// Now, developers can retrieve the exported instances from the store.\n// Take the exported functions as example. This WASM exports the function \"fib\".\n// Find the function \"fib\" from the instantiated anonymous module.\nfunc1 := store.FindFunction(\"fib\")\n// Find the function \"fib\" from the registered module \"module_fib\".\nfunc2 := store.FindFunctionRegistered(\"module_fib\", \"fib\")\n\nast.Release()\nstore.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\n```\n\n----------------------------------------\n\nTITLE: Host Function Error Handling - Post 0.11.0\nDESCRIPTION: Updated error handling implementation for WasmEdge 0.11.0+ showing how to specify custom error codes using WasmEdge_ResultGen with support for 24-bit error codes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result FaildFunc(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM with the error code. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Host Module\nDESCRIPTION: Example of registering a host module into WasmEdge store context and cleaning up resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Register the module instance into the store. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Host module registration failed: %s\\n\",\n         WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/*\n * Developers can register the host module into a VM context by the\n * `WasmEdge_VMRegisterModuleFromImport()` API.\n */\n/*\n * The owner of the host module will not be changed. Developers can register\n * the host module into several VMs or stores.\n */\n\n/* Although being registered, the host module should be destroyed. */\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: WASM Module Instantiation (WasmEdge 0.9.1)\nDESCRIPTION: Example of instantiating a WASM module using WasmEdge Executor API in version 0.9.1. The instantiated module is handled by the Store as an anonymous module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt;\n/*\n * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in WasmEdge\nDESCRIPTION: In this Go snippet, developers learn how to configure the maximum number of memory pages in WasmEdge, crucial for controlling the memory growth of WebAssembly modules. The configuration only affects Executor and VM objects. It requires the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\npagesize := conf.GetMaxMemoryPage()\n// By default, the maximum memory page size in each memory instances is 65536.\nconf.SetMaxMemoryPage(1234)\npagesize = conf.GetMaxMemoryPage()\n// `pagesize` will be 1234.\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Optimization Levels and Output Formats in C\nDESCRIPTION: Defines two enumerations: WasmEdge_CompilerOptimizationLevel for various optimization levels (O0 through Oz) and WasmEdge_CompilerOutputFormat for specifying output binary formats. The optimization levels range from minimal optimization (O0) to size-optimized (Oz), while output formats include native dynamic library and WebAssembly with AOT compiled code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_75\n\nLANGUAGE: c\nCODE:\n```\n/// AOT compiler optimization level enumeration.\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\n/// AOT compiler output binary format enumeration.\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom sections.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions\nDESCRIPTION: Demonstrates how to inspect and list exported functions from a WASM module after instantiation, including function names and types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a WASM Function with std::cout and std::string\nDESCRIPTION: This snippet showcases how to pass extern references of std::cout and a std::string object to a WASM function and execute it. The function call results in printing the string to stdout.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nstd::string PrintStr(\"Hello world!\");\nWasmEdge_Value P[2], R[1];\nP[0] = WasmEdge_ValueGenExternRef(&std::cout);\nP[1] = WasmEdge_ValueGenExternRef(&PrintStr);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"call_ostream_str\");\nWasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);\n// Will print \"Hello world!\" to stdout.\nWasmEdge_StringDelete(FuncName);\nif (!WasmEdge_ResultOK(Res)) {\n  return EXIT_FAILURE;\n}\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Lite Session Creation in Rust\nDESCRIPTION: Code for creating a TensorFlow Lite session\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// The mod_buf is a vec<u8> which contains the model data.\nlet mut session = wasmedge_tensorflow_interface::TFLiteSession::new(&mod_buf);\n```\n\n----------------------------------------\n\nTITLE: Implementing Plugin Wrapper Functions in Rust\nDESCRIPTION: Rust implementation of safe wrapper functions that interface with the generated plugin code, providing memory-safe access to the plugin functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod generated;\n\npub fn imdecode(buf: &[u8]) -> u32 {\n    unsafe { generated::imdecode(buf.as_ptr(), buf.len()) }\n}\npub fn imshow(window_name: &str, mat_key: u32) -> () {\n    unsafe { generated::imshow(window_name.as_ptr(), window_name.len(), mat_key) }\n}\npub fn waitkey(delay: u32) -> () {\n    unsafe { generated::waitkey(delay) }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge Value Types in C\nDESCRIPTION: This code demonstrates how to use WasmEdge_Value objects to work with different WASM value types, including integer and floating-point numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \"123456\" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \"1234567890123\" */\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \"123.456001\" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \"123456.1234567890\" */\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances from Module Instances in WasmEdge 0.10.0+\nDESCRIPTION: Shows how to load a WASM module, register it with a name, instantiate it, and retrieve exported function instances from module instance contexts in WasmEdge version 0.10.0 and later. The code demonstrates finding functions within both named and anonymous module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\n/* Create the store context. The store context is the object to link the modules for imports and exports. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n/* Create the executor context. The configure context and the statistics context can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Validate the WASM module. */\nRes = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: register and instantiate the WASM module with the module name \"module_fib\". */\nWasmEdge_ModuleInstanceContext *NamedModCxt = NULL;\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module_fib\");\nRes = WasmEdge_ExecutorRegister(ExecCxt, &NamedModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: Instantiate the WASM module and get the output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* Now, developers can retrieve the exported instances from the module instances. */\n/* Take the exported functions as example. This WASM exports the function \"fib\". */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FoundFuncCxt;\n/* Find the function \"fib\" from the instantiated anonymous module. */\nFoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n/* Find the function \"fib\" from the registered module \"module_fib\". */\nFoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(NamedModCxt, FuncName);\n/* Or developers can get the named module instance from the store: */\nModName = WasmEdge_StringCreateByCString(\"module_fib\");\nconst WasmEdge_ModuleInstanceContext *ModCxtGot = WasmEdge_StoreFindModule(StoreCxt, ModName);\nWasmEdge_StringDelete(ModName);\nFoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxtGot, FuncName);\nWasmEdge_StringDelete(FuncName);\n\nWasmEdge_ModuleInstanceDelete(NamedModCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\nWasmEdge_ASTModuleDelete(ASTCxt);\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ValidatorDelete(ValidCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports/Exports in Go WasmEdge\nDESCRIPTION: Shows how to query and list the imports and exports of a WASM AST Module object after loading from a WASM file or buffer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in Go\nDESCRIPTION: Example of enabling instruction counting, cost measuring, and time measuring for performance monitoring in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsInstructionCounting(true)\n// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsTimeMeasuring(true)\n// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsCostMeasuring(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge Reference Types\nDESCRIPTION: This C code demonstrates how to work with WasmEdge reference types, specifically `funcref` and `externref`, using functions like `WasmEdge_ValueGenNullRef`, `WasmEdge_ValueGenFuncRef`, `WasmEdge_ValueGenExternRef`, `WasmEdge_ValueIsNullRef`, `WasmEdge_ValueGetFuncRef`, and `WasmEdge_ValueGetExternRef`. It shows how to create references to function instances and external data. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\n/* Generate a externref to NULL. */\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\n/* The `IsNull` will be `TRUE`. */\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `NULL`. */\n\n/* Get the function instance by creation or from module instance. */\nconst WasmEdge_FunctionInstanceContext *FuncCxt = ...;\n/* Generate a funcref with the given function instance context. */\nVal = WasmEdge_ValueGenFuncRef(FuncCxt);\nconst WasmEdge_FunctionInstanceContext *GotFuncCxt = WasmEdge_ValueGetFuncRef(Val);\n/* The `GotFuncCxt` will be the same as `FuncCxt`. */\n\n/* Generate a externref to `Num`. */\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `&Num`. */\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \"10\" */\nNum += 55;\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \"65\" */\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Global Type Context in C\nDESCRIPTION: Demonstrates the creation of a Global Type context with a specific value type and mutability, and how to query information from it. This is used for global instance creation and information retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Runtime Tool via C API\nDESCRIPTION: This C code snippet uses the WasmEdge_Driver_Tool function to execute the WasmEdge runtime tool, passing command line arguments. Requires the WasmEdge library and a C compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_32\n\nLANGUAGE: C\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Proposals in WasmEdge\nDESCRIPTION: This code snippet demonstrates how to create a configuration context and manage proposals within it, including adding and removing specific proposals and checking their status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WASM Export Listing Example (Bash)\nDESCRIPTION: Command line instructions for compiling the exported function listing example with GCC and running it. Shows how to link against the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\n```\n\n----------------------------------------\n\nTITLE: Wrapping Buffers as WasmEdge Strings\nDESCRIPTION: Shows how to wrap an existing buffer as a WasmEdge_String without copying the content. The caller must manage the buffer lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"test\";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Retrieving Async Execution Results in C\nDESCRIPTION: Shows how to get return values from an asynchronous execution using a buffer\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Registrations in WasmEdge\nDESCRIPTION: Example showing how to enable WASI support in a WasmEdge configuration object. This is useful for VM contexts that need to interact with the host system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.WASI)\nconf.AddConfig(wasmedge.WASI)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Processing and Printing Inference Results in Rust\nDESCRIPTION: Rust code to sort the inference results and print the top 5 classifications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet results = sort_results(&output_buffer);\nfor i in 0..5 {\n  println!(\n    \"   {}.) [{}]({:.4}){}\",\n    i + 1,\n    results[i].0,\n    results[i].1,\n    imagenet_classes::IMAGENET_CLASSES[results[i].0]\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Unified CLI Tool API in C\nDESCRIPTION: Example of using WasmEdge_Driver_UniTool() API to access the unified WasmEdge functionality programmatically, which is equivalent to the 'wasmedge' command with various subcommands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_93\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge unified tool. */\n  /* (Within both runtime and AOT compiler) */\n  return WasmEdge_Driver_UniTool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Plugin Module Names\nDESCRIPTION: Method to retrieve all module names available in a plugin context as a vector of strings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub fn mod_names(&self) -> Vec<String>\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C\nDESCRIPTION: Function signature template for implementing host functions in WasmEdge with parameters for data, calling frame context, input parameters and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Listing Imports and Exports of AST using Go\nDESCRIPTION: In this snippet, the loaded structure of a WASM file or buffer is queried to list its imports and exports. It is crucial for understanding what interfaces the WASM module exposes and requires.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_64\n\nLANGUAGE: go\nCODE:\n```\nast := ...\n// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.\n\n// List the imports.\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\n// List the exports.\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Functions with CallingFrame\nDESCRIPTION: Shows how to use the CallingFrame object to access WebAssembly module's memory from a host function, enabling data exchange between host and WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_62\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"encoding/binary\"\n  \"fmt\"\n)\n\n// Host function body definition.\nfunc LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // Function type: {i32} -> {}\n  offset := params[0].(int32)\n\n  // Get the 0th memory instance of the module of the top frame on the stack.\n  mem := callframe.GetMemoryByIndex(0)\n\n  data, err := mem.GetData(uint(offset), 4)\n  if err != nil {\n    return nil, err\n  }\n  fmt.Println(\"u32 at memory[{}]: {}\", offset, binary.LittleEndian.Uint32(data))\n  return nil, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Async Wait Implementation in C\nDESCRIPTION: Demonstrates basic waiting for asynchronous execution completion in WasmEdge. Shows how to wait indefinitely for an async operation to complete.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Android Native Integration with TensorFlow Lite\nDESCRIPTION: C code that demonstrates integrating WasmEdge with TensorFlow Lite in an Android native application. The code creates a WasmEdge VM, registers image processing and TensorFlow Lite modules, and executes a WebAssembly function for bird image classification.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/ndk.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <wasmedge/wasmedge-image.h>\n#include <wasmedge/wasmedge-tensorflowlite.h>\n\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n  /*\n   * argv[0]: ./a.out\n   * argv[1]: WASM file\n   * argv[2]: tflite model file\n   * argv[3]: image file\n   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n   */\n\n  /* Create the VM context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n  WasmEdge_ConfigureDelete(ConfCxt);\n\n  /* Create the image and TFLite import objects. */\n  WasmEdge_ModuleInstanceContext *ImageImpObj = WasmEdge_Image_ModuleInstanceCreate();\n  WasmEdge_ModuleInstanceContext *TFLiteImpObj = WasmEdge_TensorflowLite_ModuleInstanceCreate();\n  WasmEdge_ModuleInstanceContext *TFDummyImpObj = WasmEdge_Tensorflow_ModuleInstanceCreateDummy();\n\n  /* Register into VM. */\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);\n\n  /* Init WASI. */\n  const char *Preopens[] = {\".:.\"};\n  const char *Args[] = {argv[1], argv[2], argv[3]};\n  WasmEdge_ModuleInstanceContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n  WasmEdge_ModuleInstanceInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);\n\n  /* Run WASM file. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"_start\");\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);\n  WasmEdge_StringDelete(FuncName);\n\n  /* Check the result. */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Run WASM failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  WasmEdge_ModuleInstanceDelete(ImageImpObj);\n  WasmEdge_ModuleInstanceDelete(TFLiteImpObj);\n  WasmEdge_ModuleInstanceDelete(TFDummyImpObj);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge Proposals in C\nDESCRIPTION: This C code snippet shows how to create a `WasmEdge_ConfigureContext`, add a proposal (`WasmEdge_Proposal_MultiMemories`), remove a proposal (`WasmEdge_Proposal_ReferenceTypes`), and check if a proposal is enabled (`WasmEdge_Proposal_BulkMemoryOperations`). The `Configure` context is used to manage the configuration of the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\n```c\n/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n *\n * For the current WasmEdge version, the following proposals are supported\n * (turned off by default) additionally:\n * * Tail-call\n * * Multiple memories\n * * Extended-const\n * * Threads\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Version APIs in C\nDESCRIPTION: This snippet shows how to use various WasmEdge C API functions to retrieve version information, including major, minor, and patch numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version for WasmEdge-Go Installation\nDESCRIPTION: Verifies the installed Go version meets minimum requirement of 1.16\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Creating WasmEdge Module Instance with Host Data and Finalizer\nDESCRIPTION: Demonstrates how to set host data into a module instance with a custom finalizer function. This pattern is useful when implementing plug-ins that need to manage their own resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_82\n\nLANGUAGE: c\nCODE:\n```\n/* Struct definition. */\ntypedef struct Point {\n  int X;\n  int Y;\n} Point;\n\n/* Host function body definition. */\nWasmEdge_Result Print(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  Point *P = (Point *)In;\n  printf(\"Point: (%d, %d)\\n\", P->X, P->Y);\n  return WasmEdge_Result_Success;\n}\n\n/* Finalizer definition. */\nvoid PointFinalizer(void *Data) {\n  if (Data) {\n    free((Point *)Data);\n  }\n}\n\n/* Create a module instance with host data and its finalizer. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nPoint *Data = (Point *)malloc(sizeof(Point));\nData->X = 5;\nData->Y = -5;\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);\n/*\n* When the `HostModCxt` being destroyed, the finalizer will be invoked and the\n* `Data` will be its argument.\n*/\nWasmEdge_StringDelete(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Project\nDESCRIPTION: Shows how to build and run the WasmEdge Go project, including getting the WasmEdge-go dependency and executing the compiled binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nExported function name: fib\n[2021-11-24 18:53:01.451] [debug]  Execution succeeded.\n[2021-11-24 18:53:01.452] [debug]\n ====================  Statistics  ====================\n Total execution time: 556372295 ns\n Wasm instructions execution time: 556372295 ns\n Host functions execution time: 0 ns\n Executed wasm instructions count: 28271634\n Gas costs: 0\n Instructions per second: 50814237\nGet fibonacci[30]: 1346269\n```\n\n----------------------------------------\n\nTITLE: VM Creation Patterns in Go\nDESCRIPTION: Examples of different ways to create WasmEdge VM instances with various configurations and store objects. Shows multiple initialization patterns with proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Running WASM Functions with WasmEdge in C\nDESCRIPTION: This C code snippet demonstrates running a WASM function named \"fib\" asynchronously using WasmEdge. Dependencies include the WasmEdge C API and the `fibonacci.wasm` file. The program initializes a VM context, sets parameters, and executes the WASM function asynchronously. Upon completion, it retrieves the result and prints it. Inputs include the WASM filename and function name, while the output is the function's computed result. Error handling is demonstrated for loading and execution phases.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\\n#include <stdio.h>\\nint main() {\\n  /* Create the VM context. */\\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\\n\\n  /* The parameters and returns arrays. */\\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\\n  WasmEdge_Value Returns[1];\\n  /* Function name. */\\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\\n  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */\\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\\n  /*\\n   * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,\\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\\n   */\\n\\n  /* Wait for the execution. */\\n  WasmEdge_AsyncWait(Async);\\n  /*\\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs\\n   * to wait for the asynchronous execution. These APIs will wait until the execution finished.\\n   */\\n\\n  /* Check the return values length. */\\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\\n  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */\\n\\n  /* Get the result. */\\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\\n\\n  if (WasmEdge_ResultOK(Res)) {\\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\\n  } else {\\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\\n  }\\n\\n  /* Resources deallocations. */\\n  WasmEdge_AsyncDelete(Async);\\n  WasmEdge_VMDelete(VMCxt);\\n  WasmEdge_StringDelete(FuncName);\\n  return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Building LLM Chat Application from Source\nDESCRIPTION: Commands to clone the LlamaEdge repository and build the chat application using Cargo for the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/LlamaEdge/LlamaEdge.git\ncd chat\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Loading WebAssembly Modules with WasmEdge Loader\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge Loader context to load WebAssembly modules from files or buffers. It includes error handling and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function to Output std::string\nDESCRIPTION: This snippet defines a host function that outputs a std::string to a std::ostream using extern references. It takes in two extern reference values and uses them to manipulate output streams in C++.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// Host function to output std::string through std::ostream\nWasmEdge_Result ExternSTLOStreamStr(void *,\n                                    const WasmEdge_CallingFrameContext *,\n                                    const WasmEdge_Value *In,\n                                    WasmEdge_Value *) {\n  // Function type: {externref, externref} -> {}\n  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);\n  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);\n  std::ostream &RefOS = *reinterpret_cast<std::ostream *>(Ptr0);\n  std::string &RefStr = *reinterpret_cast<std::string *>(Ptr1);\n  RefOS << RefStr;\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Runtime CLI Tool API in C\nDESCRIPTION: Example of using WasmEdge_Driver_Tool() API to run WasmEdge runtime functionality programmatically, which is equivalent to the 'wasmedge run' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_91\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Import Type Context in WasmEdge\nDESCRIPTION: Example of retrieving import information from an AST Module, including external type, module name, external name, and specific type information. Import Type contexts are used for examining module imports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/*\n * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the\n * result of loading a WASM file.\n */\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\n/*\n * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,\n * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`,\n * `WasmEdge_ExternalType_Tag`, or `WasmEdge_ExternalType_Global`.\n */\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\n/*\n * The `ModName` and `ExtName` should not be destroyed and the string\n * buffers are binded into the `ASTCxt`.\n */\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the\n * `FuncTypeCxt` will be NULL.\n */\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_TagTypeContext *TagTypeCxt =\n    WasmEdge_ImportTypeGetTagType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Tag`, the `TagTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`\n * will be NULL.\n */\n```\n\n----------------------------------------\n\nTITLE: Handling WasmEdge_Result Objects in C\nDESCRIPTION: This snippet shows how to work with WasmEdge_Result objects, including checking success status, retrieving error codes and messages, and generating custom results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be \"success\". */\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_WASM. */\n\nRes = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);\n/* Generate the user-defined result with code. */\nCode = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 123. */\nCategory = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */\n```\n\n----------------------------------------\n\nTITLE: Async Return Length Check in C\nDESCRIPTION: Demonstrates how to get the length of return values from an async execution. Used to determine buffer size for receiving results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return value list length. */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI Support in WasmEdge C\nDESCRIPTION: This snippet initializes the WASI support in the WasmEdge VM context by creating a configuration context, adding the WASI host registration, and obtaining the module instance context for WASI. It then initializes the WASI module before deleting the VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the built-in registered module instances\n * from the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding configuration is not set\n * when creating the VM context.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                      WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Function Object in WasmEdge-go\nDESCRIPTION: Shows how to create a Function object in WasmEdge-go using a host function body and function type. This object can be added to an import object for use in WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an import object object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Getting Active Module in WasmEdge C API\nDESCRIPTION: Demonstrates how to retrieve the active module instance from a VM context after instantiation. This allows access to the module's exports, memories, and other resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge Proposals in Go\nDESCRIPTION: This code snippet demonstrates how to configure WasmEdge proposals using the `wasmedge.Configure` object in Go. It shows how to add and remove specific proposals, and how to check if a proposal is enabled. The snippet initializes a `Configure` object, adds the `SIMD` proposal, removes the `REFERENCE_TYPES` proposal, and checks if `BULK_MEMORY_OPERATIONS` is enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\n```go\n   // By default, the following proposals have turned on initially:\n   // * IMPORT_EXPORT_MUT_GLOBALS\n   // * NON_TRAP_FLOAT_TO_INT_CONVERSIONS\n   // * SIGN_EXTENSION_OPERATORS\n   // * MULTI_VALUE\n   // * BULK_MEMORY_OPERATIONS\n   // * REFERENCE_TYPES\n   // * SIMD\n   conf := wasmedge.NewConfigure()\n   // Developers can also pass the proposals as parameters:\n   // conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\n   conf.AddConfig(wasmedge.SIMD)\n   conf.RemoveConfig(wasmedge.REFERENCE_TYPES)\n   is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n   // The `is_bulkmem` will be `true`.\n   conf.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Standalone WebAssembly Application - Rust\nDESCRIPTION: This Rust code shows a `main` function that can be compiled into a standalone WebAssembly application.  The `main` function demonstrates using the random number generation, printing, environment variable access, and file system operations within the WASI environment.  It also calls the helper functions defined earlier to show a full sample application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n\"fn main() {\\n  println!(\\\"Random number: {}\\\", get_random_i32());\\n  println!(\\\"Random bytes: {:?}\\\", get_random_bytes());\\n  println!(\\\"{}\\\", echo(\\\"This is from a main function\\\"));\\n  print_env();\\n  create_file(\\\"tmp.txt\\\", \\\"This is in a file\\\");\\n  println!(\\\"File content is {}\\\", read_file(\\\"tmp.txt\\\"));\\n  del_file(\\\"tmp.txt\\\");\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Module Instance Management in WasmEdge C API\nDESCRIPTION: Demonstrates how to list and find exported instances from a WASM module instance. Shows examples of listing function instances and finding specific functions by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n}\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution Completion in WasmEdge C API\nDESCRIPTION: Demonstrates how to wait for an asynchronous execution to complete using WasmEdge_AsyncWait() and properly clean up resources by deleting the async handle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Image Processing Function in Node.js\nDESCRIPTION: Node.js script that loads the WasmEdge runtime, executes the compiled WebAssembly image processing function, and handles input/output for the serverless function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst fs = require('fs');\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nmodule.exports = (req, res) => {\n  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [\n    path.join(__dirname, 'grayscale.so'),\n  ]);\n\n  let d = [];\n  wasmedge.stdout.on('data', (data) => {\n    d.push(data);\n  });\n\n  wasmedge.on('close', (code) => {\n    let buf = Buffer.concat(d);\n\n    res.setHeader('Content-Type', req.headers['image-type']);\n    res.send(buf);\n  });\n\n  wasmedge.stdin.write(req.body);\n  wasmedge.stdin.end('');\n};\n```\n\n----------------------------------------\n\nTITLE: Getting Asynchronous Execution Results\nDESCRIPTION: This snippet demonstrates how to block and wait for an asynchronous execution to complete while fetching the result values into a predefined buffer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Configuring Cost Table for WasmEdge Statistics with Go\nDESCRIPTION: This snippet shows how to set a cost table in the WasmEdge Statistics object using Go, which allocates execution weights to instructions. A limit can trigger a 'cost limit exceeded' error during runtime. It assumes WasmEdge Go SDK setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nstat := wasmedge.NewStatistics()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0,\n}\n// Developers can set the costs of each instruction. The value not covered will be 0.\n\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\n\n// ... After running the WASM functions with the `Statistics` object\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: New Plugin Configuration in VM (v0.12.0+)\nDESCRIPTION: Example showing automatic plugin loading and module registration in v0.12.0+, where plugins are automatically loaded and mock modules are registered when plugins are not installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n// The `wasmedge.WASI` is still needed.\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nmodulelist := vm.ListRegisteredModule()\nfor _, name := range modulelist {\n  fmt.Println(name)\n}\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Building and Starting the React SSR Server\nDESCRIPTION: These commands build the client-side app, bundle and transpile the server code, and start the WasmEdge server on port 8002 for the React SSR application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run dev:build-server\nnpm run dev:start-server\n```\n\n----------------------------------------\n\nTITLE: Rapid Execution of WebAssembly Function with WasmEdge VM in C\nDESCRIPTION: This C code demonstrates how to quickly execute a WebAssembly function using the WasmEdge VM context. It loads a WASM file, runs the 'fib' function, and prints the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.\n   */\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAssembly Proposals in WasmEdge\nDESCRIPTION: This Go snippet demonstrates setting up WebAssembly proposals using the WasmEdge 'Configure' object. It allows enabling or disabling features such as SIMD, bulk memory operations, and multi-value returns, with the possibility to add or remove proposals dynamically. Dependencies include the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL = Proposal(C.WasmEdge_Proposal_TailCall)\n  ANNOTATIONS = Proposal(C.WasmEdge_Proposal_Annotations)\n  MEMORY64 = Proposal(C.WasmEdge_Proposal_Memory64)\n  EXCEPTION_HANDLING = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n  EXTENDED_CONST = Proposal(C.WasmEdge_Proposal_ExtendedConst)\n  THREADS = Proposal(C.WasmEdge_Proposal_Threads)\n  FUNCTION_REFERENCES = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n)\n```\n\nLANGUAGE: Go\nCODE:\n```\n// By default, the following proposals have turned on initially:\n// * IMPORT_EXPORT_MUT_GLOBALS\n// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS\n// * SIGN_EXTENSION_OPERATORS\n// * MULTI_VALUE\n// * BULK_MEMORY_OPERATIONS\n// * REFERENCE_TYPES\n// * SIMD\n// For the current WasmEdge version, the following proposals are supported:\n// * TAIL_CALL\n// * MULTI_MEMORIES\n// * THREADS\n// * EXTENDED_CONST\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n// The `is_bulkmem` will be `true`.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Using Instruction Counter in WasmEdge Statistics\nDESCRIPTION: Example showing how to retrieve instruction count and instructions per second after running WASM functions with a Statistics object. Requires statistics configuration to be enabled first.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_28\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n// ... After running the WASM functions with the `Statistics` object\n\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM with Go\nDESCRIPTION: This snippet illustrates registering a host module into a WasmEdge VM. It creates a new VM instance, initializes a WASI module, and checks the result of the registration process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nwasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)\nres := vm.RegisterModule(wasiobj)\nvm.Release()\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Hello World JavaScript Source Code\nDESCRIPTION: Simple JavaScript program that prints command line arguments and demonstrates setTimeout functionality\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as os from 'os';\nimport * as std from 'std';\n\nargs = args.slice(1);\nprint('Hello', ...args);\nsetTimeout(() => {\n  print('timeout 2s');\n}, 2000);\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plugins\nDESCRIPTION: Shows how to create module instances from a plugin context and list available host modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/* Will print here for the WASI-Crypto plug-in here:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = \"wasi_ephemeral_crypto_common\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with WASI-NN GGML Plugin\nDESCRIPTION: Installs WasmEdge Runtime along with the wasi_nn-ggml plugin to enable LLM (Large Language Model) inference capabilities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml\n```\n\n----------------------------------------\n\nTITLE: Working with Function Instances in C\nDESCRIPTION: Shows how to retrieve a function instance from a module instance and get its function type. This is useful for examining the signature of a function before calling it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\n/* Retrieve the function instance from the module instance context. */\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */\n\n/* For the function instance creation, please refer to the `Host Function` guide. */\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go\nDESCRIPTION: Definition of the standard host function signature type in WasmEdge-Go that handles data, calling frame and parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_68\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: List Registered Modules in WasmEdge VM in Go\nDESCRIPTION: This code snippet lists the registered module names in a WasmEdge VM. It uses the `ListRegisteredModule` API to retrieve the list of module names and then prints them to the console. The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\n// Assume that the `vm` is the created `wasmedge.VM` object.\nmodnames := vm.ListRegisteredModule()\nfor _, name := range modnames {\n  fmt.Println(\"Registered module name: \", name)\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Module Instance with Host Instances in C\nDESCRIPTION: Shows how to create a Module instance with a module name and add Function, Memory, Table, and Global instances to it with their exporting names. This example focuses on adding a Function instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_79\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Table Instances in C\nDESCRIPTION: Shows the process of creating a table instance, setting and getting data, growing the table size, and handling potential errors. It also demonstrates how to retrieve and use the table type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {.HasMax = true, .Min = 10, .Max = 20};\n/* Create the table type with limit and the `FuncRef` element type. */\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\n/* Create the table instance with table type. */\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);\n/* Delete the table type. */\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\n/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `RefType` will be `WasmEdge_RefType_FuncRef`. */\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\n/* Set the function index 5 to the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);\n */\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n/* Get the FuncRef value of the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);\n */\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\n/* `Size` will be 10. */\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n/* Grow the table size of 6, the table size will be 16. */\n/*\n * This will get an \"out of bounds table access\" error because\n * the size (16 + 6) will reach the table limit(20):\n *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);\n */\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Running NPM Modules in WasmEdge JavaScript\nDESCRIPTION: Example of importing and using third-party modules md5 and mathjs in a JavaScript application bundled for WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/npm.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst md5 = require('md5');\nconsole.log('md5(message)=', md5('message'));\n\nconst { sqrt } = require('mathjs');\nconsole.log('sqrt(-4)=', sqrt(-4).toString());\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Function Types in Go\nDESCRIPTION: Demonstrates creation and manipulation of WASM function type contexts, including parameter and return value type handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Global Instance Management in C\nDESCRIPTION: Demonstrates creation and manipulation of global instances including value setting, type management, and mutation handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nenum WasmEdge_Mutability ValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n```\n\n----------------------------------------\n\nTITLE: Error Handling Implementation\nDESCRIPTION: Example of handling execution results and errors in WasmEdge-Go\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\nres, err = vm.Execute(...) // Ignore the detail of parameters.\n// Assume that `res, err` are the return values for executing a function with `vm`.\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n  category := err.GetErrorCategory()\n  // The `category` will be `wasmedge.ErrCategory_WASM`.\n}\n\nuserdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)\n// Generate the user-defined error with code.\ncode := userdef_err.GetCode()\n// The `Code` will be 123456.\n```\n\n----------------------------------------\n\nTITLE: Working with ExportType for Module Exports in WasmEdge-go\nDESCRIPTION: Shows how to retrieve and query export information from an AST Module. ExportType objects provide details about functionality exposed by a WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge_String Objects in C\nDESCRIPTION: This code demonstrates various operations with WasmEdge_String objects, including creation, wrapping, comparison, and conversion to C strings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n\nconst char CStr[] = \"test\";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */\n\nconst char CStr[] = \"abcd\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\n\nchar Buf[256];\nWasmEdge_String Str =\n    WasmEdge_StringCreateByCString(\"test_wasmedge_string\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf(\"String: %s\\n\", Buf);\n/* Will print \"test_wasmedge_string\". */\n```\n\n----------------------------------------\n\nTITLE: Using Import Type Context in C\nDESCRIPTION: Shows how to use an Import Type context to retrieve information about imported modules, including external type, module name, and external name. This is used for querying import information from an AST Module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Get Active Module from WasmEdge VM in Go\nDESCRIPTION: This code snippet retrieves the active module instance from a WasmEdge VM.  It assumes a WASM module is already instantiated in the VM. It illustrates how to use the `GetActiveModule` API. The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nmod := vm.GetActiveModule()\n// If there's no WASM module instantiated, this API will return `nil`.\n// Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Validator Context\nDESCRIPTION: This snippet shows how to use the WasmEdge Validator context to validate a WebAssembly module before instantiation. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN ChatTTS Backend\nDESCRIPTION: This snippet explains how to build WasmEdge from source with the ChatTTS backend enabled, using the necessary CMake flags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"chatTTS\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Type from Function Instance in Go\nDESCRIPTION: Shows how to retrieve the function type from a function instance obtained from a store object. Note that the function object and function type retrieved should not be manually released.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\nfuncinst := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the store object.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the store object should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly with WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C API to compile a WebAssembly file. It creates a configuration context, initializes a compiler context, and compiles a WASM file to an AOT (Ahead-of-Time) format.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_89\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\",\n                                 \"fibonacci-aot.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions - Post 0.11.0\nDESCRIPTION: Updated implementation for accessing memory in host functions using CallingFrameContext in WasmEdge 0.11.0+, supporting multiple memories and recursive invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /* Get the 0th memory instance of the module of the top frame on the stack. */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading PyTorch Model and Performing Inference in Rust\nDESCRIPTION: Rust code to load a PyTorch model, set input tensor, perform inference, and retrieve output using WASI-NN.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet graph = wasi_nn::GraphBuilder::new(\n    wasi_nn::GraphEncoding::Pytorch,\n    wasi_nn::ExecutionTarget::CPU,\n).build_from_files([model_bin_name]).unwrap();\nlet mut context = graph.init_execution_context().unwrap();\n\nlet tensor_data = image_to_tensor(image_name.to_string(), 224, 224);\ncontext.set_input(0, wasi_nn::TensorType::F32, &[1, 3, 224, 224], &tensor_data).unwrap();\n\ncontext.compute().unwrap();\n\nlet mut output_buffer = vec![0f32; 1000];\ncontext.get_output(0, &mut output_buffer).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules (Go)\nDESCRIPTION: Shows how to register a WASM module, execute a function from the registered module, and handle the result in a WasmEdge VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  // Register the WASM module from file into VM with the module name \"mod\".\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n  // The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n  // name \"mod\". As the same as host functions, other modules can import the\n  // function `\"mod\" \"fib\"`.\n\n  // Execute WASM functions in registered modules.\n  // Unlike the execution of functions, the registered functions can be\n  // invoked without `(*VM).Instantiate` because the WASM module was\n  // instantiated when registering.\n  // Developers can also invoke the host functions directly with this API.\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Example WebAssembly Module with Import Function\nDESCRIPTION: A simple WebAssembly module in WAT format that imports a host function called 'trap' from the 'extern' module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_64\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32)))\n  (import \"extern\" \"trap\" (func $f-trap (type $t0)))\n  (func (export \"trap\") (param i32)\n    local.get 0\n    call $f-trap))\n```\n\n----------------------------------------\n\nTITLE: Configuring Interpreter Mode in WasmEdge\nDESCRIPTION: Shows how to enable or disable forcible interpreter mode in the WasmEdge configuration context. This affects the execution mode of WASM files and AOT compiled WASM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* By default, The `IsForceInterp` will be `FALSE`. */\nWasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);\nIsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* The `IsForceInterp` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-NN Pre-registration\nDESCRIPTION: Demonstrates enabling WASI-NN proposal support in WasmEdge VM configuration for neural network operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */\nWasmEdge_ModuleInstanceContext *NNModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering AST Object as Named Module in Go\nDESCRIPTION: Demonstrates how to instantiate and register an AST object as a named Module instance in a Store using the Executor. This allows the module to be linked when instantiating other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_58\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Register the loaded WASM `ast` into store with the export module name \"mod\".\nmod, res := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\n// ...\n\n// Resources deallocations.\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Neural Network Graph in Rust\nDESCRIPTION: Rust code for creating a new Graph using GraphBuilder and loading the specified model.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// load the model to wasi-nn\n     let graph =\n        wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, wasi_nn::ExecutionTarget::AUTO)\n            .build_from_cache(&model_name)\n            .expect(\"Failed to load the model\");\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Definition in WAT Format\nDESCRIPTION: A WebAssembly Text (WAT) format module definition that imports an external function \"func-add\" from the \"extern\" module, and exports a function \"addTwo\" that calls the imported function with its parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_72\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format (WAT) implementation of a recursive Fibonacci function that can be converted to binary WASM format. The function takes an integer parameter and returns the corresponding Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_27\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Result Handling\nDESCRIPTION: Demonstrates creating, checking, and extracting information from WasmEdge execution results\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\\nbool IsSucceeded = WasmEdge_ResultOK(Res);\\nuint32_t Code = WasmEdge_ResultGetCode(Res);\\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Import Type Context in Go\nDESCRIPTION: Examples of working with import type contexts for handling WASM module imports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Handling WasmEdge Values (C)\nDESCRIPTION: Demonstrates how to create and manipulate WasmEdge_Value objects for various WASM value types, including number types and reference types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\n\nVal = WasmEdge_ValueGenI32(123456);\nbool IsTypeI32 = WasmEdge_ValTypeIsI32(Val.Type);\n/* The `IsTypeI32` will be `TRUE`. */\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \"123456\" */\n\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nbool IsTypeI64 = WasmEdge_ValTypeIsI64(Val.Type);\n/* The `IsTypeI64` will be `TRUE`. */\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \"1234567890123\" */\n\nVal = WasmEdge_ValueGenF32(123.456f);\nbool IsTypeF32 = WasmEdge_ValTypeIsF32(Val.Type);\n/* The `IsTypeF32` will be `TRUE`. */\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \"123.456001\" */\n\nVal = WasmEdge_ValueGenF64(123456.123456789);\nbool IsTypeF64 = WasmEdge_ValTypeIsF64(Val.Type);\n/* The `IsTypeF64` will be `TRUE`. */\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \"123456.1234567890\" */\n```\n\n----------------------------------------\n\nTITLE: Installing Go on KubeEdge Master Node\nDESCRIPTION: Downloads and installs Go 1.17.3 on the KubeEdge master node, setting up the PATH environment variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz\n$ tar xzvf go1.17.3.linux-amd64.tar.gz\n\n$ export PATH=/home/${user}/go/bin:$PATH\n$ go version\ngo version go1.17.3 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C\nDESCRIPTION: Defines the function signature for host functions in WasmEdge, which includes parameters for custom data, calling frame context, input parameters, and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Working with ImportType for Module Imports in WasmEdge-go\nDESCRIPTION: Shows how to retrieve and query import information from an AST Module. ImportType objects provide details about external dependencies of a WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Default Paths\nDESCRIPTION: Code snippet demonstrating how to load WasmEdge plugins from default installation paths. This enables extending WasmEdge runtime with additional functionality provided by shared libraries.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_72\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n```\n\n----------------------------------------\n\nTITLE: Running the React SSR Example - Bash\nDESCRIPTION: This command runs the WasmEdge JavaScript runtime with the appropriate flags to start the server and execute the bundled JavaScript file containing the SSR logic.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in WasmEdge\nDESCRIPTION: Demonstrates how to get and set the maximum memory page size in the WasmEdge configuration context. This limits the memory size of each memory instance in WASM execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/*\n * Limit the memory size of each memory instance with not larger than 1024\n * pages (64 MiB).\n */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Accessing Module Instance Exports in Go\nDESCRIPTION: This snippet demonstrates how to list and find exported instances from a WASM module instance. After instantiation, you can retrieve the names of exported functions and look up specific function instances by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Instantiate a WASM module via the executor object and get the `mod` as the output module instance.\n// ...\n\n// List the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncnames := mod.ListFunction()\n\n// Try to find the exported instance of the instantiated WASM module.\n// Take the function instances for example here.\nfuncinst := mod.FindFunction(\"fib\")\n// `funcinst` will be `nil` if the function not found.\n// The returned instance is owned by the module instance and should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Importing Library Functions and Creating Complex Operations\nDESCRIPTION: Demonstrates importing mathematical functions from another WASM module and creating new exported functions that use these imported functions to perform more complex computations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_1\n\nLANGUAGE: wat\nCODE:\n```\n(module\n  (type $type0 (func (param i32 i32)(result i32)))\n  ;; Import the \"add\" function which calculate \"a + b\".\n  (import \"math\" \"add\" (func $math-add (type $type0)))\n  ;; Import the \"mul\" function which calculate \"a * b\".\n  (import \"math\" \"mul\" (func $math-mul (type $type0)))\n  (func (export \"add_and_square\") (param i32 i32) (result i32)\n    ;; Function to add 2 numbers and square it ((a + b)^2).\n    ;; Exported as \"add_and_square\".\n    (call $math-mul\n      (call $math-add (local.get 0) (local.get 1))\n      (call $math-add (local.get 0) (local.get 1))\n    )\n  )\n  (func (export \"sum_of_squares\") (param i32 i32) (result i32)\n    ;; Function to calculate the sum of squares (a^2 + b^2).\n    ;; Exported as \"sum_of_squares\".\n    (call $math-add\n      (call $math-mul (local.get 0) (local.get 0))\n      (call $math-mul (local.get 1) (local.get 1))\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge QuickJS Examples\nDESCRIPTION: Commands for building and running the JavaScript embedding examples using Cargo to compile to WebAssembly and executing with WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd examples/embed_js\ncarbo build --target wasm32-wasip1 --release\nwasmedge --dir .:. target/wasm32-wasip1/release/embed_js.wasm\n```\n\n----------------------------------------\n\nTITLE: Querying Import Type Context in C\nDESCRIPTION: Shows how to query information from an Import Type context, including external type, module name, external name, and specific type information based on the external type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Memory Instances in WasmEdge\nDESCRIPTION: This code demonstrates how to create, manipulate, and destroy a memory instance in WasmEdge. It covers creating a memory type with limits, setting and getting memory data, checking page size, and growing the memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {.HasMax = true, .Min = 1, .Max = 5};\n/* Create the memory type with limit. The memory page size is 64KiB. */\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);\n/* Create the memory instance with memory type. */\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);\n/* Delete the memory type. */\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\n/* Set the data[0:2] to the memory[4096:4098]. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\n/* `PageSize` will be 1. */\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n/* Grow the page size of 2, the page size of the memory instance will be 3. */\n/*\n * This will get an \"out of bounds memory access\" error because\n * the page size (3 + 3) will reach the memory limit(5):\n *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);\n */\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Store Context from VM Context in WasmEdge (C)\nDESCRIPTION: Demonstrates how to get the Store context from a VM context when the VM context owns the Store. In this case, the Store should not be manually deleted since the VM context manages its lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function using Calling Frame (WasmEdge 0.11.0+)\nDESCRIPTION: Example of a host function that accesses memory using the calling frame context in WasmEdge 0.11.0 and later. This approach supports multiple memories and provides access to the module instance on the top frame of the stack.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /* Get the 0th memory instance of the module of the top frame on the stack. */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Vercel Serverless Function for Image Processing\nDESCRIPTION: JavaScript code for the Vercel serverless function that loads the WasmEdge runtime, executes the WebAssembly program, and handles input/output for image processing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst fs = require('fs');\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nmodule.exports = (req, res) => {\n  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [\n    path.join(__dirname, 'grayscale.so'),\n  ]);\n\n  let d = [];\n  wasmedge.stdout.on('data', (data) => {\n    d.push(data);\n  });\n\n  wasmedge.on('close', (code) => {\n    let buf = Buffer.concat(d);\n\n    res.setHeader('Content-Type', req.headers['image-type']);\n    res.send(buf);\n  });\n\n  wasmedge.stdin.write(req.body);\n  wasmedge.stdin.end('');\n};\n```\n\n----------------------------------------\n\nTITLE: Host Function Implementation in C for WasmEdge Example\nDESCRIPTION: C implementation of a host function that adds two integers, showing how to retrieve parameter values and generate a return value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n```\n\n----------------------------------------\n\nTITLE: WASM Module with External Function Import\nDESCRIPTION: WebAssembly module that imports an external function \"func-add\" from the \"extern\" module and exports an \"addTwo\" function that uses the imported function to add two integers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_73\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n)\n```\n\n----------------------------------------\n\nTITLE: Store Context Management in WasmEdge VM\nDESCRIPTION: Demonstrates how to create and manage Store contexts in WasmEdge VM, including both VM-owned and user-managed Store contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating JNI Bridge for WasmEdge in Kotlin\nDESCRIPTION: NativeLib class that acts as a bridge between Kotlin and native code using JNI. It loads the wasmedge_lib shared library, reads the WebAssembly bytecode from assets, and provides a function to call the native implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/apk.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nclass NativeLib(ctx : Context) {\n  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int\n\n  companion object {\n    init {\n      System.loadLibrary(\"wasmedge_lib\")\n    }\n  }\n\n  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(\"fibonacci.wasm\").readBytes()\n\n  fun wasmFibonacci(idx : Int) : Int{\n    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Registered WASM Functions in Go\nDESCRIPTION: Shows how to execute functions from a registered WebAssembly module using WasmEdge's ExecuteRegistered method\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Server\nDESCRIPTION: Command to start the WasmEdge server with the compiled React application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Contexts\nDESCRIPTION: Shows basic context management for WasmEdge objects including creation and deletion of configure contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: Example showing how to set various AOT compiler options including optimization level, output format, IR dumping, and generic binary output. These settings affect the behavior of the WasmEdge compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the optimization level is O3.\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n// By default, the output format is universal WASM.\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n// By default, the dump IR is `false`.\nconf.SetCompilerDumpIR(true)\n// By default, the generic binary is `false`.\nconf.SetCompilerGenericBinary(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Enabling Statistics in WasmEdge Contexts (C)\nDESCRIPTION: This C snippet enables various statistics options such as instruction counting and time measuring in the WasmEdge environment. Dependencies: WasmEdge C library. Outputs: Current status of statistics options.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the instruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Return Values from Asynchronous Execution in WasmEdge C API\nDESCRIPTION: Shows how to get the actual return values from an asynchronous function execution by providing a buffer to store the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded Plugin Names\nDESCRIPTION: Method to retrieve names of all currently loaded plugins as a vector of strings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn names() -> Vec<String>\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge_Process Support in WasmEdge Go SDK\nDESCRIPTION: Go code demonstrating how to enable WasmEdge_Process support in a VM instance using the WasmEdge Go SDK, including retrieving and initializing the WasmEdge_Process import object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_31\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)\nvm := wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nprocconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)\n// Initialize the WasmEdge_Process.\nprocconf.InitWasmEdgeProcess(/* ... ignored */)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Handling Execution Results in Go\nDESCRIPTION: Go code snippet demonstrating how to handle execution results and errors in WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\nres, err = vm.Execute(...) // Ignore the detail of parameters.\n// Assume that `res, err` are the return values for executing a function with `vm`.\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n  category := err.GetErrorCategory()\n  // The `category` will be `wasmedge.ErrCategory_WASM`.\n}\n\nuserdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)\n// Generate the user-defined error with code.\ncode := userdef_err.GetCode()\n// The `Code` will be 123456.\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Defines the WasmEdge_Limit struct used to represent WASM limits. It includes fields for minimum and maximum values, as well as flags for maximum value presence and shared memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge\nDESCRIPTION: Shows how to register WASM modules with exported names in WasmEdge VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances from Store Context (WasmEdge Pre-0.10.0)\nDESCRIPTION: Demonstrates how to load, validate, instantiate a WASM module, and retrieve exported instances from Store context in WasmEdge versions before 0.9.1. This example loads a fibonacci WASM module and accesses the exported 'fib' function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n/* Create the store context. The store context holds the instances. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n/* Create the executor context. The configure context and the statistics context can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Validate the WASM module. */\nRes = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: register and instantiate the WASM module with the module name \"module_fib\". */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module_fib\");\nRes = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: Instantiate the WASM module into the store context. */\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* Now, developers can retrieve the exported instances from the store. */\n/* Take the exported functions as example. This WASM exports the function \"fib\". */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FoundFuncCxt;\n/* Find the function \"fib\" from the instantiated anonymous module. */\nFoundFuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);\n/* Find the function \"fib\" from the registered module \"module_fib\". */\nModName = WasmEdge_StringCreateByCString(\"module_fib\");\nFoundFuncCxt = WasmEdge_StoreFindFunctionRegistered(StoreCxt, ModName, FuncName);\nWasmEdge_StringDelete(ModName);\nWasmEdge_StringDelete(FuncName);\n\nWasmEdge_ASTModuleDelete(ASTCxt);\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ValidatorDelete(ValidCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Basic WebAssembly External Reference Example\nDESCRIPTION: Simple WASM module demonstrating external reference usage by importing a host function that takes externref and i32 parameters and returns an i32 value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_2\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param externref i32) (result i32)))\n  ;; Import a host function which type is {externref i32} -> {i32}\n  (import \"extern_module\" \"functor_square\" (func $functor_square (type $t0)))\n  ;; WASM function which type is {externref i32} -> {i32} and exported as \"call_square\"\n  (func $call_square (export \"call_square\") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)\n    (call $functor_square (local.get $p0) (local.get $p1))\n  )\n  (memory $memory (export \"memory\") 1))\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Step-by-Step Execution Example\nDESCRIPTION: Bash commands demonstrating how to compile the C code with WasmEdge library and run the resulting executable to calculate the 10th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 89\n```\n\n----------------------------------------\n\nTITLE: Registering Modules with WasmEdge Executor in C\nDESCRIPTION: Demonstrates how to register WASM modules and import objects into a WasmEdge Store context using the Executor API. It includes creating necessary contexts, registering a WASM module with a name, and registering an import object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nRes = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_ImportObjectContext *ImpCxt = ...;\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Import object registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n\nWasmEdge_ImportObjectDelete(ImpCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Handling ImportType in WasmEdge Go SDK\nDESCRIPTION: Demonstrates how to work with ImportType objects to retrieve information about imported items in WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader in Go\nDESCRIPTION: Demonstrates how to use the WasmEdge Loader to load WASM modules from files or buffers, supporting both WASM and compiled-WASM formats.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: WASM Module Registration (WasmEdge 0.10.0)\nDESCRIPTION: Updated method for registering a WASM module using WasmEdge_ExecutorRegister API in version 0.10.0. The registered module instance is returned to the caller.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt;\n/*\n * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\n\n/* Register the WASM module into store with the export module name \"mod\". */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nRes = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nWasmEdge_StringDelete(ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Table Type Context in C\nDESCRIPTION: Example of creating and working with Table Type context, including setting limits and reference types for table instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {.HasMax = true, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Finding Exported Functions in Store in Go\nDESCRIPTION: Demonstrates how to find an exported function by name from an instantiated WASM module using the Store object. It creates a Store, assumes a module is instantiated, then attempts to find a specific function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n// ...\n// Instantiate a WASM module via the `*wasmedge.Executor` object.\n// ...\n\n// Try to find the exported functions of the instantiated WASM module.\n// Take the function instances for example here.\nfuncobj := store.FindFunction(\"fib\")\n// `funcobj` will be `nil` if the function not found.\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Registering AST Module in C\nDESCRIPTION: This snippet demonstrates how to instantiate an AST module context into a named Module instance and register it into the Store context. It includes creating necessary contexts, registering the module, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/*\n * Register the WASM module into the store with the export module name\n * \"mod\".\n */\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Validator in Go\nDESCRIPTION: Shows how to use the WasmEdge Validator to validate WASM modules before instantiation, ensuring the module's correctness.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Function Instance Type Retrieval (C)\nDESCRIPTION: Demonstrates how to retrieve function type information from function instances. Function instances can be obtained from module instances or created as host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n```\n\n----------------------------------------\n\nTITLE: Building and Running Manual Execution Example\nDESCRIPTION: Bash commands to build and run the Go application that demonstrates manual execution of the Fibonacci WASM function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\n$ go build\n$ ./wasmedge_test\nGet fibonacci[25]: 121393\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: The WasmEdge_Limit struct represents WASM limit with minimum and maximum values, along with flags for maximum value presence and shared memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Accessing Active Module in WasmEdge VM with Go\nDESCRIPTION: Explains how to access an anonymously instantiated WASM module within a WasmEdge VM. The `GetActiveModule` method retrieves the current module instance, and caution is advised against releasing this instance manually.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_51\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nmod := vm.GetActiveModule()\n// If there's no WASM module instantiated, this API will return `nil`.\n// Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugin from a Specific Path\nDESCRIPTION: Loads a WasmEdge plugin from a specified path. This allows loading plugins from custom locations outside the default search paths.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_84\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadFromPath(\"PATH_TO_PLUGIN/plugin.so\");\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Global Type Context in C\nDESCRIPTION: Demonstrates the creation of a Global Type context with a specific value type and mutability, and how to retrieve this information using WasmEdge API functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Async Timed Wait and Cancel in C\nDESCRIPTION: Shows how to implement a timed wait for async execution with cancellation support. Includes timeout handling and result checking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Plugin Interface with WIT\nDESCRIPTION: WIT interface definition for an OpenCV mini plugin that includes functions for image decoding, displaying, and keyboard event handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_0\n\nLANGUAGE: wit\nCODE:\n```\nimdecode: func(buf: list<u8>) -> u32\nimshow: func(window-name: string, mat-key: u32) -> unit\nwaitkey: func(delay: u32) -> unit\n```\n\n----------------------------------------\n\nTITLE: Manual Asynchronous Execution of WASM Functions in WasmEdge Go\nDESCRIPTION: This snippet demonstrates how to manually perform asynchronous execution of WASM functions in WasmEdge using Go. It shows the step-by-step process of loading, validating, instantiating, and executing a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,\n  // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator in Go\nDESCRIPTION: Shows how to use the WasmEdge Validator to validate WASM modules before instantiation. It includes creating a validator with custom configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-NN Pre-registration\nDESCRIPTION: Demonstrates enabling WASI-NN proposal support in WasmEdge VM through configuration context. Requires specific dependencies and prerequisites.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                         WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration or the plugin load failed.\n */\nWasmEdge_ModuleInstanceContext *NNModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                         WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded WasmEdge Plugins\nDESCRIPTION: Lists all loaded WasmEdge plugins by retrieving their names. This is useful for checking which plugins are available in the current WasmEdge runtime environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_85\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Asynchronous WASM Execution in C\nDESCRIPTION: This bash snippet shows how to compile the C code that asynchronously executes a WebAssembly function and run the resulting executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Reference Types Example\nDESCRIPTION: Demonstration of working with FuncRef and ExternRef reference types\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar funccxt *wasmedge.Function = ... // Create or get function object.\nfuncref := wasmedge.NewFuncRef(funccxt)\n// Create a `FuncRef` with the function object.\n\nnum := 1234\n// `num` is a `int`.\nexternref := wasmedge.NewExternRef(&num)\n// Create an `ExternRef` which reference to the `num`.\nnum = 5678\n// Modify the `num` to 5678.\nnumref := externref.GetRef().(*int)\n// Get the original reference from the `ExternRef`.\nfmt.Println(*numref)\n// Will print `5678`.\nnumref.Release()\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: Executing WAT-written WebAssembly Function\nDESCRIPTION: Demonstrates how to call a function from a WebAssembly module written in WAT (WebAssembly Text Format) using WasmEdge CLI in reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --reactor fibonacci.wasm fib 10\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in C\nDESCRIPTION: Demonstrates how to query the imports and exports of an AST Module context in WasmEdge. It shows listing import and export types and iterating through them.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\nuint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\nuint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Implementation\nDESCRIPTION: Example showing how to use the WasmEdge AOT compiler to compile WebAssembly modules. Includes compiler configuration and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\", \"fibonacci.wasm.so\");\n  if (!WasmEdge_ResultOK(Res)) {\n      printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n      return 1;\n  }\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Memory Instances in C\nDESCRIPTION: Illustrates the creation of a memory instance, setting and getting data, growing the memory size, and handling potential errors. It also shows how to work with memory types and limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {.HasMax = true, .Min = 1, .Max = 5};\n/* Create the memory type with limit. The memory page size is 64KiB. */\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);\n/* Create the memory instance with memory type. */\nWasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);\n/* Delete the memory type. */\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\n/* Set the data[0:2] to the memory[4096:4098]. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\n/* `PageSize` will be 1. */\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n/* Grow the page size of 2, the page size of the memory instance will be 3. */\n/*\n * This will get an \"out of bounds memory access\" error because\n * the page size (3 + 3) will reach the memory limit(5):\n *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);\n */\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposals in Go SDK\nDESCRIPTION: Constants representing WebAssembly proposals that can be enabled or disabled in the WasmEdge runtime. These proposals include features like SIMD, reference types, and bulk memory operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)\n  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)\n  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n  EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)\n  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)\n  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Registered WASM Modules in WasmEdge\nDESCRIPTION: This Go code snippet demonstrates how to list the registered WASM modules within a WasmEdge VM. It uses the `ListRegisteredModule` method to get a list of module names and prints them to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\n// Assume that the `vm` is the created `wasmedge.VM` object.\nmodnames := vm.ListRegisteredModule()\nfor _, name := range modnames {\n  fmt.Println(\"Registered module name: \", name)\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN OpenVINO Backend\nDESCRIPTION: CMake commands to build WasmEdge from source with the WASI-NN OpenVINO backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"OpenVINO\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Table Instances in WasmEdge\nDESCRIPTION: This code demonstrates how to create, manipulate, and destroy a table instance in WasmEdge. It covers creating a table type with limits, setting and getting table data, checking size, and growing the table.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {.HasMax = true, .Min = 10, .Max = 20};\n/* Create the table type with limit and the `FuncRef` element type. */\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\n/* Create the table instance with table type. */\nWasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);\n/* Delete the table type. */\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\n/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `RefType` will be `WasmEdge_RefType_FuncRef`. */\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\n/* Set the function index 5 to the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);\n */\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n/* Get the FuncRef value of the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);\n */\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\n/* `Size` will be 10. */\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n/* Grow the table size of 6, the table size will be 16. */\n/*\n * This will get an \"out of bounds table access\" error because\n * the size (16 + 6) will reach the table limit(20):\n *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);\n */\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Defining AOT Compiler Options Enums in WasmEdge\nDESCRIPTION: Defines enums for AOT compiler optimization levels and output formats in WasmEdge. These options control the behavior of the AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n  // Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  // Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  // Optimize for fast execution as much as possible without triggering\n  // significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  // Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  // Optimize for small code size as much as possible without triggering\n  // significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  // Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n  // Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  // WebAssembly with AOT compiled codes in custom section.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Type from Function Instance (C)\nDESCRIPTION: Shows how to get the function type from a function instance. The returned function type context is owned by the function instance and should not be manually destroyed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Options in C\nDESCRIPTION: This snippet defines enumerations for WasmEdge compiler optimization levels and output formats. It includes options for different optimization levels and output binary formats.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_91\n\nLANGUAGE: c\nCODE:\n```\n/// AOT compiler optimization level enumeration.\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\n/// AOT compiler output binary format enumeration.\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom sections.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Running TensorFlow JavaScript Example\nDESCRIPTION: Demonstrates how to run a TensorFlow-based JavaScript example for image classification using WasmEdge with TensorFlow Lite extension.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# Download the Tensorflow example\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js\n\n$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Global Type Context\nDESCRIPTION: Demonstrates creation and manipulation of global type contexts, including setting value types and mutability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge AOT Compiler CLI in Go\nDESCRIPTION: Example of using the RunWasmEdgeAOTCompilerCLI() API, which provides the same functionality as the 'wasmedge compile' command for ahead-of-time compilation of WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_72\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version (C)\nDESCRIPTION: C code snippet demonstrating how to retrieve and print various components of the WasmEdge version using the C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format (WAT) code defining a Fibonacci function that is exported as 'fib'. This function takes an i32 parameter and returns an i32 result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_31\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Cost Table and Limits in Statistics - C\nDESCRIPTION: This snippet demonstrates how to create a cost table in the Statistics context, set a cost limit for instruction execution, and retrieve the total cost.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n    0, 0,\n    10, /* 0x02: Block */\n    11, /* 0x03: Loop */\n    12, /* 0x04: If */\n    12, /* 0x05: Else */\n    0, 0, 0, 0, 0, 0,\n    20, /* 0x0C: Br */\n    21, /* 0x0D: Br_if */\n    22, /* 0x0E: Br_table */\n    0\n};\n/*\n * Developers can set the costs of each instruction. The value not\n * covered will be 0.\n */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Server-Side Rendering\nDESCRIPTION: Webpack configuration for bundling and transpiling the server-side code, including React components and CSS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst path = require('path');\nmodule.exports = {\n  entry: './server/index.js',\n  externals: [\n    { wasi_http: 'wasi_http' },\n    { wasi_net: 'wasi_net' },\n    { std: 'std' },\n  ],\n  output: {\n    path: path.resolve('server-build'),\n    filename: 'index.js',\n    chunkFormat: 'module',\n    library: {\n      type: 'module',\n    },\n  },\n  experiments: {\n    outputModule: true,\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: 'babel-loader',\n      },\n      {\n        test: /\\.css$/,\n        use: ['css-loader'],\n      },\n      {\n        test: /\\.svg$/,\n        use: ['svg-url-loader'],\n      },\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Host Instances\nDESCRIPTION: Examples of creating host table, memory, and global instances with their respective configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Create a host table exported as \"table\". */\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\n\n/* Create a host memory exported as \"memory\". */\nWasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\n\n/* Create a host global exported as \"global_i32\" and initialized as `666`. */\nWasmEdge_GlobalTypeContext *HostGType =\n    WasmEdge_GlobalTypeCreate(WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Const);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\n```\n\n----------------------------------------\n\nTITLE: Querying Imports and Exports from AST Module in C\nDESCRIPTION: Shows how to query the imports and exports of an AST Module context. This is useful for analyzing a WASM module's interface before instantiation to ensure required imports are available.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/*\n * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be\n * accessed.\n */\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge-Go Context Lifecycles\nDESCRIPTION: Explains how to create and properly release WasmEdge-Go context objects to manage resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\nconf := wasmedge.NewConfigure()\n// Release the `conf` immediately.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for Simple WebAssembly Application\nDESCRIPTION: Configuration for a Docker container that runs a simple WASI-enabled WebAssembly application using WasmEdge runtime. It builds a minimal image based on wasmedge/slim-runtime with only the necessary components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_0\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-runtime:0.10.1\nADD wasi_example_main.wasm /\nCMD [\"wasmedge\", \"--dir\", \".:/\", \"/wasi_example_main.wasm\"]\n```\n\n----------------------------------------\n\nTITLE: Managing Maximum Memory Pages with WasmEdge in Go\nDESCRIPTION: This snippet illustrates how to set the maximum memory page size in WasmEdge using Go. It allows developers to control memory usage in WASM execution, preventing page growth beyond a specified limit. Usage requires the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\npagesize := conf.GetMaxMemoryPage()\n// By default, the maximum memory page size in each memory instances is 65536.\nconf.SetMaxMemoryPage(1234)\npagesize = conf.GetMaxMemoryPage()\n// `pagesize` will be 1234.\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Listing Registered Modules in WasmEdge Store in C\nDESCRIPTION: Demonstrates how to list registered WASM modules in a WasmEdge Store context. It shows how to retrieve module names and iterate through them.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n}\n```\n\n----------------------------------------\n\nTITLE: VM Context Status Lifecycle Diagram\nDESCRIPTION: Text diagram showing the lifecycle of a WasmEdge VM context, including its different states (Initiated, Loaded, Validated, Instantiated) and the transitions between these states through various API calls.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_33\n\nLANGUAGE: text\nCODE:\n```\n                         |========================|\n                |------->|      VM: Initiated     |\n                |        |========================|\n                |                    |\n                |                 LoadWasm\n                |                    |\n                |                    v\n                |        |========================|\n                |--------|       VM: Loaded       |<-------|\n                |        |========================|        |\n                |              |            ^              |\n                |         Validate          |              |\n            Cleanup            |          LoadWasm         |\n                |              v            |            LoadWasm\n                |        |========================|        |\n                |--------|      VM: Validated     |        |\n                |        |========================|        |\n                |              |            ^              |\n                |      Instantiate          |              |\n                |              |          RegisterModule   |\n                |              v            |              |\n                |        |========================|        |\n                |--------|    VM: Instantiated    |--------|\n                         |========================|\n                               |            ^\n                               |            |\n                               --------------\n                  Instantiate, Execute, ExecuteRegistered\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN TensorFlow-Lite Backend\nDESCRIPTION: CMake commands to build WasmEdge from source with the WASI-NN TensorFlow-Lite backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"TensorflowLite\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Setting a Cost Table in Go\nDESCRIPTION: This snippet allows developers to define a cost table that associates specific costs with bytecode instructions. It includes functionality for setting a cost limit that can trigger an error during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_28\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0,\n}\n// Developers can set the costs of each instruction. The value not covered will be 0.\n\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\n\n// ... After running the WASM functions with the `Statistics` object\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-NN in WasmEdge\nDESCRIPTION: This snippet demonstrates how to configure a WasmEdge VM to use the WASI-NN proposal. It creates a new `Configure` object with the `wasmedge.WasiNN` option, creates a `VM` with that configuration, retrieves the WASI-NN import module, and then releases the VM and configuration objects. Note: Dependencies and prerequests must be satisfied.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\n```go\nconf := wasmedge.NewConfigure(wasmedge.WasiNN)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nnnmodule := vm.GetImportModule(wasmedge.WasiNN)\nvm.Release()\n```\n```\n\n----------------------------------------\n\nTITLE: Compiling and Executing the WASM Linking Example in Bash\nDESCRIPTION: This bash script demonstrates how to compile the C code using `gcc` and link it with the `wasmedge` library. After compilation, the script executes the compiled binary. It assumes that the WasmEdge runtime is installed and accessible.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the '(123 + 456)^2' result: 335241\nGet the '77^2 + 88^2' result: 13673\n```\n\n----------------------------------------\n\nTITLE: Working with SIMD V128 Values in Go\nDESCRIPTION: Demonstrates creation and manipulation of V128 values for SIMD operations in WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Accessing Arguments and Environment Variables in Rust for WASI\nDESCRIPTION: This Rust function shows how to access command-line arguments and environment variables in a WASI environment using the std::env module. It prints all environment variables and command-line arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\npub fn print_env() {\n  println!(\"The env vars are as follows.\");\n  for (key, value) in env::vars() {\n    println!(\"{}: {}\", key, value);\n  }\n\n  println!(\"The args are as follows.\");\n  for argument in env::args() {\n    println!(\"{}\", argument);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Information in WasmEdge\nDESCRIPTION: Shows how to query imports and exports from an AST Module context, including handling of type contexts and proper cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_53\n\nLANGUAGE: c\nCODE:\n```\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\nuint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\n\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\nuint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge C\nDESCRIPTION: This code demonstrates how to create a WasmEdge VM context, create a WASI module instance, and register it within the VM context. Developers should check the result status after registration and properly delete module instances to prevent memory leaks.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Getting Return Value List Length in WasmEdge\nDESCRIPTION: This snippet demonstrates how to retrieve the length of the return value list of an asynchronous execution using `WasmEdge_AsyncGetReturnsLength`.  This function blocks and waits for the execution to finish. If the execution failed, the function returns 0. This allows developers to create a buffer of the appropriate size to receive the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Model Execution in Rust\nDESCRIPTION: Code for running TensorFlow model inference\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nsession.run();\n```\n\n----------------------------------------\n\nTITLE: WasmEdge String Comparison\nDESCRIPTION: Demonstrates how to compare WasmEdge_String objects for equality using different string creation methods.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"abcd\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Reference Types Example\nDESCRIPTION: Demonstration of working with FuncRef and ExternRef types\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar funccxt *wasmedge.Function = ... // Create or get function object.\\nfuncref := wasmedge.NewFuncRef(funccxt)\\n// Create a `FuncRef` with the function object.\\n\\nnum := 1234\\n// `num` is a `int`.\\nexternref := wasmedge.NewExternRef(&num)\\n// Create an `ExternRef` which reference to the `num`.\\nnum = 5678\\n// Modify the `num` to 5678.\\nnumref := externref.GetRef().(*int)\\n// Get the original reference from the `ExternRef`.\\nfmt.Println(*numref)\\n// Will print `5678`.\\nnumref.Release()\\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: Creating Memory Type Context in C\nDESCRIPTION: Example of creating and using a Memory Type context with memory limits, demonstrating memory limit creation and retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plug-ins in Go\nDESCRIPTION: Demonstrates how to list available modules in a plug-in and create a module instance from a plug-in using its name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nmodules := plugincrypto.ListModule()\nfor _, name := range modules {\n  fmt.Println(\"Available module: \", name)\n}\nmodinst := plugincrypto.CreateModule(\"wasi_ephemeral_crypto_common\")\n\nmodinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Runtime Tool using C API\nDESCRIPTION: This code snippet shows how to execute the WasmEdge runtime tool using the C API. It is a simple example following the same structure as the previous snippet but calling the WasmEdge_Driver_Tool function. Like the AOT compiler, it requires WasmEdge library linkage and expects CLI arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\\n#include <stdio.h>\\nint main(int argc, const char *argv[]) {\\n  /* Run the WasmEdge runtime tool. */\\n  return WasmEdge_Driver_Tool(argc, argv);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Export Types in Go\nDESCRIPTION: Shows how to work with export type contexts and extract information from AST modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Table Instances (C)\nDESCRIPTION: Demonstrates the creation of Table instances, setting and getting data, growing the table size, and proper cleanup. It also shows how to handle potential out-of-bounds errors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(TabTypeCxt);\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Handling Reference Types in WasmEdge-Go\nDESCRIPTION: Shows how to create and use FuncRef and ExternRef types for the Reference-Types proposal in WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar funccxt *wasmedge.Function = ... // Create or get function object.\nfuncref := wasmedge.NewFuncRef(funccxt)\n// Create a `FuncRef` with the function object.\n\nnum := 1234\n// `num` is a `int`.\nexternref := wasmedge.NewExternRef(&num)\n// Create an `ExternRef` which reference to the `num`.\nnum = 5678\n// Modify the `num` to 5678.\nnumref := externref.GetRef().(*int)\n// Get the original reference from the `ExternRef`.\nfmt.Println(*numref)\n// Will print `5678`.\nnumref.Release()\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Context Management Example\nDESCRIPTION: Example showing how to create and manage WasmEdge contexts, specifically a configuration context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Object with Host Function\nDESCRIPTION: Demonstrates creating a WasmEdge Function object from a host function implementation, defining its signature, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i32} -> {i32}.\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\n\n// Create a function context with the function type and host function body.\n// The third parameter is the pointer to the additional data.\n// Developers should guarantee the life cycle of the data, and it can be\n// `nil` if the external data is not needed.\n// The last parameter can be 0 if developers do not need the cost measuring.\nfunc_add := wasmedge.NewFunction(functype, host_add, nil, 0)\n\n// If the function object is not added into an module instance object, it should be released.\nfunc_add.Release()\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from WasmEdge Plugins\nDESCRIPTION: Example showing how to find a specific plugin by name and create module instances from it. This demonstrates the plugin extension mechanism of WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_72\n\nLANGUAGE: go\nCODE:\n```\n// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.\n\n// List the available host modules in the plug-in.\nmodules := plugincrypto.ListModule()\nfor _, name := range modules {\n  fmt.Println(\"Available module: \", name)\n}\n// Will print here for the WASI-Crypto plug-in here:\n//   wasi_ephemeral_crypto_asymmetric_common\n//   wasi_ephemeral_crypto_common\n//   wasi_ephemeral_crypto_kx\n//   wasi_ephemeral_crypto_signatures\n//   wasi_ephemeral_crypto_symmetric\n\n// Create a module instance from the plug-in by the module name.\nmodinst := plugincrypto.CreateModule(\"wasi_ephemeral_crypto_common\")\n\nmodinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Ahead-of-Time Compilation for Performance Optimization\nDESCRIPTION: Commands for compiling the WebAssembly module using WasmEdge's Ahead-of-Time compiler and then running the optimized binary. AoT compilation provides higher performance compared to JIT execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/simd.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Compile wasm-simd with wasmedge aot compiler\n$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm\n# Run the native binary with wasmedge\n$ wasmedge mandelbrot-simd-out.wasm 15000\n```\n\n----------------------------------------\n\nTITLE: Listing and Retrieving Registered Modules in WasmEdge (C)\nDESCRIPTION: Demonstrates how to list all registered modules in the VM context and retrieve a specific module by name. This is useful for accessing built-in or imported modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `VMCxt` is created.\n */\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the registered module names in the VM context. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Image Classification Function in Node.js\nDESCRIPTION: Node.js script that loads the WasmEdge TensorFlow runtime, executes the compiled WebAssembly image classification function, and handles input/output for the serverless function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst fs = require('fs');\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nmodule.exports = (req, res) => {\n  const wasmedge = spawn(\n    path.join(__dirname, 'wasmedge-tensorflow-lite'),\n    [path.join(__dirname, 'classify.so')],\n    { env: { LD_LIBRARY_PATH: __dirname } },\n  );\n\n  let d = [];\n  wasmedge.stdout.on('data', (data) => {\n    d.push(data);\n  });\n\n  wasmedge.on('close', (code) => {\n    res.setHeader('Content-Type', `text/plain`);\n    res.send(d.join(''));\n  });\n\n  wasmedge.stdin.write(req.body);\n  wasmedge.stdin.end('');\n};\n```\n\n----------------------------------------\n\nTITLE: SIMD Value Type Operations\nDESCRIPTION: Example of creating and handling v128 SIMD values\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\\nhigh, low := val.GetVal()\\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Listing Registered Modules in Store in WasmEdge-go\nDESCRIPTION: Demonstrates how to list all registered module names in a Store. This allows for discovering which modules are available in the current execution environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n// ...\n// Instantiate a WASM module via the `*wasmedge.Executor` object.\n// ...\n\n// Try to list the registered WASM modules.\nmodnames := store.ListModule()\nfor _, name := range modnames {\n  fmt.Println(\"Registered module names:\", name)\n}\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Container with Podman and Youki\nDESCRIPTION: Command to execute a WebAssembly application using Podman with youki as the container runtime\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Creating and Using GlobalType in WasmEdge-go\nDESCRIPTION: Demonstrates how to create and use GlobalType objects that define WebAssembly global variable instances with value types and mutability settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go\nDESCRIPTION: Type definition for host function callback signature in WasmEdge-go that handles function parameters and memory interactions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_53\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: Plugin Loading Example\nDESCRIPTION: Example showing how to load and use WasmEdge plugins from default paths or specific locations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_68\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\npluginnames := wasmedge.ListPlugins()\nfor _, name := range pluginnames {\n  fmt.Println(\"Loaded plug-in name: \", name)\n}\n\npluginobj := wasmedge.FindPlugin(\"wasi_crypto\")\nmodules := pluginobj.ListModule()\nfor _, name := range modules {\n  fmt.Println(\"Available module: \", name)\n}\nmodinst := pluginobj.CreateModule(\"wasi_ephemeral_crypto_common\")\nmodinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Running a WebAssembly HTTP Server with CRI-O\nDESCRIPTION: This bash script shows how to pull a WebAssembly-based HTTP server container image, create necessary configuration files, and run the container using CRI-O commands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation\n\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json\n\nsudo crictl runp sandbox_config.json\nPOD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4\n```\n\n----------------------------------------\n\nTITLE: Compilation and Execution Commands\nDESCRIPTION: Shell commands for compiling and running the C programs that demonstrate WasmEdge async execution\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\n```\n\n----------------------------------------\n\nTITLE: VM Context Status Flow Diagram\nDESCRIPTION: ASCII diagram showing the different states and transitions of the WasmEdge VM Context, including Initiated, Loaded, Validated, and Instantiated states.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_38\n\nLANGUAGE: text\nCODE:\n```\n                         |========================|\n                |------->|      VM: Initiated     |\n                |        |========================|\n                |                    |\n                |                 LoadWasm\n                |                    |\n                |                    v\n                |        |========================|\n                |--------|       VM: Loaded       |<-------|\n                |        |========================|        |\n                |              |            ^              |\n                |         Validate          |              |\n            Cleanup            |          LoadWasm         |\n                |              v            |            LoadWasm\n                |        |========================|        |\n                |--------|      VM: Validated     |        |\n                |        |========================|        |\n                |              |            ^              |\n                |      Instantiate          |              |\n                |              |          RegisterModule   |\n                |              v            |              |\n                |        |========================|        |\n                |--------|    VM: Instantiated    |--------|\n                         |========================|\n                               |            ^\n                               |            |\n                               --------------\n                  Instantiate, Execute, ExecuteRegistered\n```\n\n----------------------------------------\n\nTITLE: Import Type Context Usage in C\nDESCRIPTION: Illustrates Import Type context usage for handling WASM module imports. Shows how to query import information including external types and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge Statistics Options in Go\nDESCRIPTION: This code snippet demonstrates how to configure WasmEdge statistics options using the `wasmedge.Configure` object in Go. It shows how to enable instruction counting, time measuring, and cost measuring.  These configurations allow the monitoring of resources consumed by the WASM at runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\n```go\n   conf := wasmedge.NewConfigure()\n\n   // By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\n   conf.SetStatisticsInstructionCounting(true)\n   // By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\n   conf.SetStatisticsTimeMeasuring(true)\n   // By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\n   conf.SetStatisticsCostMeasuring(true)\n\n   conf.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types in WasmEdge\nDESCRIPTION: Shows how to retrieve function types by name from an instantiated WASM module using WasmEdge VM APIs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered modules\n * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.\n * If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Built WasmEdge QuickJS\nDESCRIPTION: Commands to compile the built WebAssembly file with native machine code and run it using WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile target/wasm32-wasip1/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm\nwasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js\n```\n\n----------------------------------------\n\nTITLE: Error Handling Example\nDESCRIPTION: Demonstration of error handling with WasmEdge Result objects\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\\nres, err = vm.Execute(...) // Ignore the detail of parameters.\\n// Assume that `res, err` are the return values for executing a function with `vm`.\\nif err != nil {\\n  fmt.Println(\"Error message:\", err.Error())\\n  category := err.GetErrorCategory()\\n  // The `category` will be `wasmedge.ErrCategory_WASM`.\\n}\\n\\nuserdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)\\n// Generate the user-defined error with code.\\ncode := userdef_err.GetCode()\\n// The `Code` will be 123456.\n```\n\n----------------------------------------\n\nTITLE: Executing WasmEdge AOT Compiler via C API\nDESCRIPTION: The snippet demonstrates calling the WasmEdge AOT compiler from C using the WasmEdge_Driver_Compiler function. This function uses command line arguments. Necessary headers and a C compiler environment are required.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_31\n\nLANGUAGE: C\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded WasmEdge Plugins\nDESCRIPTION: Code for listing all loaded WasmEdge plugins. This is useful for debugging and confirming that plugins are properly loaded into the runtime environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_74\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\npluginnames := wasmedge.ListPlugins()\nfor _, name := range pluginnames {\n  fmt.Println(\"Loaded plug-in name: \", name)\n}\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Global Type Context in Go\nDESCRIPTION: Shows how to create and manage global type contexts for WASM global instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Registering and Executing WASM Modules in WasmEdge C\nDESCRIPTION: This snippet illustrates the registration of a WASM module from a file into the WasmEdge VM context using a unique module name. It demonstrates error handling upon registration failure and illustrates how to execute a registered function from the module while handling its parameters and results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n   * name \"mod\". As the same as host functions, other modules can import the\n   * function \"\"mod\" \"fib\".\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                       Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN Piper Backend\nDESCRIPTION: This snippet outlines the commands needed to build and install WasmEdge from source with the Piper backend enabled on Linux.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"Piper\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Setting AOT Compiler Options in WasmEdge\nDESCRIPTION: This snippet demonstrates how to set various AOT compiler-related options like optimization level, output format, and interruptibility within a WasmEdge configuration context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n/* Set this option to `TRUE` to support the interruptible execution in AOT\n mode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Working with FunctionType in WasmEdge-go\nDESCRIPTION: Shows how to create and use FunctionType objects to define WebAssembly function signatures with parameter and return types. Demonstrates retrieving type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge AOT Compiler using C API\nDESCRIPTION: This snippet demonstrates how to invoke the WasmEdge AOT compiler using the WasmEdge C API. It requires the WasmEdge library to be installed and linked during compilation. This code snippet expects command line arguments similar to the WasmEdge CLI tools. The main function calls the WasmEdge_Driver_Compiler function to execute the AOT compilation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\\n#include <stdio.h>\\nint main(int argc, const char *argv[]) {\\n  /* Run the WasmEdge AOT compiler. */\\n  return WasmEdge_Driver_Compiler(argc, argv);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Plugin with CMake\nDESCRIPTION: CMake configuration for building a WasmEdge plugin as a shared library. Sets up build target with C11 standard, WASMEDGE_PLUGIN definition, and links against wasmedge library. Creates shared library from testplugin.c source file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(wasmedgePluginTest\n  SHARED\n  testplugin.c\n)\n\nset_target_properties(wasmedgePluginTest PROPERTIES\n  C_STANDARD 11\n)\n\ntarget_compile_options(wasmedgePluginTest\n  PUBLIC\n  -DWASMEDGE_PLUGIN\n)\n\ntarget_link_libraries(wasmedgePluginTest\n  PRIVATE\n  wasmedge\n)\n```\n\n----------------------------------------\n\nTITLE: Rust WASI File Reader Implementation\nDESCRIPTION: Rust implementation of a file reader program that demonstrates WASI capabilities. The program reads a file line by line and allows printing specific lines based on user input.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs::File;\nuse std::io::{self, BufRead};\n\nfn main() {\n  let args: Vec<String> = env::args().collect();\n  if args.len() <= 1 {\n    println!(\"Rust: ERROR - No input file name.\");\n    return;\n  }\n  println!(\"Rust: Opening input file \\\"{}\\\"..\", args[1]);\n  let file = match File::open(&args[1]) {\n    Err(why) => {\n      println!(\"Rust: ERROR - Open file \\\"{}\\\" failed: {}\", args[1], why);\n      return;\n    },\n    Ok(file) => file,\n  };\n  // Read and process file...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge VM and Creating WASM Module Buffer in C\nDESCRIPTION: This snippet initializes a WasmEdge VM context and defines a WASM module buffer containing a simple module that imports an external addition function and exports a wrapper function called 'addTwo'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n/* The WASM module buffer. */\nuint8_t WASM[] = {\n  /* WASM header */\n  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n  /* Type section */\n  0x01, 0x07, 0x01,\n  /* function type {i32, i32} -> {i32} */\n  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n  /* Import section */\n  0x02, 0x13, 0x01,\n  /* module name: \"extern\" */\n  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n  /* extern name: \"func-add\" */\n  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n  /* import desc: func 0 */\n  0x00, 0x00,\n  /* Function section */\n  0x03, 0x02, 0x01, 0x00,\n  /* Export section */\n  0x07, 0x0A, 0x01,\n  /* export name: \"addTwo\" */\n  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n  /* export desc: func 0 */\n  0x00, 0x01,\n  /* Code section */\n  0x0A, 0x0A, 0x01,\n  /* code body */\n  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n};\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Value Type Generation and Handling\nDESCRIPTION: Demonstrates creating and manipulating different WasmEdge value types including integers, floating-point numbers, and reference types\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\\nVal = WasmEdge_ValueGenI32(123456);\\nprintf(\"%d\\\\n\", WasmEdge_ValueGetI32(Val));\\nVal = WasmEdge_ValueGenI64(1234567890123LL);\\nprintf(\"%ld\\\\n\", WasmEdge_ValueGetI64(Val));\\nVal = WasmEdge_ValueGenF32(123.456f);\\nprintf(\"%f\\\\n\", WasmEdge_ValueGetF32(Val));\\nVal = WasmEdge_ValueGenF64(123456.123456789);\\nprintf(\"%.10f\\\\n\", WasmEdge_ValueGetF64(Val));\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: This snippet defines a Fibonacci function in WebAssembly Text Format (WAT). It exports a function named 'fib' that calculates the Fibonacci number for a given input.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_37\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Running JavaScript with WasmEdge\nDESCRIPTION: Shows how to use WasmEdge as a JavaScript runtime, including downloading necessary files and executing a simple JavaScript program.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\nwget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip\nunzip modules.zip\n```\n\nLANGUAGE: javascript\nCODE:\n```\nargs = args.slice(1);\nprint('Hello', ...args);\n```\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge_quickjs.wasm hello.js 1 2 3\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in C\nDESCRIPTION: This snippet defines enumerations for the compiler optimization levels and output formats. It also demonstrates how to set compiler options for a configured context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n    // Disable as many optimizations as possible.\n    WasmEdge_CompilerOptimizationLevel_O0 = 0,\n    // Optimize quickly without destroying debuggability.\n    WasmEdge_CompilerOptimizationLevel_O1,\n    // Optimize for fast execution as much as possible without triggering\n    // significant incremental compile time or code size growth.\n    WasmEdge_CompilerOptimizationLevel_O2,\n    // Optimize for fast execution as much as possible.\n    WasmEdge_CompilerOptimizationLevel_O3,\n    // Optimize for small code size as much as possible without triggering\n    // significant incremental compile time or execution time slowdowns.\n    WasmEdge_CompilerOptimizationLevel_Os,\n    // Optimize for small code size as much as possible.\n    WasmEdge_CompilerOptimizationLevel_Oz\n};\n \nenum WasmEdge_CompilerOutputFormat {\n    // Native dynamic library format.\n    WasmEdge_CompilerOutputFormat_Native = 0,\n    // WebAssembly with AOT compiled codes in custom section.\n    WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n /* Set this option to `TRUE` to support the interruptible execution in AOT\n mode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing a Specific Version of WasmEdge\nDESCRIPTION: This command installs a specific version of WasmEdge, including pre-release or older versions, by specifying the `-v` parameter with the desired version number. It uses the `VERSION` variable to dynamically pass the version to the installation script. Installing a specific version can be useful for maintaining compatibility or testing purposes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nVERSION={{ wasmedge_version }}\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $VERSION\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge Go\nDESCRIPTION: This snippet demonstrates how to enable WASI (WebAssembly System Interface) support in a WasmEdge VM configuration and initialize the WASI module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasimodule := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasimodule.InitWasi(/* ... ignored */)\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Test Case for WasmEdge Plugin using Google Test in C++\nDESCRIPTION: This snippet demonstrates how to implement a test case for a WasmEdge plugin using the Google Test framework. It includes necessary headers, creates a test case that checks the conversion functionality of a hypothetical plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/test_plugin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"gtest/gtest.h\"\n#include \"your_plugin.h\"\n\nTEST(YourPluginTest, ConvertsNormalString) {\nYourPlugin plugin;\nstd::string input = \"123\";\nint expected = 123;\nEXPECT_EQ(expected, plugin.convert(input));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Optimization Levels in WasmEdge Go SDK\nDESCRIPTION: This code defines constants for various optimization levels available in the WasmEdge AOT compiler. It includes options ranging from O0 (minimal optimization) to O3 (maximum performance optimization), as well as Os and Oz for size optimization. Each constant maps to the corresponding C API enumeration value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_73\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: Installing GGML Plugin for WasmEdge\nDESCRIPTION: Commands to download and install the GGML plugin for WasmEdge, which is needed for running machine learning models, and verify that all dependencies are correctly resolved.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml\n\n# Make sure all your plugin dependencies is good\n> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so\n```\n\n----------------------------------------\n\nTITLE: Inserting Records into MySQL\nDESCRIPTION: Rust code demonstrating batch insertion of records into MySQL database\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n    let orders = vec![\n        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(\"Mataderos 2312\")),\n        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(\"1234 NW Bobcat\")),\n        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(\"20 Havelock\")),\n        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(\"224 Pandan Loop\")),\n        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(\"No.10 Jalan Besar\")),\n    ];\n\n    r\"INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address)\n      VALUES (:order_id, :production_id, :quantity, :amount, :shipping, :tax, :shipping_address)\"\n        .with(orders.iter().map(|order| {\n            params! {\n                \"order_id\" => order.order_id,\n                \"production_id\" => order.production_id,\n                \"quantity\" => order.quantity,\n                \"amount\" => order.amount,\n                \"shipping\" => order.shipping,\n                \"tax\" => order.tax,\n                \"shipping_address\" => &order.shipping_address,\n            }\n        }))\n        .batch(&mut conn)\n        .await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Userspace Program for eBPF Interaction\nDESCRIPTION: Userspace code compiled to WebAssembly that uses wasm_bpf APIs to load, attach, and poll the eBPF program. It opens the BPF skeleton, configures it, and sets up a ring buffer to receive events from the kernel.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/bpf.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Load and verify BPF application */\n    skel = bootstrap_bpf__open();\n    if (!skel) {\n        fprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n        return 1;\n    }\n\n    /* Parameterize BPF code with minimum duration parameter */\n    skel->rodata->min_duration_ns = env.min_duration_ms * 1000000ULL;\n\n    /* Load & verify BPF programs */\n    err = bootstrap_bpf__load(skel);\n    if (err) {\n        fprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n        goto cleanup;\n    }\n\n    /* Attach tracepoints */\n    err = bootstrap_bpf__attach(skel);\n    if (err) {\n        fprintf(stderr, \"Failed to attach BPF skeleton\\n\");\n        goto cleanup;\n    }\n\n    /* Set up ring buffer polling */\n    rb = bpf_buffer__open(skel->maps.rb, handle_event, NULL);\n    if (!rb) {\n        err = -1;\n        fprintf(stderr, \"Failed to create ring buffer\\n\");\n        goto cleanup;\n    }\n    /* Process events */\n    printf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n           \"PPID\", \"FILENAME/EXIT CODE\");\n    while (!exiting) {\n        // poll buffer\n        err = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n        /* Ctrl-C will cause -EINTR */\n        if (err == -EINTR) {\n            err = 0;\n            break;\n        }\n        if (err < 0) {\n            printf(\"Error polling perf buffer: %d\\n\", err);\n            break;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Working with Memory Type Context in C\nDESCRIPTION: Example of creating and managing Memory Type context, including setting memory limits for memory instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {.HasMax = true, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Custom Module Functions in JavaScript\nDESCRIPTION: This code demonstrates how to import and use the custom module functions defined in 'my_mod_1.js' and 'my_mod_2.js'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/modules.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { hello_mod_1 } from 'my_mod_1';\nimport { hello_mod_2 } from 'my_mod_2';\n\nhello_mod_1();\nhello_mod_2();\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Docker Container for WASI Application\nDESCRIPTION: Shell commands to build a Docker image from the Dockerfile and run the WebAssembly WASI application inside a Docker container. Shows the complete workflow from building to execution, along with the application output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm wasmedge/myapp\nRandom number: -807910034\nRandom bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]\nPrinted from wasi: This is from a main function\nThis is from a main function\nThe env vars are as follows.\nThe args are as follows.\nwasi_example_main.wasm\nFile content is This is in a file\n```\n\n----------------------------------------\n\nTITLE: Host Data Example in WasmEdge Function\nDESCRIPTION: This example shows how to pass a host data object to a WebAssembly function. The code demonstrates defining a host function that works with external data and using it with WebAssembly modules. Only a portion is shown as the example is incomplete in the source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_82\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n```\n\n----------------------------------------\n\nTITLE: Accessing WasmEdge VM Components\nDESCRIPTION: Shows how to access the internal Loader, Validator, and Executor contexts from a WasmEdge VM instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Global Type Context in C\nDESCRIPTION: Shows the creation of a Global Type context with a specified value type and mutability, and retrieving this information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting Configure Context with C API\nDESCRIPTION: This C code demonstrates how to create and delete a `WasmEdge_ConfigureContext` object using the WasmEdge C API.  The configuration context is used to configure the WasmEdge runtime environment. Proper memory management dictates that the context should be deleted once it is no longer needed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\n\"/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\"\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Files - Rust\nDESCRIPTION: This Rust code illustrates how to perform file system operations within a WebAssembly module using the standard `std::fs` API. The functions `create_file`, `read_file`, and `del_file` allow creating, reading, and deleting files, respectively. The file paths are relative to a directory mapped during WasmEdge runtime execution. The `create_file` function takes a path and content to write, `read_file` takes a path and returns the file content, and `del_file` deletes the file at the provided path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n\"use std::fs;\\nuse std::fs::File;\\nuse std::io::{Write, Read};\\n\\npub fn create_file(path: &str, content: &str) {\\n  let mut output = File::create(path).unwrap();\\n  output.write_all(content.as_bytes()).unwrap();\\n}\\n\\npub fn read_file(path: &str) -> String {\\n  let mut f = File::open(path).unwrap();\\n  let mut s = String::new();\\n  match f.read_to_string(&mut s) {\\n    Ok(_) => s,\\n    Err(e) => e.to_string(),\\n  }\\n}\\n\\npub fn del_file(path: &str) {\\n  fs::remove_file(path).expect(\\\"Unable to delete\\\");\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules with Export Names\nDESCRIPTION: Illustrates how to register a WASM module file with an exported module name, allowing other modules to import its exported functions. The module is registered from a file in this example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Go and Setting Up Kubernetes for CRI-O\nDESCRIPTION: Instructions for installing Go, cloning the Kubernetes repository, setting up etcd, and starting a local Kubernetes cluster configured to work with CRI-O as the container runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install go\n$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz\n$ sudo rm -rf /usr/local/go\nsudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz\nsource /home/${USER}/.profile\n\n# Clone k8s\ngit clone https://github.com/kubernetes/kubernetes.git\ncd kubernetes\ngit checkout v1.22.2\n\n# Install etcd with hack script in k8s\nsudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh\nexport PATH=\"/home/${USER}/kubernetes/third_party/etcd:${PATH}\"\nsudo cp third_party/etcd/etcd* /usr/local/bin/\n\n# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl\n\n# Build and run k8s with CRI-O\nsudo apt-get install -y build-essential\nsudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh\n\n... ...\nLocal Kubernetes cluster is running. Press Ctrl-C to shut it down.\n```\n\n----------------------------------------\n\nTITLE: Using Export Type Context in C\nDESCRIPTION: Illustrates how to use an Export Type context to retrieve information about exports from an AST Module. It shows querying external types, names, and specific type contexts based on the external type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Running WASM Functions with WasmEdge in Go\nDESCRIPTION: The code asynchronously runs a WASM function using the WasmEdge VM. It involves creating a VM instance, running a WASM file `fibonacci.wasm`, waiting for execution results, and managing resources. Dependencies include the `github.com/second-state/WasmEdge-go/wasmedge` library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_44\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Go Project for WasmEdge\nDESCRIPTION: Bash commands to create a new Go project and initialize the module for WasmEdge testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Converting WasmEdge String to C String\nDESCRIPTION: Shows how to convert a WasmEdge_String to a C string buffer and get its length.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[256];\nWasmEdge_String Str =\n    WasmEdge_StringCreateByCString(\"test_wasmedge_string\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf(\"String: %s\\n\", Buf);\n/* Will print \"test_wasmedge_string\". */\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST Module to Anonymous Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate a WASM module as an anonymous Module instance. Before instantiating, it's important to ensure all required imports are registered in the Store context for proper linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Getting the Active WASM Module in WasmEdge\nDESCRIPTION: This Go code snippet shows how to retrieve the active WASM module instance within a WasmEdge VM after instantiation. The module should not be released by the user. It retrieves the active module using the `GetActiveModule` method.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nmod := vm.GetActiveModule()\n// If there's no WASM module instantiated, this API will return `nil`.\n// Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules with Exported Names\nDESCRIPTION: Demonstrates how to register a WebAssembly module file with a unique module name in the WasmEdge VM environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  // The result status should be checked. The error will occur if the\n  // WASM module instantiation failed or the module name conflicts.\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering a Function Instance in WasmEdge C API\nDESCRIPTION: This code snippet demonstrates how to create a function type context, create a function instance with parameters and return values, and add it to a module instance. It includes proper resource cleanup by deleting the function type context after use.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\n/* Create and add a function instance into the module instance. */\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                     WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASM Limit Structures in Go\nDESCRIPTION: Demonstrates creating and using Limit structures for defining minimum and maximum values, including support for shared memory in thread proposals.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\nLANGUAGE: go\nCODE:\n```\nlim3 := wasmedge.NewLimitShared(20)\nfmt.Println(lim3.HasMax())\n// Will print `false`.\nfmt.Println(lim3.IsShared())\n// Will print `true`.\nfmt.Println(lim3.GetMin())\n// Will print `20`.\n\nlim4 := wasmedge.NewLimitSharedWithMax(30, 40)\nfmt.Println(lim4.HasMax())\n// Will print `true`.\nfmt.Println(lim4.IsShared())\n// Will print `true`.\nfmt.Println(lim4.GetMin())\n// Will print `30`.\nfmt.Println(lim4.GetMax())\n// Will print `40`.\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in C\nDESCRIPTION: This C code shows how to configure statistics options in WasmEdge, including instruction counting, cost measuring, and time measuring. These options are effective in Compiler, VM, and Executor contexts. Setting these options enables performance profiling of WASM execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/*\n * By default, the instruction counting is `FALSE` when running a\n * compiled-WASM or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/*\n * By default, the cost measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/*\n * By default, the time measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: WASM Function Invocation - Post v0.10.0\nDESCRIPTION: Updated example of function invocation in v0.10.0 showing how to retrieve and invoke function instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nvar mod *wasmedge.Module\nmod, err = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\nfuncinst := mod.FindFunction(\"fib\")\nif funcinst == nil {\n  fmt.Println(\"Run FAILED: Function name `fib` not found\")\n  return\n}\nres, err = executor.Invoke(store, funcinst, int32(30))\nif err == nil {\n  fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n} else {\n  fmt.Println(\"Run FAILED:\", err.Error())\n}\nast.Release()\nmod.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instances from VM Context (Post-v0.12.0)\nDESCRIPTION: Example of retrieving module instances from the VM context after version 0.12.0, using new APIs for faster retrieval of registered module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nwasimod := vm.GetImportModule(wasmedge.WASI)\ncryptocommonmod := vm.GetRegisteredModule(\"wasi_ephemeral_crypto_common\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Build Events Recorder Microservice\nDESCRIPTION: These commands build the events recorder microservice using Rust and compile it to WebAssembly. The `wasmedgec` command pre-compiles the wasm module for improved performance with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd events-service\ncargo build --target wasm32-wasip1 --release\nwasmedgec target/wasm32-wasip1/release/events_service.wasm events_service.wasm\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST Module to Anonymous Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate an AST module context into an anonymous Module instance using the Executor API. Includes context creation, module instantiation, and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Simple WASM Module Example\nDESCRIPTION: Example WebAssembly module that imports an external add function and exports an addTwo function that uses it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_66\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types from the WASM Instance in Go\nDESCRIPTION: This snippet retrieves the function type for a specific exported function from an instantiated WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_43\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nfunctype := vm.GetFunctionType(\"fib\")\n// Developers can get the function types of functions in the registered modules via the\n// `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.\n// If the function is not found, these APIs will return `nil`.\n// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Running LLM Inference with WasmEdge\nDESCRIPTION: Command to execute the llama-chat WASM application using WasmEdge CLI, loading the LLM model and setting up the chat environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat\n```\n\n----------------------------------------\n\nTITLE: Creating Host Functions with Import Objects in WasmEdge\nDESCRIPTION: Demonstrates how to create a host function in C that adds two integers, wrap it in a WasmEdge function instance, and add it to an import object. This approach was used in WasmEdge before version 0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create the import object. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the import object. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/*\n * The import objects should be deleted.\n * Developers should __NOT__ destroy the instances added into the import object contexts.\n */\nWasmEdge_ImportObjectDelete(ImpObj);\n```\n\n----------------------------------------\n\nTITLE: Building Rust WebAssembly Target\nDESCRIPTION: Commands to compile Rust code into WebAssembly bytecode functions\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\ncd rust_bindgen_funcs\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Using Import Type Context in C\nDESCRIPTION: Demonstrates how to use an Import Type context to retrieve information about imported modules, including external type and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Memory Pages in WasmEdge\nDESCRIPTION: Example demonstrating how to set and get the maximum memory page size for WasmEdge instances. This configuration limits the amount of memory a WebAssembly instance can allocate.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\npagesize := conf.GetMaxMemoryPage()\n// By default, the maximum memory page size in each memory instances is 65536.\nconf.SetMaxMemoryPage(1234)\npagesize = conf.GetMaxMemoryPage()\n// `pagesize` will be 1234.\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Module via AST Context in WasmEdge\nDESCRIPTION: Demonstrates loading a WASM module using an AST Context first, then registering it with the VM. Shows the process of parsing WASM files into AST format before registration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* Load into AST context first */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n  WasmEdge_ASTModuleContext *LibASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, \"lib.wasm\");\n\n  /* Register from AST module */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_VMRegisterModuleFromASTModule(VMCxt, ModuleName, LibASTCxt);\n\n  /* Rest of implementation... */\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Compiled Executable\nDESCRIPTION: Execute the compiled file to retrieve the WasmEdge version. The output should display the WasmEdge version number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ./a.out\nWasmEdge version: 0.11.2\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Instruction Counter in WasmEdge\nDESCRIPTION: This snippet demonstrates how to create a statistics context, retrieve the instruction count, and calculate instructions per second in WasmEdge. A statistics context is necessary to profile the performance of WASM executions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/* ....\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting WasmEdge Configure Context\nDESCRIPTION: This C code demonstrates how to create and delete a `WasmEdge_ConfigureContext` object using `WasmEdge_ConfigureCreate` and `WasmEdge_ConfigureDelete`. It highlights the importance of managing context objects for memory management. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Memory Type Context in Go\nDESCRIPTION: Demonstrates creating and managing memory type contexts for WASM memory instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Setting Cost Table with WasmEdge in C\nDESCRIPTION: The provided code sets up a cost table to accumulate instruction costs based on their weights, using WasmEdge_StatisticsContext. It specifies bytecode instruction costs and a cost limit, returning an error if the limit is exceeded. Dependencies include the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/* Developers can set the costs of each instruction. The value not covered will be 0. */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Running Llama2 Inference with Docker, WasmEdge, and GPU in Bash\nDESCRIPTION: Docker command to run a Llama2 inference application in a WebAssembly container with GPU access. The command mounts necessary libraries and model files, sets environment variables for WasmEdge and GPU layers, and uses the custom Crun runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \\\n  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \\\n  -v .:/resource \\\n  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \\\n  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \\\n  --env n_gpu_layers=100 \\\n  --rm --device nvidia.com/gpu=all --runtime=crun --annotation=module.wasm.image/variant=compat-smart --platform wasip1/wasm \\\n  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \\\n  $'[INST] <<SYS>>\\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\\n<</SYS>>\\nWhat is the capital of Japan?[/INST]'\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WASM\nDESCRIPTION: This WASM module defines a recursive function to compute Fibonacci numbers. The function 'fib' accepts an integer parameter 'n' and returns the nth Fibonacci number. The recursion handles base cases for n less than 2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_33\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes YAML for WasmEdge Application Deployment\nDESCRIPTION: Command to create a Kubernetes YAML file for deploying a WebAssembly application. The YAML defines a pod with annotations to specify WasmEdge as the runtime via the compat-smart variant.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncat > wasmedge-app.yaml << EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    module.wasm.image/variant: compat-smart\n  labels:\n    run: wasi-demo\n  name: wasi-demo\nspec:\n  containers:\n  - args:\n    - /wasi_example_main.wasm\n    - \"50000000\"\n    image: wasmedge/example-wasi:latest\n    imagePullPolicy: IfNotPresent\n    name: wasi-demo\n  hostNetwork: true\n  restartPolicy: Never\nEOF\n\nkubectl create -f wasmedge-app.yaml\n```\n\n----------------------------------------\n\nTITLE: Generating and Using WasmEdge Value Types\nDESCRIPTION: This C code demonstrates how to generate and use different WasmEdge value types such as i32, i64, f32, and f64 using the `WasmEdge_ValueGen...` and `WasmEdge_ValueGet...` functions. The values are printed to the console after being created and retrieved. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \"123456\" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \"1234567890123\" */\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \"123.456001\" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \"123456.1234567890\" */\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Memory Type Context in C\nDESCRIPTION: Illustrates the creation of a Memory Type context with specific limits and how to retrieve information from it. This is used for memory instance creation and information querying.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Memory Limits in WasmEdge Go API\nDESCRIPTION: Shows how to create Limit structures with shared memory support for the thread proposal. Demonstrates creating shared limits with and without maximum values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nlim3 := wasmedge.NewLimitShared(20)\nfmt.Println(lim3.HasMax())\n// Will print `false`.\nfmt.Println(lim3.IsShared())\n// Will print `true`.\nfmt.Println(lim3.GetMin())\n// Will print `20`.\n\nlim4 := wasmedge.NewLimitSharedWithMax(30, 40)\nfmt.Println(lim4.HasMax())\n// Will print `true`.\nfmt.Println(lim4.IsShared())\n// Will print `true`.\nfmt.Println(lim4.GetMin())\n// Will print `30`.\nfmt.Println(lim4.GetMax())\n// Will print `40`.\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Reference Types in Go\nDESCRIPTION: Go code snippet showing how to create and use FuncRef and ExternRef types in WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nvar funccxt *wasmedge.Function = ... // Create or get function object.\nfuncref := wasmedge.NewFuncRef(funccxt)\n// Create a `FuncRef` with the function object.\n\nnum := 1234\n// `num` is a `int`.\nexternref := wasmedge.NewExternRef(&num)\n// Create an `ExternRef` which reference to the `num`.\nnum = 5678\n// Modify the `num` to 5678.\nnumref := externref.GetRef().(*int)\n// Get the original reference from the `ExternRef`.\nfmt.Println(*numref)\n// Will print `5678`.\nnumref.Release()\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: Running WASM Functions Rapidly with WasmEdge Go SDK\nDESCRIPTION: Go code demonstrating how to quickly execute a WebAssembly function using the WasmEdge Go SDK. It loads a WASM file, creates a VM instance, and runs the 'fib' function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Unified CLI Tool in C\nDESCRIPTION: Example demonstrating how to use the WasmEdge_Driver_UniTool() API to access the unified WasmEdge CLI functionality from C code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge unified tool. */\n  /* (Within both runtime and AOT compiler) */\n  return WasmEdge_Driver_UniTool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Plugin Header File Implementation\nDESCRIPTION: C++ header file containing plugin class definitions including host functions, environment class, and module class declarations\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#pragma once\n\n#include \"plugin/plugin.h\"\n\n#include <cstdint>\n#include <string>\n\nnamespace WasmEdge {\nnamespace Host {\n\nclass WasmEdgePluginTestEnv {\npublic:\n  WasmEdgePluginTestEnv() noexcept = default;\n\n  static Plugin::PluginRegister Register;\n};\n\ntemplate <typename T>\nclass WasmEdgePluginTestFunc : public Runtime::HostFunction<T> {\npublic:\n  WasmEdgePluginTestFunc(WasmEdgePluginTestEnv &HostEnv)\n      : Runtime::HostFunction<T>(0), Env(HostEnv) {}\n\nprotected:\n  WasmEdgePluginTestEnv &Env;\n};\n\nclass WasmEdgePluginTestFuncAdd\n    : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncAdd> {\npublic:\n  WasmEdgePluginTestFuncAdd(WasmEdgePluginTestEnv &HostEnv)\n      : WasmEdgePluginTestFunc(HostEnv) {}\n  Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {\n    return A + B;\n  }\n};\n\nclass WasmEdgePluginTestFuncSub\n    : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncSub> {\npublic:\n  WasmEdgePluginTestFuncSub(WasmEdgePluginTestEnv &HostEnv)\n      : WasmEdgePluginTestFunc(HostEnv) {}\n  Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {\n    return A - B;\n  }\n};\n\nclass WasmEdgePluginTestModule : public Runtime::Instance::ModuleInstance {\npublic:\n  WasmEdgePluginTestModule()\n      : Runtime::Instance::ModuleInstance(\"wasmedge_plugintest_cpp_module\") {\n    addHostFunc(\"add\", std::make_unique<WasmEdgePluginTestFuncAdd>(Env));\n    addHostFunc(\"sub\", std::make_unique<WasmEdgePluginTestFuncSub>(Env));\n  }\n\n  WasmEdgePluginTestEnv &getEnv() { return Env; }\n\nprivate:\n  WasmEdgePluginTestEnv Env;\n};\n\n} // namespace Host\n} // namespace WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Instance Type in WasmEdge\nDESCRIPTION: Shows how to retrieve the function type from a function instance. Function instances can represent host functions that are passed to WASM modules as imports or functions defined in WASM modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_59\n\nLANGUAGE: c\nCODE:\n```\n/* Retrieve the function instance from the module instance context. */\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n/*\n * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be\n * destroyed.\n */\n\n/*\n * For the function instance creation, please refer to the `Host Function`\n * guide.\n */\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions - Pre 0.11.0\nDESCRIPTION: Example showing how to access memory in host functions before WasmEdge 0.11.0, using direct memory instance context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Reference Types\nDESCRIPTION: Example of creating and using FuncRef and ExternRef types for the Reference-Types proposal.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar funccxt *wasmedge.Function = ... // Create or get function object.\nfuncref := wasmedge.NewFuncRef(funccxt)\n// Create a `FuncRef` with the function object.\n\nnum := 1234\n// `num` is a `int`.\nexternref := wasmedge.NewExternRef(&num)\n// Create an `ExternRef` which reference to the `num`.\nnum = 5678\n// Modify the `num` to 5678.\nnumref := externref.GetRef().(*int)\n// Get the original reference from the `ExternRef`.\nfmt.Println(*numref)\n// Will print `5678`.\nnumref.Release()\n// Should call the `Release` method.\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options - C\nDESCRIPTION: This snippet configures statistics options, which include enabling instruction counting, cost measuring, and time measuring for performance analysis in WasmEdge contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/*\n * By default, the instruction counting is `FALSE` when running a\n * compiled-WASM or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/*\n * By default, the cost measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/*\n * By default, the time measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Extensions\nDESCRIPTION: Command to install WasmEdge with TensorFlow and Image extensions\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.12.1\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Module in Go with WasmEdge\nDESCRIPTION: Demonstrates how to register a WebAssembly module with a unique module name using WasmEdge's VM API in Go\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Component Context Retrieval in WasmEdge\nDESCRIPTION: Shows how to retrieve the Loader, Validator, and Executor contexts from a VM context for direct access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Rollup.js Configuration\nDESCRIPTION: Configuration file for rollup.js that specifies how to bundle the NodeJS modules into a single ES6 module file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/npm.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst { babel } = require('@rollup/plugin-babel');\nconst nodeResolve = require('@rollup/plugin-node-resolve');\nconst commonjs = require('@rollup/plugin-commonjs');\nconst replace = require('@rollup/plugin-replace');\n\nconst globals = require('rollup-plugin-node-globals');\nconst builtins = require('rollup-plugin-node-builtins');\nconst plugin_async = require('rollup-plugin-async');\n\nconst babelOptions = {\n  presets: ['@babel/preset-react'],\n};\n\nmodule.exports = [\n  {\n    input: './npm_main.js',\n    output: {\n      inlineDynamicImports: true,\n      file: 'dist/npm_main.mjs',\n      format: 'esm',\n    },\n    external: ['process', 'wasi_net', 'std'],\n    plugins: [\n      plugin_async(),\n      nodeResolve(),\n      commonjs({ ignoreDynamicRequires: false }),\n      babel(babelOptions),\n      globals(),\n      builtins(),\n      replace({\n        'process.env.NODE_ENV': JSON.stringify('production'),\n        'process.env.NODE_DEBUG': JSON.stringify(''),\n      }),\n    ],\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Creating WasmEdge Application Manifest\nDESCRIPTION: Kubectl command to create a YAML manifest for a WasmEdge application pod in SuperEdge. The manifest specifies a WebAssembly container image and necessary annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncat > wasmedge-app.yaml << EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    module.wasm.image/variant: compat-smart\n  labels:\n    run: wasi-demo\n  name: wasi-demo\nspec:\n  containers:\n  - args:\n    - /wasi_example_main.wasm\n    - \"50000000\"\n    image: wasmedge/example-wasi:latest\n    imagePullPolicy: IfNotPresent\n    name: wasi-demo\n  hostNetwork: true\n  restartPolicy: Never\nEOF\n\nkubectl create -f wasmedge-app.yaml\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in WasmEdge\nDESCRIPTION: Example demonstrating how to enable various statistics tracking options including instruction counting, time measuring, and cost measuring. These are useful for profiling WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsInstructionCounting(true)\n// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsTimeMeasuring(true)\n// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsCostMeasuring(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Add Function Implementation in C\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns their sum.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASM Limit Structures\nDESCRIPTION: Demonstrates creating and working with WASM Limit structures for both regular and shared memory configurations. Shows how to set minimum and maximum values and check limit properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\nLANGUAGE: go\nCODE:\n```\nlim3 := wasmedge.NewLimitShared(20)\nfmt.Println(lim3.HasMax())\n// Will print `false`.\nfmt.Println(lim3.IsShared())\n// Will print `true`.\nfmt.Println(lim3.GetMin())\n// Will print `20`.\n\nlim4 := wasmedge.NewLimitSharedWithMax(30, 40)\nfmt.Println(lim4.HasMax())\n// Will print `true`.\nfmt.Println(lim4.IsShared())\n// Will print `true`.\nfmt.Println(lim4.GetMin())\n// Will print `30`.\nfmt.Println(lim4.GetMax())\n// Will print `40`.\n```\n\n----------------------------------------\n\nTITLE: Memory Type Context Usage in C\nDESCRIPTION: Demonstrates Memory Type context handling for WASM memory instances. Shows creation and limit management for memory types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {.HasMax = true, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Basic WasmEdge Version Check Program\nDESCRIPTION: Simple C program to verify WasmEdge installation by printing the version number using the C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plug-ins from Default Paths\nDESCRIPTION: Demonstrates how to load WasmEdge plug-ins from default system paths. These plug-ins extend the WasmEdge runtime with additional functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_78\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\n```\n\n----------------------------------------\n\nTITLE: VM Creation Examples in Go\nDESCRIPTION: Examples of different ways to create WasmEdge VM instances with various configurations and store objects in Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_32\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nstore := wasmedge.NewStore()\n\n// Create a VM with default configure and store.\nvm := wasmedge.NewVM()\nvm.Release()\n\n// Create a VM with the specified configure and default store.\nvm = wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// Create a VM with the default configure and specified store.\nvm = wasmedge.NewVMWithStore(store)\nvm.Release()\n\n// Create a VM with the specified configure and store.\nvm = wasmedge.NewVMWithConfigAndStore(conf, store)\nvm.Release()\n\nconf.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Statistics Context Management\nDESCRIPTION: Create and manage a statistics context for tracking instruction count and performance metrics\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using MemoryType in WasmEdge-go\nDESCRIPTION: Shows how to create and use MemoryType objects that define WebAssembly memory instances with size limits. Demonstrates retrieving memory type properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Passing a Functor as ExternRef in C++\nDESCRIPTION: This C++ code shows how to pass a functor object as externref to a WASM function and handle it in a host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nstruct SquareStruct {\n  uint32_t operator()(uint32_t Val) const { return Val * Val; }\n};\n\nSquareStruct SS;\n\nWasmEdge_Value P[2], R[1];\nP[0] = WasmEdge_ValueGenExternRef(&SS);\nP[1] = WasmEdge_ValueGenI32(1024);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"call_square\");\nWasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  std::cout << \"Result : \" << WasmEdge_ValueGetI32(R[0]) std::endl;\n} else {\n  return EXIT_FAILURE;\n}\n\nWasmEdge_Result ExternSquare(void *, const WasmEdge_CallingFrameContext *,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);\n  SquareStruct &Obj = *reinterpret_cast<SquareStruct *>(Ptr);\n  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));\n  Out[0] = WasmEdge_ValueGenI32(C);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-Crypto in WasmEdge\nDESCRIPTION: This snippet demonstrates how to configure a WasmEdge VM to use the WASI-Crypto proposal. It creates a new `Configure` object with various `wasmedge.WasiCrypto_*` options, creates a `VM` with that configuration, retrieves the WASI-Crypto import module, and then releases the VM and configuration objects. Note: Dependencies and prerequests must be satisfied.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\n```go\nconf := wasmedge.NewConfigure(wasmedge.WasiCrypto_Common, wasmedge.WasiCrypto_AsymmetricCommon, wasmedge.WasiCrypto_Kx, wasmedge.WasiCrypto_Signatures, wasmedge.WasiCrypto_Symmetric)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nnnmodule := vm.GetImportModule(wasmedge.WasiCrypto_Common)\nvm.Release()\n```\n```\n\n----------------------------------------\n\nTITLE: Getting Return Value Length from Asynchronous Execution in WasmEdge C API\nDESCRIPTION: Demonstrates how to retrieve the length of return values from an asynchronous execution, which is useful for allocating appropriate buffer size before retrieving the values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return value list length. */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Triggering Unified WasmEdge CLI in Go\nDESCRIPTION: Illustrates how to use the new RunWasmEdgeUnifiedCLI() API to trigger the unified WasmEdge CLI in v0.13.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nwasmedge.RunWasmEdgeUnifiedCLI()\n```\n\n----------------------------------------\n\nTITLE: Handling Execution Results and Errors in WasmEdge-go\nDESCRIPTION: Demonstrates how to check for errors after executing a WebAssembly function in a VM. The Result object provides error details through the Error() method.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\nres, err = vm.Execute(...) // Ignore the detail of parameters.\n// Assume that `res, err` are the return values for executing a function with `vm`.\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing Interpreter Mode in C\nDESCRIPTION: This snippet configures the execution mode to use the interpreter for running the WASM file or AOT compiled WASM. It checks the status before and after setting the interpreter mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* By default, The `IsForceInterp` will be `FALSE`. */\nWasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);\nIsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* The `IsForceInterp` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge_Process in WasmEdge\nDESCRIPTION: This snippet demonstrates how to configure a WasmEdge VM to use the `wasmedge_process` plugin. It creates a new `Configure` object with the `wasmedge.WasmEdge_PROCESS` option, creates a `VM` with that configuration, retrieves the process import module, initializes the WasmEdge_Process, and then releases the VM and configuration objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\n```go\nconf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nprocmodule := vm.GetImportModule(wasmedge.WasmEdge_PROCESS)\n// Initialize the WasmEdge_Process.\nprocmodule.InitWasmEdgeProcess(/* ... ignored */)\n\nvm.Release()\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Project for WasmEdge\nDESCRIPTION: Creates a new Go project directory and initializes it with go mod for WasmEdge development.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Defining Host Registration Constants in Go\nDESCRIPTION: Constants for host module registrations that can be enabled in a WasmEdge VM, including WASI and other extension modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  WASI                        = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n  WasmEdge_PROCESS            = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)\n  WasiNN                      = HostRegistration(C.WasmEdge_HostRegistration_WasiNN)\n  WasiCrypto_Common           = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Common)\n  WasiCrypto_AsymmetricCommon = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon)\n  WasiCrypto_Kx               = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Kx)\n  WasiCrypto_Signatures       = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Signatures)\n  WasiCrypto_Symmetric        = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Symmetric)\n)\n```\n\n----------------------------------------\n\nTITLE: Executing WasmEdge CLI Tools in Go\nDESCRIPTION: Examples of triggering WasmEdge CLI tools (wasmedge and wasmedgec) using the WasmEdge-Go SDK. The API arguments are the same as the command line arguments of the CLI tools.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeCLI(os.Args)\n}\n```\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Types in WASM Using WasmEdge in Go\nDESCRIPTION: Describes how to obtain the function type of a given function in a WASM module using WasmEdge in Go. It explains fetching function types by name and warns against manually releasing the function type object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.\nfunctype := vm.GetFunctionType(\"fib\")\n// Developers can get the function types of functions in the registered modules via the\n// `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.\n// If the function is not found, these APIs will return `nil`.\n// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge (C)\nDESCRIPTION: This C snippet configures optimization level, output format, and other AOT compiler options in WasmEdge. Dependencies: WasmEdge C library. Inputs: Compiler context. Outputs: Compiler setting statuses.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  WasmEdge_CompilerOptimizationLevel_O1,\n  WasmEdge_CompilerOptimizationLevel_O2,\n  WasmEdge_CompilerOptimizationLevel_O3,\n  WasmEdge_CompilerOptimizationLevel_Os,\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n/* Set this option to `TRUE` to support the interruptible execution in AOT mode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in C\nDESCRIPTION: Example of creating and querying a Function Type context with parameter and return value types. Demonstrates how to work with function signatures in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge with Process Plugin\nDESCRIPTION: Command to run the WasmEdge runtime with the Process plugin enabled. The command includes directory mapping, reactor mode activation, and specifying the path to the Process plugin library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/process.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge Strings in C\nDESCRIPTION: Demonstrates operations with WasmEdge strings, such as creation, wrapping, comparison, and conversion to C strings. Includes memory management considerations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n```\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"test\";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n```\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"abcd\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\nWasmEdge_StringDelete(Str2);\n```\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[256];\nWasmEdge_String Str = WasmEdge_StringCreateByCString(\"test_wasmedge_string\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\nprintf(\"String: %s\\n\", Buf);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Asynchronous Fibonacci Example\nDESCRIPTION: Commands to compile the C code that asynchronously executes a WebAssembly Fibonacci calculator and run the resulting binary. The output shows the 20th Fibonacci number in 0-based index.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: New Module Instance Retrieval (v0.12.0+)\nDESCRIPTION: Example showing how to retrieve module instances from VM context using the new APIs in v0.12.0+.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nwasimod := vm.GetImportModule(wasmedge.WASI)\ncryptocommonmod := vm.GetRegisteredModule(\"wasi_ephemeral_crypto_common\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow-Lite shared library for Android\nDESCRIPTION: Commands to download and extract the Android-compatible TensorFlow-Lite dynamic shared library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz\n$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools\nlibtensorflowlite_c.so\n```\n\n----------------------------------------\n\nTITLE: WASM Function Invocation - Pre v0.10.0\nDESCRIPTION: Complete example of loading, validating, and executing a WASM function in WasmEdge-Go v0.9.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvar err error\nvar ast *wasmedge.AST\nvar res []interface{}\nloader := wasmedge.NewLoader()\nvalidator := wasmedge.NewValidator()\nexecutor := wasmedge.NewExecutor()\nast, err = loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n  return\n}\nerr = validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n  return\n}\nerr = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\nres, err = executor.Invoke(store, \"fib\", int32(30))\nif err == nil {\n  fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n} else {\n  fmt.Println(\"Run failed:\", err.Error())\n}\nast.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating Library WASM Module with Exported Functions\nDESCRIPTION: Defines a WebAssembly module with two exported mathematical functions: addition and multiplication. These functions can be imported by other modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_0\n\nLANGUAGE: wat\nCODE:\n```\n(module\n  (func (export \"add\") (param i32 i32) (result i32)\n    ;; Function to add 2 numbers and exported as \"add\".\n    (i32.add (local.get 0) (local.get 1))\n  )\n  (func (export \"mul\") (param i32 i32) (result i32)\n    ;; Function to mul 2 number and exported as \"mul\".\n    (i32.mul (local.get 0) (local.get 1))\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Runtime CLI Tool\nDESCRIPTION: Example showing how to use the WasmEdge_Driver_Tool() API to implement the runtime CLI functionality, equivalent to the 'wasmedge run' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_82\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Module with Name in WasmEdge 0.10.0 (C)\nDESCRIPTION: Example of registering a WASM module with a module name using the updated WasmEdge_ExecutorRegister API in WasmEdge version 0.10.0. This method returns the module instance that must be managed by the caller.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt;\n/*\n * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\n\n/* Register the WASM module into store with the export module name \"mod\". */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nRes = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nWasmEdge_StringDelete(ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version in Go\nDESCRIPTION: Retrieves version information of the installed WasmEdge shared library using Go API calls.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Running HTTP Server in Docker and Testing with cURL\nDESCRIPTION: This set of commands runs a Rust-based HTTP server in a Docker container and tests it using cURL. The server is mapped to port 8080 and responds to POST requests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_docker.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest\n\n$ curl http://localhost:8080/\n\n$ curl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\n```\n\n----------------------------------------\n\nTITLE: Compiling and Linking WasmEdge Static Library in Bash\nDESCRIPTION: This bash command shows how to compile a C program using the WasmEdge static library. Note that the -lrt flag is only needed for Linux platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/library.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge -lrt -ldl -pthread -lm -lstdc++ -o test\n$ ./test\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge Plugin Context by Name\nDESCRIPTION: Demonstrates retrieving a plugin context using its name, specifically showing the WASI crypto plugin as an example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n```\n\n----------------------------------------\n\nTITLE: Rust Image Classification Function Implementation\nDESCRIPTION: Implementation of WebAssembly-compatible image classification function using Rust and WasmEdge Tensorflow API\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasmedge_bindgen]\npub fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {\n  let start = Instant::now();\n\n  // Load the TFLite model and its metadata (the text label for each recognized object number)\n  let model_data: &[u8] = include_bytes!(\"lite-model_aiy_vision_classifier_food_V1_1.tflite\");\n  let labels = include_str!(\"aiy_food_V1_labelmap.txt\");\n\n  // Pre-process the image to a format that this model can use\n  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&image_data[..], 192, 192);\n  println!(\"RUST: Loaded image in ... {:?}\", start.elapsed());\n\n  // Run the TFLite model using the WasmEdge Tensorflow API\n  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);\n  session.add_input(\"input\", &flat_img, &[1, 192, 192, 3])\n         .run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Softmax\");\n\n  // Find the object index in res_vec that has the greatest probability\n  // Translate the probability into a confidence level\n  // Translate the object index into a label from the model metadata food_name\n  let mut i = 0;\n  let mut max_index: i32 = -1;\n  let mut max_value: u8 = 0;\n  while i < res_vec.len() {\n    let cur = res_vec[i];\n    if cur > max_value {\n      max_value = cur;\n      max_index = i as i32;\n    }\n    i += 1;\n  }\n  println!(\"RUST: index {}, prob {}\", max_index, max_value);\n\n  let confidence: String;\n  if max_value > 200 {\n    confidence = \"is very likely\".to_string();\n  } else if max_value > 125 {\n    confidence = \"is likely\".to_string();\n  } else {\n    confidence = \"could be\".to_string();\n  }\n\n  let ret_str: String;\n  if max_value > 50 {\n    let mut label_lines = labels.lines();\n    for _i in 0..max_index {\n      label_lines.next();\n    }\n    let food_name = label_lines.next().unwrap().to_string();\n    ret_str = format!(\n      \"It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture\",\n      confidence, food_name, food_name\n    );\n  } else {\n    ret_str = \"It does not appears to be a food item in the picture.\".to_string();\n  }\n\n  println!(\n    \"RUST: Finished post-processing in ... {:?}\",\n    start.elapsed()\n  );\n  return Ok(ret_str.as_bytes().to_vec());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Global Type Context in C\nDESCRIPTION: Demonstrates the creation and usage of a Global Type context in WasmEdge. It shows how to create a global type with a specific value type and mutability, and how to query its properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `GotValType` will be WasmEdge_ValType_F64. */\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `GotValMut` will be WasmEdge_Mutability_Var. */\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration - Pre v0.10.0\nDESCRIPTION: Example of registering a host module using ImportObject in version 0.9.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nimpobj := wasmedge.NewImportObject(\"module\")\nerr := executor.RegisterImport(store, impobj)\nif err != nil {\n  fmt.Println(\"Import object registration FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Return Values from Asynchronous Execution in WasmEdge C API\nDESCRIPTION: Shows how to retrieve actual return values from a completed asynchronous execution using WasmEdge_AsyncGet(). This function blocks until execution completes, then fills the provided buffer with return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version in Go\nDESCRIPTION: APIs to retrieve WasmEdge library version information including major, minor and patch numbers\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Post-processing Mediapipe Detection Results in Rust\nDESCRIPTION: Rust code snippet demonstrating how to use utility functions to draw detection results on an input image and save the output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ndraw_detection(&mut input_img, &detection_result);\ninput_img.save(output_path)?\n```\n\n----------------------------------------\n\nTITLE: Testing AWS Lambda Docker Image Locally\nDESCRIPTION: Commands for testing an AWS Lambda Docker image locally using the AWS Lambda Runtime Interface Emulator, which allows verification of the function's behavior before deployment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -p 9000:8080  myfunction:latest\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -XPOST \"http://localhost:9000/2015-03-31/functions/function/invocations\" -d '{}'\n```\n\n----------------------------------------\n\nTITLE: Implementing the echo function for axum with Rust\nDESCRIPTION: This Rust function `echo` processes incoming data streams from a `POST` request. It asynchronously reads the stream, retrieves the first chunk of data (if any), and returns it as a `Bytes` object, which is then sent back as the response message. If the stream is empty, it returns an empty `Bytes` object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nasync fn echo(mut stream: BodyStream) -> Bytes {\n    if let Some(Ok(s)) = stream.next().await {\n        s\n    } else {\n        Bytes::new()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: YoMo Integration with WasmEdge - Go\nDESCRIPTION: Go implementation for integrating YoMo with WasmEdge runtime and handling image processing\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"crypto/sha1\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n  \"sync/atomic\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n  \"github.com/yomorun/yomo\"\n)\n\nvar (\n  counter uint64\n)\n\nconst ImageDataKey = 0x10\n\nfunc main() {\n  // Connect to Zipper service\n  sfn := yomo.NewStreamFunction(\"image-recognition\", yomo.WithZipperAddr(\"localhost:9900\"))\n  defer sfn.Close()\n\n  // set only monitoring data\n  sfn.SetObserveDataID(ImageDataKey)\n\n  // set handler\n  sfn.SetHandler(Handler)\n\n  // start\n  err := sfn.Connect()\n  if err != nil {\n    log.Print(\" Connect to zipper failure: \", err)\n    os.Exit(1)\n  }\n\n  select {}\n}\n\n// Handler processes the data in the stream\nfunc Handler(img []byte) (byte, []byte) {\n  // Initialize WasmEdge's VM\n  vmConf, vm := initVM()\n  bg := bindgen.Instantiate(vm)\n  defer bg.Release()\n  defer vm.Release()\n  defer vmConf.Release()\n\n  // recognize the image\n  res, err := bg.Execute(\"infer\", img)\n  if err == nil {\n    fmt.Println(\"GO: Run bindgen -- infer:\", string(res))\n  } else {\n    fmt.Println(\"GO: Run bindgen -- infer FAILED\")\n  }\n\n  // print logs\n  hash := genSha1(img)\n  log.Printf(\" received image-%d hash %v, img_size=%d \\n\", atomic.AddUint64(&counter, 1), hash, len(img))\n\n  return 0x11, nil\n}\n\n// genSha1 generate the hash value of the image\nfunc genSha1(buf []byte) string {\n  h := sha1.New()\n  h.Write(buf)\n  return fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\n// initVM initialize WasmEdge's VM\nfunc initVM() (*wasmedge.Configure, *wasmedge.VM) {\n  wasmedge.SetLogErrorLevel()\n  // Set Tensorflow not to print debug info\n  os.Setenv(\"TF_CPP_MIN_LOG_LEVEL\", \"3\")\n  os.Setenv(\"TF_CPP_MIN_VLOG_LEVEL\", \"3\")\n\n  // Create configure\n  vmConf := wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  vm := wasmedge.NewVMWithConfig(vmConf)\n\n  // Init WASI\n  var wasi = vm.GetImportObject(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping directories\n  )\n\n  // Register WasmEdge-tensorflow and WasmEdge-image\n  var tfobj = wasmedge.NewTensorflowImportObject()\n  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()\n  vm.RegisterImport(tfobj)\n  vm.RegisterImport(tfliteobj)\n  var imgobj = wasmedge.NewImageImportObject()\n  vm.RegisterImport(imgobj)\n\n  // Instantiate wasm\n  vm.LoadWasmFile(\"rust_mobilenet_food_lib.so\")\n  vm.Validate()\n\n  return vmConf, vm\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Host Registrations in WasmEdge Configuration\nDESCRIPTION: Shows how to query and enable host registrations like WASI in a WasmEdge configuration context for use with VM instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for Qdrant Client Dependencies\nDESCRIPTION: Dependencies and patch configurations required in Cargo.toml for compiling qdrant_rest_client and tokio crates with WasmEdge-specific socket APIs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/qdrant_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nreqwest = { git = \"https://github.com/second-state/wasi_reqwest.git\", branch = \"0.11.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\n\n[dependencies]\nanyhow = \"1.0\"\nserde_json = \"1.0\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nurl = \"2.3\"\ntokio = { version = \"1\", features = [\"io-util\", \"fs\", \"net\", \"time\", \"rt\", \"macros\"] }\nqdrant_rest_client = \"0.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in C\nDESCRIPTION: This snippet allows developers to configure the maximum memory pages available to WebAssembly instances. It demonstrates how to retrieve and set the maximum memory limit.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/*\n * Limit the memory size of each memory instance with not larger than 1024\n * pages (64 MiB).\n */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing HMAC Authentication in WASI-Crypto\nDESCRIPTION: Example showing how to generate an authentication key, create an HMAC tag, and verify the authentication using WASI-crypto's Auth module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasicrypto.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// generate key\nlet key = AuthKey::generate(\"HMAC/SHA-512\")?;\n// generate tag\nlet tag = Auth::auth(\"test\", &key)?;\n// verify\nAuth::auth_verify(\"test\", &key, tag)?;\n```\n\n----------------------------------------\n\nTITLE: Installing Latest Docker CE\nDESCRIPTION: Commands to install the latest Docker Community Edition using the official installation script. This is required as Docker version > 4.29 (which includes Moby 25) is needed for CDI support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> curl -fsSL https://get.docker.com -o get-docker.sh\n> sh get-docker.sh\n\n# Check your docker\n> docker --version\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Types in Go\nDESCRIPTION: Shows how to retrieve a function type from a function object in WasmEdge. The function object is typically obtained from a module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_55\n\nLANGUAGE: go\nCODE:\n```\nfuncobj := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the module instance should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n\n// For the function object creation, please refer to the `Host Function` guide.\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Context Creation and Deletion\nDESCRIPTION: Basic example of creating and deleting a WasmEdge configuration context\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance from Plugin (Post-0.12.0)\nDESCRIPTION: Example of creating a module instance from a plugin after version 0.12.0, using the new general API with WasmEdge_PluginContext.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char CryptoPName[] = \"wasi_crypto\";\nconst char CryptoMName[] = \"wasi_crypto_common\";\nWasmEdge_String PluginName =\n    WasmEdge_StringWrap(CryptoPName, strlen(CryptoPName));\nWasmEdge_String ModuleName =\n    WasmEdge_StringWrap(CryptoMName, strlen(CryptoMName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(PluginName);\n\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, ModuleName);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Function Context in C\nDESCRIPTION: Example of creating a function context with type definition and host function body initialization.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\nWasmEdge_FunctionTypeDelete(HostType);\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Registering AST Module in Go WasmEdge Executor\nDESCRIPTION: Demonstrates how to instantiate and register a WASM AST object as a named Module instance using the Executor. Creates required components like Statistics, Executor and Store before registration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, res := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Run Command Help\nDESCRIPTION: Shows the basic usage syntax for the wasmedge run command, displaying help information for command line arguments and options.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/run.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge run -h\nUSAGE\n   wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Host Data Example\nDESCRIPTION: Shell commands for building and running the WasmEdge Go SDK host data example. Shows the output with both the function result and the data value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_73\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for WasmEdge and Qdrant\nDESCRIPTION: This `Cargo.toml` configuration applies patches to the `socket2`, `reqwest`, `hyper` and `tokio` crates, pointing them to WasmEdge-specific forks. It also defines the dependencies needed for the Qdrant example, including `anyhow`, `serde_json`, `serde`, `url`, `tokio`, and `qdrant_rest_client`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/qdrant_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n[patch.crates-io]\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nreqwest = { git = \"https://github.com/second-state/wasi_reqwest.git\", branch = \"0.11.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\n\n[dependencies]\nanyhow = \"1.0\"\nserde_json = \"1.0\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nurl = \"2.3\"\ntokio = { version = \"1\", features = [\"io-util\", \"fs\", \"net\", \"time\", \"rt\", \"macros\"] }\nqdrant_rest_client = \"0.1.0\"\n```\n```\n\n----------------------------------------\n\nTITLE: Cloning and Compiling MySQL Async Example (Bash)\nDESCRIPTION: This script clones the `wasmedge-db-examples` repository, navigates to the `mysql_async` example directory, compiles the Rust code into a WASM module targeting `wasm32-wasip1`, and then executes MySQL statements against a database specified by the `DATABASE_URL` environment variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/mysql_async\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Execute MySQL statements against a MySQL database at mysql://user:passwd@127.0.0.1:3306\nwasmedge --env \"DATABASE_URL=mysql://user:passwd@127.0.0.1:3306/mysql\" target/wasm32-wasip1/release/crud.wasm\n```\n\n----------------------------------------\n\nTITLE: Direct Asynchronous WASM Function Execution in C\nDESCRIPTION: Demonstrates how to directly execute a WebAssembly function asynchronously using WasmEdge_VMAsyncRunWasmFromFile. The example calculates the 20th Fibonacci number using a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, \"fibonacci.wasm\", FuncName, Params, 1);\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Bytecode\nDESCRIPTION: Command to compile Rust code into WebAssembly bytecode targeting the wasip1 platform.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Strings in C API\nDESCRIPTION: Detailed example of creating and managing WasmEdge_String objects. Includes creation by C string, buffer, and comparison.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n\nconst char CStr[] = \"abcd\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\n\nchar Buf[256];\nWasmEdge_String Str = WasmEdge_StringCreateByCString(\"test_wasmedge_string\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf(\"String: %s\\n\", Buf);\n/* Will print \"test_wasmedge_string\". */\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in C\nDESCRIPTION: Demonstrates the creation and usage of a Function Type context in WasmEdge. It shows how to create a function type with parameters and return values, and how to query information from it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I64};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\n/* `ParamLen` will be 2. */\nuint32_t GotParamLen =\n    WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\n/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as\n * `ParamList`. */\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\n/* `ReturnLen` will be 1. */\nuint32_t GotReturnLen =\n    WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.\n */\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: WASM Function Invocation - Post v0.10.0\nDESCRIPTION: Updated example showing function invocation in WasmEdge-Go v0.10.0 with explicit function instance retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nvar mod *wasmedge.Module\nmod, err = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\nfuncinst := mod.FindFunction(\"fib\")\nif funcinst == nil {\n  fmt.Println(\"Run FAILED: Function name `fib` not found\")\n  return\n}\nres, err = executor.Invoke(store, funcinst, int32(30))\nif err == nil {\n  fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n} else {\n  fmt.Println(\"Run FAILED:\", err.Error())\n}\nast.Release()\nmod.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Host Registration Types for WasmEdge VM\nDESCRIPTION: Constants for host module registration in WasmEdge VM. Currently only WASI is defined, but the enum is reserved for future built-in host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n)\n```\n\n----------------------------------------\n\nTITLE: Building and Running Hyper Server in WasmEdge\nDESCRIPTION: Commands to clone, build and run an HTTP server example using the hyper framework in WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/server\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/wasmedge_hyper_server.wasm wasmedge_hyper_server.wasm\n\n# Run the example\nwasmedge wasmedge_hyper_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Setting Input Tensor and Executing LLaMA Inference in Rust\nDESCRIPTION: This snippet shows how to set the input tensor with a prompt and execute the LLaMA model inference. It converts the prompt to bytes, sets it as the input tensor, and then computes the inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n // set input tensor\n    let tensor_data = prompt.as_str().as_bytes().to_vec();\n    context\n        .set_input(0, wasi_nn::TensorType::U8, &[1], &tensor_data)\n        .expect(\"Failed to set prompt as the input tensor\");\n\n  // execute the inference\n    context.compute().expect(\"Failed to complete inference\");\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM (Go)\nDESCRIPTION: Demonstrates how to enable WASI support in a WasmEdge VM configuration and retrieve the WASI import module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the built-in registered module instances from the VM object.\n// This API will return `nil` if the corresponding configuration is not set when creating the VM object.\nwasiconf := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasiconf.InitWasi(/* ... ignored */)\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding a Global Instance in WasmEdge C API\nDESCRIPTION: Creating a mutable global instance of i32 type with an initial value of 666, then adding it to a module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_73\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n   WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n   WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution in WasmEdge\nDESCRIPTION: This snippet demonstrates how to wait for an asynchronous execution to finish using `WasmEdge_AsyncWait`. It blocks until the execution completes, then deletes the asynchronous object using `WasmEdge_AsyncDelete`. Developers own the Async object and must delete it after use.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Downloading Llama2 Inference Model in Bash\nDESCRIPTION: Command to download the Llama2 chat model in GGUF format from Hugging Face, which will be used for inference in the WebAssembly application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf\n```\n\n----------------------------------------\n\nTITLE: Compiling C-SIMD Application to WebAssembly using Emscripten\nDESCRIPTION: This command compiles the 'mandelbrot-simd.c' file to WebAssembly using Emscripten compiler (emcc) with specific optimization flags and memory settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/simd.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nemcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \\\n  -mmutable-globals \\\n  -mnontrapping-fptoint \\\n  -msign-ext \\\n  mandelbrot-simd.c -o mandelbrot-simd.wasm\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application\nDESCRIPTION: Commands for building and running a Go application that uses the WasmEdge SDK. Shows how to install the dependency and execute the compiled application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_69\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge-Go Package\nDESCRIPTION: Downloads and builds the WasmEdge-Go package in project directory\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\ngo build\n```\n\n----------------------------------------\n\nTITLE: Vercel Serverless Function for AI Inference\nDESCRIPTION: JavaScript code for the Vercel serverless function that loads the WasmEdge runtime with TensorFlow support, executes the WebAssembly program, and handles input/output for image classification.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst fs = require('fs');\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nmodule.exports = (req, res) => {\n  const wasmedge = spawn(\n    path.join(__dirname, 'wasmedge-tensorflow-lite'),\n    [path.join(__dirname, 'classify.so')],\n    { env: { LD_LIBRARY_PATH: __dirname } },\n  );\n\n  let d = [];\n  wasmedge.stdout.on('data', (data) => {\n    d.push(data);\n  });\n\n  wasmedge.on('close', (code) => {\n    res.setHeader('Content-Type', `text/plain`);\n    res.send(d.join(''));\n  });\n\n  wasmedge.stdin.write(req.body);\n  wasmedge.stdin.end('');\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instances from Plug-ins in Go\nDESCRIPTION: This snippet demonstrates how to create a module instance from a loaded plug-in by listing available host modules using `ListModule` and then creating a module instance with `CreateModule`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.\n// List the available host modules in the plug-in.\nmodules := plugincrypto.ListModule()\nfor _, name := range modules {\n  fmt.Println(\"Available module: \", name)\n}\n// Create a module instance from the plug-in by the module name.\nmodinst := plugincrypto.CreateModule(\"wasi_ephemeral_crypto_common\")\n\nmodinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling WASM to AOT for improved performance\nDESCRIPTION: This command compiles the existing WASM file to AOT format, which optimizes the performance when executing the Rust application. The compiled AOT file is then executed using the WasmEdge CLI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile hello.wasm hello_aot.wasm\n\n$ wasmedge hello_aot.wasm second state\nhello\nsecond\nstate\n```\n\n----------------------------------------\n\nTITLE: Working with Reference Types in WasmEdge Go\nDESCRIPTION: Shows how to create and manipulate function and external references using WasmEdge Go API, including reference modification and memory management\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfuncref := wasmedge.NewFuncRef(10)\n\nnum := 1234\nexternref := wasmedge.NewExternRef(&num)\nnum = 5678\nnumref := externref.GetRef().(*int)\nfmt.Println(*numref)\nnumref.Release()\n```\n\n----------------------------------------\n\nTITLE: Implementing TCP Server in JavaScript\nDESCRIPTION: JavaScript code demonstrating how to create a TCP server using WasmEdge's WasiTcpServer API. The server listens on port 8000 and accepts up to 100 client connections.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as net from 'wasi_net';\nimport { TextDecoder } from 'util';\n\nasync function server_start() {\n  print('listen 8000 ...');\n  try {\n    let s = new net.WasiTcpServer(8000);\n    for (var i = 0; i < 100; i++) {\n      let cs = await s.accept();\n      handle_client(cs);\n    }\n  } catch (e) {\n    print('server accept error:', e);\n  }\n}\n\nserver_start();\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Information in Go\nDESCRIPTION: Demonstrates how to query imports and exports from an AST object representing a loaded WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_52\n\nLANGUAGE: go\nCODE:\n```\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WASM Example\nDESCRIPTION: Commands for compiling the C program with WasmEdge library and executing the resulting binary to compute the 18th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Getting Return Value Length from Asynchronous Execution\nDESCRIPTION: Demonstrates retrieving the length of return values from an asynchronous execution. This function blocks until the execution completes and returns the number of values that can be retrieved.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return value list length. */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Token from KubeEdge Cloud Side\nDESCRIPTION: Retrieves the token from the KubeEdge cloud side using keadm, which is required for joining edge nodes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config\n27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE\n```\n\n----------------------------------------\n\nTITLE: Validator Implementation Example\nDESCRIPTION: Demonstrates how to use the Validator object to validate WASM modules before instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the validator context.\n// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\nvalidator := wasmedge.NewValidatorWithConfig(conf)\n\nerr := validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n}\n\nvalidator.Release()\n```\n\n----------------------------------------\n\nTITLE: Enabling WASI-Crypto Support in WasmEdge Go\nDESCRIPTION: This snippet shows how to enable WASI-Crypto proposal support in a WasmEdge VM configuration. It requires that the dependencies and prerequisites for WASI-Crypto are satisfied.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WasiCrypto_Common, wasmedge.WasiCrypto_AsymmetricCommon, wasmedge.WasiCrypto_Kx, wasmedge.WasiCrypto_Signatures, wasmedge.WasiCrypto_Symmetric)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nnnmodule := vm.GetImportModule(wasmedge.WasiCrypto_Common)\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Host Registration Enum Definition in WasmEdge\nDESCRIPTION: Defines the enumeration of host module registrations that can be configured in WasmEdge. These determine which built-in host modules are available to WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0,\n  WasmEdge_HostRegistration_WasmEdge_Process\n};\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Custom JavaScript Modules\nDESCRIPTION: Example JavaScript code that imports functions from custom modules and calls them. This demonstrates how to use the built-in modules system in WasmEdge QuickJS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { hello_mod_1 } from 'my_mod_1';\nimport { hello_mod_2 } from 'my_mod_2';\n\nhello_mod_1();\nhello_mod_2();\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Implementation in WebAssembly\nDESCRIPTION: WebAssembly module implementing recursive Fibonacci number calculation. Exports a single function 'fib' that takes an integer parameter and returns the corresponding Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_30\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in Go\nDESCRIPTION: Shows how to query and list imports and exports from an AST object, which represents the loaded structure from a WASM file or buffer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_49\n\nLANGUAGE: go\nCODE:\n```\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Downloading and Compiling WasmEdge QuickJS Runtime\nDESCRIPTION: Commands to download the pre-built WasmEdge QuickJS runtime and perform AOT compilation for better performance\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\nwasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm\n```\n\n----------------------------------------\n\nTITLE: Building the Go SDK Application\nDESCRIPTION: These commands retrieve the WasmEdge-go SDK and build the `run.go` application. The `go get` command downloads the necessary WasmEdge Go bindings, and the `go build` command compiles the Go code into an executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\ngo build run.go\n```\n\n----------------------------------------\n\nTITLE: Context Lifecycle Management\nDESCRIPTION: Example of creating and releasing WasmEdge contexts\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\\nconf := wasmedge.NewConfigure()\\n// Release the `conf` immediately.\\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Setting Up Build Environment on Windows\nDESCRIPTION: PowerShell commands to install required dependencies using Chocolatey, configure Visual Studio development environment, and download pre-built LLVM 16 binaries for Windows.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/windows.md#2025-04-21_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n# Install the required tools\nchoco install cmake ninja vswhere\n\n$vsPath = (vswhere -latest -property installationPath)\n# If vswhere.exe is not in PATH, try the following instead.\n# $vsPath = (&\"C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -property installationPath)\n\nImport-Module (Join-Path $vsPath \"Common7\\Tools\\Microsoft.VisualStudio.DevShell.dll\")\nEnter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \"-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0\"\n\n# Download our pre-built LLVM 16 binary\n$llvm = \"LLVM-16.0.6-win64-MultiThreadedDLL.zip\"\ncurl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm\nExpand-Archive -Path $llvm\n\n# Set LLVM environment\n$llvm_dir = \"$pwd\\LLVM-16.0.6-win64-MultiThreadedDLL\\LLVM-16.0.6-win64\\lib\\cmake\\llvm\"\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge AOT Compiler Through C API\nDESCRIPTION: This snippet demonstrates how to programmatically invoke the WasmEdge AOT (Ahead-of-Time) compiler using the C API. It passes command line arguments directly to the compiler driver function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge Value Types (C)\nDESCRIPTION: Examples of using WasmEdge_ValType to encode and check various WASM value types, including number types and reference types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ValType;\nValType = WasmEdge_ValTypeGenI32();\nbool IsTypeI32 = WasmEdge_ValTypeIsI32(ValType);\n/* The `IsTypeI32` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenI64();\nbool IsTypeI64 = WasmEdge_ValTypeIsI64(ValType);\n/* The `IsTypeI64` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenF32();\nbool IsTypeF32 = WasmEdge_ValTypeIsF32(ValType);\n/* The `IsTypeF32` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenF64();\nbool IsTypeF64 = WasmEdge_ValTypeIsF64(ValType);\n/* The `IsTypeF64` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenV128();\nbool IsTypeV128 = WasmEdge_ValTypeIsV128(ValType);\n/* The `IsTypeV128` will be `TRUE`. */\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in WasmEdge\nDESCRIPTION: This snippet allows developers to set a limit on the maximum number of memory pages for a WasmEdge configuration context, enhancing memory management for WASM executions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/*\n * Limit the memory size of each memory instance with not larger than 1024\n * pages (64 MiB).\n */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Homebrew\nDESCRIPTION: Commands to install required dependencies using Homebrew and set up the necessary environment variables for building WasmEdge on macOS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/macos.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Tools and libraries\nbrew install cmake ninja llvm\nexport LLVM_DIR=\"$(brew --prefix)/opt/llvm/lib/cmake\"\nexport CC=clang\nexport CXX=clang++\n```\n\n----------------------------------------\n\nTITLE: Configuring containerd to use crun runtime\nDESCRIPTION: Commands to configure containerd to use crun as the OCI runtime. This includes creating the config directory, generating a default configuration, and applying a patch to enable crun support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir -p /etc/containerd/\nsudo bash -c \"containerd config default > /etc/containerd/config.toml\"\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff\nsudo patch -d/ -p0 < containerd_config.diff\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Value Types in C\nDESCRIPTION: Examples demonstrating how to generate and retrieve WASM numeric and reference types using WasmEdge values in C.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\nPtr = WasmEdge_ValueGetExternRef(Val);\nVal = WasmEdge_ValueGenFuncRef(20);\nuint32_t FuncIdx = WasmEdge_ValueGetFuncIdx(Val);\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\nNum += 55;\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n```\n\n----------------------------------------\n\nTITLE: Function Instance Management in Go\nDESCRIPTION: Shows how to work with function instances in WasmEdge, including retrieving function types from function objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\nfuncobj := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the module instance should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Compiling C to WebAssembly with Emscripten\nDESCRIPTION: Command to compile the Hello World C program to WebAssembly using Emscripten compiler (emcc).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nemcc hello.c -o hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Finding a Specific WasmEdge Plugin by Name\nDESCRIPTION: Example showing how to find a specific plugin by name after loading plugins. Useful when you need to access functionality from a particular plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_75\n\nLANGUAGE: go\nCODE:\n```\n// Assume that wasi_crypto plug-in is installed in the default plug-in path.\nwasmedge.LoadPluginDefaultPaths()\nplugincrypto := wasmedge.FindPlugin(\"wasi_crypto\")\n```\n\n----------------------------------------\n\nTITLE: Custom Cost Table Implementation\nDESCRIPTION: Define and set a custom cost table for tracking instruction execution costs\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  // Additional instruction costs...\n};\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge QuickJS with WASI-NN Support\nDESCRIPTION: Commands for cloning the wasmedge-quickjs repository, downloading the pre-built WasmEdge QuickJS runtime with WASI-NN support, and optionally AOT compiling it for better performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/tensorflow.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs_nn.wasm\nwasmedgec wasmedge_quickjs_nn.wasm wasmedge_quickjs_nn.wasm\n```\n\n----------------------------------------\n\nTITLE: Setting Input Tensor in Rust\nDESCRIPTION: Rust code for converting the prompt into bytes and setting it as the input tensor for model inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n // set input tensor\n    let tensor_data = prompt.as_str().as_bytes().to_vec();\n    context\n        .set_input(0, wasi_nn::TensorType::U8, &[1], &tensor_data)\n        .expect(\"Failed to set prompt as the input tensor\");\n```\n\n----------------------------------------\n\nTITLE: Running Tests for a WasmEdge Plugin\nDESCRIPTION: Commands for building and running tests for a WasmEdge plugin using CMake and CTest. This example demonstrates how to set up a test environment for the wasmedge-image plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/best_practice.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ../../../test/plugins/wasmedge_image\nmkdir build && cd build\ncmake ..\nmake\nctest\n```\n\n----------------------------------------\n\nTITLE: Legacy Module Instance Retrieval (Pre-v0.12.0)\nDESCRIPTION: Example showing how to retrieve module instances from VM context using the old API style before v0.11.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nconf := wasmedge.NewConfigure(wasmedge.WASI)\ncomf.AddConfig(wasmedge.WasiCrypto_Common)\ncomf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)\ncomf.AddConfig(wasmedge.WasiCrypto_Kx)\ncomf.AddConfig(wasmedge.WasiCrypto_Signatures)\ncomf.AddConfig(wasmedge.WasiCrypto_Symmetric)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nwasimod := vm.GetImportModule(wasmedge.WASI)\ncryptocommonmod := vm.GetImportModule(wasmedge.WasiCrypto_Common)\n\nstore := vm.GetStore()\ncryptokxmod := store.FindModule(\"wasi_ephemeral_crypto_kx\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Performing an HTTP POST Request with reqwest\nDESCRIPTION: This Rust snippet shows how to perform an asynchronous HTTP POST request using the reqwest library. It sends a message body and awaits the response, printing the response body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    let client = reqwest::Client::new();\n\n    let res = client\n        .post(\"http://eu.httpbin.org/post\")\n        .body(\"msg=WasmEdge\")\n        .send()\n        .await?;\n    let body = res.text().await?;\n\n    println!(\"POST: {}\", body);\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Optimization Levels and Output Formats in C\nDESCRIPTION: This code snippet defines the enumeration types for WasmEdge AOT compiler options. It includes optimization levels from O0 (minimal optimization) to O3 (maximum performance), Os and Oz (size optimizations), as well as output format options for native libraries or WebAssembly with AOT compiled code in custom sections.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\n/// AOT compiler optimization level enumeration.\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\n/// AOT compiler output binary format enumeration.\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom sections.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Cargo Dependencies Configuration with TLS Support\nDESCRIPTION: Configuration for cargo.toml showing required dependencies and patches for WasmEdge MySQL support with TLS enabled\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\n\n[dependencies]\nmysql_async = { version = \"0.34\", default-features=false, features = [ \"default-rustls\" ], git=\"https://github.com/blackbeam/mysql_async.git\" }\nzstd-sys = \"=2.0.9\"\ntokio = { version = \"1\", features = [ \"io-util\", \"fs\", \"net\", \"time\", \"rt\", \"macros\"] }\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module with External Function Import\nDESCRIPTION: Example of a simple WebAssembly module in WAT format that imports an external addition function and exposes an 'addTwo' function that calls the imported function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_69\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge_Process Pre-registration\nDESCRIPTION: Shows how to enable WasmEdge_Process support for Rust sources by configuring and initializing the process module through the configuration context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration or the plugin load failed.\n */\nWasmEdge_ModuleInstanceContext *ProcModule =\n    WasmEdge_VMGetImportModuleContext(\n        VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);\n/* Initialize the WasmEdge_Process. */\nWasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Setting up Client-side Hydration\nDESCRIPTION: Modified React entry point code to support client-side hydration for SSR.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nReactDOM.hydrate(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository from GitHub\nDESCRIPTION: Commands to download the WasmEdge source code from GitHub repository and navigate to the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/windows.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge TensorFlow Inference Application\nDESCRIPTION: Commands to build the Go host application and run the WebAssembly function for image inference using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/ai.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n./tflite_food rust_tflite_food_lib.wasm food.jpg\n```\n\n----------------------------------------\n\nTITLE: Configuring Cost Table and Limits for Execution in Go\nDESCRIPTION: Example of setting a custom cost table for instructions and a cost execution limit to monitor and potentially restrict WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0,\n}\n// Developers can set the costs of each instruction. The value not covered will be 0.\n\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\n\n// ... After running the WASM functions with the `Statistics` object\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Host Data Example\nDESCRIPTION: Command-line instructions for building and running the host data example using the WasmEdge Go SDK. This shows the installation of the SDK dependency and execution of the compiled binary with host data interaction.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_78\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Project with Go Mod\nDESCRIPTION: Creates a new Go project and initializes it with Go modules. The `mkdir` and `cd` commands create and move into a new directory `wasmedge_test`. The `go mod init` command initializes a new Go module named `wasmedge_test`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Creating Global Type Context in C\nDESCRIPTION: Example of creating and using a Global Type context with F64 value type and variable mutability, showing type and mutability verification.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValTypeGenF64(), WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nbool IsTypeF64 = WasmEdge_ValTypeIsF64(GotValType);\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Function Instance Operations in WasmEdge C API\nDESCRIPTION: Shows how to retrieve function type information from function instances. Function instances represent host functions that can be imported into WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version in Golang\nDESCRIPTION: This snippet shows how to use the WasmEdge-go API to check the version of the installed WasmEdge shared library. It retrieves the full version string as well as individual major, minor, and patch version numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Version Check Implementation\nDESCRIPTION: Code showing how to check the installed WasmEdge shared library version using the Version APIs\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Printing Top-5 Classification Results (Rust)\nDESCRIPTION: Sorts the inference output and prints the top-5 classification results. It iterates through the sorted results and prints the index, class ID, confidence score, and class label from `imagenet_classes::IMAGENET_CLASSES`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet results = sort_results(&output_buffer);\nfor i in 0..5 {\n  println!(\n    \"   {}.) [{}]({:.4}){}\",\n    i + 1,\n    results[i].0,\n    results[i].1,\n    imagenet_classes::IMAGENET_CLASSES[results[i].0]\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a WASI Module Instance in WasmEdge with Go\nDESCRIPTION: Code snippet demonstrating how to create and initialize a WASI module instance using the WasmEdge Go SDK. This module provides system interface capabilities to WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_65\n\nLANGUAGE: go\nCODE:\n```\nwasiobj := wasmedge.NewWasiModule(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n```\n\n----------------------------------------\n\nTITLE: Memory Page Configuration in C\nDESCRIPTION: Demonstrates configuring maximum memory pages in WasmEdge, used to limit memory instance sizes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Project\nDESCRIPTION: Commands to build and run the WasmEdge Go project, demonstrating the execution of a Fibonacci function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\n$ go build\n$ ./wasmedge_test\nExported function name: fib\n[2021-11-24 18:53:01.451] [debug]  Execution succeeded.\n[2021-11-24 18:53:01.452] [debug]\n ====================  Statistics  ====================\n Total execution time: 556372295 ns\n Wasm instructions execution time: 556372295 ns\n Host functions execution time: 0 ns\n Executed wasm instructions count: 28271634\n Gas costs: 0\n Instructions per second: 50814237\nGet fibonacci[30]: 1346269\n```\n\n----------------------------------------\n\nTITLE: Installing and Building WasmEdge-go in Go\nDESCRIPTION: Commands to install the WasmEdge-go package and build it in the Go project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\ngo build\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in WasmEdge\nDESCRIPTION: Example showing how to limit the maximum memory page size in WasmEdge. This configuration affects memory growth operations in WASM execution and is effective in Executor and VM objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\npagesize := conf.GetMaxMemoryPage()\n// By default, the maximum memory page size in each memory instances is 65536.\nconf.SetMaxMemoryPage(1234)\npagesize = conf.GetMaxMemoryPage()\n// `pagesize` will be 1234.\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Setting up Complete Development Environment\nDESCRIPTION: Complete setup commands including Go version check, WasmEdge installation, Go SDK installation, and WasmEdge-bindgen tool installation for handling complex data passing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/install.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n\n# Install WasmEdge\n$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}\n\n# Install WasmEdge-Go\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\n\n# Install the WasmEdge-bindgen tool, which helps us handle complex data passing\n$ go get github.com/second-state/wasmedge-bindgen@v0.4.1\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous HTTP GET Request with Fetch\nDESCRIPTION: JavaScript code demonstrating an asynchronous HTTP GET request using the fetch API. The example sends a request to httpbin.org and prints the response text.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function test_fetch() {\n  try {\n    let r = await fetch('http://httpbin.org/get?id=1');\n    print('test_fetch\\n', await r.text());\n  } catch (e) {\n    print(e);\n  }\n}\ntest_fetch();\n```\n\n----------------------------------------\n\nTITLE: Finding Plugin Context by Name\nDESCRIPTION: Method to retrieve a plugin context by providing its name. Returns an Option containing the Plugin if found.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn find(name: impl AsRef<str>) -> Option<Plugin>\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge Strings\nDESCRIPTION: Demonstrates creating WasmEdge_String objects from C strings and buffers. Shows how to properly allocate and deallocate string objects using WasmEdge_StringCreate and WasmEdge_StringDelete functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Managing Store Context in WasmEdge\nDESCRIPTION: Demonstrates store creation, listing registered modules, and finding named modules in the store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_54\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nconst WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_StoreFindModule(StoreCxt, ModName);\nWasmEdge_StringDelete(ModName);\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Integration\nDESCRIPTION: Commands for building and executing the Go host application with a WASM module. Shows the expected output format for various function calls.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/embed-wasm-apps-go.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cd rust_bindgen_funcs\ngo build\n./bindgen_funcs rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Retrieving Execution Result Length\nDESCRIPTION: This snippet illustrates how to obtain the number of return values from an asynchronous execution. It waits for the execution to finish before retrieving the length of the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instances from VM Context (Pre-0.12.0)\nDESCRIPTION: Example of retrieving module instances from the VM context before version 0.12.0, using WasmEdge_HostRegistration values and store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n/* Add the WASI-Crypto related configurations. */\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(Conf,\n                                      WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\n/* Add the WASI configurations. */\nWasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\n/* Get the WASI module instance. */\nWasmEdge_ModuleInstance *WASIModInst =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Get the WASI-crypto-common module instance. */\nWasmEdge_ModuleInstance *WASICryptoCommonModInst =\n    WasmEdge_VMGetImportModuleContext(\n        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\n\n/* Get the registered module instance by name. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\nWasmEdge_String ModName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_crypto_kx\");\nconst WasmEdge_ModuleInstance *WASICryptoKxModInst =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format (WAT) code defining a recursive Fibonacci function. This function is exported as 'fib' and takes an i32 parameter, returning an i32 result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_29\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n (export \"fib\" (func $fib))\n (func $fib (param $n i32) (result i32)\n  (if\n   (i32.lt_s (get_local $n)(i32.const 2))\n   (return (i32.const 1))\n  )\n  (return\n   (i32.add\n    (call $fib (i32.sub (get_local $n)(i32.const 2)))\n    (call $fib (i32.sub (get_local $n)(i32.const 1)))\n   )\n  )\n )\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function (Pre-0.11.0)\nDESCRIPTION: Example of a host function that accesses memory using the memory instance context in WasmEdge versions prior to 0.11.0. This approach directly uses the memory instance passed as an argument.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WASM Limit Structures in Go\nDESCRIPTION: Demonstrates creating and using Limit structures for defining minimum and maximum values, including support for shared memory in thread proposal.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\nLANGUAGE: go\nCODE:\n```\nlim3 := wasmedge.NewLimitShared(20)\nfmt.Println(lim3.HasMax())\n// Will print `false`.\nfmt.Println(lim3.IsShared())\n// Will print `true`.\nfmt.Println(lim3.GetMin())\n// Will print `20`.\n\nlim4 := wasmedge.NewLimitSharedWithMax(30, 40)\nfmt.Println(lim4.HasMax())\n// Will print `true`.\nfmt.Println(lim4.IsShared())\n// Will print `true`.\nfmt.Println(lim4.GetMin())\n// Will print `30`.\nfmt.Println(lim4.GetMax())\n// Will print `40`.\n```\n\n----------------------------------------\n\nTITLE: Handling Async Operations in WasmEdge Go\nDESCRIPTION: Shows how to work with asynchronous execution results and implement timeout handling in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge QuickJS with Modules Directory\nDESCRIPTION: This command demonstrates how to run WasmEdge QuickJS while mapping a host directory to the /modules directory inside the WasmEdge Runtime instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/modules.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime\n```\n\n----------------------------------------\n\nTITLE: Forcing Interpreter Mode in C\nDESCRIPTION: This C code shows how to force WasmEdge to execute WASM files or AOT compiled WASM in interpreter mode. It creates a `WasmEdge_ConfigureContext`, checks the default interpreter setting, enables forced interpreter mode, and checks the setting again to confirm the change.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* By default, The `IsForceInterp` will be `FALSE`. */\nWasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);\nIsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* The `IsForceInterp` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Optimization Levels and Output Formats\nDESCRIPTION: Enumerations defining compiler optimization levels (O0 to Oz) and output binary formats (Native and Wasm) for the WasmEdge AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_81\n\nLANGUAGE: c\nCODE:\n```\n/// AOT compiler optimization level enumeration.\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\n/// AOT compiler output binary format enumeration.\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom sections.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version in C\nDESCRIPTION: This code snippet shows how to use the WasmEdge C API to print the installed version of WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Memory Pages in WasmEdge\nDESCRIPTION: Demonstrates setting and retrieving maximum memory page limits for WebAssembly memory instances in WasmEdge configuration, which restricts memory growth during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Handling Missing WasmEdge Plugins and Error Messages\nDESCRIPTION: Demonstrates error handling for missing plugins and checking for registered modules in the VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/* The following API can retrieve the registered modules in the VM context,\n* includes the built-in WASI and the plug-ins.\n*/\n/*\n* This API will return `NULL` if the module instance is not found.\n*/\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/* The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n* installed, because the VM context will mock and register the host\n* modules.\n*/\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Loading Plug-ins in VM Objects (Post-v0.12.0)\nDESCRIPTION: Example of loading plug-ins in VM objects after version 0.12.0. Plug-ins are automatically loaded, and mocked modules are registered for uninstalled plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nmodulelist := vm.ListRegisteredModule()\nfor _, name := range modulelist {\n  fmt.Println(name)\n}\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Building Wasm from Rust Source Code\nDESCRIPTION: This snippet uses Cargo to compile a Rust project into the WASM format, targeting wasm32-wasip1. It sets the stage for utilizing OpenVINO with WasmEdge for inference tasks. Dependency: Cargo.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Plug-in Interface in WIT\nDESCRIPTION: Example of a WasmEdge plug-in interface definition using the Web Interface Type (WIT) format. It defines three functions: imdecode, imshow, and waitkey.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_0\n\nLANGUAGE: wit\nCODE:\n```\nimdecode: func(buf: list<u8>) -> u32\nimshow: func(window-name: string, mat-key: u32) -> unit\nwaitkey: func(delay: u32) -> unit\n```\n\n----------------------------------------\n\nTITLE: Testing Encrypt and Decrypt UDFs in libSQL\nDESCRIPTION: SQL commands to create a table, insert encrypted values, and test decryption with correct and incorrect passwords.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/libsql.md#2025-04-21_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE secrets(secret);\nINSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));\nINSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));\nINSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));\n\nSELECT secret, decrypt(secret, 'wrong-pass') from secrets;\nSELECT secret, decrypt(secret, 's3cretp4ss') from secrets;\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Output Formats in Go for WasmEdge\nDESCRIPTION: This code snippet defines constants for compiler output formats in WasmEdge. It includes options for native dynamic library format and WebAssembly with AOT compiled codes in custom section.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_82\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded WasmEdge Plugins\nDESCRIPTION: Example code showing how to list all currently loaded plugins and their names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"Plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Statistics Options in WasmEdge with Go\nDESCRIPTION: This snippet shows how to configure statistics options in WasmEdge using Go, focusing on instruction counting, cost measuring, and time measuring during runtime and AOT compilation. It requires the WasmEdge Go SDK for implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsInstructionCounting(true)\n// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsTimeMeasuring(true)\n// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsCostMeasuring(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Fibonacci Example Without Run Command\nDESCRIPTION: Demonstrates executing a WebAssembly fibonacci module using the standard wasmedge command with reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/run.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --reactor fibonacci.wasm fib 10\n```\n\n----------------------------------------\n\nTITLE: Building a Simple HTTP Client with WasmEdge Rust\nDESCRIPTION: This code demonstrates how to build a simple HTTP client using TCP sockets in Rust. It utilizes the wasmedge_http_req crate to perform both GET and POST requests, handling the response and presenting the status, headers, and body. Dependencies include the wasmedge_http_req crate.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/socket_networking/client.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_http_req::request;\n\nfn main() {\n  let mut writer = Vec::new(); //container for body of a response\n  let res = request::get(\"http://127.0.0.1:1234/get\", &mut writer).unwrap();\n\n  println!(\"GET\");\n  println!(\"Status: {} {}\", res.status_code(), res.reason());\n  println!(\"Headers {}\", res.headers());\n  println!(\"{}\", String::from_utf8_lossy(&writer));\n\n  let mut writer = Vec::new(); //container for body of a response\n  const BODY: &[u8; 27] = b\"field1=value1&field2=value2\";\n  // let res = request::post(\"https://httpbin.org/post\", BODY, &mut writer).unwrap();\n  // no https , no dns\n  let res = request::post(\"http://127.0.0.1:1234/post\", BODY, &mut writer).unwrap();\n\n  println!(\"POST\");\n  println!(\"Status: {} {}\", res.status_code(), res.reason());\n  println!(\"Headers {}\", res.headers());\n  println!(\"{}\", String::from_utf8_lossy(&writer));\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge_wasi_socket.git\ncd wasmedge_wasi_socket/http_client/\n\n# Build the Rust Code\ncargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/http_client.wasm http_client.wasm\n\n# Run the example\nwasmedge http_client.wasm\n```\n\n----------------------------------------\n\nTITLE: Configuring CRI-O Main Configuration for crun\nDESCRIPTION: Configuration for the main CRI-O config file to set crun as the default runtime. This is added to /etc/crio/crio.conf to change the default runtime from runc to crun.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n[crio.runtime]\ndefault_runtime = \"crun\"\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Table Type Context in Go\nDESCRIPTION: Examples of creating and managing table type contexts for WASM table instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Timeout Handling in WasmEdge Asynchronous Execution (C)\nDESCRIPTION: This C snippet shows how to handle timeouts during asynchronous execution with the WasmEdge API. If the execution extends beyond one second, it can be canceled. Dependencies: WasmEdge C library. Inputs: Async object and timeout. Outputs: Execution result or interrupted state.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in Go\nDESCRIPTION: Demonstrates registering an existing Module instance into the store with an exported module name. Used for host function modules that need to be registered for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod := wasmedge.NewModule(\"mod\")\n\nres := executor.RegisterImport(store, mod)\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plug-ins from Specific Path in Go\nDESCRIPTION: Shows how to load a WasmEdge plug-in from a specific file path using the LoadPluginFromPath function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginFromPath(\"PATH_TO_PLUGIN/plugin.so\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Rust Interface for a WasmEdge Plugin\nDESCRIPTION: Example of creating a Rust library that provides a Rust interface to a WasmEdge plugin. This code shows how to wrap the wasmedge-image plugin functionality in a Rust-friendly API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/best_practice.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// lib.rs\nextern crate wasmedge_image;\n\nuse wasmedge_image::Image;\n\npub fn load_image(path: &str) -> Result<Image, wasmedge_image::Error> {\nImage::open(path)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Registration in Go\nDESCRIPTION: Example of enabling host module registrations, such as WASI, in the WasmEdge configuration for use with a VM instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.WASI)\nconf.AddConfig(wasmedge.WASI)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application\nDESCRIPTION: Bash commands to fetch the WasmEdge Go SDK, build the Go application, and run the compiled binary to execute the Fibonacci WASM function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n$ go build\n$ ./wasmedge_test\nGet fibonacci[21]: 17711\n```\n\n----------------------------------------\n\nTITLE: Running TensorFlow Lite Example in WasmEdge Docker\nDESCRIPTION: Example demonstrating how to run a TensorFlow Lite model for food classification using the wasmedge/slim-tf Docker image. The example includes downloading necessary files and running a JavaScript-based TensorFlow Lite inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/docker-slim.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js\nlabel:\nHot dog\nconfidence:\n0.8941176470588236\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for WasmEdge Plug-in Build\nDESCRIPTION: CMake configuration for building a WasmEdge plug-in as a shared library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nwasmedge_add_library(wasmedgePluginTest\n  SHARED\n  testplugin.cpp\n)\n\ntarget_compile_options(wasmedgePluginTest\n  PUBLIC\n  -DWASMEDGE_PLUGIN\n)\n\ntarget_include_directories(wasmedgePluginTest\n  PUBLIC\n  $<TARGET_PROPERTY:wasmedgePlugin,INCLUDE_DIRECTORIES>\n  ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\nif(WASMEDGE_LINK_PLUGINS_STATIC)\n  target_link_libraries(wasmedgePluginTest\n    PRIVATE\n    wasmedgeCAPI\n  )\nelse()\n  target_link_libraries(wasmedgePluginTest\n    PRIVATE\n    wasmedge_shared\n  )\nendif()\n\ninstall(TARGETS wasmedgePluginTest DESTINATION ${CMAKE_INSTALL_LIBDIR}/wasmedge)\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Host Registrations in C\nDESCRIPTION: This C code defines the `WasmEdge_HostRegistration` enum, which lists available host registrations, such as `WasmEdge_HostRegistration_Wasi`.  These registrations are used by the VM context to enable built-in host functions and are only effective in VM contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\n```c\nenum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Performing CRUD Operations with PostgreSQL (Rust)\nDESCRIPTION: This snippet demonstrates basic CRUD operations on a PostgreSQL database using the `tokio-postgres` crate. It connects to the database, creates a table, inserts data, queries data, and finally deletes all data from the table. It requires the `tokio` runtime and the `tokio_postgres` crate.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/postgres_driver.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<(), Error> {\n    // Connect to the database.\n    let (client, connection) = tokio_postgres::connect(&*get_url(), NoTls).await?;\n\n    // The connection object performs the actual communication with the database,\n    // so spawn it off to run on its own.\n    tokio::spawn(async move {\n        if let Err(e) = connection.await {\n            eprintln!(\"connection error: {}\", e);\n        }\n    });\n\n    client.execute(\"CREATE TABLE IF NOT EXISTS orders (order_id INT, production_id INT, quantity INT, amount REAL, shipping REAL, tax REAL, shipping_address VARCHAR(256));\", &[]).await?;\n\n    let orders = vec![\n        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(\"Mataderos 2312\")),\n        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(\"1234 NW Bobcat\")),\n        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(\"20 Havelock\")),\n        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(\"224 Pandan Loop\")),\n        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(\"No.10 Jalan Besar\")),\n    ];\n\n    for order in orders.iter() {\n        client.execute(\n            \"INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address) VALUES ($1, $2, $3, $4, $5, $6, $7)\",\n            &[&order.order_id, &order.production_id, &order.quantity, &order.amount, &order.shipping, &order.tax, &order.shipping_address]\n        ).await?;\n    }\n\n    let rows = client.query(\"SELECT * FROM orders;\", &[]).await?;\n    for row in rows.iter() {\n        let order_id : i32 = row.get(0);\n        println!(\"order_id {}\", order_id);\n\n        let production_id : i32 = row.get(1);\n        println!(\"production_id {}\", production_id);\n\n        let quantity : i32 = row.get(2);\n        println!(\"quantity {}\", quantity);\n\n        let amount : f32 = row.get(3);\n        println!(\"amount {}\", amount);\n\n        let shipping : f32 = row.get(4);\n        println!(\"shipping {}\", shipping);\n\n        let tax : f32 = row.get(5);\n        println!(\"tax {}\", tax);\n\n        let shipping_address : &str = row.get(6);\n        println!(\"shipping_address {}\", shipping_address);\n    }\n\n    client.execute(\"DELETE FROM orders;\", &[]).await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Memory Type Context in WasmEdge\nDESCRIPTION: Example of creating a Memory Type context with specific limits and retrieving the limit information. Memory Type contexts are used for Memory instance creation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n/* `GotMemLim` will be the same value as `MemLim`. */\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Building WASM bytecode from Rust via Cargo\nDESCRIPTION: This snippet demonstrates how to build a WASM bytecode from a Rust application using the Cargo command line tool. The command specifies the target platform as wasm32-wasip1 and sets the build configuration to release.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Building Rust WebAssembly Module for Image Processing\nDESCRIPTION: Commands to build the Rust image processing program into WebAssembly bytecode and copy the artifact to the appropriate folder.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd api/functions/image-grayscale/\ncargo build --release --target wasm32-wasip1\ncp target/wasm32-wasip1/release/grayscale.wasm ../../\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go SDK Examples\nDESCRIPTION: Shell commands for building and running the WasmEdge Go SDK examples. Shows how to get the SDK dependency and build the application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_72\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Execution\nDESCRIPTION: Demonstrates how to asynchronously execute a WASM function using WasmEdge-go SDK. The example calculates the 20th Fibonacci number using a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge CLI Tools from Go\nDESCRIPTION: Examples showing how to trigger the WasmEdge and WasmEdge AOT compiler CLI tools directly from Go code. The API arguments are passed in the same way as command line arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeCLI(os.Args)\n}\n```\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Contexts\nDESCRIPTION: Shows how to create and delete WasmEdge contexts, which are fundamental to managing VM, Store, and Function objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Function Instance Type Retrieval in C\nDESCRIPTION: Shows how to retrieve the function type from a function instance context. This is useful for inspecting function signatures at runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel for React and ES6\nDESCRIPTION: Babel configuration file to enable transpilation of React and modern JavaScript syntax.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Default Paths\nDESCRIPTION: Demonstrates how to load WasmEdge plugins from default system paths using the C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge C API Test Program (Bash)\nDESCRIPTION: Command to compile the test C program using gcc, linking against the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngcc test.c -lwasmedge\n```\n\n----------------------------------------\n\nTITLE: Creating VM with External Store Context in C\nDESCRIPTION: Shows how to create a VM context with an externally managed Store context. The developer must ensure the Store's lifecycle extends beyond the VM's usage.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Go-WasmEdge Example\nDESCRIPTION: Command-line instructions for building and running the example Go application using WasmEdge Go SDK. This shows the installation of the SDK dependency and execution of the compiled binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_76\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Building Encrypt/Decrypt Wasm Example\nDESCRIPTION: Commands to clone and build the encrypt/decrypt example targeting wasm32-wasip1 platform.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/libsql/libsql_bindgen\ncd libsql_bindgen/examples/encrypt_decrypt\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Definition\nDESCRIPTION: Example WebAssembly module definition in WAT format showing import function declaration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_68\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32)))\n  (import \"extern\" \"trap\" (func $f-trap (type $t0)))\n  (func (export \"trap\") (param i32)\n    local.get 0\n    call $f-trap))\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Go Host Application\nDESCRIPTION: These bash commands demonstrate how to build the Go application and run it with the compiled WebAssembly module as an argument.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/bindgen.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Annotating a Rust Function for WebAssembly Compilation with wasmedge-bindgen\nDESCRIPTION: This snippet demonstrates how to use the wasmedge_bindgen macro to annotate a Rust function for WebAssembly compilation. The function takes a String parameter and returns a Result with a Vec<u8>, which are automatically converted to WebAssembly-compatible types by the bindgen process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/bindgen.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> Result<Vec<u8>, String> {\n  let r = String::from(\"hello \");\n  return Ok((r + s.as_str()).as_bytes().to_vec());\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instruction Count from Statistics - C\nDESCRIPTION: This snippet retrieves the instruction count and performance metrics from a Statistics context in order to analyze the performance of WASM executions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Getting Plugin Module Names\nDESCRIPTION: Method to retrieve all module names available in a plugin as a vector of strings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub fn mod_names(&self) -> Vec<String>\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: Commands to clone the demo project, build the WebAssembly bytecode file using Cargo, and copy the resulting WASM file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/wasm-app-in-rust.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_bindgen_funcs\ncargo build --target wasm32-wasip1 --release\ncp target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm ../\ncd ../\n```\n\n----------------------------------------\n\nTITLE: Listing and Finding Exports in Module Instances in C\nDESCRIPTION: Demonstrates how to list all exported functions in a module instance and find a specific exported function by name. The code first gets the count of exported functions, then lists them by name, and finally shows how to find a specific function by its name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\n/*\n* ...\n* Instantiate a WASM module via the executor context and get the `ModCxt` as the output module instance.\n*/\n\n/* Try to list the exported instance of the instantiated WASM module. */\n/* Take the function instances for example here. */\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\n/* If the list length is larger than the buffer length, the overflowed data will be discarded. */\nuint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\n/* Try to find the exported instance of the instantiated WASM module. */\n/* Take the function instances for example here. */\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n/* `FuncCxt` will be `NULL` if the function not found. */\n/* The returned instance is owned by the module instance context and should __NOT__ be destroyed. */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in Go\nDESCRIPTION: This snippet defines compiler optimization levels and output formats for AOT compilation. It showcases how to set these configurations in the `Configure` object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n\nconf := wasmedge.NewConfigure()\n\n// By default, the optimization level is O3.\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n// By default, the output format is universal WASM.\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n// By default, the dump IR is `false`.\nconf.SetCompilerDumpIR(true)\n// By default, the generic binary is `false`.\nconf.SetCompilerGenericBinary(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling C File with WasmEdge\nDESCRIPTION: Shows how to use GCC to compile a C file that utilizes the WasmEdge API. Ensure 'libwasmedge_c' is available during linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngcc test.c -lwasmedge_c\n```\n\n----------------------------------------\n\nTITLE: Triggering Unified WasmEdge CLI in Go\nDESCRIPTION: Illustrates how to use the new RunWasmEdgeUnifiedCLI() function to invoke the unified WasmEdge command-line interface from Go code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nwasmedge.RunWasmEdgeUnifiedCLI()\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposal Enum in C\nDESCRIPTION: Enumerates the supported WebAssembly proposals in WasmEdge. This enum is used to configure which proposals are enabled or disabled in the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  WasmEdge_Proposal_MultiValue,\n  WasmEdge_Proposal_BulkMemoryOperations,\n  WasmEdge_Proposal_ReferenceTypes,\n  WasmEdge_Proposal_SIMD,\n  WasmEdge_Proposal_TailCall,\n  WasmEdge_Proposal_ExtendedConst,\n  WasmEdge_Proposal_FunctionReferences,\n  WasmEdge_Proposal_GC,\n  WasmEdge_Proposal_MultiMemories,\n  WasmEdge_Proposal_Threads,\n  WasmEdge_Proposal_RelaxSIMD,\n  WasmEdge_Proposal_Annotations,\n  WasmEdge_Proposal_Memory64,\n  WasmEdge_Proposal_ExceptionHandling,\n  WasmEdge_Proposal_Component,\n};\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Host Function Example\nDESCRIPTION: Commands to install WasmEdge Go SDK, build the example, and run it, showing the expected output with custom error codes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_66\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\n[2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be\n[2022-08-26 15:06:40.384] [error]     When executing function name: \"trap\"\nGet the error code: 5566\n```\n\n----------------------------------------\n\nTITLE: WASM Module Instantiation - Post v0.10.0\nDESCRIPTION: Updated example showing multiple module instantiation in WasmEdge-Go v0.10.0+. Demonstrates how to handle multiple module instances with proper cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nvar ast1 *wasmedge.AST\nvar ast2 *wasmedge.AST\nmod1, err1 := executor.Instantiate(store, ast1)\nif err1 != nil {\n  fmt.Println(\"Instantiation FAILED:\", err1.Error())\n}\nmod2, err2 := executor.Instantiate(store, ast2)\nif err2 != nil {\n  fmt.Println(\"Instantiation FAILED:\", err2.Error())\n}\nmod1.Release()\nmod2.Release()\n```\n\n----------------------------------------\n\nTITLE: Waiting with Timeout and Canceling in WasmEdge (C)\nDESCRIPTION: This snippet illustrates waiting for an asynchronous execution with a timeout using `WasmEdge_AsyncWaitFor()`. If the timeout is exceeded, the execution can be canceled using `WasmEdge_AsyncCancel()`. The code also shows how to retrieve the result (or an error indicating interruption) after a timeout or cancellation. Note: interruptible execution requires enabling the `WasmEdge_ConfigureCompilerSetInterruptible()` option.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\n```c\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n```\n\n----------------------------------------\n\nTITLE: Running TensorFlow Model Session\nDESCRIPTION: This Rust snippet executes the prepared TensorFlow session, processing the inputs through the model to obtain outputs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nsession.run();\n```\n\n----------------------------------------\n\nTITLE: WasmEdge String Comparison\nDESCRIPTION: Demonstrates how to compare WasmEdge_String objects using WasmEdge_StringIsEqual function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"abcd\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Using Imported Host Function\nDESCRIPTION: A simple WebAssembly module (in text format) that imports a function named \"func-add\" from the \"extern\" module and exports a function \"addTwo\" that calls the imported function with its parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_61\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Constants for Optimization Levels\nDESCRIPTION: Constants defining the optimization levels for the WasmEdge AOT (ahead-of-time) compiler. These constants control the trade-off between compilation time, code size, and execution performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Simple HTTP Client in WasmEdge\nDESCRIPTION: Bash commands to clone the repository, build the Rust code for wasm32-wasip1 target, compile with WasmEdge AoT compiler, and run the HTTP client example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/client.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge_wasi_socket.git\ncd wasmedge_wasi_socket/http_client/\n\n# Build the Rust Code\ncargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/http_client.wasm http_client.wasm\n\n# Run the example\nwasmedge http_client.wasm\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx with WASM Module (Rust Version)\nDESCRIPTION: Nginx configuration to load and execute a WASM file compiled from Rust, injecting a custom response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/wasm-nginx.md#2025-04-21_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nworker_processes  1;\n\nerror_log  /tmp/error.log warn;\n\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    wasm_vm wasmedge;\n    init_by_lua_block {\n        local wasm = require(\"resty.proxy-wasm\")\n        package.loaded.plugin = assert(wasm.load(\"fault_injection\",\n            \"/path/to/fault-injection/target/wasm32-wasip1/debug/fault_injection.wasm\"))\n    }\n    server {\n        listen 1980;\n        location / {\n            content_by_lua_block {\n                local wasm = require(\"resty.proxy-wasm\")\n                local ctx = assert(wasm.on_configure(package.loaded.plugin,\n                    '{\"http_status\": 403, \"body\": \"powered by wasm-nginx-module\"}'))\n                assert(wasm.on_http_request_headers(ctx))\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Running WebAssembly Container with CRI-O\nDESCRIPTION: Commands to create a pod and container, then run the WebAssembly application using CRI-O. This sequence shows how to create, start, and view logs from a WebAssembly container.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Create the POD. The output will be different from the example.\n$ sudo crictl runp sandbox_config.json\n7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4\n# Set a helper variable for later use.\n$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4\n\n# Create the container instance. The output will be different from the example.\n$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json\n# Set a helper variable for later use.\nCONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Global Types in Go\nDESCRIPTION: Demonstrates creating and managing global type contexts for WebAssembly global instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Reference Type Handling\nDESCRIPTION: Code demonstrating creation and manipulation of function and external references in WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\\nvoid *Ptr;\\nbool IsNull;\\nuint32_t Num = 10;\\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\\nIsNull = WasmEdge_ValueIsNullRef(Val);\\nPtr = WasmEdge_ValueGetExternRef(Val);\\nVal = WasmEdge_ValueGenExternRef(&Num);\\nPtr = WasmEdge_ValueGetExternRef(Val);\\nprintf(\"%u\\\\n\", *(uint32_t *)Ptr);\n```\n\n----------------------------------------\n\nTITLE: WASI Initialization with WasmEdge-Go v0.9.2\nDESCRIPTION: Example showing how to initialize WASI using WasmEdge-Go v0.9.2 API, demonstrating ImportObject usage and WASI configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasiobj := vm.GetImportObject(wasmedge.WASI)\n// Initialize the WASI.\nwasiobj.InitWasi(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:.\"}, // The mapping preopens\n)\n\n// ...\n\nvm.Release()\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Value Types in C API\nDESCRIPTION: Illustrates how to use WasmEdge_Value APIs to work with WASM value types such as i32, i64, etc. Includes value generation and retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \"123456\" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \"1234567890123\" */\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \"123.456001\" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \"123456.1234567890\" */\n```\n\n----------------------------------------\n\nTITLE: WasmEdge VM Context Lifecycle Diagram\nDESCRIPTION: ASCII diagram illustrating the lifecycle and state transitions of a WasmEdge VM context. It shows the different states (Initiated, Loaded, Validated, Instantiated) and the operations that trigger transitions between these states.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_32\n\nLANGUAGE: text\nCODE:\n```\n                         |========================|\n                |------->|      VM: Initiated     |\n                |        |========================|\n                |                    |\n                |                 LoadWasm\n                |                    |\n                |                    v\n                |        |========================|\n                |--------|       VM: Loaded       |<-------|\n                |        |========================|        |\n                |              |            ^              |\n                |         Validate          |              |\n            Cleanup            |          LoadWasm         |\n                |              v            |            LoadWasm\n                |        |========================|        |\n                |--------|      VM: Validated     |        |\n                |        |========================|        |\n                |              |            ^              |\n                |      Instantiate          |              |\n                |              |          RegisterModule   |\n                |              v            |              |\n                |        |========================|        |\n                |--------|    VM: Instantiated    |--------|\n                         |========================|\n                               |            ^\n                               |            |\n                               --------------\n                  Instantiate, Execute, ExecuteRegistered\n```\n\n----------------------------------------\n\nTITLE: Editing Build Script for Reduced Parallelization\nDESCRIPTION: Command to open the build script for editing, with instruction to modify the ninja command to limit parallelization.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvi build.sh\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugin from Specific Path\nDESCRIPTION: Example showing how to load a WasmEdge plugin from a specific path, allowing developers to use custom plugin locations outside of the default plugin directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_73\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginFromPath(\"PATH_TO_PLUGIN/plugin.so\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Workspace Membership in Cargo.toml\nDESCRIPTION: Adding the new server-wasmedge crate to the workspace configuration in the root Cargo.toml file\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n\"examples/isomorphic/server-wasmedge\"\n```\n\n----------------------------------------\n\nTITLE: Managing Store Context in Go WasmEdge\nDESCRIPTION: Demonstrates using the Store object to manage WASM runtime state, including listing registered modules and finding modules by name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_53\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\n\nmodnames := store.ListModule()\n\nmod := store.FindModule(\"module\")\n\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: Initializing Execution Context in Rust\nDESCRIPTION: Rust code for creating an execution context from the loaded Graph for model inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n // initialize the execution context\n    let mut context = graph\n        .init_execution_context()\n        .expect(\"Failed to init context\");\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C Programs\nDESCRIPTION: Commands for compiling C programs with WasmEdge library and executing the resulting binary to calculate Fibonacci numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Options in C\nDESCRIPTION: This C code defines the `WasmEdge_CompilerOptimizationLevel` and `WasmEdge_CompilerOutputFormat` enums. These enums are used to configure the behavior of the WasmEdge AOT compiler, including optimization level (O0 to Oz) and output format (Native or Wasm).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n```c\nenum WasmEdge_CompilerOptimizationLevel {\n  // Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  // Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  // Optimize for fast execution as much as possible without triggering\n  // significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  // Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  // Optimize for small code size as much as possible without triggering\n  // significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  // Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n  // Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  // WebAssembly with AOT compiled codes in custom section.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Running RustPython with WasmEdge\nDESCRIPTION: Executes the compiled RustPython WebAssembly module using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/python/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge ./target/wasm32-wasip1/release/rustpython.wasm\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema Structure in Rust\nDESCRIPTION: Implementation of a Rust struct representing the database table schema for orders with constructor method.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/postgres_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Order {\n    order_id: i32,\n    production_id: i32,\n    quantity: i32,\n    amount: f32,\n    shipping: f32,\n    tax: f32,\n    shipping_address: String,\n}\n\nimpl Order {\n    fn new(\n        order_id: i32,\n        production_id: i32,\n        quantity: i32,\n        amount: f32,\n        shipping: f32,\n        tax: f32,\n        shipping_address: String,\n    ) -> Self {\n        Self {\n            order_id,\n            production_id,\n            quantity,\n            amount,\n            shipping,\n            tax,\n            shipping_address,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration in Go\nDESCRIPTION: Example of registering host modules into a WasmEdge VM instance using Go, demonstrating WASI module registration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)\n\nres := vm.RegisterImport(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Downloading and Compiling WasmEdge QuickJS Runtime\nDESCRIPTION: Download the pre-built WasmEdge QuickJS Runtime WebAssembly file and compile it for better performance using the WasmEdge AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\nwasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm\n```\n\n----------------------------------------\n\nTITLE: Plugin Implementation File\nDESCRIPTION: C++ source file containing module creation functions, plugin descriptions and registration implementation\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"testplugin.h\"\n\nnamespace WasmEdge {\nnamespace Host {\nnamespace {\n\nRuntime::Instance::ModuleInstance *\ncreate(const Plugin::PluginModule::ModuleDescriptor *) noexcept {\n  return new WasmEdgePluginTestModule;\n}\n\nPlugin::Plugin::PluginDescriptor Descriptor{\n    .Name = \"wasmedge_plugintest_cpp\",\n    .Description = \"\",\n    .APIVersion = Plugin::Plugin::CurrentAPIVersion,\n    .Version = {0, 10, 0, 0},\n    .ModuleCount = 1,\n    .ModuleDescriptions =\n        (Plugin::PluginModule::ModuleDescriptor[]){\n            {\n                .Name = \"wasmedge_plugintest_cpp_module\",\n                .Description = \"This is for the plugin tests in WasmEdge.\",\n                .Create = create,\n            },\n        },\n    .AddOptions = nullptr,\n};\n\n} // namespace\n\nPlugin::PluginRegister WasmEdgePluginTestEnv::Register(&Descriptor);\n\n} // namespace Host\n} // namespace WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Export Type Context Usage in C\nDESCRIPTION: Demonstrates Export Type context handling for WASM module exports. Shows how to query export information including external types and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: Rust: Redis Client with Timestamp Operations\nDESCRIPTION: Asynchronous Rust function that connects to a Redis server, sets the current timestamp as a key, retrieves it, and prints the value\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/redis_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<()> {\n    // connect to redis\n    let client = redis::Client::open(&*get_url()).unwrap();\n    let mut con = client.get_multiplexed_async_connection().await.unwrap();\n\n    let time = format!(\"{}\", chrono::Utc::now());\n    // throw away the result, just make sure it does not fail\n    let _: () = con.set(\"current_time\", time).await.unwrap();\n\n    // read back the key and return it.  Because the return value\n    // from the function is a result for String, this will automatically\n    // convert into one.\n    let value: String = con.get(\"current_time\").await.unwrap();\n    println!(\"Successfully GET `time`: {}\", value);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Hello World application with WasmEdge CLI\nDESCRIPTION: This command runs the previously built Hello World WASM application using WasmEdge CLI, outputting the string 'Hello WasmEdge' to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge target/wasm32-wasip1/release/hello.wasm\nHello WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Store Object with WasmEdge in Go\nDESCRIPTION: Illustrates how to create a WasmEdge VM with a Store object in Go. It shows how to instantiate the VM directly with a new Store or retrieve it from an existing VM. Provides guidance on resource management and object lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nstore := vm.GetStore()\n// The object should __NOT__ be deleted by calling `(*Store).Release`.\nvm.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvm := wasmedge.NewVMWithStore(store)\n\nstoremock := vm.GetStore()\n// The internal store context of the `store` and the `storemock` are the same.\n\nvm.Release()\nstore.Release()\n\n```\n\n----------------------------------------\n\nTITLE: Defining Plug-in Descriptions for WasmEdge\nDESCRIPTION: C++ code defining the plug-in descriptor and module descriptions for a WasmEdge plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace WasmEdge {\nnamespace Host {\nnamespace {\n\nPlugin::Plugin::PluginDescriptor Descriptor{\n    //Plug-in name - for searching the plug-in context by the\n    // `WasmEdge_PluginFind()` C API.\n    .Name = \"wasmedge_plugintest_cpp\",\n    //Plug-in description.\n    .Description = \"\",\n    //Plug-in API version.\n    .APIVersion = Plugin::Plugin::CurrentAPIVersion,\n    //Plug-in version.\n    .Version = {0, 10, 0, 0},\n    // Module count in this plug-in.\n    .ModuleCount = 1,\n    // Pointer to module description array.\n    .ModuleDescriptions =\n        // The module descriptor array.\n        (Plugin::PluginModule::ModuleDescriptor[]){\n            {\n                // Module name. This is the name for searching and creating the\n                // module instance context by the\n                // `WasmEdge_PluginCreateModule()` C API.\n                .Name = \"wasmedge_plugintest_cpp_module\",\n                // Module description.\n                .Description = \"This is for the plugin tests in WasmEdge.\",\n                // Creation function pointer.\n                .Create = create,\n            },\n        },\n    //Plug-in options (Work in progress).\n    .AddOptions = nullptr,\n};\n\n} // namespace\n} // namespace Host\n} // namespace WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Memory Type Context in C\nDESCRIPTION: Illustrates the creation and usage of a Memory Type context in WasmEdge. It shows how to set up memory limits and retrieve information from the memory type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n/* `GotMemLim` will be the same value as `MemLim`. */\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Programs\nDESCRIPTION: Shell commands for compiling C programs that use WasmEdge library and running the resulting executables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the '(123 + 456)^2' result: 335241\nGet the '77^2 + 88^2' result: 13673\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Function Types in Go\nDESCRIPTION: Shows how to create and manipulate function type contexts for defining parameter and return value types in WebAssembly functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for Node.js WebAssembly Application\nDESCRIPTION: Configuration for a Docker container running a Node.js application in WebAssembly using WasmEdge QuickJS. This setup includes the necessary runtime and modules to support Node.js APIs in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_6\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-runtime:0.10.1\nADD wasmedge_quickjs.wasm /\nADD http_echo.js /\nADD modules /modules\nCMD [\"wasmedge\", \"--dir\", \".:/\", \"/wasmedge_quickjs.wasm\", \"http_echo.js\"]\n```\n\n----------------------------------------\n\nTITLE: Creating VM with Custom Store Context in WasmEdge C API\nDESCRIPTION: Shows how to create a VM context with a user-created Store context. In this case, the developer is responsible for managing the Store's lifecycle and must delete it after the VM is deleted.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Main Function for Fibonacci Calculator in C\nDESCRIPTION: Main function that takes a command-line argument, calculates the corresponding Fibonacci number, and prints the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n// main.c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"fibonacci.h\"\n\nint main(int argc, char *argv[])\n{\n  if (argc<2) {\n    return 0;\n  }\n  int n = atoi(argv[1]);\n  printf(\"%d\",fib(n));\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using wasmedge-tensorflow-lite in Docker\nDESCRIPTION: Example demonstrating how to use the TensorFlow Lite integration in WasmEdge by downloading a model and running a food classification example using the slim-tf Docker image.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/docker-slim.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js\nlabel:\nHot dog\nconfidence:\n0.8941176470588236\n```\n\n----------------------------------------\n\nTITLE: Configuring Containerd for WasmEdge Support\nDESCRIPTION: This snippet demonstrates configuring containerd to use WasmEdge by modifying the config.toml file for curn support. It downloads a configuration patch and applies it with `patch` command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir -p /etc/containerd/\nsudo bash -c \"containerd config default > /etc/containerd/config.toml\"\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff\nsudo patch -d/ -p0 < containerd_config.diff\n```\n\n----------------------------------------\n\nTITLE: Defining Optimization Levels for WasmEdge AOT Compiler in Go\nDESCRIPTION: Constants defining various optimization levels for the WasmEdge AOT compiler. These levels range from O0 (minimal optimization) to O3 (maximum performance optimization), plus Os and Oz for size optimization. Each constant maps to a C-level WasmEdge optimization enum.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_74\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module with External Function Import Example\nDESCRIPTION: A WebAssembly module in WAT format that imports a function named 'func-add' from an external module 'extern'. The module exports a function 'addTwo' which calls the imported function with two parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_74\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plug-ins from Default Paths in Go\nDESCRIPTION: Demonstrates how to load WasmEdge plug-ins from default paths using the LoadPluginDefaultPaths function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies in Cargo.toml (TOML)\nDESCRIPTION: This snippet shows the configuration required in the `Cargo.toml` file to use `tokio-postgres` and `tokio` with WasmEdge.  It includes patching crates from GitHub repositories and specifying the dependencies along with their features.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/postgres_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\ntokio-postgres = { git = \"https://github.com/second-state/rust-postgres.git\" }\n\n[dependencies]\ntokio-postgres = \"0.7\"\ntokio = { version = \"1\", features = [\n    \"io-util\",\n    \"fs\",\n    \"net\",\n    \"time\",\n    \"rt\",\n    \"macros\",\n] }\n```\n\n----------------------------------------\n\nTITLE: Axum Server Dependencies Configuration\nDESCRIPTION: Cargo.toml configuration for axum server showing required dependencies and patches for WasmEdge compatibility\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\naxum = \"0.6\"\nbytes = \"1\"\nfutures-util = \"0.3.30\"\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\", \"io-util\"]}\n```\n\n----------------------------------------\n\nTITLE: Converting WasmEdge String to C String\nDESCRIPTION: This C code shows how to convert a `WasmEdge_String` object to a C string using `WasmEdge_StringCopy`. It creates a `WasmEdge_String` from a C string and then copies its contents into a buffer. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[256];\nWasmEdge_String Str = WasmEdge_StringCreateByCString(\"test_wasmedge_string\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf(\"String: %s\\n\", Buf);\n/* Will print \"test_wasmedge_string\". */\n```\n\n----------------------------------------\n\nTITLE: Working with Tag Instances in Exception Handling (C)\nDESCRIPTION: Shows how to list and find tag instances in a module, as well as retrieve the tag type from a tag instance. This is only available when the Exception Handling proposal is enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_72\n\nLANGUAGE: c\nCODE:\n```\nuint32_t TagNum = WasmEdge_ModuleInstanceListTagLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String TagNames[BUF_LEN];\nuint32_t RealTagNum = WasmEdge_ModuleInstanceListTag(ModCxt, TagNames, BUF_LEN);\n\nWasmEdge_String TagName = WasmEdge_StringCreateByCString(\"tag-1\");\nWasmEdge_TagInstanceContext *TagCxt =\n    WasmEdge_ModuleInstanceFindTag(ModCxt, TagName);\n\nconst WasmEdge_TagTypeContext *TagTypeCxt =\n    WasmEdge_TagInstanceGetTagType(TagCxt);\n\nWasmEdge_StringDelete(TagName);\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST Object to Anonymous Module in Go\nDESCRIPTION: Demonstrates instantiating a WASM module from an AST object into an anonymous Module instance. This is necessary before invoking functions, and requires ensuring all imports are registered for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\n// ...\n// Assume that the `ast` is the output `*wasmedge.AST` object from the loader\n// and has passed the validation.\n// Assume that the `conf` is the `*wasmedge.Configure` object.\n\n// Create the statistics object. This step is not necessary if the statistics\n// is not needed.\nstat := wasmedge.NewStatistics()\n// Create the executor object.\n// For executor creation with default configuration and without statistics,\n// you can use `wasmedge.NewExecutor()` instead.\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n// Create the store object. The store is the WASM runtime structure core.\nstore := wasmedge.NewStore()\n\n// Instantiate the WASM module.\nmod, err := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN llama.cpp Backend on Linux with CUDA 12\nDESCRIPTION: CMake commands to build WasmEdge with the WASI-NN llama.cpp backend on Linux with CUDA 12 support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\napt update\napt install -y software-properties-common lsb-release \\\n  cmake unzip pkg-config\n\nexport CXXFLAGS=\"-Wno-error\"\nexport CUDAARCHS=\"60;61;70\"\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_CUDA_ARCHITECTURES=\"60;61;70\" \\\n  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly and AOT Compilation\nDESCRIPTION: Commands to compile the Rust code to WebAssembly and perform AOT compilation using WasmEdge for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/ai.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd go_TfliteFood/rust_tflite_food\ncargo build --target wasm32-wasip1 --release\ncp target/wasm32-wasip1/release/rust_tflite_food_lib.wasm ../\ncd ../\nwasmedge compile rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: Bash commands to clone the demo project, build the Rust code into a WebAssembly bytecode file using Cargo, and prepare it for use in a Go host application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/wasm-app-in-rust.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_bindgen_funcs\ncargo build --target wasm32-wasip1 --release\ncp target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm ../\ncd ../\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Module with Name in WasmEdge 0.9.1 (C)\nDESCRIPTION: Example of registering a WASM module with a module name using the WasmEdge_ExecutorRegisterModule API in WasmEdge version 0.9.1.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt;\n/*\n * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\n\n/* Register the WASM module into store with the export module name \"mod\". */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nRes = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);\nWasmEdge_StringDelete(ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Building client-side WebAssembly using bash\nDESCRIPTION: This bash script changes the current directory to the `client` directory and then executes the `./build-wasm.sh` script, which is responsible for building the client-side WebAssembly code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncd client\n./build-wasm.sh\n\n```\n\n----------------------------------------\n\nTITLE: Function Instance Type Retrieval in WasmEdge\nDESCRIPTION: Shows how to retrieve function type information from a function instance context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using V128 Values in Go\nDESCRIPTION: Go code snippet demonstrating how to create and use V128 values for SIMD operations in WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Preparing Input and Output Tensors for Session\nDESCRIPTION: This Rust code configures the input and output tensors for the TensorFlow session, including the setting of input tensor dimensions. It's crucial for running inference on specific model layers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// The flat_img is a vec<f32> which contains normalized image in rgb32f format.\nsession.add_input(\"input\", &flat_img, &[1, 224, 224, 3])\n       .add_output(\"MobilenetV2/Predictions/Softmax\");\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI in WasmEdge 0.10.0 C API\nDESCRIPTION: Updated example of WASI initialization using WasmEdge 0.10.0 C API. It shows the changes required, mainly replacing WasmEdge_ImportObjectContext with WasmEdge_ModuleInstanceContext.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: MIME Type Handler Implementation\nDESCRIPTION: Implementation of MIME type mapping functionality for different file extensions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub struct MimeType {\n    pub r#type: String,\n}\n\nimpl MimeType {\n    pub fn new(r#type: &str) -> Self {\n        MimeType {\n            r#type: r#type.to_string(),\n        }\n    }\n\n    pub fn from_ext(ext: &str) -> Self {\n        match ext {\n            \"html\" => MimeType::new(\"text/html\"),\n            \"css\" => MimeType::new(\"text/css\"),\n            \"map\" => MimeType::new(\"application/json\"),\n            \"js\" => MimeType::new(\"application/javascript\"),\n            \"json\" => MimeType::new(\"application/json\"),\n            \"svg\" => MimeType::new(\"image/svg+xml\"),\n            \"wasm\" => MimeType::new(\"application/wasm\"),\n            _ => MimeType::new(\"text/plain\"),\n        }\n    }\n\n    pub fn get(self) -> String {\n        self.r#type\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AOT Compiler Optimization Levels and Output Formats\nDESCRIPTION: Constants for configuring the AOT compiler's optimization levels (from O0 to Oz) and output formats (native dynamic library or WebAssembly with AOT compiled code in custom section).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WebAssembly in AoT Mode\nDESCRIPTION: Commands to compile WebAssembly to native code using WasmEdge's AoT compiler and then run it for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedgec hello.wasm hello.wasm\n$ wasmedge hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Error Handling in a WasmEdge Plugin Function\nDESCRIPTION: Example of proper error handling in a WasmEdge plugin function. This C function checks for edge cases with input values and returns an error when problematic values are detected.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/best_practice.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                     const WasmEdge_Value *In, WasmEdge_Value *Out) {\n   // Check the input types...\n   int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n   int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n   if (Val1 == INT32_MIN || Val2 == INT32_MIN) {\n   return WasmEdge_Result_Error;\n   }\n   // Rest of the function...\n}\n```\n\n----------------------------------------\n\nTITLE: Running a WebAssembly HTTP server with containerd\nDESCRIPTION: Commands to pull and run a WebAssembly-based HTTP server container image using containerd and crun, with network host mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo ctr i pull docker.io/wasmedge/example-wasi-http:latest\n\nsudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi-http:latest http-server-example /http_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating Function Types with WasmEdge_ValType in C (0.14.0)\nDESCRIPTION: Updated example of creating a function type using new WasmEdge_ValType APIs in WasmEdge 0.14.0. This approach replaces the enum-based method from 0.13.5.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: These bash commands clone the example repository and compile the Rust code to WebAssembly using the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/bindgen.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_bindgen_funcs\n$cargo build --release --target wasm32-wasip1\n# The output WASM will be target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Image Loading Example in Rust\nDESCRIPTION: Example code demonstrating how to load and process an image file\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet mut file_img = File::open(\"sample.jpg\").unwrap();\nlet mut img_buf = Vec::new();\nfile_img.read_to_end(&mut img_buf).unwrap();\nlet flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb32f(&img_buf, 224, 224);\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running Node.js Apps in WasmEdge QuickJS\nDESCRIPTION: This bash script demonstrates how to clone the wasmedge-quickjs repository, set up the necessary environment, download the runtime, and run a Node.js application using WasmEdge. The script ensures that the modules directory is accessible to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/nodejs.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Clone the wasmedge-quickjs\ngit clone https://github.com/second-state/wasmedge-quickjs\n# Use the wasmedge-quickjs directory as the working directory for modules access\ncd wasmedge-quickjs\n# Download a released WasmEdge QuickJS runtime\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\n# Copy the nodejs project to the current working directory and run the nodejs app\ncp -r /path/to/my_node_app .\nwasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js\n```\n\n----------------------------------------\n\nTITLE: Legacy Value Type Usage in WasmEdge-Go v0.13.5\nDESCRIPTION: Example showing how value types and reference types were used with function and table type APIs in WasmEdge-Go v0.13.5 using constant values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i64, funcref} -> {f32}\nfunctype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{\n        wasmedge.ValType_I32,\n        wasmedge.ValType_I64,\n        wasmedge.ValType_FuncRef,\n    },\n    []wasmedge.ValType{\n        wasmedge.ValType_F32,\n    })\n\n// Get the parameter types\nvar ptypes []wasmedge.ValType = functype.GetParameters()\nif ptypes[0] == wasmedge.ValType_I32 {\n    // This will be true here.\n    // ...\n} \nfunctype.Release()\n\n// Create a table type: {min: 1}, externref\nlim := wasmedge.NewLimit(1)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\n// Get the reference type\nif tabtype.GetRefType() == wasmedge.RefType_ExternRef {\n    // This will be true here.\n    // ...\n}\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Using Export Type Context in C\nDESCRIPTION: Demonstrates the usage of an Export Type context in WasmEdge to retrieve information about exports from an AST Module. It shows how to query external types, names, and specific type contexts based on the external type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/*\n * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the\n * result of loading a WASM file.\n */\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\n/*\n * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,\n * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or\n * `WasmEdge_ExternalType_Global`.\n */\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\n/*\n * The `ExtName` should not be destroyed and the string buffer is binded\n * into the `ASTCxt`.\n */\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the\n * `FuncTypeCxt` will be NULL.\n */\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`\n * will be NULL.\n */\n```\n\n----------------------------------------\n\nTITLE: New Plugin Module Creation (v0.12.0+)\nDESCRIPTION: Example showing how to create plugin module instances using the new Plugin struct and general API in v0.12.0+.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\ncryptoplugin := wasmedge.FindPlugin(\"wasi_crypto\")\nif ctyptoplugin == nil {\n  fmt.Println(\"FAIL: Cannot find the wasi_crypto plugin.\")\n  return\n}\n\ncryptocommonmod := cryptoplugin.CreateModule(\"wasi_crypto_common\")\n\ncryptocommonmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing CRI-O on KubeEdge Worker Node\nDESCRIPTION: This snippet automates the installation of CRI-O and crun on an edge node by executing a shell script hosted remotely. Internet connectivity is required to download and execute the script.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go\nDESCRIPTION: Type definition for host function implementation with parameters for data, calling frame, and function parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposals in Go\nDESCRIPTION: This snippet demonstrates how to define constants for various WebAssembly proposals in the WasmEdge context using Go. These constants can be used to configure the WasmEdge environment to enable or disable specific WebAssembly features. It relies on the WasmEdge Go SDK as a prerequisite.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)\n  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)\n  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n  EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)\n  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)\n  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Step-by-Step Fibonacci Example\nDESCRIPTION: Commands to compile the C code that executes a WebAssembly Fibonacci calculator using the manual step-by-step approach and run the resulting binary. The output shows the 25th Fibonacci number in 0-based index.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet the result: 121393\n```\n\n----------------------------------------\n\nTITLE: Executing Model Inference in Rust\nDESCRIPTION: Rust code for executing the model inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n  // execute the inference\n    context.compute().expect(\"Failed to complete inference\");\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plug-ins from a Specific Path\nDESCRIPTION: Shows how to load a specific WasmEdge plug-in by providing its file path. This allows for more granular control over which plug-ins are available to the runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_79\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadFromPath(\"PATH_TO_PLUGIN/plugin.so\");\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a WASM Module Execution in C\nDESCRIPTION: This snippet provides instructions on how to compile a C source file containing WASM execution logic using gcc and run the resulting executable. It demonstrates the output of calculating a Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Retrieving Store Context from VM in C\nDESCRIPTION: Demonstrates how to access the internal Store context from a VM context. When a VM is created without an explicit Store, it allocates its own internally and manages its lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Building and Running Axum Server in WasmEdge\nDESCRIPTION: Commands to clone, build and run an HTTP server example using the axum framework in WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/server-axum\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler for better performance\nwasmedge compile target/wasm32-wasip1/release/wasmedge_axum_server.wasm wasmedge_axum_server.wasm\n\n# Run the example\nwasmedge wasmedge_axum_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Setting up a JavaScript-based server with WasmEdge\nDESCRIPTION: Commands to download necessary files and set up a JavaScript-based server using WasmEdge and QuickJS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\nwget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip\nunzip modules.zip\nwget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js\n```\n\n----------------------------------------\n\nTITLE: Using Import Type Context in C\nDESCRIPTION: Shows how to use an Import Type context to retrieve information about imports from an AST Module. It demonstrates querying external types, module names, and specific type contexts based on the external type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Performing Object Detection with Mediapipe in Rust\nDESCRIPTION: Rust code snippet showing how to use the Mediapipe object detector to process an input image and obtain detection results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet mut input_img = image::open(img_path)?;\nlet detection_result = detector.detect(&input_img)?;\nprintln!(\"{}\", detection_result);\n```\n\n----------------------------------------\n\nTITLE: Accessing VM Components in WasmEdge\nDESCRIPTION: Shows how to retrieve the Loader, Validator, and Executor contexts from a VM context for direct access to these components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Function in C\nDESCRIPTION: Example implementation of a host function that adds two i32 values and returns their sum.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_65\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Plug-in Descriptor Registration for WasmEdge\nDESCRIPTION: C++ code implementing the plug-in descriptor registration for a WasmEdge plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace WasmEdge {\nnamespace Host {\n\nPlugin::PluginRegister WasmEdgePluginTestEnv::Register(&Descriptor);\n\n} // namespace Host\n} // namespace WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using WasmEdge Statistics Context for Instruction Counting in C\nDESCRIPTION: This snippet demonstrates how to create a WasmEdge Statistics context, retrieve instruction count and instructions per second after running WASM functions, and properly clean up the context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/* ....\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Limit Structures in WasmEdge Go API\nDESCRIPTION: Demonstrates how to create and use Limit structures for defining minimum and maximum values in WASM. Shows creating basic limits with and without maximum values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\n----------------------------------------\n\nTITLE: Listing and Finding Instances in WasmEdge Store in C\nDESCRIPTION: Shows how to list exported instances and find specific instances by name in a WasmEdge Store context. It demonstrates listing function names and finding a function instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\nuint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n}\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Running HTTP Server Example in WasmEdge\nDESCRIPTION: Command to execute the HTTP server example JavaScript program using WasmEdge QuickJS runtime. This demonstrates how to run a JavaScript HTTP server application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_server.js\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting WasmEdge Contexts in C\nDESCRIPTION: This example demonstrates how to create and delete a WasmEdge configure context, emphasizing the importance of proper memory management for WasmEdge objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Patching wasm-bindgen for WASI Compatibility\nDESCRIPTION: Configuring a forked version of wasm-bindgen to support WebAssembly System Interface (WASI) and remove browser-specific code\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\nwasm-bindgen = { git = \"https://github.com/KernelErr/wasm-bindgen.git\", branch = \"wasi-compat\" }\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly to AOT Format in Bash\nDESCRIPTION: Demonstrates how to compile a WebAssembly file 'fibonacci.wasm' into an AOT-compiled file 'fibonacci_aot.wasm' using the WasmEdge compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile fibonacci.wasm fibonacci_aot.wasm\n```\n\n----------------------------------------\n\nTITLE: Deploying WebAssembly HTTP Service\nDESCRIPTION: Kubernetes deployment configuration for running a WebAssembly-based HTTP service container with WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh apply -f - <<< '{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"name\":\"http-server-deployment\"},\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"app\":\"http-server\"}},\"template\":{\"metadata\":{\"labels\":{\"app\":\"http-server\"}},\"spec\":{\"hostNetwork\":true,\"runtimeClassName\":\"wasm\",\"containers\":[{\"name\":\"http-server\",\"image\":\"wasmedge/example-wasi-http:latest\",\"ports\":[{\"containerPort\":1234}]}]}}}}'\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Plug-ins and Retrieving Registered Modules in Go\nDESCRIPTION: Shows how to load plug-ins, create a VM with WASI configuration, and retrieve registered modules, including mocked modules for missing plug-ins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nwasimodule := vm.GetRegisteredModule(\"wasi_snapshot_preview1\")\n\nwasinnmodule := vm.GetRegisteredModule(\"wasi_ephemeral_nn\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C API Example\nDESCRIPTION: This bash snippet shows how to compile the C code using gcc and link it with the WasmEdge C API library, then run the resulting executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Testing a TensorFlow WebAssembly Service with curl\nDESCRIPTION: Shell command to test the TensorFlow inference service by sending an image file for classification using curl. This demonstrates the ability to perform AI inference within the WebAssembly runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ curl http://localhost:3000/classify -X POST --data-binary \"@grace_hopper.jpg\"\nmilitary uniform is detected with 206/255 confidence\n```\n\n----------------------------------------\n\nTITLE: Building and Running HTTP Client Examples with WasmEdge\nDESCRIPTION: Commands to clone, build and run the reqwest demo examples using WasmEdge compiler and runtime\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_reqwest_demo\ncd wasmedge_reqwest_demo\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/http.wasm http.wasm\nwasmedge compile target/wasm32-wasip1/release/https.wasm https.wasm\n\n# Run the HTTP GET and POST examples\nwasmedge http.wasm\n\n# Run the HTTPS GET and POST examples\nwasmedge https.wasm\n```\n\n----------------------------------------\n\nTITLE: Runtime Statistics Configuration\nDESCRIPTION: Configures runtime statistics for instruction counting, cost measuring, and time tracking in WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nconf.SetStatisticsInstructionCounting(true)\nconf.SetStatisticsTimeMeasuring(true)\nconf.SetStatisticsCostMeasuring(true)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Instantiating Multiple WASM Modules in WasmEdge 0.10.0 (C)\nDESCRIPTION: Example of instantiating multiple WASM modules using the updated Executor API in WasmEdge version 0.10.0. This method outputs module instances that must be managed by the caller.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt1, *ASTCxt2;\n/*\n * Assume that `ASTCxt1` and `ASTCxt2` are loaded WASMs from different files or buffers,\n * and have both passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\nWasmEdge_ModuleInstanceContext *ModCxt1 = NULL;\nWasmEdge_ModuleInstanceContext *ModCxt2 = NULL;\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt1);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt2, StoreCxt, ASTCxt2);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies in Cargo.toml for WasmEdge Process Interface\nDESCRIPTION: This code snippet demonstrates how to include the necessary dependency in the Rust project's Cargo.toml file to access the WasmEdge process interface for executing commands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/command.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasmedge_process_interface = \"0.2.1\"\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Output Formats in Go\nDESCRIPTION: This code snippet defines constants for WasmEdge compiler output formats in Go.  These formats determine the output type of the AOT compiler. The constants are defined using the `CompilerOutputFormat` type and corresponding C definitions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\n```go\n   const (\n     // Native dynamic library format.\n     CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n     // WebAssembly with AOT compiled codes in custom section.\n     CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n   )\n   ```\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Go Application with WasmEdge\nDESCRIPTION: These bash commands demonstrate how to build the Go application and run it with the compiled WebAssembly file as an argument.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/function.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\nRun bindgen -- create_line: {\"points\":[{\"x\":1.5,\"y\":3.8},{\"x\":2.5,\"y\":5.8}],\"valid\":true,\"length\":2.2360682,\"desc\":\"A thin red line\"}\nRun bindgen -- say: hello bindgen funcs test\nRun bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt\nRun bindgen -- lowest_common_multiple: 246\nRun bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]\nRun bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]\n```\n\n----------------------------------------\n\nTITLE: Version Checking API Usage\nDESCRIPTION: Examples of using WasmEdge version-related APIs to retrieve version information\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\\n\\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-Crypto Support in WasmEdge VM\nDESCRIPTION: Demonstrates how to enable WASI-Crypto support in a WasmEdge VM configuration. It shows creating a configuration, adding multiple WASI-Crypto related registrations, creating a VM, and retrieving a WASI-Crypto module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* The WASI-Crypto related configures are suggested to turn on together. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */\nWasmEdge_ModuleInstanceContext *CryptoCommonModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Async Execution Results Length in WasmEdge C\nDESCRIPTION: This C snippet utilizes the WasmEdge_AsyncGetReturnsLength() function to obtain the length of return values from an asynchronous execution. Key dependency: WasmEdge C library. Output: Length of result values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return value list length. */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge AOT Compiler for Performance Improvement\nDESCRIPTION: Demonstrates compiling WebAssembly to native machine code using the wasmedge compile tool and shows the performance improvement when running in AOT mode compared to interpreter mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm\n[2023-02-01 22:39:15.807] [info] compile start\n[2023-02-01 22:39:15.857] [info] verify start\n[2023-02-01 22:39:15.866] [info] optimize start\n[2023-02-01 22:39:16.188] [info] codegen start\n[2023-02-01 22:39:16.403] [info] output start\n[2023-02-01 22:39:16.559] [info] compile done\n[2023-02-01 22:39:16.565] [info] output start\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30\n1346269\nreal    0m0.284s\nuser    0m0.282s\nsys     0m0.005s\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30\n1346269\nreal    0m1.814s\nuser    0m1.776s\nsys     0m0.016s\n```\n\n----------------------------------------\n\nTITLE: Rust WASM Build Stage\nDESCRIPTION: Dockerfile section that compiles Rust source code into WASM binary\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_2\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM buildbase AS build\nCOPY Cargo.toml .\nCOPY src ./src\n# Build the WASM binary\nRUN cargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Finding Plugin Context by Name\nDESCRIPTION: API to retrieve a plugin context by providing its name. Returns an Option containing the Plugin if found.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn find(name: impl AsRef<str>) -> Option<Plugin>\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-go with TensorFlow Extension in Go\nDESCRIPTION: Command to build WasmEdge-go with the TensorFlow extension enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags tensorflow\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Project for WasmEdge\nDESCRIPTION: Sets up a new Go project directory and initializes a Go module for WasmEdge development\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Context Lifecycle Management\nDESCRIPTION: Example showing how to create and release WasmEdge context objects\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\nconf := wasmedge.NewConfigure()\n// Release the `conf` immediately.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Image Processing Function in Rust\nDESCRIPTION: Rust code for a serverless function that converts an input image to grayscale. It reads image data from STDIN, processes it, and outputs the result to STDOUT.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse hex;\nuse std::io::{self, Read};\nuse image::{ImageOutputFormat, ImageFormat};\n\nfn main() {\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();\n  let img = image::load_from_memory(&buf).unwrap();\n  let filtered = img.grayscale();\n  let mut buf = vec![];\n  match image_format_detected {\n    ImageFormat::Gif => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();\n    },\n    _ => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();\n    },\n  };\n  io::stdout().write_all(&buf).unwrap();\n  io::stdout().flush().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Building hyper Demo with Rust in WasmEdge\nDESCRIPTION: This bash script clones the hyper demo repository, builds it using Rust for WasmEdge, and compiles it using the AoT compiler. It demonstrates the setup needed for running asynchronous networking applications in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/client\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/wasmedge_hyper_client.wasm wasmedge_hyper_client.wasm\n\n# Run the example\nwasmedge wasmedge_hyper_client.wasm\n```\n\n----------------------------------------\n\nTITLE: VM State Transition Diagram\nDESCRIPTION: ASCII diagram showing the different states of a WasmEdge VM object and the transitions between them through various operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_31\n\nLANGUAGE: text\nCODE:\n```\n                         |========================|\n                |------->|      VM: Initiated     |\n                |        |========================|\n                |                    |\n                |                 LoadWasm\n                |                    |\n                |                    v\n                |        |========================|\n                |--------|       VM: Loaded       |<-------|\n                |        |========================|        |\n                |              |            ^              |\n                |         Validate          |              |\n            Cleanup            |          LoadWasm         |\n                |              v            |            LoadWasm\n                |        |========================|        |\n                |--------|      VM: Validated     |        |\n                |        |========================|        |\n                |              |            ^              |\n                |      Instantiate          |              |\n                |              |          RegisterModule   |\n                |              v            |              |\n                |        |========================|        |\n                |--------|    VM: Instantiated    |--------|\n                         |========================|\n                               |            ^\n                               |            |\n                               --------------\n                  Instantiate, Execute, ExecuteRegistered,\n                  ExecuteBindgen, ExecuteBindgenRegistered\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Plugin Development Flow\nDESCRIPTION: Mermaid flowchart showing the key steps in developing a WasmEdge plugin, from environment setup to testing and debugging.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR;\nA[Developing WasmEdge Plug-in in C]\nA --> B(Set up the development environment)\nA --> C(Create a WasmEdge plug-in project)\nA --> D(Write the plug-in code)\nA --> E(Build the plug-in)\nA --> F(Test and debug the plug-in)\nB --> E\nC --> D\nD --> E\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge AOT Compiler Example\nDESCRIPTION: Bash command to compile the AOT compiler example C program and run it, showing the compilation process logs as it converts a WebAssembly file to an AOT-optimized version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_77\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module with External Function Import\nDESCRIPTION: WebAssembly module definition that imports and uses an external function for addition. Shows module structure with function import and export declarations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_61\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Pulling and running a simple WebAssembly container in containerd\nDESCRIPTION: Commands to pull a WebAssembly-based container image from Docker Hub and run it using containerd with crun runtime. The example runs a simple WASI application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ctr i pull docker.io/wasmedge/example-wasi:latest\nsudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in WasmEdge\nDESCRIPTION: This snippet illustrates how to configure options related to statistics tracking, including instruction counting, cost measuring, and time measuring within various contexts of WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/*\n * By default, the instruction counting is `FALSE` when running a\n * compiled-WASM or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/*\n * By default, the cost measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/*\n * By default, the time measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Testing Microservices with CURL Commands\nDESCRIPTION: Example CURL commands to test the deployed microservices including database initialization, image processing, and event querying\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/dapr.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:9007/init\n{\"status\":true}\n\n$ curl http://localhost:9007/events\n[]\n\n$ cd docs\n$ curl http://localhost:9005/grayscale -X POST --data-binary '@food.jpg'\nABCDEFG ...\n\n$ cd docs\n$ curl http://localhost:9006/classify -X POST --data-binary '@food.jpg'\nhotdog is detected with 255/255 confidence\n\n$ curl http://localhost:9007/events\n[{\"id\":1,\"event_ts\":1665358852918,\"op_type\":\"grayscale\",\"input_size\":68016},{\"id\":2,\"event_ts\":1665358853114,\"op_type\":\"classify\",\"input_size\":68016}]\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module with Imported Function\nDESCRIPTION: A simple WebAssembly module in WAT format that imports a function named 'trap' from the 'extern' module and exports a function that calls it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_67\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32)))\n  (import \"extern\" \"trap\" (func $f-trap (type $t0)))\n  (func (export \"trap\") (param i32)\n    local.get 0\n    call $f-trap)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Function Type Context in C\nDESCRIPTION: Demonstrates how to create a Function Type context with parameters and return types, and then query information from it using WasmEdge API functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I64};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen =\n    WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen =\n    WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance from Plugin (Pre-0.12.0)\nDESCRIPTION: Example of creating a module instance from a plugin before version 0.12.0, using specific creation functions for each plugin type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nWasmEdge_ModuleInstance *WasiCryptoCommonCxt =\n    WasmEdge_ModuleInstanceCreateWasiCryptoCommon();\n\nWasmEdge_ModuleInstanceDelete(WasiCryptoCommonCxt);\n```\n\n----------------------------------------\n\nTITLE: Running OpenVINO Inference Example\nDESCRIPTION: Commands to download model files and run the inference application using WasmEdge CLI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/openvino.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# download the fixture files (OpenVINO model files)\n./download_mobilenet.sh\nwasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg\n```\n\n----------------------------------------\n\nTITLE: Accessing Active Module in WasmEdge\nDESCRIPTION: Demonstrates how to retrieve the active anonymous module instance after WASM module instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nconst WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx with WASM Module (Go Version)\nDESCRIPTION: Nginx configuration to load and execute a WASM file compiled from Go, injecting a custom response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/wasm-nginx.md#2025-04-21_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nworker_processes  1;\n\nerror_log  /tmp/error.log warn;\n\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    wasm_vm wasmedge;\n    init_by_lua_block {\n        local wasm = require(\"resty.proxy-wasm\")\n        package.loaded.plugin = assert(wasm.load(\"fault_injection\",\n            \"/path/to/fault-injection/main.go.wasm\"))\n    }\n    server {\n        listen 1980;\n        location / {\n            content_by_lua_block {\n                local wasm = require(\"resty.proxy-wasm\")\n                local ctx = assert(wasm.on_configure(package.loaded.plugin,\n                    '{\"http_status\": 403, \"body\": \"powered by wasm-nginx-module\"}'))\n                assert(wasm.on_http_request_headers(ctx))\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Cluster Access\nDESCRIPTION: Commands for setting up Kubernetes cluster configuration and authentication for local access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport KUBERNETES_PROVIDER=local\n\nsudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\nsudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\nsudo cluster/kubectl.sh config set-context local --cluster=local --user=myself\nsudo cluster/kubectl.sh config use-context local\nsudo cluster/kubectl.sh\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Output Format Constants\nDESCRIPTION: Constants defining the output formats available for the WasmEdge Ahead-of-Time compiler, including native dynamic library format and WebAssembly with AOT compiled code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_67\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Optimization Levels in WasmEdge Go SDK\nDESCRIPTION: Constants representing different optimization levels for the WasmEdge AOT compiler. These range from O0 (minimal optimization) to O3 (maximum speed optimization) and include size optimization options (Os and Oz).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_79\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: Streaming Video to YoMo for Processing\nDESCRIPTION: The Go command executes the main.go program located in the source folder, feeding the downloaded video file into the YoMo framework. The program is responsible for invoking the WasmEdge function against each image frame captured from the video for object detection.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngo run ./source/main.go ./source/hot-dog.mp4\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Output Formats in Go\nDESCRIPTION: Constants defining output formats for the WasmEdge AOT compiler, including native dynamic library format and WebAssembly with AOT compiled code in custom sections.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_70\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing CRI-O Container for WebAssembly HTTP Server\nDESCRIPTION: This snippet shows how to create a container instance, set a container ID variable, start the container, check its status, and view its logs. It also demonstrates how to retrieve the container's IP address and test the HTTP service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Create the container instance. The output will be different from the example.\n$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json\n# Set a helper variable for later use.\nCONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Start the container\n$ sudo crictl start $CONTAINER_ID\n\n# Check the container status. It should be Running.\n# If not, wait a few seconds and check again\n$ sudo crictl ps -a\nCONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID\n4eeddf8613691       wasmedge/example-wasi-http:latest              Less than a second ago   Running             http_server         0                   1d84f30e7012e\n\n# Check the container's logs to see if the HTTP server is listening at port 1234\n$ sudo crictl logs $CONTAINER_ID\nnew connection at 1234\n\n# Get the IP address assigned to the container\n$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'\"' -f 2\n10.85.0.2\n\n# Test the HTTP service at that IP address\n$ curl -d \"name=WasmEdge\" -X POST http://10.85.0.2:1234\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Server Container with CRI-O\nDESCRIPTION: Commands to create a pod and container for running the WebAssembly HTTP server using CRI-O. This prepares the container for running the server application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Create the POD. Output will be different from example.\n$ sudo crictl runp sandbox_config.json\n7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4\n# Set a helper variable for later use.\n$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4\n```\n\n----------------------------------------\n\nTITLE: Fetch All Orders\nDESCRIPTION: CURL command to retrieve all orders from the database via GET request.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/orders\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Illustrates how to execute functions in registered WASM modules using the WasmEdge VM. It includes registering a WASM module, preparing parameters and return values, and executing a registered function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n  /*\n  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n  */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n  * The function \"fib\" in the \"fibonacci.wasm\" was exported with the module name \"mod\".\n  * As the same as host functions, other modules can import the function `\"mod\" \"fib\"`.\n  */\n\n  /*\n  * Execute WASM functions in registered modules.\n  * Unlike the execution of functions, the registered functions can be invoked without\n  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.\n  * Developers can also invoke the host functions directly with this API.\n  */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Image Classification in Rust with TensorFlow Lite and WasmEdge\nDESCRIPTION: A Rust program that reads image data from STDIN, performs image classification using TensorFlow Lite model in WasmEdge, and outputs the classification result to STDOUT. The program loads a pre-trained MobileNet model, processes the input image, and identifies the subject with confidence score.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn main() {\n  // Step 1: Load the TFLite model\n  let model_data: &[u8] = include_bytes!(\"models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite\");\n  let labels = include_str!(\"models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt\");\n\n  // Step 2: Read image from STDIN\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  // Step 3: Resize the input image for the tensorflow model\n  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);\n\n  // Step 4: AI inference\n  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);\n  session.add_input(\"input\", &flat_img, &[1, 224, 224, 3])\n         .run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Reshape_1\");\n\n  // Step 5: Find the food label that responds to the highest probability in res_vec\n  // ... ...\n  let mut label_lines = labels.lines();\n  for _i in 0..max_index {\n    label_lines.next();\n  }\n\n  // Step 6: Generate the output text\n  let class_name = label_lines.next().unwrap().to_string();\n  if max_value > 50 {\n    println!(\"It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture\", confidence.to_string(), class_name, class_name);\n  } else {\n    println!(\"It does not appears to be any food item in the picture.\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building React SSR with npm - Bash\nDESCRIPTION: This snippet shows the terminal commands needed to install the necessary dependencies for the React SSR application and build the project. It uses npm to install packages and run a build command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Generating and Checking WASM Values\nDESCRIPTION: Illustrates generating WASM values of different types (i32, i64, f32, f64) and checking their types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nbool IsTypeI32 = WasmEdge_ValTypeIsI32(Val.Type);\n/* The `IsTypeI32` will be `TRUE`. */\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \"123456\" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nbool IsTypeI64 = WasmEdge_ValTypeIsI64(Val.Type);\n/* The `IsTypeI64` will be `TRUE`. */\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \"1234567890123\" */\nVal = WasmEdge_ValueGenF32(123.456f);\nbool IsTypeF32 = WasmEdge_ValTypeIsF32(Val.Type);\n/* The `IsTypeF32` will be `TRUE`. */\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \"123.456001\" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nbool IsTypeF64 = WasmEdge_ValTypeIsF64(Val.Type);\n/* The `IsTypeF64` will be `TRUE`. */\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \"123456.1234567890\" */\n```\n\n----------------------------------------\n\nTITLE: Async Result Retrieval in C\nDESCRIPTION: Shows how to retrieve results from an async execution using a pre-allocated buffer. Handles blocking and result storage.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Global Type Context Usage in C\nDESCRIPTION: Shows Global Type context manipulation for WASM global instances. Demonstrates creating and querying global variables with their types and mutability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Testing Encrypt/Decrypt Functions\nDESCRIPTION: SQL commands demonstrating the usage of encrypt and decrypt functions with example data and password verification.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md#2025-04-21_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE secrets(secret);\nINSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));\nINSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));\nINSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));\n\nSELECT secret, decrypt(secret, 'wrong-pass') from secrets;\nSELECT secret, decrypt(secret, 's3cretp4ss') from secrets;\n```\n\n----------------------------------------\n\nTITLE: Building Mediapipe Object Detection Wasm Application\nDESCRIPTION: Commands to build the Rust application targeting wasm32-wasip1 and compile it with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\nwasmedge compile target/wasm32-wasip1/release/demo-object-detection.wasm demo-object-detection.wasm\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Test\nDESCRIPTION: This snippet shows how to build and run a WasmEdge test application written in Go. It uses `go get` to download the WasmEdge Go SDK, `go build` to compile the application, and then executes the compiled binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\n```\n```\n\n----------------------------------------\n\nTITLE: WASM Module Instantiation - Pre v0.10.0\nDESCRIPTION: Shows how to instantiate a WASM module using the Executor API in WasmEdge-Go v0.9.2. Creates an anonymous module instance handled by the Store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST\nerr := executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Memory Type Context in C\nDESCRIPTION: Demonstrates the creation of a Memory Type context with a specified limit and retrieving the limit information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Running Llama2 Inference with Podman and WasmEdge\nDESCRIPTION: Command to run Llama2 inference using Podman with WasmEdge and GPU support. This command mounts necessary libraries, sets environment variables, and specifies GPU device usage.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo <podman path> run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \\\n  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \\\n  -v .:/resource \\\n  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \\\n  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \\\n  --env n_gpu_layers=100 \\\n  --rm --device nvidia.com/gpu=all --runtime <crun path> --annotation module.wasm.image/variant=compat-smart --platform wasip1/wasm \\\n  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \\\n  $'[INST] <<SYS>>\\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\\n<</SYS>>\\nWhat is the capital of Japan?[/INST]'\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Complete Rust Module Example\nDESCRIPTION: Commands for building and running a more complete example that demonstrates creating a JavaScript class API from a Rust module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/rust.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd examples/embed_rust_module\ncarbo build --target wasm32-wasip1 --release\nwasmedge --dir .:. target/wasm32-wasip1/release/embed_rust_module.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating WebAssembly Binary in Hexadecimal Format\nDESCRIPTION: A WebAssembly binary represented in hexadecimal format that includes import/export definitions and function code. The module imports a function named 'func-add' from the 'extern' module and exports a function named 'addTwo'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_74\n\nLANGUAGE: webassembly\nCODE:\n```\n0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n/* extern name: \"func-add\" */\n0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n/* import desc: func 0 */\n0x00, 0x00,\n/* Function section */\n0x03, 0x02, 0x01, 0x00,\n/* Export section */\n0x07, 0x0A, 0x01,\n/* export name: \"addTwo\" */\n0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n/* export desc: func 0 */\n0x00, 0x01,\n/* Code section */\n0x0A, 0x0A, 0x01,\n/* code body */\n0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n```\n\n----------------------------------------\n\nTITLE: Registering and Instantiating WASM Modules from File in WasmEdge\nDESCRIPTION: This snippet demonstrates how to register a WASM module from a file, instantiate another WASM module, and execute functions from both modules using the WasmEdge VM context. It includes error handling and resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* Register the `lib.wasm` from file with the module name \"math\". */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModuleName, \"lib.wasm\");\n  WasmEdge_StringDelete(ModuleName);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Register lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Instantiate the `test.wasm`. */\n  /*\n   * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to\n   * instantiate and execute quickly.\n   */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"test.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Load test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Validate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    printf(\"Instantiate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Invoke the functions. */\n  /* Invoke the \"add_and_square\" to calculate (123 + 456)^2 */\n  WasmEdge_String FuncName =\n      WasmEdge_StringCreateByCString(\"add_and_square\");\n  Params[0] = WasmEdge_ValueGenI32(123);\n  Params[1] = WasmEdge_ValueGenI32(456);\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '(%d + %d)^2' result: %d\\n\", 123, 456,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'add_and_square' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n  /* Invoke the \"sum_of_squares\" to calculate (77^2 + 88^2) */\n  FuncName = WasmEdge_StringCreateByCString(\"sum_of_squares\");\n  Params[0] = WasmEdge_ValueGenI32(77);\n  Params[1] = WasmEdge_ValueGenI32(88);\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '%d^2 + %d^2' result: %d\\n\", 77, 88,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'sum_of_squares' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a TensorFlow WebAssembly Server in Docker\nDESCRIPTION: Shell commands to build and run a Docker container with a TensorFlow inference service in WebAssembly. The commands set up port forwarding to allow access to the AI service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 3000:3000 wasmedge/myapp\nlisten 3000 ...\n```\n\n----------------------------------------\n\nTITLE: Restarting CRI-O Service\nDESCRIPTION: Command to restart the CRI-O service to apply configuration changes. This is necessary after modifying the configuration files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsystemctl restart crio\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Proposals in Go\nDESCRIPTION: This code snippet defines constants for WebAssembly proposals in Go. These constants are used to enable or disable specific Wasm features during the configuration of the WasmEdge runtime.  The constants are defined using the `Proposal` type and corresponding C definitions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\n```go\n   const (\n     IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n     NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n     SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n     MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n     BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n     REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n     SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n     TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n     ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)\n     MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)\n     THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)\n     EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n     FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n   )\n   ```\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge_Process Support\nDESCRIPTION: Shows how to enable and configure WasmEdge_Process support for Rust sources. Includes configuration setup, process object initialization, and proper cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration import objects from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ImportObjectContext *ProcObject =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);\n/* Initialize the WasmEdge_Process. */\nWasmEdge_ImportObjectInitWasmEdgeProcess(ProcObject, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling TinyGo to WebAssembly\nDESCRIPTION: This command uses the TinyGo compiler to compile the `fib.go` source code into a WebAssembly bytecode file named `fib.wasm`.  The `-target wasi` flag specifies that the WebAssembly module should be built for the WebAssembly System Interface (WASI) environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntinygo build -o fib.wasm -target wasi fib.go\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting WasmEdge Strings with C API\nDESCRIPTION: This C code demonstrates how to create and delete `WasmEdge_String` objects using the WasmEdge C API. It shows how to create strings from C strings and buffers, and emphasizes the importance of deleting the allocated string objects using `WasmEdge_StringDelete()` to prevent memory leaks.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n\"char Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\\\"test\\\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\"\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Session Creation in Rust\nDESCRIPTION: Code examples showing different ways to create TensorFlow sessions\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// The mod_buf is a vec<u8> which contains the model data.\nlet mut session = wasmedge_tensorflow_interface::TFSession::new(&mod_buf);\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI for Library Functions - Rust\nDESCRIPTION: This Rust code snippet demonstrates how to properly initialize the WASI environment when using WASI functions within a Rust library (as opposed to a `main` function).  The `_initialize()` function (provided by the `wasmedge-wasi-helper` crate, though not explicitly shown) must be called before any WASI-dependent functionality is used (like accessing arguments, environment variables, or the file system).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n\"pub fn print_env() -> i32 {\\n  _initialize();\\n  ... ...\\n}\\n\\npub fn create_file(path: &str, content: &str) -> String {\\n  _initialize();\\n  ... ...\\n}\\n\\npub fn read_file(path: &str) -> String {\\n  _initialize();\\n  ... ...\\n}\\n\\npub fn del_file(path: &str) -> String {\\n  _initialize();\\n  ... ...\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Querying Export Type Context in C\nDESCRIPTION: Illustrates how to query information from an Export Type context, including external type, external name, and specific type information based on the external type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Lite Model Loading and Inference\nDESCRIPTION: Rust implementation of loading TensorFlow Lite model, preparing input tensor, and executing inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// load model\nlet weights = fs::read(model_bin_name)?\nlet graph = GraphBuilder::new(\n    GraphEncoding::TensorflowLite,\n    ExecutionTarget::CPU,\n).build_from_bytes(&[&weights])?\nlet mut ctx = graph.init_execution_context()?\n\n// Load a tensor that precisely matches the graph input tensor\nlet tensor_data = image_to_tensor(image_name.to_string(), 224, 224);\nctx.set_input(0, TensorType::U8, &[1, 224, 224, 3], &tensor_data)?\n\n// Execute the inference.\nctx.compute().unwrap();\n\n// Retrieve the output.\nlet mut output_buffer = vec![0u8; imagenet_classes::AIY_BIRDS_V1.len()];\n_ = ctx.get_output(0, &mut output_buffer)?\n```\n\n----------------------------------------\n\nTITLE: Executing AOT-Compiled WebAssembly in Bash\nDESCRIPTION: Demonstrates how to execute an AOT-compiled WebAssembly file 'fibonacci_aot.wasm' using WasmEdge, calling the 'fib' function with argument 30.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntime wasmedge --reactor fibonacci_aot.wasm fib 30\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge Process Plugin\nDESCRIPTION: Function to initialize the wasmedge_process plugin with optional command whitelist and execution permissions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Context for Host Function in WasmEdge\nDESCRIPTION: How to create a function context with a function type and host function body in WasmEdge, specifying parameter and return types for the function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_68\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/* If the function instance is not added into a module instance context, it should be deleted. */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Verifying crun Installation with WasmEdge Support\nDESCRIPTION: Command to check the installed version of crun and verify that it includes WasmEdge support. This confirms the successful setup of crun for running WASM applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/podman.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncrun --version\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Table Type Context in C\nDESCRIPTION: Shows how to create and use a Table Type context in WasmEdge. It demonstrates setting up a table limit and querying information from the table type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `GotRefType` will be WasmEdge_RefType_ExternRef. */\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n/* `GotTabLim` will be the same value as `TabLim`. */\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C API Example\nDESCRIPTION: This bash snippet shows how to compile the C code using gcc and run the resulting executable. It demonstrates the execution of the 18th Fibonacci number calculation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Output Format Constants\nDESCRIPTION: Constants defining the output formats for the WasmEdge AOT compiler. Developers can choose between native dynamic library format or WebAssembly with AOT compiled code in custom sections.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_61\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Adding WasmEdge Plugin Test to CMakeLists.txt\nDESCRIPTION: This CMake snippet shows how to add a test executable for a WasmEdge plugin to the build system. It specifies the test executable, links necessary libraries, and adds the test to be run with CTest.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/test_plugin.md#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(your_plugin_test your_plugin_test.cpp)\ntarget_link_libraries(your_plugin_test gtest_main your_plugin)\nadd_test(NAME your_plugin_test COMMAND your_plugin_test)\n```\n\n----------------------------------------\n\nTITLE: WASM Module Instantiation - Pre v0.10.0\nDESCRIPTION: Example of instantiating a WASM module using WasmEdge Executor API in version 0.9.2. Creates an anonymous module instance handled by the Store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST\nerr := executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly with Statistics\nDESCRIPTION: Command to execute a WebAssembly file using wasmedge with all statistics enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --enable-all-statistics hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests on Windows\nDESCRIPTION: PowerShell commands to run the WasmEdge test suite for verifying the correctness of the build. These tests are available only when WASMEDGE_BUILD_TESTS is enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/windows.md#2025-04-21_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\n$Env:PATH += \";$pwd\\build\\lib\\api\"\ncd build\nctest --output-on-failure\ncd -\n```\n\n----------------------------------------\n\nTITLE: Configuring Containerd for WasmEdge Support\nDESCRIPTION: Commands to configure Containerd to use crun runtime and apply patches for WasmEdge support. This enables Containerd to run WebAssembly modules using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir -p /etc/containerd/\nsudo bash -c \"containerd config default > /etc/containerd/config.toml\"\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff\nsudo patch -d/ -p0 < containerd_config.diff\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge-WASINN-examples Repository\nDESCRIPTION: Commands to clone the example project repository and navigate to the PyTorch MobileNet image classification example directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/pytorch-mobilenet-image/\n```\n\n----------------------------------------\n\nTITLE: Setting Statistics Options in Go\nDESCRIPTION: This snippet provides details about configuring statistics options for tracking instruction counts and measuring costs during runtime. It allows for setting thresholds and enabling features within the `Configure` object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsInstructionCounting(true)\n// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsTimeMeasuring(true)\n// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.\nconf.SetStatisticsCostMeasuring(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly SIMD Binary with WasmEdge\nDESCRIPTION: This command executes the compiled WebAssembly SIMD binary 'mandelbrot-simd.wasm' using WasmEdge runtime with an input parameter of 15000.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/simd.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge mandelbrot-simd.wasm 15000\n```\n\n----------------------------------------\n\nTITLE: Allocating Memory in Rust for WebAssembly\nDESCRIPTION: This Rust code defines functions for allocating and deallocating memory using raw pointers. The 'allocate' function allocates a memory buffer, while the 'deallocate' function safely frees it, turning the raw pointer back into a Rust Vec.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#include <std::mem>\n#include <std::os::raw::{c_void, c_int}>\n\n#[no_mangle]\npub extern fn allocate(size: usize) -> *mut c_void {\n  let mut buffer = Vec::with_capacity(size);\n  let pointer = buffer.as_mut_ptr();\n  mem::forget(buffer);\n\n  pointer as *mut c_void\n}\n\n#[no_mangle]\npub extern fn deallocate(pointer: *mut c_void, capacity: usize) {\n  unsafe {\n    let _ = Vec::from_raw_parts(pointer, 0, capacity);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Host Registration Enum in WasmEdge\nDESCRIPTION: Define supported host registrations for enabling specific runtime capabilities\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0,\n  WasmEdge_HostRegistration_WasmEdge_Process\n};\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Import Type Context\nDESCRIPTION: Shows how to handle import type contexts and retrieve import information from AST modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances from Module Instance Context (WasmEdge 0.10.0+)\nDESCRIPTION: Shows how to load, validate, instantiate a WASM module, and retrieve exported instances from Module Instance context in WasmEdge versions 0.10.0 and later. This approach provides better support for multiple anonymous modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n/* Create the store context. The store context is the object to link the modules for imports and exports. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n/* Create the executor context. The configure context and the statistics context can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Validate the WASM module. */\nRes = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: register and instantiate the WASM module with the module name \"module_fib\". */\nWasmEdge_ModuleInstanceContext *NamedModCxt = NULL;\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module_fib\");\nRes = WasmEdge_ExecutorRegister(ExecCxt, &NamedModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Example: Instantiate the WASM module and get the output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* Now, developers can retrieve the exported instances from the module instances. */\n/* Take the exported functions as example. This WASM exports the function \"fib\". */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FoundFuncCxt;\n/* Find the function \"fib\" from the instantiated anonymous module. */\nFoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n/* Find the function \"fib\" from the registered module \"module_fib\". */\nFoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(NamedModCxt, FuncName);\n/* Or developers can get the named module instance from the store: */\nModName = WasmEdge_StringCreateByCString(\"module_fib\");\nconst WasmEdge_ModuleInstanceContext *ModCxtGot = WasmEdge_StoreFindModule(StoreCxt, ModName);\nWasmEdge_StringDelete(ModName);\nFoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxtGot, FuncName);\nWasmEdge_StringDelete(FuncName);\n\nWasmEdge_ModuleInstanceDelete(NamedModCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\nWasmEdge_ASTModuleDelete(ASTCxt);\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ValidatorDelete(ValidCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Reloading Docker After Runtime Configuration\nDESCRIPTION: Command to reload the Docker daemon after configuring the custom crun runtime. This applies the changes without requiring a system restart.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Reload docker daemon\n> sudo systemctl reload docker\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Default Paths\nDESCRIPTION: Code snippet demonstrating how to load WasmEdge plugins from default paths and list all loaded plugins. This is useful for extending WasmEdge functionality through the plugin system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_86\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Simple WebAssembly Application in Kubernetes\nDESCRIPTION: Command to deploy and run a simple WebAssembly WASI program as a container in a Kubernetes pod using the wasmedge/example-wasi image with appropriate annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Installing containerd on Linux\nDESCRIPTION: Commands to install containerd, including downloading and verifying the package, extracting it, and reloading the system daemon.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport VERSION=\"1.5.7\"\necho -e \"Version: $VERSION\"\necho -e \"Installing libseccomp2 ...\"\nsudo apt install -y libseccomp2\necho -e \"Installing wget\"\nsudo apt install -y wget\n\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\nsha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\n\nsudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nsudo systemctl daemon-reload\n```\n\n----------------------------------------\n\nTITLE: Creating ES6 Module with Exported Function\nDESCRIPTION: Simple ES6 module that defines a function and exports it. This demonstrates the basic syntax for creating reusable module components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/es6.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hello() {\n  console.log('hello from module_def.js');\n}\n\nexport { hello };\n```\n\n----------------------------------------\n\nTITLE: Creating V128 SIMD Value in WasmEdge Go\nDESCRIPTION: Demonstrates creating and manipulating v128 SIMD values using WasmEdge Go API with value extraction methods\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance from Plugin (Post-0.12.0)\nDESCRIPTION: Example of creating a module instance from a plugin after version 0.12.0, using a general API for plugin module creation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char CryptoPName[] = \"wasi_crypto\";\nconst char CryptoMName[] = \"wasi_crypto_common\";\nWasmEdge_String PluginName =\n    WasmEdge_StringWrap(CryptoPName, strlen(CryptoPName));\nWasmEdge_String ModuleName =\n    WasmEdge_StringWrap(CryptoMName, strlen(CryptoMName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(PluginName);\n\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, ModuleName);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Function\nDESCRIPTION: Example of accessing memory from within a host function using the calling frame context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data,\n                              const WasmEdge_CallingFrameContext *CallFrameCxt,\n                              const WasmEdge_Value *In, WasmEdge_Value *Out) {\n     /* Function type: {i32} -> {} */\n     uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n     uint32_t Num = 0;\n\n     /*\n      * Get the 0-th memory instance of the module instance of the top frame on\n      * stack.\n      */\n     WasmEdge_MemoryInstanceContext *MemCxt =\n         WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n\n     WasmEdge_Result Res =\n         WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n     if (WasmEdge_ResultOK(Res)) {\n       printf(\"u32 at memory[%lu]: %lu\\n\", Offset, Num);\n     } else {\n       return Res;\n     }\n     return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Running LLaMA Model via WasmEdge CLI\nDESCRIPTION: Command line example showing how to run a LLaMA model inference using WasmEdge with specified directories, model file, and prompt parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-simple.wasm \\\n  --prompt 'Robert Oppenheimer most important achievement is ' --ctx-size 512\n```\n\n----------------------------------------\n\nTITLE: Update Order\nDESCRIPTION: CURL command to update an existing order by sending POST request with updated order data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/update_order -X POST -d @update_order.json\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM\nDESCRIPTION: Demonstrates how to enable and configure WASI support in a WasmEdge VM instance. Shows the process of creating configuration context, adding WASI host registration, and initializing WASI import object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration import objects from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ImportObjectContext *WasiObject =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating a Standalone WebAssembly Program in Rust with WASI\nDESCRIPTION: This Rust main() function demonstrates how to create a standalone WebAssembly program using WASI. It combines various WASI functionalities including random number generation, file I/O, and environment variable access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  println!(\"Random number: {}\", get_random_i32());\n  println!(\"Random bytes: {:?}\", get_random_bytes());\n  println!(\"{}\", echo(\"This is from a main function\"));\n  print_env();\n  create_file(\"tmp.txt\", \"This is in a file\");\n  println!(\"File content is {}\", read_file(\"tmp.txt\"));\n  del_file(\"tmp.txt\");\n}\n```\n\n----------------------------------------\n\nTITLE: Querying AST Module Imports and Exports in Go\nDESCRIPTION: Demonstrates how to query the imports and exports of an AST object, which represents a loaded WASM module. It iterates through the imports and exports, printing their names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_45\n\nLANGUAGE: go\nCODE:\n```\nast := ...\n// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.\n\n// List the imports.\nimports := ast.ListImports()\nfor _, import := range imports {\n  fmt.Println(\"Import:\", import.GetModuleName(), import.GetExternalName())\n}\n\n// List the exports.\nexports := ast.ListExports()\nfor _, export := range exports {\n  fmt.Println(\"Export:\", export.GetExternalName())\n}\n\nast.Release()\n```\n\n----------------------------------------\n\nTITLE: Delete Order\nDESCRIPTION: CURL command to delete an order by ID using GET request with query parameter.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/delete_order?id=2\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Module with ExternRef in WebAssembly Text Format\nDESCRIPTION: This WASM code defines a module that imports an external function 'func_mul' and exports a function 'call_mul' that uses externref as a parameter.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_3\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param externref i32 i32) (result i32)))\n  (import \"extern_module\" \"func_mul\" (func $func_mul (type $t0)))\n  (func $call_mul (export \"call_mul\") (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)\n    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))\n  )\n  (memory $memory (export \"memory\") 1))\n```\n\n----------------------------------------\n\nTITLE: Working with Export Type Context in C\nDESCRIPTION: Example of using Export Type context to access export information from AST Module, including external types and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: Running PyTorch Inference with WasmEdge CLI\nDESCRIPTION: Command to execute the pre-compiled WASM file for PyTorch inference using WasmEdge CLI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Type from Function Instance in Go\nDESCRIPTION: Demonstrates how to retrieve a FunctionType from a Function object obtained from the store. The retrieved function type should not be manually released.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_53\n\nLANGUAGE: go\nCODE:\n```\nfuncinst := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the store object.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the store object should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n```\n\n----------------------------------------\n\nTITLE: Tag Instance Management (C)\nDESCRIPTION: Demonstrates tag instance handling in WasmEdge with exception handling proposal enabled. Shows how to list, find, and work with tag instances from module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_70\n\nLANGUAGE: c\nCODE:\n```\nuint32_t TagNum = WasmEdge_ModuleInstanceListTagLength(ModCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String TagNames[BUF_LEN];\nuint32_t RealTagNum = WasmEdge_ModuleInstanceListTag(ModCxt, TagNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealTagNum && I < BUF_LEN; I++) {\n  /* Working with the tag name `TagNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\nWasmEdge_String TagName = WasmEdge_StringCreateByCString(\"tag-1\");\nWasmEdge_TagInstanceContext *TagCxt = WasmEdge_ModuleInstanceFindTag(ModCxt, TagName);\nconst WasmEdge_TagTypeContext *TagTypeCxt = WasmEdge_TagInstanceGetTagType(TagCxt);\n\nWasmEdge_StringDelete(TagName);\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options for WebAssembly Execution in C\nDESCRIPTION: This snippet configures the statistics options that allow tracking of instruction counts, cost measurements, and time measurements during runtime within Compiler, VM, and Executor contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/*\n * By default, the instruction counting is `FALSE` when running a\n * compiled-WASM or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/*\n * By default, the cost measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/*\n * By default, the time measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Running WASM Workloads in KinD with WasmEdge\nDESCRIPTION: Commands to create a KinD cluster with WasmEdge support and run a WebAssembly example application. This uses a pre-built image with crun and WasmEdge configured.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create a \"WASM in KinD\" Cluster\nkind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0\n# Run the example\nkubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling WASM for Performance Improvement\nDESCRIPTION: Commands to AOT compile the WASM file and run it for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm\nwasmedge --dir .:. out.wasm mobilenet.pt input.jpg\n```\n\n----------------------------------------\n\nTITLE: Building and Testing WasmEdge KinD Cluster\nDESCRIPTION: Commands to build the custom KinD node image, create a cluster using it, and run a test WebAssembly application to validate the setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t node-wasmedge .\nkind create cluster --image node-wasmedge\n# Now you can run the example to validate your cluster\nkubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Example in Bash\nDESCRIPTION: Commands for compiling the WasmEdge C example with GCC and running the resulting executable. The example demonstrates executing the 18th Fibonacci number (4181) using the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Number Value Types Example\nDESCRIPTION: Example showing how to work with various numeric value types in WasmEdge including integers and floating point numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf(\"%d\\n\", WasmEdge_ValueGetI32(Val));\n/* Will print \"123456\" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf(\"%ld\\n\", WasmEdge_ValueGetI64(Val));\n/* Will print \"1234567890123\" */\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf(\"%f\\n\", WasmEdge_ValueGetF32(Val));\n/* Will print \"123.456001\" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf(\"%.10f\\n\", WasmEdge_ValueGetF64(Val));\n/* Will print \"123456.1234567890\" */\n```\n\n----------------------------------------\n\nTITLE: Verifying crun Installation with WasmEdge Support\nDESCRIPTION: Command to check the installed version of crun and verify that it includes WasmEdge support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncrun -v\n```\n\n----------------------------------------\n\nTITLE: Cloning the WasmEdge-WASINN-examples Repository\nDESCRIPTION: This snippet demonstrates how to clone the WasmEdge-WASINN-examples repository using git. It prepares the environment for running the Whisper model example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/whisper.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/whisper-basic/\n```\n\n----------------------------------------\n\nTITLE: Function Context Creation in C\nDESCRIPTION: Demonstrates how to create a function context with specified parameter and return types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nHostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\nWasmEdge_FunctionInstanceDelete(HostFunc);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Plugins\nDESCRIPTION: Installation command for WasmEdge with TensorFlow and Image plugins\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_tensorflow wasmedge_tensorflowlite wasmedge_image -v 0.13.5\n```\n\n----------------------------------------\n\nTITLE: Configuring Containerd for WebAssembly Annotations\nDESCRIPTION: TOML configuration for containerd to pass WebAssembly-specific annotations to the runtime. This allows Kubernetes to properly handle WebAssembly workloads.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc]\n  pod_annotations = [\"*.wasm.*\", \"wasm.*\", \"module.wasm.image/*\", \"*.module.wasm.image\", \"module.wasm.image/variant.*\"]\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge WASM Execution Example\nDESCRIPTION: Shows how to compile the C code that uses WasmEdge API to execute a WASM module, and run the resulting executable. The example calculates the 18th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Table Types in Go\nDESCRIPTION: Demonstrates creating and managing table type contexts for WebAssembly table instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: AOT Compilation Commands for WasmEdge\nDESCRIPTION: Commands to perform ahead-of-time compilation and execution of WebAssembly modules for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile hello.wasm hello_aot.wasm\nwasmedge hello_aot.wasm second state\n```\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile add.wasm add_aot.wasm\nwasmedge --reactor add_aot.wasm add 2 2\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the WebAssembly Integration Example\nDESCRIPTION: Shell commands to compile the C program that uses WasmEdge API and run the resulting executable. The output shows the addition operation being performed via WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_77\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Creating and Using GlobalType in WasmEdge Go API\nDESCRIPTION: Shows how to create and use GlobalType objects for defining WASM global variable instances with specific value types and mutability.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)\n\nvtype := globtype.GetValType()\n// `vtype` will be `wasmedge.ValType_F64`.\nvmut := globtype.GetMutability()\n// `vmut` will be `wasmedge.ValMut_Var`.\n\nglobtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Waiting for Async Execution with Blocking Call\nDESCRIPTION: Demonstrates how to wait for an asynchronous execution to complete using WasmEdge_AsyncWait() API. Blocks until execution finishes and then deletes the async object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Reading Command Line Arguments in Rust\nDESCRIPTION: Rust code to read file names for the model and input image from command line arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/openvino.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet args: Vec<String> = env::args().collect();\nlet model_xml_name: &str = &args[1]; // File name for the model xml\nlet model_bin_name: &str = &args[2]; // File name for the weights\nlet image_name: &str = &args[3]; // File name for the input image\n```\n\n----------------------------------------\n\nTITLE: Error Handling in WasmEdge C Plugin\nDESCRIPTION: Example of proper error handling in a WasmEdge plugin function\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/best_practice.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                        const WasmEdge_Value *In, WasmEdge_Value *Out) {\n      // Check the input types...\n      int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n      int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n      if (Val1 == INT32_MIN || Val2 == INT32_MIN) {\n      return WasmEdge_Result_Error;\n      }\n      // Rest of the function...\n   }\n```\n\n----------------------------------------\n\nTITLE: Checking Value Types in WASM\nDESCRIPTION: Demonstrates how to use the WasmEdge API to check various value types such as i32, i64, f32, f64, and v128.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ValType;\nValType = WasmEdge_ValTypeGenI32();\nbool IsTypeI32 = WasmEdge_ValTypeIsI32(ValType);\n/* The `IsTypeI32` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenI64();\nbool IsTypeI64 = WasmEdge_ValTypeIsI64(ValType);\n/* The `IsTypeI64` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenF32();\nbool IsTypeF32 = WasmEdge_ValTypeIsF32(ValType);\n/* The `IsTypeF32` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenF64();\nbool IsTypeF64 = WasmEdge_ValTypeIsF64(ValType);\n/* The `IsTypeF64` will be `TRUE`. */\nValType = WasmEdge_ValTypeGenV128();\nbool IsTypeV128 = WasmEdge_ValTypeIsV128(ValType);\n/* The `IsTypeV128` will be `TRUE`. */\n```\n\n----------------------------------------\n\nTITLE: Building and Running the React 18 SSR Application - Bash\nDESCRIPTION: This snippet provides instructions for installing dependencies, building the application, and running the server with WasmEdge. It utilizes npm for managing packages and assumes the existence of a project structure defined in the previous JavaScript snippet.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run build\n```\n\nLANGUAGE: bash\nCODE:\n```\ncp -r ../../modules .\n```\n\nLANGUAGE: bash\nCODE:\n```\nnohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8002\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-go with Multiple Extensions in Go\nDESCRIPTION: Command to build WasmEdge-go with multiple extensions (Image and TensorFlow) enabled simultaneously.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image,tensorflow\n```\n\n----------------------------------------\n\nTITLE: Updated Invoke API Usage in WasmEdge-Go\nDESCRIPTION: Shows the updated usage of the Invoke() API in WasmEdge-Go v0.13.0, where the first wasmedge.Store parameter has been removed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n(wasmedge.Executor).Invoke()\n```\n\n----------------------------------------\n\nTITLE: Setting Cost Table and Limit in WasmEdge with Go\nDESCRIPTION: This code snippet demonstrates how to set a cost table and cost limit for WasmEdge statistics using the `wasmedge.Statistics` object in Go. It initializes a statistics object, defines a cost table for instructions, sets the cost table, and sets a cost limit.  The example also includes a C style function call which is not fully implemented.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_25\n\nLANGUAGE: go\nCODE:\n```\n```c\n   stat := wasmedge.NewStatistics()\n\n   costtable := []uint64{\n     0, 0,\n     10, /* 0x02: Block */\n     11, /* 0x03: Loop */\n     12, /* 0x04: If */\n     12, /* 0x05: Else */\n     0, 0, 0, 0, 0, 0,\n     20, /* 0x0C: Br */\n     21, /* 0x0D: Br_if */\n     22, /* 0x0E: Br_table */\n     0,\n   }\n   // Developers can set the costs of each instruction. The value not covered will be 0.\n\n   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\n   stat.SetCostTable()\n   stat.SetCostLimit(5000000)\n\n   // ... After running the WASM functions with the `Statistics` object\n   cost := stat.GetTotalCost()\n   stat.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Definition of the WasmEdge_Limit struct that represents WASM limits with minimum and maximum values, along with flags for maximum value presence and shared memory status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Hyper Server Dependencies Configuration\nDESCRIPTION: Cargo.toml configuration for hyper server showing required dependencies and patches for WasmEdge compatibility\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\nhyper = { version = \"0.14\", features = [\"full\"]}\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\", \"io-util\"]}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Definition\nDESCRIPTION: Example WebAssembly Text Format (WAT) module that imports and uses a host function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_58\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Running JavaScript-based Server in Docker and Testing\nDESCRIPTION: This example demonstrates running a JavaScript-based HTTP server using node.js API in a Docker container. It shows how to start the server and test it with a POST request.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_docker.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest\n\n$ curl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\n```\n\n----------------------------------------\n\nTITLE: Building and Installing crun with WasmEdge Support\nDESCRIPTION: Commands to clone, configure, build, and install crun from source with WasmEdge support enabled. This is necessary for platforms where pre-built packages with WasmEdge support are not available.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instances from VM Context (Pre-0.12.0)\nDESCRIPTION: Example of retrieving module instances from a VM context before version 0.12.0, using host registration enums and store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(Conf,\n                                      WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\nWasmEdge_ModuleInstance *WASIModInst =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_ModuleInstance *WASICryptoCommonModInst =\n    WasmEdge_VMGetImportModuleContext(\n        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\n\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\nWasmEdge_String ModName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_crypto_kx\");\nconst WasmEdge_ModuleInstance *WASICryptoKxModInst =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling Tokio Networking App to WebAssembly\nDESCRIPTION: Cargo build command with special configuration flags for compiling Tokio-based networking applications to WebAssembly\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Installing yurtctl for OpenYurt Management\nDESCRIPTION: This snippet covers the download and build process of the yurtctl command-line tool from the OpenYurt GitHub repository. It assists in managing and deploying OpenYurt components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/openyurtio/openyurt.git\ncd openyurt\nmake build WHAT=cmd/yurtctl\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge C++ Example\nDESCRIPTION: This bash command demonstrates how to compile a C++ example using the WasmEdge SDK. It specifies include directories, library directories, and links against the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c++/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngcc example.cpp -x c++ -I/path/to/wasmedge/include -L/path/to/wasmedge/lib -lwasmedge -o example\n```\n\n----------------------------------------\n\nTITLE: Running inference with WasmEdge\nDESCRIPTION: This command executes the `llama-chat.wasm` application within WasmEdge, using the specified GGML model. The `--dir` option maps the current directory to the WASM filesystem, and `--nn-preload` tells WasmEdge to load the LLM model using the WASI-NN plugin. `-p` specifies the prompt template.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge C++ SDK Example\nDESCRIPTION: This bash command demonstrates how to compile a C++ program using the WasmEdge SDK. It specifies include directories, library directories, and links against the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c++/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngcc example.cpp -x c++ -I/path/to/wasmedge/include -L/path/to/wasmedge/lib -lwasmedge -o example\n```\n\n----------------------------------------\n\nTITLE: Compiling and Executing With GCC\nDESCRIPTION: A bash command sequence to compile and execute a C program that uses the WasmEdge SDK. The compilation command uses 'gcc' and links against the 'wasmedge' library, resulting in an executable that can run standalone C code invoking WebAssembly functions. The process outputs results of '(123 + 456)^2' and '77^2 + 88^2' to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the '(123 + 456)^2' result: 335241\nGet the '77^2 + 88^2' result: 13673\n\n```\n\n----------------------------------------\n\nTITLE: Running Standalone WASM Rust Application with Podman\nDESCRIPTION: Execute a containerized Rust WebAssembly application using Podman runtime with WASI platform support\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npodman --runtime /usr/bin/crun-wasm run --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-hello:latest\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Text Format Example for Host Function Testing\nDESCRIPTION: A simple WebAssembly module in WAT format that imports a host function named 'trap' from the 'extern' module and exports a wrapper function to call it with a parameter.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_61\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32)))\n  (import \"extern\" \"trap\" (func $f-trap (type $t0)))\n  (func (export \"trap\") (param i32)\n    local.get 0\n    call $f-trap))\n```\n\n----------------------------------------\n\nTITLE: Creating KinD Node Image with WasmEdge Support\nDESCRIPTION: Dockerfile for creating a custom KinD node image with WasmEdge support. This replaces the default runc with the previously built crun and configures containerd appropriately.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_3\n\nLANGUAGE: Dockerfile\nCODE:\n```\n...\n\nFROM kindest/node:v1.23.0\n\nCOPY config.toml /etc/containerd/config.toml\nCOPY --from=builder /data/crun/crun /usr/local/sbin/runc\nCOPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so\n\nRUN echo \"Installing Packages ...\" \\\n    && bash -c 'cat <<< $(jq \"del(.hooks.createContainer)\" /etc/containerd/cri-base.json) > /etc/containerd/cri-base.json' \\\n    && ldconfig\n```\n\n----------------------------------------\n\nTITLE: Reloading Docker Daemon and Testing CDI Setup\nDESCRIPTION: Commands to reload the Docker daemon after configuration changes and test the CDI setup by running a container with GPU access. This verifies that containers can access GPU devices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Reload docker daemon\n> sudo systemctl reload docker\n\n# Test your cdi setup good\n> docker run --rm --device nvidia.com/gpu=all ubuntu:22.04 nvidia-smi -L\n\n# Example output \nGPU 0: NVIDIA GeForce GTX 1080 (UUID: GPU-********-****-****-****-************)\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI Environment in Rust Library Functions\nDESCRIPTION: These Rust function snippets demonstrate how to use the _initialize() function from the wasmedge-wasi-helper crate to properly set up the WASI environment in library functions that don't have a main() entry point.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub fn print_env() -> i32 {\n  _initialize();\n  ... ...\n}\n\npub fn create_file(path: &str, content: &str) -> String {\n  _initialize();\n  ... ...\n}\n\npub fn read_file(path: &str) -> String {\n  _initialize();\n  ... ...\n}\n\npub fn del_file(path: &str) -> String {\n  _initialize();\n  ... ...\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Records (Rust)\nDESCRIPTION: This Rust code inserts multiple records into the `orders` table in the MySQL database. It uses parameterized queries to prevent SQL injection and batches the inserts for performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n    let orders = vec![\n        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(\"Mataderos 2312\")),\n        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(\"1234 NW Bobcat\")),\n        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(\"20 Havelock\")),\n        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(\"224 Pandan Loop\")),\n        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(\"No.10 Jalan Besar\")),\n    ];\n\n    r\"INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address)\n      VALUES (:order_id, :production_id, :quantity, :amount, :shipping, :tax, :shipping_address)\"\n        .with(orders.iter().map(|order| {\n            params! {\n                \"order_id\" => order.order_id,\n                \"production_id\" => order.production_id,\n                \"quantity\" => order.quantity,\n                \"amount\" => order.amount,\n                \"shipping\" => order.shipping,\n                \"tax\" => order.tax,\n                \"shipping_address\" => &order.shipping_address,\n            }\n        }))\n        .batch(&mut conn)\n        .await?;\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Input Tensor Preparation in Rust\nDESCRIPTION: Example of preparing input tensors for TensorFlow model inference\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// The flat_img is a vec<f32> which contains normalized image in rgb32f format.\nsession.add_input(\"input\", &flat_img, &[1, 224, 224, 3])\n       .add_output(\"MobilenetV2/Predictions/Softmax\");\n```\n\n----------------------------------------\n\nTITLE: Testing a Node.js WebAssembly Server with curl\nDESCRIPTION: Shell command to test the Node.js server running in WebAssembly by sending a POST request with curl. This demonstrates the server's ability to process and respond to HTTP requests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ curl -X POST http://127.0.0.1:8001 -d \"WasmEdge\"\necho:WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu 22.04 in Bash\nDESCRIPTION: Commands to install necessary tools, libraries, and compilers for building WasmEdge on Ubuntu 22.04.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/linux.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Tools and libraries\nsudo apt install -y \\\n   software-properties-common \\\n   cmake\n\n# And you will need to install llvm for the AOT runtime\nsudo apt install -y \\\n   llvm-14-dev \\\n   liblld-14-dev\n\n# WasmEdge supports both clang++ and g++ compilers.\n# You can choose one of them to build this project.\n# If you prefer GCC, then:\nsudo apt install -y gcc g++\n# Or if you prefer clang, then:\nsudo apt install -y clang-14\n```\n\n----------------------------------------\n\nTITLE: Implementing Google Test Case for WasmEdge Plugin\nDESCRIPTION: Example implementation of a test case using Google Test framework to verify string conversion functionality in a WasmEdge plugin. Shows basic test structure with assertions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/test_plugin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"gtest/gtest.h\"\n#include \"your_plugin.h\"\n\nTEST(YourPluginTest, ConvertsNormalString) {\nYourPlugin plugin;\nstd::string input = \"123\";\nint expected = 123;\nEXPECT_EQ(expected, plugin.convert(input));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up HTTP Server for React 18 SSR - JavaScript\nDESCRIPTION: This snippet initializes a non-blocking HTTP server that serves CSS and HTML for a React SSR app. It fetches data asynchronously using promises and streams the response back as the server handles requests. Dependencies include React, and the std module for handling file input.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { createServer } from 'http';\nimport * as std from 'std';\n\nimport App from './component/App.js';\nimport { DataProvider } from './component/data.js';\n\nlet assets = {\n  'main.js': '/main.js',\n  'main.css': '/main.css',\n};\n\nconst css = std.loadFile('./public/main.css');\n\nfunction createServerData() {\n  let done = false;\n  let promise = null;\n  return {\n    read() {\n      if (done) {\n        return;\n      }\n      if (promise) {\n        throw promise;\n      }\n      promise = new Promise((resolve) => {\n        setTimeout(() => {\n          done = true;\n          promise = null;\n          resolve();\n        }, 2000);\n      });\n      throw promise;\n    },\n  };\n}\n\ncreateServer((req, res) => {\n  print(req.url);\n  if (req.url == '/main.css') {\n    res.setHeader('Content-Type', 'text/css; charset=utf-8');\n    res.end(css);\n  } else if (req.url == '/favicon.ico') {\n    res.end();\n  } else {\n    res.setHeader('Content-type', 'text/html');\n\n    res.on('error', (e) => {\n      print('res error', e);\n    });\n    let data = createServerData();\n    print('createServerData');\n\n    const stream = renderToPipeableStream(\n      <DataProvider data={data}>\n        <App assets={assets} />\n      </DataProvider>,\n      {\n        onShellReady: () => {\n          stream.pipe(res);\n        },\n        onShellError: (e) => {\n          print('onShellError:', e);\n        },\n      },\n    );\n  }\n}).listen(8002, () => {\n  print('listen 8002...');\n});\n```\n\n----------------------------------------\n\nTITLE: WASM Module Registration - Post v0.10.0\nDESCRIPTION: Demonstrates the new Register() API in WasmEdge-Go v0.10.0 for module registration with manual instance management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST\nmod, err := executor.Register(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n}\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing Import Type Context in C\nDESCRIPTION: Example of working with Import Type context to access import information from AST Module, including external types and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instances from VM Context (Pre-v0.12.0)\nDESCRIPTION: Example of retrieving module instances from the VM context before version 0.12.0, using wasmedge.HostRegistration const values and store object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nconf := wasmedge.NewConfigure(wasmedge.WASI)\ncomf.AddConfig(wasmedge.WasiCrypto_Common)\ncomf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)\ncomf.AddConfig(wasmedge.WasiCrypto_Kx)\ncomf.AddConfig(wasmedge.WasiCrypto_Signatures)\ncomf.AddConfig(wasmedge.WasiCrypto_Symmetric)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nwasimod := vm.GetImportModule(wasmedge.WASI)\ncryptocommonmod := vm.GetImportModule(wasmedge.WasiCrypto_Common)\n\nstore := vm.GetStore()\ncryptokxmod := store.FindModule(\"wasi_ephemeral_crypto_kx\")\n\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Active Module Instance in C\nDESCRIPTION: Shows how to get the active module instance after WASM instantiation. This provides access to the module's exports and other internal details.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Working with V128 SIMD Values\nDESCRIPTION: Example of creating and manipulating V128 values for SIMD operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Loadable Plug-in Loading Process\nDESCRIPTION: A mermaid flowchart depicting the process of loading loadable plug-ins into the WasmEdge runtime environment from specific paths, including default paths, specific paths, and directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    A((Start)) --> B(Loadable Plug-ins)\n    B --> C{Load Plug-ins}\n    C --> D[Load from Default Paths]\n    C --> E[Load from Specific Path]\n    C --> F[Load from Specific Directory]\n    D --> G{Is Plug-in Found?}\n    E --> G\n    F --> G\n    G -- Yes --> H(Load Plug-in)\n    H --> I(End)\n    G -- No --> I\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Example of registering host modules into a VM context using WasmEdge's module registration API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n  WasmEdge_ModuleInstanceCreateWASI( /* ... ignored ... */ );\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/* The created module instances should be deleted by the developers when the VM deallocation. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WebAssembly SIMD in Ahead-of-Time Mode\nDESCRIPTION: These commands demonstrate how to use WasmEdge's Ahead-of-Time (AoT) compiler to compile the WebAssembly SIMD binary for higher performance, and then run the compiled binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/simd.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Compile wasm-simd with wasmedge aot compiler\n$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm\n# Run the native binary with wasmedge\n$ wasmedge mandelbrot-simd-out.wasm 15000\n```\n\n----------------------------------------\n\nTITLE: Using Instruction Counter in WasmEdge Statistics\nDESCRIPTION: This Go code snippet illustrates acquiring instruction counts to profile WebAssembly module performance using WasmEdge statistics. Dependencies include the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_25\n\nLANGUAGE: Go\nCODE:\n```\nstat := wasmedge.NewStatistics()\n// ... After running the WASM functions with the `Statistics` object\n\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Functions with wasmedge-bindgen\nDESCRIPTION: Example Rust code demonstrating the use of wasmedge-bindgen macros to annotate functions for WebAssembly compatibility. Includes functions for string manipulation, mathematical operations, and cryptographic hashing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/wasm-app-in-rust.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\nuse num_integer::lcm;\nuse sha3::{Digest, Sha3_256, Keccak256};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n  x: f32,\n  y: f32\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n  points: Vec<Point>,\n  valid: bool,\n  length: f32,\n  desc: String\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> Result<Vec<u8>, String> {\n  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();\n  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();\n  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();\n\n  let valid = if length == 0.0 { false } else { true };\n\n  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };\n\n  return Ok(serde_json::to_vec(&line).unwrap());\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> Result<Vec<u8>, String> {\n  let r = String::from(\"hello \");\n  return Ok((r + s.as_str()).as_bytes().to_vec());\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> Result<Vec<u8>, String> {\n  let r: String = (&s).chars().map(|c| {\n    match c {\n      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,\n      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,\n      _ => c\n    }\n  }).collect();\n  Ok(r.as_bytes().to_vec())\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> Result<Vec<u8>, String> {\n  let r = lcm(a, b);\n  return Ok(r.to_string().as_bytes().to_vec());\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Result<Vec<u8>, String> {\n  return Ok(Sha3_256::digest(&v).as_slice().to_vec());\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Result<Vec<u8>, String> {\n  return Ok(Keccak256::digest(&s).as_slice().to_vec());\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Kubernetes Cluster to OpenYurt\nDESCRIPTION: Command to convert a standard Kubernetes cluster to an OpenYurt cluster using yurtctl. It deploys various OpenYurt components including YurtHub, Yurt controller, and Yurt tunnel services.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nyurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\\\n--yurt-controller-manager-image=\"openyurt/yurt-controller-manager:v0.5.0\"\\\n--yurt-tunnel-agent-image=\"openyurt/yurt-tunnel-agent:v0.5.0\"\\\n--yurt-tunnel-server-image=\"openyurt/yurt-tunnel-server:v0.5.0\"\\\n--node-servant-image=\"openyurt/node-servant:latest\"\\\n--yurthub-image=\"openyurt/yurthub:v0.5.0\"\n```\n\n----------------------------------------\n\nTITLE: Compiling C File with WasmEdge\nDESCRIPTION: Compile a C file to test the WasmEdge C API availability using 'gcc'. Assumes the file is named 'test.c' and has been saved correctly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngcc test.c -lwasmedge\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application\nDESCRIPTION: Commands to install the WasmEdge Go SDK, build the application, and run it. Shows the expected output from executing the WebAssembly function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_65\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Pulling and running a WebAssembly HTTP server in containerd\nDESCRIPTION: Commands to pull a WebAssembly-based HTTP server container from Docker Hub and run it using containerd with crun runtime. The example shows how to run a network-enabled application with host networking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo ctr i pull docker.io/wasmedge/example-wasi-http:latest\nsudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi-http:latest http-server-example /http_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Initializing Dapr Runtime\nDESCRIPTION: Command to initialize the Dapr runtime environment\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/dapr.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndapr init\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Function Type Context in Go\nDESCRIPTION: Shows how to create and manipulate function type contexts for defining parameter and return value types in WASM functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\n// `plen` will be 3.\nrlen := functype.GetReturnsLength()\n// `rlen` will be 2.\nplist := functype.GetParameters()\n// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.\nrlist := functype.GetReturns()\n// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go for WasmEdge\nDESCRIPTION: Defines the function signature for host functions in WasmEdge. Host functions take a data interface, calling frame, and parameters, and return a slice of interfaces and a Result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: Displaying WasmEdge Compile Command Help in Bash\nDESCRIPTION: Shows how to display the help message for the 'wasmedge compile' command, which provides information about its usage and options.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile -h\nUSAGE\n   wasmedge compile [OPTIONS] [--] WASM WASM_SO\n\n...\n```\n\n----------------------------------------\n\nTITLE: WASM Module Registration - Pre v0.10.0\nDESCRIPTION: Shows module registration with a name using RegisterModule() API in WasmEdge-Go v0.9.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST\nerr := executor.RegisterModule(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Model Inference with WasmEdge CLI\nDESCRIPTION: This snippet downloads OpenVINO model files and performs inference using WasmEdge CLI. It demonstrates running the inference application by specifying model and input image files, and it produces a class prediction output. Requires WasmEdge CLI and model files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./download_mobilenet.sh\nwasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Rapid Execution Example\nDESCRIPTION: Bash commands demonstrating how to compile the C code with WasmEdge library and run the resulting executable to calculate the 5th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 8\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Import Types in Go\nDESCRIPTION: Shows how to handle import type contexts for accessing WebAssembly module import information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nimptypelist := ast.ListImports()\n// Assume that `imptypelist` is an array listed from the `ast` for the imports.\n\nfor i, imptype := range imptypelist {\n  exttype := imptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  modname := imptype.GetModuleName()\n  extname := imptype.GetExternalName()\n  // Get the module name and external name of the imports.\n\n  extval := imptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Fibonacci Function in WebAssembly\nDESCRIPTION: This WebAssembly code snippet defines a module that calculates Fibonacci numbers. The function 'fib' checks if the input is less than 2; if so, it returns 1, otherwise, it recursively calls itself to compute Fibonacci values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_25\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Basic HTTP Server Implementation in Rust\nDESCRIPTION: A basic HTTP server implementation that echoes back incoming requests using WasmEdge socket API\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/server.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bytecodec::DecodeExt;\nuse httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};\nuse std::io::{Read, Write};\n#[cfg(feature = \"std\")]\nuse std::net::{Shutdown, TcpListener, TcpStream};\n#[cfg(not(feature = \"std\"))]\nuse wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};\n\nfn handle_http(req: Request<String>) -> bytecodec::Result<Response<String>> {\n  Ok(Response::new(\n    HttpVersion::V1_0,\n    StatusCode::new(200)?,\n    ReasonPhrase::new(\"\")?,\n    format!(\"echo: {}\", req.body()),\n  ))\n}\n\nfn handle_client(mut stream: TcpStream) -> std::io::Result<()> {\n  let mut buff = [0u8; 1024];\n  let mut data = Vec::new();\n\n  loop {\n    let n = stream.read(&mut buff)?;\n    data.extend_from_slice(&buff[0..n]);\n    if n < 1024 {\n      break;\n    }\n  }\n\n  let mut decoder =\n    RequestDecoder::<httpcodec::BodyDecoder<bytecodec::bytes::Utf8Decoder>>::default();\n\n  let req = match decoder.decode_from_bytes(data.as_slice()) {\n    Ok(req) => handle_http(req),\n    Err(e) => Err(e),\n  };\n\n  let r = match req {\n    Ok(r) => r,\n    Err(e) => {\n      let err = format!(\"{:?}\", e);\n      Response::new(\n        HttpVersion::V1_0,\n        StatusCode::new(500).unwrap(),\n        ReasonPhrase::new(err.as_str()).unwrap(),\n        err.clone(),\n      )\n    }\n  };\n\n  let write_buf = r.to_string();\n  stream.write(write_buf.as_bytes())?;\n  stream.shutdown(Shutdown::Both)?;\n  Ok(())\n}\n\nfn main() -> std::io::Result<()> {\n  let port = std::env::var(\"PORT\").unwrap_or(1234.to_string());\n  println!(\"new connection at {}\", port);\n  let listener = TcpListener::bind(format!(\"0.0.0.0:{}\", port))?;\n  loop {\n    let _ = handle_client(listener.accept()?.0);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Running TensorFlow Example\nDESCRIPTION: Commands to clone the WasmEdge-WASINN-examples repository and run the pre-compiled TensorFlow Lite bird classification example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/tflite-birds_v1-image/\n```\n\n----------------------------------------\n\nTITLE: Host Function Error Handling - Pre v0.11.0\nDESCRIPTION: Example of basic host function error handling before WasmEdge v0.11.0, which only supported generic failure results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM. */\n  return WasmEdge_Result_Fail;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Memory Pages in Go\nDESCRIPTION: Example of setting and getting the maximum memory page size limit for WebAssembly instances, which restricts memory growth during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\npagesize := conf.GetMaxMemoryPage()\n// By default, the maximum memory page size in each memory instances is 65536.\nconf.SetMaxMemoryPage(1234)\npagesize = conf.GetMaxMemoryPage()\n// `pagesize` will be 1234.\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Checking Golang Version in Bash\nDESCRIPTION: Command to check the installed Golang version. WasmEdge-go requires Golang version >= 1.16.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge C API with GCC\nDESCRIPTION: Demonstrates how to compile a C program using WasmEdge API to display the current version. It requires WasmEdge header files and linking with 'libwasmedge_c'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: SIMD Value Type Handling\nDESCRIPTION: Example of working with v128 SIMD values in WasmEdge-Go\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: WASM Function Invocation - Pre v0.10.0\nDESCRIPTION: Complete example of loading, validating, and invoking a WASM function in version 0.9.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nstore := wasmedge.NewStore()\nvar err error\nvar ast *wasmedge.AST\nvar res []interface{}\nloader := wasmedge.NewLoader()\nvalidator := wasmedge.NewValidator()\nexecutor := wasmedge.NewExecutor()\nast, err = loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n  return\n}\nerr = validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n  return\n}\nerr = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\nres, err = executor.Invoke(store, \"fib\", int32(30))\nif err == nil {\n  fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n} else {\n  fmt.Println(\"Run failed:\", err.Error())\n}\nast.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\nstore.Release()\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Definition with Host Function Import\nDESCRIPTION: Example WebAssembly module in WAT format that imports an external function for addition and exports a wrapper function. This demonstrates how WebAssembly modules can leverage host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_67\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Server-Side Rendering\nDESCRIPTION: Webpack configuration for bundling the server-side rendering code, including Babel transpilation and handling of CSS and SVG assets.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst path = require('path');\nmodule.exports = {\n  entry: './server/index.js',\n  externals: [\n    { wasi_http: 'wasi_http' },\n    { wasi_net: 'wasi_net' },\n    { std: 'std' },\n  ],\n  output: {\n    path: path.resolve('server-build'),\n    filename: 'index.js',\n    chunkFormat: 'module',\n    library: {\n      type: 'module',\n    },\n  },\n  experiments: {\n    outputModule: true,\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: 'babel-loader',\n      },\n      {\n        test: /\\.css$/,\n        use: ['css-loader'],\n      },\n      {\n        test: /\\.svg$/,\n        use: ['svg-url-loader'],\n      },\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Installing CRI-O on Ubuntu 20.04\nDESCRIPTION: This bash script installs CRI-O version 1.21 on Ubuntu 20.04. It adds the necessary repositories, installs dependencies, and starts the CRI-O service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OS=\"xUbuntu_20.04\"\nexport VERSION=\"1.21\"\napt update\napt install -y libseccomp2 || sudo apt update -y libseccomp2\necho \"deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\necho \"deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /\" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list\n\ncurl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -\ncurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -\n\napt-get update\napt-get install criu libyajl2\napt-get install cri-o cri-o-runc cri-tools containernetworking-plugins\nsystemctl start crio\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance from Plug-in (Post-v0.12.0)\nDESCRIPTION: Example of creating a module instance from a plug-in after version 0.12.0, using the new general API with the wasmedge.Plugin struct.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\ncryptoplugin := wasmedge.FindPlugin(\"wasi_crypto\")\nif ctyptoplugin == nil {\n  fmt.Println(\"FAIL: Cannot find the wasi_crypto plugin.\")\n  return\n}\n\ncryptocommonmod := cryptoplugin.CreateModule(\"wasi_crypto_common\")\n\ncryptocommonmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Node.js WebAssembly Server in Docker\nDESCRIPTION: Shell commands to build and run a Docker container with a Node.js application running in WebAssembly. The commands set up port forwarding to make the server accessible from the host.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 8001:8001 wasmedge/myapp\nlisten 8001 ...\n```\n\n----------------------------------------\n\nTITLE: Installing PyTorch 1.8.2 on CentOS 7.6\nDESCRIPTION: Commands to download and extract PyTorch 1.8.2 LTS for CentOS 7.6, using the pre-cxx11-abi version of libtorch. This sets up the necessary environment variables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport PYTORCH_VERSION=\"1.8.2\"\ncurl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\nunzip -q \"libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nrm -f \"libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nexport LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}\nexport Torch_DIR=$(pwd)/libtorch\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Text Format for Host Function Example\nDESCRIPTION: This snippet shows the WebAssembly text format (WAT) representation of the binary WASM module used in the examples. It defines a module that imports an external addition function and exports a wrapper function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_70\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Setting Up Network Security Parameters for Kubernetes\nDESCRIPTION: Commands to adjust the rp_filter values and IP forwarding for Kubernetes networking. These settings are required for proper packet routing in the cluster.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo vi /etc/sysctl.d/10-network-security.conf\necho 1 > /proc/sys/net/ipv4/ip_forward\nsudo sysctl --system\n```\n\n----------------------------------------\n\nTITLE: Running a WASM application with WasmEdge\nDESCRIPTION: A command to execute a WASM application (hello.wasm) using the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge hello.wasm\nHello WasmEdge!\n```\n\n----------------------------------------\n\nTITLE: Handling WasmEdge Results in C\nDESCRIPTION: Illustrates how to handle the execution results in WasmEdge using WasmEdge_Result objects to check statuses and retrieve messages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\nuint32_t Code = WasmEdge_ResultGetCode(Res);\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n```\n\n----------------------------------------\n\nTITLE: Manual Installation Setup for WasmEdge on seL4\nDESCRIPTION: This code series demonstrates the manual installation process for WasmEdge on seL4, including cloning the repository, editing the build script to manage memory usage, and executing the build.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ~\ngit clone https://github.com/second-state/wasmedge-seL4.git\ncd wasmedge-seL4\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version with C API\nDESCRIPTION: This C code snippet demonstrates how to use the WasmEdge C API to retrieve and print the WasmEdge version. It includes the necessary header file and uses the `WasmEdge_VersionGet()` function to get the version string.  The output is printed to the console using `printf`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n\"#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\"\n```\n\n----------------------------------------\n\nTITLE: Building crun with WasmEdge Support\nDESCRIPTION: Commands to build crun with WasmEdge support from source. This custom runtime is needed for running WebAssembly modules in containers with GPU access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake\n\n> git clone https://github.com/containers/crun\n> cd crun\n> ./autogen.sh\n> ./configure --with-wasmedge\n> make\n\n# Check your crun\n> ./crun --version\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C for WasmEdge\nDESCRIPTION: The function signature for defining host functions in WasmEdge. Host functions receive data, memory context, parameters, and return values, and must return a WasmEdge_Result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n  void *Data,\n  WasmEdge_MemoryInstanceContext *MemCxt,\n  const WasmEdge_Value *Params,\n  WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: WASM Loading Post-0.14.0 Example\nDESCRIPTION: Example demonstrating WASM binary loading using new WasmEdge_Bytes API in version 0.14.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nuint8_t WASM[] = {/* WASM header */\n                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                  /* Type section */\n                  0x01, 0x07, 0x01,\n                  /* function type {i32, i32} -> {i32} */\n                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                  /* Import section */\n                  0x02, 0x13, 0x01,\n                  /* module name: \"extern\" */\n                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                  /* extern name: \"func-add\" */\n                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                  /* import desc: func 0 */\n                  0x00, 0x00,\n                  /* Function section */\n                  0x03, 0x02, 0x01, 0x00,\n                  /* Export section */\n                  0x07, 0x0A, 0x01,\n                  /* export name: \"addTwo\" */\n                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                  /* export desc: func 0 */\n                  0x00, 0x01,\n                  /* Code section */\n                  0x0A, 0x0A, 0x01,\n                  /* code body */\n                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n/* Wrap onto the `WASM`. */\nWasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));\n/*\n * If developers want to copy from buffer, use the `WasmEdge_BytesCreate()`\n * instead. The created `WasmEdge_Bytes` should be destroyed.\n */\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with TensorflowLite Plugin Support\nDESCRIPTION: Commands to build WasmEdge from source with TensorflowLite plugin support enabled. This process includes configuring the build with cmake, compiling the project, and installing the binaries to the system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On\ncmake --build build\n# For the WasmEdge-TensorflowLite plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Running bootstrap example with WasmEdge and wasm_bpf plugin\nDESCRIPTION: Command to execute the bootstrap.wasm file using WasmEdge with the wasm_bpf plugin. The WASMEDGE_PLUGIN_PATH environment variable specifies the location of the plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/bpf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nWASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ wasmedge bootstrap.wasm\n```\n\n----------------------------------------\n\nTITLE: Use Grayscale Microservice\nDESCRIPTION: This command uses the grayscale microservice to process an image. It sends a POST request with binary image data to the microservice and receives a base64 encoded grayscale image as a response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ cd docs\n$ curl http://localhost:9005/grayscale -X POST --data-binary '@food.jpg'\nABCDEFG ...\n```\n\n----------------------------------------\n\nTITLE: Installing OpenVINO Dependencies on Ubuntu 20.04\nDESCRIPTION: Commands to install OpenVINO dependencies for the WASI-NN OpenVINO backend on Ubuntu 20.04.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\nsudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\necho \"deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main\" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list\nsudo apt update\nsudo apt-get -y install openvino\nldconfig\n```\n\n----------------------------------------\n\nTITLE: Store Context Management in WasmEdge VM\nDESCRIPTION: Demonstrates creating and managing Store contexts within a VM context, showing both VM-owned and externally managed Store lifecycle patterns.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Array Functions in TinyGo\nDESCRIPTION: This TinyGo code defines two functions: `fibArray` which fills a provided array with a Fibonacci sequence, and `fibArrayReturnMemory` which allocates and returns an array containing the Fibonacci sequence. These functions are exported for use in a WasmEdge environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"unsafe\"\n)\n\nfunc main() {\n  println(\"in main\")\n  n := int32(10)\n  arr := make([]int32, n)\n  arrP := &arr[0]\n  fmt.Printf(\"call fibArray(%d, %p) = %d\\n\", n, arrP, fibArray(n, arrP))\n  fmt.Printf(\"call fibArrayReturnMemory(%d) return %p\\n\", n, fibArrayReturnMemory(n))\n}\n\n// export fibArray\nfunc fibArray(n int32, p *int32) int32 {\n  arr := unsafe.Slice(p, n)\n  for i := int32(0); i < n; i++ {\n    switch {\n    case i < 2:\n      arr[i] = i\n    default:\n      arr[i] = arr[i-1] + arr[i-2]\n    }\n  }\n  return arr[n-1]\n}\n\n// export fibArrayReturnMemory\nfunc fibArrayReturnMemory(n int32) *int32 {\n  arr := make([]int32, n)\n  for i := int32(0); i < n; i++ {\n    switch {\n    case i < 2:\n      arr[i] = i\n    default:\n      arr[i] = arr[i-1] + arr[i-2]\n    }\n  }\n  return &arr[0]\n}\n```\n\n----------------------------------------\n\nTITLE: WASM Module Instantiation - Post v0.10.0\nDESCRIPTION: Demonstrates the new module instantiation approach in WasmEdge-Go v0.10.0 where multiple anonymous modules can be instantiated and must be manually released.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nvar ast1 *wasmedge.AST\nvar ast2 *wasmedge.AST\nmod1, err1 := executor.Instantiate(store, ast1)\nif err1 != nil {\n  fmt.Println(\"Instantiation FAILED:\", err1.Error())\n}\nmod2, err2 := executor.Instantiate(store, ast2)\nif err2 != nil {\n  fmt.Println(\"Instantiation FAILED:\", err2.Error())\n}\nmod1.Release()\nmod2.Release()\n```\n\n----------------------------------------\n\nTITLE: Executing Interpreted WebAssembly in Bash\nDESCRIPTION: Shows how to execute a WebAssembly file 'fibonacci.wasm' in interpreter mode using WasmEdge, calling the 'fib' function with argument 30.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntime wasmedge --reactor fibonacci.wasm fib 30\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge C API Installation\nDESCRIPTION: Basic C program to test the WasmEdge installation by printing the version number using the C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Host Registrations in Configuration\nDESCRIPTION: Demonstrate adding and checking host registrations in the WasmEdge configuration context\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                     WasmEdge_HostRegistration_Wasi);\n```\n\n----------------------------------------\n\nTITLE: Building Rust WASM Project\nDESCRIPTION: Cargo command to build the Rust project targeting WebAssembly with WASI support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Getting Plug-in Context by Name in Go\nDESCRIPTION: This snippet shows how to obtain the context of a specific WasmEdge plug-in by its name using `FindPlugin`. It is assumed that the plug-in is located in the default paths.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Assume that wasi_crypto plug-in is installed in the default plug-in path.\nwasmedge.LoadPluginDefaultPaths()\nplugincrypto := wasmedge.FindPlugin(\"wasi_crypto\")\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution Completion in WasmEdge C\nDESCRIPTION: This C code snippet demonstrates how to wait for the completion of an asynchronous execution using the WasmEdge API. It initially waits indefinitely until the execution is finished and then deletes the Async object. Dependencies include the WasmEdge C library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Buffer with WasmEdge Bytes\nDESCRIPTION: Demonstrates wrapping an existing buffer in a WasmEdge_Bytes object without copying its content.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4] = {1, 2, 3, 4};\nWasmEdge_Bytes Bytes = WasmEdge_BytesWrap(Buf, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_BytesDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Compiling and Executing the WasmEdge C Program\nDESCRIPTION: This bash snippet shows how to compile the C program that links WASM modules using WasmEdge and then execute it. It requires the WasmEdge library to be installed and available for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/multiple_modules.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the '(123 + 456)^2' result: 335241\nGet the '77^2 + 88^2' result: 13673\n```\n\n----------------------------------------\n\nTITLE: Downloading and Joining KubeEdge Edge Nodes\nDESCRIPTION: Commands to download KubeEdge, extract it, and join an edge node to the cluster. It includes specifying the cloudcore IP, edge node name, token, and runtime configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz\n$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz\n$ cd keadm-v1.8.0-linux-amd64/keadm/\n\n$ sudo ./keadm join \\\n--cloudcore-ipport=192.168.122.160:10000 \\\n--edgenode-name=edge \\\n--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \\\n--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \\\n--runtimetype=remote \\\n--cgroupdriver=systemd\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types in C\nDESCRIPTION: This snippet retrieves a function type from a VM context by its function name, allowing developers to access the characteristics of a function within a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_43\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered modules\n * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.\n * If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Apply YAML File for Wasm Job\nDESCRIPTION: This command applies a YAML file to deploy a WebAssembly job to the Kubernetes cluster. The YAML file is fetched from a remote URL on GitHub.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nkubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge Plug-in Context by Name in Go\nDESCRIPTION: Shows how to retrieve a WasmEdge plug-in context by its name using the FindPlugin function, assuming the wasi_crypto plug-in is installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\nplugincrypto := wasmedge.FindPlugin(\"wasi_crypto\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with ModuleInstance (WasmEdge 0.10.0+)\nDESCRIPTION: Shows how to create host functions and add them to a ModuleInstance in WasmEdge versions 0.10.0 and later. This updated approach provides a more consistent API with other WasmEdge components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Run WASI application in Kubernetes\nDESCRIPTION: This snippet deploys a simple WebAssembly WASI application from Docker Hub to the Kubernetes cluster as a container. It uses kubectl to create a pod with the specified image and annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Joining Edge Nodes to SuperEdge Kubernetes Cluster\nDESCRIPTION: Command to join edge nodes to the SuperEdge Kubernetes cluster using containerd runtime. The command requires cluster token and certificate hash information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./edgeadm join <Master Public/Intranet IP Or Domain>:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path <edgeadm kube-* install package address path> --enable-edge=true --runtime=containerd\n```\n\n----------------------------------------\n\nTITLE: Using Export Type Context in C\nDESCRIPTION: Shows how to use an Export Type context to retrieve information about exported modules, including external type and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n\nenum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Dependencies for WASI Random Number Generation\nDESCRIPTION: This snippet shows the necessary dependencies in Cargo.toml for using random number generation with WASI. It includes the 'rand' and 'getrandom' crates, which are configured to work with the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nrand = \"0.7.3\"\ngetrandom = \"0.1.14\"\n```\n\n----------------------------------------\n\nTITLE: Defining AOT Compiler Optimization Levels and Output Formats in Go\nDESCRIPTION: Constants for controlling the optimization level and output format in the Ahead-of-Time compiler for WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests in Bash\nDESCRIPTION: Commands to run the WasmEdge test suite after building, setting the necessary library path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/linux.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# In docker\ncd <path/to/wasmedge/build_folder>\nLD_LIBRARY_PATH=$(pwd)/lib/api ctest\n```\n\n----------------------------------------\n\nTITLE: Creating Host Module Instance\nDESCRIPTION: Example of creating a host module instance with a specified name.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String HostName = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_ModuleInstanceContext *HostMod =\n    WasmEdge_ModuleInstanceCreate(HostName);\nWasmEdge_StringDelete(HostName);\n```\n\n----------------------------------------\n\nTITLE: Building Rust Project for WasmEdge\nDESCRIPTION: Command to build the Rust project targeting WebAssembly using cargo.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/openvino.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Setting Up Kubernetes with kubeadm\nDESCRIPTION: Commands for installing kubeadm, creating a Kubernetes cluster, installing Flannel CNI, and configuring the crun RuntimeClass for WebAssembly support in Kubernetes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# install kubeadm\n$ sudo apt-get update\n$ sudo apt-get install -y apt-transport-https ca-certificates curl\n$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg\n$ echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list\n$ sudo apt-get update\n$ sudo apt-get install -y kubelet kubeadm kubectl\n$ sudo apt-mark hold kubelet kubeadm kubectl\n\n# create kubernetes cluster\n$ swapoff -a\n$ kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket unix:///var/run/containerd/containerd.sock\n$ export KUBECONFIG=/etc/kubernetes/admin.conf\n\n# install cni\n$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml\n\n# untaint master node\n$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-\n```\n\n----------------------------------------\n\nTITLE: Node.js WASM Build Stage\nDESCRIPTION: Dockerfile section that downloads and prepares WasmEdge JavaScript runtime and application files\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_5\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM buildbase AS build\nCOPY server.js .\nRUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\nRUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip\nRUN unzip modules.zip\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Example\nDESCRIPTION: Example WebAssembly module in WAT format demonstrating trap functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_66\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32)))\n  (import \"extern\" \"trap\" (func $f-trap (type $t0)))\n  (func (export \"trap\") (param i32)\n    local.get 0\n    call $f-trap))\n```\n\n----------------------------------------\n\nTITLE: Loading Plug-ins from Default Paths in Go\nDESCRIPTION: This snippet demonstrates how to load WasmEdge plug-ins from the default paths using the API `LoadPluginDefaultPaths()`. It prepares the runtime to access available plug-ins based on configured paths.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n```\n\n----------------------------------------\n\nTITLE: Importing and Using ES6 Modules\nDESCRIPTION: Main JavaScript file that demonstrates both static and dynamic imports of ES6 modules. It shows how to import and execute functions from modules, including handling async imports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/es6.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { hello as module_def_hello } from './module_def.js';\n\nmodule_def_hello();\n\nvar f = async () => {\n  let { hello, something } = await import('./module_def_async.js');\n  await hello();\n  console.log('./module_def_async.js `something` is ', something);\n};\n\nf();\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution with Timeout\nDESCRIPTION: This snippet shows how to wait for an asynchronous execution with a specified timeout. If the execution exceeds the limit, it cancels the operation and retrieves any available results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Container in Kubernetes 1.18.9\nDESCRIPTION: Command to run a WebAssembly container as a pod in Kubernetes 1.18.9 using kubectl. It includes necessary annotations and overrides for WasmEdge compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest  --overrides='{\"kind\":\"Pod\",\"metadata\":{\"annotations\":{\"module.wasm.image/variant\":\"compat-smart\"}} , \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Version Check\nDESCRIPTION: These commands demonstrate how to compile the WasmEdge version check program and run it to display the installed version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngcc test.c -lwasmedge\n./a.out\n```\n\n----------------------------------------\n\nTITLE: Deploy Classification Microservice with Dapr\nDESCRIPTION: This command deploys the image classification microservice with Dapr, configuring the application ID, protocol, ports, log level, components path, and the WasmEdge TensorFlow Lite runtime to execute the WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndapr run --app-id image-api-classify \\\n        --app-protocol http \\\n        --app-port 9006 \\\n        --dapr-http-port 3504 \\\n        --log-level debug \\\n        --components-path ../config \\\n        wasmedge-tensorflow-lite wasmedge_hyper_server_tflite.wasm\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling RustPython for Performance - Rust\nDESCRIPTION: This command compiles the RustPython WebAssembly binary into native machine code for enhanced performance during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile ./target/wasm32-wasip1/release/rustpython.wasm ./target/wasm32-wasip1/release/rustpython.wasm\n```\n\n----------------------------------------\n\nTITLE: Loading UDFs into libSQL\nDESCRIPTION: SQL commands to initialize Wasm function table and load the encrypt/decrypt UDFs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md#2025-04-21_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n./libsql\nlibsql> .init_wasm_func_table\nlibsql> .read create_encrypt_udf.sql\nlibsql> .read create_decrypt_udf.sql\n```\n\n----------------------------------------\n\nTITLE: WASI Initialization with WasmEdge-Go v0.10.0\nDESCRIPTION: Updated example showing WASI initialization using Module in WasmEdge-Go v0.10.0 after the API changes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\n\n// The following API can retrieve the pre-registration module instances from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasiobj := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasiobj.InitWasi(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:.\"},  // The mapping preopens\n)\n\n// ...\n\nvm.Release()\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker to Use Custom Crun Runtime in JSON\nDESCRIPTION: Docker daemon configuration that specifies a custom Crun runtime with the path to the built Crun binary. It also includes the CDI configuration from the previous setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"runtimes\": {\n    \"crun\": {\n      \"path\": \"<The crun binary path is built by yourself>\"\n    }\n  },\n  \"features\": {\n    \"cdi\": true\n  },\n  \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL on macOS with Homebrew\nDESCRIPTION: Command to install OpenSSL on macOS using the Homebrew package manager, which is required for building WasmEdge with WASI-Crypto support on macOS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install openssl\n```\n\n----------------------------------------\n\nTITLE: Building and Running a WebAssembly HTTP Server in Docker\nDESCRIPTION: Shell commands to build and run a Docker container with a WebAssembly HTTP server. The commands include port mapping to allow external access to the server running inside the container.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 1234:1234 wasmedge/myapp\nnew connection at 1234\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN MLX Backend\nDESCRIPTION: This snippet describes the commands to build WasmEdge from source with the MLX backend, detailing the CMake flags required.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"mlx\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C API Example\nDESCRIPTION: This bash snippet shows how to compile and run the C program that uses the WasmEdge C API to execute a WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Go application\nDESCRIPTION: This snippet shows how to get the WasmEdge-go package, build, and run the Go application. It assumes that the `main.go` file is in the current directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_57\n\nLANGUAGE: bash\nCODE:\n```\n\"$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n$ go build\n$ ./wasmedge_test\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function for STL Objects in WasmEdge\nDESCRIPTION: A host function that accesses std::ostream and std::string objects passed as externref parameters. This function demonstrates how to retrieve and cast externref values to C++ STL types to perform operations between them.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/externref.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n// Host function to output std::string through std::ostream\nWasmEdge_Result ExternSTLOStreamStr(void *,\n                                    const WasmEdge_CallingFrameContext *,\n                                    const WasmEdge_Value *In,\n                                    WasmEdge_Value *) {\n  // Function type: {externref, externref} -> {}\n  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);\n  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);\n  std::ostream &RefOS = *reinterpret_cast<std::ostream *>(Ptr0);\n  std::string &RefStr = *reinterpret_cast<std::string *>(Ptr1);\n  RefOS << RefStr;\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Memory Pages in WasmEdge\nDESCRIPTION: Shows how to limit the maximum memory size available to WebAssembly modules. This configuration restricts how much memory each instance can allocate by limiting the number of memory pages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Red Hat Systems\nDESCRIPTION: Single command installation of WasmEdge runtime, crun, and Podman for Fedora and Red Hat Linux systems\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndnf install wasmedge crun-wasm podman\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Invocation in Go\nDESCRIPTION: Demonstrates how to use the new AsyncInvoke() API to execute a WASM function asynchronously in WasmEdge-Go v0.13.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n(wasmedge.Executor).AsyncInvoke()\n```\n\n----------------------------------------\n\nTITLE: Handling WasmEdge Results in C API\nDESCRIPTION: Demonstrates the use of WasmEdge_Result to check execution status. Shows generation of success and user-defined results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be \"success\". */\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_WASM. */\n\nRes = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);\n/* Generate the user-defined result with code. */\nCode = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 123. */\nCategory = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge Go SDK\nDESCRIPTION: This bash code snippet demonstrates how to get the WasmEdge Go SDK. It retrieves the specified version of the WasmEdge Go package using the go get command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n```\n\n----------------------------------------\n\nTITLE: Legacy Plugin Configuration in VM (Pre-v0.12.0)\nDESCRIPTION: Example showing how to configure and load plugins in a VM using the old API style before v0.11.2, demonstrating manual plugin configuration and module listing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\nconf := wasmedge.NewConfigure(wasmedge.WASI)\ncomf.AddConfig(wasmedge.WasiCrypto_Common)\ncomf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)\ncomf.AddConfig(wasmedge.WasiCrypto_Kx)\ncomf.AddConfig(wasmedge.WasiCrypto_Signatures)\ncomf.AddConfig(wasmedge.WasiCrypto_Symmetric)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nstore := vm.GetStore()\nmodulelist := store.ListModule()\nfor _, name := range modulelist {\n  fmt.Println(name)\n}\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Binary with WasmEdge_Bytes in C (0.14.0)\nDESCRIPTION: Updated example of loading a WASM binary using WasmEdge_Bytes in WasmEdge 0.14.0. This is the recommended approach for buffer handling in the new version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nuint8_t WASM[] = {/* WASM header */\n                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                  /* Type section */\n                  0x01, 0x07, 0x01,\n                  /* function type {i32, i32} -> {i32} */\n                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                  /* Import section */\n                  0x02, 0x13, 0x01,\n                  /* module name: \"extern\" */\n                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                  /* extern name: \"func-add\" */\n                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                  /* import desc: func 0 */\n                  0x00, 0x00,\n                  /* Function section */\n                  0x03, 0x02, 0x01, 0x00,\n                  /* Export section */\n                  0x07, 0x0A, 0x01,\n                  /* export name: \"addTwo\" */\n                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                  /* export desc: func 0 */\n                  0x00, 0x01,\n                  /* Code section */\n                  0x0A, 0x0A, 0x01,\n                  /* code body */\n                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n/* Wrap onto the `WASM`. */\nWasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));\n/*\n * If developers want to copy from buffer, use the `WasmEdge_BytesCreate()`\n * instead. The created `WasmEdge_Bytes` should be destroyed.\n */\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Non-blocking HTTP Client in WasmEdge\nDESCRIPTION: Bash commands to clone the repository, build the Rust code for wasm32-wasip1 target, compile with WasmEdge AoT compiler, and run the non-blocking HTTP client example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/client.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge_wasi_socket\ncd wasmedge_wasi_socket/nonblock_http_client/\n\n# Build the Rust Code\ncargo build --target wasm32-wasip1 --release\n# Use the AoT compiler for better performance\nwasmedge compile target/wasm32-wasip1/release/nonblock_http_client.wasm nonblock_http_client.wasm\n\n# Run the example\nwasmedge nonblock_http_client.wasm\n```\n\n----------------------------------------\n\nTITLE: Blocking Wait for Async Execution in C\nDESCRIPTION: Demonstrates how to wait for an asynchronous execution to complete and properly delete the async object\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Running Bootstrap eBPF Program with WasmEdge\nDESCRIPTION: Shell command to execute the bootstrap.wasm file using WasmEdge with the wasm_bpf plugin. The plugin path must be specified via the WASMEDGE_PLUGIN_PATH environment variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/bpf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nWASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ wasmedge bootstrap.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing Specific WasmEdge Version\nDESCRIPTION: Installs a specific version of WasmEdge by passing the version number to the installer script using the -v flag.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nVERSION={{ wasmedge_version }}\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $VERSION\n```\n\n----------------------------------------\n\nTITLE: Active Module Retrieval in WasmEdge\nDESCRIPTION: Demonstrates how to retrieve the active module instance from the VM context after WASM module instantiation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n```\n\n----------------------------------------\n\nTITLE: Building and Running HTTP Server in WasmEdge\nDESCRIPTION: Commands to clone, build and run the HTTP server example using WasmEdge and Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/server.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge_wasi_socket\ncd wasmedge_wasi_socket/http_server\n\n# Build the Rust code\ncargo build --target wasm32-wasip1 --release\n# Use the AoT compiler for better performance\nwasmedge compile target/wasm32-wasip1/release/http_server.wasm http_server.wasm\n\n# Run the example\n$wasmedge http_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in Host Function\nDESCRIPTION: Example of returning custom error codes from a host function implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result FaildFunc(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM with the error code. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for WebAssembly Compilation\nDESCRIPTION: TOML configuration file to set default compilation target and Rust flags for WebAssembly builds\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"wasm32-wasip1\"\nrustflags = [\"--cfg\", \"wasmedge\", \"--cfg\", \"tokio_unstable\"]\n```\n\n----------------------------------------\n\nTITLE: Converting WasmEdge String to C String\nDESCRIPTION: Shows how to convert a WasmEdge_String to a C string using WasmEdge_StringCopy function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[256];\nWasmEdge_String Str =\n    WasmEdge_StringCreateByCString(\"test_wasmedge_string\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf(\"String: %s\\n\", Buf);\n/* Will print \"test_wasmedge_string\". */\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Host Function Type\nDESCRIPTION: Type definition for host function callback implementation in WasmEdge that handles parameters and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/host_function.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Hyper Cargo Dependencies Configuration\nDESCRIPTION: Cargo.toml configuration for hyper HTTP client with WasmEdge patches\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\nhyper = { version = \"0.14\", features = [\"full\"] }\ntokio = { version = \"1\", features = [ \"rt\", \"macros\", \"net\", \"time\", \"io-util\" ] }\n```\n\n----------------------------------------\n\nTITLE: Instantiating Anonymous Module Instance in Go\nDESCRIPTION: Demonstrates instantiation of a WASM module as an anonymous Module instance, including proper setup of executor and store objects with resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_48\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod, err := executor.Instantiate(stpre, ast)\nif err != nil {\n  fmt.Println(\"WASM instantiation FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Importing TensorFlow Interface in Rust\nDESCRIPTION: Code to import the wasmedge_tensorflow_interface module in Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_tensorflow_interface;\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Core Library\nDESCRIPTION: Installs WasmEdge shared library version 0.13.5 using curl command\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.13.5\n```\n\n----------------------------------------\n\nTITLE: Installing Kwasm Operator using Helm\nDESCRIPTION: These commands add the Kwasm Helm repository, update it, install the Kwasm operator in a new namespace, and annotate all nodes for Kwasm support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhelm repo add kwasm http://kwasm.sh/kwasm-operator/\nhelm repo update\nhelm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator\nkubectl annotate node --all kwasm.sh/kwasm-node=true\n```\n\n----------------------------------------\n\nTITLE: Downloading LLM Chat WASM Application\nDESCRIPTION: Command to download the latest llama-chat WASM application from GitHub releases.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LO https://github.com/LlamaEdge/LlamaEdge/releases/latest/download/llama-chat.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing Podman on Ubuntu\nDESCRIPTION: These commands install Podman on Ubuntu as a prerequisite for running WASM applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get -y update\nsudo apt-get -y install podman\n```\n\n----------------------------------------\n\nTITLE: Initializing WebAssembly Binary Module in Hexadecimal Format\nDESCRIPTION: A byte array representation of a WebAssembly module in hexadecimal format. This binary defines a module that imports a function named 'func-add' from an external module named 'extern', and exports a function named 'addTwo'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_78\n\nLANGUAGE: c\nCODE:\n```\n0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n/* Import section */\n0x02, 0x13, 0x01,\n/* module name: \"extern\" */\n0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n/* extern name: \"func-add\" */\n0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n/* import desc: func 0 */\n0x00, 0x00,\n/* Function section */\n0x03, 0x02, 0x01, 0x00,\n/* Export section */\n0x07, 0x0A, 0x01,\n/* export name: \"addTwo\" */\n0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n/* export desc: func 0 */\n0x00, 0x01,\n/* Code section */\n0x0A, 0x0A, 0x01,\n/* code body */\n0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Node.js HTTP Server with WasmEdge QuickJS\nDESCRIPTION: JavaScript code for a lightweight Node.js HTTP server using WasmEdge QuickJS. The server listens on port 8001 and echoes back any data received in POST requests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createServer, request, fetch } from 'http';\n\ncreateServer((req, resp) => {\n  req.on('data', (body) => {\n    resp.write('echo:');\n    resp.end(body);\n  });\n}).listen(8001, () => {\n  print('listen 8001 ...\\n');\n});\n```\n\n----------------------------------------\n\nTITLE: Running a WASI application container with WasmEdge runtime\nDESCRIPTION: Commands to load and run a WebAssembly demo application container using the WasmEdge runtime via containerd. This demonstrates executing a WASI-compatible WebAssembly module with parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake load\nsudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'\n```\n\n----------------------------------------\n\nTITLE: Installing Go on KubeEdge Edge Node\nDESCRIPTION: Downloads and installs Go 1.17.3 on the KubeEdge edge node, setting up the PATH environment variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz\n$ tar xzvf go1.17.3.linux-amd64.tar.gz\n\n$ export PATH=/home/${user}/go/bin:$PATH\n$ go version\ngo version go1.17.3 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Importing WasmEdge TensorFlow Interface in Rust\nDESCRIPTION: This Rust snippet brings the `wasmedge_tensorflow_interface` functions into scope, necessary for handling TensorFlow operations in WASM applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_tensorflow_interface;\n```\n\n----------------------------------------\n\nTITLE: Generating CDI Specification File for NVIDIA\nDESCRIPTION: Commands to generate and verify the Container Device Interface (CDI) specification file for NVIDIA GPUs. This configuration enables container access to GPU devices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml\n\n# Check you cdi config is good\n> nvidia-ctk cdi list\n\n# Example output\nINFO[0000] Found 2 CDI devices\nnvidia.com/gpu=0\nnvidia.com/gpu=all\n```\n\n----------------------------------------\n\nTITLE: eBPF Host Functions Interface\nDESCRIPTION: C interface definitions for the six host functions provided by the eBPF plugin for WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n/// lookup a bpf map fd by name.\ni32 wasm_bpf_map_fd_by_name(u64 obj, u32 name);\n/// detach and close a bpf program.\ni32 wasm_close_bpf_object(u64 obj);\n/// CO-RE load a bpf object into the kernel.\nu64 wasm_load_bpf_object(u32 obj_buf, u32 obj_buf_sz);\n/// attach a bpf program to a kernel hook.\ni32 wasm_attach_bpf_program(u64 obj, u32 name,\n                            u32 attach_target);\n/// poll a bpf buffer, and call a wasm callback indicated by sample_func.\n/// the first time to call this function will open and create a bpf buffer.\ni32 wasm_bpf_buffer_poll(u64 program, i32 fd, u32 sample_func,\n                         u32 ctx, u32 data, i32 max_size,\n                         i32 timeout_ms);\n/// lookup, update, delete, and get_next_key operations on a bpf map.\ni32 wasm_bpf_map_operate(u64 fd, i32 cmd, u32 key, u32 value,\n                         u32 next_key, u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-Logging Plugin Support in Bash\nDESCRIPTION: Commands to build WasmEdge from source with WASI-Logging plugin support enabled. This process involves creating a build directory, running CMake with specific options, and installing the project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_logging.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\nmkdir -p build && cd build\ncmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j\n# For the WASI-Logging plug-in, you should install this project.\ncmake --install .\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge\nDESCRIPTION: Bash command to install the WasmEdge shared library, which should match the WasmEdge-Go version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.2\n```\n\n----------------------------------------\n\nTITLE: Compiling Fibonacci Function to WebAssembly\nDESCRIPTION: Command to compile the Fibonacci function implementation to WebAssembly using TinyGo.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntinygo build -o fib.wasm -target wasi main.go\n```\n\n----------------------------------------\n\nTITLE: Initializing WebAssembly Proposals Configuration in Go\nDESCRIPTION: Defines and manages WebAssembly proposals configuration for WasmEdge runtime, allowing developers to enable or disable specific language proposals\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n)\n```\n\n----------------------------------------\n\nTITLE: Running the WebAssembly Application\nDESCRIPTION: Commands for building the Go host application and running the WebAssembly program with example input and output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/app.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n\n$ ./read_file rust_readfile/target/wasm32-wasip1/debug/rust_readfile.wasm file.txt\nRust: Opening input file \"file.txt\"...\nRust: Read input file \"file.txt\" succeeded.\nRust: Please input the line number to print the line of file.\n# Input \"5\" and press Enter.\n5\n# The output will be the 5th line of `file.txt`:\nabcDEF___!@#$%^\n```\n\n----------------------------------------\n\nTITLE: Downloading TensorFlow Dependencies\nDESCRIPTION: Downloads and extracts the TensorFlow shared libraries required for the WasmEdge-Tensorflow plugin. This script handles different versions and platform configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nVERSION=TF-2.12.0-CC\n# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.\nPLATFORM=manylinux2014_x86_64\n# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.\n# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.\n# For the MacOS arm64 platforms, please use the `darwin_arm64`.\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz\ntar -zxf WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz\nrm -f WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Host Function Error Handling - Pre 0.11.0\nDESCRIPTION: Example of basic host function error handling in WasmEdge versions before 0.11.0, showing how to return a failure result without custom error codes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM. */\n  return WasmEdge_Result_Fail;\n}\n```\n\n----------------------------------------\n\nTITLE: Running AOT Compiled LLM Inference\nDESCRIPTION: Commands to AOT compile the WASM file and run it with WasmEdge for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile llama-chat.wasm llama-chat.wasm\nwasmedge --dir .:.  --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat\n```\n\n----------------------------------------\n\nTITLE: PNG Image Processing Functions in Rust\nDESCRIPTION: Functions for decoding PNG images and converting them to different color formats and data types\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Function to decode PNG from buffer and resize to RGB8 format.\npub fn load_png_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode PNG from buffer and resize to BGR8 format.\npub fn load_png_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode PNG from buffer and resize to RGB32F format.\npub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n// Function to decode PNG from buffer and resize to BGR32F format.\npub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n```\n\n----------------------------------------\n\nTITLE: WASI Preregistration in Go\nDESCRIPTION: Example of enabling and configuring WASI (WebAssembly System Interface) support in WasmEdge VM using Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_33\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\n// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.\nvm := wasmedge.NewVMWithConfig(conf)\nvm.Release()\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasiconf := conf.GetImportObject(wasmedge.WASI)\n// Initialize the WASI.\nwasiconf.InitWasi(/* ... ignored */)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Applying Containerd Configuration Patch and Restarting Service\nDESCRIPTION: Commands to apply the containerd configuration patch and restart the containerd service to apply the changes. This enables WasmEdge support in the container runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo patch -d/ -p0 < config.toml.diff\nsudo systemctl restart containerd\n```\n\n----------------------------------------\n\nTITLE: Installing Kubernetes Development Environment\nDESCRIPTION: Commands for setting up a local Kubernetes development environment including Go installation, Kubernetes source code checkout, and etcd setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install go\n$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz\n$ sudo rm -rf /usr/local/go\n$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz\n$ source /home/${USER}/.profile\n\n# Clone k8s\n$ git clone https://github.com/kubernetes/kubernetes.git\n$ cd kubernetes\n$ git checkout v1.22.2\n\n# Install etcd with hack script in k8s\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh\n$ export PATH=\"/home/${USER}/kubernetes/third_party/etcd:${PATH}\"\n$ sudo cp third_party/etcd/etcd* /usr/local/bin/\n\n# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl\n\n# Build and run k8s with containerd\n$ sudo apt-get install -y build-essential\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh\n```\n\n----------------------------------------\n\nTITLE: AOT Compilation for Performance in WasmEdge\nDESCRIPTION: By compiling the WASM file ahead of time (AOT), this snippet enhances the inference program's execution speed. Requires WasmEdge installed with AOT compilation capability enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm\nwasmedge --dir .:. out.wasm mobilenet.xml mobilenet.bin input.jpg\n```\n\n----------------------------------------\n\nTITLE: Build Classification Microservice\nDESCRIPTION: These commands build the image classification microservice using Rust and compile it to WebAssembly. The `wasmedgec` command compiles the WebAssembly module for optimized performance using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd image-api-classify\ncargo build --target wasm32-wasip1 --release\nwasmedgec target/wasm32-wasip1/release/wasmedge_hyper_server_tflite.wasm wasmedge_hyper_server_tflite.wasm\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Type from Function Instance in C\nDESCRIPTION: Demonstrates how to retrieve the function type from a function instance context in WasmEdge. The function type context obtained is owned by the function context and should not be manually destroyed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */\n```\n\n----------------------------------------\n\nTITLE: WASI Initialization with WasmEdge 0.10.0\nDESCRIPTION: Example showing how to initialize WASI using WasmEdge 0.10.0 C API with ModuleInstanceContext.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposal Enum in C\nDESCRIPTION: Enumerate supported WebAssembly proposals in WasmEdge for enabling or disabling specific language features\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  // Additional proposals...\n}\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Container in Kubernetes 1.20.11\nDESCRIPTION: This command runs a WebAssembly application as a container in Kubernetes 1.20.11. It uses the wasmedge/example-wasi:latest image and sets necessary annotations and overrides for WasmEdge compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Registrations in WasmEdge VM (C)\nDESCRIPTION: This C snippet demonstrates enabling host registrations such as `WASI` in WasmEdge VM configuration context. Dependencies: WasmEdge C library. Outputs: Host registration status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0,\n  WasmEdge_HostRegistration_WasmEdge_Process\n};\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Host Function Example in Bash\nDESCRIPTION: This snippet shows how to compile the C program using GCC with the WasmEdge C API library and run the resulting executable. The output demonstrates the successful execution of the host function addition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_69\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN llama.cpp Backend on macOS (Apple Silicon)\nDESCRIPTION: CMake commands to build WasmEdge with the WASI-NN llama.cpp backend on macOS Apple Silicon, with Metal GPU acceleration enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=ON \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Download and Join KubeEdge Edge Node\nDESCRIPTION: This snippet downloads KubeEdge, extracts the archive, and joins an edge node to the KubeEdge cluster.  It requires `wget` and `tar` to be installed. The command uses `keadm join` with specific parameters for the cloudcore IP address, edge node name, token, runtime endpoint, runtime type, and cgroup driver.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz\n$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz\n$ cd keadm-v1.8.0-linux-amd64/keadm/\n\n$ sudo ./keadm join \\\n--cloudcore-ipport=192.168.122.160:10000 \\\n--edgenode-name=edge \\\n--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \\\n--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \\\n--runtimetype=remote \\\n--cgroupdriver=systemd\n```\n\n----------------------------------------\n\nTITLE: Running a Simple WebAssembly Container in Kubernetes\nDESCRIPTION: Command to run a simple WebAssembly WASI program as a container in Kubernetes, using the wasmedge/example-wasi:latest image with specific annotations for WebAssembly compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Setting up a Go project for WasmEdge\nDESCRIPTION: Creates a new Go project directory and initializes a Go module for WasmEdge testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Compiler Optimization Level and Output Format Enums in WasmEdge\nDESCRIPTION: Defines enumerations for AOT compiler optimization levels and output formats. These control the performance vs code size trade-offs during compilation and determine the format of the compiled output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom section.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instances from VM Context (Post-0.12.0)\nDESCRIPTION: Example of retrieving module instances from the VM context after version 0.12.0, using the new APIs for faster retrieval of registered module instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n/* Add the WASI configurations. */\nWasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\n/* Get the WASI module instance. */\nWasmEdge_ModuleInstance *WASIModInst =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Get the registered WASI-crypto-common module instance by name. */\nWasmEdge_String ModName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_crypto_common\");\nconst WasmEdge_ModuleInstance *WASICryptoKxModInst =\n    WasmEdge_VMGetImportModuleContext(VMCxt, ModName);\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Global Instance Retrieval Before v0.10.0\nDESCRIPTION: Example showing how to retrieve a Global instance using Store in versions before WasmEdge-Go v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm`, and exports the \"global_i32\".\nstore := vm.GetStore()\n\nglobinst := store.FindGlobal(\"global_i32\")\n```\n\n----------------------------------------\n\nTITLE: Installing and Testing WasmEdge in Interpreter Mode\nDESCRIPTION: Installs the compiled WasmEdge and demonstrates running WebAssembly modules in interpreter mode using the wasmedge CLI tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v\nwasmedge version 0.12.0-alpha.1-13-g610cc21f\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10\n89\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2\n4\n```\n\n----------------------------------------\n\nTITLE: Finding a WasmEdge Plug-in by Name\nDESCRIPTION: Shows how to find a specific plug-in by its name after loading the plug-ins. This example searches for the 'wasi_crypto' plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_81\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n```\n\n----------------------------------------\n\nTITLE: Building crun with WasmEdge Support in Dockerfile\nDESCRIPTION: First stage of a multi-stage Dockerfile that builds crun with WasmEdge support. It installs necessary dependencies, installs WasmEdge, and compiles crun from a specific branch with WasmEdge enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_1\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM ubuntu:21.10 AS builder\nWORKDIR /data\nRUN DEBIAN_FRONTEND=noninteractive apt update \\\n    && DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \\\n    && curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \\\n    && git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \\\n    && cd crun \\\n    && ./autogen.sh \\\n    && ./configure --with-wasmedge --enable-embedded-yajl\\\n    && make\n\n...\n```\n\n----------------------------------------\n\nTITLE: Loading Plug-ins in VM Objects (Pre-v0.12.0)\nDESCRIPTION: Example of loading plug-ins in VM objects before version 0.12.0. It demonstrates adding configurations for WASI and crypto modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\nconf := wasmedge.NewConfigure(wasmedge.WASI)\ncomf.AddConfig(wasmedge.WasiCrypto_Common)\ncomf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)\ncomf.AddConfig(wasmedge.WasiCrypto_Kx)\ncomf.AddConfig(wasmedge.WasiCrypto_Signatures)\ncomf.AddConfig(wasmedge.WasiCrypto_Symmetric)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\n\nstore := vm.GetStore()\nmodulelist := store.ListModule()\nfor _, name := range modulelist {\n  fmt.Println(name)\n}\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Using Tag Type Context in C\nDESCRIPTION: Example of using a Tag Type context for exception handling, showing how to retrieve function type information from a tag instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nconst WasmEdge_TagTypeContext *TagTypeCxt = WasmEdge_TagInstanceGetTagType(...);\n\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_TagTypeGetFunctionType(TagTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Latest Docker CE in Bash\nDESCRIPTION: Commands to download and install the latest version of Docker Community Edition using the official installation script. Also includes a command to verify the Docker version after installation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> curl -fsSL https://get.docker.com -o get-docker.sh\n> sh get-docker.sh\n\n# Check your docker\n> docker --version\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge on Windows\nDESCRIPTION: Uninstall WasmEdge using the Windows package manager winget\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nwinget uninstall wasmedge\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI-Crypto Pre-registration\nDESCRIPTION: Shows how to enable WASI-Crypto proposal support with multiple crypto-related configurations. Requires specific dependencies and prerequisites.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* The WASI-Crypto related configures are suggested to turn on together. */\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration or the plugin load failed.\n */\nWasmEdge_ModuleInstanceContext *CryptoCommonModule =\n    WasmEdge_VMGetImportModuleContext(\n        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Compile and Run Step-by-Step Example\nDESCRIPTION: Shell commands to compile and execute the step-by-step WASM execution program to calculate the 25th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 121393\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Compiler Optimization Levels in Go\nDESCRIPTION: This code snippet defines constants for WasmEdge compiler optimization levels in Go.  These levels control the optimization behavior of the AOT compiler. The constants are defined using the `CompilerOptimizationLevel` type and corresponding C definitions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\n```go\n   const (\n     // Disable as many optimizations as possible.\n     CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n     // Optimize quickly without destroying debuggability.\n     CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n     // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n     CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n     // Optimize for fast execution as much as possible.\n     CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n     // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n     CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n     // Optimize for small code size as much as possible.\n     CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n   )\n   ```\n```\n\n----------------------------------------\n\nTITLE: Adding WASM Compilation Target\nDESCRIPTION: Rust command to add WebAssembly compilation target for server-side WebAssembly development using WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Invoking WebAssembly Functions with WasmEdge in C\nDESCRIPTION: This C code snippet demonstrates using the WasmEdge C API to invoke WebAssembly functions 'add_and_square' and 'sum_of_squares'. Dependencies include the WasmEdge SDK and the availability of 'lib.wasm' and 'test.wasm' modules. The program initializes the VM context, validates the WebAssembly module, and executes functions by passing integer parameters. The output is printed on the console, displaying the results of the mathematical operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md#2025-04-21_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\n\nint main() {\n  /* The result. */\n  WasmEdge_Result Res;\n\n  /* The params and returns. */\n  WasmEdge_Value Params[2], Returns[1];\n\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* Assume that the `lib.wasm` has instantiated first. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_ASTModuleContext *LibASTCxt = NULL;\n  WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, \"lib.wasm\");\n  WasmEdge_LoaderDelete(LoadCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Load lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_ASTModuleDelete(LibASTCxt);\n    printf(\"Validate lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  /*\n   * The module name is determined when instantiation.\n   * If use the `WasmEdge_ExecutorInstantiate` API, the module name will be\n   * \"\".\n   */\n  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(\"math\");\n  Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,\n                                  ModuleName);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ASTModuleDelete(LibASTCxt);\n  WasmEdge_StringDelete(ModuleName);\n  WasmEdge_StoreDelete(StoreCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Instantiate lib.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Register the module instance with the module name \"math\". */\n  /* The module name has been determined when instantiating the `lib.wasm`. */\n  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, LibInstCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    WasmEdge_ModuleInstanceDelete(LibInstCxt);\n    printf(\"Register lib.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Instantiate the `test.wasm`. */\n  /*\n   * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to\n   * instantiate and execute quickly.\n   */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"test.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    WasmEdge_ModuleInstanceDelete(LibInstCxt);\n    printf(\"Load test.wasm error: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    WasmEdge_ModuleInstanceDelete(LibInstCxt);\n    printf(\"Validate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    WasmEdge_VMDelete(VMCxt);\n    WasmEdge_ModuleInstanceDelete(LibInstCxt);\n    printf(\"Instantiate test.wasm error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n    return -1;\n  }\n\n  /* Invoke the functions. */\n  /* Invoke the \"add_and_square\" to calculate (123 + 456)^2 */\n  WasmEdge_String FuncName =\n      WasmEdge_StringCreateByCString(\"add_and_square\");\n  Params[0] = WasmEdge_ValueGenI32(123);\n  Params[1] = WasmEdge_ValueGenI32(456);\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '(%d + %d)^2' result: %d\\n\", 123, 456,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'add_and_square' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n  /* Invoke the \"sum_of_squares\" to calculate (77^2 + 88^2) */\n  FuncName = WasmEdge_StringCreateByCString(\"sum_of_squares\");\n  Params[0] = WasmEdge_ValueGenI32(77);\n  Params[1] = WasmEdge_ValueGenI32(88);\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);\n  WasmEdge_StringDelete(FuncName);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the '%d^2 + %d^2' result: %d\\n\", 77, 88,\n           WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Execute 'sum_of_squares' error: %s\\n\",\n           WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  /* The imported module instance should be destroyed. */\n  WasmEdge_ModuleInstanceDelete(LibInstCxt);\n  return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Optimization Level Constants\nDESCRIPTION: Constants defining various optimization levels for the WasmEdge Ahead-of-Time compiler, ranging from O0 (minimal optimization) to Oz (size optimization).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_66\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Redis and Tokio in WasmEdge\nDESCRIPTION: Dependencies configuration in Cargo.toml for using Redis with WasmEdge, including necessary patches for WasmEdge-specific socket APIs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/redis_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\n\n[dependencies]\nanyhow = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nredis = { version = \"0.25.4\", default-features = false, features = [\n    \"tokio-comp\",\n] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Printing and Debugging in Rust for WASI\nDESCRIPTION: This Rust function demonstrates how to use the println! macro in a WASI environment. It prints to the STDOUT of the process running WasmEdge and returns the input string.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn echo(content: &str) -> String {\n  println!(\"Printed from wasi: {}\", content);\n  return content.to_string();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Go Project\nDESCRIPTION: This snippet demonstrates how to create a new Go project for WasmEdge. It uses `mkdir` to create a new directory, `cd` to navigate into it, and `go mod init` to initialize a new Go module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing a WasmEdge Module Instance with Host Function Instances\nDESCRIPTION: Example showing how to manually construct a module instance with various host objects including functions, memory, table, and global instances. Each instance is created with appropriate types and added to the module with export names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_64\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// Create and add a table instance into the module instance with export name \"table\".\ntabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))\nhosttab := wasmedge.NewTable(tabtype)\ntabtype.Release()\nmod.AddTable(\"table\", hosttab)\n\n// Create and add a memory instance into the module instance with export name \"memory\".\nmemtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))\nhostmem := wasmedge.NewMemory(memtype)\nmemtype.Release()\nmod.AddMemory(\"memory\", hostmem)\n\n// Create and add a global instance into the module instance with export name \"global\".\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)\nhostglob := wasmedge.NewGlobal(globtype, uint32(666))\nglobtype.Release()\nmod.AddGlobal(\"global\", hostglob)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Running Go Project for WasmEdge\nDESCRIPTION: This bash code snippet demonstrates how to run the Go project. It executes the compiled binary named wasmedge_test.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\n$ ./wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Output Tensor Processing in Rust\nDESCRIPTION: Code for retrieving and converting output tensors from TensorFlow model\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet res_vec: Vec<f32> = session.get_output(\"MobilenetV2/Predictions/Softmax\");\n```\n\n----------------------------------------\n\nTITLE: Setting Up KubeEdge Master Node with Keadm\nDESCRIPTION: This command initializes a KubeEdge master node using the keadm tool, by downloading required binaries and configuring the cloud side with the correct IP address and kubeconfig. It assumes pre-installed kubeconfig.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz\ntar xzvf keadm-v1.8.0-linux-amd64.tar.gz\ncd keadm-v1.8.0-linux-amd64/keadm/\nsudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config\n```\n\n----------------------------------------\n\nTITLE: Key Derivation with HKDF in Rust using WASI-Crypto\nDESCRIPTION: This snippet demonstrates key derivation using the HKDF (HMAC-based Key Derivation Function) with SHA-512 in Rust. It generates a key using `HKDF-EXTRACT/SHA-512`, expands it with `HKDF-EXPAND/SHA-512` using a salt and info, and checks the length of the derived key.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasicrypto.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet key = HkdfKey::generate(\"HKDF-EXTRACT/SHA-512\")?;\nlet prk = Hkdf::new(\"HKDF-EXPAND/SHA-512\", &key, Some(b\"salt\"))?;\nlet derived_key = prk.expand(\"info\", 100)?;\nassert_eq!(derived_key.len(), 100);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Linking WasmEdge Shared Library in Bash\nDESCRIPTION: This bash command demonstrates how to compile a C program using the WasmEdge shared library. It assumes WasmEdge has been installed on the system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/library.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge -o test\n$ ./test\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Go Host Application\nDESCRIPTION: These bash commands build the Go application and run it with the compiled WebAssembly module as an argument. The output shows the results of calling the various bindgen functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/bindgen.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n\n$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\nRun bindgen -- create_line: {\"points\":[{\"x\":1.5,\"y\":3.8},{\"x\":2.5,\"y\":5.8}],\"valid\":true,\"length\":2.2360682,\"desc\":\"A thin red line\"}\nRun bindgen -- say: hello bindgen funcs test\nRun bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt\nRun bindgen -- lowest_common_multiple: 246\nRun bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]\nRun bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]\n```\n\n----------------------------------------\n\nTITLE: Host Function Error Handling - v0.11.0+\nDESCRIPTION: Enhanced error handling in v0.11.0+ allowing custom error codes up to 24-bits using WasmEdge_ResultGen.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result FaildFunc(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM with the error code. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Installing youki with WasmEdge Support\nDESCRIPTION: This bash snippet clones the youki repository, builds it with WasmEdge support, and sets up the necessary environment variables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recurse-submodules https://github.com/containers/youki.git\ncd youki\n./scripts/build.sh -o . -r -f wasm-wasmedge\n./youki -h\nexport LD_LIBRARY_PATH=$HOME/.wasmedge/lib\n```\n\n----------------------------------------\n\nTITLE: Running a Simple WebAssembly App with CRI-O\nDESCRIPTION: This bash script demonstrates how to pull a WebAssembly container image, create necessary configuration files, and run the container using CRI-O commands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation\n\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json\n\nsudo crictl runp sandbox_config.json\nPOD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4\n\nsudo crictl create $POD_ID container_wasi.json sandbox_config.json\nCONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f\n\nsudo crictl start $CONTAINER_ID\n\nsudo crictl ps -a\n\nsudo crictl logs $CONTAINER_ID\n```\n\n----------------------------------------\n\nTITLE: Setting Up TensorFlow Libraries on Linux\nDESCRIPTION: Commands to install and configure TensorFlow shared libraries on Linux systems by moving files and creating symbolic links.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflow_cc.so.2.12.0 /usr/local/lib\nmv libtensorflow_framework.so.2.12.0 /usr/local/lib\nln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2\nln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so\nln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2\nln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so\n```\n\n----------------------------------------\n\nTITLE: VM Object Status Diagram\nDESCRIPTION: ASCII diagram illustrating the different states of the VM object and the transitions between them during WASM execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_37\n\nLANGUAGE: text\nCODE:\n```\n                         |========================|\n                |------->|      VM: Initiated     |\n                |        |========================|\n                |                    |\n                |                 LoadWasm\n                |                    |\n                |                    v\n                |        |========================|\n                |--------|       VM: Loaded       |<-------|\n                |        |========================|        |\n                |              |            ^              |\n                |         Validate          |              |\n            Cleanup            |          LoadWasm         |\n                |              v            |            LoadWasm\n                |        |========================|        |\n                |--------|      VM: Validated     |        |\n                |        |========================|        |\n                |              |            ^              |\n                |      Instantiate          |              |\n                |              |          RegisterModule   |\n                |              v            |              |\n                |        |========================|        |\n                |--------|    VM: Instantiated    |--------|\n                         |========================|\n                               |            ^\n                               |            |\n                               --------------\n                  Instantiate, Execute, ExecuteRegistered,\n                  ExecuteBindgen, ExecuteBindgenRegistered\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with llama.cpp Backend on Intel MacOS\nDESCRIPTION: Commands to build WasmEdge with the llama.cpp (GGML) backend on Intel MacOS. This disables both BLAS and METAL acceleration, resulting in pure CPU mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n# Disable BLAS and METAL on x86_64 macOS.\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=OFF \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Plugin CMake Configuration\nDESCRIPTION: CMake configuration file for building the plugin as a shared library with necessary dependencies and installation settings\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nwasmedge_add_library(wasmedgePluginTest\n  SHARED\n  testplugin.cpp\n)\n\ntarget_compile_options(wasmedgePluginTest\n  PUBLIC\n  -DWASMEDGE_PLUGIN\n)\n\ntarget_include_directories(wasmedgePluginTest\n  PUBLIC\n  $<TARGET_PROPERTY:wasmedgePlugin,INCLUDE_DIRECTORIES>\n  ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\nif(WASMEDGE_LINK_PLUGINS_STATIC)\n  target_link_libraries(wasmedgePluginTest\n    PRIVATE\n    wasmedgeCAPI\n  )\nelse()\n  target_link_libraries(wasmedgePluginTest\n    PRIVATE\n    wasmedge_shared\n  )\nendif()\n\ninstall(TARGETS wasmedgePluginTest DESTINATION ${CMAKE_INSTALL_LIBDIR}/wasmedge)\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge Go Host Application\nDESCRIPTION: This Go code demonstrates how to use the WasmEdge Go SDK to run a WebAssembly application. It sets up the WasmEdge VM with the necessary configurations, initializes WASI, and executes the WebAssembly file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/app.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n\n  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)\n  conf.AddConfig(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping directories\n  )\n\n  // Instantiate wasm. _start refers to the main() function\n  vm.RunWasmFile(os.Args[1], \"_start\")\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Starting YoMo CLI Application with Workflow YAML\nDESCRIPTION: This Bash command initializes the YoMo CLI application using a specified YAML configuration file which contains the necessary port settings and workflow handlers for data processing. The command expects the YAML file to be located in the defined path, and it starts listening for incoming data based on that configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyomo serve -c ./zipper/workflow.yaml\n```\n\n----------------------------------------\n\nTITLE: Executing WasmEdge Inference Application\nDESCRIPTION: Command to run the TensorFlow Lite inference application using WasmEdge runtime with directory mounting.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n```\n\n----------------------------------------\n\nTITLE: Install Go\nDESCRIPTION: This snippet downloads, extracts, and configures the Go programming language. It is required for setting up the Kubernetes environment for local development.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz\n$ sudo rm -rf /usr/local/go\n$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz\n$ source /home/${USER}/.profile\n```\n\n----------------------------------------\n\nTITLE: Defining Basic ES6 Module Export\nDESCRIPTION: A simple JavaScript module that defines a function and exports it using ES6 module syntax. This example demonstrates the basic structure of an ES6 module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/es6.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hello() {\n  console.log('hello from module_def.js');\n}\n\nexport { hello };\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge without Acceleration Framework on Linux\nDESCRIPTION: This snippet demonstrates how to build WasmEdge without any acceleration framework on a Linux system by setting specific CMake flags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Downloading LLM Model File\nDESCRIPTION: Command to download the llama-3.1-8B model in GGUF format from HuggingFace.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LO https://huggingface.co/second-state/Meta-Llama-3.1-8B-Instruct-GGUF/resolve/main/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\n```\n\n----------------------------------------\n\nTITLE: Build and Run Kubernetes\nDESCRIPTION: This snippet builds and starts a local Kubernetes cluster using containerd as the container runtime. It uses a helper script from the Kubernetes repository and requires build-essential package.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install -y build-essential\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh\n```\n\n----------------------------------------\n\nTITLE: Compiling TinyGo to WebAssembly\nDESCRIPTION: This bash command uses the TinyGo compiler to build the `fib.go` file into a WebAssembly module named `fib.wasm`. The `-target wasi` flag specifies that the WebAssembly module should target the WebAssembly System Interface (WASI).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntinygo build -o fib.wasm -target wasi fib.go\n```\n\n----------------------------------------\n\nTITLE: Deploying WebAssembly HTTP Serverless Application with Knative\nDESCRIPTION: YAML definition and commands for deploying a WebAssembly HTTP server as a serverless service using Knative Serving. The configuration includes required annotations and runtimeClassName for WebAssembly support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: serving.knative.dev/v1\nkind: Service\nmetadata:\n  name: http-wasm\n  namespace: default\nspec:\n  template:\n    metadata:\n      annotations:\n        module.wasm.image/variant: compat-smart\n    spec:\n      runtimeClassName: crun\n      timeoutSeconds: 1\n      containers:\n      - name: http-server\n        image: docker.io/wasmedge/example-wasi-http:latest\n        ports:\n        - containerPort: 1234\n          protocol: TCP\n        livenessProbe:\n          tcpSocket:\n            port: 1234\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl apply -f http-wasm-serverless.yaml\n\n# wait for a while, and check if the serverless service is available\n$ kubectl get ksvc http-wasm\nNAME          URL                                              LATESTCREATED       LATESTREADY         READY   REASON\nhttp-wasm     http://http-wasm.default.knative.example.com     http-wasm-00001     http-wasm-00001     True\n\n# Try to call the service\n# As we do not set up DNS, we can only call the service via Kourier, Knative Serving ingress port.\n# get Kourier port which is 31997 in following example\n$ kubectl --namespace kourier-system get service kourier\nNAME      TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE\nkourier   LoadBalancer   10.105.58.134                     80:31997/TCP,443:31019/TCP   53d\n$ curl -H \"Host: http-wasm.default.knative.example.com\" -d \"name=WasmEdge\" -X POST http://localhost:31997\n\n# check the new start pod\n$ kubectl get pods\nNAME                                           READY   STATUS    RESTARTS   AGE\nhttp-wasm-00001-deployment-748bdc7cf-96l4r     2/2     Running   0          19s\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Function Handler - JavaScript\nDESCRIPTION: JavaScript code that loads the WasmEdge runtime and executes the compiled WebAssembly program. Handles the communication between the Lambda function and the WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nfunction _runWasm(reqBody) {\n  return new Promise((resolve) => {\n    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [\n      path.join(__dirname, 'grayscale.so'),\n    ]);\n\n    let d = [];\n    wasmedge.stdout.on('data', (data) => {\n      d.push(data);\n    });\n\n    wasmedge.on('close', (code) => {\n      let buf = Buffer.concat(d);\n      resolve(buf);\n    });\n\n    wasmedge.stdin.write(reqBody);\n    wasmedge.stdin.end('');\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Async Execution\nDESCRIPTION: Shows how to work with asynchronous execution in WASM, including getting results and handling timeouts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Running PostgreSQL Example in WasmEdge\nDESCRIPTION: Commands to clone, compile and execute a PostgreSQL example application in WasmEdge environment with database connection configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/postgres_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/postgres\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Execute SQL statements against a PostgreSQL database at postgres://user:passwd@localhost/testdb\nwasmedge --env \"DATABASE_URL=postgres://user:passwd@localhost/testdb\" target/wasm32-wasip1/release/crud.wasm\n```\n\n----------------------------------------\n\nTITLE: Printing Results in Rust\nDESCRIPTION: Rust code for printing the prompt and inference output to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nprintln!(\"\\nprompt: {}\", &prompt);\nprintln!(\"\\noutput: {}\", output);\n```\n\n----------------------------------------\n\nTITLE: Building and Installing crun with WasmEdge Support\nDESCRIPTION: Series of commands to clone, configure, build, and install crun from source with WasmEdge support enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Rollup Configuration for WasmEdge NPM Bundling\nDESCRIPTION: Rollup.js configuration to convert CommonJS modules to ES6 modules compatible with WasmEdge, including plugin configurations for module resolution and transformation\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/npm.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { babel } = require('@rollup/plugin-babel');\nconst nodeResolve = require('@rollup/plugin-node-resolve');\nconst commonjs = require('@rollup/plugin-commonjs');\nconst replace = require('@rollup/plugin-replace');\n\nconst globals = require('rollup-plugin-node-globals');\nconst builtins = require('rollup-plugin-node-builtins');\nconst plugin_async = require('rollup-plugin-async');\n\nconst babelOptions = {\n  presets: ['@babel/preset-react'],\n};\n\nmodule.exports = [\n  {\n    input: './npm_main.js',\n    output: {\n      inlineDynamicImports: true,\n      file: 'dist/npm_main.mjs',\n      format: 'esm',\n    },\n    external: ['process', 'wasi_net', 'std'],\n    plugins: [\n      plugin_async(),\n      nodeResolve(),\n      commonjs({ ignoreDynamicRequires: false }),\n      babel(babelOptions),\n      globals(),\n      builtins(),\n      replace({\n        'process.env.NODE_ENV': JSON.stringify('production'),\n        'process.env.NODE_DEBUG': JSON.stringify(''),\n      }),\n    ],\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with GGML Backend on General Linux (No Acceleration)\nDESCRIPTION: Commands to build WasmEdge with the GGML backend on general Linux systems without any acceleration framework.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WasmEdge-Image Plugin on Linux\nDESCRIPTION: Commands to install the required dependencies (zlib and libboost) for building WasmEdge with the Image plugin on Linux platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/image.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install zlib1g-dev libboost-all-dev\n```\n\n----------------------------------------\n\nTITLE: Compile and Run Async WASM Example\nDESCRIPTION: Shell commands to compile the C program with WasmEdge library and execute it to calculate the 20th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Defining Host Registration Enum in WasmEdge\nDESCRIPTION: Defines an enum for host registrations in WasmEdge. Currently, it only includes WASI, but is reserved for future built-in host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0\n};\n```\n\n----------------------------------------\n\nTITLE: Updating and Installing OpenWRT Package Feeds\nDESCRIPTION: Commands to obtain the latest package definitions and install symlinks for all packages in OpenWRT.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd openwrt\n./scripts/feeds update -a\n./scripts/feeds install -a\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge_Process Pre-registration\nDESCRIPTION: Shows setup of WasmEdge_Process support for Rust sources, including configuration creation and module initialization.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration module instances from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */\nWasmEdge_ModuleInstanceContext *ProcModule =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);\n/* Initialize the WasmEdge_Process. */\nWasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Table Type Context Usage in C\nDESCRIPTION: Shows how to create and manage Table Type context for WASM table instances. Demonstrates setting limits and reference types for tables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {.HasMax = true, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Running RustPython with File System Access\nDESCRIPTION: Runs RustPython with WasmEdge, granting access to the current directory in the WASI virtual file system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/python/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. ./target/wasm32-wasip1/release/rustpython.wasm\n```\n\n----------------------------------------\n\nTITLE: Rust WebAssembly Functions with Bindgen\nDESCRIPTION: Example Rust code demonstrating WebAssembly functions using wasmedge-bindgen with complex types and operations\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\nuse num_integer::lcm;\nuse sha3::{Digest, Sha3_256, Keccak256};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n  x: f32,\n  y: f32\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n  points: Vec<Point>,\n  valid: bool,\n  length: f32,\n  desc: String\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> String {\n  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();\n  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();\n  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();\n\n  let valid = if length == 0.0 { false } else { true };\n\n  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };\n\n  return serde_json::to_string(&line).unwrap();\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> String {\n  let r = String::from(\"hello \");\n  return r + s.as_str();\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> String {\n  (&s).chars().map(|c| {\n    match c {\n      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,\n      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,\n      _ => c\n    }\n  }).collect()\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> i32 {\n  return lcm(a, b);\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {\n  return Sha3_256::digest(&v).as_slice().to_vec();\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {\n  return Keccak256::digest(&s).as_slice().to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Instances (WasmEdge-Go < v0.9.2)\nDESCRIPTION: This snippet demonstrates how to retrieve exported instances of named or anonymous modules from the WasmEdge store before version v0.9.2. It loads a WASM file, registers it with a name, instantiates it, and then retrieves functions from both the named and anonymous module instances using the store.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n// Create the store object. The store object holds the instances.\nstore := wasmedge.NewStore()\n// Error.\nvar err error\n// AST object.\nvar ast *wasmedge.AST\n\n// Create the loader object.\nloader := wasmedge.NewLoader()\n// Create the validator object.\nvalidator := wasmedge.NewValidator()\n// Create the executor object.\nexecutor := wasmedge.NewExecutor()\n\n// Load the WASM file or the compiled-WASM file and convert into the AST object.\nast, err = loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n  return\n}\n// Validate the WASM module.\nerr = validator.Validate(ast)\nif err != nil {\n  fmt.Println(\"Validation FAILED:\", err.Error())\n  return\n}\n// Example: register and instantiate the WASM module with the module name \"module_fib\".\nerr = executor.RegisterModule(store, ast, \"module_fib\")\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n// Example: Instantiate the WASM module into the Store object.\nerr = executor.Instantiate(store, ast)\nif err != nil {\n  fmt.Println(\"Instantiation FAILED:\", err.Error())\n  return\n}\n\n// Now, developers can retrieve the exported instances from the store.\n// Take the exported functions as example. This WASM exports the function \"fib\".\n// Find the function \"fib\" from the instantiated anonymous module.\nfunc1 := store.FindFunction(\"fib\")\n// Find the function \"fib\" from the registered module \"module_fib\".\nfunc2 := store.FindFunctionRegistered(\"module_fib\", \"fib\")\n\nast.Release()\nstore.Release()\nloader.Release()\nvalidator.Release()\nexecutor.Release()\n```\n\n----------------------------------------\n\nTITLE: Configuring containerd for WasmEdge Runtime\nDESCRIPTION: Commands to configure containerd with WasmEdge runtime support and create Kubernetes RuntimeClass for WebAssembly containers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Run the following command as root user\nsudo bash -c \"containerd config default > /etc/containerd/config.toml\"\necho '[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.wasmedge] runtime_type = \"io.containerd.wasmedge.v1\"' | sudo tee -a /etc/containerd/config.toml > /dev/null\nsudo systemctl restart containerd\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Docker Container for HTTP Server\nDESCRIPTION: Shell commands to build and run a Docker container with a WebAssembly HTTP server, demonstrating port mapping and testing the server with curl. Shows how to expose the server port from the container to the host.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 1234:1234 wasmedge/myapp\nnew connection at 1234\n```\n\n----------------------------------------\n\nTITLE: Downloading Llama2 Inference Model\nDESCRIPTION: Command to download the Llama2 inference model for the demo.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf\n```\n\n----------------------------------------\n\nTITLE: Installing CRI-O and crun on KubeEdge Edge Node\nDESCRIPTION: Uses a script to install CRI-O and crun on Ubuntu 20.04 for the KubeEdge edge node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Functions of a WASM Module in Go\nDESCRIPTION: This snippet shows how to load a WASM file, validate the module, instantiate it, and list its exported functions using the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Step 1: Load WASM file.\n  err := vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  // Step 2: Validate the WASM module.\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  // Step 3: Instantiate the WASM module.\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // List the exported functions for the names and function types.\n  funcnames, functypes := vm.GetFunctionList()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n  for _, ftype := range functypes {\n    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.\n    // Developers should __NOT__ call the `ftype.Release()`.\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Node.js Modules\nDESCRIPTION: Command to copy required Node.js modules to the working directory for API support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncp -r ../../modules .\n```\n\n----------------------------------------\n\nTITLE: Comparing WasmEdge Strings\nDESCRIPTION: This C code demonstrates how to compare two `WasmEdge_String` objects for equality using `WasmEdge_StringIsEqual`. It creates two strings, one from a C string and one from a buffer, and then compares them. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"abcd\";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Reference Type Handling\nDESCRIPTION: Examples of working with WasmEdge reference types including funcref and externref.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\nPtr = WasmEdge_ValueGetExternRef(Val);\nconst WasmEdge_FunctionInstanceContext *FuncCxt = ...;\nVal = WasmEdge_ValueGenFuncRef(FuncCxt);\nconst WasmEdge_FunctionInstanceContext *GotFuncCxt = WasmEdge_ValueGetFuncRef(Val);\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\nNum += 55;\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n```\n\n----------------------------------------\n\nTITLE: Generating HTTP responses for static assets and SSR in Rust\nDESCRIPTION: This Rust code provides functions to generate HTTP responses for static files and server-side rendered content.  The `ssr` function performs server-side rendering using the `isomorphic_app` crate, injecting the rendered HTML and initial state into a template HTML file. The `file` function reads and returns the requested file as binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::mime::MimeType;\nuse anyhow::Result;\nuse parsed::http::{Header, Response};\nuse std::fs::{read};\nuse std::path::Path;\nuse isomorphic_app::App;\n\nconst HTML_PLACEHOLDER: &str = \"#HTML_INSERTED_HERE_BY_SERVER#\";\nconst STATE_PLACEHOLDER: &str = \"#INITIAL_STATE_JSON#\";\n\npub fn ssr(path: &str, init: Option<u32>) -> Result<(Response, Option<Vec<u8>>)> {\n    let html = format!(\"{}\", include_str!(\"./index.html\"));\n\n    let app = App::new(init.unwrap_or(1001), path.to_string());\n    let state = app.store.borrow();\n\n    let html = html.replace(HTML_PLACEHOLDER, &app.render().to_string());\n    let html = html.replace(STATE_PLACEHOLDER, &state.to_json());\n\n    Ok((Response {\n        protocol: \"HTTP/1.0\".to_string(),\n        code: 200,\n        message: \"OK\".to_string(),\n        headers: vec![\n            Header {\n                name: \"content-type\".to_string(),\n                value: MimeType::from_ext(\"html\").get(),\n            },\n            Header {\n                name: \"content-length\".to_string(),\n                value: html.len().to_string(),\n            },\n        ],\n        content: html.into_bytes(),\n    }, None))\n}\n\n/// Get raw file content\npub fn file(path: &str) -> Result<(Response, Option<Vec<u8>>)> {\n    let path = Path::new(&path);\n    if path.exists() {\n        let content_type: MimeType = match path.extension() {\n            Some(ext) => MimeType::from_ext(ext.to_str().get_or_insert(\"\")),\n            None => MimeType::from_ext(\"\"),\n        };\n        let content = read(path)?;\n\n        Ok((Response {\n            protocol: \"HTTP/1.0\".to_string(),\n            code: 200,\n            message: \"OK\".to_string(),\n            headers: vec![\n                Header {\n                    name: \"content-type\".to_string(),\n                    value: content_type.get(),\n                },\n                Header {\n                    name: \"content-length\".to_string(),\n                    value: content.len().to_string(),\n                },\n            ],\n            content: vec![],\n        }, Some(content)))\n    } else {\n        Ok((Response {\n            protocol: \"HTTP/1.0\".to_string(),\n            code: 404,\n            message: \"Not Found\".to_string(),\n            headers: vec![],\n            content: vec![],\n        }, None))\n    }\n}\n\n/// Bad Request\npub fn bad_request() -> Response {\n    Response {\n        protocol: \"HTTP/1.0\".to_string(),\n        code: 400,\n        message: \"Bad Request\".to_string(),\n        headers: vec![],\n        content: vec![],\n    }\n}\n\n/// Internal Server Error\npub fn internal_error() -> (Response, Option<Vec<u8>>) {\n    (Response {\n        protocol: \"HTTP/1.0\".to_owned(),\n        code: 500,\n        message: \"Internal Server Error\".to_owned(),\n        headers: vec![],\n        content: vec![],\n    }, None)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: These bash commands clone the example repository and compile the Rust code to WebAssembly using the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/bindgen.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_bindgen_funcs\n$cargo build --release --target wasm32-wasip1\n# The output WASM will be target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Go Dependency and Running Executable for Listing Functions\nDESCRIPTION: Builds and runs a Go project to list exported functions in a WASM module using WasmEdge. It downloads necessary dependencies, compiles the code, and executes the program to list function names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\n$ go build\n$ ./wasmedge_test\nExported function name: fib\n```\n\n----------------------------------------\n\nTITLE: Creating Inner Page React Component for SSR in JavaScript\nDESCRIPTION: This code defines a simple React component 'LazyPage' that represents the inner page content. It is designed to be lazy-loaded in the server-side rendering process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\n\nclass LazyPage extends React.Component {\n  render() {\n    return (\n      <div>\n        <div>This is lazy page</div>\n      </div>\n    );\n  }\n}\n\nexport default LazyPage;\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with Image Plugin Support\nDESCRIPTION: Commands to build WasmEdge from source with the WasmEdge-Image plugin enabled using the -DWASMEDGE_PLUGIN_IMAGE=On CMake option. Includes steps for configuring, building, and installing the project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/image.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On\ncmake --build build\n# For the WasmEdge-Image plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Adding WasmEdge SDK Dependency in Cargo.toml\nDESCRIPTION: Configuration to add the wasmedge-sdk crate as a dependency in a Rust project's Cargo.toml file. This example shows adding version 0.11.0 which is compatible with WasmEdge v0.13.3.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nwasmedge-sdk = \"0.11.0\"\n```\n\n----------------------------------------\n\nTITLE: Printing Top-5 Classification Results in Rust\nDESCRIPTION: This Rust snippet sorts and prints the top-5 results from the model inference, requiring sorted output tensor data. It depends on previous tensor operations and result structuring.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet results = sort_results(&output_buffer);\nfor i in 0..5 {\nprintln!(\n\"   {}.) [{}]({:.4}){}\",\ni + 1,\nresults[i].0,\nresults[i].1,\nimagenet_classes::AIY_BIRDS_V1[results[i].0]\n);\n}\n```\n\n----------------------------------------\n\nTITLE: Get Kubernetes Node Status\nDESCRIPTION: This snippet uses `kubectl` to retrieve the status of the nodes in the Kubernetes cluster.  It requires `kubectl` to be configured to communicate with the Kubernetes cluster. The output displays the name, status, roles, age, and version of each node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get node\n```\n\n----------------------------------------\n\nTITLE: Cloning and Building reqwest Demo with Rust in WasmEdge\nDESCRIPTION: This bash script clones a demo repository for reqwest and builds it using Rust in the WasmEdge environment. It uses specific RUSTFLAGS to optimize for WasmEdge and employs the AoT compiler for better performance. Outputs include compiled wasm files for HTTP and HTTPS operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_reqwest_demo\ncd wasmedge_reqwest_demo\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/http.wasm http.wasm\nwasmedge compile target/wasm32-wasip1/release/https.wasm https.wasm\n\n# Run the HTTP GET and POST examples\nwasmedge http.wasm\n\n# Run the HTTPS GET and POST examples\nwasmedge https.wasm\n```\n\n----------------------------------------\n\nTITLE: Manual Asynchronous Execution of WASM Functions in C\nDESCRIPTION: This C code snippet illustrates a step-by-step execution of a WASM function using WasmEdge VM context APIs. Developers can execute the \"fib\" function from a WASM file manually by loading, validating, and instantiating the module before asynchronous execution. The code handles errors in each phase and retrieves the function result for an input parameter. Dependencies include the WasmEdge C library and an appropriate WASM file. This setup allows running multiple functions and detecting runtime issues.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\\n#include <stdio.h>\\nint main() {\\n  /* Create the VM context. */\\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\\n\\n  /* The parameters and returns arrays. */\\n  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };\\n  WasmEdge_Value Returns[1];\\n  /* Function name. */\\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\\n  /* Result. */\\n  WasmEdge_Result Res;\\n\\n  /* Step 1: Load WASM file. */\\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\\n  /*\\n   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,\\n   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.\\n   */\\n  if (!WasmEdge_ResultOK(Res)) {\\n    printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\\n    return 1;\\n  }\\n  /* Step 2: Validate the WASM module. */\\n  Res = WasmEdge_VMValidate(VMCxt);\\n  if (!WasmEdge_ResultOK(Res)) {\\n    printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\\n    return 1;\\n  }\\n  /* Step 3: Instantiate the WASM module. */\\n  Res = WasmEdge_VMInstantiate(VMCxt);\\n  /*\\n   * Developers can load, validate, and instantiate another WASM module to replace the\\n   * instantiated one. In this case, the old module will be cleared, but the registered\\n   * modules are still kept.\\n   */\\n  if (!WasmEdge_ResultOK(Res)) {\\n    printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\\n    return 1;\\n  }\\n  /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */\\n  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\\n  /*\\n   * Developers can execute functions repeatedly after instantiation.\\n   * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.\\n   */\\n\\n  /* Wait and check the return values length. */\\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\\n  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */\\n\\n  /* Get the result. */\\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\\n  if (WasmEdge_ResultOK(Res)) {\\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\\n  } else {\\n    printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\\n  }\\n\\n  /* Resources deallocations. */\\n  WasmEdge_AsyncDelete(Async);\\n  WasmEdge_VMDelete(VMCxt);\\n  WasmEdge_StringDelete(FuncName);\\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Instances in Store Context in C\nDESCRIPTION: Shows how to find a specific exported function instance in a Store context using its name. It demonstrates creating a string, finding the function, and proper cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* ... Instantiate a WASM module via the executor context. */\n\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);\n/* `FuncCxt` will be `NULL` if the function not found. */\n/* The returned instance is owned by the store context and should __NOT__ be destroyed. */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Running TCP Echo Server and Client Example in WasmEdge\nDESCRIPTION: Command and output from executing the TCP server/client example in WasmEdge. The example creates both a TCP server and client that communicate with each other.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_net_echo.js\nlisten 8000 ...\nserver accept: 127.0.0.1:49040\nserver recv: hello\nclient recv: echo:hello\n```\n\n----------------------------------------\n\nTITLE: Annotate Kubernetes Nodes for Kwasm\nDESCRIPTION: This command annotates all nodes in the Kubernetes cluster to indicate that they should be used for Kwasm workloads. The annotation `kwasm.sh/kwasm-node=true` is added to each node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl annotate node --all kwasm.sh/kwasm-node=true\n```\n\n----------------------------------------\n\nTITLE: Creating MySQL Table\nDESCRIPTION: Rust code for checking and creating a MySQL table if it doesn't exist\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    // create table if no tables exist\n    let result = r\"SHOW TABLES LIKE 'orders';\"\n        .with(())\n        .map(&mut conn, |s: String| String::from(s))\n        .await?;\n\n    if result.len() == 0 {\n        // table doesn't exist, create a new one\n        r\"CREATE TABLE orders (order_id INT, production_id INT, quantity INT, amount FLOAT, shipping FLOAT, tax FLOAT, shipping_address VARCHAR(20));\".ignore(&mut conn).await?;\n        println!(\"create new table\");\n    } else {\n        // delete all data from the table.\n        println!(\"delete all from orders\");\n        r\"DELETE FROM orders;\".ignore(&mut conn).await?;\n    }\n```\n\n----------------------------------------\n\nTITLE: Activating WasmEdge in Current Session\nDESCRIPTION: Makes the installed WasmEdge binary available in the current shell session by sourcing the environment file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsource $HOME/.wasmedge/env\n```\n\n----------------------------------------\n\nTITLE: Parsing Command-Line Arguments in Rust\nDESCRIPTION: This Rust snippet captures the command-line arguments for the model and image file names for further processing in the code. It assumes input files are correctly named and exist.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet args: Vec<String> = env::args().collect();\nlet model_bin_name: &str = &args[1]; // File name for the TFLite model\nlet image_name: &str = &args[2]; // File name for the input image\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with Image Plugin Support\nDESCRIPTION: Commands to build and install WasmEdge from source with the WasmEdge-Image plugin enabled using the -DWASMEDGE_PLUGIN_IMAGE=On cmake option.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/image.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On\ncmake --build build\n# For the WasmEdge-Image plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: WasmEdge String Handling Examples\nDESCRIPTION: Examples showing various string operations in WasmEdge including creation, wrapping, comparison, and conversion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Qdrant Client Example in Rust\nDESCRIPTION: This Rust program uses the `qdrant_rest_client` crate to interact with a local Qdrant server. It creates a collection, inserts points (vectors) with payloads, retrieves and searches for points, and finally deletes points from the collection. It demonstrates basic vector data operations against a Qdrant database.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/qdrant_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    let client = qdrant::Qdrant::new();\n    // Create a collection with 10-dimensional vectors\n    let r = client.create_collection(\"my_test\", 4).await;\n    println!(\"Create collection result is {:?}\", r);\n\n    let mut points = Vec::<Point>::new();\n    points.push(Point {\n        id: PointId::Num(1),\n        vector: vec![0.05, 0.61, 0.76, 0.74],\n        payload: json!({\"city\": \"Berlin\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(2),\n        vector: vec![0.19, 0.81, 0.75, 0.11],\n        payload: json!({\"city\": \"London\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(3),\n        vector: vec![0.36, 0.55, 0.47, 0.94],\n        payload: json!({\"city\": \"Moscow\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(4),\n        vector: vec![0.18, 0.01, 0.85, 0.80],\n        payload: json!({\"city\": \"New York\"})\n            .as_object()\n            .map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(5),\n        vector: vec![0.24, 0.18, 0.22, 0.44],\n        payload: json!({\"city\": \"Beijing\"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(6),\n        vector: vec![0.35, 0.08, 0.11, 0.44],\n        payload: json!({\"city\": \"Mumbai\"}).as_object().map(|m| m.to_owned()),\n    });\n\n    let r = client.upsert_points(\"my_test\", points).await;\n    println!(\"Upsert points result is {:?}\", r);\n\n    println!(\n        \"The collection size is {}\",\n        client.collection_info(\"my_test\").await\n    );\n\n    let p = client.get_point(\"my_test\", 2).await;\n    println!(\"The second point is {:?}\", p);\n\n    let ps = client.get_points(\"my_test\", vec![1, 2, 3, 4, 5, 6]).await;\n    println!(\"The 1-6 points are {:?}\", ps);\n\n    let q = vec![0.2, 0.1, 0.9, 0.7];\n    let r = client.search_points(\"my_test\", q, 2, None).await;\n    println!(\"Search result points are {:?}\", r);\n\n    let r = client.delete_points(\"my_test\", vec![1, 4]).await;\n    println!(\"Delete points result is {:?}\", r);\n\n    println!(\n        \"The collection size is {}\",\n        client.collection_info(\"my_test\").await\n    );\n\n    let q = vec![0.2, 0.1, 0.9, 0.7];\n    let r = client.search_points(\"my_test\", q, 2, None).await;\n    println!(\"Search result points are {:?}\", r);\n    Ok(())\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge C++ SDK Example\nDESCRIPTION: This bash command shows how to run the compiled WasmEdge C++ SDK example program.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c++/intro.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./example\n```\n\n----------------------------------------\n\nTITLE: Processing Inference Results in Rust\nDESCRIPTION: Rust code for sorting and displaying the top 5 classification results from the inference output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/openvino.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet results = sort_results(&output_buffer);\nfor i in 0..5 {\n    println!(\n        \"   {}.) [{}]({:.4}){}\",\n        i + 1,\n        results[i].0,\n        results[i].1,\n        imagenet_classes::IMAGENET_CLASSES[results[i].0]\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Generating and Verifying CDI Specification for NVIDIA GPUs in Bash\nDESCRIPTION: Commands to generate the Container Device Interface (CDI) specification file for NVIDIA GPUs and verify the CDI configuration. This setup allows containers to access GPU devices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml\n\n# Check you cdi config is good\n> nvidia-ctk cdi list\n\n# Example output\nINFO[0000] Found 2 CDI devices\nnvidia.com/gpu=0\nnvidia.com/gpu=all\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Module Function in JavaScript\nDESCRIPTION: This code snippet defines a simple function 'hello_mod_1' in a custom module file 'my_mod_1.js'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/modules.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport function hello_mod_1() {\n  console.log('hello from \"my_mod_1.js\"');\n}\n```\n\n----------------------------------------\n\nTITLE: Running Inference with WasmEdge Bash\nDESCRIPTION: The snippet demonstrates how to run the Mediapipe object detection model against an input image using WasmEdge, by mounting the current directory and executing the compiled WebAssembly file with an input image file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. demo-object-detection.wasm example.jpg output.jpg\n```\n\n----------------------------------------\n\nTITLE: Updating MySQL Records\nDESCRIPTION: Rust code demonstrating how to update existing records in MySQL database\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n    // update some data\n    r\"UPDATE orders\n    SET shipping_address = '8366 Elizabeth St.'\n    WHERE order_id = 2;\"\n        .ignore(&mut conn)\n        .await?;\n    // query data\n    let loaded_orders = \"SELECT * FROM orders\"\n        .with(())\n        .map(\n            &mut conn,\n            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {\n                Order::new(\n                    order_id,\n                    production_id,\n                    quantity,\n                    amount,\n                    shipping,\n                    tax,\n                    shipping_address,\n                )\n            },\n        )\n        .await?;\n    dbg!(loaded_orders.len());\n    dbg!(loaded_orders);\n```\n\n----------------------------------------\n\nTITLE: Forcing Interpreter Mode in WasmEdge\nDESCRIPTION: Example demonstrating how to force WasmEdge to use interpreter mode even for AOT compiled WASM files. This allows running any WASM in interpreter mode rather than using the compiled code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\nis_forceinterp := conf.IsForceInterpreter()\n// By default, the `is_forceinterp` will be `false`.\nconf.SetForceInterpreter(true)\nis_forceinterp = conf.IsForceInterpreter()\n/* The `is_forceinterp` will be `true`. */\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Extracting Output from TensorFlow Session\nDESCRIPTION: This Rust snippet retrieves the inference output from the TensorFlow session as a vector of floating-point numbers, allowing for further processing or analysis of model results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet res_vec: Vec<f32> = session.get_output(\"MobilenetV2/Predictions/Softmax\");\n```\n\n----------------------------------------\n\nTITLE: Building Go Project for WasmEdge\nDESCRIPTION: This bash code snippet demonstrates how to build the Go project. It uses the command go build to build the project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\n$ go build\n```\n\n----------------------------------------\n\nTITLE: Building Rust WebAssembly Module for Image Classification\nDESCRIPTION: Commands to build the Rust image classification program into WebAssembly bytecode and copy the artifact to the appropriate folder.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd api/functions/image-classification/\ncargo build --release --target wasm32-wasip1\ncp target/wasm32-wasip1/release/classify.wasm ../../\n```\n\n----------------------------------------\n\nTITLE: AoT Compilation and Execution of Addition Function\nDESCRIPTION: Commands to compile the addition function WebAssembly to native code using WasmEdge's AoT compiler and then run it for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedgec add.wasm add_aot.wasm\n$ wasmedge add_aot.wasm 4 9\n13\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Image Classification Service\nDESCRIPTION: Commands to build and deploy the TensorFlow-based image classification microservice\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/dapr.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd image-api-classify\ncargo build --target wasm32-wasip1 --release\nwasmedgec target/wasm32-wasip1/release/wasmedge_hyper_server_tflite.wasm wasmedge_hyper_server_tflite.wasm\n```\n\nLANGUAGE: bash\nCODE:\n```\ndapr run --app-id image-api-classify \\\n        --app-protocol http \\\n        --app-port 9006 \\\n        --dapr-http-port 3504 \\\n        --log-level debug \\\n        --components-path ../config \\\n        wasmedge-tensorflow-lite wasmedge_hyper_server_tflite.wasm\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Default Paths\nDESCRIPTION: Code snippet showing how to load WasmEdge plugins from default paths and list all loaded plugins. This enables extending WasmEdge runtime with additional functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_71\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\npluginnames := wasmedge.ListPlugins()\nfor _, name := range pluginnames {\n  fmt.Println(\"Loaded plug-in name: \", name)\n}\n```\n\n----------------------------------------\n\nTITLE: Building NPM Dependencies with Bash Commands\nDESCRIPTION: Commands to install dependencies and build the bundled JavaScript file using NPM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/npm.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd example_js/simple_common_js_demo\nnpm install\nnpm run build\n# Go back to the working directory\ncd ../../\n```\n\n----------------------------------------\n\nTITLE: Building Rust WASM Module\nDESCRIPTION: Command to build a Rust project into a WebAssembly module targeting the WASI platform\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/wasm-nginx.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --target=wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Building crun with WasmEdge Support for KinD\nDESCRIPTION: Dockerfile instructions for the first stage of building a custom KinD image. This stage builds crun with WasmEdge support from source, which will be used to replace the default runtime in KinD.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_1\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM ubuntu:21.10 AS builder\nWORKDIR /data\nRUN DEBIAN_FRONTEND=noninteractive apt update \\\n    && DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \\\n    && curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \\\n    && git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \\\n    && cd crun \\\n    && ./autogen.sh \\\n    && ./configure --with-wasmedge --enable-embedded-yajl\\\n    && make\n\n...\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge on Windows with CMake\nDESCRIPTION: PowerShell commands to configure the build environment, select compiler (Clang-cl or MSVC), and compile WasmEdge using CMake and Ninja. The script sets up Visual Studio tools and LLVM dependencies properly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/windows.md#2025-04-21_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n$vsPath = (vswhere -latest -property installationPath)\nImport-Module (Join-Path $vsPath \"Common7\\Tools\\Microsoft.VisualStudio.DevShell.dll\")\nEnter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \"-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0\"\n# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.\n# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \"-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933\"\n\n# Set LLVM path according to the download location\n$llvm_dir = \"$pwd\\LLVM-16.0.6-win64-MultiThreadedDLL\\LLVM-16.0.6-win64\\lib\\cmake\\llvm\"\n\n# Use clang-cl as the compiler.\n# Comment out the following two lines to use MSVC.\n$Env:CC = \"clang-cl\"\n$Env:CXX = \"clang-cl\"\n\ncmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL \"-DLLVM_DIR=$llvm_dir\" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=\"ZIP\" .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Processing Inference Output in Rust\nDESCRIPTION: Rust code for extracting and processing the inference results from the computation context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n  let mut output_buffer = vec![0u8; *CTX_SIZE.get().unwrap()];\n    let mut output_size = context\n        .get_output(0, &mut output_buffer)\n        .expect(\"Failed to get output tensor\");\n    output_size = std::cmp::min(*CTX_SIZE.get().unwrap(), output_size);\n    let output = String::from_utf8_lossy(&output_buffer[..output_size]).to_string();\n```\n\n----------------------------------------\n\nTITLE: Installing Kubernetes for Local Development using Bash\nDESCRIPTION: This snippet outlines the commands needed to install Go, clone the Kubernetes repository, and set up etcd, all essential for local Kubernetes development. Dependencies include wget, git, and build tools such as build-essential.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install go\n$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz\n$ sudo rm -rf /usr/local/go\nsudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz\nsource /home/${USER}/.profile\n\n# Clone k8s\ngit clone https://github.com/kubernetes/kubernetes.git\ncd kubernetes\ngit checkout v1.22.2\n\n# Install etcd with hack script in k8s\nsudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh\nexport PATH=\"/home/${USER}/kubernetes/third_party/etcd:${PATH}\"\nsudo cp third_party/etcd/etcd* /usr/local/bin/\n\n# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl\n\n# Build and run k8s with CRI-O\nsudo apt-get install -y build-essential\nsudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh\n\n... ...\nLocal Kubernetes cluster is running. Press Ctrl-C to shut it down.\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C for WasmEdge\nDESCRIPTION: Function signature for defining host functions in WasmEdge, showing the required parameters including data pointer, memory context, input parameters, and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_66\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n  void *Data,\n  WasmEdge_MemoryInstanceContext *MemCxt,\n  const WasmEdge_Value *Params,\n  WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with ImportObject (WasmEdge Pre-0.10.0)\nDESCRIPTION: Shows how to create host functions and add them to an ImportObject in WasmEdge versions before 0.10.0. This example implements an 'add' function that takes two i32 parameters and returns their sum.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create the import object. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the import object. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/*\n * The import objects should be deleted.\n * Developers should __NOT__ destroy the instances added into the import object contexts.\n */\nWasmEdge_ImportObjectDelete(ImpObj);\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format (WAT) code defining a recursive Fibonacci function that is exported as 'fib'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_26\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n (export \"fib\" (func $fib))\n (func $fib (param $n i32) (result i32)\n  (if\n   (i32.lt_s (get_local $n)(i32.const 2))\n   (return (i32.const 1))\n  )\n  (return\n   (i32.add\n    (call $fib (i32.sub (get_local $n)(i32.const 2)))\n    (call $fib (i32.sub (get_local $n)(i32.const 1)))\n   )\n  )\n )\n)\n```\n\n----------------------------------------\n\nTITLE: Wrapping a C String in a WasmEdge String\nDESCRIPTION: This C code shows how to wrap an existing C string in a `WasmEdge_String` object using `WasmEdge_StringWrap`. The code highlights that the wrapped string should not be deleted using `WasmEdge_StringDelete` because the `WasmEdge_String` object does not own the underlying memory. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"test\";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN Whisper Backend\nDESCRIPTION: Commands to build WasmEdge from source with the WASI-NN Whisper backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"Whisper\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Example WebAssembly Module with External Function Import\nDESCRIPTION: WebAssembly Text Format (WAT) example showing a module that imports an external function for addition and exports a wrapper function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_71\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n```\n\n----------------------------------------\n\nTITLE: Building Tokio-based WebAssembly Application\nDESCRIPTION: Command to build a Rust application with Tokio support for WebAssembly target with required feature flags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Handling Global Type Context in C\nDESCRIPTION: Example of creating and working with Global Type context, including setting value types and mutability for global instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\nWasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages in WasmEdge Executor and VM (C)\nDESCRIPTION: This C code adjusts the maximum memory page size for memory instances in WasmEdge, preventing page size from exceeding a set limit. Dependencies: WasmEdge C library. Outputs: Configured page size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: WASM Module Instantiation (WasmEdge 0.10.0)\nDESCRIPTION: Updated method for instantiating multiple WASM modules in WasmEdge 0.10.0. The instantiated module instances are returned to the caller who is responsible for their lifecycle management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt1, *ASTCxt2;\n/*\n * Assume that `ASTCxt1` and `ASTCxt2` are loaded WASMs from different files or buffers,\n * and have both passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\nWasmEdge_ModuleInstanceContext *ModCxt1 = NULL;\nWasmEdge_ModuleInstanceContext *ModCxt2 = NULL;\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt1);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt2, StoreCxt, ASTCxt2);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: These bash commands clone the example repository and compile the Rust code into WebAssembly bytecode functions using the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/function.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_bindgen_funcs\ncargo build --release --target wasm32-wasip1\n# The output WASM will be target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Accessing VM Components\nDESCRIPTION: Shows how to retrieve the Loader, Validator, and Executor contexts from a WasmEdge VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous HTTP PUT Request with Fetch\nDESCRIPTION: JavaScript code demonstrating an asynchronous HTTP PUT request with JSON data using fetch API. The example sends JSON data with appropriate content-type headers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nasync function test_fetch_put() {\n  try {\n    let r = await fetch('http://httpbin.org/put', {\n      method: 'put',\n      body: JSON.stringify({ a: 1 }),\n      headers: { 'Context-type': 'application/json' },\n    });\n    print('test_fetch_put\\n', await r.text());\n  } catch (e) {\n    print(e);\n  }\n}\ntest_fetch_put();\n```\n\n----------------------------------------\n\nTITLE: Patching Cargo.toml for hyper in WasmEdge\nDESCRIPTION: This toml configuration snippet shows how to patch the hyper crate for use in WasmEdge, specifying git sources for tokio, socket2, and hyper to ensure compatibility. It configures dependencies for hyper and tokio with relevant features for asynchronous IO.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\nhyper = { version = \"0.14\", features = [\"full\"] }\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\", \"io-util\"] }\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Version API Usage\nDESCRIPTION: Example showing how to retrieve various version components (major, minor, patch) using the WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals in WasmEdge Configuration\nDESCRIPTION: Shows how to add, remove, and check WebAssembly proposals in a WasmEdge configuration context. By default, several proposals are enabled, and this code demonstrates how to customize the enabled proposal set.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\n/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge C API Installation (C)\nDESCRIPTION: Simple C program to test the availability of WasmEdge C API by printing the installed version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Container in Kubernetes 1.20.11\nDESCRIPTION: Command to run a WebAssembly container as a pod in Kubernetes 1.20.11 using kubectl. It includes necessary annotations and overrides for WasmEdge compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN llama.cpp Backend on macOS (Intel)\nDESCRIPTION: CMake commands to build WasmEdge with the WASI-NN llama.cpp backend on macOS Intel processors, without GPU acceleration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=OFF \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Final WASM Container Stage\nDESCRIPTION: Dockerfile section that creates the final minimal WASM container with only the compiled binary\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_3\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM scratch\nENTRYPOINT [ \"hello.wasm\" ]\nCOPY --link --from=build /src/target/wasm32-wasip1/release/hello.wasm /hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Image Decoding and Conversion using WasmEdge\nDESCRIPTION: This Rust snippet provides functions for decoding JPEG and PNG images and converting them to various color formats such as RGB8, BGR8, RGB32F, and BGR32F using the WasmEdge-Image host functions, enabling efficient image processing in the correct format before model inference.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Function to decode JPEG from buffer and resize to RGB8 format.\npub fn load_jpg_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode JPEG from buffer and resize to BGR8 format.\npub fn load_jpg_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode JPEG from buffer and resize to RGB32F format.\npub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n// Function to decode JPEG from buffer and resize to BGR32F format.\npub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n\n// Function to decode PNG from buffer and resize to RGB8 format.\npub fn load_png_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode PNG from buffer and resize to BGR8 format.\npub fn load_png_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode PNG from buffer and resize to RGB32F format.\npub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n// Function to decode PNG from buffer and resize to BGR32F format.\npub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n```\n\n----------------------------------------\n\nTITLE: Executing MySQL Statements with TLS (Bash)\nDESCRIPTION: This command demonstrates how to execute MySQL statements against an AWS RDS database that requires TLS.  It sets the `DATABASE_SSL` environment variable to `1` to enable TLS and specifies the connection URL via the `DATABASE_URL` environment variable before executing the WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --env \"DATABASE_SSL=1\" --env \"DATABASE_URL=mysql://user:passwd@mydb.123456789012.us-east-1.rds.amazonaws.com:3306/mysql\" crud.wasm\n```\n\n----------------------------------------\n\nTITLE: Running Fibonacci Calculator in WasmEdge\nDESCRIPTION: Command to execute the compiled Fibonacci calculator WebAssembly file in WasmEdge, demonstrating the calculation of the 6th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge fib.wasm 6\n5\n```\n\n----------------------------------------\n\nTITLE: Installing WASI SDK\nDESCRIPTION: Commands to download and install the WASI SDK toolchain for building wasm-bpf examples.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ && sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Defines the WasmEdge_Limit struct used to represent WASM limits. It includes fields for minimum and maximum values, as well as flags for indicating if a maximum is set and if the memory is shared.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Running Fetch API Example in WasmEdge\nDESCRIPTION: Command to execute the HTTP fetch example JavaScript file using WasmEdge runtime. The command mounts the current directory and runs the example file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_fetch.js\n```\n\n----------------------------------------\n\nTITLE: Updating OpenWRT Package Feeds\nDESCRIPTION: Commands to update and install OpenWRT package definitions and symlinks.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd openwrt\n./scripts/feeds update -a\n./scripts/feeds install -a\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function with Error Code (Pre-0.11.0)\nDESCRIPTION: Example of a host function that returns a failure result in WasmEdge versions prior to 0.11.0. This approach always returns a generic failure without a specific error code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM. */\n  return WasmEdge_Result_Fail;\n}\n```\n\n----------------------------------------\n\nTITLE: Moving TensorFlow-Lite Libraries to System Path\nDESCRIPTION: Commands to move the TensorFlow-Lite libraries to the system library path. This makes the libraries available to WasmEdge at runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflowlite_c.so /usr/local/lib\nmv libtensorflowlite_flex.so /usr/local/lib\n```\n\n----------------------------------------\n\nTITLE: Retrieving Async Execution Results\nDESCRIPTION: Shows how to retrieve execution results using WasmEdge_AsyncGet() API. Blocks until execution completes and fills a buffer with return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Cloning and building WasmEdge TensorFlow-Lite sample application\nDESCRIPTION: Commands to clone the sample application repository, build the WASM bytecode file, and push necessary files to the Android device.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasm-learning.git\ncd wasm-learning/rust/birds_v1\nrustup target add wasm32-wasip1\ncargo build --release --target=wasm32-wasip1\nadb push target/wasm32-wasip1/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools\nadb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools\nadb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function with User-Defined Error Code in C\nDESCRIPTION: Example of implementing a host function that returns a user-defined error code using WasmEdge_ResultGen(). This demonstrates how to specify custom error codes in host functions after the 0.11.0 update.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result FaildFunc(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM with the error code. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing eBPF program for tracking process execution in C\nDESCRIPTION: A BPF program that tracks process execution events, wraps the event data in a struct, and sends it to userspace through a ring buffer. It demonstrates the use of BPF maps, CO-RE, and vmlinux.h to read process information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/bpf.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec* ctx) {\n    struct task_struct* task;\n    unsigned fname_off;\n    struct event* e;\n    pid_t pid;\n    u64 ts;\n\n    /* remember time exec() was executed for this PID */\n    pid = bpf_get_current_pid_tgid() >> 32;\n    ts = bpf_ktime_get_ns();\n    bpf_map_update_elem(&exec_start, &pid, &ts, BPF_ANY);\n\n    /* don't emit exec events when minimum duration is specified */\n    if (min_duration_ns)\n        return 0;\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    /* fill out the sample with data */\n    task = (struct task_struct*)bpf_get_current_task();\n\n    e->exit_event = false;\n    e->pid = pid;\n    e->ppid = BPF_CORE_READ(task, real_parent, tgid);\n    bpf_get_current_comm(&e->comm, sizeof(e->comm));\n\n    fname_off = ctx->__data_loc_filename & 0xFFFF;\n    bpf_probe_read_str(&e->filename, sizeof(e->filename),\n                       (void*)ctx + fname_off);\n\n    /* successfully submit it to user-space for post-processing */\n    bpf_ringbuf_submit(e, 0);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Podman and WasmEdge on Fedora\nDESCRIPTION: Commands to install Podman container runtime and WasmEdge WebAssembly runtime on Fedora using the dnf package manager.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/podman.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf -y install podman\nsudo dnf -y install wasmedge\n```\n\n----------------------------------------\n\nTITLE: Running a JavaScript-based Server with WasmEdge and Podman\nDESCRIPTION: Illustrates running a JavaScript HTTP server using WasmEdge as a lightweight runtime for node.js applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npodman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/node-example-server:latest\n```\n\n----------------------------------------\n\nTITLE: Listing Running Pods in Kubernetes\nDESCRIPTION: Command to view all running pods across all namespaces with detailed information including IP addresses and node assignments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide\n\nNAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES\ndefault       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   <none>           <none>\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Plugin with GCC Command\nDESCRIPTION: Command to compile a WasmEdge plugin as a shared library using GCC. The command sets the C standard to C11 and defines the WASMEDGE_PLUGIN macro which is necessary for plugin compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngcc -std=c11 -DWASMEDGE_PLUGIN -shared -o libwasmedgePluginTest.so testplugin.c\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with llama.cpp Backend on NVIDIA Jetson AGX Orin\nDESCRIPTION: Commands to build WasmEdge with the llama.cpp (GGML) backend on NVIDIA Jetson AGX Orin. This enables CUBLAS for GPU acceleration with the specific CUDA architecture for the Orin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\n# Due to cuda-related files, it will produce some warning.\n# Disable the warning as an error to avoid failures.\nexport CXXFLAGS=\"-Wno-error\"\n# Please make sure you set up the correct CUDAARCHS.\n# 72 is for NVIDIA Jetson AGX Orin\nexport CUDAARCHS=72\n\n# BLAS cannot work with CUBLAS\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Host Data Example with WasmEdge C API\nDESCRIPTION: This snippet demonstrates how to pass external data to a host function in WasmEdge. It defines a function that can access and modify a data pointer passed during creation, showing how to maintain state between host and WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_71\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                   const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Instances in Store Context in C\nDESCRIPTION: Demonstrates how to list exported function instances from a Store context. It shows the use of buffer-based APIs to retrieve function names efficiently.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* ... Instantiate a WASM module via the executor context. */\n\nuint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\nuint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n```\n\n----------------------------------------\n\nTITLE: Running Llama2 Inference with Podman and WasmEdge\nDESCRIPTION: Complete command to run a WebAssembly container using Podman with GPU acceleration. This command mounts necessary libraries and the model file, sets environment variables for WasmEdge and GPU configuration, and runs a Llama2 inference example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo <podman path> run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \\\n  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \\\n  -v .:/resource \\\n  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \\\n  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \\\n  --env n_gpu_layers=100 \\\n  --rm --device nvidia.com/gpu=all --runtime <crun path> --annotation module.wasm.image/variant=compat-smart --platform wasip1/wasm \\\n  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \\\n  $'[INST] <<SYS>>\\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\\n<</SYS>>\\nWhat is the capital of Japan?[/INST]'\n```\n\n----------------------------------------\n\nTITLE: Creating Host Functions with Module Instances in WasmEdge 0.10.0+\nDESCRIPTION: Shows how to create a host function in C for WasmEdge version 0.10.0 and later. This approach uses module instances instead of import objects while maintaining the same host function implementation of adding two integers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Building and Installing crun with WasmEdge Support\nDESCRIPTION: Commands to clone, configure, build, and install crun with WasmEdge support. The --with-wasmedge flag enables WasmEdge integration in crun.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions - Pre v0.11.0\nDESCRIPTION: Example showing memory access in host functions before v0.11.0, using direct memory instance context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Plugins\nDESCRIPTION: This command installs WasmEdge along with specified plugins using the `--plugins` parameter. It downloads and installs the specified plugins to the appropriate directory for WasmEdge to use. This allows extending the WasmEdge runtime with additional functionalities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-tensorflowlite\n```\n\n----------------------------------------\n\nTITLE: Building Rust WebAssembly App\nDESCRIPTION: Command to compile a Rust application targeting WebAssembly using the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Running WASI Application with Podman on Fedora\nDESCRIPTION: Command to run a WebAssembly System Interface (WASI) application using Podman on Fedora. The command uses a pre-built Docker image and specifies the WASM module to run.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/podman.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npodman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge-Go Package\nDESCRIPTION: Commands to get and build the WasmEdge-Go package\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\\ngo build\n```\n\n----------------------------------------\n\nTITLE: Running Inference with WasmEdge CLI (Bash)\nDESCRIPTION: Executes the compiled WASM file using the WasmEdge CLI, providing the necessary model and input image as arguments.  The `--dir .:.` option maps the current directory to the WASM's filesystem, allowing access to the model and image files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg\n```\n\n----------------------------------------\n\nTITLE: Pushing Files to Android Device Using ADB\nDESCRIPTION: Commands to push the compiled application, WebAssembly module, TensorFlow Lite model, test image, and required libraries to an Android device using ADB.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/ndk.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nadb push a.out /data/local/tmp\nadb push birds_v1.wasm /data/local/tmp\nadb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp\nadb push bird.jpg /data/local/tmp\nadb push ./WasmEdge-0.12.1-Android/lib /data/local/tmp\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes RuntimeClass for WebAssembly\nDESCRIPTION: Command to create a RuntimeClass in Kubernetes that specifies the use of the wasmedge runtime for objects labeled with 'runtime=wasm'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh apply -f - <<< '{\"apiVersion\":\"node.k8s.io/v1\",\"kind\":\"RuntimeClass\",\"metadata\":{\"name\":\"wasm\"},\"scheduling\":{\"nodeSelector\":{\"runtime\":\"wasm\"}},\"handler\":\"wasmedge\"}'\n```\n\n----------------------------------------\n\nTITLE: Building and Running MySQL Example in WasmEdge\nDESCRIPTION: Commands to clone, compile and execute the MySQL connector example with WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/mysql_async\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Execute MySQL statements against a MySQL database at mysql://user:passwd@127.0.0.1:3306\nwasmedge --env \"DATABASE_URL=mysql://user:passwd@127.0.0.1:3306/mysql\" target/wasm32-wasip1/release/crud.wasm\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Docker Container for Node.js Server\nDESCRIPTION: Shell commands to build and run a Docker container with a lightweight Node.js server using WasmEdge QuickJS. Shows the process of building the image and starting the server with port mapping.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 8001:8001 wasmedge/myapp\nlisten 8001 ...\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in Go\nDESCRIPTION: Defines the function signature for host functions in WasmEdge-go. This signature is used to create custom host functions that can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_57\n\nLANGUAGE: go\nCODE:\n```\ntype hostFunctionSignature func(\n    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)\n```\n\n----------------------------------------\n\nTITLE: Running WASI Application with Podman on Other Linux Distributions\nDESCRIPTION: Command to run a WebAssembly System Interface (WASI) application using Podman on non-Fedora Linux distributions. This uses the same Docker image and WASM module as the Fedora example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/podman.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npodman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Final Node.js WASM Container\nDESCRIPTION: Dockerfile section that creates the final Node.js WASM container with runtime and application files\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_6\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM scratch\nENTRYPOINT [ \"wasmedge_quickjs.wasm\", \"server.js\" ]\nCOPY --link --from=build /src/wasmedge_quickjs.wasm /wasmedge_quickjs.wasm\nCOPY --link --from=build /src/server.js /server.js\nCOPY --link --from=build /src/modules /modules\n```\n\n----------------------------------------\n\nTITLE: Global Instance Retrieval Before v0.10.0\nDESCRIPTION: Example showing how to retrieve a global instance from store using WasmEdge-Go before v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm`, and exports the \"global_i32\".\nstore := vm.GetStore()\n\nglobinst := store.FindGlobal(\"global_i32\")\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugin from Specific Path\nDESCRIPTION: Shows how to load a WasmEdge plugin from a specific file system path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadFromPath(\"PATH_TO_PLUGIN/plugin.so\");\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for TensorFlow Inference with WasmEdge\nDESCRIPTION: Dockerfile configuration to run a TensorFlow inference application using WasmEdge TensorFlow Lite. It uses wasmedge/slim-tf as the base image and sets up a container for image recognition service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_9\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-tf:0.10.1\nADD wasmedge_hyper_server_tflite.wasm /\nCMD [\"wasmedge-tensorflow-lite\", \"--dir\", \".:/\", \"/wasmedge_hyper_server_tflite.wasm\"]\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration\nDESCRIPTION: Cargo configuration for WasmEdge target and runner settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"wasm32-wasip1\"\n\n[target.wasm32-wasip1]\nrunner = \"wasmedge --dir /static:../client/build\"\n```\n\n----------------------------------------\n\nTITLE: Generating Fibonacci Sequence in Rust\nDESCRIPTION: The Rust function 'fib_array' calculates Fibonacci numbers and fills a provided array. It uses a mutable raw pointer to construct a Vec and computes the Fibonacci sequence based on the input parameter. 'fib_array_return_memory' returns a pointer to the allocated memory containing the Fibonacci sequence.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#include <std::mem>\n#include <std::os::raw::{c_void, c_int}>\n\n#[no_mangle]\npub extern fn fib_array(n: i32, p: *mut c_int) -> i32 {\n  unsafe {\n    let mut arr = Vec::<i32>::from_raw_parts(p, 0, (4*n) as usize);\n    for i in 0..n {\n      if i < 2 {\n        arr.push(i);\n      } else {\n        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);\n      }\n    }\n    let r = arr[(n - 1) as usize];\n    mem::forget(arr);\n    r\n  }\n}\n\n#[no_mangle]\npub extern fn fib_array_return_memory(n: i32) -> *mut c_int {\n  let mut arr = Vec::with_capacity((4 * n) as usize);\n  let pointer = arr.as_mut_ptr();\n  for i in 0..n {\n    if i < 2 {\n      arr.push(i);\n    } else {\n      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);\n    }\n  }\n  mem::forget(arr);\n  pointer\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: Command-line instructions for cloning the example repository and compiling the Rust program to WebAssembly using the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/app.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_readfile\ncargo build --target wasm32-wasip1\n# The output file will be target/wasm32-wasip1/debug/rust_readfile.wasm\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: Commands to compile Rust code into WebAssembly bytecode targeting wasm32-wasip1\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\ncd rust_bindgen_funcs\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Starting the WasmEdge Documentation Development Server\nDESCRIPTION: Command to start the local development server for the WasmEdge documentation, which will be accessible at http://localhost:3000/docs/.\nSOURCE: https://github.com/wasmedge/docs/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Runtime Tool Through C API\nDESCRIPTION: This snippet shows how to programmatically invoke the WasmEdge runtime tool using the C API. It passes command line arguments directly to the tool driver function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Hello World JavaScript Program\nDESCRIPTION: Command to execute a JavaScript hello world program using WasmEdge QuickJS runtime with directory permissions\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime\nHello WasmEdge Runtime\n```\n\n----------------------------------------\n\nTITLE: Host Registration Configuration in WasmEdge\nDESCRIPTION: Defines host registration constants for enabling WASI, process, and cryptography-related extensions in WasmEdge runtime\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  WASI                        = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n  WasmEdge_PROCESS            = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)\n  WasiNN                      = HostRegistration(C.WasmEdge_HostRegistration_WasiNN)\n  WasiCrypto_Common           = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Common)\n)\n```\n\n----------------------------------------\n\nTITLE: Downloading LLM model (GGUF format)\nDESCRIPTION: This command downloads the Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf model file in GGUF format from Hugging Face. This model will be used for LLM inference within WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LO https://huggingface.co/second-state/Meta-Llama-3.1-8B-Instruct-GGUF/resolve/main/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\n```\n\n----------------------------------------\n\nTITLE: Configuring Interpreter Mode in WasmEdge\nDESCRIPTION: Example showing how to force WasmEdge to use interpreter mode even for AOT-compiled WebAssembly modules. This can be useful for debugging or testing purposes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\nis_forceinterp := conf.IsForceInterpreter()\n// By default, the `is_forceinterp` will be `false`.\nconf.SetForceInterpreter(true)\nis_forceinterp = conf.IsForceInterpreter()\n/* The `is_forceinterp` will be `true`. */\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Implementation in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format implementation of a recursive Fibonacci number calculator function that takes an i32 parameter and returns an i32 result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_29\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n (export \"fib\" (func $fib))\n (func $fib (param $n i32) (result i32)\n  (if\n   (i32.lt_s (get_local $n)(i32.const 2))\n   (return (i32.const 1))\n  )\n  (return\n   (i32.add\n    (call $fib (i32.sub (get_local $n)(i32.const 2)))\n    (call $fib (i32.sub (get_local $n)(i32.const 1)))\n   )\n  )\n )\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring dependencies in Cargo.toml\nDESCRIPTION: This snippet declares the dependencies for the Rust project in `Cargo.toml`. It specifies versions and features for crates like `wasmedge_wasi_socket`, `querystring`, `parsed`, `anyhow`, `serde`, and a local crate `isomorphic-app`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n\n[dependencies]\nwasmedge_wasi_socket = \"0\"\nquerystring = \"1.1.0\"\nparsed = { version = \"0.3\", features = [\"http\"] }\nanyhow = \"1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nisomorphic-app = { path = \"../app\" }\n\n```\n\n----------------------------------------\n\nTITLE: Downloading Llama2 Inference Model\nDESCRIPTION: Command to download the Llama-2-7B-Chat quantized model file in GGUF format, which will be used for inference in the WebAssembly container.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf\n```\n\n----------------------------------------\n\nTITLE: Rust WebAssembly Bindgen Functions\nDESCRIPTION: Example Rust code demonstrating WebAssembly functions using wasmedge-bindgen with complex types and operations\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\nuse num_integer::lcm;\nuse sha3::{Digest, Sha3_256, Keccak256};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n  x: f32,\n  y: f32\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n  points: Vec<Point>,\n  valid: bool,\n  length: f32,\n  desc: String\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> String {\n  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();\n  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();\n  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();\n\n  let valid = if length == 0.0 { false } else { true };\n\n  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };\n\n  return serde_json::to_string(&line).unwrap();\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> String {\n  let r = String::from(\"hello \");\n  return r + s.as_str();\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> String {\n  (&s).chars().map(|c| {\n    match c {\n      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,\n      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,\n      _ => c\n    }\n  }).collect()\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> i32 {\n  return lcm(a, b);\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {\n  return Sha3_256::digest(&v).as_slice().to_vec();\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {\n  return Keccak256::digest(&s).as_slice().to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge and Go SDK\nDESCRIPTION: Commands to verify Go version, install WasmEdge runtime and WasmEdge Go SDK. Requires Go version 1.16+ and matching versions between WasmEdge and its SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/install.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n\n# Install WasmEdge\n$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}\n\n# Install WasmEdge-Go\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\n```\n\n----------------------------------------\n\nTITLE: Running WASM with WasmEdge - Bash\nDESCRIPTION: This command executes a WebAssembly module within the WasmEdge runtime environment.  The `--dir` option maps the host file system's current directory to the WebAssembly module's root directory, allowing the WebAssembly module to access files in the current directory. This is necessary to allow the wasm program to read and write to local files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n\"$ wasmedge --dir .:. target/wasm32-wasip1/release/wasi.wasm\"\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly HTTP Service with curl\nDESCRIPTION: Command to test the deployed WebAssembly HTTP service by sending a POST request to the service endpoint.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"name=WasmEdge\" -X POST http://127.0.0.1:1234\n```\n\n----------------------------------------\n\nTITLE: Building Sample Rust Application\nDESCRIPTION: Commands to clone the sample repository and build the Rust application targeting WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/cli.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasm-learning.git\ncd wasm-learning/rust/birds_v1\nrustup target add wasm32-wasip1\ncargo build --release --target=wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Table Types in Go\nDESCRIPTION: Shows how to create and manage table type contexts for WASM instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Legacy Plugin Module Creation (Pre-v0.12.0)\nDESCRIPTION: Example showing how to create plugin module instances using the old API style before v0.11.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\ncryptocommonmod := wasmedge.NewWasiCryptoCommonModule()\n\ncryptocommonmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge QuickJS with Custom Modules\nDESCRIPTION: This command runs the WasmEdge QuickJS runtime with the demo script that uses custom modules, showing the expected output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/modules.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js\nhello from \"my_mod_1.js\"\nhello from \"my_mod_2.js\"\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Application on Android Device\nDESCRIPTION: Shell commands to execute the compiled WasmEdge application on an Android device, including setting the library path and running the image classification application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/ndk.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ adb shell\nsirius:/ $ cd /data/local/tmp\nsirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH\nsirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\nINFO: Initialized TensorFlow Lite runtime.\n166 : 0.84705883\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the WasmEdge AOT Compiler Example\nDESCRIPTION: Shell commands to compile and run the C program that uses the WasmEdge AOT compiler. The output shows the compilation process with information about each phase.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_84\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n```\n\n----------------------------------------\n\nTITLE: Running wasm-bpf Examples\nDESCRIPTION: Command to run wasm-bpf examples using WasmEdge with the plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nWASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ ./build/tools/wasmedge/wasmedge execve.wasm\n```\n\n----------------------------------------\n\nTITLE: Configuring MacOS TLS Compilation Environment\nDESCRIPTION: Shell commands to set up WASI SDK path and Clang compiler for TLS library compilation on MacOS\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport WASI_SDK_PATH /path/to/wasi-sdk-22.0\nexport CC=\"${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot\"\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Configuration\nDESCRIPTION: Docker Compose YAML configuration defining three services: an Nginx client container, a Rust/WASM server container, and a MariaDB database container. Includes port mappings, environment variables, and volume configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n  client:\n    image: nginx:alpine\n    ports:\n      - 8090:80\n    volumes:\n      - ./client:/usr/share/nginx/html\n  server:\n    image: demo-microservice\n    platform: wasi/wasm\n    build:\n      context: .\n    ports:\n      - 8080:8080\n    environment:\n      DATABASE_URL: mysql://root:whalehello@db:3306/mysql\n      RUST_BACKTRACE: full\n    restart: unless-stopped\n    runtime: io.containerd.wasmedge.v1\n  db:\n    image: mariadb:10.9\n    environment:\n      MYSQL_ROOT_PASSWORD: whalehello\n```\n\n----------------------------------------\n\nTITLE: Creating a KinD Node Image with WasmEdge Support\nDESCRIPTION: Second stage of the Dockerfile that replaces runc with crun in a KinD node image and configures containerd. It copies the built crun binary and WasmEdge library, and modifies containerd configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_3\n\nLANGUAGE: Dockerfile\nCODE:\n```\n...\n\nFROM kindest/node:v1.23.0\n\nCOPY config.toml /etc/containerd/config.toml\nCOPY --from=builder /data/crun/crun /usr/local/sbin/runc\nCOPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so\n\nRUN echo \"Installing Packages ...\" \\\n    && bash -c 'cat <<< $(jq \"del(.hooks.createContainer)\" /etc/containerd/cri-base.json) > /etc/containerd/cri-base.json' \\\n    && ldconfig\n```\n\n----------------------------------------\n\nTITLE: Running inference after building WASM\nDESCRIPTION: This command runs the newly built `llama-chat.wasm` file with WasmEdge, using the same model and configuration as before.  The `--dir` option maps the current directory to the WASM filesystem, and `--nn-preload` tells WasmEdge to load the LLM model using the WASI-NN plugin. `-p` specifies the prompt template.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat\n```\n\n----------------------------------------\n\nTITLE: Clone Kubernetes Repository\nDESCRIPTION: This snippet clones the Kubernetes repository from GitHub and checks out a specific version. It is a necessary step to build and configure Kubernetes locally.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/kubernetes/kubernetes.git\n$ cd kubernetes\n$ git checkout v1.22.2\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Optimization Levels and Output Format Enumerations in C\nDESCRIPTION: C enumerations defining the available optimization levels (O0 to Oz) and output formats (Native and WebAssembly) for the WasmEdge AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_90\n\nLANGUAGE: c\nCODE:\n```\n/// AOT compiler optimization level enumeration.\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\n/// AOT compiler output binary format enumeration.\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom sections.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Joining Edge Node to SuperEdge Cluster\nDESCRIPTION: Command to join an edge node to the SuperEdge Kubernetes cluster using containerd runtime. It requires the master node's IP or domain, token, and certificate hash for authentication.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./edgeadm join <Master Public/Intranet IP Or Domain>:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path <edgeadm kube-* install package address path> --enable-edge=true --runtime=containerd\n```\n\n----------------------------------------\n\nTITLE: Building React 18 SSR Dependencies\nDESCRIPTION: Commands for installing dependencies and building the React 18 SSR application using npm.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Setting up TensorFlow Libraries on MacOS\nDESCRIPTION: Commands to move TensorFlow shared libraries to system locations and create necessary symbolic links on MacOS systems.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflow_cc.2.12.0.dylib /usr/local/lib\nmv libtensorflow_framework.2.12.0.dylib /usr/local/lib\nln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib\nln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib\nln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib\nln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with TensorFlow-Lite Backend\nDESCRIPTION: Commands to build WasmEdge from source with the TensorFlow-Lite backend for WASI-NN. This works on Linux x86_64, Linux aarch64, MacOS x86_64, or MacOS arm64 platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"TensorflowLite\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Getting Token from KubeEdge Master Node\nDESCRIPTION: Uses keadm to retrieve a token from the KubeEdge master node, necessary for joining edge nodes to the cluster. Requires access to the master node and a valid kubeconfig.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config\n```\n\n----------------------------------------\n\nTITLE: Getting Async Execution Return Value Length in C\nDESCRIPTION: Demonstrates how to retrieve the length of return values from an asynchronous execution\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN PyTorch Backend\nDESCRIPTION: CMake commands to build WasmEdge from source with the WASI-NN PyTorch backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"PyTorch\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Defining Output Formats for WasmEdge AOT Compiler in Go\nDESCRIPTION: Constants defining the available output formats for the WasmEdge AOT compiler. Developers can choose between native dynamic library format or WebAssembly with AOT compiled code in a custom section.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_75\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Building AI Inference WebAssembly Function\nDESCRIPTION: Commands to build the AI inference Rust program into WebAssembly bytecode and copy the build artifacts to the appropriate folder.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd api/functions/image-classification/\ncargo build --release --target wasm32-wasip1\ncp target/wasm32-wasip1/release/classify.wasm ../../\n```\n\n----------------------------------------\n\nTITLE: Initializing Android UI and Calling WasmEdge Functions in Kotlin\nDESCRIPTION: This Kotlin code sets up the Android UI and demonstrates how to call WasmEdge functions through a native library interface. It runs Fibonacci calculations using WebAssembly and updates the UI with the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/apk.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nclass MainActivity : AppCompatActivity() {\n  lateinit var lib: NativeLib\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n\n    val tv = findViewById<TextView>(R.id.tv_text)\n\n    lib = NativeLib(this)\n\n    Thread {\n      val lines = Vector<String>()\n      val idxArr = arrayOf(20, 25, 28, 30, 32)\n      for (idx: Int in idxArr) {\n        lines.add(\"running fib(${idx}) ...\")\n        runOnUiThread {\n          tv.text = lines.joinToString(\"\\n\")\n        }\n        val begin = System.currentTimeMillis()\n        val retVal = lib.wasmFibonacci(idx)\n        val end = System.currentTimeMillis()\n        lines.removeLast()\n        lines.add(\"fib(${idx}) -> ${retVal}, ${end - begin}ms\")\n        runOnUiThread {\n          tv.text = lines.joinToString(\"\\n\")\n        }\n      }\n    }.start()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading TensorFlow Dependencies for WasmEdge\nDESCRIPTION: Script to download TensorFlow shared libraries for WasmEdge with version and platform configuration\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nVERSION=TF-2.12.0-CC\nPLATFORM=manylinux2014_x86_64\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz\ntar -zxf WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz\nrm -f WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Downloading Simple LLM Inference WASM\nDESCRIPTION: Command to download a simplified version of the LLM inference WASM application for code understanding purposes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LO https://github.com/second-state/llamaedge/releases/latest/download/llama-simple.wasm\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for PostgreSQL in WasmEdge\nDESCRIPTION: Cargo.toml configuration for adding required dependencies and patches for PostgreSQL connectivity in WasmEdge environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/postgres_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\ntokio-postgres = { git = \"https://github.com/second-state/rust-postgres.git\" }\n\n[dependencies]\ntokio-postgres = \"0.7\"\ntokio = { version = \"1\", features = [\n    \"io-util\",\n    \"fs\",\n    \"net\",\n    \"time\",\n    \"rt\",\n    \"macros\",\n] }\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Script\nDESCRIPTION: Curl command to download and install WasmEdge version 0.9.1 using the installation script\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1\n```\n\n----------------------------------------\n\nTITLE: Running TensorFlow-Lite Model Analysis\nDESCRIPTION: Commands to examine the TensorFlow-Lite model file using show-tflite-tensor tool on Android.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/cli.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite\n```\n\n----------------------------------------\n\nTITLE: Implementing eBPF Program for Process Execution Tracking\nDESCRIPTION: A BPF program that tracks process execution events using the sched_process_exec tracepoint. It extracts process information, wraps it in an event struct, and sends it to userspace via ringbuf.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/bpf.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec* ctx) {\n    struct task_struct* task;\n    unsigned fname_off;\n    struct event* e;\n    pid_t pid;\n    u64 ts;\n\n    /* remember time exec() was executed for this PID */\n    pid = bpf_get_current_pid_tgid() >> 32;\n    ts = bpf_ktime_get_ns();\n    bpf_map_update_elem(&exec_start, &pid, &ts, BPF_ANY);\n\n    /* don't emit exec events when minimum duration is specified */\n    if (min_duration_ns)\n        return 0;\n\n    /* reserve sample from BPF ringbuf */\n    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);\n    if (!e)\n        return 0;\n\n    /* fill out the sample with data */\n    task = (struct task_struct*)bpf_get_current_task();\n\n    e->exit_event = false;\n    e->pid = pid;\n    e->ppid = BPF_CORE_READ(task, real_parent, tgid);\n    bpf_get_current_comm(&e->comm, sizeof(e->comm));\n\n    fname_off = ctx->__data_loc_filename & 0xFFFF;\n    bpf_probe_read_str(&e->filename, sizeof(e->filename),\n                       (void*)ctx + fname_off);\n\n    /* successfully submit it to user-space for post-processing */\n    bpf_ringbuf_submit(e, 0);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge via Shell Script\nDESCRIPTION: Command to download and install WasmEdge version 0.10.1 using curl. Requires git and wget as prerequisites.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.1\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Universal WASM Format in Bash\nDESCRIPTION: Demonstrates how to compile a WebAssembly file to the universal WASM format and then execute it using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/aot.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile app.wasm app_aot.wasm\nwasmedge app_aot.wasm\n```\n\n----------------------------------------\n\nTITLE: NPM Package Configuration for WasmEdge Module Bundling\nDESCRIPTION: Package.json file specifying dependencies, development dependencies, and build script for creating a bundled JavaScript module\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/npm.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dependencies\": {\n    \"mathjs\": \"^9.5.1\",\n    \"md5\": \"^2.3.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.16.5\",\n    \"@babel/preset-env\": \"^7.16.5\",\n    \"@babel/preset-react\": \"^7.16.5\",\n    \"@rollup/plugin-babel\": \"^5.3.0\",\n    \"@rollup/plugin-commonjs\": \"^21.0.1\",\n    \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n    \"@rollup/plugin-replace\": \"^3.0.0\",\n    \"rollup\": \"^2.60.1\",\n    \"rollup-plugin-babel\": \"^4.4.0\",\n    \"rollup-plugin-node-builtins\": \"^2.1.2\",\n    \"rollup-plugin-node-globals\": \"^1.4.0\",\n    \"rollup-plugin-async\": \"^1.2.0\"\n  },\n  \"scripts\": {\n    \"build\": \"rollup -c rollup.config.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AOT Compiler Optimization Levels and Output Formats\nDESCRIPTION: Constants for compiler optimization levels and output formats used in the WasmEdge AOT compiler. These options control execution speed, code size, and output file format.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n\nconst (\n  // Native dynamic library format.\n  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)\n  // WebAssembly with AOT compiled codes in custom section.\n  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating RuntimeClass for WebAssembly in Kubernetes\nDESCRIPTION: YAML definition and commands for creating a RuntimeClass named 'crun' in Kubernetes, which will be used to run WebAssembly workloads through the crun OCI runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: crun\nhandler: crun\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl apply -f runtime.yaml\n```\n\n----------------------------------------\n\nTITLE: Adding UDFs to libSQL Instance\nDESCRIPTION: SQL commands to initialize the WASM function table and read the created UDF SQL files into libSQL.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/libsql.md#2025-04-21_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n.init_wasm_func_table\n.read create_encrypt_udf.sql\n.read create_decrypt_udf.sql\n```\n\n----------------------------------------\n\nTITLE: C program to get WasmEdge version\nDESCRIPTION: This C program includes the WasmEdge header file and prints the WasmEdge version to the console using the `WasmEdge_VersionGet()` function. It demonstrates how to link against the `libwasmedge_c` library. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-Go with Multiple Extensions\nDESCRIPTION: Command to build WasmEdge-Go with multiple extensions (Image and TensorFlow).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image,tensorflow\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Edge Node\nDESCRIPTION: This command uses a simple installation script from the WasmEdge GitHub repository to install the WasmEdge runtime on the edge node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Building WASM from Rust for Nginx Module\nDESCRIPTION: Command to compile Rust code into a WebAssembly file for use with the wasm-nginx-module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/wasm-nginx.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --target=wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Running the Demo Application\nDESCRIPTION: Commands to clone the example repository, build and run the demonstration application using WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/install.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Get the source code of this example\n$ git clone https://github.com/second-state/WasmEdge-go-examples.git\n$ cd WasmEdge-go-examples//wasmedge-bindgen/go_BindgenFuncs/\n\n# build the project\ngo build\n\n# run the example\n./bindgen_funcs rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Running the Android Build Script\nDESCRIPTION: Command to execute the build script for Android in the WasmEdge source code. This script automates the build process for Android platforms and places the build artifacts in the build folder.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/build.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./utils/android/standalone/build_for_android.sh\n```\n\n----------------------------------------\n\nTITLE: Managing Host Registrations in WasmEdge Configuration\nDESCRIPTION: Demonstrates how to check and add host module registrations to a WasmEdge configuration context. This example shows enabling WASI support which makes system interfaces available to WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Running Build and Start Commands in Bash\nDESCRIPTION: This Bash command sequence allows users to build the client-side app, transpile the server code, and start the server on port 8002, providing access to the server-side rendered application in the browser.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run dev:build-server\nnpm run dev:start-server\n```\n\n----------------------------------------\n\nTITLE: Implementing Module Creation Functions for WasmEdge Plug-in\nDESCRIPTION: C++ code defining the module creation function for a WasmEdge plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"testplugin.h\"\n\nnamespace WasmEdge {\nnamespace Host {\nnamespace {\n\nRuntime::Instance::ModuleInstance *\ncreate(const Plugin::PluginModule::ModuleDescriptor *) noexcept {\n  // There can be several modules in a plug-in. For that, developers should\n  // implement several `create` functions for each module.\n  return new WasmEdgePluginTestModule;\n}\n\n} // namespace\n} // namespace Host\n} // namespace WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Cloning the LlamaEdge repository\nDESCRIPTION: This command clones the LlamaEdge GitHub repository to the local machine. This is necessary to access the Rust source code for the chat application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/LlamaEdge/LlamaEdge.git\ncd chat\n```\n\n----------------------------------------\n\nTITLE: Running HTTP Fetch Example in WasmEdge\nDESCRIPTION: Command to execute the HTTP fetch example JavaScript program using WasmEdge QuickJS runtime. This demonstrates how to run JavaScript code that makes network requests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_fetch.js\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for TensorFlow Inference Application\nDESCRIPTION: Configuration for a Docker container running a TensorFlow inference application in WebAssembly using WasmEdge. This setup allows AI image classification to be performed within the WebAssembly sandbox.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_9\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-tf:0.10.1\nADD wasmedge_hyper_server_tflite.wasm /\nCMD [\"wasmedge-tensorflow-lite\", \"--dir\", \".:/\", \"/wasmedge_hyper_server_tflite.wasm\"]\n```\n\n----------------------------------------\n\nTITLE: Verifying NVIDIA Driver and Container Toolkit Installation\nDESCRIPTION: Commands to check the NVIDIA driver and Container Toolkit installation on the system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# check your driver and device\n> nvidia-smi -L\n\n# Check your toolkit\n> nvidia-ctk --version\n```\n\n----------------------------------------\n\nTITLE: Setting Module Instance Data with Finalizer in WasmEdge C\nDESCRIPTION: Example showing how to create a module instance with custom host data and a finalizer function. Demonstrates using Point struct data and proper memory management through finalizer callbacks.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Struct definition. */\ntypedef struct Point {\n  int X;\n  int Y;\n} Point;\n\n/* Host function body definition. */\nWasmEdge_Result Print(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  Point *P = (Point *)In;\n  printf(\"Point: (%d, %d)\\n\", P->X, P->Y);\n  return WasmEdge_Result_Success;\n}\n\n/* Finalizer definition. */\nvoid PointFinalizer(void *Data) {\n  if (Data) {\n    free((Point *)Data);\n  }\n}\n\n/* Create a module instance with host data and its finalizer. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nPoint *Data = (Point *)malloc(sizeof(Point));\nData->X = 5;\nData->Y = -5;\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);\n/*\n * When the `HostModCxt` being destroyed, the finalizer will be invoked and the\n * `Data` will be its argument.\n */\nWasmEdge_StringDelete(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Adding Rand and Getrandom Dependencies - Cargo.toml\nDESCRIPTION: This snippet shows how to add the `rand` and `getrandom` crates as dependencies in your `Cargo.toml` file.  These crates provide functionality for generating random numbers in Rust, and when compiled for the `wasm32-wasip1` target, they will use WASI calls to access the host operating system's entropy source. This is essential for creating secure and unpredictable random values within the WebAssembly environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\"[dependencies]\\nrand = \\\"0.7.3\\\"\\ngetrandom = \\\"0.1.14\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Go Example\nDESCRIPTION: Commands to clone the example repository, build and run the bindgen functions demo using a pre-compiled WASM file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/install.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Get the source code of this example\n$ git clone https://github.com/second-state/WasmEdge-go-examples.git\n$ cd WasmEdge-go-examples//wasmedge-bindgen/go_BindgenFuncs/\n\n# build the project\ngo build\n\n# run the example\n./bindgen_funcs rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for Node.js Server with WasmEdge QuickJS\nDESCRIPTION: Dockerfile configuration to run a lightweight Node.js server with WasmEdge QuickJS. It sets up a container with the QuickJS runtime, JavaScript file, and required modules for running Node.js applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_6\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-runtime:0.10.1\nADD wasmedge_quickjs.wasm /\nADD http_echo.js /\nADD modules /modules\nCMD [\"wasmedge\", \"--dir\", \".:/\", \"/wasmedge_quickjs.wasm\", \"http_echo.js\"]\n```\n\n----------------------------------------\n\nTITLE: Signing Git Commits with DCO\nDESCRIPTION: Examples of how to sign off on commits to certify authorship according to the Developer Certificate of Origin (DCO) requirements. Shows both manual sign-off format and the git command line option.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/contribute.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -s -m 'This is my commit message'\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit commit --amend -s\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Memory Types in Go\nDESCRIPTION: Demonstrates creation and management of memory type contexts for WASM instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Global Instance Retrieval in v0.10.0\nDESCRIPTION: Updated example showing how to retrieve a Global instance using Module in WasmEdge-Go v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm`, and exports the \"global_i32\".\nmod := vm.GetActiveModule()\n\n// The example of retrieving the global instance.\nglobinst := mod.FindGlobal(\"global_i32\")\n```\n\n----------------------------------------\n\nTITLE: Access HTTP service\nDESCRIPTION: This snippet uses curl to send a POST request to the WebAssembly HTTP service running in Kubernetes. It verifies that the service is accessible and functioning correctly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"name=WasmEdge\" -X POST http://127.0.0.1:1234\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Verifies the installed Go version, which should be 1.16 or higher for WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the WasmEdge Host Function Example\nDESCRIPTION: Bash commands to compile the C program with the WasmEdge library and run the resulting executable. The output shows the result of adding 1234 and 5678, which is 6912.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_81\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge from Source\nDESCRIPTION: Commands to build WasmEdge from source using CMake, either within a Docker container or directly on the host system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# After pulling our wasmedge docker image\ndocker run -it --rm \\\n    -v <path/to/your/wasmedge/source/folder>:/root/wasmedge \\\n    wasmedge/wasmedge:latest\n# In docker\ncd /root/wasmedge\n# If you don't use docker then you need to run only the following commands in the cloned repository root\nmkdir -p build && cd build\ncmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. && make -j\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge Plugin with GCC\nDESCRIPTION: Compiles a WasmEdge plugin source file into a shared library using gcc compiler. Uses C11 standard and defines WASMEDGE_PLUGIN macro. Creates libwasmedgePluginTest.so from testplugin.c source file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngcc -std=c11 -DWASMEDGE_PLUGIN -shared -o libwasmedgePluginTest.so testplugin.c\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Container in Kubernetes 1.18.9\nDESCRIPTION: This command runs a WebAssembly application as a container in Kubernetes 1.18.9. It uses the wasmedge/example-wasi:latest image and sets necessary annotations and overrides for WasmEdge compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest  --overrides='{\"kind\":\"Pod\",\"metadata\":{\"annotations\":{\"module.wasm.image/variant\":\"compat-smart\"}} , \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for WasmEdge Plugin Tests\nDESCRIPTION: CMake configuration to set up test compilation and execution. Links the test executable with Google Test and the plugin library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/test_plugin.md#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(your_plugin_test your_plugin_test.cpp)\ntarget_link_libraries(your_plugin_test gtest_main your_plugin)\nadd_test(NAME your_plugin_test COMMAND your_plugin_test)\n```\n\n----------------------------------------\n\nTITLE: Compiling C program with WasmEdge library\nDESCRIPTION: This command compiles the C file `test.c` using `gcc` and links it with the `wasmedge_c` library. This creates an executable that uses the WasmEdge C API. Requires `gcc` and `libwasmedge_c` to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngcc test.c -lwasmedge_c\n```\n\n----------------------------------------\n\nTITLE: Installing Emscripten Toolchain for WebAssembly Compilation\nDESCRIPTION: Commands to clone, install, and activate the latest version of Emscripten toolchain for compiling C/C++ code to WebAssembly. This setup is required before compiling the SIMD application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/simd.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth 1 https://github.com/emscripten-core/emsdk.git\ncd emsdk\n./emsdk install latest\n./emsdk activate latest\nsource ./emsdk_env.sh\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the WasmEdge AOT Compiler Example\nDESCRIPTION: Bash commands to compile and run the WasmEdge AOT compiler program. The output shows the compilation process of transforming a WebAssembly file into an AOT-compiled format.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_89\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with GGML Backend on Windows (CUDA Disabled)\nDESCRIPTION: PowerShell commands to build WasmEdge with the GGML backend on Windows, with CUDA support disabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_13\n\nLANGUAGE: console\nCODE:\n```\n# CUDA DISABLE:\n& \"C:\\Program files\\CMake\\bin\\cmake.exe\" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_USE_LLVM=OFF .\n& \"<the ninja-build folder>\\ninja.exe\" -C build\n```\n\n----------------------------------------\n\nTITLE: Node.js Build Environment Setup\nDESCRIPTION: Dockerfile section for setting up Node.js build environment with required utilities\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_4\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase\nWORKDIR /src\nRUN <<EOT bash\n    set -ex\n    apt-get update\n    apt-get install -y \\\n        wget unzip\nEOT\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-Crypto Plugin Support\nDESCRIPTION: Commands to compile WasmEdge from source with WASI-Crypto plugin support enabled. Includes the necessary CMake options and installation steps.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.\n# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On\ncmake --build build\n# For the WASI-Crypto plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Registrations in WasmEdge\nDESCRIPTION: Example showing how to enable WASI support in a WasmEdge configuration object. This configuration is effective only in VM contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.WASI)\nconf.AddConfig(wasmedge.WASI)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Checking wasmedge Version\nDESCRIPTION: Command to display the version of the installed wasmedge CLI tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge -v\nwasmedge version {{ wasmedge_version }}\n```\n\n----------------------------------------\n\nTITLE: Creating Containerd Configuration Patch for WasmEdge Support\nDESCRIPTION: Command to create a diff file for patching containerd configuration, enabling WebAssembly support via crun and WasmEdge. The patch sets crun as the default runtime and configures WebAssembly-related annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncat > config.toml.diff << EOF\n--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800\n+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800\n@@ -24,17 +24,23 @@\n   max_concurrent_downloads = 10\n\n   [plugins.cri.containerd]\n-        default_runtime_name = \"runc\"\n-    [plugins.cri.containerd.runtimes.runc]\n+        default_runtime_name = \"crun\"\n+    [plugins.cri.containerd.runtimes.crun]\n       runtime_type = \"io.containerd.runc.v2\"\n-      pod_annotations = []\n+      pod_annotations = [\"*.wasm.*\", \"wasm.*\", \"module.wasm.image/*\", \"*.module.wasm.image\", \"module.wasm.image/variant.*\"]\n       container_annotations = []\n       privileged_without_host_devices = false\n-      [plugins.cri.containerd.runtimes.runc.options]\n-        BinaryName = \"runc\"\n+      [plugins.cri.containerd.runtimes.crun.options]\n+        BinaryName = \"crun\"\n   # cni\n   [plugins.cri.cni]\n     bin_dir = \"/opt/cni/bin\"\n     conf_dir = \"/etc/cni/net.d\"\n     conf_template = \"\"\n\n+  [plugins.\"io.containerd.runtime.v1.linux\"]\n+    no_shim = false\n+    runtime = \"crun\"\n+    runtime_root = \"\"\n+    shim = \"containerd-shim\"\n+    shim_debug = false\nEOF\n```\n\n----------------------------------------\n\nTITLE: Building and Running Manual WasmEdge Execution\nDESCRIPTION: Bash commands to build and run the Go application that manually instantiates and executes the WebAssembly module to calculate the 25th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\n$ go build\n$ ./wasmedge_test\nGet fibonacci[25]: 121393\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Plugin Tests using CMake and CTest\nDESCRIPTION: This bash script demonstrates the process of building and running tests for a WasmEdge plugin using CMake and CTest. It creates a build directory, configures the project, builds it, and runs the tests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/test_plugin.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd buildtest_plugin.md\ncmake ..\nmake\nctest\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository in Bash\nDESCRIPTION: Commands to clone the WasmEdge repository from GitHub and navigate into the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/windows.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly from Rust\nDESCRIPTION: Commands for building a Rust program into WebAssembly bytecode and copying the resulting .wasm file to the appropriate directory for AWS Lambda deployment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd api/functions/image-grayscale/\ncargo build --release --target wasm32-wasip1\n```\n\nLANGUAGE: bash\nCODE:\n```\ncp target/wasm32-wasip1/release/grayscale.wasm ../../\n```\n\n----------------------------------------\n\nTITLE: Managing Context Lifecycles in Go\nDESCRIPTION: Go code snippet showing how to create and release contexts in WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\nconf := wasmedge.NewConfigure()\n// Release the `conf` immediately.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Export Type Context\nDESCRIPTION: Demonstrates working with export type contexts and retrieving export information from AST modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Installing YoMo CLI and Dependencies - Bash\nDESCRIPTION: Commands for installing YoMo CLI, WasmEdge runtime, and repository setup\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go install github.com/yomorun/cli/yomo@latest\n$ yomo version\nYoMo CLI version: v0.1.3\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git\n```\n\n----------------------------------------\n\nTITLE: Building and Configuring crun with WasmEdge Support\nDESCRIPTION: Series of commands to clone, configure, build, and install crun with WasmEdge support. This is necessary for running WASM applications on non-Fedora Linux distributions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/podman.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n# replace crun (be careful, you may want to do a backup first)\nmv crun $(which crun)\n```\n\n----------------------------------------\n\nTITLE: Adding Workspace Member in Cargo.toml\nDESCRIPTION: Configuration to add the new server-wasmedge crate to the workspace members in the root Cargo.toml file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n\"examples/isomorphic/server-wasmedge\"\n```\n\n----------------------------------------\n\nTITLE: Defining Host Registration Constants for WasmEdge\nDESCRIPTION: Constants for host registrations that can be enabled in the VM context. Currently only includes WASI support, with the mention that more options may be added in the future.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n)\n```\n\n----------------------------------------\n\nTITLE: Running a JavaScript-based server with WasmEdge\nDESCRIPTION: Command to run a JavaScript-based server using WasmEdge and the QuickJS runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm server.js\nlisten 8080 ...\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration - Pre v0.10.0\nDESCRIPTION: Shows host module registration using ImportObject in WasmEdge-Go v0.9.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nimpobj := wasmedge.NewImportObject(\"module\")\nerr := executor.RegisterImport(store, impobj)\nif err != nil {\n  fmt.Println(\"Import object registration FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge from Source using CMake and Ninja\nDESCRIPTION: Commands to configure and build WasmEdge using CMake and Ninja, with tests enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/macos.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Runtime\nDESCRIPTION: Command to install WasmEdge runtime on Unix-like systems using the official installation script.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly HTTP Service in Kubernetes\nDESCRIPTION: Command to deploy and run a WebAssembly-based HTTP service as a container in a Kubernetes pod using the wasmedge/example-wasi-http image with appropriate annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true}}'\n```\n\n----------------------------------------\n\nTITLE: Registering Host Module in WasmEdge 0.9.1 (C)\nDESCRIPTION: Example of creating and registering a host module using WasmEdge_ImportObjectContext in WasmEdge version 0.9.1.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n/* Create the import object with the export module name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Add the host functions, tables, memories, and globals into the import object.\n */\n/* The import module context has already contained the export module name. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpObj);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Import object registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Executing compiled WasmEdge C program\nDESCRIPTION: This command executes the compiled program `a.out`. The program uses the WasmEdge C API to print the WasmEdge version. Requires the successful compilation of the `test.c` file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ./a.out\nWasmEdge version: 0.10.1\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Definition of the WasmEdge_Limit struct used to specify minimum and maximum values for WebAssembly resources. The struct contains fields for indicating if a maximum value exists, the minimum value, and an optional maximum value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Retrieving WasmEdge Version Information\nDESCRIPTION: C code snippet for getting WasmEdge version details using API functions\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge\\/wasmedge.h>\\nprintf(\"WasmEdge version: %s\\\\n\", WasmEdge_VersionGet());\\nprintf(\"WasmEdge version major: %u\\\\n\", WasmEdge_VersionGetMajor());\\nprintf(\"WasmEdge version minor: %u\\\\n\", WasmEdge_VersionGetMinor());\\nprintf(\"WasmEdge version patch: %u\\\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Adding npm Scripts for Development in package.json\nDESCRIPTION: This JSON snippet adds scripts to the package.json file to facilitate building and serving the server-side rendered application. It defines scripts for building the server and starting the WasmEdge server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"dev:build-server\": \"rollup -c rollup.config.js\",\n    \"dev:start-server\": \"wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js\",\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling WebAssembly for Performance\nDESCRIPTION: Commands to AOT (Ahead-Of-Time) compile WebAssembly modules for improved runtime performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile hello.wasm hello.wasm\n\n$ wasmedge hello.wasm\nHello TinyGo from WasmEdge!\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests\nDESCRIPTION: Commands to run the test suite to verify the correctness of the WasmEdge build, ensuring the library path is properly set.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/macos.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd build\nDYLD_LIBRARY_PATH=$(pwd)/lib/api ctest\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Proposal Enum Definition in WasmEdge C API\nDESCRIPTION: Lists all the WebAssembly proposal enums that can be enabled or disabled in WasmEdge configuration, including various extensions like SIMD, reference types, and multi-memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  WasmEdge_Proposal_MultiValue,\n  WasmEdge_Proposal_BulkMemoryOperations,\n  WasmEdge_Proposal_ReferenceTypes,\n  WasmEdge_Proposal_SIMD,\n  WasmEdge_Proposal_TailCall,\n  WasmEdge_Proposal_MultiMemories,\n  WasmEdge_Proposal_Annotations,\n  WasmEdge_Proposal_Memory64,\n  WasmEdge_Proposal_ExceptionHandling,\n  WasmEdge_Proposal_Threads,\n  WasmEdge_Proposal_FunctionReferences\n};\n```\n\n----------------------------------------\n\nTITLE: Building Rust Program into WebAssembly for AWS Lambda\nDESCRIPTION: Command-line instructions for building a Rust program into WebAssembly bytecode using cargo. The build targets wasm32-wasip1 platform and outputs a release version of the program. The resulting WebAssembly file needs to be copied to the API folder for deployment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd api/functions/image-classification/\ncargo build --release --target wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Creating Rust SDK for WasmEdge Plugin\nDESCRIPTION: Example of creating a Rust library interface for a WasmEdge plugin\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/best_practice.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// lib.rs\nextern crate wasmedge_image;\n\nuse wasmedge_image::Image;\n\npub fn load_image(path: &str) -> Result<Image, wasmedge_image::Error> {\nImage::open(path)\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Module Definition\nDESCRIPTION: WebAssembly text format (WAT) definition of a module that imports and uses the host addition function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_56\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN Piper Backend\nDESCRIPTION: Commands to build WasmEdge from source with the WASI-NN Piper backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"Piper\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Processing Command Line Arguments in Rust\nDESCRIPTION: Extracts the OpenVINO model XML, weights file, and input image file names from command line arguments, facilitating their use in further Rust code for model operations. Essential for file management in inference tasks.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet args: Vec<String> = env::args().collect();\nlet model_xml_name: &str = &args[1]; // File name for the model xml\nlet model_bin_name: &str = &args[2]; // File name for the weights\nlet image_name: &str = &args[3]; // File name for the input image\n```\n\n----------------------------------------\n\nTITLE: Creating New Go Project for WasmEdge\nDESCRIPTION: Initial setup commands for creating a new Go project to work with WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: WASM Loading Pre-0.14.0 Example\nDESCRIPTION: Example demonstrating WASM binary loading using raw buffer before version 0.14.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nuint8_t WASM[] = {/* WASM header */\n                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                  /* Type section */\n                  0x01, 0x07, 0x01,\n                  /* function type {i32, i32} -> {i32} */\n                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                  /* Import section */\n                  0x02, 0x13, 0x01,\n                  /* module name: \"extern\" */\n                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                  /* extern name: \"func-add\" */\n                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                  /* import desc: func 0 */\n                  0x00, 0x00,\n                  /* Function section */\n                  0x03, 0x02, 0x01, 0x00,\n                  /* Export section */\n                  0x07, 0x0A, 0x01,\n                  /* export name: \"addTwo\" */\n                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                  /* export desc: func 0 */\n                  0x00, 0x01,\n                  /* Code section */\n                  0x0A, 0x0A, 0x01,\n                  /* code body */\n                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, WASM, sizeof(WASM));\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\n```\n\n----------------------------------------\n\nTITLE: Cloning Mediapipe Object Detection Demo Project\nDESCRIPTION: Commands to clone the demo project repository for Mediapipe object detection and navigate to the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/juntao/demo-object-detection\ncd demo-object-detection/\n```\n\n----------------------------------------\n\nTITLE: Setting up WasmEdge QuickJS for Node.js Applications\nDESCRIPTION: This snippet shows how to set up WasmEdge QuickJS to run Node.js applications. It demonstrates cloning the repository, downloading the runtime, and executing a Node.js application using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/nodejs.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Clone the wasmedge-quickjs\ngit clone https://github.com/second-state/wasmedge-quickjs\n# Use the wasmedge-quickjs directory as the working directory for modules access\ncd wasmedge-quickjs\n# Download a released WasmEdge QuickJS runtime\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\n# Copy the nodejs project to the current working directory and run the nodejs app\ncp -r /path/to/my_node_app .\nwasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js\n```\n\n----------------------------------------\n\nTITLE: Running Demo with AoT Compilation\nDESCRIPTION: Commands to achieve better performance by using Ahead-of-Time (AoT) compilation mode with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/install.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Use the AoT mode\nwasmedgec rust_bindgen_funcs_lib.wasm rust_bindgen_funcs_lib.wasm\n\n# Run the demo\n./bindgen_funcs rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Monitoring and Viewing WebAssembly Container Output with CRI-O\nDESCRIPTION: Commands to list, start, monitor status, and view logs of the WebAssembly container using CRI-O tools. This shows the container's lifecycle and output from the WebAssembly program.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# List the container; the state should be `Created`\n$ sudo crictl ps -a\nCONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID\n1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc\n\n# Start the container\n$ sudo crictl start $CONTAINER_ID\n\n# recheck the container status.\n# If the container is not finishing its job, you will see the Running state\n# Because this example is very tiny. You may see Exited at this moment.\n$ sudo crictl ps -a\nCONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID\n1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc\n\n# When the container is finished. You can see the state becomes Exited.\n$ sudo crictl ps -a\nCONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID\n1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc\n\n# Check the container's logs. It should show outputs from the WebAssembly programs\n$ sudo crictl logs $CONTAINER_ID\n\nTest 1: Print Random Number\nRandom number: 960251471\n\nTest 2: Print Random Bytes\nRandom bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]\n\nTest 3: Call an echo function\nPrinted from wasi: This is from a main function\nThis is from a main function\n\nTest 4: Print Environment Variables\nThe env vars are as follows.\nPATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nTERM: xterm\nHOSTNAME: crictl_host\nPATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nThe args are as follows.\n/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm\n50000000\n\nTest 5: Create a file `/tmp.txt` with content `This is in a file`\n\nTest 6: Read the content from the previous file\nFile content is This is in a file\n\nTest 7: Delete the previous file\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Function in Go for WebAssembly\nDESCRIPTION: A Go program that implements a function to compute Fibonacci numbers, which can be called from WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nfunc main(){\n}\n\n//export fibArray\nfunc fibArray(n int32) int32{\n  arr := make([]int32, n)\n  for i := int32(0); i < n; i++ {\n    switch {\n    case i < 2:\n      arr[i] = i\n    default:\n      arr[i] = arr[i-1] + arr[i-2]\n    }\n  }\n  return arr[n-1]\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Module Instance in Go WasmEdge Executor\nDESCRIPTION: Shows how to register an existing Module instance into the store with an exported module name. This is typically used when registering host function modules for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_50\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod := wasmedge.NewModule(\"mod\")\n\nres := executor.RegisterImport(store, mod)\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Redis Example in WasmEdge\nDESCRIPTION: Commands to clone, compile and run the Redis connector example with WasmEdge. Includes setting up the Redis URL environment variable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/redis_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/redis\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Execute Redis command against a Redis instance at redis://localhost/\nwasmedge --env \"REDIS_URL=redis://localhost/\" target/wasm32-wasip1/release/wasmedge-redis-client-examples.wasm\n```\n\n----------------------------------------\n\nTITLE: Accessing the HTTP Service using Curl\nDESCRIPTION: This snippet demonstrates how to access the running WebAssembly-based HTTP service using the curl command. It sends a POST request to the service running on the local network.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"name=WasmEdge\" -X POST http://127.0.0.1:1234\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly\nDESCRIPTION: These bash commands clone the example repository and compile the Rust code to WebAssembly using the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/function.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_bindgen_funcs\ncargo build --release --target wasm32-wasip1\n# The output WASM will be target/wasm32-wasip1/release/rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository\nDESCRIPTION: Command to clone the forked WasmEdge documentation repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone <forked-repository-url>\n```\n\n----------------------------------------\n\nTITLE: Compiling RustPython to WebAssembly\nDESCRIPTION: Clones the RustPython repository and compiles it to WebAssembly with the standard library included.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/python/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/RustPython/RustPython.git\ncd RustPython\ncargo build --release --target wasm32-wasip1 --features=\"freeze-stdlib\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Hosts File for OpenYurt Cluster\nDESCRIPTION: Example configuration for the /etc/hosts file that maps IP addresses to hostnames for both master and node in the OpenYurt cluster. This enables hostname resolution between cluster nodes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n192.168.3.169  oy-master\n120.55.126.18  oy-master\n92.168.3.170   oy-node\n121.43.113.152 oy-node\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance from Plugin (Pre-0.12.0)\nDESCRIPTION: Example of creating a module instance from a plugin before version 0.12.0, using a specific function for WASI crypto common module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\n\nWasmEdge_ModuleInstance *WasiCryptoCommonCxt =\n    WasmEdge_ModuleInstanceCreateWasiCryptoCommon();\n\nWasmEdge_ModuleInstanceDelete(WasiCryptoCommonCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Runtime on Linux/MacOS\nDESCRIPTION: Installs the latest version of WasmEdge Runtime using a shell script. Requires git and curl to be installed on the system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly with wasmedge\nDESCRIPTION: Command to execute a WebAssembly file using the wasmedge CLI tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge target/wasm32-wasip1/release/hello.wasm\nHello WasmEdge!\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge via Bash Script\nDESCRIPTION: Command-line script to download and install WasmEdge runtime version 0.13.5 with git and wget prerequisites\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https:\\/\\/raw.githubusercontent.com\\/WasmEdge\\/WasmEdge\\/master\\/utils\\/install.sh | bash -s -- -v 0.13.5\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C Programs\nDESCRIPTION: Shell commands for compiling the C programs with WasmEdge library and executing the resulting binary to calculate Fibonacci numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with GGML Backend on Ubuntu/Debian (OpenBLAS)\nDESCRIPTION: Commands to install dependencies and build WasmEdge with the GGML backend using OpenBLAS on Ubuntu/Debian systems.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\n# You may need to install dependencies\napt update\napt install -y software-properties-common lsb-release \\\n  cmake unzip pkg-config\n# You must install OpenBLAS\napt install libopenblas-dev\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=ON \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Running an HTTP Server with WasmEdge and Podman\nDESCRIPTION: Shows how to run a Rust-based HTTP server in a WasmEdge container using Podman, mapping container port to host port.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npodman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-server:latest\n```\n\n----------------------------------------\n\nTITLE: Installing GGML Plugin for WasmEdge in Bash\nDESCRIPTION: Commands to download and install the GGML plugin for WasmEdge, which enables neural network inference capabilities. Also includes a command to verify plugin dependencies.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml\n\n# Make sure all your plugin dependencies is good\n> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so\n```\n\n----------------------------------------\n\nTITLE: Finding WasmEdge Plugin by Name\nDESCRIPTION: Shows how to retrieve a plugin context by its name, using WASI crypto plugin as an example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Page Size in WasmEdge with Go\nDESCRIPTION: This code snippet demonstrates how to set the maximum memory page size for WasmEdge instances using the `wasmedge.Configure` object in Go. It shows how to get the default page size and then set a new maximum page size. The default page size is 65536. The page size is limited to 1234 in this example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\n```go\n   conf := wasmedge.NewConfigure()\n\n   pagesize := conf.GetMaxMemoryPage()\n   // By default, the maximum memory page size in each memory instances is 65536.\n   conf.SetMaxMemoryPage(1234)\n   pagesize := conf.GetMaxMemoryPage()\n   // `pagesize` will be 1234.\n\n   conf.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Building WASM from Go for Nginx Module\nDESCRIPTION: Command to compile Go code into a WebAssembly file using TinyGo for use with the wasm-nginx-module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/wasm-nginx.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntinygo build -o ./fault-injection/main.go.wasm -scheduler=none -target=wasi ./fault-injection/main.go\n```\n\n----------------------------------------\n\nTITLE: Addition Host Function Implementation\nDESCRIPTION: Example implementation of a host function that adds two i32 values in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n    int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n    int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n    Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n    return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Go Project for Host Function Testing\nDESCRIPTION: Command to set up a new Go project for testing WasmEdge host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_63\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Building Crun with WasmEdge Support in Bash\nDESCRIPTION: Commands to install dependencies, clone the Crun repository, and build Crun with WasmEdge support. Crun is a container runtime that will be used to run WebAssembly containers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake\n\n> git clone https://github.com/containers/crun\n> cd crun\n> ./autogen.sh\n> ./configure --with-wasmedge\n> make\n\n# Check your crun\n> ./crun --version\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling WASM File with WasmEdge\nDESCRIPTION: This Bash snippet performs AOT compilation of a WASM file using WasmEdge to enhance performance. It requires the WasmEdge AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile wasmedge-wasinn-example-tflite-bird-image.wasm out.wasm\nwasmedge --dir .:. out.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Building WasmEdge with WASI-NN ChatTTS Backend\nDESCRIPTION: Commands to install dependencies and build WasmEdge from source with the WASI-NN ChatTTS backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt upgrade\nsudo apt install python3-dev\npip install chattts==0.1.1\n\ncd <path/to/your/wasmedge/source/folder>\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"chatTTS\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WasmEdge-Image Plugin on MacOS\nDESCRIPTION: Command to install required dependencies (JPEG and PNG libraries) for building WasmEdge with the Image plugin on MacOS platforms using Homebrew.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/image.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install jpeg-turbo libpng\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Instances from VM Context (Post-0.12.0)\nDESCRIPTION: Example of retrieving module instances from a VM context after version 0.12.0, using new APIs for faster retrieval of registered modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\nWasmEdge_ModuleInstance *WASIModInst =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_String ModName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_crypto_common\");\nconst WasmEdge_ModuleInstance *WASICryptoKxModInst =\n    WasmEdge_VMGetImportModuleContext(VMCxt, ModName);\nWasmEdge_StringDelete(ModName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Programming Language\nDESCRIPTION: Shell command to install Rust programming language using official rustup installation script. Compatible with Unix-like platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Installing Podman on Ubuntu for Other Linux Distributions\nDESCRIPTION: Commands to install Podman on Ubuntu-based systems. This is part of the setup process for running WASM applications on Linux distributions other than Fedora.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/podman.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get -y update\nsudo apt-get -y install podman\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge and Go SDK\nDESCRIPTION: Commands to check Go version and install WasmEdge runtime and Go SDK. Requires Go version 1.16+ and ensures matching versions between WasmEdge and its SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/install.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n\n# Install WasmEdge\n$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}\n\n# Install WasmEdge-Go\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\n```\n\n----------------------------------------\n\nTITLE: Mounting Modules Directory with WasmEdge CLI\nDESCRIPTION: Command to run JavaScript code with WasmEdge QuickJS runtime while mounting a modules directory to make built-in modules available to the JavaScript program.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime\n```\n\n----------------------------------------\n\nTITLE: Running Mediapipe Object Detection Inference\nDESCRIPTION: Command to run the compiled Wasm application for object detection on an input image using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. demo-object-detection.wasm example.jpg output.jpg\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with TensorFlow Plugin\nDESCRIPTION: Commands to build WasmEdge from source with TensorFlow plugin support enabled via CMAKE options.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On\ncmake --build build\n# For the WasmEdge-Tensorflow plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function with User-Defined Error Code (WasmEdge 0.11.0+)\nDESCRIPTION: Example of a host function that returns a user-defined error code in WasmEdge 0.11.0 and later. This allows specifying custom error codes up to 24-bits in size.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result FaildFunc(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM with the error code. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Runtime\nDESCRIPTION: Command to install WasmEdge using the official installation script. WasmEdge is the WebAssembly runtime that will execute WebAssembly modules in containers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Deleting Records from MySQL\nDESCRIPTION: Rust code showing how to delete records and verify the deletion through a query\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n    // delete some data\n    r\"DELETE FROM orders WHERE order_id=4;\"\n        .ignore(&mut conn)\n        .await?;\n\n    // query data\n    let loaded_orders = \"SELECT * FROM orders\"\n        .with(())\n        .map(\n            &mut conn,\n            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {\n                Order::new(\n                    order_id,\n                    production_id,\n                    quantity,\n                    amount,\n                    shipping,\n                    tax,\n                    shipping_address,\n                )\n            },\n        )\n        .await?;\n    dbg!(loaded_orders.len());\n    dbg!(loaded_orders);\n```\n\n----------------------------------------\n\nTITLE: Compiling Basic WasmEdge C API Test Program\nDESCRIPTION: Simple C program demonstrating WasmEdge version retrieval and compilation process using gcc\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge\\/wasmedge.h>\\n#include <stdio.h>\\nint main() {\\n  printf(\"WasmEdge version: %s\\\\n\", WasmEdge_VersionGet());\\n  return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring containerd for WasmEdge Runtime Support\nDESCRIPTION: Commands to configure containerd to support WasmEdge runtime by updating the containerd configuration file and restarting the service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Run the following command as root user\nsudo bash -c \"containerd config default > /etc/containerd/config.toml\"\necho '[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.wasmedge] runtime_type = \"io.containerd.wasmedge.v1\"' | sudo tee -a /etc/containerd/config.toml > /dev/null\nsudo systemctl restart containerd\n```\n\n----------------------------------------\n\nTITLE: Building with Cargo Config\nDESCRIPTION: Command to build WebAssembly application using cargo config settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge 0.13.5 via Bash Script\nDESCRIPTION: This snippet demonstrates how to install WasmEdge version 0.13.5 using a curl command to download and execute an installation script.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.13.5\n```\n\n----------------------------------------\n\nTITLE: Configuring PyTorch Dependencies for WASI-NN Plugin\nDESCRIPTION: These commands download and configure the necessary dependencies for the PyTorch backend of the WASI-NN plugin.  It downloads a specific version of the libtorch C++ library, unzips it, and updates the LD_LIBRARY_PATH to include the library's location. The script ensures that WasmEdge can access the required PyTorch libraries at runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport PYTORCH_VERSION=\"1.8.2\"\n# For the Ubuntu 20.04 or above, use the libtorch with cxx11 abi.\nexport PYTORCH_ABI=\"libtorch-cxx11-abi\"\n# For the manylinux2014, please use the without cxx11 abi version:\n#   export PYTORCH_ABI=\"libtorch\"\ncurl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\nunzip -q \"${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nrm -f \"${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nexport LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$(pwd)/libtorch/lib\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling RustPython with WasmEdge\nDESCRIPTION: Uses WasmEdge to compile the WebAssembly bytecode to native machine code for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/python/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile ./target/wasm32-wasip1/release/rustpython.wasm ./target/wasm32-wasip1/release/rustpython.wasm\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling the WASM file\nDESCRIPTION: This command AOT (Ahead-Of-Time) compiles the `llama-chat.wasm` file, potentially improving performance by pre-compiling the WASM bytecode to native code. The original WASM file is overwritten with the compiled version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile llama-chat.wasm llama-chat.wasm\nwasmedge --dir .:.  --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat\n```\n\n----------------------------------------\n\nTITLE: Creating and Reading V128 SIMD Values in Go\nDESCRIPTION: Demonstrates how to create a new v128 value for SIMD operations and retrieve its component values. The v128 is represented by two uint64 values for high and low bits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nval := wasmedge.NewV128(uint64(1234), uint64(5678))\nhigh, low := val.GetVal()\n// `high` will be uint64(1234), `low` will be uint64(5678)\n```\n\n----------------------------------------\n\nTITLE: Describing WebAssembly Pod on Cloud Side\nDESCRIPTION: Command to get detailed information about the deployed WebAssembly pod using kubectl describe.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl describe pod wasi-demo\n```\n\n----------------------------------------\n\nTITLE: Configuring the target platform in Cargo\nDESCRIPTION: This TOML snippet configures the Rust project to target the `wasm32-wasip1` platform. It also sets the `runner` to `wasmedge`, allowing the compiled WebAssembly binary to be executed directly using the WasmEdge runtime. The `--dir` argument specifies the directory to be mounted as `/static` for serving static assets.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"wasm32-wasip1\"\n\n[target.wasm32-wasip1]\nrunner = \"wasmedge --dir /static:../client/build\"\n\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Execution\nDESCRIPTION: Demonstrates asynchronous execution of a WebAssembly function using WasmEdge's AsyncRunWasmFile method\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  vm := wasmedge.NewVM()\n\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bindgen Functions in Rust for WebAssembly\nDESCRIPTION: This Rust code defines several functions using the wasmedge_bindgen macro. These functions demonstrate various operations including creating a line from points, string manipulation, mathematical calculations, and cryptographic hashing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/bindgen.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse num_integer::lcm;\nuse serde::{Deserialize, Serialize};\nuse sha3::{Digest, Keccak256, Sha3_256};\n#[allow(unused_imports)]\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: f32,\n    y: f32,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n    points: Vec<Point>,\n    valid: bool,\n    length: f32,\n    desc: String,\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> String {\n    let point1: Point = serde_json::from_str(&p1).unwrap();\n    let point2: Point = serde_json::from_str(&p2).unwrap();\n    let length = ((point1.x - point2.x) * (point1.x - point2.x)\n        + (point1.y - point2.y) * (point1.y - point2.y))\n        .sqrt();\n\n    let valid = if length == 0.0 { false } else { true };\n\n    let line = Line {\n        points: vec![point1, point2],\n        valid: valid,\n        length: length,\n        desc: desc,\n    };\n\n    return serde_json::to_string(&line).unwrap();\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> String {\n    let r = String::from(\"hello \");\n    return r + &s;\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> String {\n    (&s).chars()\n        .map(|c| match c {\n            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,\n            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,\n            _ => c,\n        })\n        .collect()\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> i32 {\n    let r = lcm(a, b);\n    return r;\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {\n    return Sha3_256::digest(&v).as_slice().to_vec();\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {\n    return Keccak256::digest(&s).as_slice().to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM with ExternRef using WasmEdge C API\nDESCRIPTION: This code shows how to execute a WASM module that uses externref in WasmEdge using the C API. It demonstrates creating a VM, registering a module, loading a WASM file, instantiating it, and executing a function using externref.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Create the VM context. */\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Create the module instance context that contains the host functions. */\nWasmEdge_ModuleInstanceContext *HostMod = /* Ignored ... */;\nWasmEdge_Value P[3], R[1];\nWasmEdge_String FuncName;\nWasmEdge_Result Res;\n\n/* Register the module instance into VM. */\nRes = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Import object registration failed\\n\");\n  return EXIT_FAILURE;\n}\n/* Load WASM from the file. */\nRes = WasmEdge_VMLoadWasmFromFile(VMCxt, \"funcs.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM file loading failed\\n\");\n  return EXIT_FAILURE;\n}\n/* Validate WASM. */\nRes = WasmEdge_VMValidate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM validation failed\\n\");\n  return EXIT_FAILURE;\n}\n/* Instantiate the WASM module. */\nRes = WasmEdge_VMInstantiate(VMCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed\\n\");\n  return EXIT_FAILURE;\n}\n\n/* Run a WASM function. */\nP[0] = WasmEdge_ValueGenExternRef(AddFunc);\nP[1] = WasmEdge_ValueGenI32(1234);\nP[2] = WasmEdge_ValueGenI32(5678);\n/* Run the `call_add` function. */\nFuncName = WasmEdge_StringCreateByCString(\"call_add\");\nRes = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);\nWasmEdge_StringDelete(FuncName);\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Run -- `call_add` -- 1234 + 5678 = %d\\n\",\n          WasmEdge_ValueGetI32(R[0]));\n} else {\n  printf(\"Run -- `call_add` -- 1234 + 5678 -- failed\\n\");\n  return EXIT_FAILURE;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Cluster with kubeadm on KubeEdge Master Node\nDESCRIPTION: Initializes a Kubernetes cluster using kubeadm on the KubeEdge master node, setting up necessary configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#kubernetes scheduler requires this setting to be done.\n$ sudo swapoff -a\n$ sudo vim /etc/fstab\nmark contain swapfile of row\n\n$ cat /etc/cni/net.d/100-crio-bridge.conf\n{\n    \"cniVersion\": \"0.3.1\",\n    \"name\": \"crio\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"hairpinMode\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" },\n            { \"dst\": \"1100:200::1/24\" }\n        ],\n        \"ranges\": [\n            [{ \"subnet\": \"10.85.0.0/16\" }],\n            [{ \"subnet\": \"1100:200::/24\" }]\n        ]\n    }\n}\n$ export CIDR=10.85.0.0/16\n$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock\n\n$ mkdir -p $HOME/.kube\n$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n$ sudo chown $(id -u):$(id -g) $HOME/.kube/config\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly with WasmEdge\nDESCRIPTION: Compiles the WebAssembly module to include native machine code using 'wasmedge compile', resulting in enhanced performance. The output is a natively instrumented wasm file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile target/wasm32-wasip1/release/wasmedge_quickjs.wasm wasmedge_quickjs_nn.wasm\n```\n\n----------------------------------------\n\nTITLE: Testing the JavaScript-based server with curl\nDESCRIPTION: A curl command to test the functionality of the running JavaScript-based server by sending a POST request to the /echo endpoint.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\nHello WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Proposals Constants in Go\nDESCRIPTION: Constants representing WebAssembly proposal flags that can be enabled or disabled in the WasmEdge runtime configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)\n  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)\n  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n  EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)\n  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)\n  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Containerd for WebAssembly Support\nDESCRIPTION: Configuration for containerd to add crun as a runtime for WebAssembly workloads. This setup defines a new runtime class that can handle WebAssembly modules through annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# comment this line to make cri wokrs\n# disabled_plugins = [\"cri\"]\n\n# add the following section to setup crun runtime, make sure the BinaryName equal to your crun binary path\n[plugins]\n  [plugins.cri]\n    [plugins.cri.containerd]\n      [plugins.cri.containerd.runtimes]\n...\n        [plugins.cri.containerd.runtimes.crun]\n           runtime_type = \"io.containerd.runc.v2\"\n           pod_annotations = [\"*.wasm.*\", \"wasm.*\", \"module.wasm.image/*\", \"*.module.wasm.image\", \"module.wasm.image/variant.*\"]\n           privileged_without_host_devices = false\n           [plugins.cri.containerd.runtimes.crun.options]\n             BinaryName = \"/usr/local/bin/crun\"\n```\n\n----------------------------------------\n\nTITLE: Plugin and Module Descriptors\nDESCRIPTION: Definition of plugin and module descriptors containing metadata and configuration for the WasmEdge plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstatic WasmEdge_ModuleDescriptor ModuleDesc[] = {{\n    .Name = \"wasmedge_plugintest_c_module\",\n    .Description = \"This is for the plugin tests in WasmEdge C API.\",\n    .Create = CreateTestModule,\n}};\n\nstatic WasmEdge_PluginDescriptor Desc[] = {{\n    .Name = \"wasmedge_plugintest_c\",\n    .Description = \"\",\n    .APIVersion = WasmEdge_Plugin_CurrentAPIVersion,\n    .Version =\n        {\n            .Major = 0,\n            .Minor = 1,\n            .Patch = 0,\n            .Build = 0,\n        },\n    .ModuleCount = 1,\n    .ProgramOptionCount = 0,\n    .ModuleDescriptions = ModuleDesc,\n    .ProgramOptions = NULL,\n}};\n```\n\n----------------------------------------\n\nTITLE: Creating a Hello World Application in Go for WasmEdge\nDESCRIPTION: A simple Go program that prints a message to the console. The main() function is the entry point for the application when compiled to WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/go/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nfunc main() {\n  println(\"Hello TinyGo from WasmEdge!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Optimization Levels in Go\nDESCRIPTION: Constants defining various optimization levels for the WasmEdge AOT compiler, ranging from O0 (minimal optimization) to Oz (optimized for smallest code size).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_69\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  // Disable as many optimizations as possible.\n  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)\n  // Optimize quickly without destroying debuggability.\n  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)\n  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.\n  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)\n  // Optimize for fast execution as much as possible.\n  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)\n  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.\n  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)\n  // Optimize for small code size as much as possible.\n  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)\n)\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow Interface Dependency in Rust\nDESCRIPTION: Configuration for adding the wasmedge_tensorflow_interface crate as a dependency in Cargo.toml\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasmedge_tensorflow_interface = \"0.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Adding WasmEdge Process Interface Dependency in Rust\nDESCRIPTION: This snippet shows how to add the wasmedge_process_interface dependency to the Cargo.toml file for a Rust project. This dependency is required to use the WasmEdge command interface functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/command.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasmedge_process_interface = \"0.2.1\"\n```\n\n----------------------------------------\n\nTITLE: Downloading TensorFlow-Lite Dependencies\nDESCRIPTION: Downloads and extracts the TensorFlow-Lite shared libraries required for the WASI-NN TensorflowLite plugin. This script includes version and platform configuration options.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nVERSION=TF-2.12.0-CC\n# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.\nPLATFORM=manylinux2014_x86_64\n# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.\n# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.\n# For the MacOS arm64 platforms, please use the `darwin_arm64`.\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/$VERSION/WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz\ntar -zxf WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz\nrm -f WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository\nDESCRIPTION: Commands to clone the WasmEdge source code repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Docker Container for TensorFlow Inference\nDESCRIPTION: Shell commands to build and run a Docker container with TensorFlow inference capabilities using WasmEdge. Shows the process of building the image and starting the TensorFlow inference server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 3000:3000 wasmedge/myapp\nlisten 3000 ...\n```\n\n----------------------------------------\n\nTITLE: Verifying NVIDIA Driver and Container Toolkit Installation\nDESCRIPTION: Commands to verify that NVIDIA GPU drivers and the NVIDIA Container Toolkit are properly installed and configured on the host system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# check your driver and device\n> nvidia-smi -L\n\n# Check your toolkit\n> nvidia-ctk --version\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge TLS Plugin\nDESCRIPTION: These commands download, extract, and install the WasmEdge TLS plugin, which enables HTTPS and TLS support for WasmEdge sockets. The plugin is installed either for a local user or system-wide, depending on the initial WasmEdge installation. The `cp` command places the shared library in the correct plugin directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/WasmEdge/WasmEdge/releases/download/0.13.4/WasmEdge-plugin-wasmedge_rustls-0.13.4-manylinux2014_x86_64.tar.gz\ntar xf WasmEdge-plugin-wasmedge_rustls-0.13.4-manylinux2014_x86_64.tar.gz\n\n# If you only installed WasmEdge for the local user\ncp libwasmedge_rustls.so ~/.wasmedge/plugin/\n\n# If you installed Wasmedge at /usr/local for all users\nsudo mkdir -p /usr/local/lib/wasmedge/\nsudo cp libwasmedge_rustls.so /usr/local/lib/wasmedge/\n```\n\n----------------------------------------\n\nTITLE: Verifying NVIDIA Driver and Container Toolkit Installation\nDESCRIPTION: Commands to verify that NVIDIA drivers and toolkit are properly installed on the system. These checks ensure that GPU hardware is recognized and the required CDI tools are available.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# check your driver and device\n> nvidia-smi -L\n\n# Check your toolkit\n> nvidia-ctk --version\n```\n\n----------------------------------------\n\nTITLE: Compilation Output Example\nDESCRIPTION: Shows the expected output when compiling a WebAssembly file using the WasmEdge compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_88\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n```\n\n----------------------------------------\n\nTITLE: Running a WASI Application on Other Linux with Podman\nDESCRIPTION: This command runs a simple WASI application using Podman on a Linux distribution other than Fedora, with WasmEdge runtime support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npodman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow Dependencies\nDESCRIPTION: Commands to download and extract TensorFlow shared libraries for WasmEdge plugin usage.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.\n# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.\n# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.\ntar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nrm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Installing Knative Serving\nDESCRIPTION: Commands to install Knative Serving and its networking layer (Kourier) in the Kubernetes cluster. Also includes enabling the RuntimeClass feature gate in Knative for WebAssembly support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# install the Knative Serving component\n$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-crds.yaml\n$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-core.yaml\n\n# install a networking layer\n$ kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v1.7.0/kourier.yaml\n$ kubectl patch configmap/config-network \\\n  --namespace knative-serving \\\n  --type merge \\\n  --patch '{\"data\":{\"ingress-class\":\"kourier.ingress.networking.knative.dev\"}}'\n$ kubectl --namespace kourier-system get service kourier\n\n# verify the installation\n$ kubectl get pods -n knative-serving\n\n# open runtimeClass feature gate in Knative\n$ kubectl patch configmap/config-features -n knative-serving --type merge --patch '{\"data\":{\"kubernetes.podspec-runtimeclassname\":\"enabled\"}}'\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly for WasmEdge\nDESCRIPTION: These bash commands clone the example repository, build the Rust code targeting WebAssembly, and use WasmEdge AOT compiler to optimize the generated Wasm file for faster execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/ai.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd go_TfliteFood/rust_tflite_food\ncargo build --target wasm32-wasip1 --release\ncp target/wasm32-wasip1/release/rust_tflite_food_lib.wasm ../\ncd ../\n\nwasmedge compile rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Basic WasmEdge Go Integration\nDESCRIPTION: Implementation of a Go program that creates a WASM VM, registers a host function, and executes a WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_67\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  res := params[0].(int32) + params[1].(int32)\n  returns := make([]interface{}, 1)\n  returns[0] = res\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  vm := wasmedge.NewVM()\n  wasmbuf := []byte{\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x07, 0x01,\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    0x02, 0x13, 0x01,\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    0x00, 0x00,\n    0x03, 0x02, 0x01, 0x00,\n    0x07, 0x0A, 0x01,\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    0x00, 0x01,\n    0x0A, 0x0A, 0x01,\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n  }\n\n  impmod := wasmedge.NewModule(\"extern\")\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"func-add\", hostfunc)\n  vm.RegisterImport(impmod)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Simple WebAssembly Docker Container\nDESCRIPTION: Shell commands to build a Docker image containing a WebAssembly application and run it. The commands demonstrate the process of creating and executing the container with WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm wasmedge/myapp\nRandom number: -807910034\nRandom bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]\nPrinted from wasi: This is from a main function\nThis is from a main function\nThe env vars are as follows.\nThe args are as follows.\nwasi_example_main.wasm\nFile content is This is in a file\n```\n\n----------------------------------------\n\nTITLE: WASM Module Registration (WasmEdge 0.9.1)\nDESCRIPTION: Example of registering a WASM module with a module name using WasmEdge_ExecutorRegisterModule API in version 0.9.1.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt;\n/*\n * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.\n * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.\n * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.\n */\n\n/* Register the WASM module into store with the export module name \"mod\". */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nRes = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);\nWasmEdge_StringDelete(ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Reloading Docker Daemon and Testing CDI Setup in Bash\nDESCRIPTION: Commands to reload the Docker daemon after configuration changes and test the CDI setup by running a container with access to NVIDIA GPUs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Reload docker daemon\n> sudo systemctl reload docker\n\n# Test your cdi setup good\n> docker run --rm --device nvidia.com/gpu=all ubuntu:22.04 nvidia-smi -L\n\n# Example output \nGPU 0: NVIDIA GeForce GTX 1080 (UUID: GPU-********-****-****-****-************)\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Dependencies\nDESCRIPTION: Commands to download and extract WasmEdge Android dependencies including core runtime, image processing, and TensorFlow Lite components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/ndk.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/WasmEdge/WasmEdge/releases/download/0.12.1/WasmEdge-0.12.1-android_aarch64.tar.gz\nwget https://github.com/second-state/WasmEdge-image/releases/download/0.12.1/WasmEdge-image-0.12.1-android_aarch64.tar.gz\nwget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.12.1/WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz\nwget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz\ntar -zxf WasmEdge-0.12.1-android_aarch64.tar.gz\ntar -zxf WasmEdge-image-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/\ntar -zxf WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/\ntar -zxf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/lib/\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with llama.cpp Backend on Apple Silicon MacOS\nDESCRIPTION: Commands to build WasmEdge with the llama.cpp (GGML) backend on Apple Silicon MacOS. This enables METAL acceleration for GPU support but disables BLAS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n# Enable METAL on arm64 macOS.\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=ON \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Setting up TensorFlow Libraries on Linux\nDESCRIPTION: Commands to move TensorFlow shared libraries to system locations and create necessary symbolic links on Linux systems.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflow_cc.so.2.12.0 /usr/local/lib\nmv libtensorflow_framework.so.2.12.0 /usr/local/lib\nln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2\nln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so\nln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2\nln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so\n```\n\n----------------------------------------\n\nTITLE: Installing TinyGo on Debian-based Linux Systems\nDESCRIPTION: Commands to download and install TinyGo v0.21.0 on Ubuntu or other Debian-based Linux systems with x86 processors. The installation is verified by checking the TinyGo version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/go/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb\nsudo dpkg -i tinygo_0.21.0_amd64.deb`\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ tinygo version\ntinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge on RISC-V\nDESCRIPTION: Creates a build directory, configures the build with CMake in Release mode, and compiles WasmEdge from source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j\n```\n\n----------------------------------------\n\nTITLE: Installing CRI-O on KubeEdge Master Node\nDESCRIPTION: This snippet installs CRI-O on a master node, including steps to configure kernel modules, sysctl parameters, and package repositories. It requires sudo access and network connectivity to install necessary packages and keys.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install CRI-O\ncat <<EOF | sudo tee /etc/modules-load.d/crio.conf\noverlay\nbr_netfilter\nEOF\n\nsudo modprobe overlay\nsudo modprobe br_netfilter\n\ncat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf\nnet.bridge.bridge-nf-call-iptables  = 1\nnet.ipv4.ip_forward                 = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nEOF\n\nsudo sysctl --system\nexport OS=\"xUbuntu_20.04\"\nexport VERSION=\"1.21\"\ncat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\ndeb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\nEOF\ncat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list\ndeb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /\nEOF\n\ncurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -\ncurl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -\n\nsudo apt-get update\nsudo apt-get install cri-o cri-o-runc\n\nsudo systemctl daemon-reload\nsudo systemctl enable crio --now\nsudo systemctl status cri-o\n```\n\n----------------------------------------\n\nTITLE: Pulling WasmEdge Docker Build Image\nDESCRIPTION: Command to pull a WasmEdge build environment Docker image. Replace {tag_name} with the desired version tag from the supported list.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/docker.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull wasmedge/wasmedge:{tag_name}\n```\n\n----------------------------------------\n\nTITLE: Installing crun Dependencies on Ubuntu\nDESCRIPTION: Commands to install the necessary dependencies for building crun from source on Ubuntu 20.04. This prepares the system for compiling crun with WasmEdge support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y make git gcc build-essential pkgconf libtool \\\n    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n    go-md2man libtool autoconf python3 automake\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Core\nDESCRIPTION: Command to install the WasmEdge shared library matching the WasmEdge-Go version 0.12.1\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.12.1\n```\n\n----------------------------------------\n\nTITLE: Setting Data and Finalizer in Module Instance Creation in C\nDESCRIPTION: Demonstrates how to set host data and its finalizer when creating a module instance using the WasmEdge_ModuleInstanceCreateWithData() API. This is useful for implementing plug-ins and managing resource lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Struct definition. */\ntypedef struct Point {\n  int X;\n  int Y;\n} Point;\n\n/* Host function body definition. */\nWasmEdge_Result Print(void *Data,\n                      const WasmEdge_CallingFrameContext *CallFrameCxt,\n                      const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  Point *P = (Point *)In;\n  printf(\"Point: (%d, %d)\\n\", P->X, P->Y);\n  return WasmEdge_Result_Success;\n}\n\n/* Finalizer definition. */\nvoid PointFinalizer(void *Data) {\n  if (Data) {\n    free((Point *)Data);\n  }\n}\n\n/* Create a module instance with host data and its finalizer. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nPoint *Data = (Point *)malloc(sizeof(Point));\nData->X = 5;\nData->Y = -5;\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);\n/*\n * When the `HostModCxt` being destroyed, the finalizer will be invoked and the\n * `Data` will be its argument.\n */\nWasmEdge_StringDelete(ExportName);\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with OpenVINO Backend\nDESCRIPTION: Commands to build WasmEdge from source with the OpenVINO backend for WASI-NN. This requires the OpenVINO dependency to be installed first.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"OpenVINO\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Function in Reactor Mode\nDESCRIPTION: Command to execute a WebAssembly function in reactor mode with specific parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --reactor target/wasm32-wasip1/release/add.wasm add 2 2\n```\n\n----------------------------------------\n\nTITLE: Add and Update Helm Repository for Kwasm\nDESCRIPTION: These commands add the Kwasm Helm repository and update the Helm repositories. Helm is a package manager for Kubernetes, used here to install the Kwasm operator.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhelm repo add kwasm http://kwasm.sh/kwasm-operator/\nhelm repo update\n```\n\n----------------------------------------\n\nTITLE: Closing MySQL Connection\nDESCRIPTION: Rust code showing proper cleanup of database connection and pool\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n    drop(conn);\n    pool.disconnect().await.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Running a simple WebAssembly app with containerd\nDESCRIPTION: Commands to pull and run a simple WebAssembly container image using containerd and crun.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ctr i pull docker.io/wasmedge/example-wasi:latest\n\nsudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Booting the seL4 Simulator with WasmEdge\nDESCRIPTION: Commands to navigate to the build directory and launch the seL4 simulator with the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd sel4_wasmedge/build\n./simulate\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WebAssembly Containers with CRI-O\nDESCRIPTION: This code snippet demonstrates the process of creating a container instance, starting it, checking its status, viewing logs, and interacting with the containerized HTTP server. It uses CRI-O commands to manage the container lifecycle and test the WebAssembly program running inside it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Create the container instance. The output will be different from the example.\n$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json\n# Set a helper variable for later use.\nCONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Start the container\n$ sudo crictl start $CONTAINER_ID\n\n# Check the container status. It should be Running.\n# If not, wait a few seconds and check again\n$ sudo crictl ps -a\nCONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID\n4eeddf8613691       wasmedge/example-wasi-http:latest              Less than a second ago   Running             http_server         0                   1d84f30e7012e\n\n# Check the container's logs to see if the HTTP server is listening at port 1234\n$ sudo crictl logs $CONTAINER_ID\nnew connection at 1234\n\n# Get the IP address assigned to the container\n$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'\"' -f 2\n10.85.0.2\n\n# Test the HTTP service at that IP address\n$ curl -d \"name=WasmEdge\" -X POST http://10.85.0.2:1234\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-go with TensorFlow Extension\nDESCRIPTION: Demonstrates how to build WasmEdge-go with the TensorFlow extension enabled using build tags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/intro.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags tensorflow\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with TensorFlow Plugin\nDESCRIPTION: Commands to build WasmEdge from source with TensorFlow plugin support using CMake. This includes configuration, building and installation steps.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On\ncmake --build build\n# For the WasmEdge-Tensorflow plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Axum Echo Handler Implementation\nDESCRIPTION: Implementation of the echo handler function that processes POST requests to /echo endpoint\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/server.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nasync fn echo(mut stream: BodyStream) -> Bytes {\n    if let Some(Ok(s)) = stream.next().await {\n        s\n    } else {\n        Bytes::new()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling a Test C File with WasmEdge\nDESCRIPTION: Demonstrates how to compile a test C file that utilizes the WasmEdge API to show the version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngcc test.c -lwasmedge\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Binary Code Snippet\nDESCRIPTION: A fragment of WebAssembly binary code in hexadecimal format, showing parts of the code section including export description and function body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_62\n\nLANGUAGE: webassembly\nCODE:\n```\n0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n/* export desc: func 0 */\n0x00, 0x01,\n/* Code section */\n0x0A, 0x0A, 0x01,\n/* code body */\n0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting WasmEdge Contexts\nDESCRIPTION: Shows how to create and delete WasmEdge contexts, such as configurations, to manage resources and support garbage collection.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Downloading runwasi Project\nDESCRIPTION: Clone the runwasi project repository from GitHub to get the necessary source code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containerd/runwasi.git\n```\n\n----------------------------------------\n\nTITLE: Requesting the hyper server with curl\nDESCRIPTION: This command sends a POST request to the HTTP server running on localhost:8080, specifically to the `/echo` endpoint, with the data \"WasmEdge\". The server is expected to echo back this data as a response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:8080/echo -X POST -d \"WasmEdge\"\nWasmEdge\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel for React SSR\nDESCRIPTION: Babel configuration file for transpiling React and modern JavaScript for server-side rendering.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Table Instances in WasmEdge\nDESCRIPTION: Demonstrates the creation and management of Table instances, including setting/getting data, retrieving table type, and growing table size. Tables in WebAssembly are resizable typed arrays that store function references.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\n/* Create the table type with limit and the `FuncRef` element type. */\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\n/* Create the table instance with table type. */\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(TabTypeCxt);\n/* Delete the table type. */\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\n/*\n * The `TabTypeCxt` got from table instance is owned by the `HostTable` and\n * should __NOT__ be destroyed.\n */\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `RefType` will be `WasmEdge_RefType_FuncRef`. */\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\n/* Set the function index 5 to the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);\n */\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n/* Get the FuncRef value of the table[3]. */\n/*\n * This will get an \"out of bounds table access\" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);\n */\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\n/* `Size` will be 10. */\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n/* Grow the table size of 6, the table size will be 16. */\n/*\n * This will get an \"out of bounds table access\" error because\n * the size (16 + 6) will reach the table limit(20):\n *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);\n */\n\nWasmEdge_TableInstanceDelete(HostTable);\n```\n\n----------------------------------------\n\nTITLE: Calling Rust WebAssembly Function from Go\nDESCRIPTION: This Go code demonstrates how to call a Rust-based WebAssembly function that handles string parameters. It shows memory allocation, data copying, function execution, and memory deallocation using the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"strings\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  wasi := vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n\n  err := vm.LoadWasmFile(os.Args[1])\n  if err != nil {\n    fmt.Println(\"failed to load wasm\")\n  }\n  vm.Validate()\n  vm.Instantiate()\n\n  subject := \"WasmEdge\"\n  lengthOfSubject := len(subject)\n\n  // Allocate memory for the subject, and get a pointer to it.\n  // Include a byte for the NULL terminator we add below.\n  allocateResult, _ := vm.Execute(\"allocate\", int32(lengthOfSubject + 1))\n  inputPointer := allocateResult[0].(int32)\n\n  // Write the subject into the memory.\n  mod := vm.GetActiveModule()\n  mem := mod.FindMemory(\"memory\")\n  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))\n  copy(memData, subject)\n\n  // C-string terminates by NULL.\n  memData[lengthOfSubject] = 0\n\n  // Run the `greet` function. Given the pointer to the subject.\n  greetResult, _ := vm.Execute(\"greet\", inputPointer)\n  outputPointer := greetResult[0].(int32)\n\n  pageSize := mem.GetPageSize()\n  // Read the result of the `greet` function.\n  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))\n  nth := 0\n  var output strings.Builder\n\n  for {\n    if memData[int(outputPointer) + nth] == 0 {\n      break\n    }\n\n    output.WriteByte(memData[int(outputPointer) + nth])\n    nth++\n  }\n\n  lengthOfOutput := nth\n\n  fmt.Println(output.String())\n\n  // Deallocate the subject, and the output.\n  vm.Execute(\"deallocate\", inputPointer, int32(lengthOfSubject+1))\n  vm.Execute(\"deallocate\", outputPointer, int32(lengthOfOutput+1))\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge QuickJS with WASI-NN Support\nDESCRIPTION: Instructions for building the WasmEdge QuickJS runtime with WASI-NN support from source, including installing GCC, cloning the repository, and compiling for WebAssembly with WASI-NN features.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/tensorflow.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Install GCC\nsudo apt update\nsudo apt install build-essential\n\n# get the source code\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n\n# Build the QuickJS JavaScript interpreter with WASI NN\ncargo build --target wasm32-wasip1 --release --features=wasi_nn\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly with WasmEdge\nDESCRIPTION: Command to execute the compiled WebAssembly file using WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge hello.wasm\nHello World\n```\n\n----------------------------------------\n\nTITLE: Testing Node.js Server with curl\nDESCRIPTION: Shell command to test the Node.js server running in the Docker container by sending a POST request with curl. Demonstrates how to interact with the lightweight Node.js server powered by WasmEdge QuickJS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ curl -X POST http://127.0.0.1:8001 -d \"WasmEdge\"\necho:WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Static Library with CMake\nDESCRIPTION: Provides CMake configuration commands to build WasmEdge as a static library with specific build options\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/library.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncmake -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release \\\n-DWASMEDGE_LINK_LLVM_STATIC=ON \\\n-DWASMEDGE_BUILD_SHARED_LIB=Off \\\n-DWASMEDGE_BUILD_STATIC_LIB=On \\\n-DWASMEDGE_LINK_TOOLS_STATIC=On \\\n-DWASMEDGE_BUILD_PLUGINS=Off\ncmake --build build\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Compiling Addition Function to WebAssembly\nDESCRIPTION: Command to compile the addition function C program to WebAssembly using Emscripten compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nemcc add.c -o add.wasm\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with Process Plugin Support\nDESCRIPTION: Commands to build WasmEdge from source with the WasmEdge-Process plugin enabled. The process includes configuring CMake with the WASMEDGE_PLUGIN_PROCESS option, building the project, and installing it to the system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/process.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On\ncmake --build build\n# For the WasmEdge-Process plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Command to verify the installed Go version, which must be >= 1.15 for WasmEdge-Go\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Creating an add function in Rust for WasmEdge\nDESCRIPTION: This Rust code snippet defines a public function `add()` that takes two integers and returns their sum. This function is designed to be executed within WasmEdge in reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub fn add(a: i32, b: i32) -> i32 {\n  return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Addition Function in Rust for WasmEdge\nDESCRIPTION: A Rust library function that adds two 32-bit integers. This example demonstrates creating a simple WebAssembly function that can be called from the CLI in reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub fn add(a: i32, b: i32) -> i32 {\n  return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading WasmEdge for Android Dependencies\nDESCRIPTION: Bash commands to download and extract WasmEdge and its dependencies (image processing and TensorFlow Lite modules) for Android arm64-v8a architecture.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/ndk.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/WasmEdge/WasmEdge/releases/download/0.12.1/WasmEdge-0.12.1-android_aarch64.tar.gz\nwget https://github.com/second-state/WasmEdge-image/releases/download/0.12.1/WasmEdge-image-0.12.1-android_aarch64.tar.gz\nwget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.12.1/WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz\nwget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz\ntar -zxf WasmEdge-0.12.1-android_aarch64.tar.gz\ntar -zxf WasmEdge-image-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/\ntar -zxf WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/\ntar -zxf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/lib/\n```\n\n----------------------------------------\n\nTITLE: Adding React Import for Server Recognition\nDESCRIPTION: Adding explicit React import in App.js for server-side recognition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\n//...\n```\n\n----------------------------------------\n\nTITLE: Adding DCO Signoff to Git Commits\nDESCRIPTION: Instructions for signing off on commits to comply with the Developer Certificate of Origin (DCO) requirements. The code shows how to add the signoff automatically with the -s flag to git commit.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/overview.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -s -m \"my commit message w/signoff\"\n```\n\n----------------------------------------\n\nTITLE: Automatic Installation of WasmEdge on seL4\nDESCRIPTION: This snippet shows how to perform an automatic installation of WasmEdge on seL4 using an all-in-one build script that clones and builds the required components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Generating CDI Specification for NVIDIA GPUs\nDESCRIPTION: Commands to generate and verify the Container Device Interface (CDI) specification file for NVIDIA GPUs, which enables containers to access GPU devices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml\n\n# Check you cdi config is good\n> nvidia-ctk cdi list\n\n# Example output\nINFO[0000] Found 2 CDI devices\nnvidia.com/gpu=0\nnvidia.com/gpu=all\n```\n\n----------------------------------------\n\nTITLE: Building Encrypt-Decrypt Example for WASI\nDESCRIPTION: Commands to clone the libsql_bindgen repository, navigate to the encrypt_decrypt example, and build it for the wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/libsql.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/libsql/libsql_bindgen\ncd libsql_bindgen/examples/encrypt_decrypt\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow Shared Libraries on Linux\nDESCRIPTION: Moves the downloaded TensorFlow shared libraries to the appropriate installation directory for Linux systems and creates necessary symbolic links for proper library versioning.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n# If you installed wasmedge locally as above\nmv libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib\nmv libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib\nln -s libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib/libtensorflow_cc.so.2\nln -s libtensorflow_cc.so.2 ~/.wasmedge/lib/libtensorflow_cc.so\nln -s libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib/libtensorflow_framework.so.2\nln -s libtensorflow_framework.so.2 ~/.wasmedge/lib/libtensorflow_framework.so\n\n# Or, if you installed wasmedge for all users in /usr/local/\nmv libtensorflow_cc.so.2.12.0 /usr/local/lib\nmv libtensorflow_framework.so.2.12.0 /usr/local/lib\nln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2\nln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so\nln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2\nln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so\n\n# Or on MacOS platforms\nmv libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib\nmv libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib\nln -s libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_cc.2.dylib\nln -s libtensorflow_cc.2.dylib ~/.wasmedge/lib/libtensorflow_cc.dylib\nln -s libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_framework.2.dylib\nln -s libtensorflow_framework.2.dylib ~/.wasmedge/lib/libtensorflow_framework.dylib\n```\n\n----------------------------------------\n\nTITLE: Creating WasmEdge Server Project with Cargo\nDESCRIPTION: Command to create a new Rust crate for the WasmEdge server implementation alongside the existing server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo new server-wasmedge\n```\n\n----------------------------------------\n\nTITLE: Listing and Retrieving Registered Modules\nDESCRIPTION: Demonstrates how to list and retrieve registered modules in the WasmEdge VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the registered module names in the VM context. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\n```\n\n----------------------------------------\n\nTITLE: Running a Standalone WASM App with Podman\nDESCRIPTION: Demonstrates how to use Podman to run a containerized WASM application stored in Docker Hub.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npodman --runtime /usr/bin/crun-wasm run --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-hello:latest\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WasmEdge-Image Plugin on Linux\nDESCRIPTION: Command to install required dependencies (zlib and boost libraries) for building WasmEdge with the Image plugin on Linux platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/image.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install zlib1g-dev libboost-all-dev\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-go with Image Extension in Go\nDESCRIPTION: Command to build WasmEdge-go with the Image extension enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image\n```\n\n----------------------------------------\n\nTITLE: Running JavaScript with TensorFlow Lite in WasmEdge\nDESCRIPTION: Command to run the JavaScript TensorFlow Lite example in WasmEdge with the WASI-NN runtime, showing the expected output of food recognition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/tensorflow.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs_nn.wasm example_js/tensorflow_lite_demo/wasi_nn_main.js\nlabel:\nHot dog\nconfidence:\n0.8941176470588236\n```\n\n----------------------------------------\n\nTITLE: Nginx Configuration for Go WASM Module\nDESCRIPTION: Nginx configuration file that sets up the WASM virtual machine, loads the Go WASM module, and configures HTTP server settings for custom response injection\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/wasm-nginx.md#2025-04-21_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\nworker_processes  1;\n\nerror_log  /tmp/error.log warn;\n\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    wasm_vm wasmedge;\n    init_by_lua_block {\n        local wasm = require(\"resty.proxy-wasm\")\n        package.loaded.plugin = assert(wasm.load(\"fault_injection\",\n            \"/path/to/fault-injection/main.go.wasm\"))\n    }\n    server {\n        listen 1980;\n        location / {\n            content_by_lua_block {\n                local wasm = require(\"resty.proxy-wasm\")\n                local ctx = assert(wasm.on_configure(package.loaded.plugin,\n                    '{\"http_status\": 403, \"body\": \"powered by wasm-nginx-module\"}'))\n                assert(wasm.on_http_request_headers(ctx))\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Testing KinD with WasmEdge Support\nDESCRIPTION: Commands to build a custom KinD node image with WasmEdge support, create a cluster with that image, and run a test WebAssembly application to validate the setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t node-wasmedge .\nkind create cluster --image node-wasmedge\n# Now you can run the example to validate your cluster\nkubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow-Lite Library\nDESCRIPTION: Commands to download and extract TensorFlow-Lite shared library dependencies for Android.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/cli.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz\n$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools\nlibtensorflowlite_c.so\n```\n\n----------------------------------------\n\nTITLE: Configuring containerd for WebAssembly in KinD\nDESCRIPTION: Configuration for containerd to pass WebAssembly annotations to the runtime. This is added to the containerd config.toml file to ensure WebAssembly-related pod annotations are properly handled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc]\n  pod_annotations = [\"*.wasm.*\", \"wasm.*\", \"module.wasm.image/*\", \"*.module.wasm.image\", \"module.wasm.image/variant.*\"]\n```\n\n----------------------------------------\n\nTITLE: Building and Running the SSR Server\nDESCRIPTION: Commands to build the client-side app, bundle the server code, and start the WasmEdge server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run dev:build-server\nnpm run dev:start-server\n```\n\n----------------------------------------\n\nTITLE: Creating a Go Project for WasmEdge Host Functions\nDESCRIPTION: Commands to create a new Go project for working with WasmEdge. This sets up the basic project structure and initializes the Go module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_60\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Installing OpenVINO Dependencies on Ubuntu\nDESCRIPTION: Installs OpenVINO 2023 dependencies on Ubuntu 20.04 or above systems for the WASI-NN plugin with OpenVINO backend. This adds Intel's repository and installs the required libraries.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nwget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\nsudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\necho \"deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main\" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list\nsudo apt update\nsudo apt-get -y install openvino\nldconfig\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: WebAssembly text format (WAT) code defining a recursive Fibonacci function that is exported as 'fib'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_28\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Ninja Parallelization\nDESCRIPTION: This code shows how to add a parameter to the ninja build command to control the number of parallel processes, which can help prevent memory exhaustion during building.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nninja -j 2\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Rustls Plug-in Directory in Bash\nDESCRIPTION: Command to change directory to the wasmedge_rustls folder within the cloned WasmEdge repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/rusttls.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd WasmEdge/plugins/wasmedge_rustls\n```\n\n----------------------------------------\n\nTITLE: Configure kubectl\nDESCRIPTION: This snippet configures the kubectl command-line tool to interact with the local Kubernetes cluster. It sets the cluster, credentials, and context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport KUBERNETES_PROVIDER=local\n\nsudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\nsudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\nsudo cluster/kubectl.sh config set-context local --cluster=local --user=myself\nsudo cluster/kubectl.sh config use-context local\nsudo cluster/kubectl.sh\n```\n\n----------------------------------------\n\nTITLE: Using Rustls Plug-in with WasmEdge Runtime\nDESCRIPTION: Command to run a WebAssembly file with WasmEdge, specifying the Rustls plug-in. Replace 'your_wasm_file.wasm' with the actual WebAssembly file path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm\n```\n\n----------------------------------------\n\nTITLE: Running Addition Function in WasmEdge\nDESCRIPTION: Command to execute the compiled addition function WebAssembly file in WasmEdge, demonstrating passing arguments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge add.wasm 2 3\n5\n```\n\n----------------------------------------\n\nTITLE: Installing YoMo CLI and Dependencies using Bash\nDESCRIPTION: Commands for installing YoMo CLI, WasmEdge runtime, and cloning the source repository\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go install github.com/yomorun/cli/yomo@latest\n$ yomo version\nYoMo CLI version: v0.1.3\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge C++ Example\nDESCRIPTION: This bash command shows how to run the compiled WasmEdge C++ example executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c++/intro.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./example\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Curl Script\nDESCRIPTION: Downloads and installs WasmEdge using a curl script, specifying the version to match WasmEdge-go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hosts File for OpenYurt\nDESCRIPTION: This snippet demonstrates how to configure the `/etc/hosts` file to add entries for OpenYurt master and node based on their IP addresses. Proper setup of this file allows hostname resolution in the OpenYurt cluster.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n192.168.3.169  oy-master\n120.55.126.18  oy-master\n92.168.3.170   oy-node\n121.43.113.152 oy-node\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Security Settings for K8s\nDESCRIPTION: This script sets up `rp-filter` value for network security by editing `/etc/sysctl.d/10-network-security.conf` and enabling IP forwarding. It uses `sysctl` to apply these settings system-wide.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo vi /etc/sysctl.d/10-network-security.conf\necho 1 > /proc/sys/net/ipv4/ip_forward\nsudo sysctl --system\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Extensions\nDESCRIPTION: Installation command for WasmEdge with TensorFlow and Image extensions enabled\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.1\n```\n\n----------------------------------------\n\nTITLE: Running WASI Demo Application\nDESCRIPTION: Commands to load and run a sample WASI application using containerd with the WasmEdge runtime. Demonstrates basic container execution with parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake load\nsudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'\n```\n\n----------------------------------------\n\nTITLE: Pulling WebAssembly Container Image with CRI-O\nDESCRIPTION: Command to pull a WebAssembly-based container image from Docker Hub using CRI-O's crictl tool. This image contains a simple WASI application example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation\n```\n\n----------------------------------------\n\nTITLE: Starting YoMo CLI Application - Bash\nDESCRIPTION: This snippet shows how to start the YoMo CLI application using a configuration YAML file. The YAML defines the port and workflow handler settings for processing incoming data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyomo serve -c ./zipper/workflow.yaml\n```\n\n----------------------------------------\n\nTITLE: Building and Running Qdrant Example in WasmEdge\nDESCRIPTION: Commands to clone, compile and run the Qdrant client example using WasmEdge runtime. The example connects to a local Qdrant instance on port 6333.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/qdrant_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/qdrant\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Perform vector data operations against a Qdrant at http://localhost:6333\nwasmedge target/wasm32-wasip1/release/qdrant_examples.wasm\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly using Cargo\nDESCRIPTION: This bash command compiles the Rust code into a WebAssembly bytecode application using the standard Rust compiler tools.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd rust_access_memory\ncargo build --target wasm32-wasip1\n# The output WASM will be target/wasm32-wasip1/debug/rust_access_memory_lib.wasm.\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Plugin Tests with CMake\nDESCRIPTION: Commands for building and running tests for a WasmEdge plugin using CMake and CTest\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/best_practice.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd ../../../test/plugins/wasmedge_image\nmkdir build && cd build\ncmake ..\nmake\nctest\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Memory Pages - C\nDESCRIPTION: This snippet allows developers to define and limit the maximum memory page size for WASM execution within the Executor and VM contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/*\n * Limit the memory size of each memory instance with not larger than 1024\n * pages (64 MiB).\n */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Functions with WasmEdge Go SDK\nDESCRIPTION: Complete Go application demonstrating how to define and register host functions that can be called from WebAssembly. The example creates a VM instance and registers a host function that adds two integers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_68\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\n// Host function body definition.\nfunc host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\nfunc main() {\n  // Create the VM object.\n  vm := wasmedge.NewVM()\n\n  // The WASM module buffer.\n  wasmbuf := []byte{\n    /* WASM header */\n    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n    /* Type section */\n    0x01, 0x07, 0x01,\n    /* function type {i32, i32} -> {i32} */\n    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n    /* Import section */\n    0x02, 0x13, 0x01,\n    /* module name: \"extern\" */\n    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n    /* extern name: \"func-add\" */\n    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n    /* import desc: func 0 */\n    0x00, 0x00,\n    /* Function section */\n    0x03, 0x02, 0x01, 0x00,\n    /* Export section */\n    0x07, 0x0A, 0x01,\n    /* export name: \"addTwo\" */\n    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n    /* export desc: func 0 */\n    0x00, 0x01,\n    /* Code section */\n    0x0A, 0x0A, 0x01,\n    /* code body */\n    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,\n  }\n\n  // Create the module instance with the module name \"extern\".\n  impmod := wasmedge.NewModule(\"extern\")\n\n  // Create and add a function instance into the module instance with export name \"func-add\".\n  functype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n    []wasmedge.ValType{wasmedge.ValType_I32},\n  )\n  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n  functype.Release()\n  impmod.AddFunction(\"func-add\", hostfunc)\n\n  // Register the module instance into VM.\n  vm.RegisterImport(impmod)\n\n  res, err := vm.RunWasmBuffer(wasmbuf, \"addTwo\", uint32(1234), uint32(5678))\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n\n  impmod.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Context Management\nDESCRIPTION: Example of creating and managing WasmEdge contexts, specifically showing configure context creation and deletion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Starting containerd service\nDESCRIPTION: Command to start the containerd service after installation and configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start containerd\n```\n\n----------------------------------------\n\nTITLE: Building Rust WASM Container Image\nDESCRIPTION: Docker command to build a Rust application into a WASM container image using buildx\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker buildx build --platform wasi/wasm -t secondstate/rust-example-hello .\n```\n\n----------------------------------------\n\nTITLE: Closing Database Connection (Rust)\nDESCRIPTION: This Rust snippet closes the database connection by dropping the connection object and disconnecting the connection pool.  This ensures resources are released properly after database operations are completed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n    drop(conn);\n    pool.disconnect().await.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker to Use Custom crun Runtime\nDESCRIPTION: JSON configuration for Docker daemon to use the custom-built crun as a runtime. This extends the previous configuration to include the new runtime while maintaining CDI support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"runtimes\": {\n    \"crun\": {\n      \"path\": \"<The crun binary path is built by yourself>\"\n    }\n  },\n  \"features\": {\n    \"cdi\": true\n  },\n  \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with llama.cpp Backend on Windows with CUDA\nDESCRIPTION: This snippet shows how to compile WasmEdge with CUDA support enabled for the llama.cpp backend, using Visual Studio's Developer PowerShell in a Windows environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# CUDA ENABLE:\n& \"C:\\Program files\\CMake\\bin\\cmake.exe\" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON -DWASMEDGE_USE_LLVM=OFF .\n& \"<the ninja-build folder>\\ninja.exe\" -C build\n```\n\n----------------------------------------\n\nTITLE: Updated Synchronous WASM Function Invocation in Go\nDESCRIPTION: Shows the updated Invoke() method of wasmedge.Executor, which no longer requires the wasmedge.Store parameter as the first argument.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.13.0.md#2025-04-21_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n(wasmedge.Executor).Invoke()\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Proposals in C\nDESCRIPTION: This C code defines the `WasmEdge_Proposal` enum, which lists available WebAssembly proposals that can be enabled or disabled. These proposals affect the behavior of the WasmEdge runtime, validator, and compiler. The enum includes proposals like ImportExportMutGlobals, NonTrapFloatToIntConversions, SIMD, and others.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\n```c\nenum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  WasmEdge_Proposal_MultiValue,\n  WasmEdge_Proposal_BulkMemoryOperations,\n  WasmEdge_Proposal_ReferenceTypes,\n  WasmEdge_Proposal_SIMD,\n  WasmEdge_Proposal_TailCall,\n  WasmEdge_Proposal_MultiMemories,\n  WasmEdge_Proposal_Annotations,\n  WasmEdge_Proposal_Memory64,\n  WasmEdge_Proposal_ExceptionHandling,\n  WasmEdge_Proposal_ExtendedConst,\n  WasmEdge_Proposal_Threads,\n  WasmEdge_Proposal_FunctionReferences\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Compiling Go to WebAssembly with TinyGo\nDESCRIPTION: Command to compile a Go source file to WebAssembly using TinyGo with the WASI target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntinygo build -o hello.wasm -target wasi main.go\n```\n\n----------------------------------------\n\nTITLE: Using the Rustls Plug-in with WasmEdge in Bash\nDESCRIPTION: Command showing how to run WasmEdge with the Rustls plug-in, specifying the path to the plug-in and a WebAssembly file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/rusttls.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Function Implementation in C\nDESCRIPTION: C implementation of the Fibonacci function, calculating the nth Fibonacci number iteratively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n// fibonacci.c\n\n#include <stdio.h>\n#include \"fibonacci.h\"\n\nint fib(int n){\n  int f1 = 0;\n  int f2 = 1;\n  if(n<=2){\n    if(n==1) return f1;\n    else return f2;\n  }\n  else\n    for(int i=2; i<n; i++ ){\n      int temp = f2;\n      f2=f1+f2;\n      f1=temp;\n    }\n  return f2;\n}\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration (WasmEdge 0.9.1)\nDESCRIPTION: Example of registering a host module using WasmEdge_ImportObjectContext in version 0.9.1.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n/* Create the import object with the export module name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Add the host functions, tables, memories, and globals into the import object.\n */\n/* The import module context has already contained the export module name. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpObj);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Import object registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge via Curl Script\nDESCRIPTION: Command to download and install WasmEdge version 0.9.1 using a shell script. Requires git and wget as prerequisites.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1\n```\n\n----------------------------------------\n\nTITLE: Moving TensorflowLite Libraries to System Path (MacOS)\nDESCRIPTION: Commands to move the extracted TensorflowLite libraries to the system library path on MacOS platforms, making them available to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflowlite_c.dylib /usr/local/lib\nmv libtensorflowlite_flex.dylib /usr/local/lib\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with Process Plugin Support using CMake\nDESCRIPTION: Commands to build WasmEdge from source with the WasmEdge-Process plugin enabled using the CMake option '-DWASMEDGE_PLUGIN_PROCESS=On'. After building, the installation step places the executable and plugin in the appropriate system directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/process.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On\ncmake --build build\n# For the WasmEdge-Process plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Creating SQL File for Decrypt UDF\nDESCRIPTION: Bash script to create a SQL file for the 'decrypt' UDF, similar to the encrypt UDF creation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/libsql.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport FUNC_NAME='decrypt'\necho \"DROP FUNCTION IF EXISTS ${FUNC_NAME};\" >> create_${FUNC_NAME}_udf.sql\necho -n \"CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'\" >> create_${FUNC_NAME}_udf.sql\nxxd -p  ../../target/wasm32-wasip1/release/libsql_encrypt_decrypt.wasm | tr -d \"\\n\" >> create_${FUNC_NAME}_udf.sql\necho \"';\" >> create_${FUNC_NAME}_udf.sql\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Examples on Android\nDESCRIPTION: Terminal session showing how to run various WasmEdge examples on an Android device. This demonstrates executing WebAssembly modules with different options and parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/build.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /data/local/tmp/wasmedge/examples\n$ ../wasmedge hello.wasm 1 2 3\nhello\n1\n2\n3\n\n$ ../wasmedge --reactor add.wasm add 2 2\n4\n\n$ ../wasmedge --reactor fibonacci.wasm fib 8\n34\n\n$ ../wasmedge --reactor factorial.wasm fac 12\n479001600\n\n$ cd js\n$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3\nHello 1 2 3\n```\n\n----------------------------------------\n\nTITLE: Running Llama 2 Inference with Docker, WasmEdge, and GPU\nDESCRIPTION: Docker command to run a Llama 2 inference in a WebAssembly container with GPU access. This complex command mounts the necessary libraries and model file, sets environment variables, and uses the custom crun runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \\\n  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \\\n  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \\\n  -v .:/resource \\\n  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \\\n  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \\\n  --env n_gpu_layers=100 \\\n  --rm --device nvidia.com/gpu=all --runtime=crun --annotation=module.wasm.image/variant=compat-smart --platform wasip1/wasm \\\n  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \\\n  $'[INST] <<SYS>>\\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\\n<</SYS>>\\nWhat is the capital of Japan?[/INST]'\n```\n\n----------------------------------------\n\nTITLE: Installing PyTorch Dependencies on Ubuntu 20.04\nDESCRIPTION: Commands to download and extract PyTorch libraries for the WASI-NN PyTorch backend on Ubuntu 20.04.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport PYTORCH_VERSION=\"1.8.2\"\ncurl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\nunzip -q \"libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nrm -f \"libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nexport LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}\nexport Torch_DIR=$(pwd)/libtorch\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Bash\nDESCRIPTION: This command uses curl to download and execute an installation script from the WasmEdge GitHub repository. The script installs WasmEdge version 0.12.1. Requires `curl`, `git` and `wget` to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.12.1\"\n```\n\n----------------------------------------\n\nTITLE: Installing wasmedge-bindgen in Go\nDESCRIPTION: Command to install the wasmedge-bindgen tool using Go get. This tool helps handle complex data passing between Rust and Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/wasm-app-in-rust.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/wasmedge-bindgen@v0.4.1\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN Whisper Backend\nDESCRIPTION: This snippet provides the steps to build WasmEdge from source using the Whisper backend, specifying the required CMake flags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"Whisper\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Building libSQL with WasmEdge Support\nDESCRIPTION: Commands to clone and build libSQL from source with WasmEdge runtime support enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/libsql/libsql\ncd libsql\n./configure --enable-wasm-runtime-wasmedge\nmake\n```\n\n----------------------------------------\n\nTITLE: Building OpenSSL 1.1 from Source for Legacy Systems\nDESCRIPTION: Steps to download, compile, and install OpenSSL 1.1 from source for legacy systems like CentOS 7.6 or when a custom build is required. Includes downloading a newer Perl version as a prerequisite.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Download and extract the OpenSSL source to the current directory.\ncurl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz\necho \"40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz\" | sha256sum -c\ntar -xf openssl-1.1.1n.tar.gz\ncd ./openssl-1.1.1n\n# OpenSSL configure need newer perl.\ncurl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz\ntar -xf perl-5.34.0.tar.gz\ncd perl-5.34.0\nmkdir localperl\n./Configure -des -Dprefix=$(pwd)/localperl/\nmake -j\nmake install\nexport PATH=\"$(pwd)/localperl/bin/:$PATH\"\ncd ..\n# Configure by previous perl.\nmkdir openssl\n./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl\nmake -j\nmake test\nmake install\ncd ..\n# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.\n# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.\n```\n\n----------------------------------------\n\nTITLE: Creating Encrypt UDF SQL Script\nDESCRIPTION: Bash commands to generate SQL script for creating the encrypt function in libSQL.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport FUNC_NAME='encrypt'\necho \"DROP FUNCTION IF EXISTS ${FUNC_NAME};\" >> create_${FUNC_NAME}_udf.sql\necho -n \"CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'\" >> create_${FUNC_NAME}_udf.sql\nxxd -p  ../../target/wasm32-wasip1/release/libsql_encrypt_decrypt.wasm | tr -d \"\\n\" >> create_${FUNC_NAME}_udf.sql\necho \"';\" >> create_${FUNC_NAME}_udf.sql\n```\n\n----------------------------------------\n\nTITLE: Compiling a C Plugin into a Shared Library with GCC\nDESCRIPTION: Command example for compiling a C plugin into a shared library (.so) using GCC with position-independent code flag. This is a basic compilation step required for creating a WasmEdge plugin in C.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/best_practice.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngcc -shared -fPIC -o my_plugin.so my_plugin.c\n```\n\n----------------------------------------\n\nTITLE: Using Value Types with Function and Table Types in WasmEdge-Go v0.13.5\nDESCRIPTION: Demonstrates how to create function types and table types using constant value types and reference types in WasmEdge-Go version 0.13.5. It shows the creation of a function type with parameters and return values, and a table type with a reference type.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i64, funcref} -> {f32}\nfunctype := wasmedge.NewFunctionType(\n    []wasmedge.ValType{\n        wasmedge.ValType_I32,\n        wasmedge.ValType_I64,\n        wasmedge.ValType_FuncRef,\n    },\n    []wasmedge.ValType{\n        wasmedge.ValType_F32,\n    })\n\n// Get the parameter types\nvar ptypes []wasmedge.ValType = functype.GetParameters()\nif ptypes[0] == wasmedge.ValType_I32 {\n    // This will be true here.\n    // ...\n} \nfunctype.Release()\n\n// Create a table type: {min: 1}, externref\nlim := wasmedge.NewLimit(1)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\n// Get the reference type\nif tabtype.GetRefType() == wasmedge.RefType_ExternRef {\n    // This will be true here.\n    // ...\n}\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Enabling WebAssembly Proposals in Go\nDESCRIPTION: This snippet defines constants for various WebAssembly proposals and modifies the configuration object to enable or disable them. The `Configure` object is essential for managing these proposals effectively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)\n  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)\n  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)\n  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)\n  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)\n  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)\n  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)\n  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)\n  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)\n  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)\n  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)\n  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)\n  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)\n)\n\n// By default, the following proposals have turned on initially:\n// * IMPORT_EXPORT_MUT_GLOBALS\n// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS\n// * SIGN_EXTENSION_OPERATORS\n// * MULTI_VALUE\n// * BULK_MEMORY_OPERATIONS\n// * REFERENCE_TYPES\n// * SIMD\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)\nconf.AddConfig(wasmedge.SIMD)\nconf.RemoveConfig(wasmedge.REFERENCE_TYPES)\nis_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)\n// The `is_bulkmem` will be `true`.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Generating Rust Plug-in Code with witc\nDESCRIPTION: Command to use the witc tool for generating Rust plug-in code from a WIT file named wasmedge_opencvmini.wit.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nwitc plugin wasmedge_opencvmini.wit\n```\n\n----------------------------------------\n\nTITLE: Deploy Grayscale Microservice with Dapr\nDESCRIPTION: This command deploys the grayscale microservice using Dapr. It specifies the application ID, protocol, ports, components path, log level, and the WasmEdge runtime to execute the WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndapr run --app-id image-api-grayscale \\\n        --app-protocol http \\\n        --app-port 9005 \\\n        --dapr-http-port 3503 \\\n        --components-path ../config \\\n        --log-level debug \\\n wasmedge image-api-grayscale.wasm\n```\n\n----------------------------------------\n\nTITLE: Using Docker for seL4 Build Environment\nDESCRIPTION: Commands to pull and run a Docker container with the necessary build environment for the seL4 system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/sel4_build\n$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build\n(docker) root#\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Plugin Tests\nDESCRIPTION: Shell commands for building and executing the plugin tests using CMake and CTest.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/test_plugin.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd buildtest_plugin.md\ncmake ..\nmake\nctest\n```\n\n----------------------------------------\n\nTITLE: Checking Connected Android Devices\nDESCRIPTION: Command to list all Android devices connected to the computer via ADB. This helps verify that the Android device is properly connected before pushing files to it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/build.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ adb devices\nList of devices attached\n0a388e93      device\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for WASI-NN Plugin on Windows\nDESCRIPTION: This snippet illustrates how to set environment variables necessary for executing the WASI-NN plugin using PowerShell on Windows.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$env:PATH += \";$pwd\\build\\lib\\api\"\n$env:WASMEDGE_PLUGIN_PATH = \"$pwd\\build\\plugins\"\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge QuickJS Repository\nDESCRIPTION: Commands to clone the wasmedge-quickjs repository and change into its directory\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n```\n\n----------------------------------------\n\nTITLE: Setting up RISCV-Lab Environment\nDESCRIPTION: Commands to clone and start the RISCV-Lab environment which provides Ubuntu 22.04 with riscv64 architecture.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/riscv64.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/tinylab/cloud-lab.git\ncd cloud-lab\nLOGIN=bash tools/docker/run riscv-lab\n```\n\n----------------------------------------\n\nTITLE: Addition Function in C for WebAssembly\nDESCRIPTION: A C program that takes two command-line arguments, converts them to integers, adds them, and prints the result. This demonstrates handling command-line inputs in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n// add.c\n\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char *argv[])\n{\n  int a,b;\n  if(argc==3){\n    a = atoi(argv[1]);\n    b = atoi(argv[2]);\n    printf(\"%d\\n\",a+b);\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP GET Request Using Hyper\nDESCRIPTION: Example of making an HTTP GET request using the hyper library in Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nasync fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {\n    let client = Client::new();\n    let mut res = client.get(url).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!(\"{}\", String::from_utf8_lossy(&resp_data));\n```\n\n----------------------------------------\n\nTITLE: Compiling and running a Rust add function with AOT\nDESCRIPTION: This command compiles the add function to its AOT version for improved performance and executes it in reactor mode with WasmEdge, passing in the parameters 2 and 2, expecting the output to be 4.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile add.wasm add_aot.wasm\n\n$ wasmedge --reactor add_aot.wasm add 2 2\n4\n```\n\n----------------------------------------\n\nTITLE: Installing SVG URL Loader\nDESCRIPTION: Command to install the svg-url-loader package as a development dependency.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nnpm install svg-url-loader --save-dev\n```\n\n----------------------------------------\n\nTITLE: Installing crun Dependencies on Ubuntu\nDESCRIPTION: Command to install the necessary dependencies for building crun from source on Ubuntu 20.04.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y make git gcc build-essential pkgconf libtool \\\n    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n    go-md2man libtool autoconf python3 automake\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge using curl\nDESCRIPTION: This command uses curl to download and execute an installation script for WasmEdge. The script installs WasmEdge version 0.10.1. Requires `git` and `wget`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.1\n```\n\n----------------------------------------\n\nTITLE: Checking Pod Status in Kubernetes\nDESCRIPTION: Command to check the status of pods in the Kubernetes cluster using crictl, which shows events from scheduling to running the WebAssembly workload.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncrictl ps -a\n```\n\n----------------------------------------\n\nTITLE: Building and Installing crun with WasmEdge Support\nDESCRIPTION: The snippet provides the steps to clone the crun repository, configure it with WasmEdge support, build it, and install the crun binary. This customization is necessary for running WasmEdge workloads.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow-Lite Libraries\nDESCRIPTION: Commands to download and extract TensorFlow-Lite libraries for Ubuntu 20.04 and manylinux2014. This installs the necessary libtensorflowlite_c.so and libtensorflowlite_flex.so libraries.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\ntar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nrm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Loading Plugins in VM Context (Post-0.12.0)\nDESCRIPTION: Example of loading plugins in a VM context after version 0.12.0. Plugins are automatically loaded, and only WASI configuration is needed explicitly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring Rollup for Server Deployment with JavaScript\nDESCRIPTION: This snippet sets up a Rollup configuration file to transpile server-side JavaScript code using Babel and various plugins. It specifies the entry point, output file, external dependencies, and plugins for processing JavaScript, CSS, and SVG files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst { babel } = require('@rollup/plugin-babel');\nconst nodeResolve = require('@rollup/plugin-node-resolve');\nconst commonjs = require('@rollup/plugin-commonjs');\nconst replace = require('@rollup/plugin-replace');\n\nconst globals = require('rollup-plugin-node-globals');\nconst builtins = require('rollup-plugin-node-builtins');\nconst plugin_async = require('rollup-plugin-async');\nconst css = require('rollup-plugin-import-css');\nconst svg = require('rollup-plugin-svg');\n\nconst babelOptions = {\n  babelrc: false,\n  presets: ['@babel/preset-react'],\n  babelHelpers: 'bundled',\n};\n\nmodule.exports = [\n  {\n    input: './server/index.js',\n    output: {\n      file: 'server-build/index.js',\n      format: 'esm',\n    },\n    external: ['std', 'wasi_net', 'wasi_http'],\n    plugins: [\n      plugin_async(),\n      babel(babelOptions),\n      nodeResolve({ preferBuiltins: true }),\n      commonjs({ ignoreDynamicRequires: false }),\n      css(),\n      svg({ base64: true }),\n      globals(),\n      builtins(),\n      replace({\n        preventAssignment: true,\n        'process.env.NODE_ENV': JSON.stringify('production'),\n        'process.env.NODE_DEBUG': JSON.stringify(''),\n      }),\n    ],\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Building and Starting the SSR Server\nDESCRIPTION: Commands to build the client-side app, bundle and transpile the server code, and start the WasmEdge server for SSR.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run dev:build-server\nnpm run dev:start-server\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL Development Package on Ubuntu 20.04\nDESCRIPTION: Commands to install the OpenSSL development package on Ubuntu 20.04, which is required for the WASI-Crypto implementation in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y libssl-dev\n```\n\n----------------------------------------\n\nTITLE: Retrieving Global Instance in WasmEdge 0.9.1 C API\nDESCRIPTION: Example of retrieving an exported Global instance from a WASM module using WasmEdge 0.9.1 C API. It demonstrates using the Store context to find the Global instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that a WASM module is instantiated in `VMCxt`, and exports the \"global_i32\". */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\nWasmEdge_String GlobName = WasmEdge_StringCreateByCString(\"global_i32\");\nWasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_StoreFindGlobal(StoreCxt, GlobName);\nWasmEdge_StringDelete(GlobName);\n```\n\n----------------------------------------\n\nTITLE: Managing Table Type Context in C\nDESCRIPTION: Shows how to create and query Table Type context for handling WASM table instances with specific reference types and limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu 20.04\nDESCRIPTION: Commands to install the required dependencies for building WasmEdge on Ubuntu 20.04, including LLVM 12, cmake, and compiler tools.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Tools and libraries\nsudo apt install -y \\\n   software-properties-common \\\n   cmake\n\n# And you will need to install llvm for the AOT runtime\nsudo apt install -y \\\n   llvm-12-dev \\\n   liblld-12-dev\n\n# WasmEdge supports both clang++ and g++ compilers.\n# You can choose one of them to build this project.\n# If you prefer GCC, then:\nsudo apt install -y gcc g++\n# Or if you prefer clang, then:\nsudo apt install -y clang-12\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Multiple Plugins\nDESCRIPTION: Installs WasmEdge Runtime with multiple plugins (wasi_logging and wasi_nn-ggml) to extend its functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_logging wasi_nn-ggml\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Compiler Target - Bash\nDESCRIPTION: Command to add the wasm32-wasip1 compiler target for Rust to generate WebAssembly bytecode\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Working with Export Type Context in WasmEdge\nDESCRIPTION: Example of retrieving export information from an AST Module, including external type, external name, and specific type information. Export Type contexts are used for examining module exports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ASTModuleContext *ASTCxt = ...;\n/*\n * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the\n * result of loading a WASM file.\n */\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\n/*\n * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,\n * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`,\n * `WasmEdge_ExternalType_Tag`, or `WasmEdge_ExternalType_Global`.\n */\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\n/*\n * The `ExtName` should not be destroyed and the string buffer is binded\n * into the `ASTCxt`.\n */\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the\n * `FuncTypeCxt` will be NULL.\n */\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_TagTypeContext *TagTypeCxt =\n    WasmEdge_ExportTypeGetTagType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Tag`, the `TagTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`\n * will be NULL.\n */\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions from Go Using WasmEdge Bindgen\nDESCRIPTION: This code demonstrates how to call various WASM functions annotated with [wasmedge_bindgen] using the bindgen object. It shows examples of passing different data types and handling return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/embed-wasm-apps-go.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n  res, err := bg.Execute(\"create_line\", \"{\\\"x\\\":2.5,\\\"y\\\":7.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", string(res))\n  } else {\n    fmt.Println(\"Run bindgen -- create_line FAILED\", err)\n  }\n\n  res, err = bg.Execute(\"say\", \"bindgen funcs test\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- say:\", string(res))\n  } else {\n    fmt.Println(\"Run bindgen -- say FAILED\")\n  }\n\n  res, err = bg.Execute(\"obfusticate\", \"A quick brown fox jumps over the lazy dog\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- obfusticate:\", string(res))\n  } else {\n    fmt.Println(\"Run bindgen -- obfusticate FAILED\")\n  }\n\n  res, err = bg.Execute(\"lowest_common_multiple\", int32(123), int32(2))\n  if err == nil {\n    num, _ := strconv.ParseInt(string(res), 10, 32)\n    fmt.Println(\"Run bindgen -- lowest_common_multiple:\", num)\n  } else {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple FAILED\")\n  }\n\n  res, err = bg.Execute(\"sha3_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- sha3_digest:\", res)\n  } else {\n    fmt.Println(\"Run bindgen -- sha3_digest FAILED\")\n  }\n\n  res, err = bg.Execute(\"keccak_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- keccak_digest:\", res)\n  } else {\n    fmt.Println(\"Run bindgen -- keccak_digest FAILED\")\n  }\n\n  bg.Release()\n  vm.Release()\n  conf.Release()\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Module with WasmEdge Go SDK\nDESCRIPTION: Demonstrates how to use WasmEdge Go SDK to load, validate, instantiate, and execute a WASM module. It includes setting up configuration, statistics, and using various WasmEdge components like Loader, Validator, and Executor.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_54\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level to debug to print the statistics info.\n  wasmedge.SetLogDebugLevel()\n  // Create the configure object. This is not necessary if developers use the default configuration.\n  conf := wasmedge.NewConfigure()\n  // Turn on the runtime instruction counting and time measuring.\n  conf.SetStatisticsInstructionCounting(true)\n  conf.SetStatisticsTimeMeasuring(true)\n  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.\n  stat := wasmedge.NewStatistics()\n  // Create the store object. The store object is the WASM runtime structure core.\n  store := wasmedge.NewStore()\n\n  var err error\n  var res []interface{}\n  var ast *wasmedge.AST\n  var mod *wasmedge.Module\n\n  // Create the loader object.\n  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\n  loader := wasmedge.NewLoaderWithConfig(conf)\n  // Create the validator object.\n  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.\n  validator := wasmedge.NewValidatorWithConfig(conf)\n  // Create the executor object.\n  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.\n  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\n\n  // Load the WASM file or the compiled-WASM file and convert into the AST module object.\n  ast, err = loader.LoadFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n  // Validate the WASM module.\n  err = validator.Validate(ast)\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n  // Instantiate the WASM module and get the output module instance.\n  mod, err = executor.Instantiate(store, ast)\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  // Try to list the exported functions of the instantiated WASM module.\n  funcnames := mod.ListFunction()\n  for _, fname := range funcnames {\n    fmt.Println(\"Exported function name:\", fname)\n  }\n\n  // Invoke the WASM function.\n  funcinst := mod.FindFunction(\"fib\")\n  if funcinst == nil {\n    fmt.Println(\"Run FAILED: Function name `fib` not found\")\n    return\n  }\n  res, err = executor.Invoke(store, funcinst, int32(30))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[30]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run FAILED:\", err.Error())\n  }\n\n  // Resources deallocations.\n  conf.Release()\n  stat.Release()\n  ast.Release()\n  loader.Release()\n  validator.Release()\n  executor.Release()\n  store.Release()\n  mod.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Memory Instances in WasmEdge\nDESCRIPTION: Shows how to create and manipulate Memory instances, including setting/getting data, checking page size, and growing memory. Memory instances represent linear memory in WebAssembly with a page size of 64KiB.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\n/* Create the memory type with limit. The memory page size is 64KiB. */\nWasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_MemoryTypeCreate(MemLimit);\n/* Create the memory instance with memory type. */\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(MemTypeCxt);\n/* Delete the memory type. */\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\n/* Set the data[0:2] to the memory[4096:4098]. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */\n/*\n * This will get an \"out of bounds memory access\" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\n/* `PageSize` will be 1. */\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n/* Grow the page size of 2, the page size of the memory instance will be 3.\n */\n/*\n * This will get an \"out of bounds memory access\" error because\n * the page size (3 + 3) will reach the memory limit(5):\n *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);\n */\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Defining WebAssembly Functions in Rust\nDESCRIPTION: This Rust code defines several functions using the wasmedge_bindgen macro. It includes operations like creating a line, string manipulation, mathematical calculations, and cryptographic hashing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/function.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse num_integer::lcm;\nuse serde::{Deserialize, Serialize};\nuse sha3::{Digest, Keccak256, Sha3_256};\n#[allow(unused_imports)]\nuse wasmedge_bindgen::*;\nuse wasmedge_bindgen_macro::*;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: f32,\n    y: f32,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Line {\n    points: Vec<Point>,\n    valid: bool,\n    length: f32,\n    desc: String,\n}\n\n#[wasmedge_bindgen]\npub fn create_line(p1: String, p2: String, desc: String) -> String {\n    let point1: Point = serde_json::from_str(&p1).unwrap();\n    let point2: Point = serde_json::from_str(&p2).unwrap();\n    let length = ((point1.x - point2.x) * (point1.x - point2.x)\n        + (point1.y - point2.y) * (point1.y - point2.y))\n        .sqrt();\n\n    let valid = if length == 0.0 { false } else { true };\n\n    let line = Line {\n        points: vec![point1, point2],\n        valid: valid,\n        length: length,\n        desc: desc,\n    };\n\n    return serde_json::to_string(&line).unwrap();\n}\n\n#[wasmedge_bindgen]\npub fn say(s: String) -> String {\n    let r = String::from(\"hello \");\n    return r + &s;\n}\n\n#[wasmedge_bindgen]\npub fn obfusticate(s: String) -> String {\n    (&s).chars()\n        .map(|c| match c {\n            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,\n            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,\n            _ => c,\n        })\n        .collect()\n}\n\n#[wasmedge_bindgen]\npub fn lowest_common_multiple(a: i32, b: i32) -> i32 {\n    let r = lcm(a, b);\n    return r;\n}\n\n#[wasmedge_bindgen]\npub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {\n    return Sha3_256::digest(&v).as_slice().to_vec();\n}\n\n#[wasmedge_bindgen]\npub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {\n    return Keccak256::digest(&s).as_slice().to_vec();\n}\n```\n\n----------------------------------------\n\nTITLE: Building crun with WasmEdge Support\nDESCRIPTION: Commands to build crun with WasmEdge support and verify the installation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake\n\n> git clone https://github.com/containers/crun\n> cd crun\n> ./autogen.sh\n> ./configure --with-wasmedge\n> make\n\n# Check your crun\n> ./crun --version\n```\n\n----------------------------------------\n\nTITLE: Configuring rollup.js for React SSR in WasmEdge\nDESCRIPTION: This snippet defines the rollup.js configuration for transpiling and bundling the server-side React application. It includes various plugins for handling React, CSS, SVG, and environment variables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nconst { babel } = require('@rollup/plugin-babel');\nconst nodeResolve = require('@rollup/plugin-node-resolve');\nconst commonjs = require('@rollup/plugin-commonjs');\nconst replace = require('@rollup/plugin-replace');\n\nconst globals = require('rollup-plugin-node-globals');\nconst builtins = require('rollup-plugin-node-builtins');\nconst plugin_async = require('rollup-plugin-async');\nconst css = require('rollup-plugin-import-css');\nconst svg = require('rollup-plugin-svg');\n\nconst babelOptions = {\n  babelrc: false,\n  presets: ['@babel/preset-react'],\n  babelHelpers: 'bundled',\n};\n\nmodule.exports = [\n  {\n    input: './server/index.js',\n    output: {\n      file: 'server-build/index.js',\n      format: 'esm',\n    },\n    external: ['std', 'wasi_net', 'wasi_http'],\n    plugins: [\n      plugin_async(),\n      babel(babelOptions),\n      nodeResolve({ preferBuiltins: true }),\n      commonjs({ ignoreDynamicRequires: false }),\n      css(),\n      svg({ base64: true }),\n      globals(),\n      builtins(),\n      replace({\n        preventAssignment: true,\n        'process.env.NODE_ENV': JSON.stringify('production'),\n        'process.env.NODE_DEBUG': JSON.stringify(''),\n      }),\n    ],\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Deploying OpenYurt Components Using yurtctl\nDESCRIPTION: This command uses yurtctl to convert a Kubernetes cluster to OpenYurt, deploying necessary components including tunnel server and agent. The image versions are specified for each component.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\\\n--yurt-controller-manager-image=\"openyurt/yurt-controller-manager:v0.5.0\"\\\n--yurt-tunnel-agent-image=\"openyurt/yurt-tunnel-agent:v0.5.0\"\\\n--yurt-tunnel-server-image=\"openyurt/yurt-tunnel-server:v0.5.0\"\\\n--node-servant-image=\"openyurt/node-servant:latest\"\\\n--yurthub-image=\"openyurt/yurthub:v0.5.0\"\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Programming Language\nDESCRIPTION: Command to install Rust programming language and toolchain using rustup installer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Setting Android NDK Environment Variable\nDESCRIPTION: Command to set the ANDROID_NDK_HOME environment variable to the path of your Android NDK installation. This is required for the build script to locate the Android NDK toolchain.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/build.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport ANDROID_NDK_HOME=path/to/you/ndk/dir\n```\n\n----------------------------------------\n\nTITLE: Running ES6 Modules in WasmEdge QuickJS\nDESCRIPTION: Command to execute the ES6 module demo in WasmEdge QuickJS runtime. The command specifies directory access permissions and runs the demo.js file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/es6.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js\nhello from module_def.js\nhello from module_def_async.js\n./module_def_async.js `something` is  async thing\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge_Limit Struct in C\nDESCRIPTION: Defines the WasmEdge_Limit struct used for representing WASM limits. It includes fields for minimum and maximum values, as well as flags for maximum value presence and shared memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version via Command Line\nDESCRIPTION: Command to verify the installed Go version is >= 1.15 which is required for WasmEdge-Go\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Building the Rustls Plug-in with Cargo in Bash\nDESCRIPTION: Command to build the Rustls plug-in in release mode using Cargo, Rust's package manager and build system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/rusttls.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --release\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Daemon for CDI Support in JSON\nDESCRIPTION: Docker daemon configuration file that enables Container Device Interface (CDI) support and specifies the directories where CDI specification files are located.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"features\": {\n     \"cdi\": true\n  },\n  \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Go SDK Example\nDESCRIPTION: These bash commands demonstrate how to build the Go SDK example and run the WebAssembly plugin compiled from Rust.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/passing_data.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\ngo build run.go\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ ./run rust_access_memory_lib.wasm\nfib_array() returned: 34\nfib_array memory at: 0x102d80\nfibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]\nfib_array_return_memory memory at: 0x105430\nfibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]\n```\n\n----------------------------------------\n\nTITLE: Installing CRI-O on KubeEdge Master Node\nDESCRIPTION: Sets up required modules, sysctl parameters, and installs CRI-O 1.21 on Ubuntu 20.04 for the KubeEdge master node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Create the .conf file to load the modules at bootup\ncat <<EOF | sudo tee /etc/modules-load.d/crio.conf\noverlay\nbr_netfilter\nEOF\n\nsudo modprobe overlay\nsudo modprobe br_netfilter\n\n# Set up required sysctl params; these persist across reboots.\ncat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf\nnet.bridge.bridge-nf-call-iptables  = 1\nnet.ipv4.ip_forward                 = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nEOF\n\nsudo sysctl --system\nexport OS=\"xUbuntu_20.04\"\nexport VERSION=\"1.21\"\ncat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\ndeb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\nEOF\ncat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list\ndeb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /\nEOF\n\ncurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -\ncurl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -\n\nsudo apt-get update\nsudo apt-get install cri-o cri-o-runc\n\nsudo systemctl daemon-reload\nsudo systemctl enable crio --now\nsudo systemctl status cri-o\n```\n\n----------------------------------------\n\nTITLE: Creating a Kubernetes Cluster with Kubeadm\nDESCRIPTION: This snippet provides the commands needed to install kubeadm and create a Kubernetes cluster. Essentials such as kubelet and kubectl are included, alongside initial configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# install kubeadm\n$ sudo apt-get update\n$ sudo apt-get install -y apt-transport-https ca-certificates curl\n$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg\n$ echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list\n$ sudo apt-get update\n$ sudo apt-get install -y kubelet kubeadm kubectl\n$ sudo apt-mark hold kubelet kubeadm kubectl\n\n# create kubernetes cluster\n$ swapoff -a\n$ kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket unix:///var/run/containerd/containerd.sock\n$ export KUBECONFIG=/etc/kubernetes/admin.conf\n\n# install cni\n$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml\n\n# untaint master node\n$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-\n\n# add crun runtimeClass\n$ cat > runtime.yaml <<EOF\napiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: crun\nhandler: crun\nEOF\n$ kubectl apply -f runtime.yaml\n\n# Verify if the configuration works\n$ kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true, \"runtimeClassName\": \"crun\"}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Running an HTTP server WASM application\nDESCRIPTION: Commands to download and run a WASM-based HTTP server application using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/second-state/rust-examples/releases/latest/download/server.wasm\n$ wasmedge server.wasm\nListening on http://0.0.0.0:8080\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with PyTorch Backend\nDESCRIPTION: Commands to build WasmEdge from source with the PyTorch backend for WASI-NN. This requires the PyTorch dependency to be installed first.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"PyTorch\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Binary with Raw Buffer in C (0.13.5)\nDESCRIPTION: Example of loading a WASM binary using a raw buffer in WasmEdge 0.13.5. This method is still supported but not recommended in 0.14.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nuint8_t WASM[] = {/* WASM header */\n                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                  /* Type section */\n                  0x01, 0x07, 0x01,\n                  /* function type {i32, i32} -> {i32} */\n                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                  /* Import section */\n                  0x02, 0x13, 0x01,\n                  /* module name: \"extern\" */\n                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                  /* extern name: \"func-add\" */\n                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                  /* import desc: func 0 */\n                  0x00, 0x00,\n                  /* Function section */\n                  0x03, 0x02, 0x01, 0x00,\n                  /* Export section */\n                  0x07, 0x0A, 0x01,\n                  /* export name: \"addTwo\" */\n                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                  /* export desc: func 0 */\n                  0x00, 0x01,\n                  /* Code section */\n                  0x0A, 0x0A, 0x01,\n                  /* code body */\n                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, WASM, sizeof(WASM));\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\n```\n\n----------------------------------------\n\nTITLE: WASM Module with Host Function Import\nDESCRIPTION: WebAssembly module definition that imports and calls an external host function for addition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_64\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import \"extern\" \"func-add\" (func $f-add (type $t0)))\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add))\n```\n\n----------------------------------------\n\nTITLE: Installing OpenBLAS on Ubuntu/Debian\nDESCRIPTION: This snippet provides the commands to install OpenBLAS and its dependencies on an Ubuntu/Debian system before building the plugin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\n# You may need to install dependencies\napt update\napt install -y software-properties-common lsb-release \\\n  cmake unzip pkg-config\n# You must install OpenBLAS\napt install libopenblas-dev\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=ON \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Executing WasmEdge Installer Script with Bash\nDESCRIPTION: This command downloads and executes the WasmEdge installer script, allowing for custom installation options. It uses curl to fetch the script and pipes it to bash for execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/installer.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- ${OPTIONS}\n```\n\n----------------------------------------\n\nTITLE: Executing WasmEdge Installer V2 Script via curl\nDESCRIPTION: This command downloads and executes the WasmEdge installer V2 script. It uses curl to fetch the script from the WasmEdge GitHub repository and pipes it to bash for execution. The ${OPTIONS} placeholder allows for customization of the installation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/installer_v2.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install_v2.sh | bash -s -- ${OPTIONS}\n```\n\n----------------------------------------\n\nTITLE: Testing the HTTP Server with curl\nDESCRIPTION: Demonstrates how to test the running HTTP server using curl commands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/\ncurl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\n```\n\n----------------------------------------\n\nTITLE: Granting File System Access to WASI - Rust\nDESCRIPTION: This command mounts the current working directory to the WASI virtual file system, allowing the WASI program to read and write files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. ./target/wasm32-wasip1/release/rustpython.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory Structure\nDESCRIPTION: Shell commands to create the basic directory structure for a WasmEdge plugin project\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir testplugin\ncd testplugin\nmkdir src include build\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Path\nDESCRIPTION: Method to load WasmEdge plugins from either default paths or a specified path. Default paths include environment variables and installation-relative directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn load(path: Option<&Path>) -> WasmEdgeResult<()>\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Project to WASM - Bash\nDESCRIPTION: This bash command compiles the Rust project to a WebAssembly module using the `wasm32-wasip1` target. The `--release` flag optimizes the compiled module for production environments.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo build --target wasm32-wasip1 --release\"\n```\n\n----------------------------------------\n\nTITLE: Installing GGML Plugin for WasmEdge\nDESCRIPTION: Commands to download and install the GGML plugin for WasmEdge and verify its dependencies.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml\n\n# Make sure all your plugin dependencies is good\n> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so\n```\n\n----------------------------------------\n\nTITLE: WASM Module Registration - Pre v0.10.0\nDESCRIPTION: Shows how to register a WASM module with a module name using RegisterModule() API in version 0.9.2.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST\nerr := executor.RegisterModule(store, ast, \"mod\")\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Containerd Service\nDESCRIPTION: Command to start the Containerd service after configuration. This ensures the new configuration with WasmEdge support takes effect.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsystemctl start containerd\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge-TensorFlow-Tools\nDESCRIPTION: Commands to download and extract WasmEdge-TensorFlow-Tools pre-release packages for Android arm64.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/cli.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.12.1/WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz\n$ mkdir WasmEdge-tensorflow-tools && tar zxvf WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools\nshow-tflite-tensor\nwasmedge-tensorflow-lite\n```\n\n----------------------------------------\n\nTITLE: Rust Image Classification Function Implementation\nDESCRIPTION: Implementation of the image classification function in Rust using WasmEdge Tensorflow API to process input images and return classification results\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasmedge_bindgen]\npub fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {\n  let start = Instant::now();\n\n  // Load the TFLite model and its metadata (the text label for each recognized object number)\n  let model_data: &[u8] = include_bytes!(\"lite-model_aiy_vision_classifier_food_V1_1.tflite\");\n  let labels = include_str!(\"aiy_food_V1_labelmap.txt\");\n\n  // Pre-process the image to a format that this model can use\n  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&image_data[..], 192, 192);\n  println!(\"RUST: Loaded image in ... {:?}\", start.elapsed());\n\n  // Run the TFLite model using the WasmEdge Tensorflow API\n  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);\n  session.add_input(\"input\", &flat_img, &[1, 192, 192, 3])\n         .run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Softmax\");\n\n  // Find the object index in res_vec that has the greatest probability\n  // Translate the probability into a confidence level\n  // Translate the object index into a label from the model metadata food_name\n  let mut i = 0;\n  let mut max_index: i32 = -1;\n  let mut max_value: u8 = 0;\n  while i < res_vec.len() {\n    let cur = res_vec[i];\n    if cur > max_value {\n      max_value = cur;\n      max_index = i as i32;\n    }\n    i += 1;\n  }\n  println!(\"RUST: index {}, prob {}\", max_index, max_value);\n\n  let confidence: String;\n  if max_value > 200 {\n    confidence = \"is very likely\".to_string();\n  } else if max_value > 125 {\n    confidence = \"is likely\".to_string();\n  } else {\n    confidence = \"could be\".to_string();\n  }\n\n  let ret_str: String;\n  if max_value > 50 {\n    let mut label_lines = labels.lines();\n    for _i in 0..max_index {\n      label_lines.next();\n    }\n    let food_name = label_lines.next().unwrap().to_string();\n    ret_str = format!(\n      \"It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture\",\n      confidence, food_name, food_name\n    );\n  } else {\n    ret_str = \"It does not appears to be a food item in the picture.\".to_string();\n  }\n\n  println!(\n    \"RUST: Finished post-processing in ... {:?}\",\n    start.elapsed()\n  );\n  return Ok(ret_str.as_bytes().to_vec());\n}\n```\n\n----------------------------------------\n\nTITLE: Building youki with WasmEdge Support\nDESCRIPTION: Commands to clone the youki repository, build with WebAssembly support, and configure library paths\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recurse-submodules https://github.com/containers/youki.git\ncd youki\n./scripts/build.sh -o . -r -f wasm-wasmedge\n./youki -h\nexport LD_LIBRARY_PATH=$HOME/.wasmedge/lib\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge eBPF Plugin with CMake\nDESCRIPTION: Commands to build the WasmEdge eBPF plugin using CMake, enabling the WASMEDGE_PLUGIN_WASM_BPF option.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/ebpf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncmake -DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE -B ./build -G \"Unix Makefiles\"\ncmake --build ./build\n```\n\n----------------------------------------\n\nTITLE: Installing libSQL with WasmEdge Support\nDESCRIPTION: Commands to clone the libSQL repository, configure it with WasmEdge support, and build it from source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/libsql.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/libsql/libsql\ncd libsql\n./configure --enable-wasm-runtime-wasmedge\nmake\n```\n\n----------------------------------------\n\nTITLE: Packaging WasmEdge Plugin SDK\nDESCRIPTION: Command for packaging a WasmEdge plugin SDK into a distributable format\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/best_practice.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntar czvf wasmedge_image_rust_sdk.tar.gz libwasmedge_image.so wasmedge_image.h\n```\n\n----------------------------------------\n\nTITLE: SSR Output HTML Structure\nDESCRIPTION: This HTML snippet illustrates the change in the output structure of the server-side rendered web page after enabling SSR functionality. It shows the HTML content that will be sent to the browser, displaying the rendered application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_23\n\nLANGUAGE: html\nCODE:\n```\n<div id=\"root\"><div class=\"App\" data-reactroot=\"\">...</div></div>\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Function Header in C\nDESCRIPTION: Header file for the Fibonacci function, demonstrating the use of separate header and implementation files in a WebAssembly project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n// fibonacci.h\n\nint fib(int n);\n```\n\n----------------------------------------\n\nTITLE: Install etcd\nDESCRIPTION: This snippet installs etcd, a distributed key-value store used by Kubernetes for storing cluster data. It utilizes a helper script from the Kubernetes repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh\n$ export PATH=\"/home/${USER}/kubernetes/third_party/etcd:${PATH}\"\n$ sudo cp third_party/etcd/etcd* /usr/local/bin/\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge via Shell Script\nDESCRIPTION: Script command to install WasmEdge 0.9.1 shared library which is required for WasmEdge-Go\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1\n```\n\n----------------------------------------\n\nTITLE: Testing containerd with crun for WebAssembly\nDESCRIPTION: Commands to restart containerd and test if the crun runtime works correctly with a WebAssembly example image. This verifies the container runtime integration before proceeding with Kubernetes setup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# restart containerd service\n$ sudo systemctl restart containerd\n\n# check if crun works\n$ ctr image pull docker.io/wasmedge/example-wasi:latest\n$ ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Running Golang Handler Function - Go\nDESCRIPTION: This snippet demonstrates how to navigate into the flow directory and run the Golang program with specific tags. This program handles the data processing pipeline for image recognition.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ncd flow\n\n go run --tags \"tensorflow image\" app.go\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge with Winget on Windows\nDESCRIPTION: Removes WasmEdge on Windows systems that were installed using the winget package manager.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nwinget uninstall wasmedge\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: Shows how to set various compiler options for the Ahead-of-Time (AOT) compiler, including optimization levels, output formats, IR dumping, generic binary generation, and interruptible execution support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n/* Set this option to `TRUE` to support the interruptible execution in AOT mode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Error Handling Example WebAssembly Module\nDESCRIPTION: WebAssembly module definition showing error handling implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_65\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param i32)))\n  (import \"extern\" \"trap\" (func $f-trap (type $t0)))\n  (func (export \"trap\") (param i32)\n    local.get 0\n    call $f-trap))\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-QuickJs with WASI NN Support\nDESCRIPTION: The following command uses cargo to build the WasmEdge-QuickJs runtime source with WASI NN support for wasm32-wasip1 target. Requires Rust's Cargo build system installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Build the QuickJS JavaScript interpreter with WASI NN\ncargo build --target wasm32-wasip1 --release --features=wasi_nn\n```\n\n----------------------------------------\n\nTITLE: Loader Implementation Example\nDESCRIPTION: Shows how to use the Loader object to load WASM modules from files or buffers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_41\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: Defining Another Custom Module Function in JavaScript\nDESCRIPTION: This code snippet defines another simple function 'hello_mod_2' in a custom module file 'my_mod_2.js'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/modules.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport function hello_mod_2() {\n  console.log('hello from \"my_mod_2.js\"');\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN MLX Backend\nDESCRIPTION: Commands to build WasmEdge from source with the WASI-NN MLX backend enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"mlx\"\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Booting WasmEdge on seL4\nDESCRIPTION: This code navigates to the build directory and starts the seL4 simulator with WasmEdge integrated.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd sel4_wasmedge/build\n./simulate\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge Host Registrations in Go\nDESCRIPTION: This code snippet demonstrates how to configure WasmEdge host registrations using the `wasmedge.Configure` object in Go. It shows how to add specific host registrations, such as WASI.  The snippet initializes a `Configure` object and adds the `WASI` host registration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_18\n\nLANGUAGE: go\nCODE:\n```\n```go\n   conf := wasmedge.NewConfigure()\n   // Developers can also pass the proposals as parameters:\n   // conf := wasmedge.NewConfigure(wasmedge.WASI)\n   conf.AddConfig(wasmedge.WASI)\n   conf.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration - Post v0.10.0\nDESCRIPTION: Demonstrates host module registration using Module instance in WasmEdge-Go v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nimpmod := wasmedge.NewModule(\"module\")\nerr := executor.RegisterImport(store, impmod)\nif err != nil {\n  fmt.Println(\"Module instance registration FAILED:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL Development Package on Ubuntu 20.04\nDESCRIPTION: Commands to install the OpenSSL 1.1 development package on Ubuntu 20.04, which is required for the WASI-Crypto implementation in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y libssl-dev\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow-Lite Shared Libraries to Local Path\nDESCRIPTION: Moves the downloaded TensorFlow-Lite shared libraries to the appropriate installation directory for WasmEdge to access them. Multiple options are provided for different installation scenarios.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n# If you installed wasmedge locally as above\nmv libtensorflowlite_c.so ~/.wasmedge/lib\nmv libtensorflowlite_flex.so ~/.wasmedge/lib\n\n# Or, if you installed wasmedge for all users in /usr/local/\nmv libtensorflowlite_c.so /usr/local/lib\nmv libtensorflowlite_flex.so /usr/local/lib\n\n# Or on MacOS platforms\nmv libtensorflowlite_c.dylib ~/.wasmedge/lib\nmv libtensorflowlite_flex.dylib ~/.wasmedge/lib\n```\n\n----------------------------------------\n\nTITLE: Add WASI-Crypto Dependency in Rust\nDESCRIPTION: This snippet shows how to add the WASI-crypto binding as a dependency in your Rust project's `Cargo.toml` file. This allows you to use the WASI-crypto API in your Rust code to perform cryptographic operations within a WebAssembly environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasicrypto.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n\"[dependencies]\\nwasi-crypto = \\\"0.1.5\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Running WASM Functions Rapidly with WasmEdge VM Context in C\nDESCRIPTION: This C code demonstrates how to quickly execute a WASM function using the WasmEdge VM context. It loads a Fibonacci WASM module, sets up the VM context, and calls the 'fib' function with an input of 5.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <wasmedge/wasmedge.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(\n      VMCxt, \"fibonacci.wasm\", FuncName, Params, 1, Returns, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMRunWasmFromBytes()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRunWasmFromASTModule()` API.\n   */\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding rollup.js Dependencies to package.json\nDESCRIPTION: This snippet shows the devDependencies section of package.json, listing the required rollup.js plugins and related packages for the React SSR build process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n  \"devDependencies\": {\n    //...\n    \"@rollup/plugin-babel\": \"^5.3.0\",\n    \"@rollup/plugin-commonjs\": \"^21.0.1\",\n    \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n    \"@rollup/plugin-replace\": \"^3.0.0\",\n    \"rollup\": \"^2.60.1\",\n    \"rollup-plugin-async\": \"^1.2.0\",\n    \"rollup-plugin-import-css\": \"^3.0.3\",\n    \"rollup-plugin-node-builtins\": \"^2.1.2\",\n    \"rollup-plugin-node-globals\": \"^1.4.0\",\n    \"rollup-plugin-svg\": \"^2.0.0\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Deploying WebAssembly HTTP Service with kubectl\nDESCRIPTION: Command to apply the Kubernetes YAML configuration file for deploying the WebAssembly-based HTTP service to the Kubernetes cluster.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml\n```\n\n----------------------------------------\n\nTITLE: Preparing OpenWRT Environment by Cloning Repository and Installing Dependencies\nDESCRIPTION: Commands to obtain OpenWRT source code and install the necessary build tools and dependencies on a Debian/Ubuntu system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/openwrt/openwrt\n$ sudo apt update\n$ sudo apt install build-essential ccache ecj fastjar file g++ gawk \\\ngettext git java-propose-classpath libelf-dev libncurses5-dev \\\nlibncursesw5-dev libssl-dev python python2.7-dev python3 unzip wget \\\npython-distutils-extra python3-setuptools python3-dev rsync subversion \\\nswig time xsltproc zlib1g-dev\n```\n\n----------------------------------------\n\nTITLE: Installing Build Dependencies\nDESCRIPTION: Commands to install required dependencies including LLVM 12 and build tools on Ubuntu.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/riscv64.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update\nubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake\nubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge AOT Compiler CLI in Go\nDESCRIPTION: This snippet demonstrates invoking the WasmEdge AOT Compiler CLI tools from a Go application using the WasmEdge Go SDK. It requires appropriate command line arguments mirroring those used in traditional CLI usage.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Using Docker in Bash\nDESCRIPTION: Commands to build WasmEdge using a Docker container, including mounting the source code and running CMake and make commands.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/linux.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# After pulling our wasmedge docker image\ndocker run -it --rm \\\n    -v <path/to/your/wasmedge/source/folder>:/root/wasmedge \\\n    wasmedge/wasmedge:latest\n# In docker\ncd /root/wasmedge\n# If you don't use docker then you need to run only the following commands in the cloned repository root\nmkdir -p build && cd build\ncmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. && make -j\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance for WasmEdge Plug-in\nDESCRIPTION: C function that creates a module instance with the exported host functions. This function registers the 'add' and 'sub' functions to the module named 'wasmedge_plugintest_c_module'.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* The creation function of creating the module instance. */\nWasmEdge_ModuleInstanceContext *\nCreateTestModule(const struct WasmEdge_ModuleDescriptor *Desc) {\n  /*\n   * The `Desc` is the const pointer to the module descriptor struct:\n   *\n   *   typedef struct WasmEdge_ModuleDescriptor {\n   *     const char *Name;\n   *     const char *Description;\n   *     WasmEdge_ModuleInstanceContext *(*Create)(\n   *         const struct WasmEdge_ModuleDescriptor *);\n   *   } WasmEdge_ModuleDescriptor;\n   *\n   * Developers can get the name and description from this descriptor.\n   */\n\n  /* Exported module name of this module instance. */\n  WasmEdge_String ModuleName =\n      WasmEdge_StringCreateByCString(\"wasmedge_plugintest_c_module\");\n  WasmEdge_ModuleInstanceContext *Mod =\n      WasmEdge_ModuleInstanceCreate(ModuleName);\n  WasmEdge_StringDelete(ModuleName);\n\n  WasmEdge_String FuncName;\n  WasmEdge_FunctionTypeContext *FType;\n  WasmEdge_FunctionInstanceContext *FuncCxt;\n  WasmEdge_ValType ParamTypes[2], ReturnTypes[1];\n  ParamTypes[0] = WasmEdge_ValTypeGenI32();\n  ParamTypes[1] = WasmEdge_ValTypeGenI32();\n  ReturnTypes[0] = WasmEdge_ValTypeGenI32();\n\n  /* Create and add the host function instances into the module instance. */\n  FType = WasmEdge_FunctionTypeCreate(ParamTypes, 2, ReturnTypes, 1);\n  FuncName = WasmEdge_StringCreateByCString(\"add\");\n  FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncAdd, NULL, 0);\n  WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);\n  WasmEdge_StringDelete(FuncName);\n  FuncName = WasmEdge_StringCreateByCString(\"sub\");\n  FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncSub, NULL, 0);\n  WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_FunctionTypeDelete(FType);\n\n  return Mod;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Core\nDESCRIPTION: Command to install the WasmEdge shared library matching the WasmEdge-go version 0.12.1.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.12.1\n```\n\n----------------------------------------\n\nTITLE: Handling String Parameters in TinyGo WebAssembly Function\nDESCRIPTION: This TinyGo code defines a function for greeting a subject. It demonstrates how to handle string parameters in WebAssembly, including pointer manipulation and string building.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"strings\"\n  \"unsafe\"\n)\n\nfunc main() {}\n\n//export greet\nfunc greet(subject *int32) *int32 {\n  nth := 0\n  var subjectStr strings.Builder\n  pointer := uintptr(unsafe.Pointer(subject))\n  for {\n    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))\n    if s == 0 {\n      break\n    }\n\n    subjectStr.WriteByte(byte(s))\n    nth++\n  }\n\n  output := []byte(\"Hello, \" + subjectStr.String() + \"!\")\n\n  r := make([]int32, 2)\n  r[0] = int32(uintptr(unsafe.Pointer(&(output[0]))))\n  r[1] = int32(len(output))\n\n  return &r[0]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WasmEdge on macOS using Homebrew\nDESCRIPTION: Commands to install required tools and libraries using Homebrew, and set necessary environment variables for LLVM and compilers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/macos.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install cmake ninja llvm\nexport LLVM_DIR=\"$(brew --prefix)/opt/llvm/lib/cmake\"\nexport CC=clang\nexport CXX=clang++\n```\n\n----------------------------------------\n\nTITLE: Installing containerd on Linux\nDESCRIPTION: Commands to install containerd on a Linux system, including downloading and extracting the containerd package, installing dependencies like libseccomp2, and setting up the service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport VERSION=\"1.5.7\"\necho -e \"Version: $VERSION\"\necho -e \"Installing libseccomp2 ...\"\nsudo apt install -y libseccomp2\necho -e \"Installing wget\"\nsudo apt install -y wget\n\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\nsha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\n\nsudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nsudo systemctl daemon-reload\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm\nDESCRIPTION: This Bash command runs npm to install all the development dependencies listed in the project's package.json file, necessary for running the Rollup build process and handling other project requirements.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow Shared Libraries\nDESCRIPTION: Moving and creating symlinks for TensorFlow shared libraries in local or system-wide installation paths\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib\nmv libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib\nln -s libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib/libtensorflow_cc.so.2\nln -s libtensorflow_cc.so.2 ~/.wasmedge/lib/libtensorflow_cc.so\n```\n\n----------------------------------------\n\nTITLE: Running ES6 Module Example in WasmEdge\nDESCRIPTION: Command to run the ES6 module demo using the WasmEdge QuickJS runtime. The --dir flag is used to set the working directory for file access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/es6.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js\nhello from module_def.js\nhello from module_def_async.js\n./module_def_async.js `something` is  async thing\n```\n\n----------------------------------------\n\nTITLE: Testing Server Connection\nDESCRIPTION: Command to test the HTTP server using curl.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8002\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow Dependencies\nDESCRIPTION: Commands to download and extract TensorFlow dependencies for WasmEdge. This installs the required shared libraries for TensorFlow functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.\n# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.\n# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.\ntar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nrm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version for WasmEdge-go Compatibility\nDESCRIPTION: Verifies the installed Go version to ensure compatibility with WasmEdge-go, which requires version 1.16 or higher.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Running Standalone WASM App in Docker\nDESCRIPTION: This command runs a containerized WASM application using Docker. The app is a simple 'Hello World' example written in Rust, stored as a 500KB image on Docker Hub.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_docker.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-Logging Plug-in Support in Bash\nDESCRIPTION: Command sequence for building WasmEdge from source with WASI-Logging plug-in support enabled using the CMAKE_BUILD_TYPE=Release and WASMEDGE_PLUGIN_WASI_LOGGING=ON options. After building, the commands install the project to make the plug-in available system-wide.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_logging.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\nmkdir -p build && cd build\ncmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j\n# For the WASI-Logging plug-in, you should install this project.\ncmake --install .\n```\n\n----------------------------------------\n\nTITLE: Installing wasmedge-bindgen in Go\nDESCRIPTION: Command to install the wasmedge-bindgen tool using Go get. This tool helps handle complex data passing between Rust and Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/wasm-app-in-rust.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/wasmedge-bindgen@v0.4.1\n```\n\n----------------------------------------\n\nTITLE: Dapr Initialization\nDESCRIPTION: This command initializes Dapr, setting up the necessary components for Dapr to run in your environment. It's a one-time setup step before deploying Dapr-enabled applications.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndapr init\n```\n\n----------------------------------------\n\nTITLE: Running N-Body Simulation WebAssembly Example\nDESCRIPTION: This command executes the nbody-c.wasm WebAssembly example on WasmEdge running on seL4, performing an n-body simulation with 10 iterations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge_emit /usr/bin/nbody-c.wasm 10\n```\n\n----------------------------------------\n\nTITLE: Implementing File Reading in Rust for WebAssembly\nDESCRIPTION: This Rust code implements a file reading application that takes a filename as an argument, reads its contents, and allows the user to print specific lines. It's designed to be compiled to WebAssembly and run in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/app.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs::File;\nuse std::io::{self, BufRead};\n\nfn main() {\n  // Get the argv.\n  let args: Vec<String> = env::args().collect();\n  if args.len() <= 1 {\n    println!(\"Rust: ERROR - No input file name.\");\n    return;\n  }\n\n  // Open the file.\n  println!(\"Rust: Opening input file \\\"{}\\\"...\", args[1]);\n  let file = match File::open(&args[1]) {\n    Err(why) => {\n      println!(\"Rust: ERROR - Open file \\\"{}\\\" failed: {}\", args[1], why);\n      return;\n    },\n    Ok(file) => file,\n  };\n\n  // Read lines.\n  let reader = io::BufReader::new(file);\n  let mut texts:Vec<String> = Vec::new();\n  for line in reader.lines() {\n    if let Ok(text) = line {\n      texts.push(text);\n    }\n  }\n  println!(\"Rust: Read input file \\\"{}\\\" succeeded.\", args[1]);\n\n  // Get stdin to print lines.\n  println!(\"Rust: Please input the line number to print the line of file.\");\n  let stdin = io::stdin();\n  for line in stdin.lock().lines() {\n    let input = line.unwrap();\n    match input.parse::<usize>() {\n      Ok(n) => if n > 0 && n <= texts.len() {\n        println!(\"{}\", texts[n - 1]);\n      } else {\n        println!(\"Rust: ERROR - Line \\\"{}\\\" is out of range.\", n);\n      },\n      Err(e) => println!(\"Rust: ERROR - Input \\\"{}\\\" is not an integer: {}\", input, e),\n    }\n  }\n  println!(\"Rust: Process end.\");\n}\n```\n\n----------------------------------------\n\nTITLE: WASI Initialization with WasmEdge-Go v0.10.0\nDESCRIPTION: Updated example showing WASI initialization using WasmEdge-Go v0.10.0 API, demonstrating the transition from ImportObject to Module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\n\n// The following API can retrieve the pre-registration module instances from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasiobj := vm.GetImportModule(wasmedge.WASI)\n// Initialize the WASI.\nwasiobj.InitWasi(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:.\"}, // The mapping preopens\n)\n\n// ...\n\nvm.Release()\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Dependencies on RISC-V\nDESCRIPTION: Installs the required dependencies for building WasmEdge, including LLVM 12 which is the minimum required version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update\nubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake\nubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev\n```\n\n----------------------------------------\n\nTITLE: Visualizing WasmEdge Plug-in Loading Process\nDESCRIPTION: A mermaid diagram illustrating the relationship between the host application, plug-in shared library, and WasmEdge runtime in the plug-in loading process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    A((Host Application)) -- Loads --> B((Plug-in Shared Library))\n    B -- Registers --> C((Wasmedge Runtime))\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with llama.cpp Backend on Windows without CUDA\nDESCRIPTION: This snippet demonstrates how to compile WasmEdge without CUDA support for the llama.cpp backend, using commands suitable for a Windows environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# CUDA DISABLE:\n& \"C:\\Program files\\CMake\\bin\\cmake.exe\" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_USE_LLVM=OFF .\n& \"<the ninja-build folder>\\ninja.exe\" -C build\n```\n\n----------------------------------------\n\nTITLE: Working with WASM Memory Types in Go\nDESCRIPTION: Shows how to create and manage memory type contexts for WebAssembly memory instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(1)\nmemtype := wasmedge.NewMemoryType(lim)\n\ngetlim := memtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\nmemtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Version APIs\nDESCRIPTION: Example of using WasmEdge version-related APIs to check the installed library version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge on OpenWRT\nDESCRIPTION: Commands to test WasmEdge functionality by running WebAssembly modules on OpenWRT.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge hello.wasm second state\nhello\nsecond\nstate\n$ wasmedge --reactor add.wasm add 2 2\n4\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-go with Image Extension\nDESCRIPTION: Shows the command to build WasmEdge-go with the Image extension enabled using build tags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/intro.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image\n```\n\n----------------------------------------\n\nTITLE: Downloading eBPF Example Programs\nDESCRIPTION: Command to download pre-built example wasm-bpf programs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwget https://eunomia-bpf.github.io/wasm-bpf/examples/runqlat/runqlat.wasm\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge_Process Pre-registration\nDESCRIPTION: Shows how to enable the process interface for WasmEdge (used in Rust sources) by configuring the VM with WasmEdge_Process host registration, retrieving the pre-registered import object, and initializing it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration import objects from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ImportObjectContext *ProcObject =\n  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);\n/* Initialize the WasmEdge_Process. */\nWasmEdge_ImportObjectInitWasmEdgeProcess(ProcObject, /* ... ignored */ );\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Signing Git Commits with DCO\nDESCRIPTION: Instructions for signing commits using the Developer Certificate of Origin (DCO). This includes manual signing and using Git's -s option for automatic signing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/contribute.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -s -m 'This is my commit message'\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit commit --amend -s\n```\n\n----------------------------------------\n\nTITLE: Adding npm Scripts for Building and Serving React SSR\nDESCRIPTION: This snippet shows the scripts section in package.json, defining commands for building the server bundle with rollup.js and starting the WasmEdge server with the built output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n\"scripts\": {\n  \"dev:build-server\": \"rollup -c rollup.config.js\",\n  \"dev:start-server\": \"wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js\",\n  // ...\n},\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with TensorflowLite Plugin Support\nDESCRIPTION: Commands to build WasmEdge from source with TensorflowLite plugin support enabled. The process includes configuring with CMake using the WASMEDGE_PLUGIN_TENSORFLOWLITE option, building, and installing the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On\ncmake --build build\n# For the WasmEdge-TensorflowLite plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust to WebAssembly for WasmEdge\nDESCRIPTION: These bash commands clone the example repository, navigate to the Rust project directory, and compile the Rust code to WebAssembly targeting the wasm32-wasip1 platform.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/app.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-go-examples.git\ncd rust_readfile\ncargo build --target wasm32-wasip1\n# The output file will be target/wasm32-wasip1/debug/rust_readfile.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Extensions\nDESCRIPTION: Installation command for WasmEdge with TensorFlow and Image extensions enabled\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.1\n```\n\n----------------------------------------\n\nTITLE: Creating Async ES6 Module Exports\nDESCRIPTION: An ES6 module that exports both an async function and a variable. This demonstrates how to create and export asynchronous functionality in ES6 modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/es6.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport async function hello() {\n  console.log('hello from module_def_async.js');\n  return 'module_def_async.js : return value';\n}\n\nexport var something = 'async thing';\n```\n\n----------------------------------------\n\nTITLE: Installing GCC Dependencies\nDESCRIPTION: Commands to install GCC and build essential packages needed for building WasmEdge QuickJS\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Install GCC\nsudo apt update\nsudo apt install build-essential\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge-Go Package\nDESCRIPTION: Retrieves the WasmEdge-Go package and builds it in the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\ngo build\n```\n\n----------------------------------------\n\nTITLE: Defining WasmEdge Host Registrations in Go\nDESCRIPTION: This code snippet defines constants for WasmEdge host registrations in Go. These constants are used to enable host function pre-registrations such as WASI and wasmedge_process for the VM. The constants are defined using the `HostRegistration` type and corresponding C definitions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_17\n\nLANGUAGE: go\nCODE:\n```\n```go\n   const (\n     WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n     WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)\n   )\n   ```\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Context using Bash\nDESCRIPTION: This snippet sets up the Kubernetes context for the local cluster to allow subsequent commands to interact with the running cluster. It requires the Kubernetes CLI and assumes a running Kubernetes instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport KUBERNETES_PROVIDER=local\n\nsudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\nsudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\nsudo cluster/kubectl.sh config set-context local --cluster=local --user=myself\nsudo cluster/kubectl.sh config use-context local\nsudo cluster/kubectl.sh\n```\n\n----------------------------------------\n\nTITLE: Executing WASM program for bird classification on Android\nDESCRIPTION: Command to use wasmedge-tensorflow-lite to run the compiled WASM program, which performs bird classification on the provided image.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\nINFO: Initialized TensorFlow Lite runtime.\n166 : 0.84705883\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in WasmEdge\nDESCRIPTION: Shows how to configure statistics collection options for WasmEdge execution, including instruction counting, cost measuring, and time measuring. These settings enable performance monitoring during WebAssembly execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the instruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-NN llama.cpp Backend on NVIDIA Jetson AGX Orin\nDESCRIPTION: CMake commands to build WasmEdge with the WASI-NN llama.cpp backend on NVIDIA Jetson AGX Orin.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\nexport CXXFLAGS=\"-Wno-error\"\nexport CUDAARCHS=72\n\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Global Instance Retrieval in WasmEdge 0.9.1\nDESCRIPTION: Example demonstrating how to retrieve a global instance using Store context in WasmEdge 0.9.1.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that a WASM module is instantiated in `VMCxt`, and exports the \"global_i32\". */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\nWasmEdge_String GlobName = WasmEdge_StringCreateByCString(\"global_i32\");\nWasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_StoreFindGlobal(StoreCxt, GlobName);\nWasmEdge_StringDelete(GlobName);\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository on RISCV-V\nDESCRIPTION: Clones the WasmEdge GitHub repository to the local RISC-V environment for building from source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git\nubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Installing Android Debug Bridge (adb) Tool on Ubuntu\nDESCRIPTION: Command to install the Android Debug Bridge (adb) tool on Ubuntu systems, which is needed for debugging and file transfer to Android devices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/ndk.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install adb\n```\n\n----------------------------------------\n\nTITLE: Getting and Building WasmEdge-Go\nDESCRIPTION: Commands to get the WasmEdge-Go package and build it in a Go project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2\ngo build\n```\n\n----------------------------------------\n\nTITLE: Building Rust Project for WasmEdge\nDESCRIPTION: Commands to navigate to the Rust source directory and build the project for wasm32-wasip1 target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd WasmEdge-WASINN-examples/pytorch-mobilenet-image/rust\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Installing OpenWRT Build Dependencies\nDESCRIPTION: Commands to clone OpenWRT repository and install required build tools and dependencies on Debian/Ubuntu systems.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/openwrt/openwrt\n$ sudo apt update\n$ sudo apt install build-essential ccache ecj fastjar file g++ gawk \\\ngettext git java-propose-classpath libelf-dev libncurses5-dev \\\nlibncursesw5-dev libssl-dev python python2.7-dev python3 unzip wget \\\npython-distutils-extra python3-setuptools python3-dev rsync subversion \\\nswig time xsltproc zlib1g-dev\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Compilation Commands - Bash\nDESCRIPTION: Commands for compiling Rust code to WebAssembly and optimizing with WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n\ncd flow/rust_mobilenet_food\ncargo build --target wasm32-wasip1 --release\n# The output WASM will be target/wasm32-wasip1/release/rust_mobilenet_food_lib.wasm\n\n# Copy the wasm bytecode file to the flow/ directory\ncp target/wasm32-wasip1/release/rust_mobilenet_food_lib.wasm ../\n```\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so\n```\n\n----------------------------------------\n\nTITLE: Integrating WasmEdge with TensorFlow in Go\nDESCRIPTION: This Go code demonstrates how to use the WasmEdge runtime with TensorFlow extension. It loads the compiled WebAssembly module, sets up the environment, and executes the inference function, passing image data and retrieving results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/ai.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n  bindgen \"github.com/second-state/wasmedge-bindgen/host/go\"\n)\n\nfunc main() {\n  fmt.Println(\"Go: Args:\", os.Args)\n  // Expected Args[0]: program name (./mobilenet)\n  // Expected Args[1]: wasm file (rust_mobilenet_lib.wasm)\n  // Expected Args[2]: input image name (grace_hopper.jpg)\n\n  // Set not to print debug info\n  wasmedge.SetLogErrorLevel()\n\n  // Set Tensorflow not to print debug info\n  os.Setenv(\"TF_CPP_MIN_LOG_LEVEL\", \"3\")\n  os.Setenv(\"TF_CPP_MIN_VLOG_LEVEL\", \"3\")\n\n  // Load WasmEdge-image and WasmEdge-tensorflow from default path\n  wasmedge.LoadPluginDefaultPaths()\n\n  // Create configure\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n\n  // Create VM with configure\n  var vm = wasmedge.NewVMWithConfig(conf)\n\n  // Init WASI\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n\n  // Load and validate the wasm\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n\n  // Instantiate the bindgen and vm\n  bg := bindgen.New(vm)\n  bg.Instantiate()\n\n  img, _ := ioutil.ReadFile(os.Args[2])\n  if res, _, err := bg.Execute(\"infer\", img); err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(res[0].(string))\n  }\n\n  bg.Release()\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying a WASM Serverless Service\nDESCRIPTION: This snippet shows the configuration for deploying a WASM serverless service with Knative, including setting up annotations and other specifications needed for the service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# apply the serverless service configuration\n# We need setup annotations, runtimeClassName, and ports.\n$ cat > http-wasm-serverless.yaml <<EOF\napiVersion: serving.knative.dev/v1\nkind: Service\nmetadata:\n  name: http-wasm\n  namespace: default\nspec:\n  template:\n    metadata:\n      annotations:\n        module.wasm.image/variant: compat-smart\n    spec:\n      runtimeClassName: crun\n      timeoutSeconds: 1\n      containers:\n      - name: http-server\n        image: docker.io/wasmedge/example-wasi-http:latest\n        ports:\n        - containerPort: 1234\n          protocol: TCP\n        livenessProbe:\n          tcpSocket:\n            port: 1234\nEOF\n\n$ kubectl apply -f http-wasm-serverless.yaml\n\n# wait for a while, and check if the serverless service is available\n$ kubectl get ksvc http-wasm\nNAME          URL                                              LATESTCREATED       LATESTREADY         READY   REASON\nhttp-wasm     http://http-wasm.default.knative.example.com     http-wasm-00001     http-wasm-00001     True\n\n# Try to call the service\n# As we do not set up DNS, we can only call the service via Kourier, Knative Serving ingress port.\n# get Kourier port which is 31997 in following example\n$ kubectl --namespace kourier-system get service kourier\nNAME      TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE\nkourier   LoadBalancer   10.105.58.134                     80:31997/TCP,443:31019/TCP   53d\n$ curl -H \"Host: http-wasm.default.knative.example.com\" -d \"name=WasmEdge\" -X POST http://localhost:31997\n\n# check the new start pod\n$ kubectl get pods\nNAME                                           READY   STATUS    RESTARTS   AGE\nhttp-wasm-00001-deployment-748bdc7cf-96l4r     2/2     Running   0          19s\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm\nDESCRIPTION: This command installs the necessary dependencies listed in the package.json file for the React SSR project using npm.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Client for Local Cluster\nDESCRIPTION: Commands to configure the Kubernetes client (kubectl) to connect to the local cluster by setting the cluster, credentials, context, and using the local context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport KUBERNETES_PROVIDER=local\n\nsudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\nsudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\nsudo cluster/kubectl.sh config set-context local --cluster=local --user=myself\nsudo cluster/kubectl.sh config use-context local\nsudo cluster/kubectl.sh\n```\n\n----------------------------------------\n\nTITLE: WASM Module Response Output\nDESCRIPTION: Expected HTTP response output when testing the WASM module implementation\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/wasm-nginx.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nHTTP/1.1 403 Forbidden\n...\n\npowered by wasm-nginx-module\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Defines the WasmEdge_Limit struct used to specify minimum and maximum values for WASM resources. Contains HasMax boolean flag, Min value, and optional Max value.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge for OpenWRT\nDESCRIPTION: Command to run the build script that adds WasmEdge to the OpenWRT packages list and builds the OpenWRT firmware.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./utils/openwrt/build_for_openwrt.sh ~/openwrt\n```\n\n----------------------------------------\n\nTITLE: Adding NPM Scripts for Server Build and Start\nDESCRIPTION: NPM scripts added to package.json for building and starting the SSR server using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n\"scripts\": {\n  \"dev:build-server\": \"NODE_ENV=development webpack --config webpack.server.js --mode=development\",\n  \"dev:start-server\": \"wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js\",\n  // ...\n},\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge for OpenWRT\nDESCRIPTION: Command to run the OpenWRT build script for WasmEdge, which adds WasmEdge to the OpenWRT package list and builds the firmware.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./utils/openwrt/build_for_openwrt.sh ~/openwrt\n```\n\n----------------------------------------\n\nTITLE: Moving TensorFlowLite Libraries to System Path (Linux)\nDESCRIPTION: Commands to move the extracted TensorFlowLite shared libraries to the system library path on Linux platforms, making them accessible to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflowlite_c.so /usr/local/lib\nmv libtensorflowlite_flex.so /usr/local/lib\n```\n\n----------------------------------------\n\nTITLE: Installing OpenVINO on Ubuntu 20.04\nDESCRIPTION: Commands to install OpenVINO 2023 on Ubuntu 20.04, which is required for the WASI-NN OpenVINO backend. This installs the OpenVINO package from Intel's repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\nsudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\necho \"deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main\" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list\nsudo apt update\nsudo apt-get -y install openvino\nldconfig\n```\n\n----------------------------------------\n\nTITLE: WASI Initialization with WasmEdge 0.9.1\nDESCRIPTION: Example showing how to initialize WASI using WasmEdge 0.9.1 C API with ImportObjectContext.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration import objects from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ImportObjectContext *WasiObject =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing CRI-O on Ubuntu 20.04\nDESCRIPTION: Commands to install CRI-O container runtime on Ubuntu 20.04. This script sets up repositories, installs dependencies, and starts the CRI-O service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OS=\"xUbuntu_20.04\"\nexport VERSION=\"1.21\"\napt update\napt install -y libseccomp2 || sudo apt update -y libseccomp2\necho \"deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\necho \"deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /\" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list\n\ncurl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -\ncurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -\n\napt-get update\napt-get install criu libyajl2\napt-get install cri-o cri-o-runc cri-tools containernetworking-plugins\nsystemctl start crio\n```\n\n----------------------------------------\n\nTITLE: List Containers with crictl\nDESCRIPTION: This snippet uses `crictl ps -a` to list all containers running on the edge node.  It requires `crictl` to be installed and configured to communicate with the container runtime. The output includes container IDs, image names, creation times, states, names, and pod IDs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo crictl ps -a\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge Native Application with Android NDK\nDESCRIPTION: Command for compiling a C program that uses WasmEdge and TensorFlow Lite libraries with the Android NDK's clang compiler for the arm64 architecture.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/ndk.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n(/path/to/ndk)/toolchains/llvm/prebuilt/(HostPlatform)/bin/aarch64-linux-(AndroidApiVersion)-clang test.c -I./WasmEdge-0.12.1-Android/include -L./WasmEdge-0.12.1-Android/lib -lwasmedge-image_c -lwasmedge-tensorflowlite_c -ltensorflowlite_c -lwasmedge\n```\n\n----------------------------------------\n\nTITLE: Deploy Events Recorder Microservice with Dapr\nDESCRIPTION: This command deploys the events recorder microservice with Dapr, specifying the application ID, protocol, ports, log level, components path, and the WasmEdge runtime for executing the WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndapr run --app-id events-service \\\n        --app-protocol http \\\n        --app-port 9007 \\\n        --dapr-http-port 3505 \\\n        --log-level debug \\\n        --components-path ../config \\\n        wasmedge events_service.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing Multiple WasmEdge Plugins\nDESCRIPTION: This command installs WasmEdge with multiple specified plugins using the `--plugins` parameter, passing a space-separated list of plugin names. It enables installing multiple plugins in a single command. The specified plugins are downloaded and set up for use with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-tensorflowlite wasmedge_tensorflow\n```\n\n----------------------------------------\n\nTITLE: Installing yurtctl CLI Tool\nDESCRIPTION: Commands to clone the OpenYurt repository and build the yurtctl CLI tool. This tool is used to convert a standard Kubernetes cluster to an OpenYurt cluster.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/openyurtio/openyurt.git\ncd openyurt\nmake build WHAT=cmd/yurtctl\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Installer via Curl in Bash\nDESCRIPTION: Command to download and execute the WasmEdge installer script, which accepts various configuration options to customize the installation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/installer.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- ${OPTIONS}\n```\n\n----------------------------------------\n\nTITLE: Converting OpenWRT Image to VMware Format\nDESCRIPTION: Commands to convert the compiled OpenWRT image to vmdk format using QEMU for deployment in VMware.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/openwrt/bin/targets/x86/64\nsudo apt install qemu\ngunzip openwrt-x86-64-generic-squashfs-combined.img.gz\nqemu-img convert -f raw -O vmdk openwrt-x86-64-generic-squashfs-combined.img Openwrt.vmdk\n```\n\n----------------------------------------\n\nTITLE: Pulling WebAssembly HTTP Server Container Image with CRI-O\nDESCRIPTION: Command to pull a WebAssembly-based HTTP server container image from Docker Hub using CRI-O's crictl tool. This image contains a WebAssembly HTTP server application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge in OpenWRT with WebAssembly Modules\nDESCRIPTION: Commands to test the WasmEdge program in OpenWRT by running WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge hello.wasm second state\nhello\nsecond\nstate\n$ wasmedge --reactor add.wasm add 2 2\n4\n```\n\n----------------------------------------\n\nTITLE: Installing SuperEdge Edge Kubernetes Master Node\nDESCRIPTION: Command to install the SuperEdge edge Kubernetes master node using containerd runtime. It sets up the Kubernetes cluster with specific network configurations and enables edge computing features.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=<Master Public IP> --apiserver-advertise-address=<Master Intranet IP> --enable-edge=true --runtime=containerd\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Loader Context in C\nDESCRIPTION: Example of using the WasmEdge Loader context to load WASM modules from files or memory buffers. This demonstrates both loading methods and proper resource management with appropriate error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: TensorFlow SavedModel Session Creation in Rust\nDESCRIPTION: Code for creating a TensorFlow session from a saved model\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// The mod_path is a &str which is the path to saved-model directory.\n// The second argument is the list of tags.\nlet mut session = wasmedge_tensorflow_interface::TFSession::new_from_saved_model(model_path, &[\"serve\"]);\n```\n\n----------------------------------------\n\nTITLE: Adding Target for RustPython Compilation - Rust\nDESCRIPTION: This command adds the wasm32-wasip1 target to the Rust toolchain, necessary for compiling RustPython for WebAssembly support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Reloading Docker Daemon After Runtime Configuration in Bash\nDESCRIPTION: Command to reload the Docker daemon after configuring the custom Crun runtime to ensure the new configuration takes effect.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Reload docker daemon\n> sudo systemctl reload docker\n```\n\n----------------------------------------\n\nTITLE: Downloading Llama 2 Model for Inference\nDESCRIPTION: Command to download the Llama 2 model file required for the demonstration. This quantized model is optimized for inference with GGML.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe Wrapper Functions for WasmEdge Plug-in in Rust\nDESCRIPTION: Rust code that imports the generated module and provides safe wrapper functions for each generated function in the WasmEdge plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmod generated;\n\npub fn imdecode(buf: &[u8]) -> u32 {\n    unsafe { generated::imdecode(buf.as_ptr(), buf.len()) }\n}\npub fn imshow(window_name: &str, mat_key: u32) -> () {\n    unsafe { generated::imshow(window_name.as_ptr(), window_name.len(), mat_key) }\n}\npub fn waitkey(delay: u32) -> () {\n    unsafe { generated::waitkey(delay) }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository\nDESCRIPTION: Commands to clone the WasmEdge GitHub repository and navigate to the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/macos.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Navigating to Rustls Plug-in Directory\nDESCRIPTION: Command to change the current directory to the Rustls plug-in source code location within the cloned WasmEdge repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd WasmEdge/plugins/wasmedge_rustls\n```\n\n----------------------------------------\n\nTITLE: Setting up TLS Support on MacOS\nDESCRIPTION: Environment variable configuration for enabling TLS support in Rust WebAssembly builds on MacOS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport WASI_SDK_PATH /path/to/wasi-sdk-22.0\nexport CC=\"${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot\"\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly HTTP Service with curl\nDESCRIPTION: Command to send an HTTP POST request to the deployed WebAssembly HTTP service running in Kubernetes to verify it's functioning correctly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"name=WasmEdge\" -X POST http://127.0.0.1:1234\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Module with Export Name\nDESCRIPTION: Demonstrates how to register a WASM module with an exported module name in WasmEdge VM. Shows module registration from file and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,\n * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring youki Container Runtime for WebAssembly\nDESCRIPTION: JSON configuration specifying WebAssembly runtime handler and WASM module entrypoint\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"ociVersion\": \"1.0.2-dev\",\n   \"annotations\": {\n       \"run.oci.handler\": \"wasm\"\n   },\n   \"process\": {\n       \"args\": [\n           \"wasi_example_main.wasm\"\n       ]\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Swap Space for Kubernetes Nodes\nDESCRIPTION: Commands to disable swap space on Kubernetes nodes, which is a prerequisite for Kubernetes installation. The free -m command is used to verify the swap is disabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo swapoff -a\n//verify\nfree -m\n```\n\n----------------------------------------\n\nTITLE: Creating a New Go Project for WasmEdge\nDESCRIPTION: Initialize a new Go project for WasmEdge testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Context Resource Management in WasmEdge Go\nDESCRIPTION: Illustrates proper context creation and immediate release for resource management in WasmEdge Go API\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing Podman and WasmEdge on Fedora\nDESCRIPTION: These bash commands install Podman and WasmEdge on Fedora without requiring any changes for running WasmEdge apps.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf -y install podman\nsudo dnf -y install wasmedge\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C\nDESCRIPTION: Defines the function signature for host functions in WasmEdge. This signature is used for creating custom host functions that can be called from WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n  void *Data,\n  WasmEdge_MemoryInstanceContext *MemCxt,\n  const WasmEdge_Value *Params,\n  WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge-WASINN Examples Repository Using Bash\nDESCRIPTION: This Bash snippet clones the WasmEdge-WASINN-examples repository and navigates to the project directory. It assumes Git is installed and the relevant network permissions are set.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/tflite-birds_v1-image/\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge via Curl Script (Bash)\nDESCRIPTION: Command to download and install WasmEdge using a curl script. Requires git and wget as prerequisites.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_version }}\n```\n\n----------------------------------------\n\nTITLE: Adding WASI Target for Rust\nDESCRIPTION: Command to add wasm32-wasip1 target to Rust toolchain for WebAssembly compilation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/setup.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Deploying WebAssembly HTTP Service in Kubernetes\nDESCRIPTION: Command to deploy a WebAssembly-based HTTP service in Kubernetes using a pre-built Docker image. This creates a deployment with the WasmEdge runtime and exposes the service on the host network.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh apply -f - <<< '{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"name\":\"http-server-deployment\"},\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"app\":\"http-server\"}},\"template\":{\"metadata\":{\"labels\":{\"app\":\"http-server\"}},\"spec\":{\"hostNetwork\":true,\"runtimeClassName\":\"wasm\",\"containers\":[{\"name\":\"http-server\",\"image\":\"wasmedge/example-wasi-http:latest\",\"ports\":[{\"containerPort\":1234}]}]}}}}'\n```\n\n----------------------------------------\n\nTITLE: Pushing WasmEdge CLI to Android Device\nDESCRIPTION: Commands to copy examples and push the WasmEdge CLI folder to the Android device.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/build.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncp -r examples build/tools/wasmedge/examples\ncd build\nadb push ./tools/wasmedge /data/local/tmp\n```\n\n----------------------------------------\n\nTITLE: Installing Emscripten for C to WebAssembly Compilation\nDESCRIPTION: This bash script clones the Emscripten SDK repository, installs the latest version, activates it, and sets up the environment variables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/simd.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth 1 https://github.com/emscripten-core/emsdk.git\ncd emsdk\n./emsdk install latest\n./emsdk activate latest\nsource ./emsdk_env.sh\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Command to verify the installed Go version before using WasmEdge-Go. Requires Go version 1.16 or higher.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly with WasmEdge CLI\nDESCRIPTION: Command to execute the compiled WebAssembly file using the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge hello.wasm\nHello TinyGo from WasmEdge!\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge AOT Compilation\nDESCRIPTION: Commands demonstrating AOT compilation of WebAssembly and performance comparison between interpreted and AOT execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/riscv64.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm\n[2023-02-01 22:39:15.807] [info] compile start\n[2023-02-01 22:39:15.857] [info] verify start\n[2023-02-01 22:39:15.866] [info] optimize start\n[2023-02-01 22:39:16.188] [info] codegen start\n[2023-02-01 22:39:16.403] [info] output start\n[2023-02-01 22:39:16.559] [info] compile done\n[2023-02-01 22:39:16.565] [info] output start\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30\n1346269\nreal    0m0.284s\nuser    0m0.282s\nsys     0m0.005s\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30\n1346269\nreal    0m1.814s\nuser    0m1.776s\nsys     0m0.016s\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Application\nDESCRIPTION: Commands to install the WasmEdge Go SDK, build the Go application, and run it to test the WebAssembly host function implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_68\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge with Custom Path\nDESCRIPTION: Uninstall WasmEdge by specifying a custom installation path when the executable is not in the default location\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder\n```\n\n----------------------------------------\n\nTITLE: Installing GCC on Ubuntu\nDESCRIPTION: This bash command sequence installs GCC and essential build tools on Ubuntu, necessary for building projects from source, including WasmEdge-QuickJs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Install GCC\nsudo apt update\nsudo apt install build-essential\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly SIMD Application with WasmEdge\nDESCRIPTION: Command to execute the compiled WebAssembly SIMD application using WasmEdge runtime. The number 15000 represents an input parameter for the Mandelbrot calculation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/simd.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge mandelbrot-simd.wasm 15000\n```\n\n----------------------------------------\n\nTITLE: Executing WebAssembly Function with Host Function in C\nDESCRIPTION: Demonstrates how to create a host function, register it with a module instance, load and execute a WebAssembly module that calls the host function using WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_82\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf(\"Host function \\\"Add\\\": %d + %d\\n\", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Import section */\n                    0x02, 0x13, 0x01,\n                    /* module name: \"extern\" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: \"func-add\" */\n                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x0A, 0x01,\n                    /* export name: \"addTwo\" */\n                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x0A, 0x01,\n                    /* code body */\n                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"extern\");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                   WasmEdge_ValTypeGenI32()};\n  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(\"func-add\");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"addTwo\");\n  /* Run the WASM function from memory. */\n  WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));\n  /*\n   * Note: `WasmEdge_VMRunWasmFromBuffer()` will be deprecated in the future.\n   * We recommand developers to use `WasmEdge_VMRunWasmFromBytes()` instead.\n   */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName,\n                                                    Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf(\"Error message: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance and Adding Function in C\nDESCRIPTION: Demonstrates how to create a module instance, add a function instance to it, and properly manage the lifecycle of created objects using WasmEdge C API.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_80\n\nLANGUAGE: c\nCODE:\n```\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\n/*\n * Developers can also use the WasmEdge_ModuleInstanceCreateWithData() to\n * create the module instance with the data and its finalizer. It will be\n * introduced later.\n */\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                 WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"add\");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n    WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString(\"memory\");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n\n/* Create and add a global instance into the module instance. */\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module\n * instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing the Rustls Plug-in with Cargo in Bash\nDESCRIPTION: Command to install the built Rustls plug-in into the Rust binary directory using Cargo.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/rusttls.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Crun with WasmEdge Support\nDESCRIPTION: Commands to clone, configure, build, and install crun with WasmEdge support from source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Setting Up TensorFlow Libraries on MacOS\nDESCRIPTION: Commands to install and configure TensorFlow shared libraries on MacOS systems by moving files and creating symbolic links.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflow.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflow_cc.2.12.0.dylib /usr/local/lib\nmv libtensorflow_framework.2.12.0.dylib /usr/local/lib\nln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib\nln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib\nln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib\nln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Definition of the WasmEdge_Limit struct that represents WASM limits with minimum and maximum values, including shared memory flag.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly HTTP Server with curl\nDESCRIPTION: Shell command to test the HTTP server running in the Docker container by sending a POST request with curl. Demonstrates how to interact with the WebAssembly-based HTTP server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ curl -X POST http://127.0.0.1:1234 -d \"name=WasmEdge\"\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Pulling WasmEdge Docker Image\nDESCRIPTION: Command to pull the latest WasmEdge Docker image from Docker Hub, which provides a pre-configured build environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull wasmedge/wasmedge # Pulls the latest - wasmedge/wasmedge:latest\n```\n\n----------------------------------------\n\nTITLE: Creating Plugin SDK with Shell Commands\nDESCRIPTION: Shell commands for creating a new Rust crate and generating plugin code using witc tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nwitc plugin wasmedge_opencvmini.wit\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo new --lib opencvmini-sdk && cd opencvmini-sdk\n```\n\nLANGUAGE: shell\nCODE:\n```\nwitc plugin wasmedge_opencvmini.wit > src/generated.rs\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WASI-NN ChatTTS Backend\nDESCRIPTION: This snippet includes the necessary commands to install dependencies for the ChatTTS backend before building WasmEdge from source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt upgrade\nsudo apt install python3-dev\npip install chattts==0.1.1\n```\n\n----------------------------------------\n\nTITLE: Verifying Edge Node Status from Cloud Side\nDESCRIPTION: Command to check the status of the newly joined edge node from the cloud side using kubectl.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get node\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for crun Compilation\nDESCRIPTION: This snippet demonstrates how to install the necessary dependencies for compiling crun with WasmEdge support. Ensure to have the development tools and libraries specified in the command list.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install dependencies\n$ sudo apt update\n$ sudo apt install -y make git gcc build-essential pkgconf libtool \\\n    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n    go-md2man libtool autoconf python3 automake\n\n# Compile crun\n$ git clone https://github.com/containers/crun\n$ cd crun\n$ ./autogen.sh\n$ ./configure --with-wasmedge\n$ make\n$ sudo make install\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Linux with root privileges\nDESCRIPTION: A one-liner command to install WasmEdge on Linux systems with root or sudo privileges. This command installs WasmEdge in the /usr/local directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | sudo bash -s -- -p /usr/local\n```\n\n----------------------------------------\n\nTITLE: HTTP POST Request Using Hyper\nDESCRIPTION: Example of making an HTTP POST request using the hyper library in Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nasync fn post_url_return_str (url: hyper::Uri, post_body: &'static [u8]) -> Result<()> {\n    let client = Client::new();\n    let req = Request::builder()\n        .method(Method::POST)\n        .uri(url)\n        .body(Body::from(post_body))?;\n    let mut res = client.request(req).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!(\"{}\", String::from_utf8_lossy(&resp_data));\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with GGML Backend on Windows (CUDA Enabled)\nDESCRIPTION: PowerShell commands to build WasmEdge with the GGML backend on Windows, with CUDA support enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n# CUDA ENABLE:\n& \"C:\\Program files\\CMake\\bin\\cmake.exe\" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON -DWASMEDGE_USE_LLVM=OFF .\n& \"<the ninja-build folder>\\ninja.exe\" -C build\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Fedora/Red Hat Linux\nDESCRIPTION: This command installs WasmEdge on Fedora and Red Hat Linux distributions using the `dnf` package manager. It utilizes the official WasmEdge packages available in the Fedora repositories. Using the package manager ensures that dependencies are correctly resolved and managed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndnf install wasmedge\n```\n\n----------------------------------------\n\nTITLE: Hello World Program in C\nDESCRIPTION: A simple C program that prints 'Hello World!' to the console. This serves as the basic example for compilation to WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// hello.c\n\n#include<stdio.h>\nint main(int argc,char **argv){\n  printf(\"Hello World!\\n\");\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Containerd on Edge Node\nDESCRIPTION: This snippet includes commands to install containerd version 1.5.7, using wget to fetch the release and verifying integrity via sha256sum. Installation is done by extracting the archive.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport VERSION=\"1.5.7\"\necho -e \"Version: $VERSION\"\necho -e \"Installing libseccomp2 ...\"\nsudo apt install -y libseccomp2\necho -e \"Installing wget\"\nsudo apt install -y wget\n\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\nsha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\n\nsudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nsudo systemctl daemon-reload\n```\n\n----------------------------------------\n\nTITLE: Initialize Database Table\nDESCRIPTION: CURL command to send GET request to the /init endpoint for initializing the orders table in the database.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/init\n```\n\n----------------------------------------\n\nTITLE: Value Type Creation Post-0.14.0 Example\nDESCRIPTION: Example showing how to create function types using new ValType APIs in version 0.14.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Copying Node.js API Support Modules - Bash\nDESCRIPTION: This snippet executes a command to copy necessary modules for Node.js API support into the working directory to ensure that the application runs correctly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncp -r ../../modules .\n```\n\n----------------------------------------\n\nTITLE: Running TCP Server and Client Example in WasmEdge\nDESCRIPTION: Command and output from executing the TCP echo server example, which demonstrates both a TCP server and client communicating within the same JavaScript program.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_net_echo.js\nlisten 8000 ...\nserver accept: 127.0.0.1:49040\nserver recv: hello\nclient recv: echo:hello\n```\n\n----------------------------------------\n\nTITLE: Query Events Database\nDESCRIPTION: This command queries the events database by sending a request to the events microservice. It retrieves and displays the events stored in the database.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:9007/events\n[]\n```\n\n----------------------------------------\n\nTITLE: Memory Access in Host Functions\nDESCRIPTION: Example of accessing WebAssembly memory from a host function using the calling frame.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_71\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"encoding/binary\"\n  \"fmt\"\n)\n\n// Host function body definition.\nfunc LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // Function type: {i32} -> {}\n  offset := params[0].(int32)\n\n  // Get the 0th memory instance of the module of the top frame on the stack.\n  mem := callframe.GetMemoryByIndex(0)\n\n  data, err := mem.GetData(uint(offset), 4)\n  if err != nil {\n    return nil, err\n  }\n  fmt.Println(\"u32 at memory[{}]: {}\", offset, binary.LittleEndian.Uint32(data))\n  return nil, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlowLite Dependencies\nDESCRIPTION: Commands to download and install the required TensorFlowLite shared libraries. This includes downloading pre-built binary packages from GitHub and extracting them to make the libraries available to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.\n# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.\n# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.\ntar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nrm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Installing GGML Dependencies for WasmEdge\nDESCRIPTION: Installs the OpenBLAS library required for the CPU version of the WASI-NN GGML plugin. This is only needed if you're using GGML with CPU computation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\napt update && apt install -y libopenblas-dev # You may need sudo if the user is not root.\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Fedora/Red Hat Linux\nDESCRIPTION: Installs WasmEdge on Fedora and Red Hat Linux systems using the dnf package manager.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndnf install wasmedge\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Command to check the installed Go version, which should be 1.16 or higher for WasmEdge-Go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Addition Function in C for WebAssembly\nDESCRIPTION: C program that takes two command line arguments and prints their sum, showing how to handle program arguments in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char *argv[])\n{\n  int a,b;\n  if(argc==3){\n    a = atoi(argv[1]);\n    b = atoi(argv[2]);\n    printf(\"%d\\n\",a+b);\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Check Kubernetes Cluster Info\nDESCRIPTION: This snippet retrieves and displays information about the Kubernetes cluster, verifying that it is running correctly. It uses the kubectl command-line tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo cluster/kubectl.sh cluster-info\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Kubernetes Cluster for OpenYurt\nDESCRIPTION: Commands to install required Kubernetes components and initialize a Kubernetes master node, all tailored for setting up an OpenYurt cluster. Includes Kubernetes repository integration and network settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get update && sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https\n// add K8s source\n$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -\n$ sudo tee /etc/apt/sources.list.d/kubernetes.list <<EOF\n$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\n// install K8s components 1.18.9\n$ sudo apt-get update && sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00\n// Initialize the master node\n$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \\\n--apiserver-advertise-address=192.168.3.167 \\\n--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers\n// join the work node\n$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \\\n   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195\n```\n\n----------------------------------------\n\nTITLE: Building Rust WebAssembly Function\nDESCRIPTION: Commands to build the Rust program into WebAssembly bytecode and copy the build artifacts to the appropriate folder.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd api/functions/image-grayscale/\ncargo build --release --target wasm32-wasip1\ncp target/wasm32-wasip1/release/grayscale.wasm ../../\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge from a Custom Location\nDESCRIPTION: Uninstalls WasmEdge from a specified installation path using the -p flag to specify the parent folder where WasmEdge is installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder\n```\n\n----------------------------------------\n\nTITLE: Testing the JavaScript-based Server with curl\nDESCRIPTION: Shows how to test the running JavaScript-based HTTP server using a curl command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Global Instance in WasmEdge 0.10.0 C API\nDESCRIPTION: Updated example of retrieving an exported Global instance from a WASM module using WasmEdge 0.10.0 C API. It shows the use of WasmEdge_VMGetActiveModule() to get the module instance and find the Global instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that a WASM module is instantiated in `VMCxt`, and exports the \"global_i32\". */\nconst WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);\n/* The example of retrieving the global instance. */\nWasmEdge_String GlobName = WasmEdge_StringCreateByCString(\"global_i32\");\nWasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_ModuleInstanceFindGlobal(ModCxt, GlobName);\nWasmEdge_StringDelete(GlobName);\n```\n\n----------------------------------------\n\nTITLE: Cloning and Compiling Qdrant Example\nDESCRIPTION: This bash script clones the example Qdrant client, compiles the Rust code into WASM using `cargo build`. It sets the `RUSTFLAGS` environment variable to include `wasmedge` and `tokio_unstable` configurations, essential for compiling with WasmEdge support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/qdrant_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/qdrant\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Perform vector data operations against a Qdrant at http://localhost:6333\nwasmedge target/wasm32-wasip1/release/qdrant_examples.wasm\n```\n```\n\n----------------------------------------\n\nTITLE: Building Docker Compose Containers\nDESCRIPTION: Command to build and start all three containers (client, server, and db) defined in the docker-compose configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Creating Module Instance from Plug-in (Pre-v0.12.0)\nDESCRIPTION: Example of creating a module instance from a plug-in before version 0.12.0, using specific creation functions for each plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\n\ncryptocommonmod := wasmedge.NewWasiCryptoCommonModule()\n\ncryptocommonmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with WASI-Crypto Plugin Support\nDESCRIPTION: Commands to build WasmEdge from source with the WASI-Crypto plugin enabled. This shows how to configure CMake with the required options and install the built binaries and plugins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.\n# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On\ncmake --build build\n# For the WASI-Crypto plug-in, you should install this project.\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Pulling and Running a WebAssembly Container Image with youki and Podman\nDESCRIPTION: These bash commands demonstrate how to pull a WebAssembly container image from Docker Hub and run it using youki as the runtime with Podman.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ctr i pull docker.io/wasmedge/example-wasi:latest\n\nsudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Running the Go Application for Image Processing\nDESCRIPTION: This command changes the directory to the flow folder and runs the Go application app.go with specified build tags for tensorflow and image. The application processes images as they are streamed to YoMo, handling the image recognition workflow defined in the previously mentioned YAML configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd flow\n go run --tags \"tensorflow image\" app.go\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with llama.cpp Backend on Ubuntu/Debian with CUDA 12\nDESCRIPTION: Commands to build WasmEdge with the llama.cpp (GGML) backend on Ubuntu/Debian with CUDA 12 support. This enables CUBLAS for GPU acceleration but disables BLAS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/your/wasmedge/source/folder>\n\n# You may need to install dependencies\napt update\napt install -y software-properties-common lsb-release \\\n  cmake unzip pkg-config\n\n# Due to cuda-related files, it will produce some warning.\n# Disable the warning as an error to avoid failures.\nexport CXXFLAGS=\"-Wno-error\"\n# Please make sure you set up the correct CUDAARCHS.\n# We use `60;61;70` for maximum compatibility.\nexport CUDAARCHS=\"60;61;70\"\n\n# BLAS cannot work with CUBLAS\ncmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_CUDA_ARCHITECTURES=\"60;61;70\" \\\n  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \\\n  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=\"GGML\" \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \\\n  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \\\n  .\n\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Linking WasmEdge Shared Library with GCC\nDESCRIPTION: Demonstrates how to compile a C program using the WasmEdge shared library, including compilation and execution commands\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/library.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge -o test\n$ ./test\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Generating Containerd Configuration Patch\nDESCRIPTION: Bash command to create a diff file for patching the containerd configuration to use crun as the default runtime and support WebAssembly annotations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncat > config.toml.diff << EOF\n--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800\n+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800\n@@ -24,17 +24,23 @@\n   max_concurrent_downloads = 10\n\n   [plugins.cri.containerd]\n-        default_runtime_name = \"runc\"\n-    [plugins.cri.containerd.runtimes.runc]\n+        default_runtime_name = \"crun\"\n+    [plugins.cri.containerd.runtimes.crun]\n       runtime_type = \"io.containerd.runc.v2\"\n-      pod_annotations = []\n+      pod_annotations = [\"*.wasm.*\", \"wasm.*\", \"module.wasm.image/*\", \"*.module.wasm.image\", \"module.wasm.image/variant.*\"]\n       container_annotations = []\n       privileged_without_host_devices = false\n-      [plugins.cri.containerd.runtimes.runc.options]\n-        BinaryName = \"runc\"\n+      [plugins.cri.containerd.runtimes.crun.options]\n+        BinaryName = \"crun\"\n   # cni\n   [plugins.cri.cni]\n     bin_dir = \"/opt/cni/bin\"\n     conf_dir = \"/etc/cni/net.d\"\n     conf_template = \"\"\n\n+  [plugins.\"io.containerd.runtime.v1.linux\"]\n+    no_shim = false\n+    runtime = \"crun\"\n+    runtime_root = \"\"\n+    shim = \"containerd-shim\"\n+    shim_debug = false\nEOF\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge eBPF Plugin with CMake\nDESCRIPTION: Commands to build the WasmEdge eBPF plugin using CMake. Requires setting WASMEDGE_PLUGIN_WASM_BPF flag to TRUE.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncmake -DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE -B ./build -G \"Unix Makefiles\"\ncmake --build ./build\n```\n\n----------------------------------------\n\nTITLE: Executing Bird Classification\nDESCRIPTION: Commands to run the compiled WebAssembly program for bird classification using wasmedge-tensorflow-lite.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/cli.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge-go Package\nDESCRIPTION: Commands to fetch and build the WasmEdge-go package in a Go project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1\ngo build\n```\n\n----------------------------------------\n\nTITLE: Verifying TinyGo Installation\nDESCRIPTION: Command to check the installed version of TinyGo and its dependencies.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ tinygo version\ntinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)\n```\n\n----------------------------------------\n\nTITLE: Copying Module Files to Modules Directory\nDESCRIPTION: Command to copy the module demo files to the WasmEdge QuickJS modules directory, making them available as built-in modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncp example_js/module_demo/modules/* modules/\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Linux without root privileges\nDESCRIPTION: A command to install WasmEdge in the user's home directory when root or sudo privileges are not available. This installs WasmEdge in the $HOME/.wasmedge directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Core\nDESCRIPTION: Script to install the WasmEdge shared library v0.13.5\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.13.5\n```\n\n----------------------------------------\n\nTITLE: Creating Function Types with WasmEdge_ValType in C (0.13.5)\nDESCRIPTION: Example of creating a function type using WasmEdge_ValType enum in WasmEdge 0.13.5. This approach is deprecated in 0.14.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Cloning the WasmEdge Repository for Android Build\nDESCRIPTION: Commands to clone the WasmEdge repository from GitHub and navigate to the project directory. This is the first step in building WasmEdge from source for Android.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/build.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Copying HTML file to source directory using bash\nDESCRIPTION: This bash command copies the `index.html` file from the `server/src` directory to the `server-wasmedge/src` directory. This is a prerequisite for the server-side rendering logic.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncp server/src/index.html server-wasmedge/src/\n\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions in C\nDESCRIPTION: Demonstrates how to enumerate all exported functions from a loaded and instantiated WASM module. This example loads a fibonacci implementation and prints the names of its exported functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_52\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing WASM Functions from Go\nDESCRIPTION: Demonstrates calling various wasmedge-bindgen annotated functions from Go, including handling different parameter types and return values. Shows error handling and type conversions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/embed-wasm-apps-go.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n  res, err := bg.Execute(\"create_line\", \"{\\\"x\\\":2.5,\\\"y\\\":7.8}\", \"{\\\"x\\\":2.5,\\\"y\\\":5.8}\", \"A thin red line\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- create_line:\", string(res))\n  } else {\n    fmt.Println(\"Run bindgen -- create_line FAILED\", err)\n  }\n\n  res, err = bg.Execute(\"say\", \"bindgen funcs test\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- say:\", string(res))\n  } else {\n    fmt.Println(\"Run bindgen -- say FAILED\")\n  }\n\n  res, err = bg.Execute(\"obfusticate\", \"A quick brown fox jumps over the lazy dog\")\n  if err == nil {\n    fmt.Println(\"Run bindgen -- obfusticate:\", string(res))\n  } else {\n    fmt.Println(\"Run bindgen -- obfusticate FAILED\")\n  }\n\n  res, err = bg.Execute(\"lowest_common_multiple\", int32(123), int32(2))\n  if err == nil {\n    num, _ := strconv.ParseInt(string(res), 10, 32)\n    fmt.Println(\"Run bindgen -- lowest_common_multiple:\", num)\n  } else {\n    fmt.Println(\"Run bindgen -- lowest_common_multiple FAILED\")\n  }\n\n  res, err = bg.Execute(\"sha3_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- sha3_digest:\", res)\n  } else {\n    fmt.Println(\"Run bindgen -- sha3_digest FAILED\")\n  }\n\n  res, err = bg.Execute(\"keccak_digest\", []byte(\"This is an important message\"))\n  if err == nil {\n    fmt.Println(\"Run bindgen -- keccak_digest:\", res)\n  } else {\n    fmt.Println(\"Run bindgen -- keccak_digest FAILED\")\n  }\n\n  bg.Release()\n  vm.Release()\n  conf.Release()\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Modules with WasmEdge Loader in C\nDESCRIPTION: This code demonstrates how to use the WasmEdge Loader context to load WASM modules from files or buffers. It includes error handling and shows how to create and delete necessary contexts.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_60\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nWasmEdge_Bytes Bytes = WasmEdge_BytesWrap(Buf, FileSize);\nRes = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);\n/*\n * Note: `WasmEdge_LoaderParseFromBuffer()` will be deprecated in the future.\n * We recommand developers to use `WasmEdge_LoaderParseFromBytes()` instead.\n */\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Final Build Commands\nDESCRIPTION: Commands to install dependencies and build the final bundled JavaScript file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/npm.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Loading Kernel Module and Setting Parameters for Kubernetes\nDESCRIPTION: This Bash script loads the `br_netfilter` kernel module and updates kernel network parameters required for Kubernetes networking, applying them with `sysctl`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n//load the module\nsudo modprobe br_netfilter\n//verify\nlsmod | grep br_netfilter\n// create k8s.conf\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsudo sysctl --system\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge to a System Directory\nDESCRIPTION: This command installs WasmEdge to a specified system directory, making it available to all users on the system. It requires root privileges or `sudo` as it writes to system directories. The `-p` option specifies the installation path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local\n```\n\n----------------------------------------\n\nTITLE: Returning Error Codes in Host Functions - WasmEdge C\nDESCRIPTION: Demonstrates how to return custom error codes from a host function, causing a trap in WASM. It describes error code limitations and strategies for simple trap generation using WasmEdge APIs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result FaildFunc(void *Data,\n                          const WasmEdge_CallingFrameContext *CallFrameCxt,\n                          const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* This will create a trap in WASM with the error code. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository and Setting Android NDK Path\nDESCRIPTION: Commands to clone the WasmEdge repository and set the Android NDK path in the environment variables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/build.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\nexport ANDROID_NDK_HOME=path/to/you/ndk/dir\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Dependencies for WASI Helper Functions\nDESCRIPTION: This Cargo.toml snippet shows how to include the wasmedge-wasi-helper crate, which provides initialization functions for WASI in Rust library projects without a main() function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/os.md#2025-04-21_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\n... ...\nwasmedge-wasi-helper = \"=0.2.0\"\n```\n\n----------------------------------------\n\nTITLE: Cloning the runwasi containerd shim repository\nDESCRIPTION: Command to download the runwasi project repository from GitHub, which provides WebAssembly runtime integration with containerd.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containerd/runwasi.git\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge, crun, and Podman on Red Hat Systems\nDESCRIPTION: Uses dnf to install WasmEdge, crun-wasm, and Podman on Fedora, CentOS, or Red Hat Linux systems.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndnf install wasmedge crun-wasm podman\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu 20.04 in Bash\nDESCRIPTION: Commands to install necessary tools, libraries, and compilers for building WasmEdge on Ubuntu 20.04.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/linux.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Tools and libraries\nsudo apt install -y \\\n   software-properties-common \\\n   cmake\n\n# And you will need to install llvm for the AOT runtime\nsudo apt install -y \\\n   llvm-12-dev \\\n   liblld-12-dev\n\n# WasmEdge supports both clang++ and g++ compilers.\n# You can choose one of them to build this project.\n# If you prefer GCC, then:\nsudo apt install -y gcc g++\n# Or if you prefer clang, then:\nsudo apt install -y clang-12\n```\n\n----------------------------------------\n\nTITLE: Run WebAssembly App on Kubernetes\nDESCRIPTION: This snippet runs a WebAssembly application on the Kubernetes cluster using `kubectl run`. It deploys a pod named `wasi-demo` with the `wasmedge/example-wasi:latest` image from Docker Hub. The `--annotations` flag specifies that the image should be treated as a WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl run -it --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Creating a Kubernetes Cluster with Kubeadm\nDESCRIPTION: This script installs Kubernetes components and initializes a cluster with kubeadm. It includes adjustments to system configurations such as disabling swap. It requires root access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Install and create a k8s cluster using kubeadm\nsudo apt-get update\nsudo apt-get install -y apt-transport-https curl\necho \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list\n\nsudo apt update\nK_VER=\"1.21.0-00\"\nsudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}\nsudo apt-mark hold kubelet kubeadm kubectl\n\n# Creating a k8s cluster\n$ sudo swapoff -a\n$ sudo vim /etc/fstab\nmark contain swapfile of row\n\n$ cat /etc/cni/net.d/100-crio-bridge.conf\n{\n    \"cniVersion\": \"0.3.1\",\n    \"name\": \"crio\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"hairpinMode\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" },\n            { \"dst\": \"1100:200::1/24\" }\n        ],\n        \"ranges\": [\n            [{ \"subnet\": \"10.85.0.0/16\" }],\n            [{ \"subnet\": \"1100:200::/24\" }]\n        ]\n    }\n}\n$ export CIDR=10.85.0.0/16\n$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock\n\n$ mkdir -p $HOME/.kube\n$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n$ sudo chown $(id -u):$(id -g) $HOME/.kube/config\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge for Android\nDESCRIPTION: Command to run the build script for Android in the WasmEdge source code directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/build.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./utils/android/standalone/build_for_android.sh\n```\n\n----------------------------------------\n\nTITLE: Downloading llama-chat.wasm\nDESCRIPTION: This command downloads the pre-compiled `llama-chat.wasm` file from the LlamaEdge GitHub releases page. This WASM file contains the chat application ready to be executed by WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LO https://github.com/LlamaEdge/LlamaEdge/releases/latest/download/llama-chat.wasm\n```\n\n----------------------------------------\n\nTITLE: Copying WebAssembly Build Artifacts to API Folder\nDESCRIPTION: Bash command for copying the compiled WebAssembly module to the API directory. This step is necessary for deployment as the API handlers will need to access the compiled WebAssembly file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/aws.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncp target/wasm32-wasip1/release/classify.wasm ../../\n```\n\n----------------------------------------\n\nTITLE: Downloading eBPF Example Programs\nDESCRIPTION: Command to download sample eBPF programs for testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/ebpf.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwget https://eunomia-bpf.github.io/wasm-bpf/examples/runqlat/runqlat.wasm\n```\n\n----------------------------------------\n\nTITLE: Uploading WebAssembly Test Files to OpenWRT\nDESCRIPTION: Commands to upload WebAssembly test files from the host to the OpenWRT system using scp.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nscp hello.wasm root@192.168.0.111:/\nscp add.wasm root@192.168.0.111:/\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Docker Images\nDESCRIPTION: Provides examples of using WasmEdge Docker images for compiling and running WebAssembly applications, including a TensorFlow Lite example.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/slim:{{ wasmedge_version }}\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/slim-tf:0.12.1\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite\n$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:0.12.1 wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js\n```\n\n----------------------------------------\n\nTITLE: WASM Code Defining Fibonacci Function\nDESCRIPTION: This WebAssembly module defines a recursive function for calculating the Fibonacci sequence. It uses basic WASM constructs like exporting functions and conditionals with recursive calls. Parameters and results are defined for 32-bit integers, and the function calculates Fibonacci numbers based on provided input parameters.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_32\n\nLANGUAGE: wasm\nCODE:\n```\n(module\\n  (export \\\"fib\\\" (func $fib))\\n  (func $fib (param $n i32) (result i32)\\n    (if\\n      (i32.lt_s (get_local $n)(i32.const 2))\\n      (return (i32.const 1))\\n    )\\n    (return\\n      (i32.add\\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\\n      )\\n    )\\n  )\\n)\\n\n```\n\n----------------------------------------\n\nTITLE: Installing Rustls Plug-in\nDESCRIPTION: Cargo command to install the built Rustls plug-in into the user's Rust binary directory for system-wide access.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Create Kubernetes Cluster with Kind\nDESCRIPTION: This command creates a Kubernetes cluster using Kind. Kind is a tool for running local Kubernetes clusters using Docker container \"nodes\".\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkind create cluster\n```\n\n----------------------------------------\n\nTITLE: Automatic Installation with All-in-One Script\nDESCRIPTION: A one-line command to download and execute the build script that clones and builds WasmEdge on seL4.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Command to verify the installed Go version, which should be >= 1.16 for WasmEdge-go compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom JavaScript Module (my_mod_1.js)\nDESCRIPTION: Example of defining a simple JavaScript module that exports a 'hello_mod_1' function which logs a message to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport function hello_mod_1() {\n  console.log('hello from \"my_mod_1.js\"');\n}\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization Commands\nDESCRIPTION: Commands to achieve better performance using Ahead-of-Time (AoT) compilation mode for the WASM module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/quick-start/install.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Use the AoT mode\nwasmedgec rust_bindgen_funcs_lib.wasm rust_bindgen_funcs_lib.wasm\n\n# Run the demo\n./bindgen_funcs rust_bindgen_funcs_lib.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating Decrypt UDF SQL Script\nDESCRIPTION: Bash commands to generate SQL script for creating the decrypt function in libSQL.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport FUNC_NAME='decrypt'\necho \"DROP FUNCTION IF EXISTS ${FUNC_NAME};\" >> create_${FUNC_NAME}_udf.sql\necho -n \"CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'\" >> create_${FUNC_NAME}_udf.sql\nxxd -p  ../../target/wasm32-wasip1/release/libsql_encrypt_decrypt.wasm | tr -d \"\\n\" >> create_${FUNC_NAME}_udf.sql\necho \"';\" >> create_${FUNC_NAME}_udf.sql\n```\n\n----------------------------------------\n\nTITLE: Testing WasmEdge Interpreter Mode\nDESCRIPTION: Commands to install and test WasmEdge by running WebAssembly examples in interpreter mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/riscv64.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v\nwasmedge version 0.12.0-alpha.1-13-g610cc21f\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10\n89\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2\n4\n```\n\n----------------------------------------\n\nTITLE: Installing GCC for Building WasmEdge QuickJS\nDESCRIPTION: Install the necessary build tools including GCC to compile the WasmEdge QuickJS runtime from source.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Install GCC\nsudo apt update\nsudo apt install build-essential\n```\n\n----------------------------------------\n\nTITLE: Downloading a WASM application\nDESCRIPTION: A command to download a pre-compiled WASM application (hello.wasm) from a GitHub repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Events Recording Service\nDESCRIPTION: Commands to build and deploy the events recording microservice\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/dapr.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd events-service\ncargo build --target wasm32-wasip1 --release\nwasmedgec target/wasm32-wasip1/release/events_service.wasm events_service.wasm\n```\n\nLANGUAGE: bash\nCODE:\n```\ndapr run --app-id events-service \\\n        --app-protocol http \\\n        --app-port 9007 \\\n        --dapr-http-port 3505 \\\n        --log-level debug \\\n        --components-path ../config \\\n        wasmedge events_service.wasm\n```\n\n----------------------------------------\n\nTITLE: Staging and Committing Changes\nDESCRIPTION: Commands to stage changes and commit them with DCO signoff.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit add .\ngit commit -m \" Message  Signed-off-by: Name <email@example.com> \"\n                               OR\n                   git commit -s -m \" Message \"\n```\n\n----------------------------------------\n\nTITLE: Installing TinyGo on Debian-based Linux Systems\nDESCRIPTION: Commands to download and install TinyGo v0.21.0 on Ubuntu or other Debian-based Linux systems with x86 processors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb\nsudo dpkg -i tinygo_0.21.0_amd64.deb`\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests with Custom Library Path\nDESCRIPTION: Command sequence for running WasmEdge tests after building, using a custom library path to ensure the test environment can find the required API libraries.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/build_from_src.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/wasmedge/build_folder>\nLD_LIBRARY_PATH=$(pwd)/lib/api ctest\n```\n\n----------------------------------------\n\nTITLE: Moving TensorFlowLite Libraries to System Path (MacOS)\nDESCRIPTION: Commands to move the extracted TensorFlowLite shared libraries to the system library path on MacOS platforms, making them accessible to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflowlite_c.dylib /usr/local/lib\nmv libtensorflowlite_flex.dylib /usr/local/lib\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly\nDESCRIPTION: WebAssembly module defining a Fibonacci function. This WASM code is used in subsequent Go examples to demonstrate WasmEdge execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_29\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (export \"fib\" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Containerd for OpenYurt Cluster\nDESCRIPTION: Script to install Containerd on the edge node, which provides the container runtime for the OpenYurt cluster. It downloads and extracts Containerd with CNI plugins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport VERSION=\"1.5.7\"\necho -e \"Version: $VERSION\"\necho -e \"Installing libseccomp2 ...\"\nsudo apt install -y libseccomp2\necho -e \"Installing wget\"\nsudo apt install -y wget\n\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\nsha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum\n\nsudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\nsudo systemctl daemon-reload\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Crun with WasmEdge Support\nDESCRIPTION: Commands to clone, configure, build, and install crun with WasmEdge support. This enables containerd to run WebAssembly workloads using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Building Specific Example\nDESCRIPTION: Command to build a specific example (execve) from the wasm-bpf examples.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd execve && make\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests on Windows\nDESCRIPTION: PowerShell commands to execute the WasmEdge test suite for verifying the correctness of the build. The tests are only available when the build option WASMEDGE_BUILD_TESTS is set to ON.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/windows.md#2025-04-21_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\n$Env:PATH += \";$pwd\\build\\lib\\api\"\ncd build\nctest --output-on-failure\ncd -\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions\nDESCRIPTION: Demonstrates how to list and inspect exported functions from a WASM module using WasmEdge C API, including function name retrieval and type information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n\n  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing WasmEdge to the Android Device\nDESCRIPTION: Commands to copy example files and push the WasmEdge build to the Android device using ADB. This transfers the necessary files to the /data/local/tmp directory on the device.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/build.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncp -r examples build/tools/wasmedge/examples\ncd build\nadb push ./tools/wasmedge /data/local/tmp\n```\n\n----------------------------------------\n\nTITLE: Cloning Git Repository (Rust project) (Bash)\nDESCRIPTION: Clones the specified Git repository containing the WasmEdge-WASINN examples. This is a common first step to obtain the necessary source code and related assets for the Rust example project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/pytorch-mobilenet-image/rust\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Windows using winget\nDESCRIPTION: This command installs WasmEdge on Windows 10 systems using the Windows Package Manager (winget).  It simplifies the installation process on Windows.  The package manager handles the download and setup of WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwinget install wasmedge\n```\n\n----------------------------------------\n\nTITLE: Displaying wasmedge Help\nDESCRIPTION: Command to show the help message and usage instructions for the wasmedge CLI tool.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/cli.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge -h\nUSAGE\n   wasmedge [OPTIONS] [--] WASM_OR_SO [ARG ...]\n\n...\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge on Fedora/Red Hat\nDESCRIPTION: Uninstall WasmEdge using dnf package manager on Fedora and Red Hat Linux distributions\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ndnf remove wasmedge\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies (TOML)\nDESCRIPTION: This `Cargo.toml` snippet configures dependencies for the `mysql_async` and `tokio` crates, including patching for WasmEdge-specific socket APIs and enabling TLS support.  It specifies the `default-rustls` feature for `mysql_async` and includes necessary features for `tokio`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\n\n[dependencies]\nmysql_async = { version = \"0.34\", default-features=false, features = [ \"default-rustls\" ], git=\"https://github.com/blackbeam/mysql_async.git\" }\nzstd-sys = \"=2.0.9\"\ntokio = { version = \"1\", features = [ \"io-util\", \"fs\", \"net\", \"time\", \"rt\", \"macros\"] }\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge using a Shell Script\nDESCRIPTION: Install WasmEdge version 0.11.2 by running a shell script. Ensure your system has 'git' and 'wget' installed before executing this command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.2\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Plugins and Module Registration\nDESCRIPTION: Shows how to handle plugin initialization, module registration and error cases when plugins are missing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/* The following API can retrieve the registered modules in the VM context,\n* includes the built-in WASI and the plug-ins.\n*/\n/*\n* This API will return `NULL` if the module instance is not found.\n*/\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString(\"wasi_ephemeral_nn\");\n/* The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n* installed, because the VM context will mock and register the host\n* modules.\n*/\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository in Bash\nDESCRIPTION: Commands to clone the WasmEdge GitHub repository and navigate to the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/linux.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Running HTTP Server WASM Application with Podman\nDESCRIPTION: Deploy a Rust-based HTTP server WebAssembly container, mapping container port 8080 to localhost\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npodman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-server:latest\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function with Module (WasmEdge-Go >= v0.10.0)\nDESCRIPTION: This snippet demonstrates how to define a host function and register it using a `Module` struct in WasmEdge-Go version v0.10.0 and later.  It defines a simple addition function, creates a `Module` instance, adds the function to the module, and then releases the `Module`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\n// Host function body definition.\nfunc host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // add: i32, i32 -> i32\n  res := params[0].(int32) + params[1].(int32)\n\n  // Set the returns\n  returns := make([]interface{}, 1)\n  returns[0] = res\n\n  // Return\n  return returns, wasmedge.Result_Success\n}\n\n// ...\n\n// Create a module instance with the module name \"module\".\nmod := wasmedge.NewModule(\"module\")\n\n// Create and add a function instance into the module instance with export name \"add\".\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},\n  []wasmedge.ValType{wasmedge.ValType_I32},\n)\nhostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)\n// The third parameter is the pointer to the additional data object.\n// Developers should guarantee the life cycle of the data, and it can be `nil`\n// if the external data is not needed.\nfunctype.Release()\nmod.AddFunction(\"add\", hostfunc)\n\n// The module instances should be released.\n// Developers should __NOT__ release the instances added into the module instance objects.\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: Listing Exported WASM Functions\nDESCRIPTION: Example showing how to list exported functions from a WASM module using WasmEdge VM APIs. Includes loading a WASM file, getting function count, and retrieving function names and types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, \"fibonacci.wasm\");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the overflowed data will be discarded.\n   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.\n   */\n  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf(\"Get exported function string length: %u, name: %s\\n\", Size, Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  return 0;\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet exported function string length: 3, name: fib\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Function with WasmEdge C++ SDK\nDESCRIPTION: This snippet demonstrates how to use the WasmEdge C++ SDK to create a VM context, execute a WebAssembly function from a file, and handle the result. It includes WASI support configuration and proper resource management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c++/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <iostream>\n\nint main(int argc, char** argv) {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext* conf_cxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(conf_cxt, WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext* vm_cxt = WasmEdge_VMCreate(conf_cxt, nullptr);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value params[1] = { WasmEdge_ValueGenI32(40) };\n  WasmEdge_Value returns[1];\n  /* Function name. */\n  WasmEdge_String func_name = WasmEdge_StringCreateByCString(\"fib\");\n  /* Run the WASM function from file. */\n  WasmEdge_Result res = WasmEdge_VMRunWasmFromFile(vm_cxt, argv[1], func_name, params, 1, returns, 1);\n\n  if (WasmEdge_ResultOK(res)) {\n    std::cout << \"Get result: \" << WasmEdge_ValueGetI32(returns[0]) << std::endl;\n  } else {\n    std::cout << \"Error message: \" << WasmEdge_ResultGetMessage(res) << std::endl;\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(vm_cxt);\n  WasmEdge_ConfigureDelete(conf_cxt);\n  WasmEdge_StringDelete(func_name);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Registering AST Module in C\nDESCRIPTION: Demonstrates how to instantiate an AST module context into a named Module instance and register it in the Store context using the Executor API. It includes creation of necessary contexts, registration, and proper resource cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/*\n * Register the WASM module into the store with the export module name\n * \"mod\".\n */\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing Bundled JavaScript in WasmEdge\nDESCRIPTION: Command to run the bundled JavaScript file using WasmEdge QuickJS runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/npm.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs\n```\n\n----------------------------------------\n\nTITLE: Initialize Events Database\nDESCRIPTION: This command initializes the events database table by sending a request to the events microservice. It checks the status and confirms the database table creation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:9007/init\n{\"status\":true}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL on macOS\nDESCRIPTION: Command to install OpenSSL on macOS using Homebrew package manager.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install openssl\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Crun on Ubuntu\nDESCRIPTION: Commands to install the required dependencies for building crun with WasmEdge support on Ubuntu 20.04. These packages are needed for the compilation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y make git gcc build-essential pkgconf libtool \\\n    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n    go-md2man libtool autoconf python3 automake\n```\n\n----------------------------------------\n\nTITLE: Compiling WasmEdge QuickJS for Better Performance\nDESCRIPTION: Command to use the wasmedge compile utility to add native machine code to the WebAssembly file for improved performance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/tensorflow.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile target/wasm32-wasip1/release/wasmedge_quickjs.wasm wasmedge_quickjs_nn.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing ONNX Runtime for Piper Backend\nDESCRIPTION: Installs ONNX Runtime 1.14.1 required for the WASI-NN plugin with Piper backend. The script downloads, extracts, and installs the ONNX Runtime libraries to system directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LO https://github.com/microsoft/onnxruntime/releases/download/v1.14.1/onnxruntime-linux-x64-1.14.1.tgz\ntar zxf onnxruntime-linux-x64-1.14.1.tgz\nmv onnxruntime-linux-x64-1.14.1/include/* /usr/local/include/\nmv onnxruntime-linux-x64-1.14.1/lib/* /usr/local/lib/\nrm -rf onnxruntime-linux-x64-1.14.1.tgz onnxruntime-linux-x64-1.14.1\nldconfig\n```\n\n----------------------------------------\n\nTITLE: Query Events Database After Usage\nDESCRIPTION: This command queries the events database again after using the grayscale and classification microservices, retrieving the updated event records that have been added to the database.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:9007/events\n[{\"id\":1,\"event_ts\":1665358852918,\"op_type\":\"grayscale\",\"input_size\":68016},{\"id\":2,\"event_ts\":1665358853114,\"op_type\":\"classify\",\"input_size\":68016}]\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Building crun\nDESCRIPTION: Command to install dependencies required for building crun from source. crun is the container runtime that integrates with WasmEdge for running WebAssembly workloads.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y make git gcc build-essential pkgconf libtool \\\n  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n  go-md2man libtool autoconf python3 automake\n```\n\n----------------------------------------\n\nTITLE: Adding wasm32-wasip1 Target in Rust\nDESCRIPTION: Adds the WebAssembly WASI target to the Rust toolchain for compiling to WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/python/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Checking WebAssembly Test Job Logs in Kubernetes\nDESCRIPTION: This command retrieves and displays the logs from the WebAssembly test job after it has completed execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl logs job/wasm-test\n```\n\n----------------------------------------\n\nTITLE: Installing Go on KubeEdge Master Node\nDESCRIPTION: This snippet installs Go version 1.17.3 on a Linux system, adds it to the system PATH, and verifies the Go installation. It requires internet access to download the Go tarball.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install Go\n$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz\n$ tar xzvf go1.17.3.linux-amd64.tar.gz\n\n$ export PATH=/home/${user}/go/bin:$PATH\n$ go version\ngo version go1.17.3 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository\nDESCRIPTION: Command to clone the WasmEdge source code repository from GitHub.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Sourcing WasmEdge Environment Variables\nDESCRIPTION: This command sources the environment setup script to make the WasmEdge binaries available in the current shell session. It is required to add WasmEdge executables to the PATH for easy access. The script modifies the environment variables to include WasmEdge's bin directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsource $HOME/.wasmedge/env\n```\n\n----------------------------------------\n\nTITLE: Building Rustls Plug-in\nDESCRIPTION: Cargo command to build the Rustls plug-in in release mode, generating the compiled binary in the target/release directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --release\n```\n\n----------------------------------------\n\nTITLE: Using eBPF Technical Reference\nDESCRIPTION: Code reference showing eBPF as a Linux kernel space VM bytecode format, contrasting with WebAssembly's user space VM application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/wasmedge/comparison.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\neBPF\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge CLI Examples on Android\nDESCRIPTION: Series of commands to run various WasmEdge examples on the Android device using the CLI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/build.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd /data/local/tmp/wasmedge/examples\n../wasmedge hello.wasm 1 2 3\n../wasmedge --reactor add.wasm add 2 2\n../wasmedge --reactor fibonacci.wasm fib 8\n../wasmedge --reactor factorial.wasm fac 12\ncd js\n./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3\n```\n\n----------------------------------------\n\nTITLE: Rust Build Environment Dockerfile Setup\nDESCRIPTION: Dockerfile section that sets up the Rust build environment with necessary dependencies\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_1\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase\nWORKDIR /src\nRUN <<EOT bash\n    set -ex\n    apt-get update\n    apt-get install -y \\\n        git \\\n        clang\n    rustup target add wasm32-wasip1\nEOT\n```\n\n----------------------------------------\n\nTITLE: Configuring CRI-O to use crun as default runtime\nDESCRIPTION: This configuration sets crun as the default runtime for CRI-O. It requires creating two configuration files: /etc/crio/crio.conf and /etc/crio/crio.conf.d/01-crio-runc.conf.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n[crio.runtime]\ndefault_runtime = \"crun\"\n```\n\nLANGUAGE: conf\nCODE:\n```\n[crio.runtime.runtimes.runc]\nruntime_path = \"/usr/lib/cri-o-runc/sbin/runc\"\nruntime_type = \"oci\"\nruntime_root = \"/run/runc\"\n\n[crio.runtime.runtimes.crun]\nruntime_path = \"/usr/bin/crun\"\nruntime_type = \"oci\"\nruntime_root = \"/run/crun\"\n```\n\n----------------------------------------\n\nTITLE: Configuring containerd to use crun\nDESCRIPTION: Steps to configure containerd to use crun as the OCI runtime, including creating the config file and applying a patch.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir -p /etc/containerd/\nsudo bash -c \"containerd config default > /etc/containerd/config.toml\"\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff\nsudo patch -d/ -p0 < containerd_config.diff\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Extensions\nDESCRIPTION: Command to install WasmEdge with TensorFlow and Image extensions for additional functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.12.1\n```\n\n----------------------------------------\n\nTITLE: Setting up KubeEdge Master Node\nDESCRIPTION: Downloads and initializes KubeEdge on the master node using keadm, specifying the advertise address and kubeconfig path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz\ntar xzvf keadm-v1.8.0-linux-amd64.tar.gz\ncd keadm-v1.8.0-linux-amd64/keadm/\nsudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config\n```\n\n----------------------------------------\n\nTITLE: DCO Signoff Format for Git Commits\nDESCRIPTION: The required format for the Developer Certificate of Origin (DCO) signoff line that must be added to each git commit message. This signoff confirms the contributor has the right to make the contribution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/overview.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nSigned-off-by: John Doe <john.doe@example.com>\n```\n\n----------------------------------------\n\nTITLE: WasmEdge AOT Compiler Implementation in C\nDESCRIPTION: C code example demonstrating how to use the WasmEdge AOT compiler to compile a WebAssembly file for faster execution. The example compiles a Fibonacci function WASM file into an AOT-compiled version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_76\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\",\n                               \"fibonacci-aot.wasm\");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting WasmEdge String to C String with C API\nDESCRIPTION: This C code demonstrates how to copy the content of a `WasmEdge_String` object into a C string buffer using the `WasmEdge_StringCopy()` function. The code also retrieves the length of the string and prints the copied string to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n\"char Buf[256];\nWasmEdge_String Str =\n    WasmEdge_StringCreateByCString(\\\"test_wasmedge_string\\\");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf(\\\"String: %s\\\\n\\\", Buf);\n/* Will print \\\"test_wasmedge_string\\\". */\"\n```\n\n----------------------------------------\n\nTITLE: Installing crun and WasmEdge on Fedora\nDESCRIPTION: Commands to install crun and WasmEdge packages on a Fedora Linux distribution using the dnf package manager.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf -y install wasmedge\nsudo dnf -y install crun\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on seL4 with Docker\nDESCRIPTION: This snippet shows how to use the pre-built Docker image for seL4 build environment. It pulls the Docker image and runs a container with the current directory mounted.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/sel4_build\n$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build\n(docker) root#\n```\n\n----------------------------------------\n\nTITLE: Cloning Git Repository (Bash)\nDESCRIPTION: Clones the specified Git repository containing the WasmEdge-WASINN examples. This is a common first step to obtain the necessary source code and related assets for the example project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/pytorch-mobilenet-image/\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Command to verify the installed Go version which should be >= 1.16\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\\ngo version go1.16.5 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Pulling WasmEdge Docker Image in Bash\nDESCRIPTION: Command to pull the latest WasmEdge Docker image from Docker Hub.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/linux.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull wasmedge/wasmedge # Pulls the latest - wasmedge/wasmedge:latest\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Grayscale Image Service\nDESCRIPTION: Commands to build and deploy the image grayscale microservice using WasmEdge and Dapr\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/dapr.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd image-api-grayscale\ncargo build --target wasm32-wasip1 --release\nwasmedgec ./target/wasm32-wasip1/release/image-api-grayscale.wasm image-api-grayscale.wasm\n```\n\nLANGUAGE: bash\nCODE:\n```\ndapr run --app-id image-api-grayscale \\\n        --app-protocol http \\\n        --app-port 9005 \\\n        --dapr-http-port 3503 \\\n        --components-path ../config \\\n        --log-level debug \\\n wasmedge image-api-grayscale.wasm\n```\n\n----------------------------------------\n\nTITLE: Downloading SuperEdge Installation Package for Edge Kubernetes\nDESCRIPTION: Command to download the SuperEdge installation package. You need to select the appropriate package based on your node CPU architecture (amd64 or arm64).\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\narch=amd64 version=v0.6.0 && rm -rf edgeadm-linux-* && wget https://superedge-1253687700.cos.ap-guangzhou.myqcloud.com/$version/$arch/edgeadm-linux-containerd-$arch-$version.tgz && tar -xzvf edgeadm-linux-* && cd edgeadm-linux-$arch-$version && ./edgeadm\n```\n\n----------------------------------------\n\nTITLE: Building OpenSSL 1.1 from Source for Legacy Systems\nDESCRIPTION: Commands to download, verify, and build OpenSSL 1.1 from source for legacy systems like CentOS 7.6 or when a custom build is preferred. This includes installing a newer version of Perl required for the OpenSSL configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_crypto.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Download and extract the OpenSSL source to the current directory.\ncurl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz\necho \"40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz\" | sha256sum -c\ntar -xf openssl-1.1.1n.tar.gz\ncd ./openssl-1.1.1n\n# OpenSSL configure need newer perl.\ncurl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz\ntar -xf perl-5.34.0.tar.gz\ncd perl-5.34.0\nmkdir localperl\n./Configure -des -Dprefix=$(pwd)/localperl/\nmake -j\nmake install\nexport PATH=\"$(pwd)/localperl/bin/:$PATH\"\ncd ..\n# Configure by previous perl.\nmkdir openssl\n./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl\nmake -j\nmake test\nmake install\ncd ..\n# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.\n# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.\n```\n\n----------------------------------------\n\nTITLE: Downloading TensorFlow-Lite Dependencies\nDESCRIPTION: Script to download TensorFlow-Lite shared libraries for WasmEdge with version and platform configuration\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nVERSION=TF-2.12.0-CC\nPLATFORM=manylinux2014_x86_64\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/$VERSION/WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz\ntar -zxf WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz\nrm -f WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Uploading Test Files to OpenWRT\nDESCRIPTION: Commands to upload WebAssembly test files to OpenWRT using SCP.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nscp hello.wasm root@192.168.0.111:/\nscp add.wasm root@192.168.0.111:/\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge for All Users\nDESCRIPTION: Installs WasmEdge into a system directory (/usr/local) to make it available for all users. Requires root or sudo privileges.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local\n```\n\n----------------------------------------\n\nTITLE: Applying Containerd Configuration Patch\nDESCRIPTION: Commands to apply the configuration patch to containerd and restart the service to apply changes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo patch -d/ -p0 < config.toml.diff\nsudo systemctl restart containerd\n```\n\n----------------------------------------\n\nTITLE: Testing the Server Response - Bash\nDESCRIPTION: This command uses curl to send a request to the running server to retrieve the HTML content generated by the React SSR application. It verifies that the server is responding correctly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8001\n```\n\n----------------------------------------\n\nTITLE: Running Hello World WebAssembly Example\nDESCRIPTION: This command executes a simple hello.wasm WebAssembly program that prints a greeting and performs a basic calculation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge_emit /usr/bin/hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI in WasmEdge 0.9.1 C API\nDESCRIPTION: Example of WASI initialization using WasmEdge 0.9.1 C API. It demonstrates creating a VM context, retrieving the WASI import object, and initializing it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/* The following API can retrieve the pre-registration import objects from the VM context. */\n/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */\nWasmEdge_ImportObjectContext *WasiObject =\n    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );\n\n/* ... */\n\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Loading Plugins in VM Context (Pre-0.12.0)\nDESCRIPTION: Example of loading plugins in a VM context before version 0.12.0. It demonstrates configuring host registrations for WASI Crypto modules and listing the loaded modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(Conf,\n                                      WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\nWasmEdge_String Names[32];\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\nuint32_t ModuleLen = WasmEdge_StoreListModule(StoreCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/*\n * Will print:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Code to WebAssembly\nDESCRIPTION: Commands for adding wasm32 target and building the Rust code into WebAssembly\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n\ncd flow/rust_mobilenet_food\ncargo build --target wasm32-wasip1 --release\n# The output WASM will be target/wasm32-wasip1/release/rust_mobilenet_food_lib.wasm\n\n# Copy the wasm bytecode file to the flow/ directory\ncp target/wasm32-wasip1/release/rust_mobilenet_food_lib.wasm ../\n```\n\n----------------------------------------\n\nTITLE: Testing TensorFlow Image Recognition with curl\nDESCRIPTION: Shell command to test the TensorFlow image recognition service by sending an image file to the server using curl. Demonstrates how to send binary data for inference and receive classification results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ curl http://localhost:3000/classify -X POST --data-binary \"@grace_hopper.jpg\"\nmilitary uniform is detected with 206/255 confidence\n```\n\n----------------------------------------\n\nTITLE: Running eBPF Examples with WasmEdge\nDESCRIPTION: Command to execute eBPF examples using WasmEdge CLI with the plugin path set.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/ebpf.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nWASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ ./build/tools/wasmedge/wasmedge execve.wasm\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge\nDESCRIPTION: Installs the WasmEdge shared library using a script. Optionally includes TensorFlow and Image extensions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.2\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.11.2\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly target for Rust\nDESCRIPTION: Command to add the wasm32-wasip1 target to Rust for generating WebAssembly bytecode, necessary for building serverless functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Running JavaScript Node.js Server with Podman\nDESCRIPTION: Deploy a Node.js based HTTP server WebAssembly container using WasmEdge runtime\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npodman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/node-example-server:latest\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Fibonacci Example With Run Command\nDESCRIPTION: Shows the equivalent command using the 'run' subcommand, which produces identical execution and results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/run.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge run --reactor fibonacci.wasm fib 10\n```\n\n----------------------------------------\n\nTITLE: Testing the HTTP Server with cURL\nDESCRIPTION: Command to test the HTTP server by sending a POST request using cURL. The server will respond by prepending 'echo:' to the request body.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"WasmEdge\" -X POST http://localhost:8001/\necho:WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge-TensorFlow-Tools on Android\nDESCRIPTION: Commands to access the Android shell, set up the environment, and run the show-tflite-tensor tool to examine the TensorFlow Lite model file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ adb shell\nsirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor\nsirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite\nINFO: Initialized TensorFlow Lite runtime.\nInput tensor nums: 1\n    Input tensor name: module/hub_input/images_uint8\n        dimensions: [1 , 224 , 224 , 3]\n        data type: UInt8\n        tensor byte size: 150528\nOutput tensor nums: 1\n    Output tensor name: module/prediction\n        dimensions: [1 , 965]\n        data type: UInt8\n        tensor byte size: 965\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types in WasmEdge\nDESCRIPTION: Shows how to retrieve function types by name from the WasmEdge VM context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Visualizing WasmEdge Execution Flow with Mermaid Diagram\nDESCRIPTION: This mermaid diagram illustrates the execution flow of WasmEdge, including the loader, validator, instantiator, engines, and various components for host function calls and runtime data management. It shows the process from loading WASM files to execution and interaction with system interfaces.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/internal.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    A[WASM] -->|From files or buffers| B(Loader)\n    B -->|Create WASM AST| C(Validator)\n    C -->|Validate WASM Module| D[Instantiator]\n    D -->|Create WASM instances| E{AOT section found?}\n    E -->|Yes| F[AOT Engine]\n    E -->|No| G[Interpreter Engine]\n    F <-->|Execute WASM| H[WasmEdge Engine]\n    G <-->|Execute WASM| H[WasmEdge Engine]\n    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]\n    H1 <-->|Call Host Functions| I[Host Functions]\n    H1 <-->|Access Runtime Data| J[Runtime Data Manager]\n    I <-->|System Call| I1[WASM System Interface, WASI]\n    I <-->|AI-related Function Call| I2[WASI-NN]\n    I <-->|Crypto-related Function Call| I3[WASI-Crypto]\n    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]\n    J <-->|Access Memory| J1[Memory Manager]\n    J <-->|Access Stack| J2[Stack Manager]\n    J <-->|Access Cross Module| J3[Registered Module/Function Manager]\n```\n\n----------------------------------------\n\nTITLE: Installing WASI SDK\nDESCRIPTION: Commands to download and install the WASI SDK toolkit for building WebAssembly programs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/ebpf.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ && sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n```\n\n----------------------------------------\n\nTITLE: Downloading CRI-O Configuration Files for WebAssembly Container\nDESCRIPTION: Commands to download the required configuration files for running a WebAssembly container in CRI-O. These files define the sandbox and container settings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json\n```\n\n----------------------------------------\n\nTITLE: Downloading CRI-O Configuration Files for HTTP Server Container\nDESCRIPTION: Commands to download the required configuration files for running a WebAssembly HTTP server container in CRI-O. These files define the sandbox and container settings for the HTTP server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json\nwget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json\n```\n\n----------------------------------------\n\nTITLE: Implementing Image Grayscale Conversion in Rust\nDESCRIPTION: Rust function that reads image data from STDIN, converts it to grayscale, and outputs the result to STDOUT. It handles different image formats and uses the 'image' crate for processing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse hex;\nuse std::io::{self, Read};\nuse image::{ImageOutputFormat, ImageFormat};\n\nfn main() {\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();\n  let img = image::load_from_memory(&buf).unwrap();\n  let filtered = img.grayscale();\n  let mut buf = vec![];\n  match image_format_detected {\n    ImageFormat::Gif => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();\n    },\n    _ => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();\n    },\n  };\n  io::stdout().write_all(&buf).unwrap();\n  io::stdout().flush().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Function Listing Example in Bash\nDESCRIPTION: Shows how to compile the exported function listing example with the WasmEdge library and run it to display the 'fib' function from the fibonacci.wasm module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge via Nix\nDESCRIPTION: Installs WasmEdge using the Nix package manager by utilizing the provided flake.nix in the repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnix profile install github:WasmEdge/WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Downloading and Installing WasmEdge\nDESCRIPTION: Installs the WasmEdge runtime using a shell command. Requires git and wget as prerequisites.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_version }}\n```\n\n----------------------------------------\n\nTITLE: Check Logs for Wasm Job\nDESCRIPTION: This command retrieves the logs from the `wasm-test` job in the Kubernetes cluster. This allows verification that the WebAssembly job ran successfully.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nkubectl logs job/wasm-test\n```\n\n----------------------------------------\n\nTITLE: Checking Pod Status in Kubernetes\nDESCRIPTION: This command checks the status of pods in the Kubernetes cluster using the crictl tool. It shows all containers, including those that have exited.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ncrictl ps -a\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests\nDESCRIPTION: Command to run the WasmEdge test suite after building. This verifies the correctness of the built WasmEdge binaries. The tests are only available when the WASMEDGE_BUILD_TESTS CMake option is enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/build_from_src.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <path/to/wasmedge/build_folder>\nLD_LIBRARY_PATH=$(pwd)/lib/api ctest\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Static Library with CMake\nDESCRIPTION: These CMake commands show how to build WasmEdge from source with options for creating a static library. It's recommended to use the wasmedge/wasmedge:latest docker image for the required packages.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/library.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncmake -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_LINK_LLVM_STATIC=ON -DWASMEDGE_BUILD_SHARED_LIB=Off -DWASMEDGE_BUILD_STATIC_LIB=On -DWASMEDGE_LINK_TOOLS_STATIC=On -DWASMEDGE_BUILD_PLUGINS=Off\ncmake --build build\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Installing OpenVINO Dependencies for WASI-NN Plugin\nDESCRIPTION: These commands install the OpenVINO dependencies for the WASI-NN plugin, which enables running OpenVINO models within WasmEdge. The script adds the Intel OpenVINO repository, imports the GPG key, updates the package list, and installs the OpenVINO package. The `ldconfig` command updates the shared library cache.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nwget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\nsudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\necho \"deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main\" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list\nsudo apt update\nsudo apt-get -y install openvino\nldconfig\n```\n\n----------------------------------------\n\nTITLE: Installing PyTorch Dependencies for WASI-NN\nDESCRIPTION: Installs PyTorch 1.8.2 LTS C++ libraries required for the WASI-NN plugin with PyTorch backend. The script downloads, extracts, and configures the library path for PyTorch.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nexport PYTORCH_VERSION=\"1.8.2\"\n# For the Ubuntu 20.04 or above, use the libtorch with cxx11 abi.\nexport PYTORCH_ABI=\"libtorch-cxx11-abi\"\n# For the manylinux2014, please use the without cxx11 abi version:\n#   export PYTORCH_ABI=\"libtorch\"\ncurl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\nunzip -q \"${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nrm -f \"${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nexport LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$(pwd)/libtorch/lib\n```\n\n----------------------------------------\n\nTITLE: Configuring youki's config.json for WASM Modules\nDESCRIPTION: This JSON snippet shows the required configuration in youki's config.json file to run WebAssembly modules. It specifies the OCI handler and the entrypoint for the WASM container.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"ociVersion\": \"1.0.2-dev\",\n\"annotations\": {\n    \"run.oci.handler\": \"wasm\"\n},\n\"process\": {\n    \"args\": [\n        \"wasi_example_main.wasm\",\n        ],\n```\n\n----------------------------------------\n\nTITLE: Downloading and Installing WasmEdge using Bash\nDESCRIPTION: This snippet illustrates how to download and install WasmEdge using a simple bash command. Prerequisites include having 'git' and 'wget' installed on the system.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1\n```\n\n----------------------------------------\n\nTITLE: Setting Up Kubernetes Cluster for OpenYurt\nDESCRIPTION: Commands to set up a Kubernetes cluster as a prerequisite for OpenYurt conversion. It includes adding Kubernetes package repositories and installing Kubernetes components.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get update && sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https\n// add K8s source\n$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -\n$ sudo tee /etc/apt/sources.list.d/kubernetes.list <<EOF\n$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\n// install K8s components 1.18.9\n$ sudo apt-get update && sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00\n// Initialize the master node\n$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \\\n--apiserver-advertise-address=192.168.3.167 \\\n--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers\n// join the work node\n$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \\\n   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository\nDESCRIPTION: Command to clone the WasmEdge repository from GitHub, which contains the Rustls plug-in source code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\n```\n\n----------------------------------------\n\nTITLE: Installing Crun Dependencies on Ubuntu\nDESCRIPTION: Apt commands to install the necessary dependencies for building crun with WasmEdge support on Ubuntu 20.04.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install -y make git gcc build-essential pkgconf libtool \\\n    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n    go-md2man libtool autoconf python3 automake\n```\n\n----------------------------------------\n\nTITLE: Manual Installation Steps for Memory Management\nDESCRIPTION: A sequence of commands to manually clone the repository, modify the build script for reduced parallelization, and execute the build process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ~\ngit clone https://github.com/second-state/wasmedge-seL4.git\ncd wasmedge-seL4\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Version Check Example\nDESCRIPTION: C code demonstrating how to retrieve various version information from the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests\nDESCRIPTION: Commands to run the WasmEdge test suite to verify the correctness of the build. Tests are only available when WASMEDGE_BUILD_TESTS is enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# In docker\ncd <path/to/wasmedge/build_folder>\nLD_LIBRARY_PATH=$(pwd)/lib/api ctest\n```\n\n----------------------------------------\n\nTITLE: Cloning the WasmEdge Documentation Repository\nDESCRIPTION: Command to clone the WasmEdge documentation repository from GitHub to your local machine.\nSOURCE: https://github.com/wasmedge/docs/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/docs.git\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge Project in Go\nDESCRIPTION: Sets up a new Go project for WasmEdge development by creating a directory and initializing a Go module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Source Code\nDESCRIPTION: Commands to clone the WasmEdge repository in the RISCV-Lab environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/riscv64.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git\nubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Extensions\nDESCRIPTION: Bash command to install WasmEdge with TensorFlow and Image extensions for Linux and Darwin x86_64 platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.11.2\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Function Using CallingFrameContext in C\nDESCRIPTION: Example of how to access memory in a host function using the new WasmEdge_CallingFrameContext introduced in version 0.11.0. This replaces the previous method of directly using the memory instance context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.11.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /* Get the 0th memory instance of the module of the top frame on the stack. */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Simulated Data Source - Bash\nDESCRIPTION: This snippet illustrates how to download a video file and stream it to YoMo using a Go program. It serves as simulated input for the image processing workflow defined in the handler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Download a video file\nwget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'\n\n# Stream the video to YoMo\ngo run ./source/main.go ./source/hot-dog.mp4\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with CMake\nDESCRIPTION: Commands to create build directory and compile WasmEdge using CMake in Release mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/riscv64.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build\nubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j\n```\n\n----------------------------------------\n\nTITLE: Building and Running WebAssembly with Go and WasmEdge\nDESCRIPTION: These bash commands demonstrate how to build the Go host application and run the compiled WebAssembly file. The example shows running the application with a specific WebAssembly file and input text file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/app.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n\n$ ./read_file rust_readfile/target/wasm32-wasip1/debug/rust_readfile.wasm file.txt\nRust: Opening input file \"file.txt\"...\nRust: Read input file \"file.txt\" succeeded.\nRust: Please input the line number to print the line of file.\n# Input \"5\" and press Enter.\n5\n# The output will be the 5th line of `file.txt`:\nabcDEF___!@#$%^\n# To terminate the program, send the EOF (Ctrl + D).\n^D\n# The output will print the terminate message:\nRust: Process end.\n```\n\n----------------------------------------\n\nTITLE: Creating Table Type Context in C\nDESCRIPTION: Example of creating and using a Table Type context with externref type and limits, showing how to retrieve and verify reference types and limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenExternRef(), TabLim);\n\nWasmEdge_ValType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nbool IsTypeExternRef = WasmEdge_ValTypeIsExternRef(GotRefType);\nbool IsTypeRef = WasmEdge_ValTypeIsRef(GotRefType);\nbool IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(GotRefType);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Feature Branch\nDESCRIPTION: Command to create and switch to a new feature branch for development.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my-new-branch\n```\n\n----------------------------------------\n\nTITLE: Configuring CRI-O Runtime Definition for crun\nDESCRIPTION: Configuration for the CRI-O runtime definition file to add crun as an available runtime. This extends the /etc/crio/crio.conf.d/01-crio-runc.conf file with crun runtime details.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md#2025-04-21_snippet_2\n\nLANGUAGE: conf\nCODE:\n```\n[crio.runtime.runtimes.runc]\nruntime_path = \"/usr/lib/cri-o-runc/sbin/runc\"\nruntime_type = \"oci\"\nruntime_root = \"/run/runc\"\n# The above is the original content\n\n# Add our crunw runtime here\n[crio.runtime.runtimes.crun]\nruntime_path = \"/usr/bin/crun\"\nruntime_type = \"oci\"\nruntime_root = \"/run/crun\"\n```\n\n----------------------------------------\n\nTITLE: Executing WASI-NN Plugin with LLAMA Example on Windows\nDESCRIPTION: PowerShell commands to set up the environment and run the LLAMA example using the WASI-NN plugin on Windows.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$env:PATH += \";$pwd\\build\\lib\\api\"\n$env:WASMEDGE_PLUGIN_PATH = \"$pwd\\build\\plugins\"\n\nwget https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/wasmedge-ggml/llama/wasmedge-ggml-llama.wasm\nwget https://huggingface.co/QuantFactory/Meta-Llama-3-8B-Instruct-GGUF/blob/main/Meta-Llama-3-8B-Instruct.Q5_K_M.gguf\nwasmedge --dir .:. --env llama3=true --env n_gpu_layers=100 --nn-preload default:GGML:AUTO:Meta-Llama-3-8B-Instruct.Q5_K_M.gguf wasmedge-ggml-llama.wasm default\n```\n\n----------------------------------------\n\nTITLE: Downloading Video File for Streaming\nDESCRIPTION: This Bash command downloads a video file from a specified URL and places it in the source folder. This video will be streamed to the YoMo framework for image frame processing by the WasmEdge function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/yomo.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Download a video file\n wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Unified CLI in Go\nDESCRIPTION: Example of using the RunWasmEdgeUnifiedCLI() API, which provides access to the unified 'wasmedge' tool with all subcommands, passing command line arguments directly from the application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_73\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeUnifiedCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Logging into Guest Linux on seL4\nDESCRIPTION: This command logs into the guest Linux system running on seL4 using the root account.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbuildroot login: root\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge QuickJS Repository using Git\nDESCRIPTION: This set of commands clones the WasmEdge-QuickJs GitHub repository and changes the current directory to 'wasmedge-quickjs'. It sets up the environment to run JavaScript with AI inference capabilities in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory Structure\nDESCRIPTION: Bash commands for setting up the basic directory structure for a WasmEdge plugin project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir testplugin\ncd testplugin\nmkdir src include build\n```\n\n----------------------------------------\n\nTITLE: Installing Podman Using Linuxbrew\nDESCRIPTION: Commands to install Podman using Linuxbrew and verify its version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> brew install podman\n\n# Check your podman version and you could add it to your $PATH, too.\n> $HOME/.linuxbrew/opt/podman/bin/podman --version\n```\n\n----------------------------------------\n\nTITLE: Creating Server Directory\nDESCRIPTION: Command to create a new directory for the server code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nmkdir server\n```\n\n----------------------------------------\n\nTITLE: Host Registration Enum Definition in WasmEdge C API\nDESCRIPTION: Defines the enum for host registrations that can be enabled in WasmEdge, specifically for WASI and WasmEdge_Process functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0,\n  WasmEdge_HostRegistration_WasmEdge_Process\n};\n```\n\n----------------------------------------\n\nTITLE: Creating New Rust Crate for WasmEdge Server\nDESCRIPTION: Command to generate a new Rust crate for server-side WebAssembly rendering using WasmEdge\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo new server-wasmedge\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Compiler Target in Rust\nDESCRIPTION: Command to add the wasm32-wasip1 compiler target to Rust, enabling WebAssembly bytecode generation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/netlify.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge on Android\nDESCRIPTION: Commands to set up library path and execute the WasmEdge program on Android device through ADB shell.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/ndk.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ adb shell\nsirius:/ $ cd /data/local/tmp\nsirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH\nsirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory Structure for WasmEdge Plug-in\nDESCRIPTION: Bash commands to set up the basic directory structure for a WasmEdge plug-in project, including source, include, and build directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir testplugin\ncd testplugin\nmkdir src include build\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Execution Flow Diagram with Mermaid\nDESCRIPTION: A detailed flowchart showing the complete execution path of WasmEdge. It demonstrates how WASM modules flow from loading through validation, instantiation, and execution via either AOT or interpreter engines, with connections to host functions and runtime data management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/internal.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    A[WASM] -->|From files or buffers| B(Loader)\n    B -->|Create WASM AST| C(Validator)\n    C -->|Validate WASM Module| D[Instantiator]\n    D -->|Create WASM instances| E{AOT section found?}\n    E -->|Yes| F[AOT Engine]\n    E -->|No| G[Interpreter Engine]\n    F <-->|Execute WASM| H[WasmEdge Engine]\n    G <-->|Execute WASM| H[WasmEdge Engine]\n    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]\n    H1 <-->|Call Host Functions| I[Host Functions]\n    H1 <-->|Access Runtime Data| J[Runtime Data Manager]\n    I <-->|System Call| I1[WASM System Interface, WASI]\n    I <-->|AI-related Function Call| I2[WASI-NN]\n    I <-->|Crypto-related Function Call| I3[WASI-Crypto]\n    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]\n    J <-->|Access Memory| J1[Memory Manager]\n    J <-->|Access Stack| J2[Stack Manager]\n    J <-->|Access Cross Module| J3[Registered Module/Function Manager]\n```\n\n----------------------------------------\n\nTITLE: Running N-Body Simulation WebAssembly Example\nDESCRIPTION: Command to execute the nbody-c.wasm example, which runs an N-body simulation using WasmEdge on seL4.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge_emit /usr/bin/nbody-c.wasm 10\n```\n\n----------------------------------------\n\nTITLE: Markdown Info Block for Work in Progress\nDESCRIPTION: A markdown info block indicating the documentation section is under development\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/fuzzing.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n:::info\nWork in Progress\n:::\n```\n\n----------------------------------------\n\nTITLE: Starting Containerd Service\nDESCRIPTION: A simple command to start the containerd service after configuration changes have been made. This step is crucial for the new settings to take effect.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsystemctl start containerd\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Windows\nDESCRIPTION: Installs WasmEdge on Windows 10 using the Windows Package Manager Client (winget).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nwinget install wasmedge\n```\n\n----------------------------------------\n\nTITLE: Invoking WASM Function in WasmEdge 0.10.0 (C)\nDESCRIPTION: Example of loading, instantiating, and invoking a WASM function using the updated Executor API in WasmEdge version 0.10.0. This method requires retrieving the function instance before invocation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Ignore the unchanged steps before validation. Please refer to the sample code above.\n */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Retrieve the function instance by name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\nWasmEdge_StringDelete(FuncName);\n/* Invoke the function. */\nWasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };\nWasmEdge_Value Returns[1];\nRes = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\nWasmEdge_ASTModuleDelete(ASTCxt);\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ValidatorDelete(ValidCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing ggml backend dependencies\nDESCRIPTION: This command installs the `libopenblas-dev` package, which is a dependency for the `ggml` backend. It is required for running inference with Llama 2 series models.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\napt update && apt install -y libopenblas-dev # You may need sudo if the user is not root.\n```\n\n----------------------------------------\n\nTITLE: Making the Build Script Executable\nDESCRIPTION: This command makes the build.sh script executable before running it for manual installation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo chmod a+x build.sh\n```\n\n----------------------------------------\n\nTITLE: Creating Server Directory\nDESCRIPTION: Command to create a new directory for the server code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmkdir server\n```\n\n----------------------------------------\n\nTITLE: Setting Up Windows Build Environment and Dependencies\nDESCRIPTION: PowerShell commands to install required build tools (cmake, ninja, vswhere), set up the Visual Studio development environment, and download pre-built LLVM 16 binary package needed for WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/windows.md#2025-04-21_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n# Install the required tools\nchoco install cmake ninja vswhere\n\n$vsPath = (vswhere -latest -property installationPath)\n# If vswhere.exe is not in PATH, try the following instead.\n# $vsPath = (&\"C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -property installationPath)\n\nImport-Module (Join-Path $vsPath \"Common7\\Tools\\Microsoft.VisualStudio.DevShell.dll\")\nEnter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \"-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0\"\n\n# Download our pre-built LLVM 16 binary\n$llvm = \"LLVM-16.0.6-win64-MultiThreadedDLL.zip\"\ncurl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm\nExpand-Archive -Path $llvm\n\n# Set LLVM environment\n$llvm_dir = \"$pwd\\LLVM-16.0.6-win64-MultiThreadedDLL\\LLVM-16.0.6-win64\\lib\\cmake\\llvm\"\n```\n\n----------------------------------------\n\nTITLE: Running Inference with WasmEdge CLI (Bash)\nDESCRIPTION: Executes the compiled WASM file using the WasmEdge CLI, providing the necessary model and input image as arguments. The `--dir .:.` option maps the current directory to the WASM's filesystem, allowing access to the model and image files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg\n```\n\n----------------------------------------\n\nTITLE: Adding wasmedge-wasi-helper dependency - Cargo.toml\nDESCRIPTION: This snippet shows how to add the `wasmedge-wasi-helper` crate as dependencies in your `Cargo.toml` file. This crate provides helper functionality for initializing the WASI environment in Rust library functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md#2025-04-21_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n\"[dependencies]\\n... ...\\nwasmedge-wasi-helper = \\\"=0.2.0\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating SQL File for Encrypt UDF\nDESCRIPTION: Bash script to create a SQL file for the 'encrypt' UDF, including dropping existing function and creating a new one with WASM binary content.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/libsql.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport FUNC_NAME='encrypt'\necho \"DROP FUNCTION IF EXISTS ${FUNC_NAME};\" >> create_${FUNC_NAME}_udf.sql\necho -n \"CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'\" >> create_${FUNC_NAME}_udf.sql\nxxd -p  ../../target/wasm32-wasip1/release/libsql_encrypt_decrypt.wasm | tr -d \"\\n\" >> create_${FUNC_NAME}_udf.sql\necho \"';\" >> create_${FUNC_NAME}_udf.sql\n```\n\n----------------------------------------\n\nTITLE: Cloning Whisper Examples Repository\nDESCRIPTION: Commands to clone the WasmEdge-WASINN-examples repository and navigate to the whisper-basic example directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/whisper.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/whisper-basic/\n```\n\n----------------------------------------\n\nTITLE: Create Orders\nDESCRIPTION: CURL command to send POST request with JSON data to create new orders in the database.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/build-and-run/docker_wasm.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/create_orders -X POST -d @orders.json\n```\n\n----------------------------------------\n\nTITLE: Executing the compiled program in Bash\nDESCRIPTION: This command executes the compiled program `a.out`. It assumes that the current directory contains the executable file. The output of the program, which includes the WasmEdge version, is printed to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"$ ./a.out\nWasmEdge version: 0.12.1\"\n```\n\n----------------------------------------\n\nTITLE: Installing Android Debug Bridge (ADB)\nDESCRIPTION: Commands to install and verify ADB installation on Ubuntu, including checking connected devices and accessing the Android shell.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/cli.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install adb\n$ adb devices\n* daemon not running; starting now at tcp:5037\n* daemon started successfully\nList of devices attached\nc657c643 device\n$ adb shell\nsirius:/ $\n```\n\n----------------------------------------\n\nTITLE: Visualizing WasmEdge Plug-in Development Steps with Mermaid\nDESCRIPTION: A flowchart illustrating the overall process of developing a WasmEdge plug-in, from setting up the environment to testing and debugging.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR;\nA[Developing WasmEdge Plug-in in C]\nA --> B(Set up the development environment)\nA --> C(Create a WasmEdge plug-in project)\nA --> D(Write the plug-in code)\nA --> E(Build the plug-in)\nA --> F(Test and debug the plug-in)\nB --> E\nC --> D\nD --> E\n```\n\n----------------------------------------\n\nTITLE: Value Type Creation Pre-0.14.0 Example\nDESCRIPTION: Example showing how to create function types using enum WasmEdge_ValType before version 0.14.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Table Type Context in C\nDESCRIPTION: Shows how to create a Table Type context with a specific reference type and limit, and then retrieve information from it using WasmEdge API functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Adding WasmEdge SDK Dependency in Cargo.toml\nDESCRIPTION: Demonstrates how to add the wasmedge-sdk crate dependency to a Rust project's Cargo.toml file. The example shows using version 0.11.0 which is compatible with WasmEdge v0.13.3.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/rust/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nwasmedge-sdk = \"0.11.0\"\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Status\nDESCRIPTION: Command to verify that the Kubernetes cluster is running properly and shows the status of core components like the control plane and CoreDNS.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo cluster/kubectl.sh cluster-info\n\n# Expected output\nCluster \"local\" set.\nUser \"myself\" set.\nContext \"local\" created.\nSwitched to context \"local\".\nKubernetes control plane is running at https://localhost:6443\nCoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy\n\nTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.\n```\n\n----------------------------------------\n\nTITLE: Visualizing Loadable Plug-in Loading Process\nDESCRIPTION: This Mermaid flowchart demonstrates the process of loading loadable plug-ins into the WasmEdge runtime environment from specific paths, including default paths, specific paths, and directories.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    A((Start)) --> B(Loadable Plug-ins)\n    B --> C{Load Plug-ins}\n    C --> D[Load from Default Paths]\n    C --> E[Load from Specific Path]\n    C --> F[Load from Specific Directory]\n    D --> G{Is Plug-in Found?}\n    E --> G\n    F --> G\n    G -- Yes --> H(Load Plug-in)\n    H --> I(End)\n    G -- No --> I\n```\n\n----------------------------------------\n\nTITLE: Modifying Ninja Command for Limited Parallelization\nDESCRIPTION: Example of how to modify the ninja command in the build script to use only 2 parallel processes, reducing memory usage during build.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nninja -j 2\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with CMake on Windows\nDESCRIPTION: PowerShell commands to configure Visual Studio environment, set compiler options (using either Clang-cl or MSVC), and build WasmEdge using CMake and Ninja.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/windows.md#2025-04-21_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n$vsPath = (vswhere -latest -property installationPath)\nImport-Module (Join-Path $vsPath \"Common7\\Tools\\Microsoft.VisualStudio.DevShell.dll\")\nEnter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \"-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0\"\n# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.\n# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments \"-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933\"\n\n# Set LLVM path according to the download location\n$llvm_dir = \"$pwd\\LLVM-16.0.6-win64-MultiThreadedDLL\\LLVM-16.0.6-win64\\lib\\cmake\\llvm\"\n\n# Use clang-cl as the compiler.\n# Comment out the following two lines to use MSVC.\n$Env:CC = \"clang-cl\"\n$Env:CXX = \"clang-cl\"\n\ncmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL \"-DLLVM_DIR=$llvm_dir\" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=\"ZIP\" .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Running the HTTP Service in Kubernetes using Bash\nDESCRIPTION: This snippet runs a previously defined HTTP service Pod using the kubectl command with the specified YAML file. It requires the Kubernetes environment to be configured and the correct permissions to apply the configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml\n```\n\n----------------------------------------\n\nTITLE: Linking WasmEdge Static Library with GCC\nDESCRIPTION: Shows how to compile a C program using the WasmEdge static library with additional system libraries on Linux\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/library.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge -lrt -ldl -pthread -lm -lstdc++ -o test\n$ ./test\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\n```\n\n----------------------------------------\n\nTITLE: Fetching Execution Results in WasmEdge Asynchronous Context (C)\nDESCRIPTION: This C snippet displays how to retrieve the return values from a completed asynchronous execution using the WasmEdge API. Dependencies: WasmEdge C library. Inputs: Async object and buffer. Outputs: Execution result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Starting a New Process Using Command in Rust\nDESCRIPTION: This Rust code snippet shows how to create a new command process using WasmEdge's `Command` struct, set command arguments, and pass data to the process's standard input before capturing the output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/command.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut cmd = Command::new(\"http_proxy\");\n\ncmd.arg(\"post\")\n   .arg(\"https://api.sendgrid.com/v3/mail/send\")\n   .arg(auth_header);\ncmd.stdin_u8vec(payload.to_string().as_bytes());\n\nlet out = cmd.output();\n```\n\n----------------------------------------\n\nTITLE: Installing Android debugging tools on Ubuntu\nDESCRIPTION: Commands to install and use the Android Debug Bridge (adb) for interacting with Android devices from Ubuntu.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install adb\n$ adb devices\n* daemon not running; starting now at tcp:5037\n* daemon started successfully\nList of devices attached\nc657c643 device\n$ adb shell\nsirius:/ $\n```\n\n----------------------------------------\n\nTITLE: Adding Development Dependencies in package.json\nDESCRIPTION: This JSON snippet shows the addition of development dependencies required for Rollup in a Node.js project. These dependencies include plugins for Babel, CommonJS, Node resolution, and more to enable bundling features.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"devDependencies\": {\n    //...\n    \"@rollup/plugin-babel\": \"^5.3.0\",\n    \"@rollup/plugin-commonjs\": \"^21.0.1\",\n    \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n    \"@rollup/plugin-replace\": \"^3.0.0\",\n    \"rollup\": \"^2.60.1\",\n    \"rollup-plugin-async\": \"^1.2.0\",\n    \"rollup-plugin-import-css\": \"^3.0.3\",\n    \"rollup-plugin-node-builtins\": \"^2.1.2\",\n    \"rollup-plugin-node-globals\": \"^1.4.0\",\n    \"rollup-plugin-svg\": \"^2.0.0\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading WasmEdge-TensorFlow-Tools for Android\nDESCRIPTION: Commands to download and extract WasmEdge-TensorFlow-Tools pre-release packages for Android arm64-v8a architecture.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.12.1/WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz\n$ mkdir WasmEdge-tensorflow-tools && tar zxvf WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools\nshow-tflite-tensor\nwasmedge-tensorflow-lite\n```\n\n----------------------------------------\n\nTITLE: Starting a web service in WasmEdge with Rust\nDESCRIPTION: This Rust code creates a simple HTTP server using `wasmedge_wasi_socket`. It listens on `127.0.0.1:3000`, accepts incoming connections, handles requests using the `handler` module, and sends responses back to the client. It also shuts down the stream after each request.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::Write;\nuse wasmedge_wasi_socket::{Shutdown, TcpListener};\n\nmod handler;\nmod mime;\nmod response;\n\nfn main() {\n    let server = TcpListener::bind(\"127.0.0.1:3000\", false).unwrap();\n    println!(\"Server listening on 127.0.0.1:3000\");\n\n    // Simple single-thread HTTP server\n    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server\n    loop {\n        let (mut stream, addr) = server.accept(0).unwrap();\n        println!(\"Accepted connection from {}\", addr);\n        match handler::handle_req(&mut stream, addr) {\n            Ok((res, binary)) => {\n                let res: String = res.into();\n                let bytes = res.as_bytes();\n                stream.write_all(bytes).unwrap();\n                if let Some(binary) = binary {\n                    stream.write_all(&binary).unwrap();\n                }\n            }\n            Err(e) => {\n                println!(\"Error: {:?}\", e);\n            }\n        };\n        stream.shutdown(Shutdown::Both).unwrap();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating an AST Module to an Anonymous Module Instance in C\nDESCRIPTION: Demonstrates how to instantiate a WASM or compiled-WASM module into an anonymous Module instance. Before instantiation, it's important to ensure required imports are registered in the Store context for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_55\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Go and Setting Up Kubernetes with containerd\nDESCRIPTION: Commands to install Go, clone the Kubernetes repository, install etcd, and run a local Kubernetes cluster configured to use containerd as the container runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install go\n$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz\n$ sudo rm -rf /usr/local/go\n$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz\n$ source /home/${USER}/.profile\n\n# Clone k8s\n$ git clone https://github.com/kubernetes/kubernetes.git\n$ cd kubernetes\n$ git checkout v1.22.2\n\n# Install etcd with hack script in k8s\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh\n$ export PATH=\"/home/${USER}/kubernetes/third_party/etcd:${PATH}\"\n$ sudo cp third_party/etcd/etcd* /usr/local/bin/\n\n# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl\n\n# Build and run k8s with containerd\n$ sudo apt-get install -y build-essential\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Module in WasmEdge VM\nDESCRIPTION: Shows how to register a WASM module from a file into the VM with a specific module name. Includes basic project setup and error handling.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_36\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var err error\n  err = vm.RegisterWasmFile(\"module_name\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  // The result status should be checked. The error will occur if the\n  // WASM module instantiation failed or the module name conflicts.\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TensorFlow-Lite Dependencies\nDESCRIPTION: Commands to download and install TensorFlow-Lite shared libraries for the WASI-NN TensorFlow-Lite backend.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\ntar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nrm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nmv libtensorflowlite_c.so /usr/local/lib\nmv libtensorflowlite_flex.so /usr/local/lib\n```\n\n----------------------------------------\n\nTITLE: Go Project Setup Commands\nDESCRIPTION: Terminal commands to create and initialize a new Go project for WasmEdge testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Invoking WASM Function in WasmEdge 0.9.1 (C)\nDESCRIPTION: Example of loading, instantiating, and invoking a WASM function using the Executor API in WasmEdge version 0.9.1. This method directly invokes the function by name from the Store context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n/* Create the store context. The store context holds the instances. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);\n/* Create the executor context. The configure context and the statistics context can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);\n\n/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, \"fibonacci.wasm\");\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Loading phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Validate the WASM module. */\nRes = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Instantiate the WASM module into the store context. */\nRes = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Instantiation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n/* Invoke the function which is exported with the function name \"fib\". */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nWasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };\nWasmEdge_Value Returns[1];\nRes = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);\nif (WasmEdge_ResultOK(Res)) {\n  printf(\"Get the result: %d\\n\", WasmEdge_ValueGetI32(Returns[0]));\n} else {\n  printf(\"Execution phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ValidatorDelete(ValidCxt);\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing SuperEdge Kubernetes Master Node with Containerd\nDESCRIPTION: Command to initialize a SuperEdge Kubernetes master node using containerd runtime. It sets up various network configurations and enables edge computing capabilities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=<Master Public IP> --apiserver-advertise-address=<Master Intranet IP> --enable-edge=true --runtime=containerd\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Runtime\nDESCRIPTION: Shell command to install WasmEdge runtime using official installation script. Works on Unix-like platforms and requires curl.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: File Copy Command\nDESCRIPTION: Shell command to copy the index.html template file to the server directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncp server/src/index.html server-wasmedge/src/\n```\n\n----------------------------------------\n\nTITLE: Markdown Info Block for Work in Progress\nDESCRIPTION: A markdown info block indicating that the testing documentation is still being worked on\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/test.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n:::info\nWork in Progress\n:::\n```\n\n----------------------------------------\n\nTITLE: Loading the br_netfilter Kernel Module for Kubernetes Networking\nDESCRIPTION: Commands to load the br_netfilter kernel module and configure kernel parameters required for Kubernetes networking. This enables iptables to see bridged traffic.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n//load the module\nsudo modprobe br_netfilter\n//verify\nlsmod | grep br_netfilter\n// create k8s.conf\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsudo sysctl --system\n```\n\n----------------------------------------\n\nTITLE: Pulling WasmEdge Docker Build Image\nDESCRIPTION: Command to pull a Docker image for building WasmEdge from source. The {tag_name} should be replaced with one of the supported tags listed in the documentation tables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/docker.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull wasmedge/wasmedge:{tag_name}\n```\n\n----------------------------------------\n\nTITLE: Compiling C code with GCC\nDESCRIPTION: This command compiles the C file `test.c` using GCC and links it with the `wasmedge` library. It creates an executable file named `a.out`.  The `wasmedge` library must be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"gcc test.c -lwasmedge\"\n```\n\n----------------------------------------\n\nTITLE: Listing Containers on Edge Side\nDESCRIPTION: Command to list all containers on the edge node, including the WebAssembly container, using crictl.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo crictl ps -a\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge with DNF on Fedora/Red Hat\nDESCRIPTION: Removes WasmEdge on Fedora and Red Hat Linux systems that were installed using the DNF package manager.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndnf remove wasmedge\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-Go with TensorFlow-Lite Extension\nDESCRIPTION: Command to build WasmEdge-Go with TensorFlow-Lite extension support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags tensorflowlite\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Program\nDESCRIPTION: Commands for compiling and running a WasmEdge program that calculates the 20th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Limit Structures in WasmEdge-go\nDESCRIPTION: Demonstrates how to create Limit structures with minimum values only or with both minimum and maximum values. Shows how to query limit properties.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nlim1 := wasmedge.NewLimit(12)\nfmt.Println(lim1.HasMax())\n// Will print `false`.\nfmt.Println(lim1.GetMin())\n// Will print `12`.\n\nlim2 := wasmedge.NewLimitWithMax(15, 50)\nfmt.Println(lim2.HasMax())\n// Will print `true`.\nfmt.Println(lim2.GetMin())\n// Will print `15`.\nfmt.Println(lim2.GetMax())\n// Will print `50`.\n```\n\n----------------------------------------\n\nTITLE: Adding WasmEdge TensorFlow Interface to Cargo\nDESCRIPTION: This TOML snippet demonstrates how to add the `wasmedge_tensorflow_interface` crate as a dependency in a Rust application's Cargo.toml file, crucial for enabling TensorFlow functionalities in the WasmEdge environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasmedge_tensorflow_interface = \"0.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Build Grayscale Microservice\nDESCRIPTION: These commands build the grayscale microservice. The `cargo build` command compiles the Rust code to a WebAssembly module. Then, `wasmedgec` ahead-of-time compiles the wasm module for faster performance in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd image-api-grayscale\ncargo build --target wasm32-wasip1 --release\nwasmedgec ./target/wasm32-wasip1/release/image-api-grayscale.wasm image-api-grayscale.wasm\n```\n\n----------------------------------------\n\nTITLE: Retrieving Return Values from Asynchronous Execution\nDESCRIPTION: Shows how to get return values from an asynchronous execution using a pre-allocated buffer. The function blocks until the execution completes and fills the buffer with return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Module Creation Function\nDESCRIPTION: Implementation of the module creation function that initializes and configures a WasmEdge module instance with host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ModuleInstanceContext *\nCreateTestModule(const struct WasmEdge_ModuleDescriptor *Desc) {\n    WasmEdge_String ModuleName =\n        WasmEdge_StringCreateByCString(\"wasmedge_plugintest_c_module\");\n    WasmEdge_ModuleInstanceContext *Mod =\n        WasmEdge_ModuleInstanceCreate(ModuleName);\n    WasmEdge_StringDelete(ModuleName);\n\n    WasmEdge_String FuncName;\n    WasmEdge_FunctionTypeContext *FType;\n    WasmEdge_FunctionInstanceContext *FuncCxt;\n    WasmEdge_ValType ParamTypes[2], ReturnTypes[1];\n    ParamTypes[0] = WasmEdge_ValTypeGenI32();\n    ParamTypes[1] = WasmEdge_ValTypeGenI32();\n    ReturnTypes[0] = WasmEdge_ValTypeGenI32();\n\n    FType = WasmEdge_FunctionTypeCreate(ParamTypes, 2, ReturnTypes, 1);\n    FuncName = WasmEdge_StringCreateByCString(\"add\");\n    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncAdd, NULL, 0);\n    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);\n    WasmEdge_StringDelete(FuncName);\n    FuncName = WasmEdge_StringCreateByCString(\"sub\");\n    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncSub, NULL, 0);\n    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);\n    WasmEdge_StringDelete(FuncName);\n    WasmEdge_FunctionTypeDelete(FType);\n\n    return Mod;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Externref-based WASM Function\nDESCRIPTION: This WASM example describes a module where a function `call_square` uses an imported host function `functor_square`. The function takes an `externref` and an integer, returning an integer. The host function `functor_square` must handle the `externref` passed by `call_square`, requiring proper implementation on the host side.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md#2025-04-21_snippet_2\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n  (type $t0 (func (param externref i32) (result i32)))\n  ;; Import a host function which type is {externref i32} -> {i32}\n  (import \"extern_module\" \"functor_square\" (func $functor_square (type $t0)))\n  ;; WASM function which type is {externref i32} -> {i32} and exported as \"call_square\"\n  (func $call_square (export \"call_square\") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)\n    (call $functor_square (local.get $p0) (local.get $p1))\n  )\n  (memory $memory (export \"memory\") 1))\n```\n\n----------------------------------------\n\nTITLE: Installing Emscripten for WebAssembly Compilation\nDESCRIPTION: Commands to clone, install, and activate the latest version of Emscripten, a toolchain for compiling C/C++ to WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --depth 1 https://github.com/emscripten-core/emsdk.git\ncd emsdk\n./emsdk install latest\n./emsdk activate latest\nsource ./emsdk_env.sh\n```\n\n----------------------------------------\n\nTITLE: Host Registration for WasmEdge VM in Go\nDESCRIPTION: This snippet details how to activate WASI support in WasmEdge's VM context using Go. The HostRegistration type includes constants like WASI that can be passed to the wasmedge.Configure object to enable certain host features. It assumes a working installation of the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi)\n)\n```\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n// Developers can also pass the proposals as parameters:\n// conf := wasmedge.NewConfigure(wasmedge.WASI)\nconf.AddConfig(wasmedge.WASI)\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Network Connection Error Example\nDESCRIPTION: Example of connection refused error when attempting to download installation script from githubusercontent.com\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\ncurl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n```\n\n----------------------------------------\n\nTITLE: Copying Custom Module Files\nDESCRIPTION: This command copies custom module files from an example directory to the WasmEdge QuickJS modules directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/modules.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncp example_js/module_demo/modules/* modules/\n```\n\n----------------------------------------\n\nTITLE: Installing Android Debug Tools\nDESCRIPTION: Command to install Android Debug Bridge (adb) on Ubuntu Linux for Android device management and testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/ndk.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install adb\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge C SDK integration via JNI\nDESCRIPTION: C++ implementation of the JNI native function that executes a WebAssembly function using WasmEdge C SDK. It creates a WasmEdge VM, loads the WebAssembly bytecode from memory, executes the 'fib' function, and returns the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/apk.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nextern \"C\" JNIEXPORT jint JNICALL\nJava_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(\n    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {\n  jsize buffer_size = env->GetArrayLength(image_bytes);\n  jbyte *buffer = env->GetByteArrayElements(image_bytes, nullptr);\n\n  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);\n\n  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);\n\n  const WasmEdge_String &func_name = WasmEdge_StringCreateByCString(\"fib\");\n  std::array<WasmEdge_Value, 1> params{WasmEdge_ValueGenI32(idx)};\n  std::array<WasmEdge_Value, 1> ret_val{};\n\n  const WasmEdge_Result &res = WasmEdge_VMRunWasmFromBuffer(\n      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),\n      params.size(), ret_val.data(), ret_val.size());\n\n  WasmEdge_VMDelete(vm_ctx);\n  WasmEdge_ConfigureDelete(conf);\n  WasmEdge_StringDelete(func_name);\n\n  env->ReleaseByteArrayElements(image_bytes, buffer, 0);\n  if (!WasmEdge_ResultOK(res)) {\n    return -1;\n  }\n  return WasmEdge_ValueGetI32(ret_val[0]);\n}\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Contexts in C\nDESCRIPTION: Describes the creation and deletion of WasmEdge contexts, such as configuration contexts, with a focus on memory management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing PyTorch 1.8.2 on Ubuntu 20.04\nDESCRIPTION: Commands to download and extract PyTorch 1.8.2 LTS for Ubuntu 20.04, which is required for the WASI-NN PyTorch backend. This sets up the necessary environment variables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport PYTORCH_VERSION=\"1.8.2\"\ncurl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\nunzip -q \"libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nrm -f \"libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip\"\nexport LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}\nexport Torch_DIR=$(pwd)/libtorch\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge Host Function Example\nDESCRIPTION: Bash command to compile the C program with WasmEdge library linkage and run the resulting binary, showing the output of the addition operation using the host function with external data.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_75\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nHost function \"Add\": 1234 + 5678\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Pulling WebAssembly Example Container Image\nDESCRIPTION: Command to pull a WebAssembly example container image from Docker Hub using containerd\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo ctr i pull docker.io/wasmedge/example-wasi:latest\n```\n\n----------------------------------------\n\nTITLE: Defining Fibonacci Function in WebAssembly Text Format\nDESCRIPTION: This WebAssembly Text Format (WAT) code defines a module that exports a 'fib' function to calculate Fibonacci numbers recursively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_28\n\nLANGUAGE: wasm\nCODE:\n```\n(module\n (export \"fib\" (func $fib))\n (func $fib (param $n i32) (result i32)\n  (if\n   (i32.lt_s (get_local $n)(i32.const 2))\n   (return (i32.const 1))\n  )\n  (return\n   (i32.add\n    (call $fib (i32.sub (get_local $n)(i32.const 2)))\n    (call $fib (i32.sub (get_local $n)(i32.const 1)))\n   )\n  )\n )\n)\n```\n\n----------------------------------------\n\nTITLE: Building Go WASM Module with TinyGo\nDESCRIPTION: Command to build a Go source file into a WebAssembly module using TinyGo compiler with specific targets and scheduler settings\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/wasm-nginx.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntinygo build -o ./fault-injection/main.go.wasm -scheduler=none -target=wasi ./fault-injection/main.go\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options\nDESCRIPTION: Set various compiler options like optimization level, output format, and additional compilation settings\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n```\n\n----------------------------------------\n\nTITLE: Markdown Link to Code of Conduct\nDESCRIPTION: A markdown link directing users to the main Code of Conduct document in the WasmEdge repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CODE_OF_CONDUCT.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# WasmEdge Code of Conduct\n\nSee the Code of Conduct [here](https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md).\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge with Plugins\nDESCRIPTION: Installs WasmEdge with TensorFlow and Image plugins using curl command\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_tensorflow wasmedge_tensorflowlite wasmedge_image -v 0.13.5\n```\n\n----------------------------------------\n\nTITLE: Using Export Type Context in C\nDESCRIPTION: Example of using Export Type context to retrieve export information from an AST Module, showing how to get external types and names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\nconst WasmEdge_TagTypeContext *TagTypeCxt =\n    WasmEdge_ExportTypeGetTagType(ASTCxt, ExpType);\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Proposal Enum Definition in WasmEdge\nDESCRIPTION: Defines the enumeration of WebAssembly proposals that can be configured in WasmEdge. These proposal flags control which WebAssembly features are enabled during execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  WasmEdge_Proposal_MultiValue,\n  WasmEdge_Proposal_BulkMemoryOperations,\n  WasmEdge_Proposal_ReferenceTypes,\n  WasmEdge_Proposal_SIMD,\n  WasmEdge_Proposal_TailCall,\n  WasmEdge_Proposal_MultiMemories,\n  WasmEdge_Proposal_Annotations,\n  WasmEdge_Proposal_Memory64,\n  WasmEdge_Proposal_ExceptionHandling,\n  WasmEdge_Proposal_Threads,\n  WasmEdge_Proposal_FunctionReferences\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Cost Table and Limit in WasmEdge Statistics Context in C\nDESCRIPTION: This snippet shows how to create a WasmEdge Statistics context, set a custom cost table for instructions, set a cost limit, and retrieve the total cost after running WASM functions. It also demonstrates proper cleanup of the context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/* Developers can set the costs of each instruction. The value not covered will be 0. */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/* ....\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Deploying to Android Device\nDESCRIPTION: ADB commands to push compiled program, WASM files, TensorFlow model, test images and libraries to Android device.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/ndk.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nadb push a.out /data/local/tmp\nadb push birds_v1.wasm /data/local/tmp\nadb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp\nadb push bird.jpg /data/local/tmp\nadb push ./WasmEdge-0.12.1-Android/lib /data/local/tmp\n```\n\n----------------------------------------\n\nTITLE: Registering Existing Module Instance in Go\nDESCRIPTION: Shows how to register an existing Module instance into the store with an exported module name. Useful for registering host function modules for linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\nexecutor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)\nstore := wasmedge.NewStore()\n\nmod := wasmedge.NewModule(\"mod\")\n\nres := executor.RegisterImport(store, mod)\nif err != nil {\n  fmt.Println(\"WASM registration FAILED:\", err.Error())\n  return\n}\n\nexecutor.Release()\nstat.Release()\nstore.Release()\nmod.Release()\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Lite JavaScript AI Inference Example\nDESCRIPTION: JavaScript code for running AI inference on an image using TensorFlow Lite model with WASI NN in the WasmEdge runtime environment. Inputs include an image and an AI model, and it outputs the recognized label and confidence factor.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Image } from 'image';\nimport * as fs from 'fs';\nimport { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';\n\nlet img = new Image(__dirname + '/food.jpg');\nlet img_rgb = img.to_rgb().resize(192, 192);\nlet rgb_pix = img_rgb.pixels();\n\nlet data = fs.readFileSync(\n  __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite',\n);\nlet graph = new NnGraph([data.buffer], 'tensorflowlite', 'cpu');\nlet context = new NnContext(graph);\ncontext.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);\ncontext.compute();\n\nlet output_view = new Uint8Array(2024);\ncontext.getOutput(0, output_view.buffer);\n\nlet max = 0;\nlet max_idx = 0;\nfor (var i in output_view) {\n  let v = output_view[i];\n  if (v > max) {\n    max = v;\n    max_idx = i;\n  }\n}\n\nlet label_file = fs.readFileSync(\n  __dirname + '/aiy_food_V1_labelmap.txt',\n  'utf-8',\n);\nlet lables = label_file.split(/\\r?\\n/);\n\nlet label = lables[max_idx];\n\nprint('label:');\nprint(label);\nprint('confidence:');\nprint(max / 255);\n```\n\n----------------------------------------\n\nTITLE: Executing Functions in Registered WASM Modules\nDESCRIPTION: Demonstrates registering and executing a function from a WASM module. Shows complete example including error handling and result processing for calculating Fibonacci numbers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_37\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  // Register the WASM module from file into VM with the module name \"mod\".\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // `(*VM).RegisterAST` function.\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n  // The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n  // name \"mod\". As the same as host functions, other modules can import the\n  // function `\"mod\" \"fib\"`.\n\n  // Execute WASM functions in registered modules.\n  // Unlike the execution of functions, the registered functions can be\n  // invoked without `(*VM).Instantiate` because the WASM module was\n  // instantiated when registering.\n  // Developers can also invoke the host functions directly with this API.\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Optimization Level Enum Definition in WasmEdge C API\nDESCRIPTION: Defines the enumeration for compiler optimization levels available in WasmEdge, ranging from no optimization (O0) to size optimization (Oz).\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom section.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n```\n\n----------------------------------------\n\nTITLE: Git Commit with DCO Signoff\nDESCRIPTION: Command to commit changes with automatic DCO signoff using the -s flag.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -s -m \"my commit message w/signoff\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up Knative Serving\nDESCRIPTION: This snippet details the installation of Knative Serving along with the necessary network layer configuration. It demonstrates how to patch configurations for network integration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# install the Knative Serving component\n$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-crds.yaml\n$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-core.yaml\n\n# install a networking layer\n$ kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v1.7.0/kourier.yaml\n$ kubectl patch configmap/config-network \\\n  --namespace knative-serving \\\n  --type merge \\\n  --patch '{\"data\":{\"ingress-class\":\"kourier.ingress.networking.knative.dev\"}}'\n$ kubectl --namespace kourier-system get service kourier\n\n# verify the installation\n$ kubectl get pods -n knative-serving\n\n# open runtimeClass feature gate in Knative\n$ kubectl patch configmap/config-features -n knative-serving --type merge --patch '{\"data\":{\"kubernetes.podspec-runtimeclassname\":\"enabled\"}}'\n```\n\n----------------------------------------\n\nTITLE: Installing SVG URL Loader\nDESCRIPTION: Command to install the svg-url-loader package as a development dependency for handling SVG files in the build process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nnpm install svg-url-loader --save-dev\n```\n\n----------------------------------------\n\nTITLE: Adding DCO Signoff to Git Commits\nDESCRIPTION: Example of the required Developer Certificate of Origin (DCO) signoff format for Git commits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSigned-off-by: John Doe <john.doe@example.com>\n```\n\n----------------------------------------\n\nTITLE: Pushing WasmEdge-TensorFlow packages to Android device\nDESCRIPTION: Command to push the downloaded WasmEdge-TensorFlow packages onto a connected Android device using adb.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nadb push WasmEdge-tensorflow-tools /data/local/tmp\n```\n\n----------------------------------------\n\nTITLE: Instantiating AST Module to Anonymous Module Instance in C\nDESCRIPTION: This example demonstrates how to instantiate an AST module into an anonymous Module instance. This is a key step before function invocation, with proper validation and error handling for the instantiation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_58\n\nLANGUAGE: c\nCODE:\n```\n/*\n* ...\n* Assume that the `ASTCxt` is the output AST module context from the loader context\n* and has passed the validation.\n* Assume that the `ConfCxt` is the configure context.\n*/\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/* Create the executor context. The configure and the statistics contexts can be NULL. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/* Create the store context. The store context is the object to link the modules for imports and exports. */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"WASM instantiation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n```\n\n----------------------------------------\n\nTITLE: Getting Function Types in WasmEdge\nDESCRIPTION: Shows how to retrieve function types by name from the VM context for both regular and registered module functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_46\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString(\"fib\");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WASM Example\nDESCRIPTION: Commands to compile the C code with WasmEdge library and execute the resulting binary to calculate the 18th Fibonacci number.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge_c\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Converting OpenWRT Image for VMware\nDESCRIPTION: Commands to convert the OpenWRT image to VMware-compatible format using QEMU.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/openwrt.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/openwrt/bin/targets/x86/64\nsudo apt install qemu\ngunzip openwrt-x86-64-generic-squashfs-combined.img.gz\nqemu-img convert -f raw -O vmdk openwrt-x86-64-generic-squashfs-combined.img Openwrt.vmdk\n```\n\n----------------------------------------\n\nTITLE: Building and Running Host Data Example in WasmEdge\nDESCRIPTION: Commands for building and running a Go application that shares data between host and WebAssembly using the WasmEdge SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_71\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\n$ go build\n$ ./wasmedge_test\nGet the result: 6912\nData value: 6912\n```\n\n----------------------------------------\n\nTITLE: Configuring Cost Table in WasmEdge\nDESCRIPTION: This snippet illustrates how to create a statistics context, define a cost table for instructions, set a cost limit, and retrieve the total cost after executing WASM functions. This allows for monitoring and managing execution costs effectively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/* Developers can set the costs of each instruction. The value not covered will be 0. */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/* ....\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory Structure for WasmEdge Plug-in\nDESCRIPTION: Bash commands to set up the initial directory structure for a WasmEdge plug-in project.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir testplugin\ncd testplugin\nmkdir src include build\n```\n\n----------------------------------------\n\nTITLE: Adding Host Functions to Module Instance - WasmEdge C\nDESCRIPTION: Demonstrates creating a function type and context for a host function in WasmEdge. It includes initializing parameter and return lists, creating the function type and instance, and final cleanup. This process is key for embedding host functions into module instances, facilitating interactions with WebAssembly modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n  * Create a function context with the function type and host function body.\n  * The `Cost` parameter can be 0 if developers do not need the cost\n  * measuring.\n  */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n  * The third parameter is the pointer to the additional data.\n  * Developers should guarantee the life cycle of the data, and it can be NULL if the external data is not needed.\n  */\nWasmEdge_FunctionTypeDelete(HostType);\n```\n\n----------------------------------------\n\nTITLE: HTML Output with SSR\nDESCRIPTION: This HTML snippet demonstrates the output in the browser after implementing server-side rendering, showing the React app's content within the root div element.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_23\n\nLANGUAGE: html\nCODE:\n```\n<div id=\"root\"><div class=\"App\" data-reactroot=\"\">...</div></div>\n```\n\n----------------------------------------\n\nTITLE: Requesting the axum server with curl\nDESCRIPTION: This command sends a POST request to the HTTP server running on localhost:8080, specifically to the `/echo` endpoint, with the data \"WasmEdge\". The server is expected to echo back this data as a response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:8080/echo -X POST -d \"WasmEdge\"\nWasmEdge\n```\n\n----------------------------------------\n\nTITLE: Configuring wasm-bindgen Patch for WASI Compatibility\nDESCRIPTION: Patch configuration for wasm-bindgen to use a forked version that supports WASI compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\nwasm-bindgen = { git = \"https://github.com/KernelErr/wasm-bindgen.git\", branch = \"wasi-compat\" }\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in C\nDESCRIPTION: Demonstrates creation and manipulation of Function Type context for managing WASM function signatures including parameter and return types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };\nenum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };\nWasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\nuint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\nuint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Version Handling in C\nDESCRIPTION: Provides functions to get version details of the WasmEdge library, including major, minor, and patch numbers. Requires WasmEdge headers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.9.x.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge with CMake\nDESCRIPTION: Commands to configure and build WasmEdge from source using CMake and Ninja with tests enabled.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/macos.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Testing a WebAssembly HTTP Server with curl\nDESCRIPTION: Shell command to test the WebAssembly HTTP server running in Docker by sending a POST request with curl. This demonstrates the server's ability to receive and respond to HTTP requests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ curl -X POST http://127.0.0.1:1234 -d \"name=WasmEdge\"\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Implementing Cost Table and Limits for Execution Control in WasmEdge C API\nDESCRIPTION: This snippet shows how to set up a cost table for WebAssembly instructions and define execution cost limits. It demonstrates creating a Statistics context, defining instruction costs, setting cost limits, and retrieving total execution cost.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0,\n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/* Developers can set the costs of each instruction. The value not covered will be 0. */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n```\n\n----------------------------------------\n\nTITLE: Executing Functions from Registered WASM Modules in WasmEdge Go\nDESCRIPTION: This snippet demonstrates how to execute functions from registered WASM modules in WasmEdge using Go. It includes registering a module, executing a function, and handling the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_34\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  var res []interface{}\n  var err error\n  // Register the WASM module from file into VM with the module name \"mod\".\n  err = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\n  // Developers can register the WASM module from `[]byte` with the\n  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with\n  // the `(*VM).RegisterAST` function.\n  if err != nil {\n    fmt.Println(\"WASM registration failed:\", err.Error())\n    return\n  }\n  // The function \"fib\" in the \"fibonacci.wasm\" was exported with the module\n  // name \"mod\". As the same as host functions, other modules can import the\n  // function `\"mod\" \"fib\"`.\n\n  // Execute WASM functions in registered modules.\n  // Unlike the execution of functions, the registered functions can be\n  // invoked without `(*VM).Instantiate` because the WASM module was\n  // instantiated when registering.\n  // Developers can also invoke the host functions directly with this API.\n  res, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TensorflowLite Dependencies\nDESCRIPTION: Commands to download and install the necessary TensorflowLite dependencies (libtensorflowlite_c.so and libtensorflowlite_flex.so) for use with the WasmEdge-TensorflowLite plugin. Instructions for Linux x86_64 platforms are shown.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.\n# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.\n# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.\ntar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\nrm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Containerd Configuration for crun\nDESCRIPTION: This snippet shows how to configure containerd to use crun as its runtime. The configuration file is modified to add crun settings and ensure proper restart of the containerd service.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cat /etc/containerd/config.toml\n\n# comment this line to make cri wokrs\n# disabled_plugins = [\"cri\"]\n\n# add the following section to setup crun runtime, make sure the BinaryName equal to your crun binary path\n[plugins]\n  [plugins.cri]\n    [plugins.cri.containerd]\n      [plugins.cri.containerd.runtimes]\n...\n        [plugins.cri.containerd.runtimes.crun]\n           runtime_type = \"io.containerd.runc.v2\"\n           pod_annotations = [\"*.wasm.*\", \"wasm.*\", \"module.wasm.image/*\", \"*.module.wasm.image\", \"module.wasm.image/variant.*\"]\n           privileged_without_host_devices = false\n           [plugins.cri.containerd.runtimes.crun.options]\n             BinaryName = \"/usr/local/bin/crun\"\n...\n\n# restart containerd service\n$ sudo systemctl restart containerd\n\n# check if crun works\n$ ctr image pull docker.io/wasmedge/example-wasi:latest\n$ ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Host Module Registration (WasmEdge 0.10.0)\nDESCRIPTION: Updated method for registering a host module using WasmEdge_ModuleInstanceContext in version 0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n/* Create the module instance with the export module name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"module\");\nWasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Add the host functions, tables, memories, and globals into the module instance.\n */\n/* The module instance context has already contained the export module name. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Module instance registration failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Cluster with Kind for Kwasm\nDESCRIPTION: This command creates a new Kubernetes cluster using Kind, which is required for installing the Kwasm operator.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkind create cluster\n```\n\n----------------------------------------\n\nTITLE: Server WasmEdge Cargo Configuration\nDESCRIPTION: Basic package configuration for the WasmEdge server implementation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"isomorphic-server-wasmedge\"\nversion = \"0.1.0\"\nedition = \"2021\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Table Instance to Module Instance in WasmEdge C API\nDESCRIPTION: This snippet shows how to create a table type with specific limits, instantiate a table instance, and add it to a module instance in WasmEdge. It defines table limits, creates a table type and instance, and registers it with the module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_67\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit TableLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString(\"table\");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Compiler and Runtime in Docker\nDESCRIPTION: Example showing how to compile and run a WebAssembly file using the wasmedge/slim Docker image. The example demonstrates mounting the current directory, compiling hello.wasm to hello.aot.wasm, and then executing it.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/docker-slim.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ docker pull wasmedge/slim:{{ wasmedge_version }}\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm\n[2022-07-07 08:15:49.154] [info] compile start\n[2022-07-07 08:15:49.163] [info] verify start\n[2022-07-07 08:15:49.169] [info] optimize start\n[2022-07-07 08:15:49.808] [info] codegen start\n[2022-07-07 08:15:50.419] [info] output start\n[2022-07-07 08:15:50.421] [info] compile done\n[2022-07-07 08:15:50.422] [info] output start\n\n$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world\nhello\nworld\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Function Type Context in WasmEdge\nDESCRIPTION: Example of creating a Function Type context with specific parameter and return types, then retrieving information about parameters and return values. Function Type contexts are used for function creation and type validation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),\n                                 WasmEdge_ValTypeGenI64()};\nWasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenFuncRef()};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nWasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\n/* `ParamLen` will be 2. */\nuint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\n/*\n * `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as\n * `ParamList`.\n */\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\n/* `ReturnLen` will be 1. */\nuint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n/*\n * `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.\n */\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring axum project dependencies in Cargo.toml\nDESCRIPTION: This configuration file patch and dependencies section specifies the necessary crates and their versions for building an axum HTTP server in WasmEdge. It includes patches for `tokio`, `socket2`, and `hyper` to ensure compatibility with the WasmEdge environment, along with dependencies on `axum`, `bytes`, `futures-util`, and `tokio`.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\naxum = \"0.6\"\nbytes = \"1\"\nfutures-util = \"0.3.30\"\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\", \"io-util\"]}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge Bytes (C)\nDESCRIPTION: Examples of creating and managing WasmEdge_Bytes objects, which are used for input/output buffers in various WasmEdge operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4] = {1, 2, 3, 4};\nWasmEdge_Bytes Bytes = WasmEdge_BytesCreate(Buf, 4);\n/* The objects should be deleted by `WasmEdge_BytesDelete()`. */\nWasmEdge_BytesDelete(Bytes);\n\n/* Wrap a `WasmEdge_Bytes` to a buffer with length */\nuint8_t Buf[4] = {1, 2, 3, 4};\nWasmEdge_Bytes Bytes = WasmEdge_BytesWrap(Buf, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_BytesDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Building Crun with WasmEdge Support\nDESCRIPTION: Commands to install dependencies, clone the Crun repository, and build Crun with WasmEdge support to enable running WebAssembly containers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake\n\n> git clone https://github.com/containers/crun\n> cd crun\n> ./autogen.sh\n> ./configure --with-wasmedge\n> make\n\n# Check your crun\n> ./crun --version\n```\n\n----------------------------------------\n\nTITLE: Applying WebAssembly Test Job in Kubernetes\nDESCRIPTION: This command applies a YAML file that defines a WebAssembly test job in the Kubernetes cluster.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nkubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge-Go Package\nDESCRIPTION: Commands to get and build the WasmEdge-Go package in a Go project\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2\ngo build\n```\n\n----------------------------------------\n\nTITLE: Visualizing WasmEdge Plug-in Integration Flow\nDESCRIPTION: This Mermaid diagram illustrates the flow of how a host application loads a plug-in shared library and registers it with the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/intro.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    A((Host Application)) -- Loads --> B((Plug-in Shared Library))\n    B -- Registers --> C((Wasmedge Runtime))\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Function Body with Context - WasmEdge C\nDESCRIPTION: Provides tips on implementing the body of a host function using `WasmEdge_CallingFrameContext` to access module instances on the call stack. It demonstrates retrieving memory instances and using them for data operations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Host function body definition. */\nWasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /* Get the 0th memory instance of the module of the top frame on the stack. */\n  /*\n   * Noticed that the `MemCxt` will be `NULL` if there's no memory instance in\n   * the module instance on the top frame.\n   */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf(\"u32 at memory[%u]: %u\\n\", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmEdge function calls in Android MainActivity (Kotlin)\nDESCRIPTION: Main Activity class in Kotlin that initializes the UI and creates a thread to run Fibonacci calculations using WasmEdge. It demonstrates how to call WebAssembly functions from an Android app and display results in the UI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/android/apk.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nclass MainActivity : AppCompatActivity() {\n  lateinit var lib: NativeLib\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n\n    val tv = findViewById<TextView>(R.id.tv_text)\n\n    lib = NativeLib(this)\n\n    Thread {\n      val lines = Vector<String>()\n      val idxArr = arrayOf(20, 25, 28, 30, 32)\n      for (idx: Int in idxArr) {\n        lines.add(\"running fib(${idx}) ...\")\n        runOnUiThread {\n          tv.text = lines.joinToString(\"\\n\")\n        }\n        val begin = System.currentTimeMillis()\n        val retVal = lib.wasmFibonacci(idx)\n        val end = System.currentTimeMillis()\n        lines.removeLast()\n        lines.add(\"fib(${idx}) -> ${retVal}, ${end - begin}ms\")\n        runOnUiThread {\n          tv.text = lines.joinToString(\"\\n\")\n        }\n      }\n    }.start()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Memory Instances (C)\nDESCRIPTION: Shows how to create Memory instances, set and get data, grow memory pages, and handle potential out-of-bounds errors. It also demonstrates proper cleanup of resources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_62\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\nWasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_MemoryTypeCreate(MemLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(MemTypeCxt);\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n```\n\n----------------------------------------\n\nTITLE: Installing Go and Kubernetes for Local Development with containerd\nDESCRIPTION: Script to set up a local Kubernetes development environment with Go installation, Kubernetes source code checkout, etcd installation, and building/running Kubernetes with containerd.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install go\n$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz\n$ sudo rm -rf /usr/local/go\n$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz\n$ source /home/${USER}/.profile\n\n# Clone k8s\n$ git clone https://github.com/kubernetes/kubernetes.git\n$ cd kubernetes\n$ git checkout v1.22.2\n\n# Install etcd with hack script in k8s\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh\n$ export PATH=\"/home/${USER}/kubernetes/third_party/etcd:${PATH}\"\n$ sudo cp third_party/etcd/etcd* /usr/local/bin/\n\n# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl\n\n# Build and run k8s with containerd\n$ sudo apt-get install -y build-essential\n$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh\n\n... ...\nLocal Kubernetes cluster is running. Press Ctrl-C to shut it down.\n```\n\n----------------------------------------\n\nTITLE: Running the Modified Build Script\nDESCRIPTION: This command executes the manually edited build script to start the installation process with controlled parallelization.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Daemon for CDI Support\nDESCRIPTION: JSON configuration for Docker daemon to enable CDI features and specify CDI specification directories. This is added to the /etc/docker/daemon.json file.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"features\": {\n     \"cdi\": true\n  },\n  \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous WASM Function Execution with WasmEdge in Go\nDESCRIPTION: This code snippet demonstrates how to asynchronously run a WASM function using WasmEdge. It creates a VM, asynchronously runs the 'fib' function from the 'fibonacci.wasm' file, waits for the execution to complete, and retrieves the result. The code depends on the WasmEdge Go SDK.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_38\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Importing ReactPlayer Component\nDESCRIPTION: This code snippet imports the ReactPlayer component from the 'react-player/lazy' library.  ReactPlayer is used to embed and play videos within the React application. The lazy import allows for code splitting and improved initial load time.\nSOURCE: https://github.com/wasmedge/docs/blob/main/src/pages/talks.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ReactPlayer from 'react-player/lazy'\n```\n\n----------------------------------------\n\nTITLE: Compiling WebAssembly to AOT with WasmEdge C API\nDESCRIPTION: This example shows how to use the WasmEdge AOT compiler to compile a WebAssembly module to AOT format. It creates a compiler context, compiles the WASM file to a shared library, and handles the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_74\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, \"fibonacci.wasm\", \"fibonacci.wasm.so\");\n  if (!WasmEdge_ResultOK(Res)) {\n      printf(\"Compilation failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n      return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Patching Cargo.toml for HTTPS hyper in WasmEdge\nDESCRIPTION: This snippet outlines the patching process for the Cargo.toml file to use hyper with HTTPS capabilities in WasmEdge, including necessary crates such as hyper-rustls, rustls, and webpki-roots.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\n\n[dependencies]\nhyper = { version = \"0.14\", features = [\"full\"]}\nhyper-rustls = { version = \"0.25\", default-features = false, features = [ \"http1\", \"tls12\", \"logging\", \"ring\", \"webpki-tokio\" ] }\nrustls = { version = \"0.22\", default-features = false }\nwebpki-roots = \"0.26.1\"\n\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\", \"io-util\"]}\npretty_env_logger = \"0.4.0\"\n```\n\n----------------------------------------\n\nTITLE: Loading Plugins in VM Context (Pre-0.12.0)\nDESCRIPTION: Example of loading plugins in a VM context before version 0.12.0. It demonstrates configuring the VM with specific host registrations for WASI crypto modules.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(Conf,\n                                      WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(\n    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\nWasmEdge_String Names[32];\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\nuint32_t ModuleLen = WasmEdge_StoreListModule(StoreCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Configuring WasmEdge AOT Compiler Options in Go\nDESCRIPTION: This code snippet demonstrates how to configure WasmEdge AOT compiler options using the `wasmedge.Configure` object in Go. It shows how to set the optimization level, output format, dump IR option, and generic binary option. The snippet sets the optimization level to O2, the output format to native, enables IR dumping, and enables generic binary output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\n```go\n   conf := wasmedge.NewConfigure()\n\n   // By default, the optimization level is O3.\n   conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n   // By default, the output format is universal WASM.\n   conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n   // By default, the dump IR is `false`.\n   conf.SetCompilerDumpIR(true)\n   // By default, the generic binary is `false`.\n   conf.SetCompilerGenericBinary(true)\n\n   conf.Release()\n   ```\n```\n\n----------------------------------------\n\nTITLE: Loading Plugins in VM Context (Post-0.12.0)\nDESCRIPTION: Example of loading plugins in a VM context after version 0.12.0. It shows how plugins are automatically loaded and registered, including mock modules for uninstalled plugins.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nWasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n/* The `WasmEdge_HostRegistration_Wasi` is still needed. */\nWasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);\nWasmEdge_ConfigureDelete(Conf);\n\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  printf(\"%s\\n\", Names[I].Buf);\n}\n/*\n * Will print:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n * wasi_ephemeral_nn\n * wasi_snapshot_preview1\n * wasmedge_httpsreq\n * wasmedge_process\n */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Image Processing in Rust for WebAssembly\nDESCRIPTION: Rust program that converts images to grayscale. It reads image data from STDIN, processes it, and writes the grayscale image to STDOUT. This code can be compiled to WebAssembly for AWS Lambda.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse hex;\nuse std::io::{self, Read};\nuse image::{ImageOutputFormat, ImageFormat};\n\nfn main() {\n  let mut buf = Vec::new();\n  io::stdin().read_to_end(&mut buf).unwrap();\n\n  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();\n  let img = image::load_from_memory(&buf).unwrap();\n  let filtered = img.grayscale();\n  let mut buf = vec![];\n  match image_format_detected {\n    ImageFormat::Gif => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();\n    },\n    _ => {\n      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();\n    },\n  };\n  io::stdout().write_all(&buf).unwrap();\n  io::stdout().flush().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TensorFlow Lite Inference in Rust with WasmEdge\nDESCRIPTION: This Rust function performs image classification using TensorFlow Lite. It loads an image, resizes it, runs inference using a pre-trained model, and returns the classification results. The function uses WasmEdge TensorFlow Lite plugin and wasmedge_bindgen for parameter passing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/ai.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasmedge_bindgen]\nfn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {\n  let img = image::load_from_memory(&image_data).unwrap().to_rgb8();\n  let flat_img = image::imageops::thumbnail(&img, 192, 192);\n\n  let model_data: &[u8] = include_bytes!(\"lite-model_aiy_vision_classifier_food_V1_1.tflite\");\n  let labels = include_str!(\"aiy_food_V1_labelmap.txt\");\n\n  let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(model_data);\n  session.add_input(\"input\", &flat_img).run();\n  let res_vec: Vec<u8> = session.get_output(\"MobilenetV1/Predictions/Softmax\");\n  ... ...\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying crun Installation with WasmEdge Support\nDESCRIPTION: Command to verify that crun is properly installed with WasmEdge support. The output should show WasmEdge listed among the capabilities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncrun -v\n# Output\ncrun version 1.7.2\ncommit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4\nrundir: /run/user/501/crun\nspec: 1.0.0\n+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL\n```\n\n----------------------------------------\n\nTITLE: Using the WasmEdge Loader in Go\nDESCRIPTION: This code snippet demonstrates how to use the WasmEdge Loader to load WASM modules from files or buffers. It shows configuration setup, loader creation, and loading from both file and buffer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_47\n\nLANGUAGE: go\nCODE:\n```\nvar buf []byte\n// ... Read the WASM code to the `buf`.\n\n// Developers can adjust settings in the configure object.\nconf := wasmedge.NewConfigure()\n// Create the loader object.\n// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.\nloader := wasmedge.NewLoaderWithConfig(conf)\nconf.Release()\n\n// Load WASM or compiled-WASM from the file.\nast, err := loader.LoadFile(\"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\n// Load WASM or compiled-WASM from the buffer\nast, err = loader.LoadBuffer(buf)\nif err != nil {\n  fmt.Println(\"Load WASM from buffer FAILED:\", err.Error())\n} else {\n  // The output AST object should be released.\n  ast.Release()\n}\n\nloader.Release()\n```\n\n----------------------------------------\n\nTITLE: Cloning and Compiling PostgreSQL Example (Bash)\nDESCRIPTION: This snippet clones the wasmedge-db-examples repository, navigates to the postgres example, compiles the Rust code into WASM, and then executes SQL statements against a PostgreSQL database using WasmEdge. The DATABASE_URL environment variable is set to connect to the database.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/postgres_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/postgres\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Execute SQL statements against a PostgreSQL database at postgres://user:passwd@localhost/testdb\nwasmedge --env \"DATABASE_URL=postgres://user:passwd@localhost/testdb\" target/wasm32-wasip1/release/crud.wasm\n```\n\n----------------------------------------\n\nTITLE: Building and running the server in WasmEdge using bash\nDESCRIPTION: This bash script changes the directory to `server-wasmedge`, builds the Rust server code using `cargo build --target wasm32-wasip1`, and then executes the compiled Wasm binary using `wasmedge`. The `OUTPUT_CSS` environment variable and `--dir` option are used to configure the WasmEdge runtime to access static assets.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncd ../server-wasmedge\ncargo build --target wasm32-wasip1\nOUTPUT_CSS=\"$(pwd)/../client/build/app.css\" wasmedge --dir /static:../client/build ../../../target/wasm32-wasip1/debug/isomorphic-server-wasmedge.wasm\n\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in WasmEdge\nDESCRIPTION: Demonstrates how to set various AOT compiler options in the WasmEdge configuration context, including optimization level, output format, dump IR, generic binary, and interruptible execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n/* Set this option to `TRUE` to support the interruptible execution in AOT\nmode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Global Instance to Module Instance in WasmEdge C API\nDESCRIPTION: This snippet shows how to create a global type with a specific value type and mutability, instantiate a global instance with an initial value, and add it to a module instance in WasmEdge. It creates a mutable i32 global with value 666.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_69\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString(\"global\");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module\n * instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n```\n\n----------------------------------------\n\nTITLE: Testing the HTTP server with curl commands\nDESCRIPTION: Curl commands to test the functionality of the running HTTP server, including a GET request and a POST request to the /echo endpoint.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/getting-started/quick_start.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ curl http://localhost:8080/\nTry POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`\n\n$ curl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\nHello WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Updated Value Type Usage in WasmEdge-Go v0.14.0\nDESCRIPTION: Example demonstrating the new struct-based value type usage in WasmEdge-Go v0.14.0, showing how to create and check value types using the new API methods.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.14.0.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Create a function type: {i32, i64, funcref} -> {f32}\nfunctype := wasmedge.NewFunctionType(\n    []*wasmedge.ValType{\n        wasmedge.NewValTypeI32(),\n        wasmedge.NewValTypeI64(),\n        wasmedge.NewValTypeFuncRef(),\n    },\n    []*wasmedge.ValType{\n        wasmedge.NewValTypeF32,\n    })\n\n// Get the parameter types\nvar ptypes []*wasmedge.ValType = functype.GetParameters()\nif ptypes[0].IsI32() {\n    // This will be true here.\n    // ...\n} \nfunctype.Release()\n\n// Create a table type: {min: 1}, externref\nlim := wasmedge.NewLimit(1)\ntabtype := wasmedge.NewTableType(wasmedge.NewValTypeExternRef(), lim)\n\n// Get the reference type\nif tabtype.GetRefType().IsExternRef() {\n    // This will be true here.\n    // ...\n}\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Global Instance Operations in Go\nDESCRIPTION: Demonstrates global instance management including creation, value setting/getting, and type handling with mutation control.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_60\n\nLANGUAGE: go\nCODE:\n```\n// Create the global type with value type and mutation.\nglobtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)\n// Create the global instance with value and global type.\nglobinst := wasmedge.NewGlobal(globtype, uint64(1000))\n// Delete the global type.\nglobtype.Release()\n\ngotglobtype := globinst.GetGlobalType()\n// The `gotglobtype` got from global instance is owned by the `globinst`\n// and should __NOT__ be released.\nvaltype := gotglobtype.GetValType()\n// The `valtype` will be `wasmedge.ValType_I64`.\nvalmut := gotglobtype.GetMutability()\n// The `valmut` will be `wasmedge.ValMut_Var`.\n\nglobinst.SetValue(uint64(888))\n// Set the value u64(888) to the global.\n// This function will do nothing if the value type mismatched or the\n// global mutability is `wasmedge.ValMut_Const`.\ngotval := globinst.GetValue()\n// The `gotbal` will be `interface{}` which the type is `uint64` and\n// the value is 888.\n\nglobinst.Release()\n```\n\n----------------------------------------\n\nTITLE: Building axum server with cargo and wasmedge\nDESCRIPTION: This set of commands builds the axum-based HTTP server for WasmEdge, compiles it using the AOT compiler for improved performance, and runs the compiled WebAssembly module. The `RUSTFLAGS` environment variable sets configurations for wasmedge and tokio.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/server-axum\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler for better performance\nwasmedge compile target/wasm32-wasip1/release/wasmedge_axum_server.wasm wasmedge_axum_server.wasm\n\n# Run the example\nwasmedge wasmedge_axum_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Building hyper server with cargo and wasmedge\nDESCRIPTION: This set of commands builds the hyper-based HTTP server for WasmEdge, compiles it using the AOT compiler for improved performance, and runs the compiled WebAssembly module. The `RUSTFLAGS` environment variable sets configurations for wasmedge and tokio.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/server\n\n# Build the Rust code\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasip1/release/wasmedge_hyper_server.wasm wasmedge_hyper_server.wasm\n\n# Run the example\nwasmedge wasmedge_hyper_server.wasm\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Functions with WasmEdge Go SDK\nDESCRIPTION: Go code demonstrating how to use the WasmEdge Go SDK to execute a WebAssembly function from a file. It sets up the VM, runs the 'fib' function, and prints the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Set the logging level.\n  wasmedge.SetLogErrorLevel()\n\n  // Create the configure context and add the WASI support.\n  // This step is not necessary unless you need WASI support.\n  conf := wasmedge.NewConfigure(wasmedge.WASI)\n  // Create VM with the configure.\n  vm := wasmedge.NewVMWithConfig(conf)\n\n  res, err := vm.RunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(21))\n  if err == nil {\n    fmt.Println(\"Get fibonacci[21]:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Run failed:\", err.Error())\n  }\n\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing WasmEdge VM Contexts\nDESCRIPTION: C code demonstrating the creation and management of WasmEdge VM contexts with custom configurations and store contexts. Shows proper resource management and retrieving the statistics context from a VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/*\n * The VM context already contains the statistics context and can be retrieved\n * by this API.\n */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by\n * VM APIs should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Server with curl\nDESCRIPTION: Execute HTTP requests against the deployed WebAssembly HTTP server to demonstrate functionality\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8080/\ncurl http://localhost:8080/echo -X POST -d \"Hello WasmEdge\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory in Host Functions with CallingFrame Object\nDESCRIPTION: Example demonstrating how to use the CallingFrame object to access the memory instance of the module on the calling stack. This allows host functions to read from and write to WebAssembly memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_59\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  \"encoding/binary\"\n  \"fmt\"\n)\n\n// Host function body definition.\nfunc LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {\n  // Function type: {i32} -> {}\n  offset := params[0].(int32)\n\n  // Get the 0th memory instance of the module of the top frame on the stack.\n  mem := callframe.GetMemoryByIndex(0)\n\n  data, err := mem.GetData(uint(offset), 4)\n  if err != nil {\n    return nil, err\n  }\n  fmt.Println(\"u32 at memory[{}]: {}\", offset, binary.LittleEndian.Uint32(data))\n  return nil, wasmedge.Result_Success\n}\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge version information\nDESCRIPTION: This C code retrieves and prints WasmEdge version information, including the full version string, major version, minor version, and patch version. It demonstrates the use of `WasmEdge_VersionGet`, `WasmEdge_VersionGetMajor`, `WasmEdge_VersionGetMinor`, and `WasmEdge_VersionGetPatch` functions. Requires the WasmEdge C API to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Registering WASM Modules in WasmEdge VM\nDESCRIPTION: This snippet demonstrates how to register a WASM module file into a WasmEdge VM context with a specified module name. It also mentions alternative methods for registering modules from different sources.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_44\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString(\"mod\");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, \"fibonacci.wasm\");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBytes()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Reference Types Example\nDESCRIPTION: Example demonstrating how to work with reference types in WasmEdge, including funcref and externref types.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\n/* Generate a externref to NULL. */\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\n/* The `IsNull` will be `TRUE`. */\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `NULL`. */\n\n/* Generate a funcref with function index 20. */\nVal = WasmEdge_ValueGenFuncRef(20);\nuint32_t FuncIdx = WasmEdge_ValueGetFuncIdx(Val);\n/* The `FuncIdx` will be 20. */\n\n/* Generate a externref to `Num`. */\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `&Num`. */\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \"10\" */\nNum += 55;\nprintf(\"%u\\n\", *(uint32_t *)Ptr);\n/* Will print \"65\" */\n```\n\n----------------------------------------\n\nTITLE: Listing and Retrieving Registered Modules in C\nDESCRIPTION: Demonstrates how to enumerate and access all registered modules within a VM context. This is useful for interacting with host functions or predefined modules like WASI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_56\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `VMCxt` is created.\n */\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the registered module names in the VM context. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\n```\n\n----------------------------------------\n\nTITLE: Working with WasmEdge Results\nDESCRIPTION: Demonstrates handling WasmEdge_Result objects, including checking success status, getting error codes and messages, and generating custom results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be \"success\". */\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_WASM. */\n\nRes = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);\n/* Generate the user-defined result with code. */\nCode = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 123. */\nCategory = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */\n```\n\n----------------------------------------\n\nTITLE: Accessing Component Contexts from VM in WasmEdge C API\nDESCRIPTION: Shows how to retrieve the Loader, Validator, and Executor contexts from a VM context. These components enable more direct control over WebAssembly module loading, validation, and execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge on Edge Node\nDESCRIPTION: Curl command to download and execute the WasmEdge installation script, which installs WasmEdge on the edge node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Accessing command line arguments (Rust)\nDESCRIPTION: Retrieves the command-line arguments passed to the program. `env::args()` returns an iterator over the arguments, which are then collected into a `Vec<String>`.  The model and image file names are extracted from the vector at indices 1 and 2, respectively.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet args: Vec<String> = env::args().collect();\nlet model_bin_name: &str = &args[1]; // File name for the PyTorch model\nlet image_name: &str = &args[2]; // File name for the input image\n```\n\n----------------------------------------\n\nTITLE: Configuring Statistics Options in WasmEdge\nDESCRIPTION: Shows how to configure statistics options in the WasmEdge configuration context. These options control instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/*\n * By default, the instruction counting is `FALSE` when running a\n * compiled-WASM or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/*\n * By default, the cost measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/*\n * By default, the time measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Implementing an Addition Host Function in C\nDESCRIPTION: Example of implementing a host function that adds two i32 values in WasmEdge, showing parameter retrieval, computation, and return value generation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_64\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  * Developers should take care about the function type.\n  */\n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WASI Support in WasmEdge VM\nDESCRIPTION: This snippet demonstrates how to enable WASI support in a WasmEdge VM configuration, create a VM context with WASI, and initialize the WASI module instance.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/*\n * The following API can retrieve the built-in registered module instances\n * from the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding configuration is not set\n * when creating the VM context.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                      WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Creating a Table (Rust)\nDESCRIPTION: This Rust snippet checks for the existence of a table named `orders` and creates it if it doesn't exist. If the table exists, it deletes all data from the table.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n    // create table if no tables exist\n    let result = r\"SHOW TABLES LIKE 'orders';\"\n        .with(())\n        .map(&mut conn, |s: String| String::from(s))\n        .await?;\n\n    if result.len() == 0 {\n        // table doesn't exist, create a new one\n        r\"CREATE TABLE orders (order_id INT, production_id INT, quantity INT, amount FLOAT, shipping FLOAT, tax FLOAT, shipping_address VARCHAR(20));\".ignore(&mut conn).await?;\n        println!(\"create new table\");\n    } else {\n        // delete all data from the table.\n        println!(\"delete all from orders\");\n        r\"DELETE FROM orders;\".ignore(&mut conn).await?;\n    }\n```\n\n----------------------------------------\n\nTITLE: Performing an Asynchronous HTTPS GET Request with hyper\nDESCRIPTION: This example illustrates how to perform an asynchronous GET request over HTTPS using hyper and rustls in a WasmEdge environment. It initializes a client with a custom HTTPS connector and processes the received data stream.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nasync fn fetch_https_url(url: hyper::Uri) -> Result<()> {\n    let https = wasmedge_hyper_rustls::connector::new_https_connector(\n        wasmedge_rustls_api::ClientConfig::default(),\n    );\n    let client = Client::builder().build::<_, hyper::Body>(https);\n    let res = client.get(url).await?;\n\n    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();\n    println!(\"{}\", String::from_utf8(body.into()).unwrap());\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Components of VM Context in C\nDESCRIPTION: This snippet outlines how to access the Loader, Validator, and Executor contexts from the VM context for direct usage, emphasizing that they should not be deleted by the developer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_45\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Building and Running HTTPS hyper Demo with Rust\nDESCRIPTION: This bash script guides users through building and running an HTTPS client using the hyper library for WasmEdge. It highlights the configuration of the RUSTFLAGS and the compilation of the wasm file, aiming at demonstrating HTTPS capabilities.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n// Build\ncd wasmedge_hyper_demo/client-https\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\nwasmedge compile target/wasm32-wasip1/release/wasmedge_hyper_client_https.wasm wasmedge_hyper_client_https.wasm\n\n// Run\nwasmedge wasmedge_hyper_client_https.wasm\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Execution of WASM Functions in WasmEdge Go\nDESCRIPTION: This snippet shows how to asynchronously execute WASM functions in WasmEdge using Go. It demonstrates creating a VM, asynchronously running a WASM function, and retrieving the result.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  // Create VM.\n  vm := wasmedge.NewVM()\n\n  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.\n  async := vm.AsyncRunWasmFile(\"fibonacci.wasm\", \"fib\", uint32(20))\n\n  // Block and wait for the execution and get the results.\n  res, err := async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Running Pods in Kubernetes using Bash\nDESCRIPTION: This snippet retrieves information about running Pods in the Kubernetes cluster, specifically displaying their status and IP addresses. It requires appropriate access to the Kubernetes API and that the cluster is up and running.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide\n\nNAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES\ndefault       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   <none>           <none>\n```\n\n----------------------------------------\n\nTITLE: Managing WebAssembly Proposals in WasmEdge Configuration\nDESCRIPTION: Demonstrates how to create a configuration context and manage WebAssembly proposals by adding, removing, and checking their status in the configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.9.x.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\n/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Registering and Executing WASM Modules in WasmEdge with Go\nDESCRIPTION: This snippet demonstrates how to register a WASM module file (`fibonacci.wasm`) in a WasmEdge VM and execute a function (`fib`) from that module. It shows error handling during registration and execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_42\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\nerr = vm.RegisterWasmFile(\"mod\", \"fibonacci.wasm\")\nif err != nil {\n  fmt.Println(\"WASM registration failed:\", err.Error())\n  return\n}\nres, err = vm.ExecuteRegistered(\"mod\", \"fib\", int32(25))\nif err == nil {\n  fmt.Println(\"Get fibonacci[25]:\", res[0].(int32))\n} else {\n  fmt.Println(\"Run failed:\", err.Error())\n}\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Accessing VM Component Contexts in C\nDESCRIPTION: Shows how to retrieve the internal Loader, Validator, and Executor contexts from a VM context. This allows direct access to lower-level functionality while reusing existing instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Downloading and Running WASI-NN Example on Windows\nDESCRIPTION: This snippet provides commands to download the WASM file and run it with the WASI-NN plugin on Windows, utilizing wget and WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nwget https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/wasmedge-ggml/llama/wasmedge-ggml-llama.wasm\nwget https://huggingface.co/QuantFactory/Meta-Llama-3-8B-Instruct-GGUF/blob/main/Meta-Llama-3-8B-Instruct.Q5_K_M.gguf\nwasmedge --dir .:. --env llama3=true --env n_gpu_layers=100 --nn-preload default:GGML:AUTO:Meta-Llama-3-8B-Instruct.Q5_K_M.gguf wasmedge-ggml-llama.wasm default\n```\n\n----------------------------------------\n\nTITLE: Logging into Guest Linux on seL4\nDESCRIPTION: Command to log into the guest Linux operating system running on seL4 after boot.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbuildroot login: root\n```\n\n----------------------------------------\n\nTITLE: Validating WASM Modules with WasmEdge Validator in C\nDESCRIPTION: This code snippet shows how to use the WasmEdge Validator context to validate a WASM module before instantiation. It includes error handling and context management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_61\n\nLANGUAGE: c\nCODE:\n```\n/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf(\"Validation phase failed: %s\\n\", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n```\n\n----------------------------------------\n\nTITLE: JPEG Image Processing Functions in Rust\nDESCRIPTION: Functions for decoding JPEG images and converting them to different color formats and data types\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Function to decode JPEG from buffer and resize to RGB8 format.\npub fn load_jpg_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode JPEG from buffer and resize to BGR8 format.\npub fn load_jpg_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>\n// Function to decode JPEG from buffer and resize to RGB32F format.\npub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n// Function to decode JPEG from buffer and resize to BGR32F format.\npub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>\n```\n\n----------------------------------------\n\nTITLE: Handling WASM Export Type Context in Go\nDESCRIPTION: Examples of working with export type contexts for managing WASM module exports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nvar ast *wasmedge.AST = ...\n// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.\nexptypelist := ast.ListExports()\n// Assume that `exptypelist` is an array listed from the `ast` for the exports.\n\nfor i, exptype := range exptypelist {\n  exttype := exptype.GetExternalType()\n  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,\n  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.\n\n  extname := exptype.GetExternalName()\n  // Get the external name of the exports.\n\n  extval := exptype.GetExternalValue()\n  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,\n  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Asynchronous WASM Function Execution\nDESCRIPTION: Details step-by-step manual loading, validation, instantiation, and asynchronous execution of a WebAssembly module\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  var err error\n  var res []interface{}\n\n  vm := wasmedge.NewVM()\n\n  err = vm.LoadWasmFile(\"fibonacci.wasm\")\n  if err != nil {\n    fmt.Println(\"Load WASM from file FAILED:\", err.Error())\n    return\n  }\n\n  err = vm.Validate()\n  if err != nil {\n    fmt.Println(\"Validation FAILED:\", err.Error())\n    return\n  }\n\n  err = vm.Instantiate()\n  if err != nil {\n    fmt.Println(\"Instantiation FAILED:\", err.Error())\n    return\n  }\n\n  async := vm.AsyncExecute(\"fib\", uint32(25))\n\n  res, err = async.GetResult()\n  if err == nil {\n    fmt.Println(\"Get the result:\", res[0].(int32))\n  } else {\n    fmt.Println(\"Error message:\", err.Error())\n  }\n  async.Release()\n  vm.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying React App for Server-Side Rendering - JavaScript\nDESCRIPTION: This snippet demonstrates modifying the React app's 'index.js' to use the 'hydrate' method instead of 'render' for supporting SSR. This change informs React that the DOM initialized on the server must be rehydrated on the client side.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nReactDOM.hydrate(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating TensorFlow Session in WasmEdge\nDESCRIPTION: This Rust code snippet demonstrates the creation of a TensorFlow session using a model buffer and offers an alternative method for initializing sessions with a saved-model path, critical for managing TensorFlow operations in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// The mod_buf is a vec<u8> which contains the model data.\nlet mut session = wasmedge_tensorflow_interface::TFSession::new(&mod_buf);\n\n// The mod_path is a &str which is the path to saved-model directory.\n// The second argument is the list of tags.\nlet mut session = wasmedge_tensorflow_interface::TFSession::new_from_saved_model(model_path, &[\"serve\"]);\n```\n\n----------------------------------------\n\nTITLE: Sorting and Printing Inference Results in Rust\nDESCRIPTION: Sorts and prints the top-5 classification results from an inference output buffer using a custom function to help interpret the AI output. Key for evaluating model accuracy and performance metrics in Rust.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet results = sort_results(&output_buffer);\nfor i in 0..5 {\n    println!(\n        \"   {}.) [{}]({:.4}){}\",\n        i + 1,\n        results[i].0,\n        results[i].1,\n        imagenet_classes::IMAGENET_CLASSES[results[i].0]\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Function Instances in WasmEdge Go\nDESCRIPTION: This snippet shows how to retrieve and work with function instances in WasmEdge. You can get the function type from a function object which is useful for understanding the function's signature.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_55\n\nLANGUAGE: go\nCODE:\n```\nfuncobj := ...\n// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.\nfunctype := funcobj.GetFunctionType()\n// The `funcobj` retrieved from the module instance should __NOT__ be released.\n// The `functype` retrieved from the `funcobj` should __NOT__ be released.\n\n// For the function object creation, please refer to the `Host Function` guide.\n```\n\n----------------------------------------\n\nTITLE: Implementing a TCP Server in JavaScript\nDESCRIPTION: JavaScript code for creating a TCP server using WasmEdge-specific networking APIs. The server listens on port 8000 and accepts up to 100 connections, handling each client in a separate function.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as net from 'wasi_net';\nimport { TextDecoder } from 'util';\n\nasync function server_start() {\n  print('listen 8000 ...');\n  try {\n    let s = new net.WasiTcpServer(8000);\n    for (var i = 0; i < 100; i++) {\n      let cs = await s.accept();\n      handle_client(cs);\n    }\n  } catch (e) {\n    print('server accept error:', e);\n  }\n}\n\nserver_start();\n```\n\n----------------------------------------\n\nTITLE: Creating a Fibonacci Function in Go for WasmEdge\nDESCRIPTION: A Go program that implements a function to compute Fibonacci numbers. It includes an empty main() function required for proper OS access setup, and exports the fibArray function for external calls.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/go/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nfunc main(){\n}\n\n//export fibArray\nfunc fibArray(n int32) int32{\n  arr := make([]int32, n)\n  for i := int32(0); i < n; i++ {\n    switch {\n    case i < 2:\n      arr[i] = i\n    default:\n      arr[i] = arr[i-1] + arr[i-2]\n    }\n  }\n  return arr[n-1]\n}\n```\n\n----------------------------------------\n\nTITLE: Building and installing the WasmEdge containerd shim\nDESCRIPTION: Commands to build and install the WasmEdge containerd shim for runwasi. This includes running the Linux setup script, building the WasmEdge-specific components, and installing them with appropriate permissions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Reference: https://github.com/containerd/runwasi/blob/main/CONTRIBUTING.md#setting-up-your-local-environment\ncd runwasi\n./scripts/setup-linux.sh\nmake build-wasmedge\nINSTALL=\"sudo install\" LN=\"sudo ln -sf\" make install-wasmedge\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for youki on Ubuntu 20.04\nDESCRIPTION: This bash snippet installs the necessary dependencies for building youki on Ubuntu 20.04. It also includes the command to install the Rust toolchain if not already present.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install \\\n   curl                \\\n   git                 \\\n   pkg-config          \\\n   libsystemd-dev      \\\n   libdbus-glib-1-dev  \\\n   build-essential     \\\n   libelf-dev          \\\n   libzstd-dev         \\\n   libseccomp-dev      \\\n   libclang-dev\n\n# If you don't have the rust toolchain installed run:\n$ curl https://sh.rustup.rs -sSf | sudo sh -s -- -y\n```\n\n----------------------------------------\n\nTITLE: Deleting Records (Rust)\nDESCRIPTION: This Rust snippet deletes records from the `orders` table where the `order_id` is 4. It then queries the database again to display the current state.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n    // delete some data\n    r\"DELETE FROM orders WHERE order_id=4;\"\n        .ignore(&mut conn)\n        .await?;\n\n    // query data\n    let loaded_orders = \"SELECT * FROM orders\"\n        .with(())\n        .map(\n            &mut conn,\n            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {\n                Order::new(\n                    order_id,\n                    production_id,\n                    quantity,\n                    amount,\n                    shipping,\n                    tax,\n                    shipping_address,\n                )\n            },\n        )\n        .await?;\n    dbg!(loaded_orders.len());\n    dbg!(loaded_orders);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WasmEdge C API Example\nDESCRIPTION: This bash snippet shows how to compile the C code that uses WasmEdge API and run the resulting executable. It demonstrates the output of the compilation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/latest.md#2025-04-21_snippet_90\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n```\n\n----------------------------------------\n\nTITLE: Running inference with log statistics\nDESCRIPTION: This command runs the `llama-chat.wasm` file with WasmEdge, using the specified GGML model and prompt template, and enables logging statistics with `--log-stat`. This provides insights into the model's performance at runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf \\\n  llama-chat.wasm --prompt-template llama-3-chat --log-stat\n```\n\n----------------------------------------\n\nTITLE: Performing an HTTP GET Request with reqwest in Rust\nDESCRIPTION: This Rust code demonstrates performing an asynchronous HTTP GET request using the reqwest library. It expects a URL and returns a JSON response as a HashMap. The function is non-blocking and uses tokio runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let resp = reqwest::get(\"http://eu.httpbin.org/ip\")\n        .await?\n        .json::<HashMap<String, String>>()\n        .await?;\n    println!(\"{:#?}\", resp);\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Registered Modules in WasmEdge\nDESCRIPTION: Shows how to list and retrieve registered modules from the VM context, including handling module names and instances.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_String Names[32];\nuint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the registered module names in the VM context. */\n  printf(\"%s\\n\", Names[I].Buf);\n}\n\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString(\"wasi_snapshot_preview1\");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\n```\n\n----------------------------------------\n\nTITLE: Configuring and Testing Kubernetes Cluster Setup\nDESCRIPTION: Commands to setup the Kubernetes context and verify the cluster is running correctly. This script configures the kubectl client with the necessary certificates and checks the cluster status.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport KUBERNETES_PROVIDER=local\n\nsudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\nsudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\nsudo cluster/kubectl.sh config set-context local --cluster=local --user=myself\nsudo cluster/kubectl.sh config use-context local\nsudo cluster/kubectl.sh\n```\n\n----------------------------------------\n\nTITLE: Downloading WasmEdge QuickJS + WASI NN Runtime\nDESCRIPTION: This bash snippet downloads the pre-built WasmEdge QuickJS + WASI NN runtime program and optionally compiles it for optimized performance using AOT. Requires 'curl' and 'wasmedgec' to be installed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs_nn.wasm\nwasmedgec wasmedge_quickjs_nn.wasm wasmedge_quickjs_nn.wasm\n```\n\n----------------------------------------\n\nTITLE: Install Go on KubeEdge Worker Node\nDESCRIPTION: Installs Go version 1.17.3 on a Linux system at the edge node, adds it to the system PATH, and verifies the Go installation. Requires internet access to download the Go tarball.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Install Go on Edge Side\n$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz\n$ tar xzvf go1.17.3.linux-amd64.tar.gz\n\n$ export PATH=/home/${user}/go/bin:$PATH\n$ go version\ngo version go1.17.3 linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Definition of the WasmEdge_Limit struct which represents WebAssembly limits for tables and memories, specifying minimum and maximum values along with shared memory flags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\n/// Struct of WASM limit.\ntypedef struct WasmEdge_Limit {\n  /// Boolean to describe has max value or not.\n  bool HasMax;\n  /// Boolean to describe is shared memory or not.\n  bool Shared;\n  /// Minimum value.\n  uint32_t Min;\n  /// Maximum value. Will be ignored if the `HasMax` is false.\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge VM in Go\nDESCRIPTION: Sets up and configures a WasmEdge VM instance with WASI support. Demonstrates loading and validating a WASM file, and instantiating the bindgen interface.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/embed-wasm-apps-go.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  var conf = wasmedge.NewConfigure(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportModule(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],     // The args\n    os.Environ(),    // The envs\n    []string{\".:\"}, // The mapping preopens\n  )\n  vm.LoadWasmFile(os.Args[1])\n  vm.Validate()\n\n  // Instantiate the bindgen and vm\n  bg := bindgen.Instantiate(vm)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Memory Type Context in C\nDESCRIPTION: Illustrates the creation of a Memory Type context with specific limits and how to query information from it. This is used for memory instance creation and information retrieval.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Setting up Complete Development Environment\nDESCRIPTION: Complete setup commands including WasmEdge installation, Go SDK installation, and WasmEdge-bindgen tool installation for handling complex data passing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/install.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.16.5 linux/amd64\n\n# Install WasmEdge\n$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}\n\n# Install WasmEdge-Go\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\n\n# Install the WasmEdge-bindgen tool, which helps us handle complex data passing\n$ go get github.com/second-state/wasmedge-bindgen@v0.4.1\n```\n\n----------------------------------------\n\nTITLE: Building WASM file with Cargo (Bash)\nDESCRIPTION: Builds the WASM file from the Rust source code using the `cargo` build tool. The `--target wasm32-wasip1` flag specifies the target architecture as WASM, and the `--release` flag enables optimizations for production builds.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Workloads in KinD with WasmEdge\nDESCRIPTION: Commands to create a KinD cluster with WasmEdge support and run a WebAssembly example. This uses a pre-built image with crun configured for WebAssembly compatibility.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kind.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create a \"WASM in KinD\" Cluster\nkind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0\n# Run the example\nkubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Dockerfile for AWS Lambda with WebAssembly\nDESCRIPTION: Dockerfile to create a container image for AWS Lambda that includes WasmEdge runtime and WebAssembly modules. It uses the AWS Lambda Node.js base image and prepares the WebAssembly modules for execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md#2025-04-21_snippet_5\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM public.ecr.aws/lambda/nodejs:14\n\n# Change directory to /var/task\nWORKDIR /var/task\n\nRUN yum update -y && yum install -y curl tar gzip\n\n# Bundle and pre-compile the wasm files\nCOPY *.wasm ./\nCOPY pre.sh ./\nRUN chmod +x pre.sh\nRUN ./pre.sh\n\n# Bundle the JS files\nCOPY *.js ./\n\nCMD [ \"hello.handler\" ]\n```\n\n----------------------------------------\n\nTITLE: Message Authentication with HMAC-SHA-512 in Rust\nDESCRIPTION: This code snippet shows how to generate a key, generate a tag, and verify the authentication using HMAC-SHA-512 algorithm in Rust with WASI-Crypto. It showcases the use of `AuthKey::generate`, `Auth::auth`, and `Auth::auth_verify` functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasicrypto.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// generate key\nlet key = AuthKey::generate(\"HMAC/SHA-512\")?;\n// generate tag\nlet tag = Auth::auth(\"test\", &key)?;\n// verify\nAuth::auth_verify(\"test\", &key, tag)?;\n```\n\n----------------------------------------\n\nTITLE: Checking crun Installation\nDESCRIPTION: This command verifies the crun installation and lists its version and features, ensuring WasmEdge support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncrun --version\n# Output\ncrun version 1.7.2.0.0.0.26-51af\ncommit: 51af1448f60b69326cf26e726e14b38fcb253943\nrundir: /run/user/0/crun\nspec: 1.0.0\n+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL\n```\n\n----------------------------------------\n\nTITLE: Importing and Using ES6 Modules in JavaScript\nDESCRIPTION: Main script that demonstrates both static and dynamic imports of ES6 modules. It shows how to rename imports, use async/await with dynamic imports, and destructure multiple exports.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/es6.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { hello as module_def_hello } from './module_def.js';\n\nmodule_def_hello();\n\nvar f = async () => {\n  let { hello, something } = await import('./module_def_async.js');\n  await hello();\n  console.log('./module_def_async.js `something` is ', something);\n};\n\nf();\n```\n\n----------------------------------------\n\nTITLE: Go WASI Program Runner\nDESCRIPTION: Go code showing how to run a complete WASI program compiled to WebAssembly. Demonstrates VM configuration, WASI initialization, and program execution.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.SetLogErrorLevel()\n  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)\n  conf.AddConfig(wasmedge.WASI)\n  var vm = wasmedge.NewVMWithConfig(conf)\n  var wasi = vm.GetImportObject(wasmedge.WASI)\n  wasi.InitWasi(\n    os.Args[1:],\n    os.Environ(),\n    []string{\".:.\"},\n  )\n  vm.RunWasmFile(os.Args[1], \"_start\")\n  vm.Release()\n  conf.Release()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Registrations in WasmEdge\nDESCRIPTION: Shows how to check and add host registrations in the WasmEdge configuration context. This example demonstrates enabling WASI support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                      WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge WASINN Examples Repository\nDESCRIPTION: This snippet demonstrates how to clone the WasmEdge-WASINN-examples repository using Git. It provides the necessary commands to set up the local environment for further exploration and usage of the WasmEdge Piper model.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/piper.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/wasmedge-piper/\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Application in Kubernetes using Bash\nDESCRIPTION: This snippet runs a WebAssembly container in the Kubernetes cluster and outputs the result to the console. It requires an existing Kubernetes context and access to Docker Hub for the WebAssembly image.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\nLANGUAGE: bash\nCODE:\n```\nRandom number: 401583443\nRandom bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]\nPrinted from wasi: This is from a main function\nThis is from a main function\nThe env vars are as follows.\nThe args are as follows.\n/wasi_example_main.wasm\n50000000\nFile content is This is in a file\npod \"wasi-demo-2\" deleted\n```\n\n----------------------------------------\n\nTITLE: Running the add function with WasmEdge in reactor mode\nDESCRIPTION: This command runs the add function from the compiled WASM bytecode using the WasmEdge CLI in reactor mode, passing in two parameters (2 and 2), and expecting the result (4) to be printed.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --reactor target/wasm32-wasip1/release/add.wasm add 2 2\n4\n```\n\n----------------------------------------\n\nTITLE: Implementing User-defined Error Codes in Host Functions in C\nDESCRIPTION: Demonstrates how to use user-defined error codes in host functions. This example shows a 'trap' function that returns a custom error code passed as a parameter.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_78\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Trap(void *Data,\n                       const WasmEdge_CallingFrameContext *CallFrameCxt,\n                       const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val = WasmEdge_ValueGetI32(In[0]);\n  /* Return the error code from the param[0]. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Example of registering host modules into a VM context, specifically showing WASI module registration and proper cleanup.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Store Context from VM in WasmEdge C API\nDESCRIPTION: Demonstrates how to get a Store context from a VM context when the VM creates and owns the Store. The retrieved Store should not be manually deleted as it's owned by the VM.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_42\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\n----------------------------------------\n\nTITLE: Adding Git Aliases for Automatic DCO Signoff\nDESCRIPTION: A Git configuration example that creates aliases to automatically include DCO signoffs in all commits. This helps ensure compliance with the Developer Certificate of Origin requirements.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/overview.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[alias]\n  amend = commit -s --amend\n  cm = commit -s -m\n  commit = commit -s\n```\n\n----------------------------------------\n\nTITLE: Initializing WASI Support in WasmEdge with Go\nDESCRIPTION: This snippet demonstrates how to initialize the WASI support in a WasmEdge VM configuration. It creates a configuration object, sets the WASI option, and initializes the VM. Additionally, it retrieves and initializes the WASI import module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_39\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\nconf.Release()\nwasiconf := vm.GetImportModule(wasmedge.WASI)\nwasiconf.InitWasi(/* ... ignored */)\nvm.Release()\n```\n\n----------------------------------------\n\nTITLE: Forcing Interpreter Mode - C\nDESCRIPTION: This snippet shows how to configure the WasmEdge runtime to execute WASM files in interpreter mode, overriding default behaviors.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* By default, The `IsForceInterp` will be `FALSE`. */\nWasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);\nIsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* The `IsForceInterp` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu 22.04\nDESCRIPTION: Commands to install the required dependencies for building WasmEdge on Ubuntu 22.04, including LLVM 14, cmake, and compiler tools.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Tools and libraries\nsudo apt install -y \\\n   software-properties-common \\\n   cmake\n\n# And you will need to install llvm for the AOT runtime\nsudo apt install -y \\\n   llvm-14-dev \\\n   liblld-14-dev\n\n# WasmEdge supports both clang++ and g++ compilers.\n# You can choose one of them to build this project.\n# If you prefer GCC, then:\nsudo apt install -y gcc g++\n# Or if you prefer clang, then:\nsudo apt install -y clang-14\n```\n\n----------------------------------------\n\nTITLE: Configuring kubectl for Local Kubernetes Cluster\nDESCRIPTION: Commands to configure kubectl to connect to the local Kubernetes cluster by setting up authentication credentials and context.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport KUBERNETES_PROVIDER=local\n\nsudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\nsudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\nsudo cluster/kubectl.sh config set-context local --cluster=local --user=myself\nsudo cluster/kubectl.sh config use-context local\nsudo cluster/kubectl.sh\n```\n\n----------------------------------------\n\nTITLE: Reqwest Cargo Dependencies Configuration\nDESCRIPTION: Cargo.toml configuration for reqwest HTTP client with WasmEdge patches and dependencies\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\nsocket2 = { git = \"https://github.com/second-state/socket2.git\", branch = \"v0.5.x\" }\nhyper = { git = \"https://github.com/second-state/wasi_hyper.git\", branch = \"v0.14.x\" }\nreqwest = { git = \"https://github.com/second-state/wasi_reqwest.git\", branch = \"0.11.x\" }\n\n[dependencies]\nreqwest = { version = \"0.11\", default-features = false, features = [\"rustls-tls\"] }\ntokio = { version = \"1\", features = [\"rt\", \"macros\", \"net\", \"time\"] }\n```\n\n----------------------------------------\n\nTITLE: Creating a Node.js HTTP Echo Server in JavaScript\nDESCRIPTION: JavaScript code for a simple HTTP server that echoes back request body data. This code uses Node.js APIs supported by WasmEdge QuickJS to create a lightweight server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createServer, request, fetch } from 'http';\n\ncreateServer((req, resp) => {\n  req.on('data', (body) => {\n    resp.write('echo:');\n    resp.end(body);\n  });\n}).listen(8001, () => {\n  print('listen 8001 ...\\n');\n});\n```\n\n----------------------------------------\n\nTITLE: Compiling crun with WasmEdge Support\nDESCRIPTION: Commands to install dependencies and compile crun with WasmEdge support, which is required to run WebAssembly workloads in a container runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install dependencies\n$ sudo apt update\n$ sudo apt install -y make git gcc build-essential pkgconf libtool \\\n    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \\\n    go-md2man libtool autoconf python3 automake\n\n# Compile crun\n$ git clone https://github.com/containers/crun\n$ cd crun\n$ ./autogen.sh\n$ ./configure --with-wasmedge\n$ make\n$ sudo make install\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge Plugin with CMake Configuration\nDESCRIPTION: CMake configuration to build a WasmEdge plugin as a shared library. It sets up the build target, specifies C11 standard, defines the WASMEDGE_PLUGIN macro, and links against the WasmEdge library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md#2025-04-21_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(wasmedgePluginTest\n  SHARED\n  testplugin.c\n)\n\nset_target_properties(wasmedgePluginTest PROPERTIES\n  C_STANDARD 11\n)\n\ntarget_compile_options(wasmedgePluginTest\n  PUBLIC\n  -DWASMEDGE_PLUGIN\n)\n\ntarget_link_libraries(wasmedgePluginTest\n  PRIVATE\n  wasmedge\n)\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly in Kubernetes\nDESCRIPTION: Command to run a test WebAssembly module in Kubernetes using the crun RuntimeClass. This verifies that the Kubernetes configuration works correctly with WebAssembly workloads.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/knative.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Verify if the configuration works\n$ kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" --overrides='{\"kind\":\"Pod\", \"apiVersion\":\"v1\", \"spec\": {\"hostNetwork\": true, \"runtimeClassName\": \"crun\"}}' /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Drawing Detection Results Rust\nDESCRIPTION: This snippet illustrates the use of the 'draw_detection()' utility function from the 'mediapipe-rs' crate. It processes the detection results by drawing them on the input image, which is then saved to a specified output path.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/mediapipe.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ndraw_detection(&mut input_img, &detection_result);\ninput_img.save(output_path)?;\n```\n\n----------------------------------------\n\nTITLE: Bash: Cloning and Executing Redis Example\nDESCRIPTION: Commands to clone the WasmEdge Redis example repository, compile Rust code to WebAssembly, and execute the Redis client\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/redis_driver.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/redis\n\n# Compile the rust code into WASM\nRUSTFLAGS=\"--cfg wasmedge --cfg tokio_unstable\" cargo build --target wasm32-wasip1 --release\n\n# Execute Redis command against a Redis instance at redis://localhost/\nwasmedge --env \"REDIS_URL=redis://localhost/\" target/wasm32-wasip1/release/wasmedge-redis-client-examples.wasm\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Memory Type Context in C\nDESCRIPTION: Illustrates the creation of a Memory Type context with a specific limit, and how to retrieve the limit information using WasmEdge API functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n```\n\n----------------------------------------\n\nTITLE: Defining Host Function Signature in C\nDESCRIPTION: Defines the standard function signature for host functions in WasmEdge, which requires pointers for data access, calling frame context, parameter values, and return values.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_63\n\nLANGUAGE: c\nCODE:\n```\ntypedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n```\n\n----------------------------------------\n\nTITLE: Defining a Lazy Loaded React Component - JavaScript\nDESCRIPTION: This snippet defines the LazyPage component which is a basic React component containing static content. This component is loaded lazily after a timeout in the LazyHome component.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\n\nclass LazyPage extends React.Component {\n  render() {\n    return (\n      <div>\n        <div>This is lazy page</div>\n      </div>\n    );\n  }\n}\n\nexport default LazyPage;\n```\n\n----------------------------------------\n\nTITLE: Labeling Kubernetes Node for WebAssembly Runtime\nDESCRIPTION: Commands to identify and label the Kubernetes node to support WebAssembly runtime execution by adding the 'runtime=wasm' label.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo cluster/kubectl.sh get nodes\n# Sample output from the command above\nNAME        STATUS     ROLES    AGE    VERSION\n127.0.0.1   Ready   <none>   3h4m   v1.22.2\n# Run the following command to label the node \nsudo cluster/kubectl.sh label nodes 127.0.0.1 runtime=wasm\n# A successful output from the above command looks like this\nnode/127.0.0.1 labeled\n```\n\n----------------------------------------\n\nTITLE: Building the WASM file with cargo\nDESCRIPTION: This command builds the `llama-chat.wasm` file from the Rust source code using Cargo. The `--target wasm32-wasip1` option specifies that the output should be a WASM file compatible with the WASI standard.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Use Image Classification Microservice\nDESCRIPTION: This command uses the image classification microservice to classify an image. It sends a POST request with binary image data and receives a text label indicating the detected object and its confidence.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ cd docs\n$ curl http://localhost:9006/classify -X POST --data-binary '@food.jpg'\nhotdog is detected with 255/255 confidence\n```\n\n----------------------------------------\n\nTITLE: Describe Kubernetes Pod\nDESCRIPTION: This snippet uses `kubectl describe pod` to retrieve detailed information about the `wasi-demo` pod. It displays information such as the pod's status, node assignment, container details, and events.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl describe pod wasi-demo\n```\n\n----------------------------------------\n\nTITLE: Defining WASM Limit Structure in C\nDESCRIPTION: Defines the WasmEdge_Limit struct used to represent WASM limits. It includes fields for minimum and maximum values, as well as flags for maximum value presence and shared memory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct WasmEdge_Limit {\n  bool HasMax;\n  bool Shared;\n  uint32_t Min;\n  uint32_t Max;\n} WasmEdge_Limit;\n```\n\n----------------------------------------\n\nTITLE: Building Go SDK Example\nDESCRIPTION: These commands build the Go SDK example. The first command retrieves the WasmEdge-go library using `go get`, and the second command compiles the `run.go` file into an executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}\ngo build run.go\n```\n\n----------------------------------------\n\nTITLE: Compiling C Application with SIMD Support Using Emscripten\nDESCRIPTION: Command for compiling a C application with SIMD instructions to WebAssembly using Emscripten compiler. The command includes optimization flags, memory settings, and WebAssembly feature flags.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/simd.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nemcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \\\n  -mmutable-globals \\\n  -mnontrapping-fptoint \\\n  -msign-ext \\\n  mandelbrot-simd.c -o mandelbrot-simd.wasm\n```\n\n----------------------------------------\n\nTITLE: Building crun with WasmEdge Support\nDESCRIPTION: This sequence of commands clones the crun repository, configures it with WasmEdge support, builds it, and replaces the existing crun binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/containers/crun\ncd crun\n./autogen.sh\n./configure --with-wasmedge\nmake\nsudo make install\nmv crun $(which crun)\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution - Blocking\nDESCRIPTION: This snippet demonstrates how to wait for the completion of an asynchronous execution using the WasmEdge API. It blocks until the execution is finished and then deletes the Async object.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.13.x.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Rust: Cargo Configuration for WasmEdge Redis Client\nDESCRIPTION: Cargo.toml configuration with necessary patches and dependencies for compiling Redis and Tokio crates for WasmEdge WebAssembly target\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/redis_driver.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n[patch.crates-io]\ntokio = { git = \"https://github.com/second-state/wasi_tokio.git\", branch = \"v1.36.x\" }\n\n[dependencies]\nanyhow = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nredis = { version = \"0.25.4\", default-features = false, features = [\n    \"tokio-comp\",\n] }\n```\n\n----------------------------------------\n\nTITLE: Finding WasmEdge Plugin by Name\nDESCRIPTION: Retrieves a plugin context by its name. This allows accessing a specific plugin's functionality after loading it into the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_86\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = \"wasi_crypto\";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n```\n\n----------------------------------------\n\nTITLE: Registering Host Modules in WasmEdge VM\nDESCRIPTION: Shows how to create and register a WASI host module in a WasmEdge VM, which allows WebAssembly modules to import and use these host functions.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.13.x.md#2025-04-21_snippet_35\n\nLANGUAGE: go\nCODE:\n```\nvm := wasmedge.NewVM()\n// You can also create and register the WASI host modules by this API.\nwasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)\n\nres := vm.RegisterModule(wasiobj)\n// The result status should be checked.\n\nvm.Release()\n// The created import objects should be released.\nwasiobj.Release()\n```\n\n----------------------------------------\n\nTITLE: Cloning Example Repository in Bash\nDESCRIPTION: The code snippet uses git to clone the WasmEdge-WASINN-examples GitHub repository and navigates to the relevant directory, setting up for model and inference execution in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/openvino-mobilenet-image/\n```\n\n----------------------------------------\n\nTITLE: Creating and Using TableType in WasmEdge Go API\nDESCRIPTION: Shows how to create and use TableType objects for defining WASM table instances. Demonstrates setting reference types and limits for tables.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: WASI Initialization with WasmEdge-Go v0.9.2\nDESCRIPTION: Example showing WASI initialization using ImportObject in WasmEdge-Go v0.9.2 before the API changes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure(wasmedge.WASI)\nvm := wasmedge.NewVMWithConfig(conf)\n\n// The following API can retrieve the pre-registration import objects from the VM object.\n// This API will return `nil` if the corresponding pre-registration is not set into the configuration.\nwasiobj := vm.GetImportObject(wasmedge.WASI)\n// Initialize the WASI.\nwasiobj.InitWasi(\n  os.Args[1:],     // The args\n  os.Environ(),    // The envs\n  []string{\".:.\"},  // The mapping preopens\n)\n\n// ...\n\nvm.Release()\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Installing Kubernetes Components on KubeEdge Master Node\nDESCRIPTION: Installs Kubernetes components (kubelet, kubectl, kubeadm) version 1.21.0-00 on the KubeEdge master node.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\nsudo apt-get install -y apt-transport-https curl\necho \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list\n\nsudo apt update\nK_VER=\"1.21.0-00\"\nsudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}\nsudo apt-mark hold kubelet kubeadm kubectl\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Server with cURL\nDESCRIPTION: Command to test the HTTP server using cURL, sending a POST request with data and receiving the echoed response. This shows how to interact with the WasmEdge HTTP server.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"WasmEdge\" -X POST http://localhost:8001/\necho:WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous HTTP GET Request in JavaScript\nDESCRIPTION: JavaScript code demonstrating an asynchronous HTTP GET request using the fetch API. This shows how to make a simple GET request and process the response text.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/networking.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function test_fetch() {\n  try {\n    let r = await fetch('http://httpbin.org/get?id=1');\n    print('test_fetch\\n', await r.text());\n  } catch (e) {\n    print(e);\n  }\n}\ntest_fetch();\n```\n\n----------------------------------------\n\nTITLE: Verifying NVIDIA Driver and Container Toolkit Installation in Bash\nDESCRIPTION: Commands to verify that NVIDIA drivers and Container Toolkit are properly installed on the system. These commands check the available GPU devices and the version of the NVIDIA Container Toolkit.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/docker_wasm_gpu.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# check your driver and device\n> nvidia-smi -L\n\n# Check your toolkit\n> nvidia-ctk --version\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hello World application in Rust with WasmEdge\nDESCRIPTION: This snippet defines a basic Rust function that prints 'Hello WasmEdge!' to the console. It demonstrates how to create a simple executable using Rust that works with WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  let s : &str = \"Hello WasmEdge!\";\n  println!(\"{}\", s);\n}\n```\n\n----------------------------------------\n\nTITLE: Instruction Counter and Cost Table Management\nDESCRIPTION: Demonstrates how to create and use statistics objects for tracking instruction counts and managing instruction costs\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_27\n\nLANGUAGE: go\nCODE:\n```\nstat := wasmedge.NewStatistics()\ncount := stat.GetInstrCount()\nips := stat.GetInstrPerSecond()\n\ncosttable := []uint64{\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n}\nstat.SetCostTable()\nstat.SetCostLimit(5000000)\ncost := stat.GetTotalCost()\nstat.Release()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Custom-Built WasmEdge QuickJS Runtime\nDESCRIPTION: Compile the WebAssembly file with WasmEdge's AOT compiler for improved performance and run a JavaScript example with the custom-built runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge compile target/wasm32-wasip1/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm\nwasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js\n```\n\n----------------------------------------\n\nTITLE: Disabling Swap and Verifying Status in Bash\nDESCRIPTION: This Bash snippet disables swap space on Linux using the `swapoff` command and verifies the status with `free -m`. This is necessary for Kubernetes and OpenYurt configurations.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo swapoff -a\n//verify\nfree -m\n```\n\n----------------------------------------\n\nTITLE: Building Wasm File from Rust Source Using Cargo\nDESCRIPTION: This Bash code snippet builds a WebAssembly binary from Rust source code using Cargo targeting wasm32-wasi architecture. It requires Cargo setup with the correct target.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Managing WASM Table Type Context\nDESCRIPTION: Demonstrates creation and usage of table type contexts for WASM instances, including setting reference types and limits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nlim := wasmedge.NewLimit(12)\ntabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)\n\nrtype := tabtype.GetRefType()\n// `rtype` will be `wasmedge.RefType_ExternRef`.\ngetlim := tabtype.GetLimit()\n// `getlim` will be the same value as `lim`.\n\ntabtype.Release()\n```\n\n----------------------------------------\n\nTITLE: Handling WasmEdge Results and Errors\nDESCRIPTION: Example showing how to handle execution results and custom error creation\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\nres, err = vm.Execute(...) // Ignore the detail of parameters.\n// Assume that `res, err` are the return values for executing a function with `vm`.\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n  category := err.GetErrorCategory()\n  // The `category` will be `wasmedge.ErrCategory_WASM`.\n}\n\nuserdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)\n// Generate the user-defined error with code.\ncode := userdef_err.GetCode()\n// The `Code` will be 123456.\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Status\nDESCRIPTION: Command to verify that the Kubernetes cluster is running properly by displaying the cluster information.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubernetes-cri-o.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo cluster/kubectl.sh cluster-info\n\n# Expected output\nCluster \"local\" set.\nUser \"myself\" set.\nContext \"local\" created.\nSwitched to context \"local\".\nKubernetes control plane is running at https://localhost:6443\nCoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy\n\nTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.\n```\n\n----------------------------------------\n\nTITLE: Adding NPM Scripts for Server Build and Start\nDESCRIPTION: NPM scripts added to package.json for building and starting the server-side rendering application using WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n\"scripts\": {\n  \"dev:build-server\": \"NODE_ENV=development webpack --config webpack.server.js --mode=development\",\n  \"dev:start-server\": \"wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js\",\n  // ...\n},\n```\n\n----------------------------------------\n\nTITLE: Global Instance Retrieval in WasmEdge 0.10.0\nDESCRIPTION: Example showing how to retrieve a global instance using ModuleInstance context in WasmEdge 0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Assume that a WASM module is instantiated in `VMCxt`, and exports the \"global_i32\". */\nconst WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);\n/* The example of retrieving the global instance. */\nWasmEdge_String GlobName = WasmEdge_StringCreateByCString(\"global_i32\");\nWasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_ModuleInstanceFindGlobal(ModCxt, GlobName);\nWasmEdge_StringDelete(GlobName);\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Manual WASM Instantiation and Execution in Bash\nDESCRIPTION: This bash snippet demonstrates how to compile the C code that manually instantiates and asynchronously executes a WASM function, and then run the resulting executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 121393\n```\n\n----------------------------------------\n\nTITLE: Handling WasmEdge Results\nDESCRIPTION: Example of error handling and working with Result objects in WasmEdge-go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Assume that `vm` is a `wasmedge.VM` object.\nres, err = vm.Execute(...) // Ignore the detail of parameters.\n// Assume that `res, err` are the return values for executing a function with `vm`.\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n  category := err.GetErrorCategory()\n  // The `category` will be `wasmedge.ErrCategory_WASM`.\n}\n\nuserdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)\n// Generate the user-defined error with code.\ncode := userdef_err.GetCode()\n// The `Code` will be 123456.\n```\n\n----------------------------------------\n\nTITLE: Building and Installing wasmedge-containerd-shim\nDESCRIPTION: Commands to build and install the WasmEdge containerd shim component from the runwasi project. Includes setup script execution and make commands with sudo privileges.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/cri-runtime/containerd.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd runwasi\n./scripts/setup-linux.sh\nmake build-wasmedge\nINSTALL=\"sudo install\" LN=\"sudo ln -sf\" make install-wasmedge\n```\n\n----------------------------------------\n\nTITLE: Querying Tag Type Context in WasmEdge\nDESCRIPTION: Example of retrieving tag type information from a tag instance. This functionality is only available when the Exception Handling proposal is enabled in WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_19\n\nLANGUAGE: c\nCODE:\n```\n/* Get the tag type from a tag instance. */\nconst WasmEdge_TagTypeContext *TagTypeCxt = WasmEdge_TagInstanceGetTagType(...);\n\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_TagTypeGetFunctionType(TagTypeCxt);\n```\n\n----------------------------------------\n\nTITLE: Loading WasmEdge Plugins from Default Paths\nDESCRIPTION: Loads WasmEdge plugins from default search paths, including environment variables, installation directories, and system directories. This enables extending the WasmEdge runtime with additional functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_83\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\n```\n\n----------------------------------------\n\nTITLE: Building and Packaging a Rust SDK for a WasmEdge Plugin\nDESCRIPTION: Commands for building a Rust library using Cargo and packaging it into a tarball. These steps are necessary when creating a Rust SDK for a WasmEdge plugin that other developers can use.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/best_practice.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --release\n```\n\nLANGUAGE: bash\nCODE:\n```\ntar czvf wasmedge_image_rust_sdk.tar.gz libwasmedge_image.so wasmedge_image.h\n```\n\n----------------------------------------\n\nTITLE: Editing Build Script for Memory Usage Control\nDESCRIPTION: This snippet shows how to modify the build script to restrict parallelization and manage memory usage during the build process by adding a -j parameter to the ninja command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvi build.sh\n```\n\n----------------------------------------\n\nTITLE: Importing React in Components - JavaScript\nDESCRIPTION: This snippet emphasizes the requirement to import React in the App component to ensure that it is recognized during server-side rendering, helping maintain consistency with SSR practices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md#2025-04-21_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\n//...\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge TensorFlow Application in Go\nDESCRIPTION: These bash commands demonstrate how to build the Go host application with WasmEdge Go SDK and run the resulting executable. The application calls the WebAssembly function in WasmEdge to perform inference on an input image.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/ai.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n\n./tflite_food rust_tflite_food_lib.wasm food.jpg\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compiler Options in Go\nDESCRIPTION: Example of setting optimization level, output format, and other compiler options for the WasmEdge AOT compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\n// By default, the optimization level is O3.\nconf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)\n// By default, the output format is universal WASM.\nconf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)\n// By default, the dump IR is `false`.\nconf.SetCompilerDumpIR(true)\n// By default, the generic binary is `false`.\nconf.SetCompilerGenericBinary(true)\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Using WasmEdge Runtime CLI in Go\nDESCRIPTION: Example of using the RunWasmEdgeCLI() API, which provides the same functionality as the 'wasmedge run' command. It passes command line arguments directly to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_71\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"os\"\n  \"github.com/second-state/WasmEdge-go/wasmedge\"\n)\n\nfunc main() {\n  wasmedge.RunWasmEdgeCLI(os.Args)\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running WASM Execution Example in Bash\nDESCRIPTION: This bash snippet shows how to compile the C code that uses the WasmEdge API to execute a WASM module, and then run the resulting executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_59\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for WebAssembly HTTP Server with WasmEdge\nDESCRIPTION: Dockerfile configuration to run a WebAssembly-based HTTP server using the WasmEdge runtime. It sets up a container that runs the http_server.wasm application with proper directory mapping.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md#2025-04-21_snippet_2\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM wasmedge/slim-runtime:0.10.1\nADD http_server.wasm /\nCMD [\"wasmedge\", \"--dir\", \".:/\", \"/http_server.wasm\"]\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Function Types\nDESCRIPTION: Shows how to create function types with parameter and return value specifications using WasmEdge Go API\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunctype := wasmedge.NewFunctionType(\n  []wasmedge.ValType{\n    wasmedge.ValType_ExternRef,\n    wasmedge.ValType_I32,\n    wasmedge.ValType_I64,\n  }, []wasmedge.ValType{\n    wasmedge.ValType_F32,\n    wasmedge.ValType_F64,\n  })\n\nplen := functype.GetParametersLength()\nrlen := functype.GetReturnsLength()\nplist := functype.GetParameters()\nrlist := functype.GetReturns()\n\nfunctype.Release()\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded Plug-ins in Go\nDESCRIPTION: This snippet demonstrates how to retrieve and print the names of all loaded WasmEdge plug-ins after they have been initialized using the `ListPlugins` method.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\npluginnames := wasmedge.ListPlugins()\nfor _, name := range pluginnames {\n  fmt.Println(\"Loaded plug-in name: \", name)\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust with WASM Target\nDESCRIPTION: This Bash command showcases how to compile Rust code into WASM using a specific WASM target, a necessary step for deploying Rust applications as WebAssembly modules with WasmEdge support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target=wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Store Context Management in WasmEdge VM\nDESCRIPTION: Demonstrates creating and managing Store contexts within a WasmEdge VM context. Shows both automatic and manual Store context lifecycle management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.10.x.md#2025-04-21_snippet_47\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n```\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n```\n\n----------------------------------------\n\nTITLE: Generating and Verifying CDI Specification for NVIDIA GPUs\nDESCRIPTION: Commands to generate the CDI specification file for NVIDIA GPUs and verify the CDI configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml\n\n# Check you cdi config is good\n> nvidia-ctk cdi list\n\n# Example output\nINFO[0000] Found 2 CDI devices\nnvidia.com/gpu=0\nnvidia.com/gpu=all\n```\n\n----------------------------------------\n\nTITLE: Getting Results from Asynchronous Execution in WasmEdge-go\nDESCRIPTION: Demonstrates how to retrieve results from asynchronous WebAssembly function execution. Shows the blocking wait pattern to get return values when execution completes.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.9.x.md#2025-04-21_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution and get the return values.\nres, err := async.GetResult()\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Install Kwasm Operator with Helm\nDESCRIPTION: This command installs the Kwasm operator into the Kubernetes cluster using Helm. The command also creates a namespace called \"kwasm\" if it doesn't already exist.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhelm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator\n```\n\n----------------------------------------\n\nTITLE: Checking WasmEdge Version in Go\nDESCRIPTION: Go code snippet to check the installed WasmEdge shared library version using the Version APIs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/second-state/WasmEdge-go/wasmedge\"\n\nverstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.\nvermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.\nverminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.\nverpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Execution Completion in WasmEdge C API\nDESCRIPTION: Demonstrates how to wait for an asynchronous execution to finish using WasmEdge_AsyncWait() and properly clean up resources with WasmEdge_AsyncDelete().\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.12.x.md#2025-04-21_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n```\n\n----------------------------------------\n\nTITLE: Hello World JavaScript Program for WasmEdge\nDESCRIPTION: A simple JavaScript program that imports OS and standard modules, prints command line arguments, and demonstrates setTimeout functionality.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as os from 'os';\nimport * as std from 'std';\n\nargs = args.slice(1);\nprint('Hello', ...args);\nsetTimeout(() => {\n  print('timeout 2s');\n}, 2000);\n```\n\n----------------------------------------\n\nTITLE: Running a WASI Application on Fedora with Podman\nDESCRIPTION: This command runs a simple WASI application using Podman on Fedora, with the WasmEdge runtime as the default.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npodman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Application on KubeEdge\nDESCRIPTION: Command to run a WebAssembly-based container image on the Kubernetes cluster. It uses a WASI example image and passes arguments to the WebAssembly module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/kubernetes/kubedge.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl run -it --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=\"module.wasm.image/variant=compat-smart\" /wasi_example_main.wasm 50000000\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge QuickJS from Source\nDESCRIPTION: Clone the repository and build the QuickJS JavaScript interpreter targeting the WebAssembly System Interface (WASI) platform.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# get the source code\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n\n# Build the QuickJS JavaScript interpreter\ncargo build --target wasm32-wasip1 --release\n```\n\n----------------------------------------\n\nTITLE: Processing and Displaying Classification Results\nDESCRIPTION: Rust code for sorting and displaying top-5 classification results from the model output.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet results = sort_results(&output_buffer);\nfor i in 0..5 {\n    println!(\n        \"   {}.) [{}]({:.4}){}\",\n        i + 1,\n        results[i].0,\n        results[i].1,\n        imagenet_classes::AIY_BIRDS_V1[results[i].0]\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Compiling RustPython - Rust\nDESCRIPTION: The commands clone the RustPython repository and compile it for the wasm32-wasip1 target, including the Python standard library in the output binary.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/RustPython/RustPython.git\ncd RustPython\ncargo build --release --target wasm32-wasip1 --features=\"freeze-stdlib\"\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge with the Process Plugin\nDESCRIPTION: Command to execute a WebAssembly file using WasmEdge with the Process plugin enabled. The command specifies directory access, reactor mode, and the path to the Process plugin shared library.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/process.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm\n```\n\n----------------------------------------\n\nTITLE: Running TensorFlow Lite Inference with WasmEdge\nDESCRIPTION: This Bash command runs the TensorFlow Lite inference using the WasmEdge runtime. It requires the WasmEdge CLI and TensorFlow model and image files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg\n```\n\n----------------------------------------\n\nTITLE: Wrapping Buffer as WasmEdge String\nDESCRIPTION: Shows how to wrap an existing buffer as a WasmEdge_String without copying the content. Note that the caller must manage the buffer lifecycle.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nconst char CStr[] = \"test\";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly HTTP Service with curl\nDESCRIPTION: Command to test the deployed WebAssembly HTTP service by sending a POST request to the service endpoint and receiving the echoed response.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -d \"name=WasmEdge\" -X POST http://127.0.0.1:1234\necho: name=WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Moving TensorflowLite Libraries to System Path (Linux)\nDESCRIPTION: Commands to move the extracted TensorflowLite libraries to the system library path on Linux platforms, making them available to the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflowlite.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmv libtensorflowlite_c.so /usr/local/lib\nmv libtensorflowlite_flex.so /usr/local/lib\n```\n\n----------------------------------------\n\nTITLE: Installing and Running RISCV-Lab Environment for WasmEdge\nDESCRIPTION: Sets up the RISCV-Lab environment which provides an Ubuntu 22.04 system with riscv64 architecture for building WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/tinylab/cloud-lab.git\ncd cloud-lab\nLOGIN=bash tools/docker/run riscv-lab\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Asynchronous WASM Execution in Bash\nDESCRIPTION: This bash snippet shows how to compile the C code that asynchronously executes a WASM function and run the resulting executable.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\n$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n```\n\n----------------------------------------\n\nTITLE: Running the Module Demo with WasmEdge\nDESCRIPTION: Command to execute the demo.js file with WasmEdge QuickJS while mounting the current directory to make the modules available.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js\nhello from \"my_mod_1.js\"\nhello from \"my_mod_2.js\"\n```\n\n----------------------------------------\n\nTITLE: Creating Go Project for WasmEdge\nDESCRIPTION: This bash code snippet demonstrates how to create a Go project for using WasmEdge. It creates a directory, navigates into it, and initializes a Go module.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.12.x.md#2025-04-21_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Hello World Go Program with WasmEdge\nDESCRIPTION: Commands to compile a Go program to WebAssembly using TinyGo targeting the WASI interface, and then running the compiled WebAssembly module with WasmEdge CLI.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/go/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntinygo build -o hello.wasm -target wasi main.go\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge hello.wasm\nHello TinyGo from WasmEdge!\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded WasmEdge Plugins\nDESCRIPTION: Example showing how to enumerate loaded plugins and print their names.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_PluginLoadWithDefaultPaths();\nprintf(\"Number of loaded plug-ins: %d\\n\", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf(\"Plug-in %d name: %s\\n\", I, Names[I].Buf);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Interpreter Mode in Go\nDESCRIPTION: Example of forcing interpreter mode for WebAssembly execution, even for AOT-compiled modules, available in WasmEdge v0.11.2 or newer.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/go/reference/0.11.x.md#2025-04-21_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nconf := wasmedge.NewConfigure()\n\nis_forceinterp := conf.IsForceInterpreter()\n// By default, the `is_forceinterp` will be `false`.\nconf.SetForceInterpreter(true)\nis_forceinterp = conf.IsForceInterpreter()\n/* The `is_forceinterp` will be `true`. */\n\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Running Hello World WebAssembly Example\nDESCRIPTION: Command to execute the hello.wasm example, which prints a greeting and performs a simple calculation using WasmEdge on seL4.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge_emit /usr/bin/hello.wasm\n```\n\n----------------------------------------\n\nTITLE: WasmEdge String Creation and Management\nDESCRIPTION: Examples of creating, manipulating, and converting WasmEdge strings using various API functions\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.13.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\\nWasmEdge_StringDelete(Str1);\\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Running a JavaScript Hello World Program in WasmEdge\nDESCRIPTION: Execute a simple JavaScript program using the WasmEdge QuickJS runtime with directory permissions to access local files.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime\nHello WasmEdge Runtime\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge Version\nDESCRIPTION: Provides code snippets to retrieve the major, minor, and patch version of the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\nprintf(\"WasmEdge version: %s\\n\", WasmEdge_VersionGet());\nprintf(\"WasmEdge version major: %u\\n\", WasmEdge_VersionGetMajor());\nprintf(\"WasmEdge version minor: %u\\n\", WasmEdge_VersionGetMinor());\nprintf(\"WasmEdge version patch: %u\\n\", WasmEdge_VersionGetPatch());\n```\n\n----------------------------------------\n\nTITLE: Creating and Deleting WasmEdge Bytes\nDESCRIPTION: Shows how to create a WasmEdge_Bytes object from a buffer and the importance of memory management.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nuint8_t Buf[4] = {1, 2, 3, 4};\nWasmEdge_Bytes Bytes = WasmEdge_BytesCreate(Buf, 4);\n/* The objects should be deleted by `WasmEdge_BytesDelete()`. */\nWasmEdge_BytesDelete(Bytes);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Execution Result Handling\nDESCRIPTION: Demonstrates retrieving and managing asynchronous WebAssembly function execution results with timeout handling\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nasync := ... // Ignored. Asynchronous execute a function.\n\n// Blocking and waiting for the execution with the timeout(ms).\nisend := async.WaitFor(1000)\nif isend {\n  res, err := async.GetResult()\n  // ...\n} else {\n  async.Cancel()\n  _, err := async.GetResult()\n  // The error message in `err` will be \"execution interrupted\".\n}\nasync.Release()\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom JavaScript Module (my_mod_2.js)\nDESCRIPTION: Example of defining a simple JavaScript module that exports a 'hello_mod_2' function which logs a message to the console.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport function hello_mod_2() {\n  console.log('hello from \"my_mod_2.js\"');\n}\n```\n\n----------------------------------------\n\nTITLE: Installing youki Dependencies on Ubuntu\nDESCRIPTION: Command to install system-level dependencies required for building youki with package management tools\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install \\\n   curl                \\\n   git                 \\\n   pkg-config          \\\n   libsystemd-dev      \\\n   libdbus-glib-1-dev  \\\n   build-essential     \\\n   libelf-dev          \\\n   libzstd-dev         \\\n   libseccomp-dev      \\\n   libclang-dev\n```\n\n----------------------------------------\n\nTITLE: Installing crun and WasmEdge on Fedora\nDESCRIPTION: Commands to install crun and WasmEdge packages on Fedora Linux. This prepares the system for running WebAssembly applications in containers.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/crun.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf -y install wasmedge\nsudo dnf -y install crun\n```\n\n----------------------------------------\n\nTITLE: Global Instance Retrieval in v0.10.0\nDESCRIPTION: Updated example showing how to retrieve a global instance using the new GetActiveModule() API in WasmEdge-Go v0.10.0.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Assume that a WASM module is instantiated in `vm`, and exports the \"global_i32\".\nmod := vm.GetActiveModule()\n\n// The example of retrieving the global instance.\nglobinst := mod.FindGlobal(\"global_i32\")\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge in Non-Interactive Mode\nDESCRIPTION: Uninstalls WasmEdge without prompting for confirmation by using the --quick or -q flag, suitable for scripted or automated removal.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge using Bash Script\nDESCRIPTION: Curl command to download and execute the WasmEdge installation script. The script installs WasmEdge with the same version as WasmEdge-go.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge Using the Uninstall Script\nDESCRIPTION: Command to uninstall WasmEdge by downloading and executing the uninstall script. This will remove WasmEdge from the default installation location.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/install.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)\n```\n\n----------------------------------------\n\nTITLE: Installing WasmEdge Runtime on Edge Nodes\nDESCRIPTION: Script to install WasmEdge on edge nodes using the WasmEdge project's installation script. This is required to support WebAssembly workloads.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded WasmEdge Plug-ins in Go\nDESCRIPTION: Demonstrates how to list the names of loaded WasmEdge plug-ins using the ListPlugins function and iterating over the results.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/go_sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nwasmedge.LoadPluginDefaultPaths()\npluginnames := wasmedge.ListPlugins()\nfor _, name := range pluginnames {\n  fmt.Println(\"Loaded plug-in name: \", name)\n}\n```\n\n----------------------------------------\n\nTITLE: Build and Run Scripts\nDESCRIPTION: Shell script for building and running the WasmEdge web application.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\ncd $(dirname $0)\n\ncd ./client\n\n./build-wasm.sh\n\ncd ../server-wasmedge\n\nOUTPUT_CSS=\"$(pwd)/../client/build/app.css\" cargo run -p isomorphic-server-wasmedge\n```\n\n----------------------------------------\n\nTITLE: HTML Output without SSR\nDESCRIPTION: This HTML snippet shows the output in the browser before implementing server-side rendering, containing only the root div element.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/ssr.md#2025-04-21_snippet_22\n\nLANGUAGE: html\nCODE:\n```\n<div id=\"root\"></div>\n```\n\n----------------------------------------\n\nTITLE: Running HTTP Server Example in WasmEdge\nDESCRIPTION: Command to execute the HTTP server example JavaScript file using WasmEdge runtime. The server listens on port 8001 and responds to HTTP requests.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_server.js\n```\n\n----------------------------------------\n\nTITLE: Generating Rust Code from WIT and Saving to File\nDESCRIPTION: Command to generate Rust code from the WIT file using witc and save it to a new file src/generated.rs.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nwitc plugin wasmedge_opencvmini.wit > src/generated.rs\n```\n\n----------------------------------------\n\nTITLE: Cloning the wasmedge-quickjs Repository\nDESCRIPTION: Clone the wasmedge-quickjs repository and navigate to its directory to set up the QuickJS runtime environment for WasmEdge.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/wasmedge-quickjs\ncd wasmedge-quickjs\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up OpenVINO Example Project\nDESCRIPTION: Commands to clone the WasmEdge-WASINN-examples repository and navigate to the OpenVINO example directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/openvino.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/openvino-mobilenet-image/\n```\n\n----------------------------------------\n\nTITLE: Installing Podman from Linuxbrew\nDESCRIPTION: Commands to install Podman version 4.0 or higher using Linuxbrew and verify the installation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/gpu/podman_wasm_gpu.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> brew install podman\n\n# Check your podman version and you could add it to your $PATH, too.\n> $HOME/.linuxbrew/opt/podman/bin/podman --version\n```\n\n----------------------------------------\n\nTITLE: WasmEdge String Operations\nDESCRIPTION: Examples of creating and manipulating WasmEdge string objects, including string creation, comparison, and conversion.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/embed/c/reference/0.10.x.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nchar Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString(\"test\");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n```\n\n----------------------------------------\n\nTITLE: Creating Rust SDK Crate for WasmEdge Plug-in\nDESCRIPTION: Command to create a new Rust library crate named opencvmini-sdk for the WasmEdge plug-in.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_rustsdk.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo new --lib opencvmini-sdk && cd opencvmini-sdk\n```\n\n----------------------------------------\n\nTITLE: Building and Running WasmEdge Go Example\nDESCRIPTION: Commands to build and run the WasmEdge Go example, demonstrating the execution of a Fibonacci function in WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.13.x.md#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.13.5\n$ go build\n$ ./wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Input Validation in WasmEdge C Plugin\nDESCRIPTION: Example of proper input validation in a WasmEdge plugin function implementation\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/best_practice.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                        const WasmEdge_Value *In, WasmEdge_Value *Out) {\n      if (In[0].Type != WasmEdge_ValType_I32 || In[1].Type != WasmEdge_ValType_I32) {\n      return WasmEdge_Result_Error;\n      }\n      // Rest of the function...\n   }\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge-WASINN-examples Repository\nDESCRIPTION: Commands to clone and navigate to the WasmEdge-WASINN-examples repository containing Piper backend examples.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/wasinn/piper.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/second-state/WasmEdge-WASINN-examples.git\ncd WasmEdge-WASINN-examples/wasmedge-piper/\n```\n\n----------------------------------------\n\nTITLE: HTTP GET Request Using Reqwest\nDESCRIPTION: Example of making an HTTP GET request using the reqwest library in Rust\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let resp = reqwest::get(\"http://eu.httpbin.org/ip\")\n        .await?\n        .json::<HashMap<String, String>>()\n        .await?;\n    println!(\"{:#?}\", resp);\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WasmEdge-Image Plugin on MacOS\nDESCRIPTION: Commands to install the required dependencies (jpeg-turbo and libpng) for building WasmEdge with the Image plugin on MacOS platforms.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/image.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install jpeg-turbo libpng\n```\n\n----------------------------------------\n\nTITLE: Running RustPython on WasmEdge - Rust\nDESCRIPTION: This command runs the compiled RustPython WebAssembly binary, providing a Python shell within the WebAssembly environment.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge ./target/wasm32-wasip1/release/rustpython.wasm\n```\n\n----------------------------------------\n\nTITLE: AOT Compiling and Running Function-based WebAssembly\nDESCRIPTION: Commands to AOT compile and execute a function-based WebAssembly module using WasmEdge's reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge compile fib.wasm fib.wasm\n\n$ wasmedge --reactor fib.wasm fibArray 10\n34\n```\n\n----------------------------------------\n\nTITLE: WasmEdge Compiler CLI Tool Implementation\nDESCRIPTION: Implementation of the WasmEdge compiler CLI tool using C API, equivalent to 'wasmedge compile' command.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_90\n\nLANGUAGE: c\nCODE:\n```\n#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Build Script Permissions and Execution\nDESCRIPTION: Commands to make the build script executable and run it for the manual installation process.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/os/sel4.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo chmod a+x build.sh\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Hello World Program in C for WebAssembly\nDESCRIPTION: Basic C program that prints 'Hello World!' to demonstrate WasmEdge execution of WebAssembly compiled from C code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/hello_world.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include<stdio.h>\nint main(int argc,char **argv){\n  printf(\"Hello World!\\n\");\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Compiler Target for Rust\nDESCRIPTION: Command to add the wasm32-wasip1 compiler target to Rust, necessary for generating WebAssembly bytecode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/start/usage/serverless/vercel.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-wasip1\n```\n\n----------------------------------------\n\nTITLE: Compiler Optimization Level Enum\nDESCRIPTION: Define different optimization levels for the WasmEdge AOT compiler\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/0.11.x.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nenum WasmEdge_CompilerOptimizationLevel {\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  WasmEdge_CompilerOptimizationLevel_O1,\n  WasmEdge_CompilerOptimizationLevel_O2,\n  // Additional optimization levels...\n};\n```\n\n----------------------------------------\n\nTITLE: Compiling Fibonacci Calculator to WebAssembly\nDESCRIPTION: Command to compile the Fibonacci calculator C program (including multiple source files) to WebAssembly using Emscripten compiler.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/c/hello_world.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nemcc main.c fibonacci.c -o fib.wasm\n```\n\n----------------------------------------\n\nTITLE: Hello World Program in Go for WebAssembly\nDESCRIPTION: A simple Go program that prints a message to the console, designed to be compiled to WebAssembly.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nfunc main() {\n  println(\"Hello TinyGo from WasmEdge!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning the WasmEdge Repository in Bash\nDESCRIPTION: Command to clone the WasmEdge repository from GitHub, which is needed to access the Rustls plug-in source code.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/contribute/source/plugin/rusttls.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Toolchain\nDESCRIPTION: Script to install Rust programming language toolchain using rustup for system-wide development\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://sh.rustup.rs -sSf | sudo sh -s -- -y\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge Process Plugin\nDESCRIPTION: Method to initialize the wasmedge_process plugin with optional command whitelist and permissions flag.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)\n```\n\n----------------------------------------\n\nTITLE: Uninstalling WasmEdge on Generic Systems\nDESCRIPTION: Script to uninstall WasmEdge runtime using the official uninstall utility from GitHub repository\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Implementation with Header File\nDESCRIPTION: Multi-file C program implementation of Fibonacci sequence calculation, demonstrating how to structure larger programs for WebAssembly compilation.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/c/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint fib(int n);\n```\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include \"fibonacci.h\"\n\nint fib(int n){\n  int f1 = 0;\n  int f2 = 1;\n  if(n<=2){\n    if(n==1) return f1;\n    else return f2;\n  }\n  else\n    for(int i=2; i<n; i++ ){\n      int temp = f2;\n      f2=f1+f2;\n      f1=temp;\n    }\n  return f2;\n}\n```\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include \"fibonacci.h\"\n\nint main(int argc, char *argv[])\n{\n  if (argc<2) {\n    return 0;\n  }\n  int n = atoi(argv[1]);\n  printf(\"%d\",fib(n));\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Tests on macOS\nDESCRIPTION: Commands to run the WasmEdge test suite, setting the necessary library path for dynamic linking.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/macos.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd build\nDYLD_LIBRARY_PATH=$(pwd)/lib/api ctest\n```\n\n----------------------------------------\n\nTITLE: Cloning and Building wasm-bpf Examples\nDESCRIPTION: Commands to clone the wasm-bpf repository and build the examples.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/eunomia-bpf/wasm-bpf\ncd wasm-bpf/examples\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Source Code on Linux\nDESCRIPTION: Commands to clone the WasmEdge repository from GitHub and navigate to the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Error Handling in WasmEdge VM Execution\nDESCRIPTION: Demonstrates basic error handling and message retrieval when executing WebAssembly functions using WasmEdge VM\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nres, err = vm.Execute(...)\nif err != nil {\n  fmt.Println(\"Error message:\", err.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Git Global Alias Configuration for DCO\nDESCRIPTION: Git configuration aliases to automatically include DCO signoff in commits.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[alias]\n  amend = commit -s --amend\n  cm = commit -s -m\n  commit = commit -s\n```\n\n----------------------------------------\n\nTITLE: Running WasmEdge Application\nDESCRIPTION: Command to execute the compiled WebAssembly module using the WasmEdge runtime.\nSOURCE: https://github.com/wasmedge/docs/blob/main/docs/develop/rust/hello_world.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasmedge target/wasm32-wasip1/release/hello.wasm\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Function with WasmEdge Reactor\nDESCRIPTION: Command to execute a specific function in a WebAssembly module using WasmEdge's reactor mode.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ wasmedge --reactor fib.wasm fibArray 10\n34\n```\n\n----------------------------------------\n\nTITLE: Starting the containerd service\nDESCRIPTION: Command to start the containerd service after installation and configuration.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd-crun.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start containerd\n```\n\n----------------------------------------\n\nTITLE: Initializing WasmEdge Project in Go\nDESCRIPTION: Creates a new Go project directory and initializes a Go module for WasmEdge testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Cloning WasmEdge Repository in Bash\nDESCRIPTION: Commands to clone the WasmEdge repository from GitHub and navigate to the project directory.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/macos.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/WasmEdge/WasmEdge.git\ncd WasmEdge\n```\n\n----------------------------------------\n\nTITLE: Project Setup for WasmEdge Testing\nDESCRIPTION: Shows how to set up a new Go project directory for WasmEdge testing.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\nmkdir wasmedge_test && cd wasmedge_test\ngo mod init wasmedge_test\n```\n\n----------------------------------------\n\nTITLE: Getting WasmEdge-Go Package\nDESCRIPTION: Commands to get and build the WasmEdge-Go package in a Go project\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.9.x.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2\ngo build\n```\n\n----------------------------------------\n\nTITLE: Listing Loaded Plugin Names\nDESCRIPTION: Method to retrieve names of all currently loaded plugins as a vector of strings.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn names() -> Vec<String>\n```\n\n----------------------------------------\n\nTITLE: Managing WasmEdge Context Lifecycles\nDESCRIPTION: Example of creating and properly releasing WasmEdge context objects.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.12.x.md#2025-04-21_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Create a Configure.\nconf := wasmedge.NewConfigure()\n// Release the `conf` immediately.\nconf.Release()\n```\n\n----------------------------------------\n\nTITLE: Quick Uninstall of WasmEdge\nDESCRIPTION: Non-interactive uninstallation of WasmEdge using the quick flag\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/start/install.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q\n```\n\n----------------------------------------\n\nTITLE: Running the Compiled Program\nDESCRIPTION: Shows how to run the compiled C program to print the WasmEdge version.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/latest.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ./a.out\nWasmEdge version: {{ wasmedge_version }}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for WasmEdge Documentation\nDESCRIPTION: Command to install the necessary dependencies for the WasmEdge documentation project using npm.\nSOURCE: https://github.com/wasmedge/docs/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-Go with TensorFlow Extension\nDESCRIPTION: Command to build WasmEdge-Go with TensorFlow extension support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags tensorflow\n```\n\n----------------------------------------\n\nTITLE: Building WasmEdge-Go with Image Extension\nDESCRIPTION: Command to build WasmEdge-Go with Image extension support.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/0.11.x.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngo build -tags image\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Remote\nDESCRIPTION: Command to push the committed changes to the remote repository.\nSOURCE: https://github.com/wasmedge/docs/blob/main/CONTRIBUTING.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit push origin my-new-branch\n```\n\n----------------------------------------\n\nTITLE: Checking Connected Android Devices\nDESCRIPTION: ADB command to list connected Android devices.\nSOURCE: https://github.com/wasmedge/docs/blob/main/i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/build.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nadb devices\n```"
  }
]