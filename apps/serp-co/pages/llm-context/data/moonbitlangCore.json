[
  {
    "owner": "moonbitlang",
    "repo": "core",
    "content": "TITLE: Parsing with strconv.parse_bool, parse_int, parse_double in MoonBit\nDESCRIPTION: This code snippet demonstrates how to use `parse_bool`, `parse_int`, and `parse_double` functions in MoonBit's `strconv` package to convert strings to their corresponding boolean, integer, and double values. The example includes tests to verify the conversions.\nSOURCE: https://github.com/moonbitlang/core/blob/main/strconv/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let b = @strconv.parse_bool!(\"true\")\n  assert_eq!(b, true)\n  let i1 = @strconv.parse_int!(\"1234567\")\n  assert_eq!(i1, 1234567)\n  let i2 = @strconv.parse_int!(\"101\", base=2)\n  assert_eq!(i2, 5)\n  let d = @strconv.parse_double!(\"123.4567\")\n  assert_eq!(d, 123.4567)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Int64 Operations in MoonBit\nDESCRIPTION: Demonstrates basic Int64 operations including literal initialization, conversion from Int, accessing max and min values, and calculating the absolute value. It showcases the use of Int64 literals (suffixed with `L`) and the `from_int` function for conversion. The expected output for each operation is verified using `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int64/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"basic operations\" {\n  let i : Int64 = -12345L // Int64 literal\n  // You can also convert from an `Int` like so:\n  inspect!(@int64.from_int(-12345) == i, content=\"true\")\n\n  // Max and min values\n  inspect!(@int64.max_value, content=\"9223372036854775807\")\n  inspect!(@int64.min_value, content=\"-9223372036854775808\")\n\n  // Absolute value\n  inspect!(@int64.abs(i), content=\"12345\")\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing and Validating JSON in MoonBit\nDESCRIPTION: This snippet demonstrates how to parse and validate JSON strings in MoonBit using the `json` package. It shows how to check if a string is valid JSON and how to parse a JSON string into a `Json` value. The example also includes error handling for different parsing errors and pretty printing the parsed JSON with indentation.\nSOURCE: https://github.com/moonbitlang/core/blob/main/json/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"parse and validate jsons\" {\n  // Check if a string is valid JSON\n  assert_true!(@json.valid(\"{\\\"key\\\": 42}\"))\n  assert_true!(@json.valid(\"[1, 2, 3]\"))\n  assert_true!(@json.valid(\"null\"))\n  assert_true!(@json.valid(\"false\"))\n\n  // Parse JSON string into Json value\n  let json = try {\n    @json.parse!(\"{\\\"key\\\": 42}\")\n  } catch {\n    ParseError::InvalidChar(_, _) => panic()\n    ParseError::InvalidEof => panic()\n    ParseError::InvalidNumber(_, _) => panic()\n    ParseError::InvalidIdentEscape(_) => panic()\n  }\n\n  // Pretty print with indentation\n  inspect!(\n    @json.stringify(json, indent=2),\n    content=\n      #|{\n      #|  \"key\": 42\n      #|} \n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Bitwise Operations\nDESCRIPTION: Demonstrates bitwise operations including AND, OR, XOR, left shift, and right shift with UInt64 values. The `inspect!` macro is used to verify the results of these operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 bitwise operations\" {\n  let a : UInt64 = 0b1010UL\n  let b : UInt64 = 0b1100UL\n\n  // Bitwise AND\n  inspect!(a & b, content=\"8\")\n\n  // Bitwise OR\n  inspect!(a | b, content=\"14\")\n\n  // Bitwise XOR\n  inspect!(a ^ b, content=\"6\")\n\n  // Left shift\n  inspect!(a << 1, content=\"20\")\n  inspect!(a << 2, content=\"40\")\n\n  // Right shift\n  inspect!(a >> 1, content=\"5\")\n  inspect!(b >> 2, content=\"3\")\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Buffer Operations in MoonBit\nDESCRIPTION: This snippet demonstrates fundamental buffer operations in MoonBit, including creating a new buffer, writing bytes, checking its contents (emptiness and length), retrieving the contents as bytes, and resetting the buffer to its initial state. It utilizes the `@buffer.new()` constructor, `write_byte()`, `is_empty()`, `length()`, `contents()`, and `reset()` methods. The `inspect!` macro is used for assertion.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"basic buffer operations\" {\n  let buf = @buffer.new()\n\n  // Write some bytes\n  buf..write_byte(b'H').write_byte(b'i')\n\n  // Check contents\n  inspect!(buf.is_empty(), content=\"false\")\n  inspect!(buf.length(), content=\"2\")\n\n  // Get contents as bytes\n  let bytes = buf.contents()\n  inspect!(\n    bytes,\n    content=\n      #|b\"\\x48\\x69\"\n    ,\n  )\n\n  // Reset buffer\n  buf.reset()\n  inspect!(buf.is_empty(), content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Result Values with ok and err functions in Moonbit\nDESCRIPTION: This code demonstrates how to create `Result` values using the `ok` and `err` functions. Type annotations are provided to specify the types of the success and error values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _result : Result[String, Unit] = ok(\"yes\")\n    let _error : Result[Int, String] = err(\"error\")\n}\n```\n\n----------------------------------------\n\nTITLE: Number Serialization in MoonBit\nDESCRIPTION: This snippet illustrates number serialization in MoonBit using big-endian and little-endian encodings for integers and floating-point numbers. It creates a new buffer, writes integers and floating point numbers using methods like `write_int_be()`, `write_int_le()`, `write_float_be()`, `write_float_le()`, `write_int64_be()`, `write_int64_le()`, `write_uint_be()`, and `write_uint_le()`, and then converts the buffer to bytes using `.to_bytes()`. The `inspect!` macro is used for assertion.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"number serialization\" {\n  inspect!(\n    @buffer.new()\n    // Write integers in different byte orders\n    ..write_int_be(42)\n    ..write_int_le(42)\n    .to_bytes(),\n    content=\n      #|b\"\\x00\\x00\\x00\\x2a\\x2a\\x00\\x00\\x00\"\n    ,\n  )\n  inspect!(\n    @buffer.new()\n    // Write floating point numbers\n    ..write_float_be(3.14)\n    ..write_float_le(3.14)\n    .to_bytes(),\n    content=\n      #|b\"\\x40\\x48\\xf5\\xc3\\xc3\\xf5\\x48\\x40\"\n    ,\n  )\n  inspect!(\n    @buffer.new()\n    // Write 64-bit integers\n    ..write_int64_be(0xAABBCCDDEEL)\n    ..write_int64_le(0xAABBCCDDEEL)\n    .to_bytes(),\n    content=\n      #|b\"\\x00\\x00\\x00\\xaa\\xbb\\xcc\\xdd\\xee\\xee\\xdd\\xcc\\xbb\\xaa\\x00\\x00\\x00\"\n    ,\n  )\n  inspect!(\n    @buffer.new()\n    // Write unsigned integers\n    ..write_uint_be(0x2077U)\n    ..write_uint_le(0x2077U)\n    .to_bytes(),\n    content=\n      #|b\"\\x00\\x00\\x20\\x77\\x77\\x20\\x00\\x00\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Array Operations in MoonBit\nDESCRIPTION: Illustrates common array operations such as filtering, mapping, and folding in MoonBit. It shows how to filter out odd numbers and negate even numbers using `filter_map`, sum an array using `fold`, and find the last element using `last`. The expected output of each operation is inspected.\nSOURCE: https://github.com/moonbitlang/core/blob/main/array/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"array operations\" {\n  let nums = [1, 2, 3, 4, 5]\n\n  // Filtering out odd numbers and negating the remaining\n  let neg_evens = nums.filter_map(fn(x) {\n    if x % 2 == 0 {\n      Some(-x)\n    } else {\n      None\n    }\n  })\n\n  // Summing array\n  let sum = nums.fold(init=0, fn(acc, x) { acc + x })\n\n  // Finding last element\n  let last = nums.last()\n  inspect!(neg_evens, content=\"[-2, -4]\")\n  inspect!(sum, content=\"15\")\n  inspect!(last, content=\"Some(5)\")\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Set and Get Operations in MoonBit\nDESCRIPTION: Illustrates how to add key-value pairs to a HashMap using the `set()` function and retrieve values using `get()`, `get_or_default()`. It also shows how to remove a key-value pair and check if a key exists using `contains()`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map : @hashmap.T[String, Int] = @hashmap.new()\n  map.set(\"a\", 1)\n  assert_eq!(map.get(\"a\"), Some(1))\n  assert_eq!(map.get_or_default(\"a\", 0), 1)\n  assert_eq!(map.get_or_default(\"b\", 0), 0)\n  map.remove(\"a\")\n  assert_eq!(map.contains(\"a\"), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Result Variant with is_ok and is_err in Moonbit\nDESCRIPTION: This code demonstrates how to check the variant of a `Result` using the `is_ok` and `is_err` methods. These methods return a boolean value indicating whether the `Result` is `Ok` or `Err` respectively.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Ok(42)\n    let is_ok = result.is_ok()\n    assert_eq!(is_ok, true)\n    let is_err = result.is_err()\n    assert_eq!(is_err, false)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Result with Pattern Matching in Moonbit\nDESCRIPTION: This code demonstrates how to extract the value from a `Result` using pattern matching with the `match` expression.  It handles both the `Ok` and `Err` variants, providing a default value for the `Err` case.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result : Result[Int, Unit] = Ok(33)\n    let val = match result {\n        Ok(value) => value\n        Err(_) => -1\n    }\n    assert_eq!(val, 33)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting values from an Option using Pattern Matching in MoonBit\nDESCRIPTION: Illustrates how to extract the value from an `Option` using the `match` expression (Pattern Matching). It uses the `Some` and `None` cases to handle both scenarios.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let i = Some(42)\n    let j = match i {\n        Some(value) => value\n        None => abort(\"unreachable\")\n    }\n    assert_eq!(j, 42)\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Arrays in MoonBit\nDESCRIPTION: Demonstrates various sorting utilities in MoonBit, including basic sorting with `sort`, custom comparison sorting with `sort_by`, and sorting by key with `sort_by_key`. It shows how to sort an array of numbers, strings based on length, and pairs based on the first element.\nSOURCE: https://github.com/moonbitlang/core/blob/main/array/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"sorting\" {\n  let arr = [3, 1, 4, 1, 5, 9, 2, 6]\n\n  // Basic sorting - creates new sorted array\n  let sorted1 = arr.copy()\n  sorted1.sort()\n  inspect!(sorted1, content=\"[1, 1, 2, 3, 4, 5, 6, 9]\")\n\n  // Custom comparison\n  let strs = [\"aa\", \"b\", \"ccc\"]\n  let sorted2 = strs\n    .copy()\n    ..sort_by(fn(a, b) { a.length().compare(b.length()) })\n  inspect!(\n    sorted2,\n    content=\n      #|[\"b\", \"aa\", \"ccc\"]\n    ,\n  )\n\n  // Sort by key\n  let pairs = [(2, \"b\"), (1, \"a\"), (3, \"c\")]\n  let sorted3 = pairs.copy()..sort_by_key(fn(p) { p.0 })\n  inspect!(\n    sorted3,\n    content=\n      #|[(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: JSON to Native Type Conversion in MoonBit\nDESCRIPTION: This snippet showcases how to convert JSON values to native MoonBit types using `@json.from_json!`. It demonstrates converting JSON numbers to `Int`, JSON arrays to `Array[Int]`, and JSON maps to `Map[String, Int]`. This feature enables type-safe conversion of JSON data to MoonBit's data structures.\nSOURCE: https://github.com/moonbitlang/core/blob/main/json/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"json decode\" {\n  // Decode basic types\n  let json_number = (42 : Json)\n  let number : Int = @json.from_json!(json_number)\n  inspect!(number, content=\"42\")\n\n  // Decode arrays\n  let json_array = ([1, 2, 3] : Json)\n  let array : Array[Int] = @json.from_json!(json_array)\n  inspect!(array, content=\"[1, 2, 3]\")\n\n  // Decode maps\n  let json_map = ({ \"a\": 1, \"b\": 2 } : Json)\n  let map : Map[String, Int] = @json.from_json!(json_map)\n  inspect!(\n    map,\n    content=\n      #|{\\\"a\\\": 1, \\\"b\\\": 2}\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Numeric Interpretation of Bytes in MoonBit\nDESCRIPTION: Shows how to interpret byte sequences as various numeric types in both little-endian and big-endian formats using MoonBit. It creates `Bytes` from an array of bytes representing an int64, then creates a view of it and uses `to_int64_be` and `to_uint64_le` to interpret the bytes as signed and unsigned 64-bit integers, respectively. The interpretations are then inspected for verification.\nSOURCE: https://github.com/moonbitlang/core/blob/main/bytes/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"numeric interpretation\" {\n  // Create test data\n  let int64_bytes = @bytes.from_array([\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42,\n  ])\n  let int64_view = int64_bytes[:]\n  inspect!(int64_view.to_int64_be(), content=\"66\")\n  inspect!(int64_view.to_uint64_le(), content=\"4755801206503243776\")\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Getting Moonbit Map Values\nDESCRIPTION: Illustrates how to add (set) and retrieve (get) values in a Moonbit Map using keys. Also shows usage of `get_or_default`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map : Map[String, Int] = {}\n  map.set(\"a\", 1)\n  assert_eq!(map.get(\"a\"), Some(1))\n  assert_eq!(map.get_or_default(\"a\", 0), 1)\n  assert_eq!(map.get_or_default(\"b\", 0), 0)\n  @json.inspect!(map, content={ \"a\": 1 })\n  map.set(\"a\", 2) // duplicate key\n  @json.inspect!(map, content={ \"a\": 2 })\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Option values using `filter` method in MoonBit\nDESCRIPTION: Shows how to use the `filter` method to apply a predicate to the value within an `Option`. The `filter` method returns `Some` if the predicate is true, and `None` otherwise.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let some: Int? = Some(42)\n  let new_some = some.filter(fn(value: Int) { value > 40 }) // Some(42)\n  let none = some.filter(fn(value: Int) { value > 50 }) // None\n  assert_eq!(new_some, Some(42))\n  assert_eq!(none, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Floating-Point Operations in MoonBit\nDESCRIPTION: This code snippet showcases basic mathematical operations available in the `double` package in MoonBit, including absolute value, rounding functions (floor, ceil, round, trunc), sign determination, and type conversion from integer to double. The `inspect!` macro is used to verify the results of these operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"basic operations\" {\n  // Absolute value\n  inspect!(@double.abs(-3.14), content=\"3.14\")\n\n  // Rounding functions\n  inspect!(@double.floor(3.7), content=\"3\")\n  inspect!(@double.ceil(3.2), content=\"4\")\n  inspect!(@double.round(3.5), content=\"4\")\n  inspect!(@double.trunc(3.7), content=\"3\")\n\n  // Sign\n  inspect!(@double.signum(-3.14), content=\"-1\")\n  inspect!(@double.signum(2.0), content=\"1\")\n\n  // Type conversion\n  inspect!(@double.from_int(42), content=\"42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Map From Array MoonBit\nDESCRIPTION: Shows how to create a sorted map from an array of key-value pairs using `of()` or `from_array()`. The `elems()` and `keys()` functions are used to retrieve the values and keys respectively, and assertions are made to verify the content of the map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  assert_eq!(map.elems(), [1, 2, 3])\n  assert_eq!(map.keys(), [\"a\", \"b\", \"c\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting values from an Option using `or_else` method in MoonBit\nDESCRIPTION: Illustrates using the `or_else` method to extract a value from an `Option`, using a function to compute the default value if the Option is `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let none: Int? = None\n  let value = none.or_else(fn() -> Int { 0 }) // 0\n  assert_eq!(value, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Result with or_else in Moonbit\nDESCRIPTION: This code demonstrates how to extract a value safely from a `Result` using the `or_else` method. This method takes a function that returns a default value, which is called if the `Result` is `Err`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Err(\"error\")\n    let value = result.or_else(fn() { 0 })\n    assert_eq!(value, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Method Syntax in MoonBit\nDESCRIPTION: Demonstrates the method syntax available for integer operations in MoonBit, including `abs()`, `to_be_bytes()`, and `to_le_bytes()`. The `inspect!` macro is used to assert the results of these operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"method syntax\" {\n  let n = -42\n\n  // Using method syntax\n  inspect!(n.abs(), content=\"42\")\n\n  // Byte conversions using method syntax\n  let be = n.to_be_bytes()\n  let le = n.to_le_bytes()\n  inspect!(\n    be.to_string(),\n    content=\n      #|b\"\\xff\\xff\\xff\\xd6\"\n    ,\n  )\n  inspect!(\n    le.to_string(),\n    content=\n      #|b\"\\xd6\\xff\\xff\\xff\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Reference Values in Moonbit\nDESCRIPTION: This snippet shows how to update the value of a reference using the `update` function. It takes a reference and a transformation function as arguments. The transformation function modifies the current value of the reference. The example updates a counter, incrementing it and then multiplying it by 2, using both `@ref.update` and `counter.update`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/ref/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"updating refs\" {\n  let counter = @ref.new(0)\n  @ref.update(counter, fn(x) { x + 1 })\n  inspect!(counter.val, content=\"1\")\n  counter.update(fn(x) { x * 2 })\n  inspect!(counter.val, content=\"2\")\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Type Conversions\nDESCRIPTION: Demonstrates conversions to and from UInt64 with other types like Int and Double. Includes examples of converting from Int to UInt64, UInt64 to Int, and UInt64 to Double. Also, it shows the overflow handling when converting from negative Int to UInt64, where it wraps around.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 conversions\" {\n  // From Int to UInt64\n  inspect!((42).to_uint64(), content=\"42\")\n\n  // From UInt64 to Int or Double\n  let value : UInt64 = 100UL\n  inspect!(value.to_int(), content=\"100\")\n  let as_double = value.to_double()\n  inspect!(as_double, content=\"100\")\n\n  // Overflow handling in conversions\n  inspect!((-1).to_uint64(), content=\"18446744073709551615\") // Negative numbers wrap around\n\n  // Converting back from floating point\n  let from_double = 42.0.to_uint64()\n  inspect!(from_double, content=\"42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Range Operations on MoonBit SortedMap\nDESCRIPTION: Illustrates how to get a subset of the map within a specified range of keys using the `range` method. The range is inclusive for both bounds. Demonstrates iteration over range.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([\n    (1, \"one\"),\n    (2, \"two\"),\n    (3, \"three\"),\n    (4, \"four\"),\n    (5, \"five\"),\n  ])\n  let range_items = []\n  map.range(2, 4).each(fn(k, v) { range_items.push((k, v)) })\n  assert_eq!(range_items, [(2, \"two\"), (3, \"three\"), (4, \"four\")])\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Result Enum in Moonbit\nDESCRIPTION: This code defines the `Result` enum with two variants: `Ok(T)` representing success with a value of type `T`, and `Err(E)` representing an error with a value of type `E`. This enum is used to handle computation results and errors.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Result[T, E] {\n    Ok(T)\n    Err(E)\n}\n```\n\n----------------------------------------\n\nTITLE: UInt Methods: to_int64, to_be_bytes, to_le_bytes in MoonBit\nDESCRIPTION: This code snippet demonstrates using method syntax for `UInt` to convert it to other types.  It shows how to use the `.to_int64()`, `.to_be_bytes()`, and `.to_le_bytes()` methods directly on a `UInt` variable in MoonBit.  The results of these methods are then inspected to verify their correctness.  The example uses the number 1000U.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"uint methods\" {\n  let num = 1000U\n\n  // Using method syntax\n  inspect!(num.to_int64(), content=\"1000\")\n  inspect!(\n    num.to_be_bytes(),\n    content=\n      #|b\"\\x00\\x00\\x03\\xe8\"\n    ,\n  )\n  inspect!(\n    num.to_le_bytes(),\n    content=\n      #|b\"\\xe8\\x03\\x00\\x00\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting and Looking Up Values in Map MoonBit\nDESCRIPTION: Illustrates how to insert a key-value pair into a sorted map using `add()` and retrieve the value associated with a key using `get()`. The code first creates an empty map, adds a key-value pair, and then asserts that the value can be retrieved correctly.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map : @sorted_map.T[String,Int] = @sorted_map.new()\n  let map = map.add(\"a\", 1)\n  assert_eq!(map.get(\"a\"), Some(1))\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting values from an Option using `or` method in MoonBit\nDESCRIPTION: Shows how to use the `or` method to safely extract a value from an `Option`, providing a default value to return if the Option is `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let none: Int? = None\n  let value = none.or(0) // 0\n  assert_eq!(value, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Immutable Arrays in MoonBit\nDESCRIPTION: Illustrates how to update immutable arrays using `set()` and `push()` in MoonBit. Since arrays are immutable, these operations return a new array with the updated value without modifying the original array.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/array/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let arr1 = @array.of([1, 2, 3, 4, 5])\n  let arr2 = arr1.set(2, 10).push(6)\n  assert_eq!(arr1.to_array(), [1, 2, 3, 4, 5])\n  assert_eq!(arr2.to_array(), [1, 2, 10, 4, 5, 6])\n}\n```\n\n----------------------------------------\n\nTITLE: Rational Arithmetic Operations in MoonBit\nDESCRIPTION: This snippet demonstrates arithmetic operations using the `Rational` type in MoonBit, including addition, subtraction, multiplication, division, negation, reciprocal, and absolute value. It uses the `@rational.new` function to create Rational instances and `assert_eq!` to verify the results of the operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/rational/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let a = @rational.new(1L, 2L).unwrap()\n    let b = @rational.new(1L, 3L).unwrap()\n    assert_eq!(a + b, @rational.new(5L, 6L).unwrap())\n    assert_eq!(a - b, @rational.new(1L, 6L).unwrap())\n    assert_eq!(a * b, @rational.new(1L, 6L).unwrap())\n    assert_eq!(a / b, @rational.new(3L, 2L).unwrap())\n    assert_eq!(a.neg(), @rational.new(-1L, 2L).unwrap())\n    assert_eq!(a.reciprocal(), @rational.new(2L, 1L).unwrap())\n    assert_eq!(a.abs(), @rational.new(1L, 2L).unwrap())\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Iteration in MoonBit\nDESCRIPTION: Demonstrates how to iterate through all key-value pairs in a HashMap using the `each()` and `eachi()` functions. `each()` iterates through the key-value pairs, while `eachi()` iterates with index. These functions take a closure to process each key-value pair.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n   let map = @hashmap.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n   let arr = []\n    map.each(fn(k, v) { arr.push((k, v)) })\n    let arr2 = []\n    map.eachi(fn(i, k, v) { arr2.push((i, k, v)) })\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Lists Moonbit\nDESCRIPTION: Shows how to reduce a list to a single value using the `fold()` method.  The `fold` method takes an initial value and a function that combines the accumulator and the current element. This example sums all elements in the list.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let list = @list.of([1, 2, 3, 4, 5])\n  assert_eq!(list.fold(init=0, fn(acc, x) { acc + x }), 15)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays with Initial Values in MoonBit\nDESCRIPTION: Shows how to create immutable arrays with initial values using `make()` and `makei()` in MoonBit. `make()` initializes all elements with the same value, while `makei()` uses a function to generate values based on the index.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/array/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let arr1 = @array.make(5, 1)\n  assert_eq!(arr1.to_array(), [1, 1, 1, 1, 1])\n  let arr2 = @array.makei(5, fn(i){i + 1})\n  assert_eq!(arr2.to_array(), [1, 2, 3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Large Number Operations\nDESCRIPTION: Shows how UInt64 can be used to represent and perform arithmetic operations with large numbers that exceed the maximum value of smaller integer types.  The code initializes a large number close to the maximum value of UInt64 and demonstrates a multiplication operation.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 for large numbers\" {\n  // UInt64 can represent very large numbers\n  let large_number : UInt64 = (1UL << 63) - 1UL\n\n  // This exceeds a 32-bit integer's maximum value\n  inspect!(large_number > (1UL << 32) - 1UL, content=\"true\")\n\n  // Arithmetic still works with large values\n  let result = large_number * 2UL\n  inspect!(result, content=\"18446744073709551614\") // This effectively calculates 2^64 - 2\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Values in Map MoonBit\nDESCRIPTION: Illustrates how to map a function over all values in a sorted map using `map()` and `map_with_key()`. `map()` applies a function to each value, while `map_with_key()` provides both the key and the value to the function. The example adds 1 to each value and asserts that the new values are as expected.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let map = map.map(fn(v) { v + 1 })\n  assert_eq!(map.elems(), [2, 3, 4])\n  let map = map.map_with_key(fn(_k, v) { v + 1 })\n  assert_eq!(map.elems(), [3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays in MoonBit\nDESCRIPTION: Demonstrates different ways to create arrays in MoonBit, including using array literals, creating arrays with indices using `Array::makei`, and creating arrays from iterators using `Array::from_iter`. It showcases the initialization and expected content of the created arrays.\nSOURCE: https://github.com/moonbitlang/core/blob/main/array/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"array creation\" {\n  // Using array literal\n  let arr1 = [1, 2, 3]\n\n  // Creating with indices\n  let arr2 = Array::makei(3, fn(i) { i * 2 })\n\n  // Creating from iterator\n  let arr3 = Array::from_iter(\"hello\".iter())\n  inspect!(arr1, content=\"[1, 2, 3]\")\n  inspect!(arr2, content=\"[0, 2, 4]\")\n  inspect!(arr3, content=\"['h', 'e', 'l', 'l', 'o']\")\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Bytes in MoonBit\nDESCRIPTION: Illustrates how to convert `Bytes` to and from different formats, including arrays and fixed arrays in MoonBit. It leverages the `to_array` and `to_fixedarray` methods, as well as iterators and `to_array` to demonstrate conversion functionalities. The converted data structures are then inspected for verification.\nSOURCE: https://github.com/moonbitlang/core/blob/main/bytes/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"bytes conversion\" {\n  let original = [b'x', b'y', b'z']\n  let bytes = @bytes.from_array(original)\n\n  // Convert to array\n  let array = bytes.to_array()\n  inspect!(array, content=\"[b'\\\\x78', b'\\\\x79', b'\\\\x7A']\")\n\n  // Convert to fixed array\n  let fixed = bytes.to_fixedarray()\n  inspect!(fixed, content=\"[b'\\\\x78', b'\\\\x79', b'\\\\x7A']\")\n\n  // Convert to iterator and collect back\n  let collected = bytes.iter().to_array()\n  inspect!(collected, content=\"[b'\\\\x78', b'\\\\x79', b'\\\\x7A']\")\n}\n```\n\n----------------------------------------\n\nTITLE: Rational Comparison Operations in MoonBit\nDESCRIPTION: This code snippet illustrates comparison operations for the `Rational` type in MoonBit, showcasing equality, inequality, less than, less than or equal to, greater than, greater than or equal to, and comparison (using `compare`). It relies on `@rational.new` to create Rational objects and `assert_eq!` to check the boolean results of the comparison.\nSOURCE: https://github.com/moonbitlang/core/blob/main/rational/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let a = @rational.new(1L, 2L).unwrap()\n    let b = @rational.new(1L, 3L).unwrap()\n    assert_eq!(a == b, false)\n    assert_eq!(a != b, true)\n    assert_eq!(a < b, false)\n    assert_eq!(a <= b, false)\n    assert_eq!(a > b, true)\n    assert_eq!(a >= b, true)\n    assert_eq!(a.compare(b), 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Key-Value Pairs in MoonBit SortedMap\nDESCRIPTION: Demonstrates how to iterate over all key-value pairs in sorted key order using the `each` method. The snippet extracts keys and values into separate arrays.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(3, \"three\"), (1, \"one\"), (2, \"two\")])\n  let keys = []\n  let values = []\n  map.each(fn(k, v) {\n    keys.push(k)\n    values.push(v)\n  })\n  assert_eq!(keys, [1, 2, 3])\n  assert_eq!(values, [\"one\", \"two\", \"three\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Check Special Float Values in MoonBit\nDESCRIPTION: This snippet demonstrates how to check if a floating-point value is infinite, negative infinite, positive infinite, or NaN (Not a Number) using the `is_inf`, `is_neg_inf`, `is_pos_inf`, and `is_nan` functions from MoonBit's float package. The inspect! macro is employed to verify the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"checking special values\" {\n  // Testing for special values\n  inspect!(@float.is_inf(@float.infinity), content=\"true\")\n  inspect!(@float.is_neg_inf(@float.neg_infinity), content=\"true\")\n  inspect!(@float.is_pos_inf(@float.infinity), content=\"true\")\n  inspect!(@float.is_nan(@float.not_a_number), content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Result Values with map in Moonbit\nDESCRIPTION: This code demonstrates how to transform the value inside a `Result` using the `map` method. The function passed to `map` is only applied if the `Result` is `Ok`; otherwise, the `Result` remains unchanged.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Ok(42)\n    let new_result = result.map(fn(x) { x + 1 })\n    assert_eq!(new_result, Ok(43))\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Comparison and Equality\nDESCRIPTION: Shows how to use comparison and equality operators with UInt64 values. Includes examples for equality (`==`), inequality (`!=`), greater than (`>`), less than (`<`), greater than or equal to (`>=`), and less than or equal to (`<=`).\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 comparison and equality\" {\n  let a : UInt64 = 100UL\n  let b : UInt64 = 50UL\n  let c : UInt64 = 100UL\n\n  // Equality\n  inspect!(a == c, content=\"true\")\n  inspect!(a != b, content=\"true\")\n\n  // Comparison\n  inspect!(a > b, content=\"true\")\n  inspect!(b < a, content=\"true\")\n  inspect!(a >= c, content=\"true\")\n  inspect!(c <= a, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Arithmetic\nDESCRIPTION: Illustrates basic arithmetic operations such as addition, subtraction, multiplication, and division with UInt64 values. It also showcases the overflow behavior where the value wraps around to 0 when exceeding the maximum value and wraps to the maximum value on underflow.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 arithmetic\" {\n  let a : UInt64 = 100UL\n  let b : UInt64 = 50UL\n\n  // Addition\n  inspect!(a + b, content=\"150\")\n\n  // Subtraction\n  inspect!(a - b, content=\"50\")\n\n  // Multiplication\n  inspect!(a * b, content=\"5000\")\n\n  // Division\n  inspect!(a / b, content=\"2\")\n\n  // Overflow behavior\n  inspect!(@uint64.max_value + 1UL, content=\"0\") // Wraps around to 0\n  inspect!(@uint64.min_value - 1UL, content=\"18446744073709551615\") // Underflow wraps to maximum value\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Result Error Values with map_err in Moonbit\nDESCRIPTION: This code demonstrates how to transform the error value inside a `Result` using the `map_err` method. The function passed to `map_err` is only applied if the `Result` is `Err`; otherwise, the `Result` remains unchanged.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Err(\"error\")\n    let new_result = result.map_err(fn(x) { x + \"!\" })\n    assert_eq!(new_result, Err(\"error!\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Popping Element from Priority Queue in MoonBit\nDESCRIPTION: Demonstrates how to pop the element at the front of a priority queue using the `pop()` method in MoonBit. The method returns an `Option` containing the popped value or `None` if the queue is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([5, 4, 3, 2, 1])\n  assert_eq!(pq.pop(), Some(5))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Key-Value Pairs to a SortedMap in MoonBit\nDESCRIPTION: Illustrates adding a key-value pair to a SortedMap using the `add` method and the subscript syntax (`map[key] = value`). It demonstrates how to insert or update values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\")])\n  map.add(3, \"three\")\n  assert_eq!(map.size(), 3)\n}\n```\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.new()\n  map[1] = \"one\"\n  map[2] = \"two\"\n  assert_eq!(map.size(), 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing using strconv.parse for FromStr types in MoonBit\nDESCRIPTION: This snippet shows how to use the `parse` helper function in MoonBit's `strconv` package for types that implement the `FromStr` trait. The code demonstrates converting strings to `Int` and `Bool` types and asserting the correctness of the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/strconv/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let a : Int = @strconv.parse!(\"123\")\n  assert_eq!(a, 123)\n  let b : Bool = @strconv.parse!(\"true\")\n  assert_eq!(b, true)\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Lists Moonbit\nDESCRIPTION: Illustrates how to transform list elements using the `map()` method. `map()` applies a given function to each element in the list and returns a new list with the transformed elements.  The example shows how to multiply each element by 2.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let list = @list.of([1, 2, 3, 4, 5])\n  assert_eq!(list.map(fn (ele) { ele * 2 }).to_array(), [2, 4, 6, 8, 10])\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Key Access with Default Value in MoonBit SortedMap\nDESCRIPTION: Shows best practices for safe key access when keys might not exist, using pattern matching and providing a default value. Includes a function `get_score` that handles missing keys by returning 0.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_19\n\nLANGUAGE: moonbit\nCODE:\n```\nfn get_score(scores : @sorted_map.T[Int, Int], student_id : Int) -> Int {\n  match scores.get(student_id) {\n    Some(score) => score\n    None =>\n      // println(\n      //   \"Student ID \" +\n      //   student_id.to_string() +\n      //   \" does not exist, returning default score\",\n      // )\n      0 // Default score\n  }\n}\n\ntest \"safe_key_access\" {\n  // Create a mapping storing student IDs and their scores\n  let scores = @sorted_map.from_array([(1001, 85), (1002, 92), (1003, 78)])\n\n  // Access an existing key\n  assert_eq!(get_score(scores, 1001), 85)\n\n  // Access a non-existent key, returning the default value\n  assert_eq!(get_score(scores, 9999), 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Key-Value Pair From Map MoonBit\nDESCRIPTION: Demonstrates how to remove a key-value pair from a sorted map using the `remove()` function. A map is created with initial values, then a key is removed, and finally, it's verified that the removed key is no longer present in the map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let map = map.remove(\"a\")\n  assert_eq!(map.get(\"a\"), None)\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Contains Operation in MoonBit\nDESCRIPTION: Shows how to check if a HashMap contains a specific key using the `contains()` function. The example demonstrates both a case where the key exists and a case where it does not.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let map = @hashmap.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n    assert_eq!(map.contains(\"a\"), true)\n    assert_eq!(map.contains(\"d\"), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Queue Length and Checking if Empty in MoonBit\nDESCRIPTION: Shows how to retrieve the number of elements in the queue using the `length` method and how to check if the queue is empty using the `is_empty` method.  These methods are useful for determining the state of the queue before performing operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.of([1,2,3])\n    assert_eq!(queue.length(), 3)\n    assert_eq!(queue.is_empty(), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Lists Moonbit\nDESCRIPTION: Demonstrates concatenating two lists using both the `concat()` method and the `+` operator.  Both methods produce a new list containing all elements from the first list followed by all elements from the second list. The example shows both approaches and asserts that they produce the same result.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list1 = @list.of([1, 2, 3])\n    let list2 = @list.of([4, 5, 6])\n    let list3 = list1.concat(list2)\n    let list4 = list1 + list2\n    assert_eq!(list3.to_array(), [1, 2, 3, 4, 5, 6])\n    assert_eq!(list4.to_array(), [1, 2, 3, 4, 5, 6])\n}\n```\n\n----------------------------------------\n\nTITLE: Set Operations: Union & Intersection in MoonBit\nDESCRIPTION: Demonstrates how to perform union and intersection operations on two ImmutableSets using the `union()` and `intersection()` methods. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set1 = @sorted_set.of([3, 4, 5])\n    let set2 = @sorted_set.of([4, 5, 6])\n    assert_eq!(set1.union(set2).to_array(), [3, 4, 5, 6])\n    assert_eq!(set1.intersection(set2).to_array(), [4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Map Size MoonBit\nDESCRIPTION: Illustrates how to get the number of key-value pairs in a sorted map using the `size()` function. A map is created with some initial values, and then the size is asserted to be the expected number.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  assert_eq!(map.size(), 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Peeking at the Head of Priority Queue in MoonBit\nDESCRIPTION: Shows how to peek at the head element (maximum or minimum value) of the priority queue using `peek()`. The return type is an `Option`, which is `None` if the queue is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/priority_queue/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([1, 2, 3, 4, 5])\n  assert_eq!(pq.peek(), Some(5))\n  // @json.inspect!(pq)\n  // we have to add `@json` package in test-import\n  // it's reported unused package currently\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Size and Capacity in MoonBit\nDESCRIPTION: Demonstrates how to get the size (number of key-value pairs) and capacity of a HashMap using the `size()` and `capacity()` functions, respectively.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let map = @hashmap.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n    assert_eq!(map.size(), 3)\n    assert_eq!(map.capacity(), 8)\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Object Navigation in MoonBit\nDESCRIPTION: This snippet shows how to navigate and access values within a JSON object in MoonBit using the `json` package.  It demonstrates how to access string, number, and array values using the `value` method and `as_string`, `as_number`, and `as_array` methods. It also shows how to handle missing keys gracefully by checking for `None` values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/json/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"json object navigation\" {\n  let json = @json.parse!(\n    \"{\\\"string\\\":\\\"hello\\\",\\\"number\\\":42,\\\"array\\\":[1,2,3]}\",\n  )\n\n  // Access string\n  let string_opt = json.value(\"string\").unwrap().as_string()\n  inspect!(\n    string_opt,\n    content=\n      #|Some(\"hello\")\n    ,\n  )\n\n  // Access number\n  let number_opt = json.value(\"number\").unwrap().as_number()\n  inspect!(number_opt, content=\"Some(42)\")\n\n  // Access array\n  let array_opt = json.value(\"array\").unwrap().as_array()\n  inspect!(array_opt, content=\"Some([Number(1), Number(2), Number(3)])\")\n\n  // Handle missing keys gracefully\n  inspect!(json.value(\"missing\"), content=\"None\")\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Element into Priority Queue in MoonBit\nDESCRIPTION: Shows how to add elements to a priority queue using the `push()` method in MoonBit. The example demonstrates adding elements and then peeking to ensure the highest priority element is at the head.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq : @priority_queue.T[Int] = @priority_queue.new()\n  pq.push(1)\n  pq.push(2)\n  assert_eq!(pq.peek(), Some(2))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Creating a Queue in MoonBit\nDESCRIPTION: Demonstrates how to create a new queue using `new` and how to construct it from an array using `of`. These methods allow for the instantiation of a queue either manually or by directly initializing it with a set of elements.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _queue : @queue.T[Int] = @queue.new()\n    let _queue1 = @queue.of([1,2,3])\n}\n```\n\n----------------------------------------\n\nTITLE: Search and Contains in MoonBit\nDESCRIPTION: Shows how to use the `contains()` and `search()` methods to find out if a value is in the deque, or to find its index. The search function returns an Option containing the index, or None if the value is not found.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dv.contains(1), true)\n  assert_eq!(dv.contains(6), false)\n  assert_eq!(dv.search(1), Some(0))\n  assert_eq!(dv.search(6), None)\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Arrays in MoonBit\nDESCRIPTION: Demonstrates the use of fixed arrays in MoonBit. It showcases concatenation, checking for containment, and checking if an array starts or ends with a specific sequence using `+`, `contains`, `starts_with`, and `ends_with` respectively. These operations create new arrays and do not modify the original fixed array.\nSOURCE: https://github.com/moonbitlang/core/blob/main/array/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"fixed arrays\" {\n  let fixed : FixedArray[_] = [1, 2, 3]\n\n  // Concatenation creates new array\n  let combined = fixed + [4, 5]\n\n  // Check for containment\n  let has_two = fixed.contains(2)\n\n  // Check if array starts/ends with sequence\n  let starts = fixed.starts_with([1, 2])\n  let ends = fixed.ends_with([2, 3])\n  inspect!(combined, content=\"[1, 2, 3, 4, 5]\")\n  inspect!(has_two, content=\"true\")\n  inspect!(starts, content=\"true\")\n  inspect!(ends, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Arrays in MoonBit\nDESCRIPTION: Demonstrates different ways to create immutable arrays in MoonBit, including using `new()`, `of()`, `from_iter()`, and `from_array()`.  It shows how to initialize an empty array or construct it from existing data structures.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/array/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _arr1 = @array.of([1, 2, 3, 4, 5])    \n  let _arr2 : @array.T[Int] = @array.new()\n  let _arr3 = @array.from_iter((1).until(5))\n  let _arr4 = @array.from_array([1, 2, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Bytes View Operations in MoonBit\nDESCRIPTION: Demonstrates view operations on `Bytes`, including creating views, accessing individual bytes, interpreting bytes as integers (big-endian and little-endian), and creating sub-views using slicing in MoonBit. It uses methods such as `to_int_be`, `to_int_le`, and slicing `[:]` to manipulate and interpret the byte data. The operations and results are then inspected for verification.\nSOURCE: https://github.com/moonbitlang/core/blob/main/bytes/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"bytes view operations\" {\n  // Create bytes with numeric data\n  let num_bytes = @bytes.from_array([0x12, 0x34, 0x56, 0x78])\n\n  // Create a view\n  let view = num_bytes[:]\n\n  // Get individual bytes\n  inspect!(view[0], content=\"b'\\\\x12'\")\n\n  // Interpret as integers (big-endian)\n  inspect!(view.to_int_be(), content=\"305419896\")\n\n  // Interpret as integers (little-endian)\n  inspect!(view.to_int_le(), content=\"2018915346\")\n\n  // Create a sub-view\n  let sub_view = view[1:3]\n  inspect!(sub_view.length(), content=\"2\")\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in MoonBit SortedMap\nDESCRIPTION: Shows how to check if a key exists in the map using the `contains` method, which returns a boolean value. Covers both existing and non-existing keys.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n  assert_eq!(map.contains(2), true)\n  assert_eq!(map.contains(4), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in Map MoonBit\nDESCRIPTION: Shows how to check if a key exists in a sorted map using the `contains()` function. The example creates a map with some initial values and then checks for the presence of an existing key and a non-existing key.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  assert_eq!(map.contains(\"a\"), true)\n  assert_eq!(map.contains(\"d\"), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Element to ImmutableSet in MoonBit\nDESCRIPTION: Demonstrates how to add an element to an ImmutableSet using the `add()` method, which returns a new set with the added element. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.of([1, 2, 3, 4])\n    assert_eq!(set.add(5).to_array(), [1, 2, 3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Key-Value Pairs from a SortedMap in MoonBit\nDESCRIPTION: Shows how to remove a key-value pair from a SortedMap using the `remove` method.  Verifies the size and confirms that the removed key is no longer present.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n  map.remove(2)\n  assert_eq!(map.size(), 2)\n  assert_eq!(map.contains(2), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Removing a Moonbit Map Entry\nDESCRIPTION: Demonstrates how to remove a key-value pair from a Moonbit Map using the `remove` function.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = { \"a\": 1, \"b\": 2, \"c\": 3 }\n  map.remove(\"a\")\n  inspect!(\n    map,\n    content=\n      #|{\"b\": 2, \"c\": 3}\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Deque in MoonBit\nDESCRIPTION: Demonstrates how to create a deque in MoonBit using `new()` and `of()` methods. The `new()` method can be used with or without specifying an initial capacity. The `of()` method initializes the deque with given values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _dv : @deque.T[Int] = @deque.new()\n    let _dv = @deque.of([1, 2, 3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Result Computations with bind in Moonbit\nDESCRIPTION: This code demonstrates how to chain computations that return `Result` values using the `bind` method.  The function passed to `bind` should return a `Result`, and it's only called if the original `Result` is `Ok`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Ok(42)\n    let new_result = result.bind(fn(x) { Ok(x + 1) })\n    assert_eq!(new_result, Ok(43))\n}\n```\n\n----------------------------------------\n\nTITLE: Random Number Generation Example in MoonBit\nDESCRIPTION: This code snippet demonstrates how to use the random number generator in MoonBit to generate various types of random numbers (uint, int, double, int64, uint64) and shuffle an array. It initializes a random number generator, asserts the output of several random number generations and shuffles an array and confirms its new order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/random/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let r = @random.new()\n  assert_eq!(r.uint(limit=10), 7)\n  assert_eq!(r.uint(limit=10), 0)\n  assert_eq!(r.uint(limit=10), 5)\n  assert_eq!(r.int(), 1064320769)\n  assert_eq!(r.double(), 0.3318940049218405)\n  assert_eq!(r.int(limit=10), 0)\n  assert_eq!(r.uint(), 311122750)\n  assert_eq!(r.int64(), -9223372036854775808)\n  assert_eq!(r.int64(limit=10), 8)\n  assert_eq!(r.uint64(), 3951155890335085418)\n  let a = [1, 2, 3, 4, 5]\n  r.shuffle(\n    a.length(),\n    fn(i : Int, j : Int) {\n      let t = a[i]\n      a[i] = a[j]\n      a[j] = t\n    },\n  )\n  assert_eq!(a, [2, 1, 4, 3, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested Results with flatten in Moonbit\nDESCRIPTION: This code demonstrates how to flatten a nested `Result` (i.e., `Result[Result[T, E], E]`) using the `flatten` method. This method simplifies the nested `Result` into a single `Result[T, E]`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Result[Int, String], String] = Ok(Ok(42))\n    let flattened = result.flatten()\n    assert_eq!(flattened, Ok(42))\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Moonbit Map Key Existence\nDESCRIPTION: Shows how to check if a key exists in a Moonbit Map using the `contains` function.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = { \"a\": 1, \"b\": 2, \"c\": 3 }\n  assert_eq!(map.contains(\"a\"), true)\n  assert_eq!(map.contains(\"d\"), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Result with or in Moonbit\nDESCRIPTION: This code demonstrates how to extract a value safely from a `Result` using the `or` method. This method returns the value if the `Result` is `Ok`, and a default value if it is `Err`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Err(\"error\")\n    let value = result.or(0)\n    assert_eq!(value, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Option values using `map` method in MoonBit\nDESCRIPTION: Demonstrates how to transform the value of an `Option` using the `map` method. It applies the provided function to the value if the Option is `Some`, otherwise returns `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let some: Int? = Some(42)\n  let new_some = some.map(fn(value: Int) { value + 1 }) // Some(43)\n  assert_eq!(new_some, Some(43))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Option values in MoonBit\nDESCRIPTION: Demonstrates how to create Option values using `Some` and `None` constructors, including proper type annotations.  It also shows how to use `when` to conditionally create `Some` or `None` based on a boolean condition. The `when` function evaluates the expression lazily.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet _some: Int? = Some(42)\nlet _none: String? = None\n```\n\n----------------------------------------\n\nTITLE: Rational Double Operations in MoonBit\nDESCRIPTION: This snippet illustrates the conversion of `Rational` numbers to and from double-precision floating-point numbers in MoonBit. It demonstrates the usage of `to_double()` to convert a `Rational` to a double and `@rational.from_double!` to convert a double back to a `Rational`, with verification through `assert_eq!` and `to_string()`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/rational/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let a = @rational.new(1L, 2L).unwrap()\n    assert_eq!(a.to_double(), 0.5)\n    assert_eq!(@rational.from_double!(0.5).to_string(), \"1/2\")\n}\n```\n\n----------------------------------------\n\nTITLE: Currying a Function in MoonBit\nDESCRIPTION: This snippet demonstrates how to curry a function using the `curry` method in MoonBit. Currying transforms a function that takes multiple arguments into a sequence of functions, each taking a single argument.  The example shows currying an addition function.\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let add = fn(a, b) { a + b }\n    let curried_add = @tuple.curry(add)\n    let _result = curried_add(1)(2) // result = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Exponential and Logarithmic Functions in MoonBit\nDESCRIPTION: This snippet shows how to use exponential and logarithmic functions provided by MoonBit's float package. It includes `exp` (exponential), `expm1` (exp(x) - 1), `ln` (natural logarithm), `ln_1p` (ln(1 + x)), `pow` (power function), and `cbrt` (cube root). The `inspect!` macro is used to assert the output values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"exp and log functions\" {\n  // Exponential\n  inspect!(@float.exp(0.0), content=\"1\")\n  inspect!(@float.expm1(0.0), content=\"0\") // exp(x) - 1\n\n  // Natural logarithm\n  inspect!(@float.ln(1.0), content=\"0\")\n  inspect!(@float.ln_1p(0.0), content=\"0\") // ln(1 + x)\n\n  // Power functions\n  inspect!(@float.pow(2.0, 3.0), content=\"8\")\n  inspect!(@float.cbrt(8.0), content=\"2\") // cube root\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Set Operations in Moonbit\nDESCRIPTION: This snippet demonstrates set operations like union, intersection, and difference between two Sorted Sets in Moonbit. It creates two sets, performs the operations, and asserts that the resulting sets are as expected.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set1 = @sorted_set.from_array([3, 4, 5])\n    let set2 = @sorted_set.from_array([4, 5, 6])\n    let set3 = set1.union(set2)\n    assert_eq!(set3.to_array(), [3, 4, 5, 6])\n    let set4 = set1.intersection(set2)\n    assert_eq!(set4.to_array(), [4, 5])\n    let set5 = set1.difference(set2)\n    assert_eq!(set5.to_array(), [3])\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Moonbit Map\nDESCRIPTION: Demonstrates how to create an empty Moonbit Map or initialize it with key-value pairs.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _map1 : Map[String, Int] = {}\n  let _map2 = { \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5 }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Popping Elements from Priority Queue in MoonBit\nDESCRIPTION: Illustrates how to remove the head element from the immutable priority queue using `pop()`, which returns a new queue wrapped in an `Option`. If the queue is empty, `pop()` returns `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/priority_queue/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([5, 4, 3, 2, 1])\n  let val = match pq.pop() {\n    Some(q) => q.peek()\n    None => None\n  }\n  assert_eq!(val, Some(4))\n}\n```\n\n----------------------------------------\n\nTITLE: Bytes Concatenation and Comparison in MoonBit\nDESCRIPTION: Demonstrates concatenation and comparison operations on `Bytes` using the `+` operator and `==`, `<` operators in MoonBit. It creates `Bytes` from arrays of bytes and concatenates them using the `+` operator.  It then compares the created Bytes objects using `==` and `<` operators, and inspects the results to confirm correctness.\nSOURCE: https://github.com/moonbitlang/core/blob/main/bytes/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"bytes operations\" {\n  let b1 = @bytes.from_array([b'a', b'b'])\n  let b2 = @bytes.from_array([b'c', b'd'])\n\n  // Concatenation\n  let combined = b1 + b2\n  inspect!(\n    combined,\n    content=\n      #|b\"\\x61\\x62\\x63\\x64\"\n    ,\n  )\n\n  // Comparison\n  let same = @bytes.from_array([b'a', b'b'])\n  let different = @bytes.from_array([b'x', b'y'])\n  inspect!(b1 == same, content=\"true\")\n  inspect!(b1 == different, content=\"false\")\n  inspect!(b1 < b2, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Keys and Values from MoonBit SortedMap\nDESCRIPTION: Shows how to extract all keys and values from the map using the `keys` and `values` methods respectively. The keys and values are returned as arrays.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(3, \"three\"), (1, \"one\"), (2, \"two\")])\n  assert_eq!(map.keys(), [1, 2, 3])\n  assert_eq!(map.values(), [\"one\", \"two\", \"three\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Getting All Values From Map MoonBit\nDESCRIPTION: Illustrates how to get all values from a sorted map in ascending order of their keys using the `elems()` function. A map is created, and then the `elems()` function is used to retrieve the values, which are then asserted to be in the expected order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let elems = map.elems() // [1, 2, 3]\n  assert_eq!(elems, [1, 2, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Result Values in Moonbit\nDESCRIPTION: This code demonstrates how to create `Result` values using the `Ok` and `Err` constructors. Type annotations are provided to specify the types of the success and error values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _result: Result[Int, String] = Ok(42)\n    let _error: Result[Int, String] = Err(\"Error message\")\n}\n```\n\n----------------------------------------\n\nTITLE: UInt Byte Conversion: Big-Endian and Little-Endian in MoonBit\nDESCRIPTION: This code snippet shows how to convert a `UInt` to its byte representation in both big-endian and little-endian formats using the `@uint.to_be_bytes()` and `@uint.to_le_bytes()` functions in MoonBit. The resulting byte arrays are then inspected to confirm that the byte order is correct. The example uses the number 258 (0x00000102 in hex).\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"uint byte conversion\" {\n  let num = 258U // 0x00000102 in hex\n\n  // Big-endian bytes (most significant byte first)\n  let be_bytes = @uint.to_be_bytes(num)\n  inspect!(\n    be_bytes,\n    content=\n      #|b\"\\x00\\x00\\x01\\x02\"\n    ,\n  )\n\n  // Little-endian bytes (least significant byte first)\n  let le_bytes = @uint.to_le_bytes(num)\n  inspect!(\n    le_bytes,\n    content=\n      #|b\"\\x02\\x01\\x00\\x00\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing nested Option values using `flatten` method in MoonBit\nDESCRIPTION: Demonstrates how to reduce nested `Option` values into a single `Option` using the `flatten` method.  Transforms `Some(Some(value))` to `Some(value)` and `None` otherwise.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let some: Option[Option[Int]] = Some(Some(42))\n  let new_some = some.flatten() // Some(42)\n  assert_eq!(new_some, Some(42))\n  let none: Int?? = Some(None)\n  let new_none = none.flatten() // None\n  assert_eq!(new_none, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Special Value Testing in MoonBit\nDESCRIPTION: This code snippet demonstrates how to test for special floating-point values using the `double` package in MoonBit. It shows the usage of `is_nan`, `is_inf`, `is_pos_inf`, and `is_neg_inf` functions to check if a number is NaN, infinity, positive infinity, or negative infinity, respectively. It also shows how to perform approximate equality checks using `is_close` with a relative tolerance.\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"special value testing\" {\n  // Testing for special values\n  inspect!(@double.is_nan(@double.not_a_number), content=\"true\")\n  inspect!(@double.is_inf(@double.infinity), content=\"true\")\n  inspect!(@double.is_pos_inf(@double.infinity), content=\"true\")\n  inspect!(@double.is_neg_inf(@double.neg_infinity), content=\"true\")\n\n  // Approximate equality\n  let relative_tolerance = 1.e-9\n  inspect!(\n    @double.is_close(0.1 + 0.2, 0.3, relative_tolerance~),\n    content=\"true\",\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Creation in MoonBit\nDESCRIPTION: Demonstrates how to create an empty HashMap in MoonBit using the `new()` function. The type of the HashMap is explicitly defined as `HashMap[String, Int]`, indicating that it will store string keys and integer values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _map2 : @hashmap.T[String, Int] = @hashmap.new()\n}\n```\n\n----------------------------------------\n\nTITLE: Deque Iteration and Mapping in MoonBit\nDESCRIPTION: Demonstrates the use of iteration and mapping functions (`each`, `eachi`, `map`, `mapi`) on a deque.  These functions provide ways to traverse and transform the elements of the deque.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  let arr = []\n  dv.each(fn(elem) { arr.push(elem) })\n  assert_eq!(arr, [1, 2, 3, 4, 5])\n  let arr2 = []\n  dv.eachi(fn(i, _elem) { arr2.push(i) })\n  assert_eq!(arr2, [0, 1, 2, 3, 4])\n  let arr3 = []\n  let _ = dv.map(fn(elem) { arr3.push(elem + 1) })\n  assert_eq!(arr3, [2, 3, 4, 5, 6])\n  let arr4 = []\n  let _ = dv.mapi(fn(i, elem) { arr4.push(elem + i) })\n  assert_eq!(arr4, [1, 3, 5, 7, 9])\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Access and Error Handling in MoonBit SortedMap\nDESCRIPTION: Illustrates safe key access with error handling using `inspect!` macro, showing how to handle cases where a key might not exist in the SortedMap.  Specifies content to display if value is None.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\")])\n  let key = 3\n  inspect!(map.get(key), content=\"None\")\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Values in Map MoonBit\nDESCRIPTION: Shows how to filter keys/values in a sorted map using `filter()` and `filter_with_key()`. The `filter()` function filters values based on a predicate, while `filter_with_key()` filters based on both keys and values. The example filters values greater than 1 and keys greater than \"a\", and then asserts the remaining values and keys.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let map = map.filter(fn (v) { v > 1 })\n  assert_eq!(map.elems(), [2, 3])\n  assert_eq!(map.keys(), [\"b\", \"c\"])\n  let map = map.filter_with_key(fn (k, v) { k > \"a\" && v > 1 })\n  assert_eq!(map.elems(), [2, 3])\n  assert_eq!(map.keys(), [\"b\", \"c\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping References in Moonbit\nDESCRIPTION: This snippet demonstrates the `map` function, which transforms a reference while preserving the reference wrapper. It takes a reference and a transformation function as arguments. The transformation function modifies the value within the new reference. The example demonstrates mapping using both `@ref.map` and `num.map`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/ref/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"mapping refs\" {\n  let num = @ref.new(10)\n  let doubled = @ref.map(num, fn(x) { x * 2 })\n  inspect!(doubled.val, content=\"20\")\n  let squared = num.map(fn(x) { x * x })\n  inspect!(squared.val, content=\"100\")\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing and Popping Elements in MoonBit\nDESCRIPTION: Demonstrates how to add elements to the end of the queue using the `push` method and remove elements from the front of the queue using the `pop` method. The `pop` method returns an `Option`, allowing to handle cases where the queue is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.new()\n    queue.push(1)\n    queue.push(2)\n    assert_eq!(queue.pop(), Some(1))\n    assert_eq!(queue.pop(), Some(2))\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Element Existence in Moonbit\nDESCRIPTION: This snippet demonstrates how to check if a Sorted Set contains a specific element in Moonbit using the `contains` method. It shows both a positive and negative case.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.from_array([1, 2, 3, 4])\n    assert_eq!(set.contains(1), true)\n    assert_eq!(set.contains(5), false)\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Remove Operation in MoonBit\nDESCRIPTION: Demonstrates how to remove a key-value pair from a HashMap using the `remove()` function.  The example first initializes the map with key-value pairs using the `of()` function and then removes the key \"a\".\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let map = @hashmap.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n    map.remove(\"a\") |> ignore\n    assert_eq!(map.to_array(), [(\"c\", 3), (\"b\", 2)])\n}\n```\n\n----------------------------------------\n\nTITLE: Byte to UInt64 Conversion in MoonBit\nDESCRIPTION: This snippet illustrates how to convert a byte value to a `UInt64` value using the `to_uint64()` method. It demonstrates both calling the method directly on a byte and calling it as a package function.\nSOURCE: https://github.com/moonbitlang/core/blob/main/byte/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte conversion\" {\n  let byte = b'A'\n  inspect!(byte.to_uint64(), content=\"65\")\n  let byte = b' '\n  inspect!(@byte.to_uint64(byte), content=\"32\")\n}\n```\n\n----------------------------------------\n\nTITLE: Swapping Reference Values in Moonbit\nDESCRIPTION: This snippet demonstrates the `swap` function, which exchanges the values of two references. It takes two references as arguments and swaps their contained values. The example swaps the values of `r1` and `r2` and verifies the change using `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/ref/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"swapping refs\" {\n  let r1 = @ref.new(\"first\")\n  let r2 = @ref.new(\"second\")\n  @ref.swap(r1, r2)\n  inspect!(r1.val, content=\"second\")\n  inspect!(r2.val, content=\"first\")\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Byte Conversion\nDESCRIPTION: Demonstrates how to convert a UInt64 value to a byte array in both big-endian and little-endian formats using `@uint64.to_be_bytes` and `@uint64.to_le_bytes` functions respectively. It checks if the resulting byte arrays are in the expected order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 byte conversion\" {\n  // Convert to bytes in big-endian order (most significant byte first)\n  let be_bytes = @uint64.to_be_bytes(0x123456789ABCDEF0UL)\n  inspect!(\n    be_bytes,\n    content=\n      #|b\"\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde\\xf0\"\n    ,\n  )\n\n  // Convert to bytes in little-endian order (least significant byte first)\n  let le_bytes = @uint64.to_le_bytes(0x123456789ABCDEF0UL)\n  inspect!(\n    le_bytes,\n    content=\n      #|b\"\\xf0\\xde\\xbc\\x9a\\x78\\x56\\x34\\x12\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Lists Moonbit\nDESCRIPTION: Illustrates flattening a list of lists into a single list using the `flatten()` method. The example constructs a list containing other lists as elements and then uses `flatten()` to combine all the sublists into one.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let ls1 = @list.of([1, 2, 3])\n    let ls2 = @list.of([4, 5, 6])\n    let ls3 = @list.of([7, 8, 9])\n    let ls4 = @list.of([ls1, ls2, ls3])\n    assert_eq!(ls4.flatten().to_array(), [1, 2, 3, 4, 5, 6, 7, 8, 9])\n}\n```\n\n----------------------------------------\n\nTITLE: Folding a Queue with Fold in MoonBit\nDESCRIPTION: Demonstrates how to reduce the queue to a single value by applying a function to each element and accumulating the result, using the `fold` method. This method takes an initial value and a function that combines the accumulator with each element of the queue.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.of([1,2,3])\n    let sum = queue.fold(init = 0, fn(acc, x) { acc + x })\n    assert_eq!(sum, 6)\n}\n```\n\n----------------------------------------\n\nTITLE: Method Style Character Classification in MoonBit\nDESCRIPTION: This code demonstrates the method-style usage of character classification functions in MoonBit. It shows how to call classification methods directly on character variables using dot notation.  It tests letter, digit, and special character methods. The `inspect!` macro validates the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/char/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"method style\" {\n  // Letter methods\n  let c = 'A'\n  inspect!(c.is_ascii(), content=\"true\")\n  inspect!(c.is_ascii_alphabetic(), content=\"true\")\n  inspect!(c.is_ascii_uppercase(), content=\"true\")\n\n  // Digit methods\n  let d = '7'\n  inspect!(d.is_ascii_digit(), content=\"true\")\n  inspect!(d.is_digit(8U), content=\"true\")\n  inspect!(d.is_ascii_hexdigit(), content=\"true\")\n\n  // Special character methods\n  let s = ' '\n  inspect!(s.is_ascii_whitespace(), content=\"true\")\n  inspect!(s.is_whitespace(), content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to a Sorted Set in Moonbit\nDESCRIPTION: This snippet demonstrates how to add an element to a Sorted Set in Moonbit using the `add` method. It initializes a set from an array, adds a new element, and verifies that the set now contains the added element.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set4 = @sorted_set.from_array([1, 2, 3, 4])\n    set4.add(5) // ()\n    let set6 = @sorted_set.from_array([1, 2, 3, 4, 5])\n    assert_eq!(set6.to_array(), [1, 2, 3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing a Queue with Each in MoonBit\nDESCRIPTION: Shows how to iterate over each element in the queue using the `each` method, applying a given function to each element. This allows performing operations on each element in the queue in the order they were added.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.of([1,2,3])\n    let mut sum = 0\n    queue.each(fn(x) { sum += x })\n    assert_eq!(sum, 6)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Bytes in MoonBit\nDESCRIPTION: Demonstrates how to create `Bytes` from various sources such as arrays, fixed arrays, empty and iterators using MoonBit's `@bytes` module. It uses `from_array`, `of`, `default`, and `from_iter` methods for creating bytes instances from these different sources. The created bytes objects are then inspected for verification.\nSOURCE: https://github.com/moonbitlang/core/blob/main/bytes/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"bytes creation\" {\n  // Create from array of bytes\n  let arr = [b'h', b'e', b'l', b'l', b'o']\n  let bytes1 = @bytes.from_array(arr)\n  inspect!(\n    bytes1,\n    content=\n      #|b\"\\x68\\x65\\x6c\\x6c\\x6f\"\n    ,\n  )\n\n  // Create from fixed array\n  let fixed = FixedArray::make(3, b'a')\n  let bytes2 = @bytes.of(fixed)\n  inspect!(\n    bytes2,\n    content=\n      #|b\"\\x61\\x61\\x61\"\n    ,\n  )\n\n  // Create empty bytes\n  let empty = @bytes.default()\n  inspect!(\n    empty,\n    content=\n      #|b\"\"\n    ,\n  )\n\n  // Create from iterator\n  let iter_bytes = @bytes.from_iter(arr.iter())\n  inspect!(\n    iter_bytes,\n    content=\n      #|b\"\\x68\\x65\\x6c\\x6c\\x6f\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Int64 Method-Style Usage in MoonBit\nDESCRIPTION: Illustrates the method-style syntax available for Int64 operations, specifically the `abs()` and `to_be_bytes()` methods.  An Int64 value is initialized, and then the absolute value and big-endian byte representation are computed using the method syntax. The expected results are verified through `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int64/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"method style\" {\n  let x = -42L\n\n  // Using method syntax for absolute value\n  inspect!(x.abs(), content=\"42\")\n\n  // Binary conversions as methods\n  inspect!(\n    x.to_be_bytes(),\n    content=\n      #|b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xd6\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing a Queue in MoonBit\nDESCRIPTION: Illustrates how to clear all elements from an existing queue using the `clear` method. This operation effectively empties the queue, resetting its state to be empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.of([1,2,3])\n    queue.clear()\n}\n```\n\n----------------------------------------\n\nTITLE: Int16 Arithmetic Operations Moonbit\nDESCRIPTION: This code snippet shows standard arithmetic operations for the `Int16` type, including addition, subtraction, multiplication, and division.  It also illustrates the overflow behavior, demonstrating how `max_value + 1` wraps around to `min_value` and `min_value - 1` wraps around to `max_value`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int16/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"int16 arithmetic\" {\n  let a : Int16 = 100\n  let b : Int16 = 50\n\n  // Basic arithmetic\n  inspect!(a + b, content=\"150\")\n  inspect!(a - b, content=\"50\")\n  inspect!(a * b, content=\"5000\")\n  inspect!(a / b, content=\"2\")\n\n  // Overflow behavior\n  let max = @int16.max_value\n  let min = @int16.min_value\n  inspect!(max + 1, content=\"-32768\") // Wraps around to min_value\n  inspect!(min - 1, content=\"32767\") // Wraps around to max_value\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Sequence Writing in MoonBit\nDESCRIPTION: This code demonstrates writing byte sequences to a buffer in MoonBit using both byte arrays and iterators.  It creates a new buffer using `@buffer.new()`, writes a byte array using `write_bytes()`, and writes a byte iterator using `write_iter()`. The final buffer contents, representing the concatenated byte sequences, are then converted to bytes using `to_bytes()` and asserted using the `inspect!` macro.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte sequence writing\" {\n  let buf = @buffer.new()\n\n  // Write byte array\n  let bytes = b\"Hello\"\n  buf.write_bytes(bytes)\n\n  // Write byte iterator\n  buf.write_iter(bytes.iter())\n  let contents = buf.to_bytes()\n  inspect!(\n    contents,\n    content=\n      #|b\"\\x48\\x65\\x6c\\x6c\\x6f\\x48\\x65\\x6c\\x6c\\x6f\"\n    ,\n  ) // \"Hello\" written twice\n}\n```\n\n----------------------------------------\n\nTITLE: Buffer with Size Hint in MoonBit\nDESCRIPTION: This snippet demonstrates how to create a buffer with an initial size hint in MoonBit to improve performance. It creates a new buffer using `@buffer.new(size_hint=1024)`, which pre-allocates space for 1024 bytes. It then writes 100 integers to the buffer using `write_int_le()`. Finally, it checks the length of the buffer using `length()`, which should be 400 bytes (100 integers * 4 bytes per integer) and asserts this value using `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"buffer with size hint\" {\n  // Create buffer with initial capacity hint\n  let buf = @buffer.new(size_hint=1024)\n\n  // Write some data\n  for i = 0; i < 100; i = i + 1 {\n    buf.write_int_le(i)\n  }\n\n  // Each integer takes 4 bytes\n  inspect!(buf.length(), content=\"400\")\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Array Navigation in MoonBit\nDESCRIPTION: This snippet demonstrates how to navigate and access elements within a JSON array in MoonBit. It uses the `item` method to access elements by index and handles out-of-bounds access. The snippet also shows how to iterate through the array using `as_array().unwrap().iter()`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/json/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"json array navigation\" {\n  let array = @json.parse!(\"[1,2,3,4,5]\")\n\n  // Access by index\n  let first = array.item(0)\n  inspect!(first, content=\"Some(Number(1))\")\n\n  // Access out of bounds\n  let missing = array.item(10)\n  inspect!(missing, content=\"None\")\n\n  // Iterate through array\n  let values = array.as_array().unwrap()\n  inspect!(\n    values.iter(),\n    content=\"[Number(1), Number(2), Number(3), Number(4), Number(5)]\",\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Lists Moonbit\nDESCRIPTION: Demonstrates how to initialize empty and pre-filled lists in Moonbit using `default()` and `of()` methods. `default()` creates an empty list, while `of()` constructs a list from an array.  The example includes assertions to check the length of the created lists.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list0 : @list.T[Int] = @list.default()\n    assert_eq!(list0.length(), 0)\n    let list1 = @list.of([1, 2, 3, 4, 5])\n    assert_eq!(list1.length(), 5)\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Constants\nDESCRIPTION: Demonstrates the usage of `uint64.min_value` and `uint64.max_value` constants to represent the minimum and maximum values for UInt64, respectively. It uses the `inspect!` macro to check if the values are as expected.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 constants\" {\n  // Minimum value of UInt64\n  inspect!(@uint64.min_value, content=\"0\")\n\n  // Maximum value of UInt64\n  inspect!(@uint64.max_value, content=\"18446744073709551615\")\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Comparison Functions in MoonBit\nDESCRIPTION: This snippet demonstrates generic comparison functions `maximum` and `minimum` provided by the MoonBit math library. These functions can work with any type implementing the `Compare` trait, including numbers and floating-point numbers, as shown in the test cases.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"generic comparison\" {\n  // Works with numbers\n  inspect!(@math.maximum(3, 4), content=\"4\")\n  inspect!(@math.minimum(3, 4), content=\"3\")\n\n  // Works with floating point\n  inspect!(@math.maximum(3.14, 2.718), content=\"3.14\")\n  inspect!(@math.minimum(3.14, 2.718), content=\"2.718\")\n}\n```\n\n----------------------------------------\n\nTITLE: Shrinking Deque Capacity in MoonBit\nDESCRIPTION: Shows how to reduce the memory footprint of a deque using `shrink_to_fit`.  This method attempts to reduce the capacity to match the current length of the deque.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.new(capacity=10)\n  dv.push_back(1)\n  dv.push_back(2)\n  dv.push_back(3)\n  assert_eq!(dv.capacity(), 10)\n  dv.shrink_to_fit()\n  assert_eq!(dv.capacity(), 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Special Floating-Point Values in MoonBit\nDESCRIPTION: This code snippet demonstrates the usage of special floating-point values provided by the `double` package in MoonBit, such as infinity, negative infinity, and NaN (Not a Number). It also shows how to access the maximum, minimum, and minimum positive values that a double-precision floating-point number can represent.\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"special values\" {\n  // Special values\n  inspect!(@double.infinity, content=\"Infinity\")\n  inspect!(@double.neg_infinity, content=\"-Infinity\")\n  inspect!(@double.not_a_number, content=\"NaN\")\n\n  // Limits\n  inspect!(@double.max_value, content=\"1.7976931348623157e+308\")\n  inspect!(@double.min_value, content=\"-1.7976931348623157e+308\")\n  inspect!(@double.min_positive, content=\"2.2250738585072014e-308\")\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ImmutableSet in MoonBit\nDESCRIPTION: Demonstrates how to create an empty ImmutableSet, create a set with a single element, and create a set from an array. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _set1 : @sorted_set.T[Int] = @sorted_set.new()\n    let _set2 = @sorted_set.singleton(1)\n    let _set4 = @sorted_set.from_array([1])\n    let _set5= @sorted_set.of([1])\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Equality of MoonBit SortedMaps\nDESCRIPTION: Demonstrates how to check if two maps are equal using the `==` operator. Maps with the same key-value pairs are considered equal, regardless of the insertion order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_18\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map1 = @sorted_map.from_array([(1, \"one\"), (2, \"two\")])\n  let map2 = @sorted_map.from_array([(2, \"two\"), (1, \"one\")])\n  assert_eq!(map1 == map2, true)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Priority Queues in MoonBit\nDESCRIPTION: Demonstrates how to create a new immutable priority queue using `new()` and initialize it with elements using `of()`. It shows how to create a queue with default (greater-first) ordering.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/priority_queue/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _queue1 : @priority_queue.T[Int] = @priority_queue.new()\n  let _queue2 = @priority_queue.of([1, 2, 3])\n\n}\n```\n\n----------------------------------------\n\nTITLE: Transferring Elements Between Queues in MoonBit\nDESCRIPTION: Shows how to move all elements from one queue to another using the `transfer` method. After the transfer, the source queue is empty, and the destination queue contains all the elements that were in the source queue.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let dst : @queue.T[Int] = @queue.new()\n    let src : @queue.T[Int] = @queue.of([5, 6, 7, 8])\n    src.transfer(dst)\n}\n```\n\n----------------------------------------\n\nTITLE: Rounding Functions in MoonBit\nDESCRIPTION: This snippet showcases various rounding functions available in MoonBit's float package, including `ceil` (rounds up), `floor` (rounds down), `round` (rounds to the nearest integer), and `trunc` (removes the decimal part). The `inspect!` macro is used to assert the correctness of the rounding operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"rounding functions\" {\n  // Ceiling - rounds up\n  inspect!(@float.ceil(3.2), content=\"4\")\n  inspect!(@float.ceil(-3.2), content=\"-3\")\n\n  // Floor - rounds down\n  inspect!(@float.floor(3.2), content=\"3\")\n  inspect!(@float.floor(-3.2), content=\"-4\")\n\n  // Round - rounds to nearest integer\n  inspect!(@float.round(3.7), content=\"4\")\n  inspect!(@float.round(3.2), content=\"3\")\n\n  // Truncate - removes decimal part\n  inspect!(@float.trunc(3.7), content=\"3\")\n  inspect!(@float.trunc(-3.7), content=\"-3\")\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Immutable Arrays in MoonBit\nDESCRIPTION: Shows how to query immutable arrays using `op_get()`, `length()`, and `is_empty()` in MoonBit.  `op_get()` retrieves the value at a specific index, `length()` returns the array's length, and `is_empty()` checks if the array is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/array/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let arr = @array.of([1, 2, 3, 4, 5])\n  assert_eq!(arr[2], 3)\n  assert_eq!(arr.length(), 5)\n  assert_eq!(arr.is_empty(), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Representation Conversion in MoonBit\nDESCRIPTION: This code snippet demonstrates how to convert a double-precision floating-point number to its binary representation in both big-endian and little-endian byte orders using the `double` package in MoonBit. It creates a double `num` with value `1.0` and then converts it to byte arrays using `to_be_bytes` and `to_le_bytes` functions, respectively.\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"binary representation\" {\n  let num = 1.0\n\n  // Convert to big-endian and little-endian bytes\n  // Different byte orders should produce different results\n  inspect!(\n    num.to_be_bytes(),\n    content=\n      #|b\"\\x3f\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\"\n    ,\n  )\n  inspect!(\n    num.to_le_bytes(),\n    content=\n      #|b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Immutable Arrays in MoonBit\nDESCRIPTION: Illustrates how to iterate over immutable arrays using `iter()`, `each()`, and `eachi()` in MoonBit. `iter()` returns an iterator, `each()` iterates over values, and `eachi()` iterates over indices and values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/array/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let arr = @array.of([1, 2, 3, 4, 5])\n  inspect!(arr.iter(), content=\"[1, 2, 3, 4, 5]\")\n  let val = []\n  arr.each(fn(v) { val.push(v) })\n  assert_eq!(val, [1, 2, 3, 4, 5])\n  let vali = []\n  arr.eachi(fn(i, v) { vali.push((i, v)) })\n  assert_eq!(vali, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Element from ImmutableSet in MoonBit\nDESCRIPTION: Shows how to remove an element from an ImmutableSet using the `remove()` method, which returns a new set without the removed element. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.of([3, 8, 1])\n    assert_eq!(set.remove(8).to_array(), [1, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Rounding Functions in MoonBit\nDESCRIPTION: This snippet showcases various rounding functions provided by the MoonBit math library, including `round`, `ceil`, `floor`, and `trunc`. The test cases demonstrate how these functions round different floating-point numbers to integers.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"rounding functions\" {\n  // Round to nearest integer\n  inspect!(@math.round(3.7), content=\"4\")\n  inspect!(@math.round(-3.7), content=\"-4\")\n\n  // Ceiling (round up)\n  inspect!(@math.ceil(3.2), content=\"4\")\n  inspect!(@math.ceil(-3.2), content=\"-3\")\n\n  // Floor (round down)\n  inspect!(@math.floor(3.7), content=\"3\")\n  inspect!(@math.floor(-3.7), content=\"-4\")\n\n  // Truncate (round toward zero)\n  inspect!(@math.trunc(3.7), content=\"3\")\n  inspect!(@math.trunc(-3.7), content=\"-3\")\n}\n```\n\n----------------------------------------\n\nTITLE: Reserving Deque Capacity in MoonBit\nDESCRIPTION: Demonstrates using `reserve_capacity` to ensure a deque can hold a minimum number of elements without reallocating.  It guarantees the capacity will be at least the specified value.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1])\n  dv.reserve_capacity(10)\n  assert_eq!(dv.capacity(), 10)\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Elements to Front and Back in MoonBit\nDESCRIPTION: Illustrates how to add elements to the front and back of a deque using `push_front()` and `push_back()`, respectively.  This shows the bi-directional nature of the deque.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv.push_front(6)\n  dv.push_front(7)\n  dv.push_back(8)\n  dv.push_back(9)\n  //now: 6 7 1 2 3 4 5 8 9\n}\n```\n\n----------------------------------------\n\nTITLE: UInt16 Comparison and Equality in MoonBit\nDESCRIPTION: Illustrates comparison and equality operations (==, !=, >, <, >=, <=) for UInt16 in MoonBit. It showcases how to compare UInt16 values for equality, inequality, greater than, less than, greater than or equal to, and less than or equal to.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint16/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt16 comparison and equality\" {\n  let a : UInt16 = 100\n  let b : UInt16 = 50\n  let c : UInt16 = 100\n\n  // Equality\n  inspect!(a == c, content=\"true\")\n  inspect!(a != b, content=\"true\")\n\n  // Comparison\n  inspect!(a > b, content=\"true\")\n  inspect!(b < a, content=\"true\")\n  inspect!(a >= c, content=\"true\")\n  inspect!(c <= a, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Int64 Binary Conversion in MoonBit\nDESCRIPTION: Shows how to convert an Int64 value to its big-endian and little-endian byte representations using `to_be_bytes` and `to_le_bytes` respectively. It then converts the byte arrays to strings for inspection and verifies their contents and lengths.  This snippet relies on the `to_string()` method of byte arrays and the `length()` method.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int64/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"binary conversion\" {\n  let x = 258L // Int64 value of 258\n  let be_bytes = @int64.to_be_bytes(x)\n  let le_bytes = @int64.to_le_bytes(x)\n\n  // Convert to String for inspection\n  inspect!(\n    be_bytes.to_string(),\n    content=\n      #|b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\"\n    ,\n  )\n  inspect!(\n    le_bytes.to_string(),\n    content=\n      #|b\"\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"\n    ,\n  )\n\n  // We can verify they represent the same number but in different byte orders\n  let len = be_bytes.length()\n  inspect!(len, content=\"8\")\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Integer Operations in MoonBit\nDESCRIPTION: Demonstrates basic integer operations such as getting the absolute value of an integer and accessing the minimum and maximum integer values. It showcases the usage of `@int.abs`, `@int.min_value`, and `@int.max_value` functions. The `inspect!` macro is used to verify the output.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"basic int operations\" {\n  // Get absolute value\n  inspect!(@int.abs(-42), content=\"42\")\n  inspect!(@int.abs(42), content=\"42\")\n\n  // Access min/max values\n  inspect!(@int.min_value, content=\"-2147483648\")\n  inspect!(@int.max_value, content=\"2147483647\")\n}\n```\n\n----------------------------------------\n\nTITLE: Getting All Keys From Map MoonBit\nDESCRIPTION: Shows how to get all keys from a sorted map in ascending order using the `keys()` function. The example creates a map and then retrieves the keys, asserting that they are in the expected order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let keys = map.keys() // [\"a\", \"b\", \"c\"]\n  assert_eq!(keys, [\"a\", \"b\", \"c\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from a Sorted Set in Moonbit\nDESCRIPTION: This snippet shows how to remove an element from a Sorted Set in Moonbit using the `remove` method.  It creates a set, removes an element, and asserts that the resulting set matches the expected content.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.from_array([3, 8, 1]) \n    set.remove(8) // () \n    let set7 = @sorted_set.from_array([1, 3])\n    assert_eq!(set7.to_array(), [1, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Temporary Value Protection in Moonbit\nDESCRIPTION: This snippet shows how to use the `protect` function to temporarily set a reference to a value and restore it after executing a block. It takes a reference, a new value, and a function as arguments. The reference is set to the new value before the function is executed, and restored to its original value afterward. The example shows how to temporarily modify state within a protected block.\nSOURCE: https://github.com/moonbitlang/core/blob/main/ref/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"protected updates\" {\n  let state = @ref.new(100)\n  let mut middle = 0\n  let result = @ref.protect(state, 50, fn() {\n    middle = state.val\n    42\n  })\n  inspect!(middle, content=\"50\")\n  inspect!(result, content=\"42\")\n  inspect!(state.val, content=\"100\")\n}\n```\n\n----------------------------------------\n\nTITLE: Bool to Integer Conversion in MoonBit\nDESCRIPTION: This snippet demonstrates the conversion of boolean values to integers using the `to_int` function/method in MoonBit. It showcases converting `true` to 1 and `false` to 0 using both direct function calls ( `@bool.to_int(bool_value)`) and method syntax (`bool_value.to_int()`).\nSOURCE: https://github.com/moonbitlang/core/blob/main/bool/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"bool to integer conversions\" {\n  // Direct function calls\n  inspect!(@bool.to_int(true), content=\"1\")\n  inspect!(@bool.to_int(false), content=\"0\")\n\n  // Method syntax\n  inspect!(true.to_int(), content=\"1\")\n  inspect!(false.to_int(), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements in MoonBit\nDESCRIPTION: This snippet demonstrates how to access the elements of a tuple using the `fst` and `snd` methods, as well as the shorthand dot notation in MoonBit. It shows how to retrieve the first and second elements of the tuple and assert their values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let tuple = (1, 2)\n    assert_eq!(tuple.0, 1)\n    assert_eq!(tuple.1, 2)\n    assert_eq!(@tuple.fst(tuple), 1)\n    assert_eq!(@tuple.snd(tuple), 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Random Value Generation\nDESCRIPTION: Demonstrates how to generate random values of types that implement the `Arbitrary` trait using `@quickcheck.gen()`. Includes examples for `Bool` and `Int`, as well as generating a sized `Array[Int]`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/quickcheck/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"basic generation\" {\n  let b : Bool = @quickcheck.gen()\n  inspect!(b, content=\"true\")\n  let x : Int = @quickcheck.gen()\n  inspect!(x, content=\"0\")\n\n  // Generate with size parameter\n  let sized : Array[Int] = @quickcheck.gen(size=5)\n  inspect!(sized.length() <= 5, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements Moonbit\nDESCRIPTION: Illustrates accessing elements in a list using `head()`, `last()`, and `nth()`. `head()` retrieves the first element, `last()` retrieves the last element, and `nth()` retrieves the element at a specified index. The example demonstrates how to access different elements and handles cases where the list is empty or the index is out of bounds.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.of([1, 2, 3, 4, 5])\n    assert_eq!(list.head(), Some(1))\n    assert_eq!(list.last(), Some(5))\n}\n```\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.of([1, 2, 3, 4, 5])\n    assert_eq!(list.nth(2), Some(3))\n    assert_eq!(list.nth(8), None)\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing a Moonbit Map\nDESCRIPTION: Shows how to remove all key-value pairs from a Moonbit Map using the `clear` function. The allocated memory remains unchanged.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = { \"a\": 1, \"b\": 2, \"c\": 3 }\n  map.clear()\n  assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over a List Moonbit\nDESCRIPTION: Illustrates iterating over a list using the `each()` method, which applies a given function to each element in the list. The example shows how to collect the elements of the list into an array using `each()`. The `ele` parameter represents the current element during iteration.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.of([1, 2, 3, 4, 5])\n    let arr = []\n    list.each(fn (ele) { arr.push(ele) }) \n    assert_eq!(arr, [1, 2, 3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: All & Any Predicate Checks in MoonBit\nDESCRIPTION: Demonstrates how to use `all()` to verify all elements match a predicate and `any()` to check if at least one element matches a predicate in an ImmutableSet. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    assert_eq!(@sorted_set.of([2, 4, 6]).all(fn(v) { v % 2 == 0}), true)\n    assert_eq!(@sorted_set.of([1, 4, 3]).any(fn(v) { v % 2 == 0}), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a SortedMap in MoonBit\nDESCRIPTION: Demonstrates how to create an empty SortedMap and a SortedMap from an array of key-value pairs using `sorted_map.new()` and `sorted_map.from_array()` respectively. The snippets use type annotations and simple assignments.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _map1 : @sorted_map.T[Int, String] = @sorted_map.new()\n  let _map2 = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Priority Queue Length in MoonBit\nDESCRIPTION: Shows how to get the number of elements in a priority queue using the `length()` method and how to determine if a priority queue is empty using the `is_empty()` method. These methods are useful for checking the state of the queue.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([1, 2, 3, 4, 5])\n  assert_eq!(pq.length(), 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Exponential & Logarithmic Functions in MoonBit\nDESCRIPTION: This code demonstrates exponential and logarithmic functions provided by the `double` package in MoonBit. It includes `exp`, `expm1` (exp(x) - 1), natural logarithm (`ln`), `ln_1p` (ln(1 + x)), base-2 logarithm (`log2`), base-10 logarithm (`log10`), and power functions like `pow`, `cbrt` (cube root), and `hypot` (sqrt(x^2 + y^2)).\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"exponential and logarithmic\" {\n  // Exponential functions\n  inspect!(@double.exp(0.0), content=\"1\")\n  inspect!(@double.expm1(0.0), content=\"0\") // exp(x) - 1\n\n  // Logarithmic functions\n  inspect!(@double.ln(1.0), content=\"0\") // Natural logarithm\n  inspect!(@double.ln_1p(0.0), content=\"0\") // ln(1 + x)\n  inspect!(@double.log2(1.0), content=\"0\") // Base-2 logarithm\n  inspect!(@double.log10(1.0), content=\"0\") // Base-10 logarithm\n\n  // Power functions\n  inspect!(@double.pow(2.0, 3.0), content=\"8\")\n  inspect!(@double.cbrt(8.0), content=\"2\") // Cube root\n  inspect!(@double.hypot(3.0, 4.0), content=\"5\") // sqrt(x^2 + y^2)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Type Arbitrary Implementation\nDESCRIPTION: Shows how to implement the `Arbitrary` trait for custom types. The example defines a `Point` struct with `x` and `y` fields of type `Int` and implements the `Arbitrary` trait for it. It also demonstrates generating random `Point` instances and arrays of `Point` instances.\nSOURCE: https://github.com/moonbitlang/core/blob/main/quickcheck/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x : Int\n  y : Int\n} derive(Show)\n\nimpl Arbitrary for Point with arbitrary(size, r0) {\n  let r1 = r0.split()\n  let y = Arbitrary::arbitrary(size, r1)\n  { x: Arbitrary::arbitrary(size, r0), y }\n}\n\ntest \"custom type generation\" {\n  let point : Point = @quickcheck.gen()\n  inspect!(point, content=\"{x: 0, y: 0}\")\n  let points : Array[Point] = @quickcheck.samples(10)\n  inspect!(\n    points[6:],\n    content=\"[{x: 0, y: 1}, {x: -1, y: -5}, {x: -6, y: -6}, {x: -1, y: 7}]\",\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Tuple Elements in MoonBit\nDESCRIPTION: This snippet demonstrates how to transform the elements of a tuple using the `map_fst` and `map_snd` methods in MoonBit. These methods apply a given function to the first or second element of the tuple, respectively, creating new tuples with transformed values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let tuple = (1, 2)\n    let _tuple2 = @tuple.map_fst(fn(x) { x + 1 }, tuple) // tuple2 = (2, 2)\n    let _tuple3 = @tuple.map_snd(fn(x) { x + 1 }, tuple) // tuple3 = (1, 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Min/Max Values in MoonBit\nDESCRIPTION: Illustrates how to find the minimum and maximum values in an ImmutableSet using the `min()` and `max()` methods, and their option counterparts `min_option()` and `max_option()`. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.of([1, 2, 3, 4])\n    assert_eq!(set.min(), 1)\n    assert_eq!(set.max(), 4)\n    assert_eq!(set.min_option(), Some(1))\n    assert_eq!(set.max_option(), Some(4))\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Conversions in MoonBit\nDESCRIPTION: Demonstrates how to convert an integer to its byte representation in both big-endian and little-endian formats using `@int.to_be_bytes` and `@int.to_le_bytes` respectively. The `inspect!` macro checks if the converted byte strings are as expected.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte conversions\" {\n  let num = 258 // 0x0102 in hex\n\n  // Big-endian conversion (most significant byte first)\n  let be_bytes = @int.to_be_bytes(num)\n  inspect!(\n    be_bytes.to_string(),\n    content=\n      #|b\"\\x00\\x00\\x01\\x02\"\n    ,\n  )\n\n  // Little-endian conversion (least significant byte first)\n  let le_bytes = @int.to_le_bytes(num)\n  inspect!(\n    le_bytes.to_string(),\n    content=\n      #|b\"\\x02\\x01\\x00\\x00\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting values from an Option using `unwrap` method in MoonBit\nDESCRIPTION: Demonstrates extracting a value from an `Option` using the `unwrap` method, which panics if the Option is `None`.  It emphasizes that this is unsafe and `or` or `or_else` should be preferred.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let some: Int? = Some(42)\n    let value = some.unwrap() // 42\n    assert_eq!(value, 42)\n}\n```\n\n----------------------------------------\n\nTITLE: Bool to Other Integer Types in MoonBit\nDESCRIPTION: This snippet shows how to convert boolean values to other integer types like `UInt`, `Int64`, and `UInt64` in MoonBit.  `true` is converted to 1, and `false` is converted to 0 for each integer type. The conversion is done through method syntax (e.g., `bool_value.to_uint()`).\nSOURCE: https://github.com/moonbitlang/core/blob/main/bool/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"bool to other integer types\" {\n  // UInt\n  inspect!(true.to_uint(), content=\"1\")\n  inspect!(false.to_uint(), content=\"0\")\n\n  // Int64\n  inspect!(true.to_int64(), content=\"1\")\n  inspect!(false.to_int64(), content=\"0\")\n\n  // UInt64\n  inspect!(true.to_uint64(), content=\"1\")\n  inspect!(false.to_uint64(), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Indexed Iteration in MoonBit SortedMap\nDESCRIPTION: Illustrates iteration with an index using the `eachi` method. The snippet accumulates the index, key, and value into an array of tuples.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(3, \"three\"), (1, \"one\"), (2, \"two\")])\n  let result = []\n  map.eachi(fn(i, k, v) { result.push((i, k, v)) })\n  assert_eq!(result, [(0, 1, \"one\"), (1, 2, \"two\"), (2, 3, \"three\")])\n}\n```\n\n----------------------------------------\n\nTITLE: Copying a Queue in MoonBit\nDESCRIPTION: Illustrates how to create a new queue that is a copy of an existing queue using the `copy` method. This creates a separate queue with the same elements in the same order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.of([1,2,3])\n    let _queue2 = queue.copy()\n}\n```\n\n----------------------------------------\n\nTITLE: Using `when` to conditionally create Option values in MoonBit\nDESCRIPTION: Demonstrates using the `when` function to create `Some` if the condition is true, otherwise `None`. The value is lazily evaluated. It also shows `unless` which does the opposite.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let some = @option.when(1 > 0, fn () { 42 })\n    assert_eq!(some, Some(42))\n    let none = @option.when(1 < 0, fn () { 42 })\n    assert_eq!(none, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Representation in MoonBit\nDESCRIPTION: This snippet illustrates converting a floating-point number to its byte representation using `to_be_bytes` (big-endian) and `to_le_bytes` (little-endian) methods in MoonBit. It also validates the length of the byte arrays produced by these methods.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte representation\" {\n  let x : Float = 3.14\n  // Big-endian bytes\n  let be_bytes = x.to_be_bytes()\n  // Little-endian bytes\n  let le_bytes = x.to_le_bytes()\n  inspect!(be_bytes.length(), content=\"4\")\n  inspect!(le_bytes.length(), content=\"4\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Repeated Lists Moonbit\nDESCRIPTION: Shows how to build a list by repeating a specified element a given number of times using the `repeat()` method. The example asserts that the created list contains the specified number of repeated elements.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    assert_eq!(@list.repeat(3, 1).to_array(), [1, 1, 1])\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Front and Back Elements in MoonBit\nDESCRIPTION: Explains how to access the first and last elements of a deque using `front()` and `back()`.  These methods return an Option type, which will be None if the deque is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dv.front(), Some(1))\n  assert_eq!(dv.back(), Some(5))\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Result with unwrap in Moonbit\nDESCRIPTION: This code demonstrates how to extract the value from a `Result` using the `unwrap` method. Note that this method will panic if the `Result` is `Err`.  It should be used with caution, only when it is certain that the `Result` is `Ok`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Ok(42)\n    let value = result.unwrap()\n    assert_eq!(value, 42)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple in MoonBit\nDESCRIPTION: This snippet demonstrates how to create a new tuple using the `pair` function or the tuple literal syntax in MoonBit. It initializes two tuples named `_tuple` and `_tuple2` with the values (1, 2).\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _tuple = @tuple.pair(1, 2)\n    let _tuple2 = (1, 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Element Value in MoonBit\nDESCRIPTION: Demonstrates how to modify elements of a deque using the index operator (`[]`).  Bounds checking is the responsibility of the user.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv[0] = 5\n  assert_eq!(dv[0], 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Array Utilities in MoonBit\nDESCRIPTION: Illustrates additional array utilities in MoonBit, including joining a string array using `join` and shuffling an array using `shuffle`.  It demonstrates how to join the elements of a string array with a specified delimiter and shuffle the elements of an array using a deterministic random function for demonstration purposes.\nSOURCE: https://github.com/moonbitlang/core/blob/main/array/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"utilities\" {\n  // Join string array\n  let words = [\"hello\", \"world\"]\n  let joined = words.join(\" \")\n\n  // Random shuffling\n  let nums = [1, 2, 3, 4, 5]\n  // Using deterministic `rand` function below for demonstration\n  // NOTE: When using a normal `rand` function, the actual result may vary\n  let shuffled = nums.shuffle(rand=fn(_) { 1 })\n  inspect!(joined, content=\"hello world\")\n  inspect!(shuffled, content=\"[1, 3, 4, 5, 2]\")\n}\n```\n\n----------------------------------------\n\nTITLE: Number Classification in MoonBit\nDESCRIPTION: This code snippet demonstrates number classification functions in MoonBit, including checks for decimal digits, hexadecimal digits, octal digits, and digits in custom bases. It also includes a check for general numeric characters.  The `inspect!` macro verifies the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/char/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"number classification\" {\n  // Decimal digits\n  inspect!(@char.is_ascii_digit('5'), content=\"true\")\n  inspect!(@char.is_ascii_digit('x'), content=\"false\")\n\n  // Hexadecimal digits\n  inspect!(@char.is_ascii_hexdigit('F'), content=\"true\")\n  inspect!(@char.is_ascii_hexdigit('G'), content=\"false\")\n\n  // Octal digits\n  inspect!(@char.is_ascii_octdigit('7'), content=\"true\")\n  inspect!(@char.is_ascii_octdigit('8'), content=\"false\")\n\n  // Custom base digits\n  inspect!(@char.is_digit('5', 6U), content=\"true\")\n  inspect!(@char.is_digit('6', 6U), content=\"false\")\n\n  // General numeric characters\n  inspect!(@char.is_numeric('1'), content=\"true\")\n  inspect!(@char.is_numeric('A'), content=\"false\")\n}\n```\n\n----------------------------------------\n\nTITLE: Exponential and Logarithmic Functions in MoonBit\nDESCRIPTION: This snippet demonstrates exponential and logarithmic functions provided by the MoonBit math library, including `exp`, `expm1`, `ln`, `ln_1p`, `log2`, and `log10`. It showcases the usage of these functions with sample input values and verifies their output.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"exponential and logarithmic\" {\n  // Exponential functions\n  inspect!(@math.exp(1.0), content=\"2.718281828459045\")\n  inspect!(@math.expm1(1.0), content=\"1.718281828459045\")\n\n  // Natural logarithm\n  inspect!(@math.ln(2.718281828459045), content=\"1\")\n  inspect!(@math.ln_1p(1.718281828459045), content=\"1\")\n\n  // Other logarithm bases\n  inspect!(@math.log2(8.0), content=\"3\")\n  inspect!(@math.log10(100.0), content=\"2\")\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if Priority Queue is Empty in MoonBit\nDESCRIPTION: Illustrates how to use the `is_empty()` method to check if a priority queue is empty in MoonBit. This is useful before performing operations like peek or pop to avoid errors.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq : @priority_queue.T[Int] = @priority_queue.new()\n  assert_eq!(pq.is_empty(), true)\n }\n```\n\n----------------------------------------\n\nTITLE: Getting Length After Initialization in MoonBit\nDESCRIPTION: This snippet checks the length of priority queue after initialization using `of`. It asserts that the length is the same as the number of elements passed in the initialization.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([5, 4, 3, 2, 1])\n  assert_eq!(pq.length(), 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Object Writing in MoonBit\nDESCRIPTION: This snippet shows how to write structured data (specifically, an integer) to a buffer in MoonBit using the `write_object()` method. It assumes the data implements the `Show` trait, which allows it to be represented as a string. The buffer's content will be the string representation of the integer as bytes. The result is then converted to bytes using `.contents()` and compared against the expected byte representation using `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"object writing\" {\n  let buf = @buffer.new()\n\n  // Write int as object\n  buf.write_object(42)\n\n  // Contents will be \"42\" as bytes\n  let contents = buf.contents()\n  inspect!(\n    contents,\n    content=\n      #|b\"\\x34\\x00\\x32\\x00\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Elements with Intersperse Moonbit\nDESCRIPTION: Demonstrates inserting a specified element between each element in a list using the `intersperse()` method. This method adds the given element after each existing element in the original list.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.of([1, 2, 3])\n    assert_eq!(list.intersperse(0).to_array(), [1, 0, 2, 0, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Using `unless` to conditionally create Option values in MoonBit\nDESCRIPTION: Demonstrates using the `unless` function to create `Some` if the condition is false, otherwise `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let some = @option.unless(1 < 0, fn () { 42 })\n    assert_eq!(some, Some(42))\n    let none = @option.unless(1 > 0, fn () { 42 })\n    assert_eq!(none, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Refs in Moonbit\nDESCRIPTION: This code snippet demonstrates how to create a new reference using `@ref.new()` and access its value through the `val` field.  The example creates a reference `r1` initialized with the value 42 and then uses `inspect!` to verify the value.\nSOURCE: https://github.com/moonbitlang/core/blob/main/ref/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"creating and accessing refs\" {\n  let r1 = @ref.new(42)\n  inspect!(r1.val, content=\"42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering ImmutableSet in MoonBit\nDESCRIPTION: Shows how to filter elements in an ImmutableSet based on a given predicate using the `filter()` method. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.of([1, 2, 3, 4, 5, 6])\n    assert_eq!(set.filter(fn(v) { v % 2 == 0}).to_array(), [2, 4, 6])\n}\n```\n\n----------------------------------------\n\nTITLE: Trigonometric Functions in MoonBit\nDESCRIPTION: This snippet demonstrates the use of trigonometric functions in the MoonBit float package. It covers basic functions like `sin`, `cos`, `tan`, inverse trigonometric functions like `asin`, and hyperbolic functions like `sinh`, `cosh`, `tanh`, along with their inverses `asinh`, `acosh`, and `atanh`. The `inspect!` macro is used to verify the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"trigonometric functions\" {\n  // Basic trigonometric functions\n  inspect!(@float.sin(0.0), content=\"0\")\n  inspect!(@float.cos(0.0), content=\"1\")\n  inspect!(@float.tan(0.0), content=\"0\")\n\n  // Inverse trigonometric functions\n  let y = @float.sin(0.5)\n  inspect!(@float.asin(y), content=\"0.5\")\n\n  // Hyperbolic functions\n  inspect!(@float.sinh(0.0), content=\"0\")\n  inspect!(@float.cosh(0.0), content=\"1\")\n  inspect!(@float.tanh(0.0), content=\"0\")\n\n  // Inverse hyperbolic functions\n  inspect!(@float.asinh(0.0), content=\"0\")\n  inspect!(@float.acosh(1.0), content=\"0\")\n  inspect!(@float.atanh(0.0), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Length of Priority Queue in MoonBit\nDESCRIPTION: Illustrates how to determine the length of an immutable priority queue using the `length()` method. It shows how adding elements with `push()` affects the length.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/priority_queue/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.new()\n  assert_eq!(pq.length(), 0)\n  assert_eq!(pq.push(1).length(), 1)\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Hexadecimal Literals\nDESCRIPTION: Demonstrates the usage of hexadecimal literals with UInt64 for improved readability when working with bit patterns. The code shows how to extract a specific byte from a UInt64 value using bitwise shifts and masks and converts the value to its byte representation.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 hexadecimal literals\" {\n  // Using hex literals for better readability when working with bit patterns\n  let value = 0xDEADBEEFUL\n\n  // Extract specific byte using shifts and masks\n  let ad = (value >> 16) & 0xFFUL\n  inspect!(ad.to_byte(), content=\"b'\\\\xAD'\")\n\n  // Convert to byte representation\n  let bytes = @uint64.to_be_bytes(value)\n  inspect!(\n    bytes,\n    content=\n      #|b\"\\x00\\x00\\x00\\x00\\xde\\xad\\xbe\\xef\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Lists with Cons Moonbit\nDESCRIPTION: Illustrates creating a list using the `Cons` constructor, which prepends a single element to the beginning of the list. This example shows how to build a list by repeatedly applying `Cons` to add elements.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.Cons(1, Cons(2, Cons(3, Nil)))\n    assert_eq!(list.to_array(), [1, 2, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Trigonometric Functions in MoonBit\nDESCRIPTION: This snippet showcases basic trigonometric functions (sin, cos, tan) and their inverse functions (asin, acos, atan) provided by the MoonBit math library. The tests verify that these functions operate correctly with specific input values in radians.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"basic trigonometry\" {\n  // Basic trig functions\n  inspect!(@math.sin(@math.PI / 2.0), content=\"1\")\n  inspect!(@math.cos(0.0), content=\"1\")\n  inspect!(@math.tan(@math.PI / 4.0), content=\"0.9999999999999999\")\n\n  // Inverse trig functions\n  inspect!(@math.asin(1.0), content=\"1.5707963267948966\")\n  inspect!(@math.acos(1.0), content=\"0\")\n  inspect!(@math.atan(1.0), content=\"0.7853981633974483\")\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Lists Moonbit\nDESCRIPTION: Shows how to filter, take, and drop elements from a list using `filter()`, `take()`, `drop()`, `take_while()`, and `drop_while()`. The example demonstrates different filtering criteria, including filtering based on a condition, taking the first N elements, dropping the first N elements, taking elements while a condition is met, and dropping elements while a condition is met.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let ls = @list.of([1, 2, 3, 4, 5])\n    assert_eq!(ls.filter(fn (ele) { ele % 2 == 0 }).to_array(), [2, 4])\n    assert_eq!(ls.take(2).to_array(), [1, 2])\n    assert_eq!(ls.drop(2).to_array(), [3, 4, 5])\n    assert_eq!(ls.take_while(fn (ele) { ele < 3 }).to_array(), [1, 2])\n    assert_eq!(ls.drop_while(fn (ele) { ele < 3 }).to_array(), [3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Create a new MoonBit project (bash)\nDESCRIPTION: This command creates a new MoonBit project named 'hello' and navigates into the project directory.  It then creates a simple MoonBit program that prints the reversed array [1, 2, 3].\nSOURCE: https://github.com/moonbitlang/core/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmoon new hello\ncd hello\necho \\\"\\\"\\\"fn main {\n  println([1, 2, 3].rev())\n}\\\"\\\"\\\" > src/main/main.mbt\nmoon run src/main\n```\n\n----------------------------------------\n\nTITLE: Trigonometric Functions in MoonBit\nDESCRIPTION: This snippet demonstrates the use of trigonometric functions provided by the `double` package in MoonBit. It includes examples for sine, cosine, tangent, and their respective inverse functions (arcsin, arccos, arctan). Additionally, it shows the usage of the two-argument arctangent function, `atan2`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"trigonometric functions\" {\n  // Basic trigonometric functions\n  inspect!(@double.sin(0.0), content=\"0\")\n  inspect!(@double.cos(0.0), content=\"1\")\n  inspect!(@double.tan(0.0), content=\"0\")\n\n  // Inverse trigonometric functions\n  inspect!(@double.asin(0.0), content=\"0\")\n  inspect!(@double.acos(1.0), content=\"0\")\n  inspect!(@double.atan(0.0), content=\"0\")\n\n  // Two-argument arctangent\n  inspect!(@double.atan2(0.0, 1.0), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Clone moonbitlang/core repository (bash)\nDESCRIPTION: This command clones the moonbitlang/core repository from GitHub into the default location where the `moon` tool expects to find it. This step is essential to get the latest version of the core library.\nSOURCE: https://github.com/moonbitlang/core/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/moonbitlang/core ~/.moon/lib/core\n```\n\n----------------------------------------\n\nTITLE: Iterating and Folding in MoonBit\nDESCRIPTION: Illustrates how to iterate through an ImmutableSet using `each()`, and how to fold (reduce) the set into a single value using `fold()`, also demonstrating `map()` to transform each element. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let arr = []\n    @sorted_set.of([7, 2, 9, 4, 5, 6, 3, 8, 1]).each(fn(v) { arr.push(v) })\n    assert_eq!(arr, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    let val = @sorted_set.of([1, 2, 3, 4, 5]).fold(init=0, fn(acc, x) { acc + x })\n    assert_eq!(val, 15)\n    let set = @sorted_set.of([1, 2, 3])\n    assert_eq!(set.map(fn(x){ x * 2}).to_array(), [2, 4, 6])\n}\n```\n\n----------------------------------------\n\nTITLE: UInt16 Arithmetic Operations in MoonBit\nDESCRIPTION: Illustrates standard arithmetic operations (+, -, *, /) for UInt16 in MoonBit. It showcases how UInt16 values can be added, subtracted, multiplied, and divided. Also demonstrates overflow and underflow behavior.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint16/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt16 arithmetic\" {\n  let a : UInt16 = 100\n  let b : UInt16 = 50\n\n  // Addition\n  inspect!(a + b, content=\"150\")\n\n  // Subtraction\n  inspect!(a - b, content=\"50\")\n\n  // Multiplication\n  inspect!(a * b, content=\"5000\")\n\n  // Division\n  inspect!(a / b, content=\"2\")\n\n  // Overflow behavior\n  inspect!(@uint16.max_value + 1, content=\"0\") // Wraps around to 0\n  inspect!(@uint16.min_value - 1, content=\"65535\") // Underflow wraps to maximum value\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if Moonbit Map is Empty\nDESCRIPTION: Demonstrates how to check if a Moonbit Map is empty using the `is_empty` function.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map : Map[String, Int] = {}\n  assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Byte View Writing in MoonBit\nDESCRIPTION: This snippet demonstrates writing a subset (view) of a byte array to a buffer in MoonBit.  It creates a new buffer using `@buffer.new()`, defines a byte array, and then writes a portion of the byte array (from index 0 up to, but not including, index 5, resulting in the substring \"Hello\") to the buffer using the `write_bytesview()` method.  Finally, it converts the buffer's contents to bytes using `to_bytes()` and verifies the byte representation of the written view using `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte view writing\" {\n  let buf = @buffer.new()\n  let bytes = b\"Hello World\"\n\n  // Write a view of the bytes\n  buf.write_bytesview(bytes[0:5]) // Write \"Hello\"\n  let contents = buf.to_bytes()\n  inspect!(\n    contents,\n    content=\n      #|b\"\\x48\\x65\\x6c\\x6c\\x6f\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Uncurrying a Function in MoonBit\nDESCRIPTION: This snippet demonstrates how to uncurry a function using the `uncurry` method in MoonBit. Uncurrying transforms a curried function (a sequence of single-argument functions) back into a function that takes multiple arguments at once. The example shows uncurrying an addition function.\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let add = fn(a) { fn(b) { a + b } }\n    let uncurried_add = @tuple.uncurry(add)\n    let _result = uncurried_add(1, 2) // result = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Int16 Type Coercion Moonbit\nDESCRIPTION: This code snippet demonstrates the type coercion of integer literals to the `Int16` type. Integer literals, including hexadecimal and binary literals, are implicitly converted to `Int16` when the type is explicitly specified.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int16/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"int16 coercion\" {\n  let a : Int16 = 42 // Coercion from integer literal\n  let b : Int16 = 0xFF // Hexadecimal literal\n  let c : Int16 = 0b1111 // Binary literal\n  inspect!(a, content=\"42\")\n  inspect!(b, content=\"255\")\n  inspect!(c, content=\"15\")\n}\n```\n\n----------------------------------------\n\nTITLE: UInt Basics: Default, Max, and Min Values in MoonBit\nDESCRIPTION: This code snippet demonstrates accessing the default, maximum, and minimum values of the `UInt` type in MoonBit. It showcases the usage of `@uint.default()`, `@uint.max_value`, and `@uint.min_value` to retrieve these values, which are then inspected to verify their correctness. No external dependencies are required.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"uint basics\" {\n  // Default value is 0\n  inspect!(@uint.default(), content=\"0\")\n\n  // Maximum and minimum values\n  inspect!(@uint.max_value, content=\"4294967295\")\n  inspect!(@uint.min_value, content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Special Functions in MoonBit\nDESCRIPTION: This snippet showcases special two-argument mathematical functions from the MoonBit math library, including `atan2`, `hypot`, and `cbrt`. The test cases demonstrate how these functions work with specific inputs and provide the expected outputs.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"special functions\" {\n  // atan2 gives the angle in radians between the positive x-axis and the ray to point (x,y)\n  inspect!(@math.atan2(1.0, 1.0), content=\"0.7853981633974483\")\n\n  // hypot computes sqrt(x*x + y*y) without intermediate overflow\n  inspect!(@math.hypot(3.0, 4.0), content=\"5\")\n\n  // Cube root\n  inspect!(@math.cbrt(8.0), content=\"2\")\n}\n```\n\n----------------------------------------\n\nTITLE: Buffer as Logger in MoonBit\nDESCRIPTION: This snippet illustrates how to use a buffer as a logger in MoonBit.  It creates a new buffer, then uses the `output()` method (which is part of the `Logger` trait) to write the string representation of an array to the buffer. Finally, it retrieves the contents of the buffer as bytes using `contents()` and verifies the byte representation of the array's logged output using `inspect!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"buffer as logger\" {\n  let buf = @buffer.new()\n  let array = [1, 2, 3]\n\n  // Use buffer to log array\n  array.output(buf)\n  let contents = buf.contents()\n  inspect!(\n    contents,\n    content=\n      #|b\"\\x5b\\x00\\x31\\x00\\x2c\\x00\\x20\\x00\\x32\\x00\\x2c\\x00\\x20\\x00\\x33\\x00\\x5d\\x00\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Map MoonBit\nDESCRIPTION: Demonstrates creating an empty sorted map and a map with a single key-value pair using `new()` and `singleton()` respectively. The `size()` function is then used to assert the number of elements in each map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map1 : @sorted_map.T[String, Int] = @sorted_map.new()\n  let map2 = @sorted_map.singleton(\"a\", 1)\n  assert_eq!(map1.size(), 0)\n  assert_eq!(map2.size(), 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Both Tuple Elements in MoonBit\nDESCRIPTION: This snippet demonstrates how to transform both elements of a tuple using the `map_both` method in MoonBit. The `map_both` method applies separate functions to the first and second elements of the tuple, resulting in a new tuple with the transformed values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let tuple = (1, 2)\n    let _mapped = @tuple.map_both(\n        fn(x : Int) -> Int { x + 1 },\n        fn(x : Int) -> Int { x - 1 },\n        tuple\n    ) // mapped = (2, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Comparison by Key Example in MoonBit\nDESCRIPTION: Demonstrates the usage of `@cmp.maximum_by_key()` and `@cmp.minimum_by_key()` to compare strings by their length and structs by a specific field (age). It also shows how the comparison handles cases where the keys are equal, prioritizing the first argument as the minimum.\nSOURCE: https://github.com/moonbitlang/core/blob/main/cmp/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"cmp_by_key\" {\n  struct Person {\n    name : String\n    age : Int\n  } derive(Show)\n\n  // Compare strings by their length\n  let s1 = \"hello\"\n  let s2 = \"hi\"\n  let longer = @cmp.maximum_by_key(s1, s2, String::length)\n  inspect!(longer, content=\"hello\")\n\n  // Compare structs by a specific field\n  let alice = { name: \"Alice\", age: 25 }\n  let bob = { name: \"Bob\", age: 30 }\n  let younger = @cmp.minimum_by_key(alice, bob, fn(p) { p.age })\n  inspect!(younger, content=\"{name: \\\"Alice\\\", age: 25}\")\n\n  // When keys are equal, the first argument is considered the minimum\n  let p1 = (\"first\", 1)\n  let p2 = (\"second\", 1)\n  let snd = fn(p : (_, _)) { p.1 }\n  assert_eq!(@cmp.minimum_by_key(p1, p2, snd), p1)\n  assert_eq!(@cmp.maximum_by_key(p1, p2, snd), p2)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Sub-lists Moonbit\nDESCRIPTION: Demonstrates how to get sub-lists using the `init_()` and `tail()` methods. `init_()` returns a list containing all elements except the last one, and `tail()` returns a list containing all elements except the first one.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.of([1, 2, 3, 4, 5])\n    assert_eq!(list.init_().to_array(), [1, 2, 3, 4])\n    assert_eq!(list.tail().to_array(), [2, 3, 4, 5])\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Multiple Samples\nDESCRIPTION: Illustrates how to generate multiple test cases using the `samples` function. Shows how to generate an array of random `Int` and `String` values and inspect a slice of the `String` array.\nSOURCE: https://github.com/moonbitlang/core/blob/main/quickcheck/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"multiple samples\" {\n  let ints : Array[Int] = @quickcheck.samples(5)\n  inspect!(ints, content=\"[0, 0, 0, -1, -1]\")\n  let strings : Array[String] = @quickcheck.samples(12)\n  inspect!(\n    strings[5:10],\n    content=\n      \n  #|[\"E\\b\\x0f \", \"\", \"K\\x1f[\", \"!@\", \"xvLxb\"]\n\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Hyperbolic Functions in MoonBit\nDESCRIPTION: This snippet demonstrates the usage of hyperbolic functions (sinh, cosh, tanh) and their inverse functions (asinh, acosh, atanh) from the MoonBit math library. Test cases verify the output of these functions with specific input values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"hyperbolic functions\" {\n  // Hyperbolic functions\n  inspect!(@math.sinh(1.0), content=\"1.1752011936438014\")\n  inspect!(@math.cosh(1.0), content=\"1.5430806348152437\")\n  inspect!(@math.tanh(1.0), content=\"0.7615941559557649\")\n\n  // Inverse hyperbolic functions\n  inspect!(@math.asinh(1.0), content=\"0.881373587019543\")\n  inspect!(@math.acosh(2.0), content=\"1.3169578969248166\")\n  inspect!(@math.atanh(0.5), content=\"0.5493061443340548\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a MoonBit SortedMap from an Iterator\nDESCRIPTION: Illustrates how to create a map from an iterator using `sorted_map.from_iter()`. The iterator provides key-value pairs.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_15\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pairs = [(1, \"one\"), (2, \"two\"), (3, \"three\")].iter()\n  let map = @sorted_map.from_iter(pairs)\n  assert_eq!(map.size(), 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Lists Moonbit\nDESCRIPTION: Demonstrates pattern matching on a list to extract the head element. The `match` statement checks if the list is `Cons` (non-empty) or `Nil` (empty), and extracts the head element if it exists. This example shows basic list destructuring.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let list = @list.of([1, 2, 3, 4, 5])\n    let arr = []\n    match list {\n        Cons(head, _tail) => arr.push(head)\n        Nil => println(\"Empty list\")\n    }\n    assert_eq!(arr, [1])\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Element Access in MoonBit\nDESCRIPTION: Demonstrates direct access to deque elements using the index operator (`[]`). It's important to ensure the index is within the bounds of the deque to avoid errors.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dv[0], 1)\n  assert_eq!(dv[4], 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing a MoonBit SortedMap\nDESCRIPTION: Illustrates how to remove all elements from the map using the `clear` method and confirms the map is empty after clearing.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n  map.clear()\n  assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if Sorted Set is Empty in Moonbit\nDESCRIPTION: This snippet demonstrates how to check if a Sorted Set is empty using the `is_empty` method in Moonbit.  It creates an empty set and asserts that `is_empty` returns true.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set : @sorted_set.T[Int] = @sorted_set.new()\n    assert_eq!(set.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Hyperbolic Functions in MoonBit\nDESCRIPTION: This code snippet illustrates the usage of hyperbolic functions from the `double` package in MoonBit. It covers basic hyperbolic functions like sinh, cosh, and tanh, as well as their inverse counterparts: asinh, acosh, and atanh. The `inspect!` macro verifies the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/double/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"hyperbolic functions\" {\n  // Basic hyperbolic functions\n  inspect!(@double.sinh(0.0), content=\"0\")\n  inspect!(@double.cosh(0.0), content=\"1\")\n  inspect!(@double.tanh(0.0), content=\"0\")\n\n  // Inverse hyperbolic functions\n  inspect!(@double.asinh(0.0), content=\"0\")\n  inspect!(@double.acosh(1.0), content=\"0\")\n  inspect!(@double.atanh(0.0), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Int16 Comparison Operations Moonbit\nDESCRIPTION: This code snippet illustrates the comparison operations for the `Int16` type using `==`, `>`, and `<` operators. It also demonstrates the `compare` function, which returns -1, 0, or 1 depending on whether the first value is less than, equal to, or greater than the second value, respectively.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int16/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"int16 comparison\" {\n  let a : Int16 = 100\n  let b : Int16 = 50\n  let c : Int16 = 100\n\n  // Equality\n  inspect!(a == b, content=\"false\")\n  inspect!(a == c, content=\"true\")\n\n  // Ordering\n  inspect!(a > b, content=\"true\")\n  inspect!(b < c, content=\"true\")\n\n  // Compare function returns -1, 0, or 1\n  inspect!(a.compare(b), content=\"1\")\n  inspect!(b.compare(c), content=\"-1\")\n  inspect!(a.compare(c), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting ImmutableSet in MoonBit\nDESCRIPTION: Shows how to split an ImmutableSet into two sets based on an intermediate value using the `split()` method. The method returns a tuple containing the left set, a boolean indicating if the value exists and the right set. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let (left, present, right) = @sorted_set.of([7, 2, 9, 4, 5, 6, 3, 8, 1]).split(5)\n    assert_eq!(present, true)\n    assert_eq!(left.to_array(), [1, 2, 3, 4])\n    assert_eq!(right.to_array(), [6, 7, 8, 9])\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing a Deque in MoonBit\nDESCRIPTION: Shows how to remove all elements from a deque using the `clear()` method. The capacity remains unchanged.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv.clear()\n  assert_eq!(dv.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Is Empty Check in MoonBit\nDESCRIPTION: Illustrates how to check if a HashMap is empty using the `is_empty()` function. The example creates a new empty HashMap and verifies that `is_empty()` returns true.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let map: @hashmap.T[String, Int] = @hashmap.new()\n    assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Int16 Default Value Moonbit\nDESCRIPTION: This code snippet demonstrates the default value for the `Int16` type, which is 0. It utilizes the `Int16::default()` method to obtain the default value.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int16/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"int16 default\" {\n  let x = Int16::default()\n  inspect!(x, content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Deque with Capacity in MoonBit\nDESCRIPTION: Shows how to create a deque with a specified initial capacity using the `new()` method.  This allows pre-allocation of memory to potentially improve performance when many elements are added.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _dv: @deque.T[Int] = @deque.new(capacity=10)\n}\n```\n\n----------------------------------------\n\nTITLE: UInt16 Type Conversions in MoonBit\nDESCRIPTION: Illustrates type conversions to and from UInt16 in MoonBit. It shows how to convert from Int to UInt16 using `.to_uint16()` and from UInt16 to Int using `.to_int()`.  It also shows how byte literals can be converted to UInt16.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint16/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt16 conversions\" {\n  // From Int to UInt16\n  inspect!((42).to_uint16(), content=\"42\")\n\n  // From UInt16 to Int\n  let value : UInt16 = 100\n  inspect!(value.to_int(), content=\"100\")\n\n  // Overflow handling in conversions\n  inspect!((-1).to_uint16(), content=\"65535\") // Negative numbers wrap around\n  inspect!((65536).to_uint16(), content=\"0\") // Values too large wrap around\n  inspect!((65537).to_uint16(), content=\"1\") // 65536 + 1 = 1 (modulo 65536)\n\n  // From Byte to UInt16\n  inspect!(b'A'.to_uint16(), content=\"65\")\n  inspect!(b'\\xFF'.to_uint16(), content=\"255\")\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Values from a SortedMap in MoonBit\nDESCRIPTION: Demonstrates how to retrieve a value by its key using the `get` method, which returns an `Option[V]`. It covers cases where the key exists and when it doesn't.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n  assert_eq!(map.get(2), Some(\"two\"))\n  assert_eq!(map.get(4), None)\n}\n```\n\n----------------------------------------\n\nTITLE: Utility Functions in MoonBit\nDESCRIPTION: This snippet demonstrates the usage of utility functions available in MoonBit's float package. These include `abs` (absolute value), `hypot` (hypotenuse calculation), `to_int` (conversion to integer), and `default` (default value). The inspect! macro validates the returned values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"utility functions\" {\n  // Absolute value\n  inspect!(@float.abs(-3.14), content=\"3.140000104904175\")\n\n  // Hypotenuse calculation\n  inspect!(@float.hypot(3.0, 4.0), content=\"5\")\n\n  // Conversion to integer\n  inspect!(@float.to_int(3.14), content=\"3\")\n\n  // Default value\n  inspect!(@float.default(), content=\"0\")\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Decode Error Handling with JSON Path in MoonBit\nDESCRIPTION: This snippet demonstrates how to handle errors that occur during JSON decoding in MoonBit, specifically using `@json.JsonDecodeError` to capture the error path and message. It catches the `JsonDecodeError` exception, extracts the path and message, and inspects them. This allows for precise error reporting when converting JSON to native types.\nSOURCE: https://github.com/moonbitlang/core/blob/main/json/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"json path\" {\n  // Handle decode errors\n  try {\n    let _arr : Array[Int] = @json.from_json!(([42, \"not a number\", 49] : Json))\n    panic()\n  } catch {\n    @json.JsonDecodeError((path, msg)) => {\n      inspect!(path, content=\"$[1]\")\n      inspect!(msg, content=\"Int::from_json: expected number\")\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Result to Option with to_option in Moonbit\nDESCRIPTION: This code demonstrates how to convert a `Result[T, E]` into an `Option[T]` using the `to_option` method.  If the `Result` is `Ok`, it returns `Some(value)`; if it's `Err`, it returns `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/result/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let result: Result[Int, String] = Ok(42)\n    let option = result.to_option()\n    assert_eq!(option, Some(42))\n    let result1: Result[Int, String] = Err(\"error\")\n    let option1 = result1.to_option()\n    assert_eq!(option1, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Determining Inclusion and Separation in Moonbit\nDESCRIPTION: This snippet demonstrates how to determine subset and disjoint relationships between two Sorted Sets in Moonbit. It showcases the usage of `subset` and `disjoint` methods.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set1 = @sorted_set.from_array([1, 2, 3])\n    let set2 = @sorted_set.from_array([7, 2, 9, 4, 5, 6, 3, 8, 1])\n    assert_eq!(set1.subset(set2), true)\n    let set3 = @sorted_set.from_array([4, 5, 6])\n    assert_eq!(set1.disjoint(set3), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Moonbit Map Size and Capacity\nDESCRIPTION: Illustrates how to retrieve the size (number of key-value pairs) and capacity of a Moonbit Map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = { \"a\": 1, \"b\": 2, \"c\": 3 }\n  assert_eq!(map.size(), 3)\n  assert_eq!(map.capacity(), 8)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ImmutableSet to Array in MoonBit\nDESCRIPTION: Shows how to convert an ImmutableSet to a sorted array using the `to_array()` method. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.of([3, 2, 1])\n    assert_eq!(set.to_array(), [1, 2, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Unit String Conversion MoonBit\nDESCRIPTION: Shows how to convert a `Unit` value to a string using both the standalone `to_string` function and the method call on the `Unit` value itself.\nSOURCE: https://github.com/moonbitlang/core/blob/main/unit/README.mbt.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"unit string conversion\" {\n  let u = ()\n  // Both ways produce the same result\n  inspect!(@unit.to_string(u), content=\"()\")\n  inspect!(u.to_string(), content=\"()\")\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Literals in MoonBit\nDESCRIPTION: This snippet showcases the use of byte literals in MoonBit, demonstrating various ways to define them, including ASCII characters, hexadecimal escape sequences, null bytes, and maximum values. It then converts each byte to a `UInt64` and inspects the result.\nSOURCE: https://github.com/moonbitlang/core/blob/main/byte/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte literals\" {\n  // ASCII character\n  let a = b'a'\n  inspect!(a.to_uint64(), content=\"97\")\n\n  // Hexadecimal escape sequence\n  let hex = b'\\\\x41'\n  inspect!(hex.to_uint64(), content=\"65\")\n\n  // Null byte\n  let null = b'\\\\x00'\n  inspect!(null.to_uint64(), content=\"0\")\n\n  // Maximum value\n  let max = b'\\\\xff'\n  inspect!(max.to_uint64(), content=\"255\")\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Constants in MoonBit\nDESCRIPTION: This snippet demonstrates how to access the minimum and maximum values of a byte in MoonBit using the `byte` package. It uses the `inspect!` macro to verify the values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/byte/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"byte constants\" {\n  inspect!(@byte.min_value, content=\"b'\\\\x00'\")\n  inspect!(@byte.max_value, content=\"b'\\\\xFF'\")\n}\n```\n\n----------------------------------------\n\nTITLE: Rational Integer Operations in MoonBit\nDESCRIPTION: This snippet demonstrates integer-related operations on the `Rational` type in MoonBit, including `floor`, `ceil`, `fract`, `trunc`, and `is_integer`. The `fract` function's result is converted to a string using `to_string()`. It uses `assert_eq!` to validate the results of these operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/rational/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let a = @rational.new(1L, 2L).unwrap()\n    assert_eq!(a.floor(), 0)\n    assert_eq!(a.ceil(), 1)\n    assert_eq!(a.fract().to_string(), \"1/2\")\n    assert_eq!(a.trunc(), 0)\n    assert_eq!(a.is_integer(), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Mathematical Constants in MoonBit\nDESCRIPTION: This snippet demonstrates the usage of the mathematical constant  (PI) from the MoonBit math library within a test case. It verifies that the constant's value is approximately 3.141592653589793.\nSOURCE: https://github.com/moonbitlang/core/blob/main/math/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"mathematical constants\" {\n  inspect!(@math.PI, content=\"3.141592653589793\")\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Priority Queue in MoonBit\nDESCRIPTION: Demonstrates how to create a priority queue in MoonBit using `new()` and `of()` methods. `new()` creates an empty priority queue, while `of()` creates a priority queue from a given list of elements. The default priority queue is greater-first.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _queue1 : @priority_queue.T[Int] = @priority_queue.new()\n  let _queue2 = @priority_queue.of([1, 2, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: Checking If Map Is Empty MoonBit\nDESCRIPTION: Demonstrates how to check if a sorted map is empty using the `is_empty()` function. An empty map is created, and then it's asserted that the map is indeed empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map : @sorted_map.T[String, Int] = @sorted_map.new()\n  assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Set Difference in MoonBit\nDESCRIPTION: Illustrates how to calculate the difference between two ImmutableSets using the `difference()` method. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set1 = @sorted_set.of([1, 2, 3])\n    let set2 = @sorted_set.of([4, 5, 1])\n    assert_eq!(set1.difference(set2).to_array(), [2, 3])\n}\n```\n\n----------------------------------------\n\nTITLE: UInt16 Bitwise Operations in MoonBit\nDESCRIPTION: Demonstrates bitwise operations (AND, OR, XOR, left shift, right shift) for UInt16 in MoonBit. The code shows how to perform bitwise AND (&), bitwise OR (|), bitwise XOR (^), left shift (<<), and right shift (>>) operations on UInt16 values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint16/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt16 bitwise operations\" {\n  let a : UInt16 = 0b1010\n  let b : UInt16 = 0b1100\n\n  // Bitwise AND\n  inspect!(a & b, content=\"8\")\n\n  // Bitwise OR\n  inspect!(a | b, content=\"14\")\n\n  // Bitwise XOR\n  inspect!(a ^ b, content=\"6\")\n\n  // Left shift\n  inspect!(a << 1, content=\"20\")\n  inspect!(a << 2, content=\"40\")\n\n  // Right shift\n  inspect!(a >> 1, content=\"5\")\n  inspect!(b >> 2, content=\"3\")\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Immutable Arrays in MoonBit\nDESCRIPTION: Demonstrates how to concatenate two immutable arrays using `concat()` in MoonBit. The operation returns a new array containing all elements from both input arrays.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/array/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let arr1 = @array.of([1, 2, 3])\n  let arr2 = @array.of([4, 5, 6])\n  let arr3 = arr1.concat(arr2)\n  assert_eq!(arr3.to_array(), [1, 2, 3, 4, 5, 6])\n}\n```\n\n----------------------------------------\n\nTITLE: UInt64 Default Value and Hashing\nDESCRIPTION: Illustrates the default value implementation for UInt64, which is 0. Additionally, demonstrates hash support via `.hash()` method and verifies its output.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint64/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt64 default value\" {\n  // Default value is 0\n  let a : UInt64 = 0UL\n  inspect!(a, content=\"0\")\n\n  // Hash support is available via .hash()\n  let value : UInt64 = 42UL\n  inspect!(value.hash(), content=\"-1962516083\")\n}\n```\n\n----------------------------------------\n\nTITLE: Int16 Range Definition Moonbit\nDESCRIPTION: This code snippet demonstrates the range of the `Int16` type using `min_value` and `max_value` constants. It asserts that the minimum value is -32768 and the maximum value is 32767.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int16/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"int16 range\" {\n  inspect!(@int16.min_value, content=\"-32768\")\n  inspect!(@int16.max_value, content=\"32767\")\n}\n```\n\n----------------------------------------\n\nTITLE: Safe vs Unsafe String Operations in MoonBit\nDESCRIPTION: This snippet demonstrates the difference between unsafe and safe string operations in MoonBit. Unsafe operations, like `char_at(1)` on a string containing a surrogate pair, may split surrogate pairs, leading to unexpected results. Safe operations, like iterating over a string using `iter()`, handle surrogate pairs correctly and ensure Unicode safety. The example uses `ignore(c)` to prevent the 'unused variable' warning, indicating that the character `c` is intentionally not being used in the loop body.\nSOURCE: https://github.com/moonbitlang/core/blob/main/string/DESIGN.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"unsafe vs safe\" {\n  // Unsafe: May split surrogate pairs\n  let emoji = \"\"\n  let _ = emoji.char_at(1) // Gets second half of surrogate pair\n  // Safe: Uses iterator\n  for c in \"Hello \".iter() {\n    // Properly handles both ASCII and Unicode chars\n    ignore(c)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bundle moonbitlang/core (bash)\nDESCRIPTION: This command bundles the moonbitlang/core library.  It compiles the core library into a single file that can be used by other MoonBit projects.  The `--source-dir` argument specifies the location of the source code.\nSOURCE: https://github.com/moonbitlang/core/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmoon bundle --source-dir ~/.moon/lib/core\n```\n\n----------------------------------------\n\nTITLE: Converting MoonBit SortedMap to Array\nDESCRIPTION: Demonstrates how to convert the map to an array of key-value pairs using the `to_array` method. The resulting array maintains the sorted order of keys.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(3, \"three\"), (1, \"one\"), (2, \"two\")])\n  assert_eq!(map.to_array(), [(1, \"one\"), (2, \"two\"), (3, \"three\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Popping Elements in MoonBit\nDESCRIPTION: Demonstrates the usage of `unsafe_pop_front()` and `unsafe_pop_back()` to remove elements without returning the value. These functions panic if the deque is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  dv.unsafe_pop_front()\n  assert_eq!(dv.front(), Some(2))\n  dv.unsafe_pop_back()\n  assert_eq!(dv.back(), Some(4))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Sorted Sets in Moonbit\nDESCRIPTION: This snippet demonstrates various ways to initialize a Sorted Set in Moonbit, including creating an empty set, a singleton set, and a set from an array.  It showcases the `new`, `singleton`, and `from_array` methods.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let _set1 : @sorted_set.T[Int] = @sorted_set.new()\n    let _set2 = @sorted_set.singleton(1)\n    let _set3 = @sorted_set.from_array([1])\n}\n```\n\n----------------------------------------\n\nTITLE: Peeking at Priority Queue Head in MoonBit\nDESCRIPTION: Demonstrates how to peek at the head element (maximum or minimum value) of a priority queue using the `peek()` method in MoonBit. The method returns an Option, which will be `None` if the queue is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([1, 2, 3, 4, 5])\n  assert_eq!(pq.peek(), Some(5))\n}\n```\n\n----------------------------------------\n\nTITLE: Getting the Size of a MoonBit SortedMap\nDESCRIPTION: Shows how to retrieve the size of the map using the `size` method. This provides the number of key-value pairs in the map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n  assert_eq!(map.size(), 3)\n}\n```\n\n----------------------------------------\n\nTITLE: UInt16 Constants in MoonBit\nDESCRIPTION: Defines and demonstrates the use of `min_value` and `max_value` constants for UInt16 in MoonBit. `min_value` represents the smallest possible UInt16 value (0), and `max_value` represents the largest possible UInt16 value (65535).\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint16/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt16 constants\" {\n  // Minimum value of UInt16\n  inspect!(@uint16.min_value, content=\"0\")\n\n  // Maximum value of UInt16\n  inspect!(@uint16.max_value, content=\"65535\")\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Trait Implementations MoonBit\nDESCRIPTION: Illustrates the implementation of the `Compare`, `Hash`, and `Default` traits for the `Unit` type.  All unit values compare equal and hash to the same value. `Unit::default()` returns the unit value.\nSOURCE: https://github.com/moonbitlang/core/blob/main/unit/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"unit trait implementations\" {\n  // Compare - all unit values compare equal\n  let u1 = ()\n  let u2 = ()\n  inspect!(u1.compare(u2), content=\"0\")\n\n  // Hash - all unit values hash to the same value\n  let h1 = u1.hash()\n  let h2 = u2.hash()\n  inspect!(h1 == h2, content=\"true\")\n\n  // Default - provides the unit value\n  let u3 = Unit::default()\n  inspect!(u3 == u1, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Define Special Float Values in MoonBit\nDESCRIPTION: This snippet defines and tests special floating-point values such as infinity, negative infinity, NaN (Not a Number), maximum value, minimum value, and minimum positive value using the MoonBit's float package. The inspect! macro is used to check the values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"special float values\" {\n  // Infinity values\n  inspect!(@float.infinity, content=\"Infinity\")\n  inspect!(@float.neg_infinity, content=\"-Infinity\")\n\n  // Not a Number\n  inspect!(@float.not_a_number, content=\"NaN\")\n\n  // Bounds\n  inspect!(@float.max_value, content=\"3.4028234663852886e+38\")\n  inspect!(@float.min_value, content=\"-3.4028234663852886e+38\")\n  inspect!(@float.min_positive, content=\"1.1754943508222875e-38\")\n}\n```\n\n----------------------------------------\n\nTITLE: UInt16 Default Value and Hashing in MoonBit\nDESCRIPTION: Demonstrates the default value and hashing capabilities of UInt16 in MoonBit. The default value for UInt16 is 0. It shows how to retrieve the default value and how to generate a hash value using the `.hash()` method.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint16/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"UInt16 default value\" {\n  // Default value is 0\n  let a : UInt16 = 0\n  inspect!(a, content=\"0\")\n\n  // Hash support is available via .hash()\n  let value : UInt16 = 42\n  inspect!(value.hash(), content=\"42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Peeking at the First Element in MoonBit\nDESCRIPTION: Illustrates how to view the first element in the queue without removing it, using the `peek` method. This is useful for inspecting the next element to be processed without modifying the queue's structure.\nSOURCE: https://github.com/moonbitlang/core/blob/main/queue/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let queue = @queue.of([1,2,3])\n    assert_eq!(queue.peek(), Some(1))\n}\n```\n\n----------------------------------------\n\nTITLE: ASCII Character Classification in MoonBit\nDESCRIPTION: This code snippet demonstrates the usage of functions for basic ASCII character classification in MoonBit. It includes checks for ASCII characters, alphabetic characters, uppercase letters, and lowercase letters. The `inspect!` macro is used to assert the expected boolean results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/char/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"ascii classification\" {\n  // Basic ASCII checks\n  inspect!(@char.is_ascii('A'), content=\"true\")\n  inspect!(@char.is_ascii(''), content=\"false\")\n\n  // Letter classification\n  inspect!(@char.is_ascii_alphabetic('Z'), content=\"true\")\n  inspect!(@char.is_ascii_alphabetic('1'), content=\"false\")\n\n  // Case classification\n  inspect!(@char.is_ascii_uppercase('A'), content=\"true\")\n  inspect!(@char.is_ascii_uppercase('a'), content=\"false\")\n  inspect!(@char.is_ascii_lowercase('a'), content=\"true\")\n  inspect!(@char.is_ascii_lowercase('A'), content=\"false\")\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if Priority Queue is Empty in MoonBit\nDESCRIPTION: Demonstrates how to check if an immutable priority queue is empty using the `is_empty()` method.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/priority_queue/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq : @priority_queue.T[Int] = @priority_queue.new()\n  assert_eq!(pq.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Element Existence in MoonBit\nDESCRIPTION: Demonstrates how to check if an element exists in an ImmutableSet using the `contains()` method. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.of([1, 2, 3, 4])\n    assert_eq!(set.contains(1), true)\n    assert_eq!(set.contains(5), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Int16 Bitwise Operations Moonbit\nDESCRIPTION: This code snippet showcases the bitwise operations available for `Int16`, including AND, OR, and XOR. It also demonstrates left and right bit shifts.\nSOURCE: https://github.com/moonbitlang/core/blob/main/int16/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"int16 bitwise\" {\n  let a : Int16 = 0b1100\n  let b : Int16 = 0b1010\n\n  // Bitwise AND, OR, XOR\n  inspect!(a & b, content=\"8\") // 0b1000\n  inspect!(a | b, content=\"14\") // 0b1110\n  inspect!(a ^ b, content=\"6\") // 0b0110\n\n  // Bit shifts\n  let x : Int16 = 8\n  inspect!(x << 1, content=\"16\") // Left shift\n  inspect!(x >> 1, content=\"4\") // Right shift\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Priority Queue in MoonBit\nDESCRIPTION: Demonstrates how to create a copy of a priority queue using the `copy()` method in MoonBit. The new priority queue will contain the same elements as the original.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([1, 2, 3])\n  let _pq2 = pq.copy()\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Inspection in MoonBit\nDESCRIPTION: This snippet shows how to use `@json.inspect!()` for JSON-based snapshot testing in MoonBit. This is an alternative to the standard `inspect!()` when the `ToJson` representation is preferred for debugging, especially with deeply nested data structures. The example demonstrates inspecting simple JSON values, null values, and boolean values.\nSOURCE: https://github.com/moonbitlang/core/blob/main/json/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"json inspection\" {\n  let null = Null\n\n  // Simple json values\n  let json_value : Json = { \"key\": \"value\", \"numbers\": [1, 2, 3] }\n  @json.inspect!(json_value, content={ \"key\": \"value\", \"numbers\": [1, 2, 3] })\n\n  // Null and boolean values\n  let json_special = { \"null\": null, \"bool\": true }\n  @json.inspect!(json_special, content={ \"null\": null, \"bool\": true })\n}\n```\n\n----------------------------------------\n\nTITLE: Folding Values in Map MoonBit\nDESCRIPTION: Demonstrates how to fold the values in a sorted map using `fold()`, `foldl_with_key()`, and `foldr_with_key()`. The `fold()` function folds the values in pre-order, while `foldl_with_key()` and `foldr_with_key()` allow accessing the key during the fold operation.  `foldl_with_key` folds from left to right and `foldr_with_key` folds from right to left.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  assert_eq!(map.fold(fn (acc, v) { acc + v }, init=0), 6) // 6\n  assert_eq!(map.foldl_with_key(fn (acc, k, v) { acc + k + v.to_string() }, init=\"\"), \"a1b2c3\") // \"a1b2c3\"\n  assert_eq!(map.foldr_with_key(fn (acc, k, v) { acc + k + v.to_string() }, init=\"\"), \"c3b2a1\") // \"c3b2a1\"\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if a MoonBit SortedMap is Empty\nDESCRIPTION: Demonstrates how to check if the map is empty using the `is_empty` method. Shows instantiation of an empty map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map : @sorted_map.T[Int, String] = @sorted_map.new()\n  assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: UInt to Int64 Conversion in MoonBit\nDESCRIPTION: This code snippet demonstrates converting a `UInt` to an `Int64` using the `@uint.to_int64()` function in MoonBit. It tests the conversion with both a small number (42) and the maximum `UInt` value (4294967295) to ensure that the conversion handles the full range of `UInt` values correctly. The resulting `Int64` values are inspected to verify their accuracy.\nSOURCE: https://github.com/moonbitlang/core/blob/main/uint/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"uint type conversion\" {\n  let num = 42U\n  inspect!(@uint.to_int64(num), content=\"42\")\n  let large_num = 4294967295U // max value\n  inspect!(@uint.to_int64(large_num), content=\"4294967295\")\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Priority Queue in MoonBit\nDESCRIPTION: Shows how to clear all elements from a priority queue using the `clear()` method in MoonBit. After clearing, the queue is empty, as verified by `is_empty()`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/priority_queue/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq = @priority_queue.of([1, 2, 3, 4, 5])\n  pq.clear()\n  assert_eq!(pq.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap Clear Operation in MoonBit\nDESCRIPTION: Shows how to remove all key-value pairs from a HashMap using the `clear()` function. The example creates a HashMap, clears it, and then verifies that it is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n   let map = @hashmap.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n    map.clear()\n    assert_eq!(map.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Immutable Hashmap Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates the basic usage of an immutable hashmap in MoonBit. It creates a new hashmap, adds key-value pairs, and then retrieves values using the `find` method. The `assert_eq!` macro is used to verify the correctness of the operations.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/hashmap/README.mbt.md#_snippet_0\n\nLANGUAGE: MoonBit\nCODE:\n```\ntest {\n  let map =\n    @hashmap.new()\n      .add(\"a\", 1)\n      .add(\"b\", 2)\n      .add(\"c\", 3)\n  assert_eq!(map.find(\"a\"), Some(1))\n  assert_eq!(map.find(\"d\"), None)\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Deques in MoonBit\nDESCRIPTION: Illustrates how to compare two deques for equality using `op_equal`.  This compares the elements within the deques.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dqa = @deque.of([1, 2, 3, 4, 5])\n  let dqb = @deque.of([1, 2, 3, 4, 5])\n  assert_eq!(dqa, dqb)\n}\n```\n\n----------------------------------------\n\nTITLE: Special Character Classification in MoonBit\nDESCRIPTION: This snippet showcases functions for classifying special characters in MoonBit, including whitespace, control characters, graphic characters, and punctuation. The `inspect!` macro ensures the correctness of the classification.\nSOURCE: https://github.com/moonbitlang/core/blob/main/char/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"special characters\" {\n  // Whitespace characters\n  inspect!(@char.is_ascii_whitespace(' '), content=\"true\")\n  inspect!(@char.is_whitespace('\\n'), content=\"true\")\n\n  // Control characters\n  inspect!(@char.is_ascii_control('\\u0000'), content=\"true\")\n  inspect!(@char.is_control('\\u007F'), content=\"true\")\n\n  // Graphic and punctuation characters\n  inspect!(@char.is_ascii_graphic('!'), content=\"true\")\n  inspect!(@char.is_ascii_graphic(' '), content=\"false\")\n  inspect!(@char.is_ascii_punctuation(','), content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Method Style Calls in MoonBit\nDESCRIPTION: This snippet demonstrates how to invoke functions in MoonBit's float package using method style. It shows how to call `floor`, `ceil`, `round`, and `pow` methods directly on a float value. The inspect! macro confirms the results.\nSOURCE: https://github.com/moonbitlang/core/blob/main/float/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"method style calls\" {\n  let x : Float = 3.14\n  inspect!(x.floor(), content=\"3\")\n  inspect!(x.ceil(), content=\"4\")\n  inspect!(x.round(), content=\"3\")\n  let y : Float = 2.0\n  inspect!(y.pow(3.0), content=\"8\")\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Construction MoonBit\nDESCRIPTION: Demonstrates how to construct `Unit` values in MoonBit, both with the literal `()` and the `default()` function.  It verifies that any two `Unit` values are equal.\nSOURCE: https://github.com/moonbitlang/core/blob/main/unit/README.mbt.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"unit construction\" {\n  let u1 = ()\n  let u2 = @unit.default()\n  // Any two unit values are equal\n  inspect!(u1 == u2, content=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Sorted Set to String in Moonbit\nDESCRIPTION: This snippet demonstrates how to convert a Sorted Set to a string representation in Moonbit using the `to_string` method. This uses the Show trait implementation.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.from_array([1, 2, 3])\n    assert_eq!(set.to_string(), \"@sorted_set.of([1, 2, 3])\")\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Option operations using `bind` method in MoonBit\nDESCRIPTION: Explains how to chain multiple operations that return `Option` using the `bind` method. It applies a function that returns an `Option` to the value if the original Option is `Some`, otherwise it returns `None`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/option/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let some: Int? = Some(42)\n  let new_some = some.bind(fn(value: Int) -> Int? { Some(value + 1) }) // Some(43)\n  assert_eq!(new_some, Some(43))\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Elements in Moonbit\nDESCRIPTION: This snippet showcases how to iterate over the elements of a Sorted Set in Moonbit using the `each` method. The example adds each element to an array and asserts that the array contains all the elements in the original set.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let arr = []\n    @sorted_set.from_array([1, 2, 3, 4]).each(fn(v) { arr.push(v) })\n    assert_eq!(arr, [1, 2, 3, 4])\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Built-in Types\nDESCRIPTION: Demonstrates how to generate random values for various built-in MoonBit types using `@quickcheck.gen()`. Covers basic types like `Bool`, `Char`, and `Byte`, numeric types like `Int`, `Int64`, `UInt`, `UInt64`, `Float`, `Double`, and `BigInt`, and collections like `String`, `Bytes`, and `Iter[Int]`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/quickcheck/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"builtin types\" {\n  // Basic types\n  let _b : Bool = @quickcheck.gen()\n  let _c : Char = @quickcheck.gen()\n  let _byte : Byte = @quickcheck.gen()\n\n  // Numeric types\n  let _i : Int = @quickcheck.gen()\n  let _i64 : Int64 = @quickcheck.gen()\n  let _ui : UInt = @quickcheck.gen()\n  let _ui64 : UInt64 = @quickcheck.gen()\n  let _f : Float = @quickcheck.gen()\n  let _d : Double = @quickcheck.gen()\n  let _bi : BigInt = @quickcheck.gen()\n\n  // Collections\n  let _s : String = @quickcheck.gen()\n  let _bs : Bytes = @quickcheck.gen()\n  let _it : Iter[Int] = @quickcheck.gen()\n\n}\n```\n\n----------------------------------------\n\nTITLE: Deque Length and Capacity in MoonBit\nDESCRIPTION: Illustrates how to retrieve the length and capacity of a deque using the `length()` and `capacity()` methods, respectively.  Also demonstrates how to check if a deque is empty using `is_empty()`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n   let dv = @deque.of([1, 2, 3, 4, 5])\n   assert_eq!(dv.length(), 5)\n   assert_eq!(dv.capacity(), 5)\n}\n\ntest {\n   let dv : @deque.T[Int] = @deque.new()\n   assert_eq!(dv.is_empty(), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating with `iter` in MoonBit SortedMap\nDESCRIPTION: Shows how to obtain an iterator over key-value pairs using the `iter` method, then converts the iterator to an array.  This gives an ordered array of tuples.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(3, \"three\"), (1, \"one\"), (2, \"two\")])\n  let pairs = map.iter().to_array()\n  assert_eq!(pairs, [(1, \"one\"), (2, \"two\"), (3, \"three\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Reversing Lists Moonbit\nDESCRIPTION: Demonstrates reversing the order of elements in a list using the `rev()` method. The `rev()` method returns a new list with the elements in reverse order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/list/README.mbt.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let list = @list.of([1, 2, 3, 4, 5])\n  assert_eq!(list.rev().to_array(), [5, 4, 3, 2, 1])\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through a Moonbit Map\nDESCRIPTION: Demonstrates how to iterate through all key-value pairs in a Moonbit Map using `each` and `eachi`, preserving insertion order.\nSOURCE: https://github.com/moonbitlang/core/blob/main/builtin/LinkedHashMap.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = { \"a\": 1, \"b\": 2, \"c\": 3 }\n    let arr = []\n    map.each(fn(k, v) { arr.push((k, v)) })\n    assert_eq!(arr, [(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n    let arr2 = []\n    map.eachi(fn(i, k, v) { arr2.push((i, k, v)) })\n    assert_eq!(arr2, [(0, \"a\", 1), (1, \"b\", 2), (2, \"c\", 3)])\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating with `iter2` in MoonBit SortedMap\nDESCRIPTION: Illustrates how to use the `iter2` method for a convenient key-value iteration.  Transformes key-value pairs into strings and then pushes the strings to a list.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.from_array([(3, \"three\"), (1, \"one\"), (2, \"two\")])\n  let transformed = []\n  map.iter2().each(fn(k, v) { transformed.push(k.to_string() + \": \" + v) })\n  assert_eq!(transformed, [\"1: one\", \"2: two\", \"3: three\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Test MoonBit changes (bash)\nDESCRIPTION: These commands are used to test the changes made to the MoonBit codebase. `moon check` performs static analysis, `moon test` runs the unit tests, `moon fmt` formats the code, `moon bundle` creates a bundle, and `moon info` generates mbti files.\nSOURCE: https://github.com/moonbitlang/core/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmoon check\nmoon test\nmoon fmt\nmoon bundle\nmoon info // Generate mbti files, these files should be tracked by git\n```\n\n----------------------------------------\n\nTITLE: Array Views in MoonBit\nDESCRIPTION: Illustrates the usage of array views in MoonBit, which provide a lightweight way to work with array slices. It shows how to create a view of an array, map the view to a new array using `map`, and modify the view in-place using `map_inplace`. The effects of in-place modification on the original array are highlighted.\nSOURCE: https://github.com/moonbitlang/core/blob/main/array/README.mbt.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"array views\" {\n  let arr = [1, 2, 3, 4, 5]\n  let view = arr[1:4] // View of elements 1,2,3\n\n  // Map view to new array\n  let doubled = view.map(fn(x) { x * 2 })\n\n  // Modify view in-place\n  view.map_inplace(fn(x) { x + 1 })\n  inspect!(doubled, content=\"[4, 6, 8]\")\n  inspect!(arr, content=\"[1, 3, 4, 5, 5]\")\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Map Elements MoonBit\nDESCRIPTION: Shows how to iterate through all key-value pairs in a sorted map using the `each()` and `eachi()` functions. The `each()` function iterates through the key-value pairs, while `eachi()` provides the index as well.  The code appends formatted strings into an array within each iteration and asserts the array matches the expected output.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_map/README.mbt.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @sorted_map.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let arr = []\n  map.each(fn(k, v) { arr.push(\"key:\\{k}, value:\\{v}\") })\n  assert_eq!(arr, [\"key:a, value:1\", \"key:b, value:2\", \"key:c, value:3\"])\n  let arr = []\n  map.eachi(fn(i, k, v) { arr.push(\"index:\\{i}, key:\\{k}, value:\\{v}\") })\n  assert_eq!(arr, [\"index:0, key:a, value:1\", \"index:1, key:b, value:2\", \"index:2, key:c, value:3\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Remove existing core library (bash)\nDESCRIPTION: This command removes the existing moonbitlang/core library from the default location. This is necessary to ensure that you are working with a clean copy when cloning the repository.\nSOURCE: https://github.com/moonbitlang/core/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf ~/.moon/lib/core\n```\n\n----------------------------------------\n\nTITLE: HashMap Iterator in MoonBit\nDESCRIPTION: Shows how to obtain an iterator for a HashMap using the `iter()` function. The resulting iterator can be used to traverse the key-value pairs in the map.\nSOURCE: https://github.com/moonbitlang/core/blob/main/hashmap/README.mbt.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let map = @hashmap.of([(\"a\", 1), (\"b\", 2), (\"c\", 3)])\n  let _iter = map.iter()\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Size of Sorted Set in Moonbit\nDESCRIPTION: This snippet shows how to retrieve the number of elements in a Sorted Set using the `size` method in Moonbit.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_set/README.mbt.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set = @sorted_set.from_array([1, 2, 3, 4])\n    assert_eq!(set.size(), 4)\n}\n```\n\n----------------------------------------\n\nTITLE: Buffer Conversion in MoonBit\nDESCRIPTION: This snippet demonstrates converting a buffer's content to bytes in MoonBit. It creates a new buffer, writes three bytes ('a', 'b', 'c') to it, and then converts the buffer's contents to a byte array using the `to_bytes()` method. Finally, the byte array is compared with the expected value using `inspect!` to verify that the conversion was successful.\nSOURCE: https://github.com/moonbitlang/core/blob/main/buffer/README.mbt.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"buffer conversion\" {\n  let buf = @buffer.new()\n  buf.write_byte(b'a')\n  buf.write_byte(b'b')\n  buf.write_byte(b'c')\n  let bytes = buf.to_bytes()\n  inspect!(\n    bytes,\n    content=\n      #|b\"\\x61\\x62\\x63\"\n    ,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Edge Cases for Range Operations in MoonBit SortedMap\nDESCRIPTION: Demonstrates edge cases for range operations, including out-of-bounds ranges and invalid ranges (low > high). Shows how the `range` method handles these cases by returning an empty result or a subset within valid bounds.\nSOURCE: https://github.com/moonbitlang/core/blob/main/sorted_map/README.mbt.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\n// Example with out-of-bounds range\ntest {\n  let map = @sorted_map.from_array([(1, \"one\"), (2, \"two\"), (3, \"three\")])\n  let range_items = []\n  map.range(0, 10).each(fn(k, v) { range_items.push((k, v)) })\n  assert_eq!(range_items, [(1, \"one\"), (2, \"two\"), (3, \"three\")])\n\n  // Example with invalid range\n  let empty_range : Array[(Int, String)] = []\n  map.range(10, 5).each(fn(k, v) { empty_range.push((k, v)) })\n  assert_eq!(empty_range, [])\n}\n```\n\n----------------------------------------\n\nTITLE: Rational String Operations in MoonBit\nDESCRIPTION: This snippet demonstrates converting a `Rational` number to its string representation using the `to_string()` method in MoonBit. It initializes a `Rational` using `@rational.new` and checks if the string representation matches the expected value using `assert_eq!`.\nSOURCE: https://github.com/moonbitlang/core/blob/main/rational/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let a = @rational.new(1L, 2L).unwrap()\n    assert_eq!(a.to_string(), \"1/2\")\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if ImmutableSet is Empty in MoonBit\nDESCRIPTION: Shows how to check if an ImmutableSet is empty using the `is_empty()` method. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let set1 : @sorted_set.T[Int] = @sorted_set.of([])\n    assert_eq!(set1.is_empty(), true)\n    let set2 = @sorted_set.of([1])\n    assert_eq!(set2.is_empty(), false)\n}\n```\n\n----------------------------------------\n\nTITLE: Swapping Tuple Elements in MoonBit\nDESCRIPTION: This snippet demonstrates how to swap the elements of a tuple using the `swap` method in MoonBit. The `swap` method returns a new tuple with the first and second elements interchanged.\nSOURCE: https://github.com/moonbitlang/core/blob/main/tuple/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    let tuple = (1, 2)\n    let _swapped = @tuple.swap(tuple) // swapped = (2, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Subset & Disjoint Checks in MoonBit\nDESCRIPTION: Demonstrates how to check if one ImmutableSet is a subset of another and if two sets are disjoint using the `subset()` and `disjoint()` methods. Requires the `@sorted_set` module.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/sorted_set/README.mbt.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n    assert_eq!(@sorted_set.of([1, 2, 3]).subset(@sorted_set.of([7, 2, 9, 4, 5, 6, 3, 8, 1])), true)\n    assert_eq!(@sorted_set.of([1, 2, 3]).disjoint(@sorted_set.of([4, 5, 6])), true)\n}\n```\n\n----------------------------------------\n\nTITLE: Popping Elements from Front and Back in MoonBit\nDESCRIPTION: Explains how to remove elements from the front and back of a deque using `pop_front()` and `pop_back()`. These methods return an Option containing the popped value or None if the deque is empty.\nSOURCE: https://github.com/moonbitlang/core/blob/main/deque/README.mbt.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let dv = @deque.of([1, 2, 3, 4, 5])\n  let _back = dv.pop_back() // Some(5)\n  assert_eq!(dv.back(), Some(4))\n  let _front = dv.pop_front() //Some(1)\n  assert_eq!(dv.front(), Some(2))\n  assert_eq!(dv.length(), 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Elements into Priority Queue in MoonBit\nDESCRIPTION: Demonstrates how to add elements to the immutable priority queue using `push()`, which returns a new queue with the added element. The `peek()` method can then be used to verify the head element.\nSOURCE: https://github.com/moonbitlang/core/blob/main/immut/priority_queue/README.mbt.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let pq : @priority_queue.T[Int] = @priority_queue.new()\n  assert_eq!(pq.push(1).peek(), Some(1))\n}\n```"
  }
]