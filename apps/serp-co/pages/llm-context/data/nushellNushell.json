[
  {
    "owner": "nushell",
    "repo": "nushell",
    "content": "TITLE: Installing Nushell via Package Managers\nDESCRIPTION: Commands to install Nushell on Linux, macOS, and Windows using their respective package managers.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Linux and macOS\nbrew install nushell\n# Windows\nwinget install nushell\n```\n\n----------------------------------------\n\nTITLE: Cloning and Building Nushell in Bash\nDESCRIPTION: Commands to clone the Nushell repository from GitHub and build it using Cargo. This is the basic setup process for contributors who want to start working with the Nushell codebase.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/nushell/nushell\ncd nushell\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Exposing Commands in the Standard Library Module\nDESCRIPTION: Code to add to mod.nu to expose a new command to users through the std namespace. Shows handling for both regular commands and commands that update the environment.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_2\n\nLANGUAGE: nushell\nCODE:\n```\nexport use foo *    # command doesn't update environment\nexport-env {\n       use bar *    # command *does* update environment\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Standard Library Commands in Nushell\nDESCRIPTION: Example of selectively importing specific commands from the standard library, which allows using them without the 'std' prefix. This approach is recommended for interactive use in the env.nu configuration.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/README.md#2025-04-19_snippet_2\n\nLANGUAGE: nushell\nCODE:\n```\nuse std [\"log debug\" assert]\n\nlog debug \"Running again\"\nassert (2 == 1)\n```\n\n----------------------------------------\n\nTITLE: Error Handling Flow Description in Nushell\nDESCRIPTION: Outlines the error handling flow in Nushell, including parser errors, shell errors, and best practices for error reporting. References the miette library for error formatting and emphasizes the use of structured error handling over direct printing.\nSOURCE: https://github.com/nushell/nushell/blob/main/devdocs/FAQ.md#2025-04-19_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. Are you reporting the error in the parser/static checking phase?\n    - Use `nu_protocol::ParseError` variants\n    - Follow the logic used in the context as we need to collect multiple errors for a good IDE experience\n2. Pick the right `nu_protocol::ShellError` variant\n    - Does a matching existing variant fit your need?\n    - Check what context the [`miette`] macros add during formatting!\n    - If it is a one-of specific error, consider using a generic variant\n    - Else add a new class of errors\n        - add the necessary `Span` information\n        - general shared error text, to inform and point to a resolution\n        - dynamic information gathered from the error site\n        - Don't use a tuple enum variant, named structs going forward only!\n3. Are you in a command?\n    - `return Err(ShellError::...)` and you're done in a `Command::run`\n4. Do you want to report a warning but not stop execution?\n    - **NEVER** `println!`, we can write to stderr if necessary but...\n    - good practice: `nu_protocol::cli_error::report_error` or `report_error_new`\n        - depending on whether you have access to a `StateWorkingSet`\n    - if only relevant to in the field debugging: `log`-crate macros.\n```\n\n----------------------------------------\n\nTITLE: Locating Nushell Config Path\nDESCRIPTION: Command to find the location of the Nushell config file on your system.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n$nu.config-path\n```\n\n----------------------------------------\n\nTITLE: Installing Nushell tab completion in Zsh\nDESCRIPTION: Commands to set up tab completion for Nushell in Zsh shell. This snippet shows how to generate the completion script and integrate it with Zsh's completion system.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/[a] bc.txt#2025-04-19_snippet_1\n\nLANGUAGE: zsh\nCODE:\n```\n# Generate a completion script\nnu --tab-completion=zsh > nu_completion.zsh\n\n# source the completion script in .zshrc or equivalent\nsource /path/to/nu_completion.zsh\n```\n\n----------------------------------------\n\nTITLE: Installing Nushell tab completion in Fish\nDESCRIPTION: Commands to set up tab completion for Nushell in Fish shell. This shows how to generate and place the completion script in Fish's completions directory for automatic loading.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/[a] bc.txt#2025-04-19_snippet_2\n\nLANGUAGE: fish\nCODE:\n```\n# Generate a completion script\nnu --tab-completion=fish > ~/.config/fish/completions/nu.fish\n```\n\n----------------------------------------\n\nTITLE: Installing Nushell tab completion in Bash\nDESCRIPTION: Commands to set up tab completion for Nushell in Bash shell. This snippet shows how to generate the completion script and add it to the Bash configuration for persistent autocompletion support.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/[a] bc.txt#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Generate a completion script\nnu --tab-completion=bash > nu_completion.bash\n\n# source the completion script in .bashrc or equivalent\nsource /path/to/nu_completion.bash\n```\n\n----------------------------------------\n\nTITLE: Lite Parse Tree Structure\nDESCRIPTION: Illustrates the hierarchical pipeline structure after lite parsing, grouping commands and their arguments.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/README.md#2025-04-19_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nPipeline:\n  Command #1:\n    <item: \"head1\">, <item: \"arg1\">, <item: \"arg2\">\n  Command #2:\n    <item: \"head2\">\n```\n\n----------------------------------------\n\nTITLE: Filtering Directory Contents Pipeline\nDESCRIPTION: Example of using Nushell pipelines to list and filter directory contents to show only directories.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nls | where type == \"dir\" | table\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for Nushell Standard Library\nDESCRIPTION: Command to execute all unit tests for the Nushell standard library using the debug version of the NU interpreter. Supports different log levels: ERROR for failures only, INFO for module progress, and DEBUG for individual test details.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_3\n\nLANGUAGE: nushell\nCODE:\n```\ncargo run -- -c 'use crates/nu-std/testing.nu; testing run-tests --path crates/nu-std'\n```\n\n----------------------------------------\n\nTITLE: Running Nushell with Cargo\nDESCRIPTION: Command to build and run Nushell directly using Cargo. This is useful during development to test changes immediately.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_1\n\nLANGUAGE: nushell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested TOML Data\nDESCRIPTION: Example of accessing a specific section of a TOML file using the get command.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nopen Cargo.toml | get package\n```\n\n----------------------------------------\n\nTITLE: Listing Standard Library Commands in Nushell\nDESCRIPTION: A command to display available standard library commands by using the scope command to filter and display all commands that start with 'std'.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/README.md#2025-04-19_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n> use std\n> scope commands | select name description | where name =~ \"std \"\n```\n\n----------------------------------------\n\nTITLE: Accessing Deep Nested TOML Value\nDESCRIPTION: Demonstration of accessing a deeply nested value in a TOML file structure.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nopen Cargo.toml | get package.version\n```\n\n----------------------------------------\n\nTITLE: Installing Nushell Plugin\nDESCRIPTION: Commands to register and activate a Nushell plugin in the development environment. The plugin needs to be added and then activated in the current session.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_example/README.md#2025-04-19_snippet_0\n\nLANGUAGE: nushell\nCODE:\n```\nplugin add target/debug/nu_plugin_example\n# or then either restart your current nushell session or run:\nplugin use target/debug/nu_plugin_example\n```\n\n----------------------------------------\n\nTITLE: Opening and Viewing TOML File\nDESCRIPTION: Command to open and display the structured contents of a TOML file.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nopen Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Importing and Using the Entire Standard Library in Nushell\nDESCRIPTION: Example of importing the entire standard library module and using commands with the 'std' prefix. This approach requires prefixing all standard library commands with 'std' when invoking them.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/README.md#2025-04-19_snippet_1\n\nLANGUAGE: nushell\nCODE:\n```\nuse std\n\nstd log debug \"Running now\"\nstd assert (1 == 2)\n```\n\n----------------------------------------\n\nTITLE: Process Filtering Pipeline\nDESCRIPTION: Example of filtering system processes to show only those with CPU usage greater than 0.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nps | where cpu > 0\n```\n\n----------------------------------------\n\nTITLE: Configuring Nushell Environment and Aliases\nDESCRIPTION: This snippet sets up the Nushell environment, including color schemes, prompt customization, and custom aliases. It defines various utility commands and shortcuts for improved productivity.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/te'st.txt#2025-04-19_snippet_0\n\nLANGUAGE: nushell\nCODE:\n```\n# Nushell Config File\n\nmodule completions {\n  # Custom completions for external commands (those outside of Nushell)\n  # Each completions has two parts: the form of the external command, including its flags and parameters\n  # and a helper command that knows how to generate completions given the form of the external command.\n  extern \"git checkout\" []\n  extern \"git push\" []\n  extern \"git pull\" []\n  extern \"git add\" []\n  extern \"i3-msg\" []\n}\n\n# Get just the extern definitions without the custom completion commands\nuse completions *\n\n# for more information on themes see\n# https://github.com/nushell/nushell/blob/main/docs/How_To_Coloring_and_Theming.md\nlet default_theme = {\n    # color for nushell primitives\n    separator: white\n    leading_trailing_space_bg: { attr: n } # no fg, no bg, attr none effectively turns this off\n    header: green_bold\n    empty: blue\n    # Closures can be used to choose colors for specific values.\n    # The value (in this case, a bool) is piped into the closure.\n    bool: { if $in { 'light_cyan' } else { 'light_gray' } }\n    int: white\n    filesize: {|e|\n      if $e == 0b {\n        'white'\n      } else if $e < 1mb {\n        'cyan'\n      } else { 'blue' }\n    }\n    duration: white\n    date: { (date now) - $in |>\n      if $in < 1hr {\n        'purple'\n      } else if $in < 6hr {\n        'red'\n      } else if $in < 1day {\n        'yellow'\n      } else if $in < 3day {\n        'green'\n      } else if $in < 1wk {\n        'light_green'\n      } else if $in < 6wk {\n        'cyan'\n      } else if $in < 52wk {\n        'blue'\n      } else { 'dark_gray' }\n    }\n    range: white\n    float: white\n    string: white\n    nothing: white\n    binary: white\n    cellpath: white\n    row_index: green_bold\n    record: white\n    list: white\n    block: white\n    hints: dark_gray\n\n    shape_and: purple_bold\n    shape_binary: purple_bold\n    shape_block: blue_bold\n    shape_bool: light_cyan\n    shape_closure: green_bold\n    shape_custom: green\n    shape_datetime: cyan_bold\n    shape_directory: cyan\n    shape_external: cyan\n    shape_externalarg: green_bold\n    shape_filepath: cyan\n    shape_flag: blue_bold\n    shape_float: purple_bold\n    # shapes are used to change the cli syntax highlighting\n    shape_garbage: { fg: white bg: red attr: b}\n    shape_globpattern: cyan_bold\n    shape_int: purple_bold\n    shape_internalcall: cyan_bold\n    shape_list: cyan_bold\n    shape_literal: blue\n    shape_match_pattern: green\n    shape_matching_brackets: { attr: u }\n    shape_nothing: light_cyan\n    shape_operator: yellow\n    shape_or: purple_bold\n    shape_pipe: purple_bold\n    shape_range: yellow_bold\n    shape_record: cyan_bold\n    shape_redirection: purple_bold\n    shape_signature: green_bold\n    shape_string: green\n    shape_string_interpolation: cyan_bold\n    shape_table: blue_bold\n    shape_variable: purple\n}\n\n# The default config record. This is where much of your global configuration is setup.\n$env.config = {\n  ls: {\n    use_ls_colors: true # use the LS_COLORS environment variable to colorize output\n    clickable_links: true # enable or disable clickable links. Your terminal has to support links.\n  }\n  rm: {\n    always_trash: false # always act as if -t was given. Can be overridden with -p\n  }\n  cd: {\n    abbreviations: false # allows `cd s/o/f` to expand to `cd some/other/folder`\n  }\n  table: {\n    mode: rounded # basic, compact, compact_double, light, thin, with_love, rounded, reinforced, heavy, none, other\n    index_mode: always # \"always\" show indexes, \"never\" show indexes, \"auto\" = show indexes when a table has \"index\" column\n    trim: {\n      methodology: wrapping # wrapping or truncating\n      wrapping_try_keep_words: true # A strategy used by the 'wrapping' methodology\n      truncating_suffix: \"...\" # A suffix used by the 'truncating' methodology\n    }\n  }\n\n  explore: {\n    help_banner: true\n    exit_esc: true\n\n    command_bar_text: '#C4C9C6'\n    # command_bar: {fg: '#C4C9C6' bg: '#223311' }\n\n    status_bar_background: {fg: '#1D1F21' bg: '#C4C9C6' }\n    # status_bar_text: {fg: '#C4C9C6' bg: '#223311' }\n\n    highlight: {bg: 'yellow' fg: 'black' }\n\n    status: {\n      # warn: {bg: 'yellow', fg: 'blue'}\n      # error: {bg: 'yellow', fg: 'blue'}\n      # info: {bg: 'yellow', fg: 'blue'}\n    }\n\n    try: {\n      # border_color: 'red'\n      # highlighted_color: 'blue'\n\n      # reactive: false\n    }\n\n    table: {\n      split_line: '#404040'\n\n      cursor: true\n\n      line_index: true\n      line_shift: true\n      line_head_top: true\n      line_head_bottom: true\n\n      show_head: true\n      show_index: true\n\n      # selected_cell: {fg: 'white', bg: '#777777'}\n      # selected_row: {fg: 'yellow', bg: '#C1C2A3'}\n      # selected_column: blue\n\n      # padding_column_right: 2\n      # padding_column_left: 2\n\n      # padding_index_left: 2\n      # padding_index_right: 1\n    }\n\n    config: {\n      cursor_color: {bg: 'yellow' fg: 'black' }\n\n      # border_color: white\n      # list_color: green\n    }\n  }\n\n  history: {\n    max_size: 10000 # Session has to be reloaded for this to take effect\n    sync_on_enter: true # Enable to share history between multiple sessions, else you have to close the session to write history to file\n    file_format: \"plaintext\" # \"sqlite\" or \"plaintext\"\n  }\n  completions: {\n    case_sensitive: false # set to true to enable case-sensitive completions\n    quick: true  # set this to false to prevent auto-selecting completions when only one remains\n    partial: true  # set this to false to prevent partial filling of the prompt\n    algorithm: \"prefix\"  # prefix or fuzzy\n    external: {\n      enable: true # set to false to prevent nushell looking into $env.PATH to find more suggestions, `false` recommended for WSL users as this look up my be very slow\n      max_results: 100 # setting it lower can improve completion performance at the cost of omitting some options\n      completer: null # check 'carapace_completer' above as an example\n    }\n  }\n  filesize: {\n    metric: true # true => KB, MB, GB (ISO standard), false => KiB, MiB, GiB (Windows standard)\n    format: \"auto\" # b, kb, kib, mb, mib, gb, gib, tb, tib, pb, pib, eb, eib, zb, zib, auto\n  }\n  cursor_shape: {\n    emacs: line # block, underscore, line (line is the default)\n    vi_insert: block # block, underscore, line (block is the default)\n    vi_normal: underscore # block, underscore, line  (underscore is the default)\n  }\n  color_config: $default_theme   # if you want a light theme, replace `$default_theme` to `$light_theme`\n  use_grid_icons: true\n  footer_mode: \"25\" # always, never, number_of_rows, auto\n  float_precision: 2\n  # buffer_editor: \"emacs\" # command that will be used to edit the current line buffer with ctrl+o, if unset fallback to $env.EDITOR and $env.VISUAL\n  use_ansi_coloring: true\n  edit_mode: emacs # emacs, vi\n  shell_integration: true # enables terminal markers and a workaround to arrow keys stop working issue\n  show_banner: true # true or false to enable or disable the banner\n  render_right_prompt_on_last_line: false # true or false to enable or disable right prompt to be rendered on last line of the prompt.\n\n  hooks: {\n    pre_prompt: [{||null}] # run before the prompt is shown\n    pre_execution: [{||null}] # run before the repl input is run\n    env_change: {\n      PWD: [{|before, after| null }] # run if the PWD environment is different since the last repl input\n    }\n    display_output: {\n      if (term size).columns >= 100 { table -e } else { table }\n    }\n  }\n  menus: [\n      # Configuration for default nushell menus\n      # Note the lack of source parameter\n      {\n        name: completion_menu\n        only_buffer_difference: false\n        marker: \"| \"\n        type: {layout: columnar}\n        style: {\n          text: green\n          selected_text: green_reverse\n          description_text: yellow\n        }\n      }\n      {\n        name: history_menu\n        only_buffer_difference: true\n        marker: \"? \"\n        type: {layout: list, page_size: 10}\n        style: {\n          text: green\n          selected_text: green_reverse\n          description_text: yellow\n        }\n      }\n      {\n        name: help_menu\n        only_buffer_difference: true\n        marker: \"? \"\n        type: {layout: description, columns: 4, col_width: 20   }\n        style: {\n          text: green\n          selected_text: green_reverse\n          description_text: yellow\n        }\n      }\n      # Example of extra menus created using a nushell source\n      # Use the source field to create a list of records that populates\n      # the menu\n      {\n        name: commands_menu\n        only_buffer_difference: false\n        marker: \"# \"\n        type: {layout: columnar}\n        style: {\n          text: green\n          selected_text: green_reverse\n          description_text: yellow\n        }\n        source: { |buffer, position|\n            $nu.scope.commands\n            | where name =~ $buffer\n            | each { |it| {value: $it.name description: $it.usage} }\n        }\n      }\n      {\n        name: vars_menu\n        only_buffer_difference: true\n        marker: \"# \"\n        type: {layout: list, page_size: 10}\n        style: {\n          text: green\n          selected_text: green_reverse\n          description_text: yellow\n        }\n        source: { |buffer, position|\n            $nu.scope.vars\n            | where name =~ $buffer\n            | sort-by name\n            | each { |it| {value: $it.name description: $it.type} }\n        }\n      }\n      {\n        name: commands_with_description\n        only_buffer_difference: true\n        marker: \"# \"\n        type: {layout: description, columns: 4, col_width: 20   }\n        style: {\n          text: green\n          selected_text: green_reverse\n          description_text: yellow\n        }\n        source: { |buffer, position|\n            $nu.scope.commands\n            | where name =~ $buffer\n            | each { |it| {value: $it.name description: $it.usage} }\n        }\n      }\n  ]\n  keybindings: [\n    {\n      name: completion_menu\n      modifier: none\n      keycode: tab\n      mode: [emacs vi_normal vi_insert]\n      event: {\n        until: [\n          { send: menu name: completion_menu }\n          { send: menunext }\n        ]\n      }\n    }\n    {\n      name: completion_previous\n      modifier: shift\n      keycode: backtab\n      mode: [emacs, vi_normal, vi_insert] # Note: You can add the same keybinding to all modes by using a list\n      event: { send: menuprevious }\n    }\n    {\n      name: history_menu\n      modifier: control\n      keycode: char_r\n      mode: emacs\n      event: { send: menu name: history_menu }\n    }\n    {\n      name: next_page\n      modifier: control\n      keycode: char_x\n      mode: emacs\n      event: { send: menupagenext }\n    }\n    {\n      name: undo_or_previous_page\n      modifier: control\n      keycode: char_z\n      mode: emacs\n      event: {\n        until: [\n          { send: menupageprevious }\n          { edit: undo }\n        ]\n       }\n    }\n    {\n      name: yank\n      modifier: control\n      keycode: char_y\n      mode: emacs\n      event: {\n        until: [\n          {edit: pastecutbufferafter}\n        ]\n      }\n    }\n    {\n      name: unix-line-discard\n      modifier: control\n      keycode: char_u\n      mode: [emacs, vi_normal, vi_insert]\n      event: {\n        until: [\n          {edit: cutfromlinestart}\n        ]\n      }\n    }\n    {\n      name: kill-line\n      modifier: control\n      keycode: char_k\n      mode: [emacs, vi_normal, vi_insert]\n      event: {\n        until: [\n          {edit: cuttolineend}\n        ]\n      }\n    }\n    # Keybindings used to trigger the user defined menus\n    {\n      name: commands_menu\n      modifier: control\n      keycode: char_t\n      mode: [emacs, vi_normal, vi_insert]\n      event: { send: menu name: commands_menu }\n    }\n    {\n      name: vars_menu\n      modifier: alt\n      keycode: char_o\n      mode: [emacs, vi_normal, vi_insert]\n      event: { send: menu name: vars_menu }\n    }\n    {\n      name: commands_with_description\n      modifier: control\n      keycode: char_s\n      mode: [emacs, vi_normal, vi_insert]\n      event: { send: menu name: commands_with_description }\n    }\n  ]\n}\n\nalias gc = git checkout\nalias gl = git log\nalias gf = git fetch\nalias gp = git push\nalias gpl = git pull\nalias gb = git branch\nalias ga = git add\nalias gs = git status\nalias gd = git diff\nalias gm = git merge\nalias hx = helix\n```\n\n----------------------------------------\n\nTITLE: Running Custom Commands with Logging in Nushell\nDESCRIPTION: Commands demonstrating how to run custom commands with different logging levels (INFO for verbose, DEBUG for very verbose) using environment variables.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_5\n\nLANGUAGE: nushell\nCODE:\n```\nNU_LOG_LEVEL=INFO std foo bar bas # verbose\nNU_LOG_LEVEL=DEBUG std foo bar bas # very verbose\n```\n\n----------------------------------------\n\nTITLE: Setting Up Git Hooks for Quality Checks\nDESCRIPTION: Command to set up Git hooks that run formatting and linting checks before committing and pushing changes. This helps catch issues early in the development process.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_7\n\nLANGUAGE: nushell\nCODE:\n```\nuse toolkit.nu setup-git-hooks\nsetup-git-hooks\n```\n\n----------------------------------------\n\nTITLE: Formatting Nushell Code\nDESCRIPTION: Commands to automatically format all code in the Nushell project according to the project's style guidelines. This ensures consistent formatting across the codebase.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_6\n\nLANGUAGE: nushell\nCODE:\n```\ncargo fmt --all\n```\n\nLANGUAGE: nushell\nCODE:\n```\nuse toolkit.nu fmt\nfmt\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stream Processing with `ls` and `where` in Nushell\nDESCRIPTION: This example shows how Nushell processes streams efficiently, where the 'ls' command outputs a stream that's filtered by 'where' in a lazy fashion, without having to load all files into memory first.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/partial_completions/partial/hello.txt#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nls | where size > 10kb\n```\n\n----------------------------------------\n\nTITLE: Lexical Analysis Token Output\nDESCRIPTION: Shows the token structure after lexical analysis phase, breaking down command and arguments into discrete tokens.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/README.md#2025-04-19_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n<item: \"head1\">, <item: \"arg1\">, <item: \"arg2\">, <pipe>, <item: \"head2\">\n```\n\n----------------------------------------\n\nTITLE: Illustrating Pipeline Data Flow in Nushell with Multiple Commands\nDESCRIPTION: This example demonstrates a more complex pipeline in Nushell, showing how data flows through multiple transformations including filtering by size, name pattern matching, and sorting before limiting results.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/partial_completions/partial/hello.txt#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nls | where size > 10kb | where name =~ .rs | sort-by size | first 5\n```\n\n----------------------------------------\n\nTITLE: Running Nushell with Verbose Logging\nDESCRIPTION: Command to run Nushell with trace-level logging enabled. This is useful for debugging and understanding the internal workings of Nushell during development.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_8\n\nLANGUAGE: nushell\nCODE:\n```\ncargo run --release -- --log-level trace\n```\n\n----------------------------------------\n\nTITLE: Installing Nushell tab completion in PowerShell\nDESCRIPTION: Commands to set up tab completion for Nushell in PowerShell. This shows how to generate the completion script and load it in PowerShell's profile for persistent autocompletion.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/[a] bc.txt#2025-04-19_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\n# Generate a completion script\nnu --tab-completion=powershell > nu_completion.ps1\n\n# Reference the script in your PowerShell profile\n. /path/to/nu_completion.ps1\n```\n\n----------------------------------------\n\nTITLE: Simplified Directory Listing Pipeline\nDESCRIPTION: Shortened version of the directory listing command, demonstrating implicit table output.\nSOURCE: https://github.com/nushell/nushell/blob/main/README.md#2025-04-19_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nls | where type == \"dir\"\n```\n\n----------------------------------------\n\nTITLE: Adding nu_plugin_formats to Nushell\nDESCRIPTION: This command adds the compiled nu_plugin_formats binary to Nushell. It assumes the plugin is compiled in the ./target/debug/ directory.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_formats/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nplugin add ./target/debug/nu_plugin_formats\n```\n\n----------------------------------------\n\nTITLE: Committing SQLite Transaction in Rust for NuShell\nDESCRIPTION: This function commits a SQLite transaction. It returns a NuShell Value indicating success or an error if the commit fails.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/semicolon_;.txt#2025-04-19_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\npub fn commit_transaction(conn: &Connection) -> Result<Value, ShellError> {\n    conn.commit().map_err(|err| {\n        ShellError::GenericError(\n            \"Failed to commit transaction\".into(),\n            err.to_string(),\n            Some(Span::unknown()),\n            None,\n            Vec::new(),\n        )\n    })?;\n\n    Ok(Value::String {\n        val: \"Transaction committed successfully\".into(),\n        span: Span::unknown(),\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Command for Detecting Source Code Language in Nushell\nDESCRIPTION: This snippet defines a custom Nushell command 'detect-lang' that takes a file path as input and attempts to determine the programming language of the file. It uses a combination of file extension matching and content analysis.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/curly-bracket_{.txt#2025-04-19_snippet_0\n\nLANGUAGE: Nushell\nCODE:\n```\ndef detect-lang [file: path] {\n    let ext = $file | path parse | get extension\n    let content = (open $file | first 1000 | str collect)\n    let lang = match $ext {\n        \"rs\" => \"Rust\",\n        \"py\" => \"Python\",\n        \"js\" => \"JavaScript\",\n        \"ts\" => \"TypeScript\",\n        \"html\" => \"HTML\",\n        \"css\" => \"CSS\",\n        \"md\" => \"Markdown\",\n        \"json\" => \"JSON\",\n        \"yaml\" | \"yml\" => \"YAML\",\n        \"toml\" => \"TOML\",\n        \"sh\" => \"Shell\",\n        _ => if ($content | str contains \"<?php\") {\n                \"PHP\"\n            } else if ($content | str contains \"<html>\") {\n                \"HTML\"\n            } else if ($content | str contains \"import\") {\n                \"Python\"\n            } else if ($content | str contains \"function\") {\n                \"JavaScript\"\n            } else if ($content | str contains \"fn \") {\n                \"Rust\"\n            } else {\n                \"Unknown\"\n            }\n    }\n    $lang\n}\n```\n\n----------------------------------------\n\nTITLE: Rolling Back SQLite Transaction in Rust for NuShell\nDESCRIPTION: This function rolls back a SQLite transaction. It returns a NuShell Value indicating success or an error if the rollback fails.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/semicolon_;.txt#2025-04-19_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\npub fn rollback_transaction(conn: &Connection) -> Result<Value, ShellError> {\n    conn.rollback().map_err(|err| {\n        ShellError::GenericError(\n            \"Failed to rollback transaction\".into(),\n            err.to_string(),\n            Some(Span::unknown()),\n            None,\n            Vec::new(),\n        )\n    })?;\n\n    Ok(Value::String {\n        val: \"Transaction rolled back successfully\".into(),\n        span: Span::unknown(),\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for a Specific Command\nDESCRIPTION: Command to run tests for a specific Nushell command. This is useful when making changes to a particular command and wanting to verify only that functionality.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_4\n\nLANGUAGE: nushell\nCODE:\n```\ncargo test --package nu-cli --test main -- commands::<command_name_here>\n```\n\n----------------------------------------\n\nTITLE: Converting SQLite Value to NuShell Value in Rust\nDESCRIPTION: This function converts a SQLite value to its corresponding NuShell Value representation. It handles various data types including integers, floats, text, and binary data.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/semicolon_;.txt#2025-04-19_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn convert_sqlite_to_nu_value(value: rusqlite::types::Value) -> Value {\n    match value {\n        rusqlite::types::Value::Null => Value::Nothing { span: Span::unknown() },\n        rusqlite::types::Value::Integer(i) => Value::Int { val: i, span: Span::unknown() },\n        rusqlite::types::Value::Real(f) => Value::Float { val: f, span: Span::unknown() },\n        rusqlite::types::Value::Text(s) => Value::String {\n            val: s,\n            span: Span::unknown(),\n        },\n        rusqlite::types::Value::Blob(b) => Value::Binary {\n            val: b,\n            span: Span::unknown(),\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Specific Module in Nushell\nDESCRIPTION: Command to run tests for a specific test module in the Nushell standard library, taking the module name as a parameter.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_4\n\nLANGUAGE: nushell\nCODE:\n```\ncargo run -- -c 'use crates/nu-std/testing.nu; testing run-tests --path crates/nu-std --module test_foo'\n```\n\n----------------------------------------\n\nTITLE: Configuring Nushell Plugin Environment\nDESCRIPTION: Example configuration structure for the plugin that should be added to the Nushell environment config. The configuration is stored in the plugins.example namespace.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_example/README.md#2025-04-19_snippet_1\n\nLANGUAGE: nushell\nCODE:\n```\n$env.config = {\n  plugins: {\n    example: [\n      some\n      values\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Nushell Command Pipeline Example\nDESCRIPTION: Demonstrates the basic syntax of Nushell commands with a pipeline using whitespace-separated tokens.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/README.md#2025-04-19_snippet_0\n\nLANGUAGE: nushell\nCODE:\n```\nhead1 arg1 arg2 | head2\n```\n\n----------------------------------------\n\nTITLE: Running Clippy on Nushell Workspace\nDESCRIPTION: Commands to run Clippy linter on the entire Nushell workspace with specific warning flags. This helps maintain code quality by identifying potential issues and unwanted patterns.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_2\n\nLANGUAGE: nushell\nCODE:\n```\ncargo clippy --workspace -- -D warnings -D clippy::unwrap_used\n```\n\nLANGUAGE: nushell\nCODE:\n```\nuse toolkit.nu clippy\nclippy\n```\n\n----------------------------------------\n\nTITLE: Using nu-glob to Find JPG Files in Directories\nDESCRIPTION: Example demonstrating how to use the nu-glob crate to recursively find all JPG files within the /media/ directory and its subdirectories. The code handles the result of the glob operation and displays matching paths.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-glob/README.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse nu_nu_glob::glob;\n\nfor entry in glob(\"/media/**/*.jpg\").expect(\"Failed to read glob pattern\") {\n    match entry {\n        Ok(path) => println!(\"{:?}\", path.display()),\n        Err(e) => println!(\"{:?}\", e),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding the Query Plugin to Nushell\nDESCRIPTION: Command to add the installed Query plugin to Nushell. This needs to be run from within the Nushell environment.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_query/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n> plugin add <path to installed plugin>\n```\n\n----------------------------------------\n\nTITLE: Importing from Other Standard Library Modules in Nushell\nDESCRIPTION: Example of how to import a command from another standard library module when creating a new standard library command. This pattern is required because your module is also a child module under std.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_0\n\nLANGUAGE: nushell\nCODE:\n```\n... your foo.nu ...\nexport def mycommand [] {\n  use log \"log info\"\n  . . .\n  log info \"info level log message\"\n  . . .\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Tests for Nushell\nDESCRIPTION: Commands to run the entire test suite for the Nushell workspace. This ensures that changes don't break existing functionality.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_3\n\nLANGUAGE: nushell\nCODE:\n```\ncargo test --workspace\n```\n\nLANGUAGE: nushell\nCODE:\n```\nuse toolkit.nu test\ntest\n```\n\n----------------------------------------\n\nTITLE: Installing Query Plugin with Cargo for Nushell\nDESCRIPTION: Command to install the Query plugin for Nushell using Cargo. This installs the plugin from the current directory.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_query/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n> cargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Using config_hex() for Customized Hex Dumps in Rust\nDESCRIPTION: This example demonstrates the config_hex() function that allows for customized hex dump formatting. It shows how to create a HexConfig object to specify formatting options like width, grouping, and title display, then applies it to binary data from a file.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-pretty-hex/README.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pretty_hex::*;\n\nlet cfg = HexConfig {title: false, width: 8, group: 0, ..HexConfig::default() };\n\nlet v = &include_bytes!(\"data\");\nassert_eq!(config_hex(&v, cfg), format!(\"{:?}\", v.hex_conf(cfg)));\n\nprintln!(\"{:?}\", v.hex_conf(cfg));\n```\n\n----------------------------------------\n\nTITLE: Example Output of config_hex() in Rust\nDESCRIPTION: This snippet shows the output format of the config_hex() function with custom configuration, displaying a narrower width of 8 bytes per line, no byte grouping, and with the title disabled while maintaining address offsets and ASCII representation.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-pretty-hex/README.md#2025-04-19_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n0000:   6b 4e 1a c3 af 03 d2 1e   kN......\n0008:   7e 73 ba c8 bd 84 0f 83   ~s......\n0010:   89 d5 cf 90 23 67 4b 48   ....#gKH\n0018:   db b1 bc 35 bf ee         ...5..\n```\n\n----------------------------------------\n\nTITLE: Checking Code Formatting\nDESCRIPTION: Commands to check if the codebase adheres to the project's formatting rules without making any changes. This helps maintain consistent code style.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_5\n\nLANGUAGE: nushell\nCODE:\n```\ncargo fmt --all -- --check\n```\n\nLANGUAGE: nushell\nCODE:\n```\nuse toolkit.nu fmt\nfmt --check\n```\n\n----------------------------------------\n\nTITLE: Example Output of simple_hex() in Rust\nDESCRIPTION: This snippet shows the output format of the simple_hex() function, which displays bytes in a single line with spaces between groups of bytes for readability.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-pretty-hex/README.md#2025-04-19_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nde ad be ef  ca fe 20 18\n```\n\n----------------------------------------\n\nTITLE: Customizing Nushell Prompt\nDESCRIPTION: This snippet defines a custom prompt for Nushell, including git status information and command duration. It uses various functions to gather system information and format the prompt.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/te'st.txt#2025-04-19_snippet_1\n\nLANGUAGE: nushell\nCODE:\n```\ndef create_left_prompt [] {\n    let path_segment = if (is-admin) {\n        $\"(ansi red_bold)($env.PWD)\"\n    } else {\n        $\"(ansi green_bold)($env.PWD)\"\n    }\n\n    $path_segment\n}\n\ndef create_right_prompt [] {\n    let time_segment = ([?\n        (date now | date format '%m/%d/%Y %r')\n    ] | str join)\n\n    let last_exit_code = if ($env.LAST_EXIT_CODE != 0) {$\"(ansi red)($env.LAST_EXIT_CODE)\"} else {\"\"}\n\n    ([$last_exit_code, (char space), $time_segment] | str join)\n}\n\n# Use nushell functions to define your right and left prompt\n$env.PROMPT_COMMAND = { || create_left_prompt }\n# FIXME: This default is not implemented in rust code as of 2023-09-08.\n$env.PROMPT_COMMAND_RIGHT = { || create_right_prompt }\n\n# The prompt indicators are environmental variables that represent\n# the state of the prompt\n$env.PROMPT_INDICATOR = { || \":\" }\n$env.PROMPT_INDICATOR_VI_INSERT = { || \": \" }\n$env.PROMPT_INDICATOR_VI_NORMAL = { || \"v \" }\n$env.PROMPT_MULTILINE_INDICATOR = { || \"\\ \" }\n\n# If you want previously entered commands to have a different prompt from the usual one,\n# you can uncomment one or more of the following lines.\n# This can be useful if you want to distinguish between commands that you entered yourself,\n# and commands that were entered by someone else or by a script.\n# $env.PROMPT_COMMAND_RIGHT_PREV = { || \"\" }\n# $env.PROMPT_INDICATOR_PREV = { || \"\" }\n# $env.PROMPT_INDICATOR_VI_INSERT_PREV = { || \"\" }\n# $env.PROMPT_INDICATOR_VI_NORMAL_PREV = { || \"\" }\n# $env.PROMPT_MULTILINE_INDICATOR_PREV = { || \"\" }\n\n# Specifies how environment variables are:.\n# - converted from a string to a value on Nushell startup (from_string)\n# - converted from a value back to a string when running external commands (to_string)\n# Note: The conversions happen *after* config.nu is loaded\n$env.ENV_CONVERSIONS = {\n  \"PATH\": {\n    from_string: { |s| $s | split row (char esep) | path expand --no-symlink }\n    to_string: { |v| $v | path expand --no-symlink | str join (char esep) }\n  }\n  \"Path\": {\n    from_string: { |s| $s | split row (char esep) | path expand --no-symlink }\n    to_string: { |v| $v | path expand --no-symlink | str join (char esep) }\n  }\n}\n\n# Directories to search for scripts when calling source or use\n$env.NU_LIB_DIRS = [\n    # FIXME: This default is not implemented in rust code as of 2023-09-06.\n    ($nu.default-config-dir | path join 'scripts')\n]\n\n# Directories to search for plugin binaries when calling register\n$env.NU_PLUGIN_DIRS = [\n    # FIXME: This default is not implemented in rust code as of 2023-09-06.\n    ($nu.default-config-dir | path join 'plugins')\n]\n\n# To add entries to PATH (on Windows you might use Path), you can use the following pattern:\n# $env.PATH = ($env.PATH | split row (char esep) | prepend '/some/path')\n\n# To load in specific modules from the std library at startup (useful for overrides) use the following:\n#$env.NU_LIB_DIRS = [\"some/path/to/custom/std\", \"some/path/to/other/custom/std\"]\n```\n\n----------------------------------------\n\nTITLE: Redirecting Trace Logs to a File\nDESCRIPTION: Commands to run Nushell with trace logging directed to a file and then open that log file. This is useful for examining detailed logs without cluttering the console.\nSOURCE: https://github.com/nushell/nushell/blob/main/CONTRIBUTING.md#2025-04-19_snippet_9\n\nLANGUAGE: nushell\nCODE:\n```\ncargo run --release -- --log-level trace --log-target file\nopen $\"($nu.temp-path)/nu-($nu.pid).log\"\n```\n\n----------------------------------------\n\nTITLE: Running Individual Benchmarks with Cargo in Rust\nDESCRIPTION: Command to run specific benchmarks using Cargo in the Nushell project. This allows for running benchmarks that match a given regex pattern, such as 'parse'.\nSOURCE: https://github.com/nushell/nushell/blob/main/benches/README.md#2025-04-19_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n```shell\ncargo bench -- <regex>\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Assert Commands in Test Files using std\nDESCRIPTION: Shows two different ways to import assert commands for use in test files. Test files are not modules under std, so the import pattern differs from standard library source files.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_1\n\nLANGUAGE: nushell\nCODE:\n```\n... your test_foo.nu ...\ndef test1 [] {\n  use std\n  . . .\n  std assert greater $l $r\n  . . .\n  std assert $predicate\n}\n\ndef test2 [] {\n  use std ['assert greater' assert]\n  . . .\n  assert greater $l $r\n  . . .\n  assert $predicate\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Running a Specific Benchmark in Rust\nDESCRIPTION: Example command demonstrating how to run a specific benchmark (in this case, 'parse') using Cargo in the Nushell project.\nSOURCE: https://github.com/nushell/nushell/blob/main/benches/README.md#2025-04-19_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n```shell\ncargo bench -- parse\n```\n```\n\n----------------------------------------\n\nTITLE: Building and Running Nushell\nDESCRIPTION: Basic command to build and run Nushell, particularly useful after modifying the prelude.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-std/CONTRIBUTING.md#2025-04-19_snippet_6\n\nLANGUAGE: nushell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Using simple_hex() for One-Line Hex Dumps in Rust\nDESCRIPTION: This example demonstrates the simple_hex() function which renders a one-line hex dump of binary data. It shows how to convert a vector of bytes into a formatted hex string using both the function directly and the hex_dump() trait method.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-pretty-hex/README.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pretty_hex::*;\n\nlet v = vec![222, 173, 190, 239, 202, 254, 32, 24];\nassert_eq!(simple_hex(&v), format!(\"{}\", v.hex_dump()));\n\nprintln!(\"{}\", v.hex_dump());\n```\n\n----------------------------------------\n\nTITLE: Inheriting Workspace Dependencies in Cargo.toml\nDESCRIPTION: Example of how to properly inherit a dependency from the workspace in a Nushell crate's Cargo.toml file. This approach ensures version consistency across the workspace.\nSOURCE: https://github.com/nushell/nushell/blob/main/devdocs/HOWTOS.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\ncratename = { workspace = true }\n```\n\n----------------------------------------\n\nTITLE: Using pretty_hex() for Multi-Line Formatted Hex Dumps in Rust\nDESCRIPTION: This example demonstrates the pretty_hex() function which creates a multi-line formatted hex dump with address offsets and ASCII representation. It shows how to convert random bytes into a detailed hex dump using both the function and the hex_dump() trait method with the debug formatter.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-pretty-hex/README.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pretty_hex::*;\n\nlet v: &[u8] = &random::<[u8;30]>();\nassert_eq!(pretty_hex(&v), format!(\"{:?}\", v.hex_dump()));\n\nprintln!(\"{:?}\", v.hex_dump());\n```\n\n----------------------------------------\n\nTITLE: Example Output of pretty_hex() in Rust\nDESCRIPTION: This snippet shows the output format of the pretty_hex() function, which displays byte data with address offsets, grouped hex values, and an ASCII representation on the right side. It also includes information about the total length of the data.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-pretty-hex/README.md#2025-04-19_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nLength: 30 (0x1e) bytes\n0000:   6b 4e 1a c3  af 03 d2 1e  7e 73 ba c8  bd 84 0f 83   kN......~s......\n0010:   89 d5 cf 90  23 67 4b 48  db b1 bc 35  bf ee         ....#gKH...5..\n```\n\n----------------------------------------\n\nTITLE: Example of an Ideal default_config.nu in Nushell\nDESCRIPTION: Shows the minimal implementation of default_config.nu when all values are set via nu-protocol::config. In this ideal case, the file would simply set an empty configuration object.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-utils/src/default_files/README.md#2025-04-19_snippet_0\n\nLANGUAGE: nushell\nCODE:\n```\n$env.config = {}\n```\n\n----------------------------------------\n\nTITLE: Where Command Example\nDESCRIPTION: Example of a where command syntax used to demonstrate type shapes and parsing behavior.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/README.md#2025-04-19_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nwhere $x > 10\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-fuzz for Nushell Parser Fuzzing\nDESCRIPTION: Command to install the cargo-fuzz tool, which is required for fuzzing the Nushell parser.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/fuzz/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-fuzz\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies via Command Line\nDESCRIPTION: Commands for adding nu-json and serde dependencies using cargo add\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-json/README.md#2025-04-19_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n cargo add serde\n cargo add nu-json\n```\n\n----------------------------------------\n\nTITLE: Running Nushell Parser Fuzzer with Seeds\nDESCRIPTION: Command to run the fuzzer targeting the parse functionality, specifying output and seed directories.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/fuzz/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo fuzz run parse out seeds\n```\n\n----------------------------------------\n\nTITLE: Running the nu-path Fuzzer\nDESCRIPTION: Command to execute the fuzzer on the 'parse' target with results stored in the 'out' directory.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-path/fuzz/README.md#2025-04-19_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo fuzz run parse out\n```\n\n----------------------------------------\n\nTITLE: Installing Git Stat Plugin using Cargo\nDESCRIPTION: Command to install the Git stat plugin using Cargo from the current directory. This is the first step in setting up the plugin.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_gstat/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n> cargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Running All Benchmarks with Cargo in Rust\nDESCRIPTION: Command to run all benchmarks using Cargo in the Nushell project. This will execute all benchmarks defined using the Divan microbenchmarking tool.\nSOURCE: https://github.com/nushell/nushell/blob/main/benches/README.md#2025-04-19_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```shell\ncargo bench\n```\n```\n\n----------------------------------------\n\nTITLE: Parsing and Generating Hjson in Rust\nDESCRIPTION: Complete example demonstrating how to decode Hjson text into Rust data structures, manipulate the data, and encode it back to Hjson format. Shows usage of Map and Value types along with various parsing and conversion methods.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-json/README.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate serde;\nextern crate nu_json;\n\nuse nu_json::{Map,Value};\n\nfn main() {\n\n    // Now let's look at decoding Hjson data\n\n    let sample_text=r#\"\n    {\n        ## specify rate in requests/second\n        rate: 1000\n        array:\n        [\n            foo\n            bar\n        ]\n    }\"#;\n\n    // Decode and unwrap.\n    let mut sample: Map<String, Value> = nu_json::from_str(&sample_text).unwrap();\n\n    // scope to control lifetime of borrow\n    {\n        // Extract the rate\n        let rate = sample.get(\"rate\").unwrap().as_f64().unwrap();\n        println!(\"rate: {}\", rate);\n\n        // Extract the array\n        let array : &mut Vec<Value> = sample.get_mut(\"array\").unwrap().as_array_mut().unwrap();\n        println!(\"first: {}\", array.first().unwrap());\n\n        // Add a value\n        array.push(Value::String(\"baz\".to_string()));\n    }\n\n    // Encode to Hjson\n    let sample2 = nu_json::to_string(&sample).unwrap();\n    println!(\"Hjson:\\n{}\", sample2);\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for Nushell Platform Support\nDESCRIPTION: Comprehensive markdown documentation describing Nushell's platform support policy, including build targets, testing infrastructure, and packaging guidelines.\nSOURCE: https://github.com/nushell/nushell/blob/main/devdocs/PLATFORM_SUPPORT.md#2025-04-19_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Nushell platform support policy\n\nNushell envisions to be a cross-platform shell, despite taking some strong design inspiration from UNIX and POSIX command names and style conventions we explicitly support Windows.\n\n## cross-platform design\nThis commitment to a cross-platform Nushell forces us to make provisions so users on Windows can have the generally same pleasant experience: e.g. supporting paths with backslash as the directory separator, forces us to support string literals that accept those.\n\nIn general our design strives to have a consistent behavior across all platforms if defining the semantics is possible for Nushell.\nIn some cases where the platform requirements dominate we may choose to follow the platform specific defaults. (some nuances around the file system)\nOnly rarely do we want to accept commands/language features that only support a single platform, only to access common system behavior of this particular platform (e.g. `registry query` command for the windows registry, `exec` for Linux and MacOS)\n\n## cross-platform builds and testing\n\nThe Nushell team runs **testing of Nushell for the following platforms** through our CI:\n\n- macOS (latest version available through GitHub CI)\n- Windows (10 and 11)\n- Linux (our test runners use `ubuntu-20.04` to represent distributions with not the latest glibc versions.)\n\nAll PR level tests are performed on x86/AMD64 (at least at the time of writing the default macOS runner was not yet using arm64).\n\nAs an additional layer of validation we perform [nightly builds](https://github.com/nushell/nightly/releases).\n\nThose target **additional build targets**:\n- **aarch64 for all platforms**\n- musl as an alternative to Glibc on linux\n- riscv only for linux\n- armv7 only for linux\n\nWe will try to provide builds for all of them but a standard configuration for x86-64 or aarch64 will take priority for us should we face technical challenges in a release cycle.\n\n### Supported feature flags\n\nWe have features of Nushell behind flags that can be passed at compilation time.\n\nThe design focus of Nushell is primarily expressed by everything accessible without passing additional feature flag.\nThis provides a standard command set and receives the most attention.\n\n## Passively supported platforms\n\nThese platforms are not actively managed through our CI so may encounter unintended regressions.\nFurthermore certain features may not yet be available, even though we are willing to accept PRs trying to close that gap.\n\n\n- OpenBSD\n    - e.g. missing the `ps` command\n- FreeBSD\n    - e.g. missing the `ps` command\n- Android via Termux\n\nHelp from the community to make sure they get tested and improved so they can become first class targets would be greatly appreciated!\n\n\n## Providing builds and packaging\n\nThe Nushell team only provides a select few distribution sources and so far encourages community members to maintain the individual packages for particular package managers:\n\nWe provide:\n- source code distribution via `crates.io` -> `cargo install nu`\n- GitHub builds with each release: (following the build matrix of the nightly builds)\n- the setup for `winget` packaging\n\n### For package maintainers:\n\nWe aim to support the rust version that is two releases behind the most recent version of stable Rust so the build infrastructure of your packaging environment can already be proven out.\n```\n\n----------------------------------------\n\nTITLE: Data Representation in JSON Format\nDESCRIPTION: Example of data represented in standard JSON format, showing a person with name, birth date, and numeric statistics.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nuon/README.md#2025-04-19_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Some One\",\n    \"birth\": \"1970-01-01\",\n    \"stats\": [\n      2544729499973429198,\n      687051042647753531,\n      6702443901704799912\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Data Representation in NUON Format\nDESCRIPTION: The same person data represented in NUON format, demonstrating unquoted keys, trailing commas, and inline comments - features not available in standard JSON.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nuon/README.md#2025-04-19_snippet_1\n\nLANGUAGE: nuon\nCODE:\n```\n{\n    name: \"Some One\",       # the name of the person\n    birth: \"1970-01-01\",    # their date of birth\n    stats: [                # some dummy \"stats\" about them\n      2544729499973429198,\n      687051042647753531,\n      6702443901704799912, # note the trailing comma here...\n    ], # and here\n} # wait, are these comments in a JSON-like document?!?!\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-fuzz for Nushell Path Fuzzing\nDESCRIPTION: Command to install the cargo-fuzz tool, which is required for fuzzing the nu-path component.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-path/fuzz/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-fuzz\n```\n\n----------------------------------------\n\nTITLE: Adding nu-glob as a Dependency in Cargo.toml\nDESCRIPTION: Instructions for adding the nu-glob library to a Rust project's Cargo.toml dependencies section. This example shows how to specify version 0.60.0 as a dependency.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-glob/README.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nnu-glob = \"0.60.0\"\n```\n\n----------------------------------------\n\nTITLE: Creating Output Directory for Fuzzer Results\nDESCRIPTION: Command to create an output directory to store fuzzing results and artifacts.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-path/fuzz/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmkdir out\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Cargo.toml\nDESCRIPTION: Configuration for adding nu-json and serde dependencies to a Rust project using Cargo.toml\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-json/README.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nserde = \"1\"\nnu-json = \"0.76\"\n```\n\n----------------------------------------\n\nTITLE: Creating Output Directory for Fuzzer Results\nDESCRIPTION: Command to create a directory for storing fuzzer output results.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-parser/fuzz/README.md#2025-04-19_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmkdir out\n```\n\n----------------------------------------\n\nTITLE: Plugin Engine Description in Markdown\nDESCRIPTION: Header and basic description of the nu-plugin-engine crate and its relationship to Nushell\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu-plugin-engine/README.md#2025-04-19_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# nu-plugin-engine\n\nThis crate provides functionality for the [Nushell](https://nushell.sh/) engine to spawn and interact with plugins.\n```\n\n----------------------------------------\n\nTITLE: Markdown Table of Nushell Script Execution Locations\nDESCRIPTION: A markdown table listing various Nushell scripts and their execution capabilities from different locations in the project structure. It indicates whether scripts can be run from the ./scripts/ directory, the root directory, or from anywhere.\nSOURCE: https://github.com/nushell/nushell/blob/main/scripts/README.md#2025-04-19_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| script                  | `./scripts/` | root | anywhere |\n| ----------------------- | ------------ | ---- | -------- |\n| `build-all-maclin.sh`   | x            | x    | x        |\n| `build-all-windows.cmd` | ?            | x    | ?        |\n| `build-all.nu`          | x            | x    | x        |\n| `coverage-local.nu`     | x            | x    | x        |\n| `coverage-local.sh`     | x            | x    | x        |\n| `install-all.ps1`       | ?            | x    | ?        |\n| `install-all.sh`        | x            | x    | x        |\n| `uninstall-all.sh`      | x            | x    | x        |\n```\n\n----------------------------------------\n\nTITLE: Executing SQLite Query in Rust for NuShell\nDESCRIPTION: This function executes a SQLite query and returns the results as a NuShell Value. It handles different data types and converts them to appropriate NuShell representations.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/quoted_completions/semicolon_;.txt#2025-04-19_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn query_db(conn: &Connection, query: &str) -> Result<Value, ShellError> {\n    let mut stmt = conn.prepare(query)?;\n    let column_names: Vec<String> = stmt\n        .column_names()\n        .into_iter()\n        .map(|c| c.to_string())\n        .collect();\n\n    let column_count = column_names.len();\n\n    let mut rows = Vec::new();\n    let mut row_result = stmt.query([])?;\n    while let Some(row) = row_result.next()? {\n        let mut record = Record::new();\n        for i in 0..column_count {\n            let column_name = &column_names[i];\n            let value: rusqlite::types::Value = row.get(i)?;\n            record.push(column_name, convert_sqlite_to_nu_value(value));\n        }\n        rows.push(Value::Record { val: record, span: Span::unknown() });\n    }\n\n    Ok(Value::List {\n        vals: rows,\n        span: Span::unknown(),\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Profiling Code for Measuring Type Checking Performance in Rust\nDESCRIPTION: A code snippet that sets up profiling for type checking operations in Nushell. It configures a profiling session, executes type checking, and outputs timing information to help diagnose performance issues.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/cp/dir_with_mount/copy_me.txt#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut guard = flame::start_guard(\"typechecking\");\nflame::note(\"signatures\", format!(\"{}\", self.signatures.len()));\nflame::note(\"decls\", format!(\"{}\", self.decls.len()));\nlet result = f();\nguard.end();\nflame_graph::render_html(flame::dump()).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Benchmark Comparison of Type Checking Methods in Rust\nDESCRIPTION: A code snippet showing benchmark results for different optimization approaches to type checking in Nushell. It compares the performance of different methods with timing measurements.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/cp/dir_with_mount/copy_me.txt#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntypechecking: 3.2s\n  check_usage: 2.5s\n    collect_definitions: 240ms\n    checking_cmds: 1.5s\n    checking_exprs: 700ms\n  stack_type_check: 700ms\n```\n\n----------------------------------------\n\nTITLE: Example of Memoization Pattern in Rust\nDESCRIPTION: A code snippet demonstrating a memoization implementation using a HashMap to cache computation results. This pattern is suggested for optimizing type checking operations by avoiding redundant calculations.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/cp/dir_with_mount/copy_me.txt#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut cache = HashMap::new();\n\nfn expensive_computation(arg: i32, cache: &mut HashMap<i32, i32>) -> i32 {\n    if let Some(&result) = cache.get(&arg) {\n        return result;\n    }\n    \n    let result = /* expensive computation */;\n    cache.insert(arg, result);\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed LSP Optimization Using Dependency Graph in Rust\nDESCRIPTION: A proposed implementation approach for optimizing Nushell's LSP performance by using a dependency graph. This would track relationships between definitions and references to avoid unnecessary recalculations.\nSOURCE: https://github.com/nushell/nushell/blob/main/tests/fixtures/cp/dir_with_mount/copy_me.txt#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// 1. Build a graph of dependencies between variables/functions\n// 2. When a file changes, determine which definitions were affected\n// 3. Mark those definitions and anything that depends on them as \"dirty\"\n// 4. Only recheck dirty items\n```\n\n----------------------------------------\n\nTITLE: Adding Git Stat Plugin to Nushell\nDESCRIPTION: Command to add the installed Git stat plugin to Nushell. This should be run from inside Nushell after the plugin has been installed.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_gstat/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n> plugin add <path to installed plugin>\n```\n\n----------------------------------------\n\nTITLE: Viewing Plugin Configuration\nDESCRIPTION: Command to display the current plugin configuration values.\nSOURCE: https://github.com/nushell/nushell/blob/main/crates/nu_plugin_example/README.md#2025-04-19_snippet_2\n\nLANGUAGE: nushell\nCODE:\n```\nexample config\n```"
  }
]