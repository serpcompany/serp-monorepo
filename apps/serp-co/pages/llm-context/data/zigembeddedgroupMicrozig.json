[
  {
    "owner": "zigembeddedgroup",
    "repo": "microzig",
    "content": "TITLE: Initializing UART and Performing Async I/O with microzig (Zig)\nDESCRIPTION: This code sets up a UART interface with specific configuration (baud rate, stop bits, parity, data bits), enables evented I/O to allow async/await patterns, and demonstrates reading/writing text buffers. Prerequisites include a correct clock rate and enabled DMA channels if required. Inputs are traditional UART serial settings and output is driver state (transmitted data and X received buffer).\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_5\n\nLANGUAGE: zig\nCODE:\n```\nconst std = @import(\"std\");\nconst microzig = @import(\"\\xC2\\xB5zig\");\n\n// if const it can be comptime-optimized\npub var cpu_frequency = 100.0 * microzig.clock.mega_hertz;\n\n// if this is enabled, a event loop will run\n// in microzig.main() that allows using `async`/`await` \"just like that\" *grin*\npub const io_mode = .evented;\n\npub fn main() !void {\n  var debug_port = microzig.Uart.init(0, .{\n    .baud_rate = 9600,\n    .stop_bits = .@\"2\",\n    .parity = .none, // { none, even, odd, mark, space }\n    .data_bits = .@\"8\", // 5, 6, 7, 8, or 9 data bits\n    //.in_dma_channel = 0,\n    //.out_dma_channel = 0,\n  });\n \n  debug_port.configureDMA(???);\n  \n  try debug_port.writer().writeAll(\"Hello, World!\");\n  \n  var line_buffer: [64]u8 = undefined;\n  const len = try debug_port.reader().readUntilDelimiter(&line_buffer, '\\n');\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing .data Section in Zig Startup Routine for Embedded Systems\nDESCRIPTION: This Zig snippet implements the embedded system startup routine that initializes the runtime .data section by copying its contents from flash memory (load address) to RAM (execution address). It declares external symbols defined in the linker script (code_end, data_begin, data_end) to determine source and destination addresses and length of .data. Using std.mem.copy, it transfers initialized variables from flash to RAM before proceeding with the main program entry. This routine uses Zig's extern declarations, pointer casts, and callconvention attributes to run as a naked startup function which must never return. The snippet depends on the previously defined linker script layout and the Zig standard library.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/website/content/tutorials/02-embedded-programming.md#_snippet_1\n\nLANGUAGE: zig\nCODE:\n```\nconst std = @import(\"std\");\n\n// We can access symbols by declaring them as extern c_void\n// and taking their address\nextern var code_end: c_void;\nextern var data_begin: c_void;\nextern var data_end: c_void;\n\nextern fn _start() callconv(.naked) noreturn {\n  // first, gather both source and destination addresses:\n  const src_ptr = @ptrCast([*]const u8, &code_end);\n  const dst_ptr = @ptrCast([*]u8, &data_begin);\n\n  // then, compute the length of the .data section by\n  // just subtracting two pointers\n  const length = @ptrToInt(&data_end) - @ptrToInt(&data_begin);\n\n  // and finally, initialize .data:\n  std.mem.copy(u8, dst_ptr[0..length], src_ptr[0..length]);\n\n  // call your program enty point here:\n  // …\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Memory Regions and Sections in GNU Linker Script for Embedded C++\nDESCRIPTION: This GNU linker script declares memory regions for flash and RAM, and defines the placement rules for program sections such as .text and .data. It specifies .text to reside in flash memory and .data in RAM, but sets the load address of .data at the end of .text in flash. Symbols (code_end, data_begin, data_end) mark boundaries used to copy initialized data from flash to RAM at startup. This layout supports embedded systems where RAM contents are not persistent and must be loaded from flash memory. The script requires a linker supporting MEMORY and SECTIONS directives and must be combined with a compatible startup routine to copy .data at runtime.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/website/content/tutorials/02-embedded-programming.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n/* This section declares two memory regions:\n * flash: 512k of non-writeable memory at position 0,\n * ram:   32k of writeable memory at position 256M\n */\nMEMORY\n{\n  flash (rx!w) : ORIGIN = 0x00000000, LENGTH = 512k\n  ram   (rwx)  : ORIGIN = 0x10000000, LENGTH = 32k\n}\n\n/* This section declares rules where to put different\n * symbols (functions and variables) in memory\n */\nSECTIONS\n{\n  /* this is the output section \".text\" which will be located in flash */\n  .text :\n  {\n    /* include all things that are functions or have linksection(\".text\") */\n    *(.text)\n  } >flash /* this means that this section is layed out in \"flash\" MEMORY */\n\n  /* assign the current location to a symbol called code_end */\n  code_end = .;\n\n  /* this is the output section \".data\" which will be located in RAM.\n   * AT(X) means that this section is *loaded* at position X in memory, in this\n   * case: after our code in flash.\n   */\n  .data : AT (code_end)\n  {\n    /* create a symbol called data_begin at the start of the data section */\n    data_begin = .;\n    \n    /* include all things that are variables or have linksection(\".data\") */\n    *(.data)\n\n    /* same as above, but now at the end of the section */\n    data_end = .;\n  } >ram /* this means that this section is layed out in \"ram\" MEMORY */\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Interrupts in microzig (Zig)\nDESCRIPTION: This snippet shows various operations with microzig's interrupts API. It enables/disables specific interrupts, performs compile-time error checks for invalid interrupts, handles critical sections, and defines interrupt handler symbols for different architectures. Dependencies include the microzig.interrupts API, and all handler functions must conform to the expected interface. Inputs are interrupt identifiers or vectors; outputs are runtime changes in interrupt states or error messages.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_2\n\nLANGUAGE: zig\nCODE:\n```\npub fn main() void {\n  microzig.interrupts.enable(.WDT);  // enables the WDT interrupt\n  microzig.interrupts.disable(.WDT); // enables the WDT interrupt\n  microzig.interrupts.enable(.WTF); // yields compile error \"WTF is not a valid interrupt\"\n  microzig.interrupts.enable(.PCINT0); // yields compile error \"PCINT0 has no defined interrupt handler\"\n  microzig.interrupts.enable(.NMI); // yields compile error \"NMI cannot be masked\"\n  microzig.interrupts.enableAll();\n  microzig.interrupts.batchEnable(.{ .NMI, .WDT  });\n  \n  microzig.interrupts.cli(); // set interrupt enabled (global enable)\n  \n  { // critical section\n    var crit = microzig.interrupts.enterCriticalSection();\n    defer crit.leave();\n  }\n}\n\nvar TIMER2_OVF_RUNTIME: fn()void = foo;\n\npub const interrupt_handlers = struct {\n\t\n  // AVR \n\tpub fn TIMER2_OVF() void { TIMER2_OVF_RUNTIME(); }\n  pub fn WDT() void { }\n  \n  pub const PCINT1 = .reset;\n  pub const PCINT2 = .hang;\n  \n  // cortex-mX exceptions\n  pub fn NMI() void { }\n  pub fn HardFault() void {}\n\n  // LPC 1768 interrupt/irq\n  pub fn SSP1() void { }\n};\n```\n\n----------------------------------------\n\nTITLE: Performing Early MCU and Root Initialization in Zig\nDESCRIPTION: This Zig extern function illustrates low-level initialization for microzig-enabled binaries. It checks for the existence of mcu_reset and various root/MCU entry symbols, then runs zeroing and data copy logic before calling user code. Requires Zig compiler builtins and access to all initialization routines; expected outputs include runtime initialization and potential compile errors if symbols are missing.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_6\n\nLANGUAGE: zig\nCODE:\n```\nextern fn reset() noreturn {\n  if(@hasDecl(mcu, \"mcu_reset\")) {\n  \tmcu.mcu_reset();\n    @unreachable();\n  }\n\t// zeroing bss, copying .data, setting stack address\n  \n  if(@hasDecl(root, \"early_main\")) // idk about the name\n    root.early_main();\n  else {\n  \tmcu.init();\n  \n  \tif(@hasDecl(root, \"main\"))\n  \t\troot.main();\n\t\telse\n  \t\t@compileError(\"main or entry_main missing\")\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Panic and Main Entry Point in Zig Root File\nDESCRIPTION: This snippet demonstrates how to declare a panic handler in the root Zig file to ensure the proper instantiation and wiring of the microzig system. It explicitly imports microzig, sets panic forwarding, and defines an empty main function, serving as the standard entry point. No input parameters are required, but the microzig dependency must be available; output is determined by microzig's runtime behavior.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_0\n\nLANGUAGE: zig\nCODE:\n```\nconst microzig = @import(\"microzig\");\n\npub const panic = microzig.panic; // this will instantiate microzig\n\ncomptime { _ = microzig };  // this should not be necessary\n\npub fn main() void {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Timer-Based Sleep and LED Control (Zig)\nDESCRIPTION: Illustrates the use of a timer-based sleep mode via the microzig API, periodically toggling an LED with a 100ms delay. The cpu_frequency and sleep_mode are configurable, and the user must provide appropriate LED initialization logic. Inputs include timer durations and outputs are observed LED state changes; microzig.clock must be configured for correct timing.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_3\n\nLANGUAGE: zig\nCODE:\n```\npub var cpu_frequency = 16.0 * microzig.clock.mega_hertz;\n\npub const sleep_mode = .timer; // timer, busyloop, whatever\n\npub fn main() !void {\n  led.init();\n\n  while(true) {\n    led.toggle();\n    microzig.sleep(100_000); // sleep 100ms\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting and Forwarding MCU Symbols and Board Configuration (microzig.mcu, Zig)\nDESCRIPTION: This Zig code, typically seen in microzig's internal files, conditionally imports MCU or board-specific code based on build options. It uses Zig's compile-time features (usingnamespace, if) to route hardware abstractions. Required dependencies include the microzig build_options module. The snippet sets up feature flags and exports for board interactions; expected use is for compile-time hardware selection.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_1\n\nLANGUAGE: zig\nCODE:\n```\n// mcu.zig in microzig.zig\nconst config = @import(\"build_options\");\n\nusingnamespace if(config.has_board)\n\t@import(\"board\").mcu\nelse\n\t@import(\"mcu\");\n\npub const has_board = config.has_board;\npub const board = @import(\"board\");\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Pins and Bit Banging with microzig (Zig)\nDESCRIPTION: This Zig example configures input/output pins and registers for GPIO bit banging, then defines a bitBang function for outputting 4-bit data. It demonstrates type-safe pin initialization, software rerouting, and runtime API structure. Dependencies include microzig.Pin, microzig.Gpio, and compile-time pin definitions; usage requires proper mapping of pin names and runtime support for different modes (input, output, input_output, open_drain, generic).\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/core/thoughts.md#_snippet_4\n\nLANGUAGE: zig\nCODE:\n```\n\n// microzig.Pin returns a type containing all relevant pin information\nconst status_led_pin = microzig.Pin(\"PA3\");\n\n// generate a runtime possible pin that cannot be used in all APIs\nvar generic_pic: microzig.RuntimePin.init(status_led_pin);\n\n// 4 Bit IEEE-488 bit banging register\nconst serial_out = microzig.GpioOutputRegister(.{\n  microzig.Pin(\"PA0\"),\n  microzig.Pin(\"PA1\"),\n  microzig.Pin(\"PA3\"), // whoopsies, i miswired, let the software fix that\n  microzig.Pin(\"PA2\"),\n});\n\npub fn bitBang(nibble: u4) void {\n  serial_out.write(nibble);\n}\n\npub fn main() !void {\n\n  // Route all gpio pins from the bit bang register\n\tinline for(serial_out.pins) |pin| {\n  \tpin.route(\".gpio\");\n  }\n  serial_out.init();\n\n\t// route that pin to UART.RXD\n  status_led_pin.route(.uart0_rxd);  \n  \n  //var uart_read_dma_channel = microzig.Dma.init(.{.channel = 1});\n  \n  const status_led = microzig.Gpio(status_led_pin, .{\n    .mode          = .output,       // { input, output, input_output, open_drain, generic }\n    .initial_state = .unspecificed, // { unspecified, low, high, floating, driven }\n  });\n  status_led.init();\n  \n  switch(status_led.mode) {\n  \t// only reading API is available\n  \t.input => {\n   \t_ = status_led.read();\n    },\n    \n    // reading and writing is available\n    .output => {\n   \t_ = status_led.read();\n      status_led.write(.high);\n      \n      // \"subvariant\" of the write \n      status_led.toggle();\n      status_led.setToHigh();\n      status_led.setToLow();\n    },\n    \n    // reading, writing and changing direction is available\n    .input_output => {\n      status_led.setDirection(.input, undefined);\n   \t_ = status_led.read();\n      status_led.setDirection(.output, .high); // reqires a defined state after setting the direction\n      status_led.write(.high);\n    },\n    \n    // reading and setDive is available\n    .open_drain => {\n      status_led.setDrive(.disabled);\n   \t_ = status_led.read();\n      status_led.setDrive(.enabled);\n    },\n    \n    // will have all available APIs enabled\n    .generic => {},\n  }\n  \n \t// AVR:   PORTA[3]   => \"PA3\"\n  // NXP:   PORT[1][3] => \"P1.3\"\n  // PICO:  PORT[1]    => \"P3\"\n  // STM:   PORT[A][3] => \"A3\"\n  // ESP32: PORT[1]    => \"P3\"\n\n```\n\n----------------------------------------\n\nTITLE: Generating an ESP Image from ELF in build.zig (Zig)\nDESCRIPTION: This Zig code snippet demonstrates how to use the 'esp_image' package within a `build.zig` file. It first declares the dependency using `b.dependency`, then calls the `esp_image.from_elf` function, passing the dependency object, the path to the ELF file (`elf_file`), and configuration options like the target `chip_id` (e.g., `.esp32_c3`). Finally, it uses `b.addInstallFile` to add the generated image file to the build installation with the name 'test.bin'.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/esp_image/README.md#_snippet_0\n\nLANGUAGE: zig\nCODE:\n```\nconst esp_image = @import(\"esp_image\");\n\npub fn build(b: *Build) void {\n    // ...\n\n    const esp_image_dep = b.dependency(\"esp_image\", .{});\n    const image_file = esp_image.from_elf(esp_image_dep, elf_file, .{\n        .chip_id = .esp32_c3,\n    });\n\n    b.addInstallFile(image_file, \"test.bin\");\n}\n```\n\n----------------------------------------\n\nTITLE: Generating UF2 from ELF using uf2.from_elf in Zig\nDESCRIPTION: This snippet demonstrates generating a UF2 file from an ELF binary using the `uf2.from_elf` function within a Zig build script. It adds the UF2 library as a dependency, calls `uf2.from_elf` with the ELF executable and family ID, and installs the resulting UF2 file. Requires the 'uf2' dependency to be available.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/uf2/README.md#_snippet_0\n\nLANGUAGE: Zig\nCODE:\n```\nconst uf2 = @import(\"uf2\");\n\npub fn build(b: *Build) void {\n    // ...\n    const uf2_dep = b.dependency(\"uf2\", .{});\n\n    const uf2_file = uf2.from_elf(uf2_dep, exe, .{ .family_id = .RP2040 });\n    _ = b.addInstallFile(uf2_file, \"bin/test.uf2\");\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Executing elf2uf2 tool in Zig\nDESCRIPTION: This code shows how to manually execute the `elf2uf2` tool from a Zig build script to generate a UF2 file.  It defines the `uf2` dependency, adds a run artifact for `elf2uf2`, specifies command-line arguments for the family ID, ELF file path, and output file path, and installs the resulting UF2 file. Requires the 'uf2' dependency to contain the `elf2uf2` executable.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/uf2/README.md#_snippet_1\n\nLANGUAGE: Zig\nCODE:\n```\npub fn build(b: *Build) void {\n    // ...\n\n    const uf2_dep = b.dependency(\"uf2\", .{});\n\n    const elf2uf2_run = b.addRunArtifact(uf2_dep.artifact(\"elf2uf2\"));\n\n    // family id\n    elf2uf2_run.addArgs(&.{ \"--family-id\", \"RP2040\" });\n\n    // elf file\n    elf2uf2_run.addArg(\"--elf-path\");\n    elf2uf2_run.addArtifactArg(exe);\n\n    // output file\n    const uf2_file = elf2uf2_run.addPrefixedOutputFileArg(\"--output-path\", \"test.uf2\");\n    _ = b.addInstallFile(uf2_file, \"bin/test.uf2\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a MicroZig Target Configuration in Zig\nDESCRIPTION: Example of defining a `microzig.Target` variable in Zig for an STM32F103RD microcontroller. This configuration includes dependencies (`dep`), preferred binary format, Zig target specifics (CPU architecture, model, OS, ABI), chip details (`name`, path to register definitions, memory layout), and HAL configuration (path to root source file). The `chip.name` field must correspond to an entry in the `chip` module's `devices` namespace.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/docs/design.md#_snippet_1\n\nLANGUAGE: zig\nCODE:\n```\npub const stm32f103: microzig.Target = .{\n    .dep = dep,\n    .preferred_binary_format = .elf,\n    .zig_target = .{\n        .cpu_arch = .thumb,\n        .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m3 },\n        .os_tag = .freestanding,\n        .abi = .eabi,\n    },\n    .chip = .{\n        .name = \"STM32F103RD\",\n        .register_definition = .{\n            .zig = b.path(\"/path/to/file.zig\"),\n        },\n        .memory_regions = &.{\n            .{ .offset = 0x08000000, .length = 64 * 1024, .kind = .flash },\n            .{ .offset = 0x20000000, .length = 20 * 1024, .kind = .ram },\n        },\n    },\n    .hal = .{\n        .root_source_file = b.path(\"/path/to/file.zig\"),\n    },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Chip Module Structure in Zig\nDESCRIPTION: Illustrates the required Zig code structure for a `chip` module in MicroZig, usually generated by the Regz tool. It defines a `types` struct for peripheral type definitions and a `devices` struct containing nested structs for specific chips, holding peripheral and interrupt table details.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/docs/design.md#_snippet_0\n\nLANGUAGE: zig\nCODE:\n```\npub const types = struct {\n    // type definitions for peripherals here\n};\n\npub const devices = struct {\n    pub const chip_name = struct {\n        // peripherals and interrupt table here ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Registers with Generated Zig Code\nDESCRIPTION: This Zig code demonstrates how to access and modify microcontroller registers using the code generated by regz. It imports the generated register definitions and uses the `modify` function to set values of specific registers. Requires the `nrf52.zig` file generated by regz.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/regz/README.md#_snippet_0\n\nLANGUAGE: Zig\nCODE:\n```\nconst regs = @import(\"nrf52.zig\").registers;\n\npub fn main() void {\n    regs.P0.PIN_CNF[17].modify(.{\n        .DIR = 1,\n        .INPUT = 1,\n        .PULL = 0,\n        .DRIVE = 0,\n        .SENSE = 0,\n    });\n    regs.P0.OUT.modify(.{ .PIN17 = 1 });\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Zig code from SVD file\nDESCRIPTION: This command generates Zig code from an SVD file using the regz tool. The path to the SVD file is provided as a command-line argument, and the output is redirected to a Zig file. Requires regz to be built and accessible in the system's PATH.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/regz/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nregz <path-to-svd> > my-chip.zig\n```\n\n----------------------------------------\n\nTITLE: Generating Zig code from SVD via stdin\nDESCRIPTION: This command generates Zig code from an SVD schema passed through stdin to the regz tool. It specifies the format as SVD using the `--format` flag and redirects the output to a Zig file. Requires regz to be built and accessible in the system's PATH.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/regz/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ncat my-file.svd | regz --format svd > my-chip.zig\n```\n\n----------------------------------------\n\nTITLE: Building regz\nDESCRIPTION: This command builds the regz project using the Zig build system. It creates an executable file in the `zig-out/bin` directory. Assumes that the Zig compiler is installed and configured correctly in the environment.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/tools/regz/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nzig build\n```\n\n----------------------------------------\n\nTITLE: Building Zig Firmware (Bash)\nDESCRIPTION: Commands to build the firmware using the Zig build system. The first command (`-Doptimize=ReleaseSmall`) is recommended for microcontroller targets to reduce binary size for flash memory. The second command is the default build, which may result in a larger binary that doesn't fit depending on project size and target device.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/wch/ch32v/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ zig build -Doptimize=ReleaseSmall\n\n$ zig build\n# will make ReleaseMode and not fit to the FLASH memory.\n```\n\n----------------------------------------\n\nTITLE: Flashing CH32V003 Firmware with wlink (Bash)\nDESCRIPTION: Command using the `wlink` tool to flash a binary firmware file (`BIN_FILE`) onto CH32V003 microcontrollers. The `--address 0x08000000` argument explicitly sets the flash memory start address where the firmware should be written, which is common for microcontrollers. This command requires the `wlink` tool to be installed, which may have dependencies like `libusb-1.0-0-dev`.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/wch/ch32v/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ wlink flash --address 0x08000000 BIN_FILE\n```\n\n----------------------------------------\n\nTITLE: Flashing CH32V103/V203 Firmware with wch-isp (Bash)\nDESCRIPTION: Command using the `wch-isp` tool to flash a binary firmware file (`BIN_FILE`) onto CH32V103 or CH32V203 microcontrollers. The `-pr` flag is typically used to program and reset the device. This command requires the `wch-isp` tool to be installed, which may have dependencies like `libusb-1.0-0-dev`.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/wch/ch32v/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n#$ wchisp flash BIN_FILE\n$ wch-isp -pr flash BIN_FILE\n```\n\n----------------------------------------\n\nTITLE: Disassembling RISC-V ELF File (Bash)\nDESCRIPTION: Command to disassemble an ELF executable or object file for RISC-V architectures using `riscv64-unknown-elf-objdump`. The `--disassemble-all` flag disassembles all sections. The output is redirected (`>`) to a specified file for later analysis. This requires the RISC-V binutils toolchain to be installed.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/wch/ch32v/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ riscv64-unknown-elf-objdump --disassemble-all ELF_FILE > DISASSEMBLED_FILE\n```\n\n----------------------------------------\n\nTITLE: Flashing Standard ESP-IDF Image using esptool.py (Shell)\nDESCRIPTION: This command demonstrates how to flash a standard ESP-IDF image structure onto an ESP32-C3 using esptool.py. It requires separate binaries for the bootloader, partition table, and firmware, specifying their respective flash addresses (0x0, 0x8000, 0x10000). Prerequisites include esptool.py installed and the bootloader and partition table binaries available.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/espressif/esp/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nesptool.py --chip esp32c3 --baud 460800 --before default_reset --after hard_reset write_flash \\\n        0x0 bootloader.bin 0x8000 partition_table.bin 0x10000 zig-out/firmware/esp32_c3_blinky.bin\n```\n\n----------------------------------------\n\nTITLE: Flashing Direct Boot Image using esptool.py (Shell)\nDESCRIPTION: This command shows how to flash a single 'direct boot' image onto an ESP32-C3 using esptool.py. Unlike the standard method, this only requires the main firmware binary and flashes it directly to address 0x0. This approach is simpler and based on the esp32c3-direct-boot-example.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/espressif/esp/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nesptool.py --chip esp32c3 --baud 460800 --before default_reset --after hard_reset write_flash 0x0 \\\n    zig-out/firmware/esp32_c3_direct_boot_blinky.bin\n```\n\n----------------------------------------\n\nTITLE: Flashing Firmware Using Picotool in Shell\nDESCRIPTION: Demonstrates how to flash .uf2 firmware files to Raspberry Pi Pico devices using the picotool command-line utility. The command loads the specified file to the device and reboots it to start the application.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/examples/raspberrypi/rp2xxx/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npicotool load -x zig-out/firmware/${file}.uf2\n```\n\n----------------------------------------\n\nTITLE: Example Zig Test Code\nDESCRIPTION: This Zig code snippet demonstrates how to embed a JSON configuration within a Zig file for testing purposes. It uses documentation comments to define expected standard output and standard error messages. The code writes these messages to the test suite output and then exits with a specific code.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/sim/aviron/README.md#_snippet_1\n\nLANGUAGE: zig\nCODE:\n```\n//! {\n//!   \"stdout\": \"hello\",\n//!   \"stderr\": \"world\"\n//! }\nconst testsuite = @import(\"testsuite\");\n\nexport fn _start() callconv(.C) noreturn {\n    testsuite.write(.stdout, \"hello\");\n    testsuite.write(.stderr, \"world\");\n    testsuite.exit(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Test Suite\nDESCRIPTION: This shell command runs the test suite for the AViRon project using the Zig build system.  It recursively searches the `testsuite` folder for files to compile and run, checking for specific file extensions such as .S, .c, .cpp, .zig, .bin, and .elf.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/sim/aviron/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n[~/projects/aviron]$ zig build test\n[~/projects/aviron]$ \n```\n\n----------------------------------------\n\nTITLE: Inspecting Generated Files\nDESCRIPTION: This shell command demonstrates building the `debug-testsuite` step to inspect the generated test files and their location.  This includes the file structure output and shows the compiled files within the `zig-out` directory.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/sim/aviron/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n[~/projects/aviron]$ zig build debug-testsuite\n[~/projects/aviron]$ tree zig-out/\nzig-out/\n├── bin\n│   └── aviron-test-runner\n└── testsuite\n    ├── instructions\n    │   ├── cbi.elf\n    │   ├── in-stdio.elf\n        ├── ...\n    │   ├── out-stdout.elf\n    │   └── sbi.elf\n    ├── lib\n    │   └── write-chan.elf\n    └── simulator\n        ├── scratch-reg0.elf\n        ├── scratch-reg1.elf\n        ├── ...\n        ├── scratch-rege.elf\n        └── scratch-regf.elf\n```\n\n----------------------------------------\n\nTITLE: Disassembling ELF Files\nDESCRIPTION: These shell commands use `llvm-objdump` and `avr-objdump` to disassemble ELF files generated by the build process. The commands display the assembly code of a specific ELF file, allowing for inspection of the compiled output.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/sim/aviron/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n[~/projects/aviron]$ llvm-objdump -d zig-out/testsuite/instructions/out-exit-0.elf \n\nzig-out/testsuite/instructions/out-exit-0.elf:  file format elf32-avr\n\nDisassembly of section .text:\n\n00000000 <_start>:\n       0: 00 27         clr     r16\n       2: 00 b9         out     0x0, r16\n       \n[~/projects/aviron]$ avr-objdump -d zig-out/testsuite/instructions/out-exit-0.elf \n\nzig-out/testsuite/instructions/out-exit-0.elf:     file format elf32-avr\n\nDisassembly of section .text:\n\n00000000 <_start>:\n   0:   00 27           eor     r16, r16\n   2:   00 b9           out     0x00, r16       ; 0\n\n[~/projects/aviron]$ \n```\n\n----------------------------------------\n\nTITLE: Updating AVR-GCC Tests\nDESCRIPTION: This shell command runs the `update-testsuite` build step to regenerate tests located in the `testsuite.avr-gcc` directory. It ensures that the vendored binaries are up to date, but it does not automatically detect changed files, so it's recommended to run this command followed by the regular test command.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/sim/aviron/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n[~/projects/aviron]$ zig build update-testsuite\n[~/projects/aviron]$ \n```\n\n----------------------------------------\n\nTITLE: Compiling Foundation libc Using Zig Build System - Shell\nDESCRIPTION: Instructions to compile the Foundation libc using the Zig build system. This snippet shows the shell commands to initiate a build process that compiles the libc and generates library files and headers. It requires Zig version 0.11 or compatible, and produces output files in the \"zig-out/lib\" and \"zig-out/include\" directories.\nSOURCE: https://github.com/zigembeddedgroup/microzig/blob/main/modules/foundation-libc/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nuser@microzig ~/foundation-libc $ zig build\nuser@microzig ~/foundation-libc $ \n```"
  }
]