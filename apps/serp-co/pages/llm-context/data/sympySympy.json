[
  {
    "owner": "sympy",
    "repo": "sympy",
    "content": "TITLE: Basic ODE Solving with SymPy's dsolve Function\nDESCRIPTION: Demonstrates how to solve a second-order ODE y''(x) + 9*y(x) = 0 using SymPy's dsolve function and verify the solution with checkodesol.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, dsolve, Derivative, checkodesol\n>>> from sympy.abc import x\n>>> y = Function('y')\n>>> # Solve the ODE\n>>> result = dsolve(Derivative(y(x), x, x) + 9*y(x), y(x))\n>>> result\nEq(y(x), C1*sin(3*x) + C2*cos(3*x))\n>>> # Check that the solution is correct\n>>> checkodesol(Derivative(y(x), x, x) + 9*y(x), result)\n(True, 0)\n```\n\n----------------------------------------\n\nTITLE: Different Ways to Express Derivatives in SymPy\nDESCRIPTION: Shows multiple equivalent ways to represent the second derivative of a function y(x) with respect to x using SymPy's Derivative and diff functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nypp = y(x).diff(x, x)\nypp = y(x).diff(x, 2)\nypp = y(x).diff((x, 2))\nypp = diff(y(x), x, x)\nypp = diff(y(x), x, 2)\nypp = Derivative(y(x), x, x)\nypp = Derivative(y(x), x, 2)\nypp = Derivative(Derivative(y(x), x), x)\nypp = diff(diff(y(x), x), x)\nyp = y(x).diff(x)\nypp = yp.diff(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Symbols in SymPy using symbols() function\nDESCRIPTION: Demonstrates the recommended way to create symbols in SymPy using the symbols() function. It shows how to create single and multiple symbols, add assumptions, and create Function objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> x = symbols('x')\n>>> a, b, c = symbols('a b c')\n>>> i, j, k = symbols('i j k', integer=True)\n>>> from sympy import Function\n>>> f, g, h = symbols('f g h', cls=Function)\n>>> symbols('x:10')\n(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n```\n\n----------------------------------------\n\nTITLE: Computing Integrals with SymPy\nDESCRIPTION: Examples of computing both definite and indefinite integrals using integrate() function, including single and multiple integrals.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nintegrate(cos(x), x)\nintegrate(exp(-x), (x, 0, oo))\nintegrate(exp(-x**2 - y**2), (x, -oo, oo), (y, -oo, oo))\n```\n\n----------------------------------------\n\nTITLE: Converting SymPy to Numeric Functions with Lambdify\nDESCRIPTION: Examples of using lambdify to convert SymPy expressions into numerical functions for efficient evaluation using various backends like NumPy or math.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/basic_operations.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nexpr = sin(x)\nf = lambdify(x, expr, \"math\")\nf(0.1)\n\ndef mysin(x):\n    \"\"\"\n    My sine. Note that this is only accurate for small x.\n    \"\"\"\n    return x\nf = lambdify(x, expr, {\"sin\":mysin})\nf(0.1)\n```\n\n----------------------------------------\n\nTITLE: Linear System Solving with Linsolve\nDESCRIPTION: Demonstrates solving linear systems of equations using linsolve in different formats: list of equations, augmented matrix, and A*x = b form.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/solvers.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlinsolve([x + y + z - 1, x + y + 2*z - 3 ], (x, y, z))\nlinsolve(Matrix(([1, 1, 1, 1], [1, 1, 2, 3])), (x, y, z))\nM = Matrix(((1, 1, 1, 1), (1, 1, 2, 3)))\nsystem = A, b = M[:, :-1], M[:, -1]\nlinsolve(system, x, y, z)\n```\n\n----------------------------------------\n\nTITLE: Basic Expression Simplification Examples\nDESCRIPTION: Demonstrates usage of the simplify() function to reduce complex mathematical expressions to simpler forms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsimplify(sin(x)**2 + cos(x)**2)\nsimplify((x**3 + x**2 - x - 1)/(x**2 + 2*x + 1))\nsimplify(gamma(x)/gamma(x - 2))\n```\n\n----------------------------------------\n\nTITLE: Finding Approximate Numeric Roots with nroots in SymPy\nDESCRIPTION: Demonstrates the use of the SymPy `nroots` function to find approximate numerical roots of a polynomial expression. This example shows that the output might include numerical noise, such as small imaginary components for roots that should be purely real. Assumes `expression` is a predefined SymPy polynomial.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> nroots(expression)\n[3.0, -2.0 - 4.18482169793536e-14*I, -2.0 + 4.55872552179222e-14*I]\n```\n\n----------------------------------------\n\nTITLE: Solving Linear Equations with SymPy\nDESCRIPTION: Demonstrates how to solve a system of linear equations using SymPy's solve function. The example solves for x and y in terms of z.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x, y, z\n>>> solve([x + y - 2*z, y + 4*z], [x, y], dict=True)\n[{x: 6*z, y: -4*z}]\n```\n\n----------------------------------------\n\nTITLE: Symbolic Expression Manipulation in SymPy\nDESCRIPTION: Shows how to create and manipulate symbolic expressions using SymPy's symbols function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/intro.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> x, y = symbols('x y')\n>>> expr = x + 2*y\n>>> expr\nx + 2*y\n>>> expr + 1\nx + 2*y + 1\n>>> expr - x\n2*y\n```\n\n----------------------------------------\n\nTITLE: Using Special Matrix Constructors in SymPy (eye, zeros, ones, diag) in Python\nDESCRIPTION: Demonstrates the use of special SymPy matrix constructors: `eye(n)` for an n x n identity matrix, `zeros(n)` for an n x n zero matrix, `zeros(m, n)` for an m x n zero matrix, `ones(n)` for an n x n matrix of ones, `ones(m, n)` for an m x n matrix of ones, and `diag(elements)` to create a block diagonal matrix from the provided elements (scalars or matrices). Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> eye(4)\n[1  0  0  0]\n[          ]\n[0  1  0  0]\n[          ]\n[0  0  1  0]\n[          ]\n[0  0  0  1]\n>>> zeros(2)\n[0  0]\n[    ]\n[0  0]\n>>> zeros(2, 5)\n[0  0  0  0  0]\n[             ]\n[0  0  0  0  0]\n>>> ones(3)\n[1  1  1]\n[       ]\n[1  1  1]\n[       ]\n[1  1  1]\n>>> ones(1, 3)\n[1  1  1]\n>>> diag(1, Matrix([[1, 2], [3, 4]]))\n[1  0  0]\n[       ]\n[0  1  2]\n[       ]\n[0  3  4]\n```\n\n----------------------------------------\n\nTITLE: Computing Derivatives with SymPy\nDESCRIPTION: Demonstrates various ways to compute derivatives using diff() function, including single and multiple variable derivatives with different syntaxes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndiff(cos(x), x)\ndiff(exp(x**2), x)\ndiff(x**4, x, x, x)\ndiff(x**4, x, 3)\nexpr = exp(x*y*z)\ndiff(expr, x, y, y, z, z, z, z)\ndiff(expr, x, y, 2, z, 4)\ndiff(expr, x, y, y, z, 4)\nexpr.diff(x, y, y, z, 4)\n```\n\n----------------------------------------\n\nTITLE: Running SymPy Tests Using Shell Commands\nDESCRIPTION: These shell commands demonstrate how to run SymPy tests and doctests using the provided scripts. It also shows how to run tests for specific modules or subsets of the test suite.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./bin/test\n\n./bin/doctest\n\n./bin/test solvers\n\npytest -m 'not slow' sympy/solvers\n```\n\n----------------------------------------\n\nTITLE: Performing Vector Operations (Cross and Dot Product) with SymPy Matrices in Python\nDESCRIPTION: Illustrates vector operations using SymPy `Matrix` objects representing vectors. It calculates the cross product (`v1.cross(v2)`) and dot product (`v1.dot(v2)`, `v2.dot(v3)`, `v1.dot(v3)`) of column vectors. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> v1 = Matrix([1,2,3])\n>>> v2 = Matrix([4,5,6])\n>>> v3 = v1.cross(v2)\n>>> v1.dot(v2)\n32\n>>> v2.dot(v3)\n0\n>>> v1.dot(v3)\n0\n```\n\n----------------------------------------\n\nTITLE: Basic Square Root Comparison in Python and SymPy\nDESCRIPTION: Demonstrates the difference between Python's numerical math.sqrt() and SymPy's symbolic sqrt() functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/intro.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import math\n>>> math.sqrt(9)\n3.0\n>>> math.sqrt(8)\n2.82842712475\n>>> import sympy\n>>> sympy.sqrt(3)\nsqrt(3)\n>>> sympy.sqrt(8)\n2*sqrt(2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Divides Function in SymPy\nDESCRIPTION: Implementation of a custom divides function that returns 1 if one number divides another and 0 otherwise. Includes type checking, assumptions, evaluation rules and LaTeX printing.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Function, Integer\nfrom sympy.core.logic import fuzzy_not\nclass divides(Function):\n    @classmethod\n    def eval(cls, m, n):\n        if isinstance(m, Integer) and isinstance(n, Integer):\n            return int(n % m == 0)\n        if m.is_integer is False or n.is_integer is False:\n            raise TypeError(\"m and n should be integers\")\n\n    is_integer = True\n    is_negative = False\n\n    def _eval_is_zero(self):\n        m, n = self.args\n        if m.is_integer and n.is_integer:\n             return fuzzy_not((n/m).is_integer)\n\n    def doit(self, deep=False, **hints):\n        m, n = self.args\n        if deep:\n           m, n = m.doit(deep=deep, **hints), n.doit(deep=deep, **hints)\n        isint = (n/m).is_integer\n        if isint is True:\n            return Integer(1)\n        elif isint is False:\n            return Integer(0)\n        else:\n            return divides(m, n)\n\n    def _latex(self, printer):\n        m, n = self.args\n        _m, _n = printer._print(m), printer._print(n)\n        return r'\\left [ %s \\middle | %s \\right ]' % (_m, _n)\n```\n\n----------------------------------------\n\nTITLE: Advanced Mathematical Operations in SymPy\nDESCRIPTION: Shows various advanced mathematical operations including derivatives, integrals, limits, and differential equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/intro.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> x, t, z, nu = symbols('x t z nu')\n>>> init_printing(use_unicode=True)\n>>> diff(sin(x)*exp(x), x)\nℯ^x⋅sin(x) + ℯ^x⋅cos(x)\n>>> integrate(exp(x)*sin(x) + exp(x)*cos(x), x)\nℯ^x⋅sin(x)\n>>> integrate(sin(x**2), (x, -oo, oo))\n√2⋅√π/2\n>>> limit(sin(x)/x, x, 0)\n1\n>>> solve(x**2 - 2, x)\n[-√2, √2]\n```\n\n----------------------------------------\n\nTITLE: Finding Polynomial Roots Algebraically using roots() in Python\nDESCRIPTION: Basic example of using SymPy's roots() function to find the roots of a quadratic polynomial algebraically, reproducing the quadratic formula.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import roots\n>>> from sympy.abc import x, a, b, c\n>>> roots(a*x**2 + b*x + c, x)\n{-b/(2*a) - sqrt(-4*a*c + b**2)/(2*a): 1,\n -b/(2*a) + sqrt(-4*a*c + b**2)/(2*a): 1}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Matrices in SymPy\nDESCRIPTION: Shows how to initialize matrices using the Matrix constructor with different input formats. Demonstrates creating both row-based and column vector matrices.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\ninit_printing(use_unicode=True)\n\nMatrix([[1, -1], [3, 4], [0, 2]])\nMatrix([1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Implementing Proper Evaluation and Simplification in SymPy Custom Functions\nDESCRIPTION: This snippet shows the recommended approach for implementing custom SymPy functions. It demonstrates proper use of eval for explicit values, doit for assumption-based simplification, and _eval_expand_func for symbolic identities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nclass f(Function):\n    @classmethod\n    def eval(cls, x):\n        if isinstance(x, Integer): # Good (only evaluating on explicit integers)\n            return 0\n\n    # Good (applying simplification on assumptions in doit())\n    def doit(self, deep=True, **hints):\n        x = self.args[0]\n        if deep:\n           x = x.doit(deep=deep, **hints)\n        if x.is_integer:\n           return S(0)\n        return self\n\n    # Good (applying symbolic identities inside of simplification functions)\n    def _eval_expand_func(self, **hints):\n        x = self.args[0]\n        if isinstance(x, Add):\n            return Add(*[f(i) for i in x.args])\n        return self\n\n```\n\n----------------------------------------\n\nTITLE: Generating and Solving Equations of Motion for Rolling Disc in Python\nDESCRIPTION: This code generates the equations of motion using Lagrange's method and solves for the generalized accelerations. It forms Lagrange's equations, simplifies them, and then uses the 'rhs' method to solve for the accelerations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_lagrange.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nq = [q1, q2, q3]\nl = LagrangesMethod(Lag, q)\nle = l.form_lagranges_equations()\nle.simplify(); le\nlrhs = l.rhs(); lrhs.simplify(); lrhs\n```\n\n----------------------------------------\n\nTITLE: Solving Nonlinear Equations with SymPy\nDESCRIPTION: Shows how to solve a system of nonlinear equations using SymPy's solve function. The example solves for x and y in terms of z, resulting in two solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x, y, z\n>>> solve([x**2 + y - 2*z, y + 4*z], x, y, dict=True)\n[{x: -sqrt(6)*sqrt(z), y: -4*z}, {x: sqrt(6)*sqrt(z), y: -4*z}]\n```\n\n----------------------------------------\n\nTITLE: Solving a System of First-Order ODEs in SymPy\nDESCRIPTION: Shows how to solve a system of coupled first-order ODEs by defining functions without including their independent variables and providing them as a list to dsolve.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Eq, Function, dsolve\n>>> f, g = symbols(\"f g\", cls=Function)\n>>> x = symbols(\"x\")\n>>> eqs = [Eq(f(x).diff(x), g(x)), Eq(g(x).diff(x), f(x))]\n>>> dsolve(eqs, [f(x), g(x)])\n[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]\n```\n\n----------------------------------------\n\nTITLE: Solving a Basic Matrix Equation with SymPy\nDESCRIPTION: Demonstrates solving a 2x2 matrix equation with symbolic variables using SymPy's Matrix.solve() method. This creates the coefficient matrix, constant vector, and solves the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.matrices import Matrix\n>>> c, d, e = symbols(\"c, d, e\")\n>>> A = Matrix([[c,d], [1, -e]])\n>>> A\n⎡c  d ⎤\n⎢     ⎥\n⎣1  -e⎦\n>>> b = Matrix([2, 0])\n>>> b\n⎡2⎤\n⎢ ⎥\n⎣0⎦\n>>> A.solve(b)\n⎡  2⋅e  ⎤\n⎢───────⎥\n⎢c⋅e + d⎥\n⎢       ⎥\n⎢   2   ⎥\n⎢───────⎥\n⎣c⋅e + d⎦\n```\n\n----------------------------------------\n\nTITLE: Applying Loads and Forces to Multi-DOF Holonomic System in Python\nDESCRIPTION: This code applies various loads and forces to the system, including gravity, a linear spring and damper, rotational spring, and specified forces and torques. It uses the System class methods to add these loads.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/multi_degree_freedom_holonomic_system.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nsystem.apply_uniform_gravity(-g * wall.y)\nsystem.add_loads(Force(block, F * wall.x))\nspring_damper_path = LinearPathway(wall.masscenter, block.masscenter)\nsystem.add_actuators(\n    LinearSpring(k, spring_damper_path),\n    LinearDamper(c, spring_damper_path),\n    TorqueActuator(T, wall.z, compound_pend, wall),\n    TorqueActuator(kT * q3, wall.z, compound_pend, simple_pend_frame),\n)\n```\n\n----------------------------------------\n\nTITLE: Basic SymPy Usage Example in Python\nDESCRIPTION: Demonstrates a simple SymPy session where a symbolic variable is created, a trigonometric expression is defined, and a series expansion is computed. This showcases SymPy's core functionality for symbolic mathematics.\nSOURCE: https://github.com/sympy/sympy/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, cos\n>>> x = Symbol('x')\n>>> e = 1/cos(x)\n>>> print(e.series(x, 0, 10))\n1 + x**2/2 + 5*x**4/24 + 61*x**6/720 + 277*x**8/8064 + O(x**10)\n```\n\n----------------------------------------\n\nTITLE: Using Solveset for Basic Equations\nDESCRIPTION: Examples of using solveset to solve algebraic equations, showing different ways to express equations including Eq() and implicit zero equality.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/solvers.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsolveset(Eq(x**2, 1), x)\nsolveset(Eq(x**2 - 1, 0), x)\nsolveset(x**2 - 1, x)\n```\n\n----------------------------------------\n\nTITLE: Implementing Versine Function in SymPy\nDESCRIPTION: Implementation of the versine function class including evaluation, numerical computation, assumptions checking, rewriting rules, and differentiation. The versine function is defined as 1 - cos(x) or 2sin²(x/2).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Function, cos, expand_trig, Integer, pi, sin\nfrom sympy.core.logic import fuzzy_and, fuzzy_not\nclass versin(Function):\n    @classmethod\n    def eval(cls, x):\n        n = x/pi\n        if isinstance(n, Integer):\n            return 1 - (-1)**n\n\n    def _eval_evalf(self, prec):\n        return (2*sin(self.args[0]/2)**2)._eval_evalf(prec)\n\n    def _eval_is_nonnegative(self):\n        x = self.args[0]\n        if x.is_real is True:\n            return True\n\n    def _eval_is_positive(self):\n        x = self.args[0]\n        coeff, pi_ = x.as_independent(pi, as_Add=False)\n        if pi_ == pi:\n            return fuzzy_and([x.is_real, fuzzy_not(coeff.is_even)])\n        elif x.is_real is False:\n            return False\n\n    def _eval_rewrite(self, rule, args, **hints):\n        if rule == cos:\n            return 1 - cos(*args)\n        elif rule == sin:\n            return 2*sin(x/2)**2\n\n    def _eval_expand_trig(self, **hints):\n        x = self.args[0]\n        return expand_trig(1 - cos(x))\n\n    def as_real_imag(self, deep=True, **hints):\n        return self.rewrite(cos).as_real_imag(deep=deep, **hints)\n\n    def fdiff(self, argindex=1):\n        return sin(self.args[0])\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy Solving Functions and Symbols\nDESCRIPTION: Imports the necessary SymPy functions and symbols for equation solving examples. Includes the solve function, common mathematical functions like sqrt and exp, Symbol class, and Eq for equation creation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import sqrt, exp, solve, Symbol, Eq\nfrom sympy.abc import x, y, z, a, b\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of SymPy Geometry Module in Python\nDESCRIPTION: Demonstrates fundamental operations within the SymPy geometry module. It shows how to create Point objects, check for collinearity using `Point.is_collinear`, instantiate a Triangle, calculate its area, access its medians (as Segment objects), find the intersection of multiple lines (medians), create Circle and Line objects, check for tangency between a circle and a line using `is_tangent`, and find the intersection points between a circle and a line.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/geometry/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.geometry import *\n>>> x = Point(0, 0)\n>>> y = Point(1, 1)\n>>> z = Point(2, 2)\n>>> zp = Point(1, 0)\n>>> Point.is_collinear(x, y, z)\nTrue\n>>> Point.is_collinear(x, y, zp)\nFalse\n>>> t = Triangle(zp, y, x)\n>>> t.area\n1/2\n>>> t.medians[x]\nSegment2D(Point2D(0, 0), Point2D(1, 1/2))\n>>> m = t.medians\n>>> intersection(m[x], m[y], m[zp])\n[Point2D(2/3, 1/3)]\n>>> c = Circle(x, 5)\n>>> l = Line(Point(5, -5), Point(5, 5))\n>>> c.is_tangent(l) # is l tangent to c?\nTrue\n>>> l = Line(x, y)\n>>> c.is_tangent(l) # is l tangent to c?\nFalse\n>>> intersection(c, l)\n[Point2D(-5*sqrt(2)/2, -5*sqrt(2)/2), Point2D(5*sqrt(2)/2, 5*sqrt(2)/2)]\n```\n\n----------------------------------------\n\nTITLE: Calculating the Determinant of SymPy Matrices using det() in Python\nDESCRIPTION: Demonstrates calculating the determinant of SymPy `Matrix` objects using the `det()` method. Examples include a general 3x3 matrix, the identity matrix, and a singular matrix (determinant 0). Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Matrix(( [1, 2, 3], [3, 6, 2], [2, 0, 1] ))\n>>> M.det()\n-28\n>>> M2 = eye(3)\n>>> M2.det()\n1\n>>> M3 = Matrix(( [1, 0, 0], [1, 0, 0], [1, 0, 0] ))\n>>> M3.det()\n0\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Symbols in Python\nDESCRIPTION: Basic setup for using SymPy by importing the library and creating symbolic variables x, y, z.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/basic_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols(\"x y z\")\n```\n\n----------------------------------------\n\nTITLE: Finding All Roots Using the Poly Class Method all_roots in SymPy\nDESCRIPTION: Shows how to convert a SymPy expression into a `Poly` object and then use its `all_roots` method. This method returns a list containing all roots, including complex ones, with repetitions according to their multiplicities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> expression_complex_poly = Poly(expression_complex)\n>>> expression_complex_poly.all_roots()\n[3, -2*I, -2*I, 2*I, 2*I]\n```\n\n----------------------------------------\n\nTITLE: Finding Complex Roots and Multiplicities with roots in SymPy\nDESCRIPTION: Illustrates using the SymPy `roots` function to find all roots (including complex ones) of a polynomial. This function returns a dictionary where keys are the roots and values are their multiplicities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> roots(expression_complex, x)\n{3: 1, -2*I: 2, 2*I: 2}\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Function from SymPy Expression using lambdify (math backend)\nDESCRIPTION: Illustrates using `lambdify` to convert a SymPy expression into a standard Python function. By default, it uses the `math` standard library for numerical operations, offering significantly better performance than `subs`/`evalf`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.abc import x\n>>> expr = sin(x)/x\n>>> f = lambdify(x, expr)\n>>> f(3.14)\n0.000507214304614\n```\n\n----------------------------------------\n\nTITLE: Using Equality in SymPy with Eq() instead of = operator\nDESCRIPTION: Demonstrates how to properly represent mathematical equality in SymPy using Eq() rather than the assignment operator (=). The equals sign in Python assigns values to variables rather than creating mathematical equalities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.abc import x, y\na = x - y\nprint(a)\n```\n\n----------------------------------------\n\nTITLE: Performing QR Decomposition on SymPy Matrices in Python\nDESCRIPTION: Demonstrates performing QR decomposition on a SymPy `Matrix` `A` using the `A.QRdecomposition()` method. This method returns two matrices, `Q` (orthogonal) and `R` (upper triangular), such that `A = Q * R`. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> A = Matrix([[1,1,1],[1,1,3],[2,3,4]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\n[  ___     ___      ___ ]\n[\\/ 6   -\\/ 3    -\\/ 2  ]\n[-----  -------  -------]\n[  6       3        2   ]\n[                       ]\n[  ___     ___      ___ ]\n[\\/ 6   -\\/ 3     \\/ 2  ]\n[-----  -------   ----- ]\n[  6       3        2   ]\n[                       ]\n[  ___     ___          ]\n[\\/ 6    \\/ 3           ]\n[-----   -----      0   ]\n[  3       3            ]\n>>> R\n[           ___         ]\n\n```\n\n----------------------------------------\n\nTITLE: Converting Expressions to Holonomic Functions and Integrating - sympy.holonomic - Python\nDESCRIPTION: This snippet demonstrates transforming a rational function and the sine cardinal function (sin(x)/x) to their holonomic representations using expr_to_holonomic, integrating them, and then converting the integrals back into ordinary symbolic expressions. The code relies on importing variables from sympy.abc, functions like sin from sympy, and expr_to_holonomic from sympy.holonomic. Key parameters like the integrand and the variable of integration are clearly defined, and the essential workflow involves conversion, integration, and symbolic restoration. Limitations include possible failures converting back for some integrals or functions without closed holonomic forms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/uses.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x, a\n>>> from sympy import sin\n>>> from sympy.holonomic import expr_to_holonomic\n>>> expr_to_holonomic(1/(x**2+a), x).integrate(x).to_expr()\natan(x/sqrt(a))/sqrt(a)\n>>> expr_to_holonomic(sin(x)/x).integrate(x).to_expr()\nSi(x)\n```\n\n----------------------------------------\n\nTITLE: Symbol Equality with Different Assumptions\nDESCRIPTION: Demonstrates how symbols with the same name but different assumptions are considered distinct.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nx1 = Symbol('x', positive=True)\nx2 = Symbol('x')\nx1\nx2\nx1 == x2\n```\n\n----------------------------------------\n\nTITLE: Working with Critical Points\nDESCRIPTION: Demonstrates finding critical points of a function by solving its derivative and analyzing the results using substitution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-equation-algebraically.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x\n>>> from sympy import solve, diff\n>>> f = x**3 + x**2 - x\n>>> derivative = diff(f, x)\n>>> critical_points = solve(derivative, x, dict=True)\n>>> print(critical_points)\n[{x: -1}, {x: 1/3}]\n>>> point1, point2 = critical_points\n>>> print(f.subs(point1))\n1\n>>> print(f.subs(point2))\n-5/27\n>>> curvature = diff(f, x, 2)\n>>> print(curvature.subs(point1))\n-4\n>>> print(curvature.subs(point2))\n4\n```\n\n----------------------------------------\n\nTITLE: Converting SymPy Expression to NumPy Function using Lambdify\nDESCRIPTION: This snippet demonstrates the recommended workflow for using SymPy and NumPy together. First, a symbolic expression is constructed and manipulated using SymPy (e.g., differentiation). Then, `sympy.lambdify` is used to convert the symbolic expression into a Python function that can efficiently operate on NumPy arrays for numerical evaluation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> # First symbolically construct the expression you are interested in with SymPy\n>>> from sympy import diff, sin, exp, lambdify, symbols\n>>> x = symbols('x')\n>>> expr = diff(sin(x)*exp(x**2), x)\n\n>>> # Then convert it to a numeric function with lambdify()\n>>> f = lambdify(x, expr)\n\n>>> # Now use this function with NumPy\n>>> import numpy as np\n>>> a = np.linspace(0, 10)\n>>> f(a) # doctest: +SKIP\n[ 1.00000000e+00  1.10713341e+00  1.46699555e+00 ... -3.15033720e+44]\n```\n\n----------------------------------------\n\nTITLE: Using RootOf Objects to Find Exact Numerical Roots in SymPy\nDESCRIPTION: Using RootOf to represent roots exactly, even for polynomials that don't have radical solutions. This approach can provide all roots of a polynomial with known multiplicity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> [RootOf(expression, n) for n in range(3)]\n[-2, -2, 3]\n```\n\n----------------------------------------\n\nTITLE: Forming Lagrange's Equations of Motion in Python\nDESCRIPTION: Demonstrates how to generate the equations of motion using the LagrangesMethod object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/lagrange.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nmechanics_printing(pretty_print=False)\nLM.form_lagranges_equations()\n```\n\n----------------------------------------\n\nTITLE: Converting Expressions with Algebraic Numbers to Polynomials\nDESCRIPTION: Demonstrates how to handle algebraic numbers in polynomials by setting the extension parameter. This ensures proper treatment of algebraic numbers like square roots as elements of an extension field.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> e = x + sqrt(2)\n>>> e.as_poly()\nPoly(x + (sqrt(2)), x, sqrt(2), domain='ZZ')\n>>> e.as_poly(extension=True)\nPoly(x + sqrt(2), x, domain='QQ<sqrt(2)>')\n```\n\n----------------------------------------\n\nTITLE: Numerically Solving ODE System with SymPy and SciPy in Python\nDESCRIPTION: Demonstrates a workflow for solving an ODE system numerically. First, the system (representing chemical kinetics) is defined symbolically using SymPy. Then, `lambdify` converts the symbolic expressions for the derivatives into a numerical function compatible with SciPy. Finally, SciPy's `solve_ivp` is used to numerically integrate the ODE system given initial conditions and time points. The result is plotted using Matplotlib.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_15\n\nLANGUAGE: py\nCODE:\n```\n>>> from sympy import symbols, lambdify\n>>> import numpy as np\n>>> import scipy.integrate\n>>> import matplotlib.pyplot as plt\n>>> # Create symbols y0, y1, and y2\n>>> y = symbols('y:3')\n>>> kf, kb = symbols('kf kb')\n>>> rf = kf * y[0]**2 * y[1]\n>>> rb = kb * y[2]**2\n>>> # Derivative of the function y(t); values for the three chemical species\n>>> # for input values y, kf, and kb\n>>> ydot = [2*(rb - rf), rb - rf, 2*(rf - rb)]\n>>> ydot\n[2*kb*y2**2 - 2*kf*y0**2*y1, kb*y2**2 - kf*y0**2*y1, -2*kb*y2**2 + 2*kf*y0**2*y1]\n>>> t = symbols('t') # not used in this case\n>>> # Convert the SymPy symbolic expression for ydot into a form that\n>>> # SciPy can evaluate numerically, f\n>>> f = lambdify((t, y, kf, kb), ydot)\n>>> k_vals = np.array([0.42, 0.17]) # arbitrary in this case\n>>> y0 = [1, 1, 0] # initial condition (initial values)\n>>> t_eval = np.linspace(0, 10, 50) # evaluate integral from t = 0-10 for 50 points\n>>> # Call SciPy's ODE initial value problem solver solve_ivp by passing it\n>>> #   the function f,\n>>> #   the interval of integration,\n>>> #   the initial state, and\n>>> #   the arguments to pass to the function f\n>>> solution = scipy.integrate.solve_ivp(f, (0, 10), y0, t_eval=t_eval, args=k_vals)\n>>> # Extract the y (concentration) values from SciPy solution result\n>>> y = solution.y\n>>> # Plot the result graphically using matplotlib\n>>> plt.plot(t_eval, y.T) # doctest: +SKIP\n>>> # Add title, legend, and axis labels to the plot\n>>> plt.title('Chemical Kinetics') # doctest: +SKIP\n>>> plt.legend(['NO', 'Br$_2$', 'NOBr'], shadow=True) # doctest: +SKIP\n>>> plt.xlabel('time') # doctest: +SKIP\n>>> plt.ylabel('concentration') # doctest: +SKIP\n>>> # Finally, display the annotated plot\n>>> plt.show()\n```\n\n----------------------------------------\n\nTITLE: Evaluating Symbolic Solutions Numerically in Python\nDESCRIPTION: This example shows how to evaluate a symbolic solution numerically to obtain its approximate value. This helps to understand the magnitude of complex expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import pi, sqrt, exp, solve, evalf\n>>> shorter = solve(sqrt(2)*x - exp(pi), x, dict=True)\n>>> shorter\n[{x: sqrt(2)*exp(pi)/2}]\n>>> [solution[x].evalf(3) for solution in shorter]\n[16.4]\n```\n\n----------------------------------------\n\nTITLE: Solving and Using Results in a Dictionary\nDESCRIPTION: Demonstrates how to solve a system of equations and access the results stored in a dictionary format. This method is recommended for programmatic extraction of solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x, y, z\n>>> equations = [x**2 + y - 2*z, y + 4*z]\n>>> solutions = solve(equations, x, y, dict=True)\n>>> solutions\n[{x: -sqrt(6)*sqrt(z), y: -4*z}, {x: sqrt(6)*sqrt(z), y: -4*z}]\n>>> solutions[0][x]\n-sqrt(6)*sqrt(z)\n>>> solutions[0][y]\n-4*z\n```\n\n----------------------------------------\n\nTITLE: Enhanced Zero Testing with Exponential Rewriting in SymPy\nDESCRIPTION: Implements an improved zero testing function that rewrites expressions in exponential form and applies simplification. Demonstrates a more robust approach for handling hyperbolic functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef my_iszero(x):\n    result = x.rewrite(exp).simplify().is_zero\n\n    # Warnings if evaluated into None\n    if result is None:\n        warnings.warn(\"Zero testing of {} evaluated into None\".format(x))\n    return result\n\nm.nullspace(iszerofunc=my_iszero) # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System Using LU Decomposition in Python\nDESCRIPTION: This snippet demonstrates how to solve a linear system Ax=b using the LUsolve method in SymPy. It creates a matrix A, a vector x, computes b, and then solves for x using A.LUsolve(b).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> A = Matrix([ [2, 3, 5], [3, 6, 2], [8, 3, 6] ])\n>>> x = Matrix(3,1,[3,7,5])\n>>> b = A*x\n>>> soln = A.LUsolve(b)\n>>> soln\n[3]\n[ ]\n[7]\n[ ]\n[5]\n```\n\n----------------------------------------\n\nTITLE: Polynomial Factorization in SymPy\nDESCRIPTION: Demonstrates factorization of univariate and multivariate polynomials with rational coefficients using the factor function in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> factor(x**4/2 + 5*x**3/12 - x**2/3)\n 2\nx *(2*x - 1)*(3*x + 4)\n----------------------\n          12\n\n>>> factor(x**2 + 4*x*y + 4*y**2)\n         2\n(x + 2*y)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Simulation Results with Matplotlib\nDESCRIPTION: Creates a multi-panel plot showing the simulation results: muscle length, velocity, activation, and force over time. Demonstrates how the muscle pulls the mass against gravity until reaching equilibrium.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(4, 1, sharex=True)\n_ = axes[0].plot(sol.t, sol.y[0] - p_vals[4], label='length of muscle')\n_ = axes[0].set_ylabel('Distance [m]')\n_ = axes[1].plot(sol.t, sol.y[1], label=state[1])\n_ = axes[1].set_ylabel('Speed [m/s]')\n_ = axes[2].plot(sol.t, sol.y[2], label=state[2])\n_ = axes[2].set_ylabel('Activation')\n_ = axes[3].plot(sol.t, eval_force(sol.y, p_vals).T, label='force')\n_ = axes[3].set_ylabel('Force [N]')\n_ = axes[3].set_xlabel('Time [s]')\n_ = axes[0].legend(), axes[1].legend(), axes[2].legend(), axes[3].legend()\n```\n\n----------------------------------------\n\nTITLE: Creating Symbol with Inferred Positive Assumption in Python\nDESCRIPTION: This snippet demonstrates how SymPy infers assumptions based on given predicates. Here, a symbol 'x' is created with 'real=True', 'negative=False', and 'zero=False', from which SymPy infers that 'x' must be positive.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x', real=True, negative=False, zero=False)\nx.is_positive\n```\n\n----------------------------------------\n\nTITLE: Numerically Solving a Single Equation with SymPy in Python\nDESCRIPTION: Demonstrates how to use SymPy's nsolve function to find a numeric solution for the equation cos(x) = x. The solution is approximately 0.739085133215161.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import cos, nsolve, Symbol\n>>> x = Symbol('x')\n>>> nsolve(cos(x) - x, x, 1)\n0.739085133215161\n```\n\n----------------------------------------\n\nTITLE: Integrating Multiple Polynomials over 2D Polygon\nDESCRIPTION: Shows how to integrate a list of specified polynomials over a 2D polygon, with a maximum degree specified.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\npolytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), [3, x*y + y**2, x**4], max_degree=4)\npolytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), [1.125, x, x**2, 6.89*x**3, x*y + y**2, x**4], max_degree=4)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Trigonometric Expression with Integer Assumption in Python\nDESCRIPTION: This snippet demonstrates how assumptions can lead to significant simplifications in SymPy, comparing the simplification of sin(n*pi) with and without the integer assumption.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import sin, pi\nn1 = Symbol('n1')\nn2 = Symbol('n2', integer=True)\nsin(n1 * pi)\nsin(n2 * pi)\n```\n\n----------------------------------------\n\nTITLE: Performing Matrix-Vector Multiplication with SymPy Matrices in Python\nDESCRIPTION: Illustrates matrix-vector multiplication using SymPy `Matrix` objects. A 3x3 matrix `M` is multiplied by a 3x1 column vector `M2`. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> M2 = Matrix(3,1,[1,5,0])\n>>> M*M2\n[11]\n[  ]\n[29]\n[  ]\n[47]\n```\n\n----------------------------------------\n\nTITLE: Slicing Submatrices in SymPy using Python Slice Notation\nDESCRIPTION: Illustrates how to extract submatrices from a SymPy `Matrix` using Python's slice notation `[row_slice, col_slice]`. Examples show slicing a 2x2 block, handling empty slices (`2:2`), extracting a full column (`[:, 2]`), and extracting part of a column (`[:1, 2]`). Slices always return a `Matrix` object. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> M[0:2, 0:2]\n[1  2]\n[    ]\n[4  5]\n>>> M[2:2, 2]\n[]\n>>> M[:, 2]\n[3]\n[ ]\n[6]\n>>> M[:1, 2]\n[3]\n```\n\n----------------------------------------\n\nTITLE: Creating a Function for SciPy Numerical Solving from SymPy in Python\nDESCRIPTION: Shows a workflow to create a function that can be solved numerically with SciPy. It involves using SymPy for symbolic simplification, lambdify for conversion, and SciPy for numerical solving.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import simplify, cos, sin, lambdify\n>>> from sympy.abc import x, y\n>>> from scipy.optimize import root_scalar\n>>> expr = cos(x * (x + x**2)/(x*sin(y)**2 + x*cos(y)**2 + x))\n>>> simplify(expr) # 1. symbolically simplify expression\ncos(x*(x + 1)/2)\n>>> lam_f = lambdify(x, cos(x*(x + 1)/2)) # 2. lambdify\n>>> sol = root_scalar(lam_f, bracket=[0, 2]) # 3. numerically solve using SciPy\n>>> sol.root\n1.3416277185114782\n```\n\n----------------------------------------\n\nTITLE: Performing Dimensional Analysis with SymPy Units (Python)\nDESCRIPTION: This snippet demonstrates how to perform dimensional analysis using SymPy's physics units module. It defines dimensions for mass, acceleration, and force, calculates the dimension of force using F=ma, and retrieves its fundamental dimensional dependencies (Length, Mass, Time) using the SI dimension system (`dimsys_SI`). It also shows how to compare dimensions for equivalence and sets up the gravitational force equation to determine the dimensions of the gravitational constant G.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/examples.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.physics.units.systems import SI\n>>> from sympy.physics.units import length, mass, acceleration, force\n>>> from sympy.physics.units import gravitational_constant as G\n>>> from sympy.physics.units.systems.si import dimsys_SI\n>>> F = mass*acceleration\n>>> F\nDimension(acceleration*mass)\n>>> dimsys_SI.get_dimensional_dependencies(F)\n{Dimension(length): 1, Dimension(mass, M): 1, Dimension(time): -2}\n>>> dimsys_SI.get_dimensional_dependencies(force)\n{Dimension(length): 1, Dimension(mass): 1, Dimension(time): -2}\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> F == force\nFalse\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> dimsys_SI.equivalent_dims(F, force)\nTrue\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> m1, m2, r = symbols(\"m1 m2 r\")\n>>> grav_eq = G * m1 * m2 / r**2\n>>> F2 = grav_eq.subs({m1: mass, m2: mass, r: length, G: G.dimension})\n>>> F2  #doctest: +SKIP\nDimension(mass*length*time**-2)\n>>> F2.get_dimensional_dependencies()  #doctest: +SKIP\n{'length': 1, 'mass': 1, 'time': -2}\n```\n\n----------------------------------------\n\nTITLE: Finding and Representing Polynomial Roots Using SymPy\nDESCRIPTION: Shows how to use real_roots() and Poly.all_roots() to find roots of a fifth-order polynomial exactly. The RootOf objects allow precise symbolic representation of roots that can be manipulated and categorized.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import init_printing\n>>> init_printing()\n>>> real_roots(fifth_order)\n        / 5           \\\n[CRootOf\\x  - x + 1, 0/]\n>>> r = r0, r1, r2, r3, r4 = Poly(fifth_order, x).all_roots(); r\n        / 5           \\         / 5           \\         / 5           \\         / 5           \\         / 5           \\\n[CRootOf\\x  - x + 1, 0/, CRootOf\\x  - x + 1, 1/, CRootOf\\x  - x + 1, 2/, CRootOf\\x  - x + 1, 3/, CRootOf\\x  - x + 1, 4/]\n>>> r0\n       / 5           \\\nCRootOf\\x  - x + 1, 0/\n```\n\n----------------------------------------\n\nTITLE: Performing Basic Arithmetic Operations on SymPy Matrices in Python\nDESCRIPTION: Demonstrates standard arithmetic operations on SymPy `Matrix` objects: subtraction (`M - M`), addition (`M + M`), and matrix multiplication (`M * M`). Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Matrix(([1,2,3],[4,5,6],[7,8,9]))\n>>> M - M\n[0  0  0]\n[       ]\n[0  0  0]\n[       ]\n[0  0  0]\n>>> M + M\n[2   4   6 ]\n[          ]\n[8   10  12]\n[          ]\n[14  16  18]\n>>> M * M\n[30   36   42 ]\n[             ]\n[66   81   96 ]\n[             ]\n[102  126  150]\n```\n\n----------------------------------------\n\nTITLE: Using C Code Printer in SymPy\nDESCRIPTION: Example showing how to convert mathematical expressions to C code using the print_ccode function. This snippet demonstrates printing simple expressions, assigning results to variables, and using different C standards.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.printing import print_ccode\n>>> from sympy.functions import sin, cos, Abs, gamma\n>>> from sympy.abc import x\n>>> print_ccode(sin(x)**2 + cos(x)**2, standard='C89')\npow(sin(x), 2) + pow(cos(x), 2)\n>>> print_ccode(2*x + cos(x), assign_to=\"result\", standard='C89')\nresult = 2*x + cos(x);\n>>> print_ccode(Abs(x**2), standard='C89')\nfabs(pow(x, 2))\n>>> print_ccode(gamma(x**2), standard='C99')\ntgamma(pow(x, 2))\n```\n\n----------------------------------------\n\nTITLE: Gram-Schmidt Orthogonalization in Python using SymPy\nDESCRIPTION: This code snippet demonstrates the Gram-Schmidt orthogonalization process using SymPy. It creates a set of vectors, applies the GramSchmidt function to orthogonalize them, and then checks the orthogonality and normality of the resulting vectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> A = Matrix([ [2, 3, 5], [3, 6, 2], [8, 3, 6] ])\n>>> x = Matrix(3,1,[3,7,5])\n>>> b = A*x\n>>> soln = A.LUsolve(b)\n>>> soln\n[3]\n[ ]\n[7]\n[ ]\n[5]\n\n>>> L = [Matrix([2, 3, 5]), Matrix([3, 6, 2]), Matrix([8, 3, 6])]\n>>> out1 = GramSchmidt(L)\n>>> out2 = GramSchmidt(L, True)\n\n>>> for i in out1:\n...     print(i)\n...\nMatrix([[2], [3], [5]])\nMatrix([[23/19], [63/19], [-47/19]])\nMatrix([[1692/353], [-1551/706], [-423/706]])\n>>> for i in out2:\n...      print(i)\n...\nMatrix([[sqrt(38)/19], [3*sqrt(38)/38], [5*sqrt(38)/38]])\nMatrix([[23*sqrt(6707)/6707], [63*sqrt(6707)/6707], [-47*sqrt(6707)/6707]])\nMatrix([[12*sqrt(706)/353], [-11*sqrt(706)/706], [-3*sqrt(706)/706]])\n\n>>> out1[0].dot(out1[1])\n0\n>>> out1[0].dot(out1[2])\n0\n>>> out1[1].dot(out1[2])\n0\n>>> out2[0].norm()\n1\n>>> out2[1].norm()\n1\n>>> out2[2].norm()\n1\n```\n\n----------------------------------------\n\nTITLE: Handling Equations Without Closed-Form Solutions Using nsolve in Python\nDESCRIPTION: This example demonstrates how to use nsolve to find a numerical solution for cos(x) - x = 0, which has no closed-form solution expressible in terms of elementary functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve, cos\n>>> from sympy.abc import x\n>>> solve(cos(x) - x, x, dict=True)\nTraceback (most recent call last):\n  ...\nNotImplementedError: multiple generators [x, cos(x)]\nNo algorithms are implemented to solve equation -x + cos(x)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import nsolve, cos\n>>> from sympy.abc import x\n>>> nsolve(cos(x) - x, x, 2)\n0.739085133215161\n```\n\n----------------------------------------\n\nTITLE: Discrete Transforms Implementation in SymPy\nDESCRIPTION: Collection of transform functions including Fast Fourier Transform (FFT/IFFT), Number Theoretic Transform (NTT/INTT), Fast Walsh Hadamard Transform (FWHT/IFWHT), and Möbius Transform with their inverse operations. These transforms are used for efficient computation of discrete sequences.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/discrete.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.discrete.transforms import (\n    fft, ifft,\n    ntt, intt,\n    fwht, ifwht,\n    mobius_transform, inverse_mobius_transform\n)\n```\n\n----------------------------------------\n\nTITLE: Simplifying and Printing Auxiliary Equations\nDESCRIPTION: This code defines a function to simplify the auxiliary equations and applies it to print the simplified results of the constraint forces.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import trigsimp, signsimp, collect, factor_terms\ndef simplify_auxiliary_eqs(w):\n    return signsimp(trigsimp(collect(collect(factor_terms(w), f2), m*r)))\nmprint(KM.auxiliary_eqs.applyfunc(simplify_auxiliary_eqs))\n```\n\n----------------------------------------\n\nTITLE: Extracting Common Factors from SymPy Matrix Elements using GCD in Python\nDESCRIPTION: Demonstrates how to find and extract a common factor from the elements of a symbolic SymPy `Matrix`. It first calculates the inverse of a matrix with symbolic entries, then uses `sympy.gcd` on a tuple of its flattened elements (`tuple(_)`) to find the common denominator, and finally divides the matrix by this common factor. Requires `sympy.abc`, `sympy.gcd`, and `sympy.Matrix`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x, y\n>>> from sympy import gcd\n>>> m = Matrix([[x, y], [1, x*y]]).inv('ADJ'); m\n[  x*y       -y    ]\n[--------  --------]\n[ 2         2      ]\n[x *y - y  x *y - y]\n[                  ]\n[  -1         x    ]\n[--------  --------]\n[ 2         2      ]\n[x *y - y  x *y - y]\n>>> gcd(tuple(_))\n       1\n    --------\n     2\n    x *y - y\n>>> m/_\n[x*y  -y]\n[       ]\n[-1   x ]\n```\n\n----------------------------------------\n\nTITLE: Calculating Eigenvalues of Linearized Bicycle Model in SymPy\nDESCRIPTION: Extracts the relevant parts of the linearized system matrix and calculates eigenvalues for different forward speeds. This analysis reveals the stability characteristics of the bicycle model at various speeds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nA = Amat.extract([1, 2, 3, 5], [1, 2, 3, 5])\nA\nprint('v = 1')\nprint(A.subs(v, 1).eigenvals())\nprint('v = 2')\nprint(A.subs(v, 2).eigenvals())\nprint('v = 3')\nprint(A.subs(v, 3).eigenvals())\nprint('v = 4')\nprint(A.subs(v, 4).eigenvals())\nprint('v = 5')\nprint(A.subs(v, 5).eigenvals())\n```\n\n----------------------------------------\n\nTITLE: Handling Singularities in Symbolic Expressions in Python\nDESCRIPTION: This snippet illustrates how singularities can occur in symbolic expressions during linearization, and demonstrates techniques to avoid them using simplification or smart substitution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import sin, tan\n>>> expr = sin(q1)/tan(q1)\n>>> op_point = {q1: 0}\n>>> expr.subs(op_point)\nnan\n\n>>> expr.simplify().subs(op_point)\n1\n\n>>> msubs(expr, op_point, smart=True)\n1\n```\n\n----------------------------------------\n\nTITLE: Handling Matrix Equations with No Solution\nDESCRIPTION: Demonstrates the error that occurs when attempting to solve a matrix equation with a singular matrix (determinant of zero), which indicates that the system has no unique solution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.matrices import Matrix\n>>> c, d, e = symbols(\"c, d, e\")\n>>> A = Matrix([[c*e**2, d*e], [c*e, d]])\n>>> A\n    ⎡   2     ⎤\n    ⎢c⋅e   d⋅e⎥\n    ⎢         ⎥\n    ⎣c⋅e    d ⎦\n>>> b = Matrix([2, 0])\n>>> A.LUsolve(b)\nTraceback (most recent call last):\n    ...\nNonInvertibleMatrixError: Matrix det == 0; not invertible.\n```\n\n----------------------------------------\n\nTITLE: Analyzing SymPy Expression Structure in Python\nDESCRIPTION: Shows how to examine the structure of a SymPy expression by accessing its func and args attributes, and demonstrates expression reconstruction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nexpr = 3*y**2*x\nexpr.func\n# Output: <class 'sympy.core.mul.Mul'>\nexpr.args\n# Output: (3, x, y**2)\n\nexpr.func(*expr.args)\n# Output: 3*x*y**2\nexpr == expr.func(*expr.args)\n# Output: True\n\nexpr = y**2*3*x\nexpr.args\n# Output: (3, x, y**2)\n\nexpr.args[2]\n# Output: y**2\nexpr.args[2].args\n# Output: (y, 2)\n\ny.args\n# Output: ()\nInteger(2).args\n# Output: ()\n```\n\n----------------------------------------\n\nTITLE: Matrix Operations and Manipulation\nDESCRIPTION: Demonstrates basic matrix operations including multiplication, accessing and modifying rows/columns. Shows both in-place and returning operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nM = Matrix([[1, 2, 3], [3, 2, 1]])\nN = Matrix([0, 1, 1])\nM*N\n\nM.row(0)\nM.col(-1)\n\nM.col_del(0)\nM.row_del(1)\n```\n\n----------------------------------------\n\nTITLE: Creating Fully Evaluated Functions in Python\nDESCRIPTION: Demonstrates how to create a fully evaluated function using a normal Python function definition. This is suitable for functions that always evaluate to a value.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> def f(x):\n...     if x == 0:\n...         return 0\n...     else:\n...         return x + 1\n\n>>> f(0)\n0\n>>> f(1)\n2\n>>> f(x)\nx + 1\n```\n\n----------------------------------------\n\nTITLE: Variable Interval Specification for SymPy Plots\nDESCRIPTION: Shows different ways to specify variable intervals when creating plots. The examples demonstrate the flexible syntax for defining the domain of variables in plots.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nPlot(x**2) # implies [x,-5,5,100]\nPlot(x**2, [], []) # [x,-1,1,40], [y,-1,1,40]\nPlot(x**2-y**2, [100], [100]) # [x,-1,1,100], [y,-1,1,100]\nPlot(x**2, [x,-13,13,100])\nPlot(x**2, [-13,13]) # [x,-13,13,100]\nPlot(x**2, [x,-13,13]) # [x,-13,13,100]\nPlot(1*x, [], [x], 'mode=cylindrical') # [unbound_theta,0,2*Pi,40], [x,-1,1,20]\n```\n\n----------------------------------------\n\nTITLE: Finding and Evaluating the Real Root of a Quintic using real_roots\nDESCRIPTION: Illustrates using `real_roots` to efficiently find only the real root(s) of a higher-order polynomial, represented as a `CRootOf` object. The real root is then evaluated numerically using `.n()`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> real_root = real_roots(fifth_order, x)\n>>> real_root\n[CRootOf(x**5 - x + 1, 0)]\n>>> real_root[0].n(10)\n-1.167303978\n```\n\n----------------------------------------\n\nTITLE: Solving ODEs with Initial Conditions Using Option 1 Syntax\nDESCRIPTION: Demonstrates how to solve a system of ODEs with initial conditions f(0) = 1 and g(2) = 3 using the ics parameter with option 1 syntax (defining functions without their independent variables).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Eq, Function, dsolve\n>>> f, g = symbols(\"f g\", cls=Function)\n>>> x = symbols(\"x\")\n>>> eqs = [Eq(f(x).diff(x), g(x)), Eq(g(x).diff(x), f(x))]\n>>> dsolve(eqs, [f(x), g(x)])\n[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]\n>>> dsolve(eqs, [f(x), g(x)], ics={f(0): 1, g(2): 3})\n[Eq(f(x), (1 + 3*exp(2))*exp(x)/(1 + exp(4)) - (-exp(4) + 3*exp(2))*exp(-x)/(1 + exp(4))), Eq(g(x), (1 + 3*exp(2))*exp(x)/(1 + exp(4)) + (-exp(4) + 3*exp(2))*exp(-x)/(1 + exp(4)))]\n```\n\n----------------------------------------\n\nTITLE: Increasing Precision of Numerical Solutions with SymPy in Python\nDESCRIPTION: Demonstrates how to increase the precision of the numerical solution using the 'prec' parameter in nsolve. This is useful when higher accuracy is required.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, nsolve\n>>> x1 = Symbol('x1')\n>>> x2 = Symbol('x2')\n>>> f1 = 3 * x1**2 - 2 * x2**2 - 1\n>>> f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8\n>>> print(nsolve((f1, f2), (x1, x2), (-1, 1), prec=25))\nMatrix([[-1.192873099352460791205211], [1.278444111699106966687122]])\n```\n\n----------------------------------------\n\nTITLE: Linearizing with LagrangesMethod Linearizer in Python\nDESCRIPTION: This snippet demonstrates how to create a Linearizer object from LagrangesMethod and use it to linearize a system. It specifies independent coordinates and speeds, and returns the linearized state matrices A and B.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> linearizer = LM.to_linearizer(q_ind=[q1], qd_ind=[q1d])\n\n>>> A, B = linearizer.linearize(A_and_B=True, op_point=op_point)\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]])\n```\n\n----------------------------------------\n\nTITLE: Symbol Creation with Assumptions in SymPy\nDESCRIPTION: Shows how to create symbols with specific assumptions and how simplification behavior changes based on assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Symbol, simplify\nx = Symbol('x')\nsqrt(x**2)\nsimplify(sqrt(x**2))\ny = Symbol('y', positive=True)\nsqrt(y**2)\n```\n\n----------------------------------------\n\nTITLE: Creating a CuPy-aware Function using lambdify for GPU Computation in Python\nDESCRIPTION: Demonstrates using `lambdify` with the 'cupy' backend to generate a function suitable for GPU execution via the CuPy library. This requires CuPy installation and allows leveraging CUDA for accelerating computations on compatible hardware.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> f = lambdify(x, expr, \"cupy\")\n>>> import cupy as cp\n>>> data = cp.linspace(1, 10, 10000)\n>>> y = f(data) # perform the computation\n>>> cp.asnumpy(y) # explicitly copy from GPU to CPU / numpy array\n[ 0.84147098  0.84119981  0.84092844 ... -0.05426074 -0.05433146\n -0.05440211]\n```\n\n----------------------------------------\n\nTITLE: Obtaining Mass Matrix and Forcing Vector in Lagrange's Method\nDESCRIPTION: Shows how to retrieve the mass matrix and forcing vector from the LagrangesMethod object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/lagrange.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nLM.mass_matrix\nLM.forcing\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Fixed-Ends Beam with Center Point Load using SymPy\nDESCRIPTION: This example shows how to analyze a beam fixed at both ends with a concentrated point load at the midpoint. It calculates reaction forces, moments, shear force, bending moment, slope, and deflection for a beam with fixed boundary conditions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I, F = symbols('E I F')\n>>> l = symbols('l', positive=True)\n>>> b = Beam(l, E, I)\n>>> R1,R2 = symbols('R1  R2')\n>>> M1, M2 = symbols('M1, M2')\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(M1, 0, -2)\n>>> b.apply_load(R2, l, -1)\n>>> b.apply_load(M2, l, -2)\n>>> b.apply_load(-F, l/2, -1)\n>>> b.bc_deflection = [(0, 0),(l, 0)]\n>>> b.bc_slope = [(0, 0),(l, 0)]\n>>> b.solve_for_reaction_loads(R1, R2, M1, M2)\n>>> b.reaction_loads\n⎧    -F⋅l       F⋅l      F      F⎫\n⎨M₁: ─────, M₂: ───, R₁: ─, R₂: ─⎬\n⎩      8         8       2      2⎭\n\n>>> b.load\n         -2               -2        -1              -1             -1\n  F⋅l⋅<x>     F⋅l⋅<-l + x>     F⋅<x>          l          F⋅<-l + x>\n- ───────── + ────────────── + ─────── - F⋅<- ─ + x>   + ────────────\n      8             8             2           2               2\n\n>>> b.shear_force()\n         -1               -1        0              0             0\n  F⋅l⋅<x>     F⋅l⋅<-l + x>     F⋅<x>         l         F⋅<-l + x>\n  ───────── - ────────────── - ────── + F⋅<- ─ + x>  - ───────────\n      8             8            2           2              2\n\n>>> b.bending_moment()\n         0               0        1              1             1\n  F⋅l⋅<x>    F⋅l⋅<-l + x>    F⋅<x>         l         F⋅<-l + x>\n  ──────── - ───────────── - ────── + F⋅<- ─ + x>  - ───────────\n     8             8           2           2              2\n\n>>> b.slope()\n ⎛                                               2              ⎞\n ⎜                                         l                    ⎟\n ⎜       1               1        2   F⋅<- ─ + x>              2⎟\n ⎜F⋅l⋅<x>    F⋅l⋅<-l + x>    F⋅<x>         2         F⋅<-l + x> ⎟\n-⎜──────── - ───────────── - ────── + ──────────── - ───────────⎟\n ⎝   8             8           4           2              4     ⎠\n──────────────────────────────────────────────────────────────────\n                               E⋅I\n\n>>> b.deflection()\n ⎛                                               3              ⎞\n ⎜                                         l                    ⎟\n ⎜       2               2        3   F⋅<- ─ + x>              3⎟\n ⎜F⋅l⋅<x>    F⋅l⋅<-l + x>    F⋅<x>         2         F⋅<-l + x> ⎟\n-⎜──────── - ───────────── - ────── + ──────────── - ───────────⎟\n ⎝   16            16          12          6              12    ⎠\n──────────────────────────────────────────────────────────────────\n                               E⋅I\n```\n\n----------------------------------------\n\nTITLE: Polynomial Division with Rational Coefficients in SymPy\nDESCRIPTION: Demonstrates polynomial division with rational coefficients using the div function in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 5*x**2 + 10*x + 3\n>>> g = 2*x + 2\n\n>>> q, r = div(f, g, domain='QQ')\n>>> q\n5*x   5\n--- + -\n 2    2\n>>> r\n-2\n>>> (q*g + r).expand()\n   2\n5*x  + 10*x + 3\n```\n\n----------------------------------------\n\nTITLE: Symbol Substitution\nDESCRIPTION: Shows the correct way to substitute values into symbolic expressions using the subs() method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nx = symbols('x')\nexpr = x + 1\nexpr.subs(x, 2)\n```\n\n----------------------------------------\n\nTITLE: Computing GCD of Polynomials in SymPy\nDESCRIPTION: Shows how to use the gcd function to compute the greatest common divisor of univariate polynomials over a field in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 4*x**2 - 1\n>>> g = 8*x**3 + 1\n>>> gcd(f, g, domain=QQ)\nx + 1/2\n```\n\n----------------------------------------\n\nTITLE: Basic 2D Plotting with SymPy\nDESCRIPTION: Shows the simplest usage of the plotting module to create a 2D plot. This example initializes variables and creates a simple mathematical plot using the PygletPlot class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import var\nfrom sympy.plotting.pygletplot import PygletPlot as Plot\nvar('x y z')\nPlot(x*y**3-y*x**3)\n```\n\n----------------------------------------\n\nTITLE: Computing Scalar Potential Difference in SymPy\nDESCRIPTION: This snippet shows how to compute the scalar potential difference between two points in space for a given conservative vector field using SymPy's scalar_potential_difference function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame, Point\n>>> from sympy.physics.vector import scalar_potential_difference\n>>> R = ReferenceFrame('R')\n>>> O = Point('O')\n>>> P = O.locatenew('P', 1*R.x + 2*R.y + 3*R.z)\n>>> vectfield = 4*R[0]*R[1]*R.x + 2*R[0]**2*R.y\n>>> scalar_potential_difference(vectfield, R, O, P, O)\n4\n```\n\n----------------------------------------\n\nTITLE: Generating Nonlinear Equations of Motion for Bicycle Model using Kane's Method in SymPy\nDESCRIPTION: Uses Kane's method to generate the nonlinear equations of motion for the bicycle model. It specifies independent and dependent coordinates and speeds, along with constraints and kinematic differential equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nkane = me.KanesMethod(\n    N,\n    q_ind=[q1, q2, q5],\n    q_dependent=[q4],\n    configuration_constraints=conlist_coord,\n    u_ind=[u2, u3, u5],\n    u_dependent=[u1, u4, u6],\n    velocity_constraints=conlist_speed,\n    kd_eqs=kd,\n    constraint_solver='CRAMER')\nfr, frstar = kane.kanes_equations(bodies, loads=forces)\n```\n\n----------------------------------------\n\nTITLE: Constructing Kinematic Equations with SymPy Mechanics in Python\nDESCRIPTION: These snippets demonstrate the construction of common kinematic equations using SymPy mechanics' predefined time symbol ('me.dynamicsymbols._t'). 's = u*t + a*t**2/2' represents position under constant acceleration. Dependencies: 'me' mechanics module, symbolic variables. Inputs: initial velocity 'u', acceleration 'a', and time 't'. Outputs: symbolic expression for position.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nt = me.dynamicsymbols._t\n```\n\nLANGUAGE: python\nCODE:\n```\ns = u*t + a*t**2/2\n```\n\n----------------------------------------\n\nTITLE: Creating Nonnegative Real Symbol in Python\nDESCRIPTION: This snippet demonstrates how to properly create a nonnegative real symbol in SymPy, showing the implied assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x', real=True, negative=False)\nprint(x.is_negative)\nprint(x.is_nonnegative)\nprint(x.is_real)\nprint(x.is_complex)\nprint(x.is_finite)\n```\n\n----------------------------------------\n\nTITLE: Handling Systems with No Solution\nDESCRIPTION: Demonstrates how SymPy handles systems of equations with no solution, returning an empty list. This example shows two cases where the equations are contradictory.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x, y\n>>> solve([x + y - 1, x + y], [x, y], dict=True)\n[]\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import solve\nfrom sympy.abc import x, y, z\nsolve([x + y - (z + 1), x + y - z)], [x, y], dict=True)\n[]\n```\n\n----------------------------------------\n\nTITLE: Solving Equations with Results in a Set\nDESCRIPTION: Shows how to solve a system of equations and get the results as a set of solutions, along with a list of symbols. This method uses the set=True parameter in the solve function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import solve\nfrom sympy.abc import x, y, z\nsolve([x**2 + y - 2*z, y + 4*z], [x, y], set=True)\n([x, y], {(-sqrt(6)*sqrt(z), -4*z), (sqrt(6)*sqrt(z), -4*z)})\n```\n\n----------------------------------------\n\nTITLE: Finding Approximate Numeric Roots of a Quintic Polynomial with nroots\nDESCRIPTION: Demonstrates using `nroots` to find numerical approximations of all roots (real and complex) for a higher-order (quintic) polynomial, where symbolic solutions might not exist in radicals.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import roots, solve, real_roots, nroots\n>>> from sympy.abc import x\n>>> fifth_order = x**5 - x + 1\n>>> nroots(fifth_order)\n[-1.16730397826142,\n -0.181232444469875 - 1.08395410131771*I,\n -0.181232444469875 + 1.08395410131771*I,\n 0.764884433600585 - 0.352471546031726*I,\n 0.764884433600585 + 0.352471546031726*I]\n```\n\n----------------------------------------\n\nTITLE: Using sympy.abc for Common Symbol Names\nDESCRIPTION: Demonstrates importing predefined symbols from sympy.abc module, which provides a convenient way to access commonly used mathematical symbols without explicit definition.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.abc import w\nw\nw\nimport sympy\ndir(sympy.abc)  #doctest: +SKIP\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n'P', 'Q', 'R', 'S', 'Symbol', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n'__builtins__', '__doc__', '__file__', '__name__', '__package__', '_greek',\n'_latin', 'a', 'alpha', 'b', 'beta', 'c', 'chi', 'd', 'delta', 'e',\n'epsilon', 'eta', 'f', 'g', 'gamma', 'h', 'i', 'iota', 'j', 'k', 'kappa',\n'l', 'm', 'mu', 'n', 'nu', 'o', 'omega', 'omicron', 'p', 'phi', 'pi',\n'psi', 'q', 'r', 'rho', 's', 'sigma', 't', 'tau', 'theta', 'u', 'upsilon',\n'v', 'w', 'x', 'xi', 'y', 'z', 'zeta']\n```\n\n----------------------------------------\n\nTITLE: Solving for First Derivative Approximation Using SymPy in Python\nDESCRIPTION: Solves the matrix equation to find the coefficients of the finite difference approximation. The first derivative approximation is extracted from the solution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nX =  M.inv() * R\nprint(together(X[1]))\n```\n\n----------------------------------------\n\nTITLE: Generating Equations of Motion for Multi-DOF Holonomic System in Python\nDESCRIPTION: This snippet forms the equations of motion for the system using the KanesMethod in the backend. It displays the resulting equations, mass matrix, and forcing vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/multi_degree_freedom_holonomic_system.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nsystem.form_eoms(explicit_kinematics=True)\n\nsystem.mass_matrix_full\n\nsystem.forcing_full\n```\n\n----------------------------------------\n\nTITLE: Creating SymPy Matrices Using a Function Definition in Python\nDESCRIPTION: Illustrates creating a 4x4 SymPy `Matrix` using a function `f(i, j)`. The function defines the matrix elements based on their row index `i` and column index `j`. In this example, it creates an identity matrix by returning 1 if `i == j` and 0 otherwise. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> def f(i,j):\n...     if i == j:\n...         return 1\n...     else:\n...         return 0\n...\n>>> Matrix(4, 4, f)\n[1  0  0  0]\n[          ]\n[0  1  0  0]\n[          ]\n[0  0  1  0]\n[          ]\n[0  0  0  1]\n```\n\n----------------------------------------\n\nTITLE: Using factor() to Simplify Polynomials and Reveal Roots in SymPy\nDESCRIPTION: Factoring expanded polynomials to reveal their roots indirectly. This approach works with both concrete and symbolic polynomials and can provide simpler expressions than explicit root calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> expression_expanded = expand(expression)\n>>> expression_expanded\nx**3 + x**2 - 8*x - 12\n>>> factor(expression_expanded)\n(x - 3)*(x + 2)**2\n>>> symbolic_expanded = expand(symbolic)\n>>> symbolic_expanded\n-a**2*b + a**2*x - 2*a*b*x + 2*a*x**2 - b*x**2 + x**3\n>>> factor(symbolic_expanded)\n(a + x)**2*(-b + x)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fused Multiply-Add (FMA) Custom Function in SymPy\nDESCRIPTION: Complete implementation of a Fused Multiply-Add (FMA) function as a custom SymPy function. Demonstrates how to define eval(), _eval_evalf(), doit(), _eval_rewrite(), fdiff(), and code printer methods for C and C++.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Number, symbols, Add, Mul\n>>> x, y, z = symbols('x y z')\n>>> class FMA(Function):\n...     \"\"\"\n...     FMA(x, y, z) = x*y + z\n...     \n...     FMA is often defined as a single operation in hardware for better\n...     rounding and performance.\n...     \n...     FMA can be evaluated by using the doit() method.\n...     \n...     References\n...     ==========\n...     \n...     .. [1] https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add\n...     \"\"\"\n...     # Define automatic evaluation on explicit numbers\n...     @classmethod\n...     def eval(cls, x, y, z):\n...         # Number is the base class of Integer, Rational, and Float\n...         if all(isinstance(i, Number) for i in [x, y, z]):\n...            return x*y + z\n...     \n...     # Define numerical evaluation with evalf().\n...     def _eval_evalf(self, prec):\n...         return self.doit(deep=False)._eval_evalf(prec)\n...     \n...     # Define full evaluation to Add and Mul in doit(). This effectively\n...     # treats FMA(x, y, z) as just a shorthand for x*y + z that is useful\n...     # to have as a separate expression in some contexts and which can be\n...     # evaluated to its expanded form in other contexts.\n...     def doit(self, deep=True, **hints):\n...         x, y, z = self.args\n...         # Recursively call doit() on the args whenever deep=True.\n...         # Be sure to pass deep=True and **hints through here.\n...         if deep:\n...             x = x.doit(deep=deep, **hints)\n...             y = y.doit(deep=deep, **hints)\n...             z = z.doit(deep=deep, **hints)\n...         return x*y + z\n...     \n...     # Define FMA.rewrite(Add) and FMA.rewrite(Mul).\n...     def _eval_rewrite(self, rule, args, **hints):\n...         x, y, z = self.args\n...         if rule in [Add, Mul]:\n...             return self.doit()\n...     \n...     # Define differentiation.\n...     def fdiff(self, argindex):\n...         # argindex indexes the args, starting at 1\n...         x, y, z = self.args\n...         if argindex == 1:\n...             return y\n...         elif argindex == 2:\n...             return x\n...         elif argindex == 3:\n...             return 1\n...     \n...     # Define code printers for ccode() and cxxcode()\n...     def _ccode(self, printer):\n...         x, y, z = self.args\n...         _x, _y, _z = printer._print(x), printer._print(y), printer._print(z)\n...         return \"fma(%s, %s, %s)\" % (_x, _y, _z)\n...     \n...     def _cxxcode(self, printer):\n...         x, y, z = self.args\n...         _x, _y, _z = printer._print(x), printer._print(y), printer._print(z)\n...         return \"std::fma(%s, %s, %s)\" % (_x, _y, _z)\n```\n\n----------------------------------------\n\nTITLE: Forming Equations of Motion using System Class\nDESCRIPTION: Shows how to use the System class to generate equations of motion for a joint system. Demonstrates system initialization from a Newtonian reference frame, adding joints, and forming equations of motion using KanesMethod as the backend.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/joints.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsystem = System.from_newtonian(parent)\nsystem.add_joints(joint)\nsystem.form_eoms()\nMatrix([[-(child_izz + 9*child_mass)*u']])\ntype(system.eom_method)  # The method working in the backend\n<class 'sympy.physics.mechanics.kane.KanesMethod'>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom SymPy Function with Assumption Handling (Python)\nDESCRIPTION: Defines a custom SymPy function `expreal` inheriting from `sympy.Function`. This function represents exp(x) restricted to extended real arguments. It implements the `eval` classmethod to handle specific input values (0, +/- infinity) using assumption checks (e.g., `x.is_zero`, `x.is_infinite`). It also includes `_eval_*` methods (like `_eval_is_finite`, `_eval_is_zero`) which are part of SymPy's mechanism for determining properties of the function based on its arguments' properties, using fuzzy logic (`fuzzy_and`, `fuzzy_or`). An `is_extended_nonnegative` class attribute sets a default property for the function output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, S # Assuming S was imported earlier\n>>> from sympy.core.logic import fuzzy_and, fuzzy_or\n>>>\n>>> class expreal(Function):\n...     \"\"\"exponential function E**x restricted to the extended reals\"\"\"\n...\n...     is_extended_nonnegative = True\n...\n...     @classmethod\n...     def eval(cls, x):\n...         # Validate the argument\n...         if x.is_extended_real is False:\n...             raise ValueError(\"non-real argument to expreal\")\n...         # Evaluate for special values\n...         if x.is_zero:\n...             return S.One\n...         elif x.is_infinite:\n...             if x.is_extended_negative:\n...                 return S.Zero\n...             elif x.is_extended_positive:\n...                 return S.Infinity\n...\n...     @property\n...     def x(self):\n...         return self.args[0]\n...\n...     def _eval_is_finite(self):\n...         return fuzzy_or([self.x.is_real, self.x.is_extended_nonpositive])\n...\n...     def _eval_is_algebraic(self):\n...         if fuzzy_and([self.x.is_rational, self.x.is_nonzero]):\n...             return False\n...\n...     def _eval_is_integer(self):\n...         if self.x.is_zero:\n...             return True\n...\n...     def _eval_is_zero(self):\n...         return fuzzy_and([self.x.is_infinite, self.x.is_extended_negative])\n```\n\n----------------------------------------\n\nTITLE: Creating SymPy Matrices with Dimensions and Flat List in Python\nDESCRIPTION: Demonstrates creating a SymPy `Matrix` by specifying the number of rows (2), number of columns (3), and a flat list containing the elements `[1, 2, 3, 4, 5, 6]` in row-major order. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> Matrix(2, 3, [1, 2, 3, 4, 5, 6])\n[1  2  3]\n[       ]\n[4  5  6]\n```\n\n----------------------------------------\n\nTITLE: Solving Equations in Eq Form\nDESCRIPTION: Shows how to solve equations using Eq objects to represent equations explicitly, which helps prevent sign errors when manipulating equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-equation-algebraically.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Eq, solve, solveset\n>>> from sympy.abc import x, y\n>>> eqn = Eq(x**2, y)\n>>> eqn\nEq(x**2, y)\n>>> solutions = solve(eqn, x, dict=True)\n>>> print(solutions)\n[{x: -sqrt(y)}, {x: sqrt(y)}]\n>>> solutions_set = solveset(eqn, x)\n>>> print(solutions_set)\n{-sqrt(y), sqrt(y)}\n>>> for solution_set in solutions_set:\n...     print(solution_set)\nsqrt(y)\n-sqrt(y)\n```\n\n----------------------------------------\n\nTITLE: Solving Power Inequalities in Python with SymPy\nDESCRIPTION: This example shows how to solve a system of inequalities involving a power of the variable. SymPy can handle these types of inequalities effectively.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import reduce_inequalities\n>>> from sympy.abc import x, y\n>>> reduce_inequalities([x ** 2 < 4, x > 0], x)\n(0 < x) & (x < 2)\n```\n\n----------------------------------------\n\nTITLE: Performing Vector Operations in SymPy\nDESCRIPTION: Illustrates various vector operations including scalar multiplication, division, addition, and subtraction. It also shows how these operations maintain the vector nature of the expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nv = N.i - 2*N.j\nv/3\nv + N.k\nVector.zero/2\n(v/3)*4\n```\n\n----------------------------------------\n\nTITLE: Solving Equations with SymPy's solveset Function\nDESCRIPTION: Demonstrates how to use the solveset function to solve equations in SymPy. It shows two equivalent ways of solving x^2 = 1: using the Eq function to create an equation, and by manually rewriting the equation as an expression equal to 0.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solveset\n>>> from sympy import Symbol, Eq\n>>> x = Symbol('x')\n>>> solveset(Eq(x**2, 1), x)\n{-1, 1}\n\n>>> solveset(x**2 - 1, x)\n{-1, 1}\n```\n\n----------------------------------------\n\nTITLE: Finding Polynomial Roots with Multiplicities using roots() in SymPy\nDESCRIPTION: Using SymPy's roots() function to find the roots of polynomials and their multiplicities. Returns a dictionary where keys are the roots and values are their multiplicities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> roots(expression, x)\n{-2: 2, 3: 1}\n>>> roots(symbolic, x)\n{-a: 2, b: 1}\n```\n\n----------------------------------------\n\nTITLE: Representing Complex Solutions in Rectangular Form with ComplexRegion in Python\nDESCRIPTION: This snippet demonstrates how to use ComplexRegion to represent solutions in rectangular form, specifically for the first two quadrants of the Argand plane.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import ComplexRegion, Interval, pi, oo, pprint\npprint(ComplexRegion(Interval(-oo, oo)*Interval(0, oo)), use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Simulating the Muscle-actuated System using SciPy's solve_ivp\nDESCRIPTION: Uses SciPy's solve_ivp function to numerically integrate the system's differential equations over time. Simulates the system motion over 3 seconds from the specified initial conditions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from scipy.integrate import solve_ivp\n\n>>> t0, tf = 0.0, 3.0\n>>> ts = np.linspace(t0, tf, num=301)\n>>> x0 = np.hstack((q_vals, u_vals, a_vals))\n>>> sol = solve_ivp(lambda t, x: eval_rhs(t, x, eval_r, p_vals),\n...                 (t0, tf), x0, t_eval=ts)\n```\n\n----------------------------------------\n\nTITLE: Accessing SymbolicSystem Attributes and Components\nDESCRIPTION: Demonstrates how to access various attributes of the SymbolicSystem objects, including states, coordinates, speeds, right-hand sides, mass matrices, and physical components.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsymsystem1.states\nMatrix([\n[     x],\n[     y],\n[     u],\n[     v],\n[lambda]])\nsymsystem2.coordinates\nMatrix([\n[x],\n[y]])\nsymsystem3.speeds\nMatrix([\n[u],\n[v]])\nsymsystem1.comb_explicit_rhs\nMatrix([\n[                          u],\n[                          v],\n[(-g*y + u**2 + v**2)*x/l**2],\n[(-g*y + u**2 + v**2)*y/l**2],\n[m*(-g*y + u**2 + v**2)/l**2]])\nsymsystem2.comb_implicit_rhs\nMatrix([\n[                 u],\n[                 v],\n[                 0],\n[                 0],\n[-g*y + u**2 + v**2]])\nsymsystem2.comb_implicit_mat\nMatrix([\n[1, 0, 0, 0,      0],\n[0, 1, 0, 0,      0],\n[0, 0, 1, 0,   -x/m],\n[0, 0, 0, 1,   -y/m],\n[0, 0, 0, 0, l**2/m]])\nsymsystem3.dyn_implicit_rhs\nMatrix([\n[                 0],\n[                 0],\n[-g*y + u**2 + v**2]])\nsymsystem3.dyn_implicit_mat\nMatrix([\n[1, 0,   -x/m],\n[0, 1,   -y/m],\n[0, 0, l**2/m]])\nsymsystem3.kin_explicit_rhs\nMatrix([\n[u],\n[v]])\nsymsystem1.alg_con\n[4]\nsymsystem1.bodies\n(Pa,)\nsymsystem1.loads\n((P, g*m*N.x),)\n```\n\n----------------------------------------\n\nTITLE: Calculating the Inverse of SymPy Matrices using inv() in Python\nDESCRIPTION: Shows how to compute the inverse of a SymPy `Matrix` using the `inv()` method. It demonstrates finding the inverse of the identity matrix and another 3x3 matrix. The `method` parameter can be specified (e.g., `method=\"LU\"` for LU decomposition, default is Gaussian elimination). The product of a matrix and its inverse yields the identity matrix. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> M2.inv()\n[1  0  0]\n[       ]\n[0  1  0]\n[       ]\n[0  0  1]\n>>> M2.inv(method=\"LU\")\n[1  0  0]\n[       ]\n[0  1  0]\n[       ]\n[0  0  1]\n>>> M.inv(method=\"LU\")\n[-3/14  1/14  1/2 ]\n[                 ]\n[-1/28  5/28  -1/4]\n[                 ]\n[ 3/7   -1/7   0  ]\n>>> M * M.inv(method=\"LU\")\n[1  0  0]\n[       ]\n[0  1  0]\n[       ]\n[0  0  1]\n```\n\n----------------------------------------\n\nTITLE: Simplifying Complex Solutions with Numerical Evaluation in Python\nDESCRIPTION: This demonstrates how to simplify complex symbolic solutions by evaluating them numerically. This is useful when symbolic solutions are unwieldy or difficult to interpret.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, solve\n>>> x = symbols('x')\n>>> solutions = solve(x**4 + 10*x**2 + x + 1, x, dict=True)\n>>> solutions\n[{x: -sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3))/2 - sqrt(-40/3 - 2*(1307/432 + sqrt(434607)*I/144)**(1/3) + 2/sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3)) - 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)))/2}, {x: sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3))/2 - sqrt(-40/3 - 2*(1307/432 + sqrt(434607)*I/144)**(1/3) - 2/sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3)) - 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)))/2}, {x: sqrt(-40/3 - 2*(1307/432 + sqrt(434607)*I/144)**(1/3) - 2/sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3)) - 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)))/2 + sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3))/2}, {x: sqrt(-40/3 - 2*(1307/432 + sqrt(434607)*I/144)**(1/3) + 2/sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3)) - 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)))/2 - sqrt(-20/3 + 56/(9*(1307/432 + sqrt(434607)*I/144)**(1/3)) + 2*(1307/432 + sqrt(434607)*I/144)**(1/3))/2}]\n>>> for solution in solutions:\n...     solution[x].evalf()\n-0.0509758447494279 + 0.313552108895239*I\n0.0509758447494279 + 3.14751999969868*I\n0.0509758447494279 - 3.14751999969868*I\n-0.0509758447494279 - 0.313552108895239*I\n```\n\n----------------------------------------\n\nTITLE: Numerically Evaluating a Complex Symbolic Root in SymPy\nDESCRIPTION: Demonstrates how to obtain a numerical approximation of a complex symbolic root (previously calculated, e.g., using `roots`) using the `.n()` method (equivalent to `evalf`). This is often preferred when the exact symbolic form is too complex.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> rq0.n()\n-0.349745826211722 - 0.438990337475312*I\n```\n\n----------------------------------------\n\nTITLE: Applying Kane's Method and Solving Equations of Motion\nDESCRIPTION: This snippet applies Kane's method to derive the equations of motion, solves for the right-hand side of the equations, and simplifies the results.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nKM = KanesMethod(N, q_ind=[q1, q2, q3], u_ind=[u1, u2, u3], kd_eqs=kd,\n          u_auxiliary=[u4, u5, u6])\n(fr, frstar) = KM.kanes_equations(BodyList, ForceList)\nMM = KM.mass_matrix\nforcing = KM.forcing\nrhs = MM.inv() * forcing\nkdd = KM.kindiffdict()\nrhs = rhs.subs(kdd)\nrhs.simplify()\nmprint(rhs)\n```\n\n----------------------------------------\n\nTITLE: Satisfiability Checking of Boolean Expressions (SymPy, Python)\nDESCRIPTION: This snippet demonstrates using the satisfiable function from sympy.logic.inference to check whether Boolean expressions are satisfiable. It imports required functions and symbols, constructs logical formulas, and queries satisfiability. The first example returns False, indicating an unsatisfiable expression, while the second returns a dictionary mapping variables to values for a satisfiable case. Dependencies are SymPy (with sympy.logic.inference), inputs are symbolic Boolean expressions, and outputs are Boolean or model dictionaries.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/logic.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.logic.inference import satisfiable\n>>> from sympy import Symbol\n>>> x = Symbol('x')\n>>> y = Symbol('y')\n>>> satisfiable(x & ~x)\nFalse\n>>> satisfiable((x | y) & (x | ~y) & (~x | y))\n{x: True, y: True}\n```\n\n----------------------------------------\n\nTITLE: Reducing a System of Linear and Quadratic Inequalities in Python with SymPy\nDESCRIPTION: This example demonstrates solving a system with both linear and quadratic inequalities. The resulting expression represents the intersection of the solution sets of both inequalities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, reduce_inequalities, pi\n>>> x = symbols('x')\n>>> reduce_inequalities([3*x >= 1, x**2 <= pi], x)\n(1/3 <= x) & (x <= sqrt(pi))\n```\n\n----------------------------------------\n\nTITLE: Solving for Roots with Symbolic Coefficients using solve in SymPy\nDESCRIPTION: Demonstrates using SymPy's `solve` function on a polynomial with a symbolic coefficient (`a`). By defining the symbol `a` with `positive=True`, SymPy can correctly deduce that the roots involving `a` are imaginary.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> a = Symbol(\"a\", positive=True)\n>>> symbolic_complex = (x**2+a)**2 * (x-3)\n>>> solve(symbolic_complex, x, dict=True)\n[{x: 3}, {x: -I*sqrt(a)}, {x: I*sqrt(a)}]\n```\n\n----------------------------------------\n\nTITLE: Ensuring Root Found is Within a Given Interval using SymPy in Python\nDESCRIPTION: Demonstrates how to use the 'bisect' solver option in nsolve to ensure the root found is within a specified interval. This is useful when multiple roots exist and you want to find a specific one.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import nsolve\n>>> from sympy.abc import x\n>>> nsolve(x**2 - 1, -0.1)\n1.00000000000000\n>>> nsolve(x**2 - 1, (-10, 0), solver='bisect')\n-1.00000000000000\n```\n\n----------------------------------------\n\nTITLE: Extracting Content and Primitive Part of Polynomials in SymPy\nDESCRIPTION: Demonstrates the use of the as_content_primitive method to extract the content and primitive part of polynomials in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 6*x**2 - 3*x + 9\n>>> c, p = f.as_content_primitive()\n>>> c, p\n       2\n(3, 2*x  - x + 3)\n>>> f = x**2/3 - x/2 + 1\n>>> c, p = f.as_content_primitive()\n>>> c, p\n         2\n(1/6, 2*x  - 3*x + 6)\n```\n\n----------------------------------------\n\nTITLE: Implementing RLC Circuit State-Space Model in Python\nDESCRIPTION: Creates a state-space representation of a series RLC circuit using SymPy's StateSpace class and converts it to a transfer function. Uses symbolic variables R, L, and C to represent circuit components.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/electrical_problems.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Matrix, symbols, pprint\nfrom sympy.physics.control import *\nR, L, C = symbols('R L C')\nA = Matrix([[-R/L, -1/L], [1/C, 0]])\nB = Matrix([[1/L], [0]])\nC = Matrix([[0, 1]])\nD = Matrix([[0]])\nss = StateSpace(A, B, C, D)\ntf = ss.rewrite(TransferFunction)[0][0]\n```\n\n----------------------------------------\n\nTITLE: Converting Expressions with Functions to Polynomials\nDESCRIPTION: Demonstrates how expressions containing functions of generators are handled. The functions are treated as new generators, maintaining algebraic independence between variables.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> e = x*sin(y) - y\n>>> e.as_poly()\nPoly(x*(sin(y)) - y, x, y, sin(y), domain='ZZ')\n```\n\n----------------------------------------\n\nTITLE: Numerical Simplification of Expressions with nsimplify in SymPy - Python\nDESCRIPTION: Illustrates the use of SymPy's nsimplify function to deduce exact symbolic formulas from approximate numerical values and to simplify symbolic expressions. Shows recovery of rational numbers, algebraic forms, and linear combinations of constants. Inputs are floats or symbolic expressions; outputs are simplified symbolic formulas. Requires SymPy's nsimplify and relevant mathematical functions/constants.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> nsimplify(0.1)\n1/10\n>>> nsimplify(6.28, [pi], tolerance=0.01)\n2*pi\n>>> nsimplify(pi, tolerance=0.01)\n22/7\n>>> nsimplify(pi, tolerance=0.001)\n355\n---\n113\n>>> nsimplify(0.33333, tolerance=1e-4)\n1/3\n>>> nsimplify(2.0**(1/3.), tolerance=0.001)\n635\n---\n504\n>>> nsimplify(2.0**(1/3.), tolerance=0.001, full=True)\n3 ___\n\\/ 2\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Beam with Fixed Supports and a Sliding Hinge using SymPy\nDESCRIPTION: This code demonstrates how to analyze a beam of length 3*l with fixed supports at both ends, a point load at l/3, a distributed load between 2*l and 3*l, and a sliding hinge at 5*l/2. The analysis includes calculating reaction loads, shear forces, bending moments, slope, and deflection using SymPy's continuum mechanics module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols, Rational\n>>> E, I = symbols('E, I')\n>>> l = symbols('l', positive=True)\n>>> b = Beam(3*l, E, I)\n>>> r0, m0 = b.apply_support(0, type='fixed')\n>>> r3l, m3l = b.apply_support(3*l, type='fixed')\n>>> s1 = b.apply_sliding_hinge(l*Rational(5, 2))\n>>> P1, q1 = symbols('P1 q1')\n>>> b.apply_load(P1, l*Rational(1, 3), -1)\n>>> b.apply_load(q1, 2*l, 0, 3*l)\n>>> b.solve_for_reaction_loads(r0, r3l, m0, m3l)\n>>> b.reaction_loads\n⎧                  2                       2                                  ⎫\n⎪    17⋅P₁⋅l   25⋅l ⋅q₁         P₁⋅l   11⋅l ⋅q₁            l⋅q₁         -l⋅q₁ ⎪\n⎨M₀: ─────── + ────────, M_3*l: ──── + ────────, R₀: -P₁ - ────, R_3*l: ──────⎬\n⎪      54         36             54       36                2             2   ⎪\n⎩                                                                             ⎭\n\n>>> b.load\n                                                                                                                                                                                                        -4\n                                                                                                                                                ⎛         3        4   ⎞    5⋅l\n                    -1                  -1                                                          ⎛           2   ⎞                ⎛              2   ⎞         ⎝- 25⋅P₁⋅l  - 297⋅l ⋅q₁⎠⋅<- ─── + x>\n            l          l⋅q₁⋅<-3⋅l + x>                  0                0   ⎛      l⋅q₁⎞    -1   ⎜P₁⋅l   11⋅l ⋅q₁⎟           -2   ⎜17⋅P₁⋅l   25⋅l ⋅q₁⎟    -2                                2\n        P₁⋅<- ─ + x>   - ───────────────── + q₁⋅<-2⋅l + x>  - q₁⋅<-3⋅l + x>  + ⎜-P₁ - ────⎟⋅<x>   + ⎜──── + ────────⎟⋅<-3⋅l + x>   + ⎜─────── + ────────⎟⋅<x>   + ──────────────────────────────────────\n            3                  2                                             ⎝       2  ⎠         ⎝ 54       36   ⎠                ⎝  54         36   ⎠                          324\n\n>>> b.shear_force()\n                        0                  0                                                         ⎛           2   ⎞                ⎛              2   ⎞         ⎛         3       4   ⎞            -3\n            l         l⋅q₁⋅<-3⋅l + x>                 1                1   ⎛      l⋅q₁⎞    0   ⎜P₁⋅l   11⋅l ⋅q₁⎟           -1   ⎜17⋅P₁⋅l   25⋅l ⋅q₁⎟    -1   ⎜  25⋅P₁⋅l    11⋅l ⋅q₁⎟    5⋅l\n    - P₁⋅<- ─ + x>  + ──────────────── - q₁⋅<-2⋅l + x>  + q₁⋅<-3⋅l + x>  - ⎜-P₁ - ────⎟⋅<x>  - ⎜──── + ────────⎟⋅<-3⋅l + x>   - ⎜─────── + ────────⎟⋅<x>   - ⎜- ──────── - ────────⎟⋅<- ─── + x>\n            3                2                                             ⎝       2  ⎠        ⎝ 54       36   ⎠                ⎝  54         36   ⎠         ⎝    324         12   ⎠     2\n\n>>> b.bending_moment()\n                        1                  1                2                2                      ⎛                2   ⎞        ⎛             2   ⎞               ⎛       3       4   ⎞            -2\n            l         l⋅q₁⋅<-3⋅l + x>    q₁⋅<-2⋅l + x>    q₁⋅<-3⋅l + x>    ⎛     l⋅q₁⎞    1   ⎜  17⋅P₁⋅l   25⋅l ⋅q₁⎟    0   ⎜  P₁⋅l   11⋅l ⋅q₁⎟           0   ⎜25⋅P₁⋅l    11⋅l ⋅q₁⎟    5⋅l\n    - P₁⋅<- ─ + x>  + ──────────────── - ────────────── + ────────────── + ⎜P₁ + ────⎟⋅<x>  + ⎜- ─────── - ────────⎟⋅<x>  + ⎜- ──── - ────────⎟⋅<-3⋅l + x>  + ⎜──────── + ────────⎟⋅<- ─── + x>\n            3                2                 2                2          ⎝      2  ⎠        ⎝    54         36   ⎠        ⎝   54       36   ⎠               ⎝  324         12   ⎠     2\n\n>>> b.slope()\n            ⎛                    -1                                                           2                       -1                                                                                                        ⎞\n    ⎜       3    5⋅l                                                            l             4       5⋅l                                                                                                               ⎟\n    ⎜25⋅P₁⋅l ⋅<- ─── + x>                1                  1         2   P₁⋅<- ─ + x>    11⋅l ⋅q₁⋅<- ─── + x>         2       1       2              1           2                  2                3                3⎟\n    ⎜             2           17⋅P₁⋅l⋅<x>    P₁⋅l⋅<-3⋅l + x>    P₁⋅<x>          3                      2           25⋅l ⋅q₁⋅<x>    11⋅l ⋅q₁⋅<-3⋅l + x>    l⋅q₁⋅<x>    l⋅q₁⋅<-3⋅l + x>    q₁⋅<-2⋅l + x>    q₁⋅<-3⋅l + x> ⎟\n    -⎜────────────────────── - ──────────── - ──────────────── + ─────── - ───────────── + ────────────────────── - ───────────── - ──────────────────── + ───────── + ──────────────── - ────────────── + ──────────────⎟\n    ⎝         324                  54               54             2            2                   12                  36                  36                4              4                 6                6       ⎠\n    ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n                                                                                                            E⋅I\n\n>>> b.deflection()\n            ⎛                    0                                                           3                       0                                                                                                        ⎞\n    ⎜       3    5⋅l                                                           l             4       5⋅l                                                                                                              ⎟\n    ⎜25⋅P₁⋅l ⋅<- ─── + x>               2                  2         3   P₁⋅<- ─ + x>    11⋅l ⋅q₁⋅<- ─── + x>        2       2       2              2           3                  3                4                4⎟\n    ⎜             2          17⋅P₁⋅l⋅<x>    P₁⋅l⋅<-3⋅l + x>    P₁⋅<x>          3                      2          25⋅l ⋅q₁⋅<x>    11⋅l ⋅q₁⋅<-3⋅l + x>    l⋅q₁⋅<x>    l⋅q₁⋅<-3⋅l + x>    q₁⋅<-2⋅l + x>    q₁⋅<-3⋅l + x> ⎟\n    -⎜───────────────────── - ──────────── - ──────────────── + ─────── - ───────────── + ───────────────────── - ───────────── - ──────────────────── + ───────── + ──────────────── - ────────────── + ──────────────⎟\n    ⎝         324                108              108             6            6                  12                  72                  72               12              12                24               24      ⎠\n    ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n                                                                                                            E⋅I\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Exact Symbolic Computation with sympy.pi\nDESCRIPTION: This snippet shows the advantage of using SymPy's symbolic representation `sympy.pi`. Because `sympy.pi` represents the mathematical constant $\\pi$ exactly, `sympy.sin(sympy.pi)` correctly evaluates to exactly zero, avoiding the precision issues associated with floating-point approximations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> sympy.sin(sympy.pi)\n0\n```\n\n----------------------------------------\n\nTITLE: Series Expansion with Arbitrary Limit Points in Python using SymPy\nDESCRIPTION: This code snippet shows how to perform series expansion with arbitrary limit points other than 0 using SymPy's series function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> exp(x - 6).series(x, x0=6)\n            2          3          4          5\n     (x - 6)    (x - 6)    (x - 6)    (x - 6)         ⎛       6       ⎞\n-5 + ──────── + ──────── + ──────── + ──────── + x + O⎝(x - 6) ; x → 6⎠\n        2          6          24        120\n```\n\n----------------------------------------\n\nTITLE: Correct Symbolic Input Example in SymPy\nDESCRIPTION: Shows the proper way to create and manipulate symbolic expressions using symbols function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> x = symbols('x')\n>>> expand((x**2 + x)/x)\nx + 1\n```\n\n----------------------------------------\n\nTITLE: Using LagrangesMethod linearize Class Method in Python\nDESCRIPTION: This snippet shows how to use the linearize class method of LagrangesMethod to perform linearization. It specifies independent coordinates and speeds, and returns the linearized state matrices A and B, as well as the input vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> A, B, inp_vec = LM.linearize(q_ind=[q1], qd_ind=[q1d], A_and_B=True, op_point=op_point)\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]])\n```\n\n----------------------------------------\n\nTITLE: Finding and Verifying Real Roots Numerically in SymPy\nDESCRIPTION: Illustrates how to obtain accurate numerical approximations of only the real roots using SymPy's `real_roots` combined with numerical evaluation via `.n()`. It also shows how to verify that the roots found by `real_roots` are indeed real using the `is_real` property. Assumes `expression` is a predefined SymPy polynomial.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> [r.n(2) for r in real_roots(expression)]\n[-2.0, -2.0, 3.0]\n>>> [r.is_real for r in real_roots(expression)]\n[True, True, True]\n```\n\n----------------------------------------\n\nTITLE: Custom Function with Variable Arguments\nDESCRIPTION: Shows how to implement a custom function that accepts variable number of arguments using *args and optional parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> class f(Function):\n...     @classmethod\n...     def eval(cls, x, y=1, *args):\n...         return None\n```\n\n----------------------------------------\n\nTITLE: Accessing Matrix Properties and Elements in SymPy\nDESCRIPTION: Demonstrates how to access matrix properties like number of columns and rows, and how to get specific columns, rows, and elements in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nA.cols\nA.col(0)\nA.rows\nA.row(0)\nM[2, 3]\n```\n\n----------------------------------------\n\nTITLE: Creating a Particle in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a Particle object with an associated point and mass. The Particle class requires a name, a Point object, and a mass parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import Particle, Point\n>>> from sympy import Symbol\n>>> m = Symbol('m')\n>>> po = Point('po')\n>>> # create a particle container\n>>> pa = Particle('pa', po, m)\n```\n\n----------------------------------------\n\nTITLE: Series Expansion with SymPy in Python\nDESCRIPTION: These snippets demonstrate how to define a symbolic cosine expression and compute Taylor series expansions in two variables, removing the order term for a polynomial result. Required dependencies: 'sm' for SymPy, symbolic variables. The primary input is the expression and variable points for expansion. Outputs are truncated series, useful in analysis and approximation contexts.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ne = sm.cos(x*y)\n```\n\nLANGUAGE: python\nCODE:\n```\nb = e.series(x, 0, 2).removeO().series(y, 0, 2).removeO()\n```\n\n----------------------------------------\n\nTITLE: Differentiation and Time Derivatives with SymPy and Mechanics in Python\nDESCRIPTION: These snippets demonstrate ordinary differentiation, total time derivatives using mechanics' time symbol, and derivatives with respect to vectors and frames. They show both scalar and vector calculus applications in symbolic form and require imports for SymPy mechanics ('me') and core SymPy ('sm'). Outputs are symbolic derivatives, including higher-order and directionally specified derivatives, useful for dynamics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nE.diff(y)\n```\n\nLANGUAGE: python\nCODE:\n```\nE.diff(me.dynamicsymbols._t)\n```\n\nLANGUAGE: python\nCODE:\n```\ndt2 = v.dt(A)\n```\n\nLANGUAGE: python\nCODE:\n```\ndy2 = v.diff(y, A)\n```\n\n----------------------------------------\n\nTITLE: Using SymPy's ordered Function for Canonical Ordering\nDESCRIPTION: Shows how to use SymPy's ordered() function to sort expressions in a canonical order that works with symbolic expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ordered\n>>> list(ordered([x, 0]))\n[0, x]\n```\n\n----------------------------------------\n\nTITLE: Solving Matrix Equations Using Matrix Inversion\nDESCRIPTION: Demonstrates solving matrix equations by computing the inverse matrix and multiplying it by the constant vector. This method is generally slower but conceptually simpler.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Matrix, simplify\n>>> c, d, e = symbols(\"c, d, e\")\n>>> A = Matrix([[c,d], [1, -e]])\n>>> b = Matrix([2, 0])\n>>> b\n    ⎡2⎤\n    ⎢ ⎥\n    ⎣0⎦\n>>> b2 = Matrix([4, 0])\n>>> b2\n    ⎡4⎤\n    ⎢ ⎥\n    ⎣0⎦\n>>> inv = A.inv()\n>>> inv\n    ⎡   e        d   ⎤\n    ⎢───────  ───────⎥\n    ⎢c⋅e + d  c⋅e + d⎥\n    ⎢                ⎥\n    ⎢   1       -c   ⎥\n    ⎢───────  ───────⎥\n    ⎣c⋅e + d  c⋅e + d⎦\n>>> # Solves Ax = b for x\n>>> solution = inv * b\n>>> solution\n    ⎡  2⋅e  ⎤\n    ⎢───────⎥\n    ⎢c⋅e + d⎥\n    ⎢       ⎥\n    ⎢   2   ⎥\n    ⎢───────⎥\n    ⎣c⋅e + d⎦\n>>> # Demonstrate that solution is correct\n>>> simplify(A * solution)\n    ⎡2⎤\n    ⎢ ⎥\n    ⎣0⎦\n>>> # Solves Ax = b2 for x\n>>> solution2 = inv * b2\n>>> solution2\n    ⎡  4⋅e  ⎤\n    ⎢───────⎥\n    ⎢c⋅e + d⎥\n    ⎢       ⎥\n    ⎢   4   ⎥\n    ⎢───────⎥\n    ⎣c⋅e + d⎦\n>>> # Demonstrate that solution2 is correct\n>>> simplify(A * solution2)\n    ⎡4⎤\n    ⎢ ⎥\n    ⎣0⎦\n```\n\n----------------------------------------\n\nTITLE: Differential Equation Solving\nDESCRIPTION: Shows how to solve differential equations using dsolve, including creation of function symbols and solving ODEs.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/solvers.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nf, g = symbols('f g', cls=Function)\ndiffeq = Eq(f(x).diff(x, x) - 2*f(x).diff(x) + f(x), sin(x))\ndsolve(diffeq, f(x))\ndsolve(f(x).diff(x)*(1 - sin(f(x))) - 1, f(x))\n```\n\n----------------------------------------\n\nTITLE: Incorrect Configuration of Coordinates and Speeds\nDESCRIPTION: Shows a problematic configuration where the time derivatives of generalized coordinates use the same symbol names as the generalized speeds, which would cause issues in the Kane object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/advanced.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>> KM.coords([q1, q2, q3])\n>> KM.speeds([q1d, q2d, q3d])\n```\n\n----------------------------------------\n\nTITLE: Normalizing rational functions with cancel\nDESCRIPTION: Using the cancel function to simplify rational expressions by removing common factors from the numerator and denominator. This produces a normalized form of the rational function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> cancel((x**2 - 4)/(x**2 + 4*x + 4))\nx - 2\n─────\nx + 2\n```\n\n----------------------------------------\n\nTITLE: Solving Polynomial Equations with SymPy\nDESCRIPTION: Examples of solving polynomial equations using SymPy's roots and solve_poly_system functions, including single equations and systems of equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import roots, solve_poly_system\n\n>>> solve(x**3 + 2*x + 3, x)\n               ____          ____\n         1   \\/ 11 *I  1   \\/ 11 *I\n    [-1, - - --------, - + --------]\n         2      2      2      2\n\n>>> p = Symbol('p')\n>>> q = Symbol('q')\n\n>>> solve(x**2 + p*x + q, x)\n              __________           __________\n             /  2                 /  2\n       p   \\/  p  - 4*q     p   \\/  p  - 4*q\n    [- - - -------------, - - + -------------]\n       2         2          2         2\n\n>>> solve_poly_system([y - x, x - 5], x, y)\n    [(5, 5)]\n\n>>> solve_poly_system([y**2 - x**3 + 1, y*x], x, y)\n                                       ___                 ___\n                                 1   \\/ 3 *I         1   \\/ 3 *I\n    [(0, -I), (0, I), (1, 0), (- - - -------, 0), (- - + -------, 0)]\n```\n\n----------------------------------------\n\nTITLE: Reducing Inequalities for Multiple Variables in Python with SymPy\nDESCRIPTION: This example shows how to reduce a system of inequalities for multiple variables, where each inequality contains only one symbol to be reduced for. The result is equivalent to reducing the inequalities separately and combining the results.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import reduce_inequalities, symbols\n>>> x, y = symbols(\"x y\")\n>>> x_y_reduced = reduce_inequalities([x > 1, y > 0], [x, y]); x_y_reduced\n(0 < y) & (1 < x) & (x < oo) & (y < oo)\n```\n\n----------------------------------------\n\nTITLE: Convolution Operations in SymPy\nDESCRIPTION: Implementation of various convolution operations including general convolution, FFT-based convolution, NTT-based convolution, FWHT-based convolution, subset convolution, covering product, and intersecting product. These methods provide efficient ways to compute convolutions of discrete sequences.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/discrete.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.discrete.convolutions import (\n    convolution,\n    convolution_fft,\n    convolution_ntt,\n    convolution_fwht,\n    convolution_subset,\n    covering_product,\n    intersecting_product\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Right-Hand Side Function for ODE Solver\nDESCRIPTION: Creates a function suitable for SciPy's ODE solver that evaluates the derivatives at a given time and state. It uses fixed excitation of 1.0 and the predefined parameter values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\ndef eval_rhs(t, x):\n\n    r = np.array([1.0])\n\n    return eval_eom(x, r, p_vals)\n```\n\n----------------------------------------\n\nTITLE: Basic Series Expansion in Python Using SymPy\nDESCRIPTION: Demonstrates how to expand a cosine function as a series using SymPy's series() function. The example shows the intuitive API that wraps Basic.series().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/series/series.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, cos, series\n>>> x = Symbol('x')\n>>> series(cos(x),x)\n1 - x**2/2 + x**4/24 + O(x**6)\n```\n\n----------------------------------------\n\nTITLE: Working with Coordinate Variables in SymPy\nDESCRIPTION: This snippet shows how to work with coordinate variables in different systems. It demonstrates how the expression of scalar fields changes when expressed in different coordinate systems.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nR = N.locate_new('R', N.i + 2*N.j + 3*N.k)\nT_N = N.x + N.y + N.z\nexpress(T_N, R, variables=True)\n```\n\n----------------------------------------\n\nTITLE: Term Collection and Rational Function Cancellation\nDESCRIPTION: Shows usage of collect() for grouping terms and cancel() for simplifying rational expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nexpr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3\ncollect(expr, x)\ncancel((x**2 + 2*x + 1)/(x**2 + x))\n```\n\n----------------------------------------\n\nTITLE: Examining Default Symbol Assumptions in Python\nDESCRIPTION: This snippet demonstrates that a 'vanilla' symbol without explicit assumptions has very limited known properties in SymPy's assumption system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x')\nx.assumptions0\nprint(x.is_commutative)\nprint(x.is_rational)\nprint(x.is_complex)\nprint(x.is_real)\nprint(x.is_integer)\nprint(x.is_finite)\n```\n\n----------------------------------------\n\nTITLE: Performing Integer Operations with ZZ Domain\nDESCRIPTION: This code demonstrates basic arithmetic operations within the ZZ (integer) domain, including floor division and modulo operations. Note that true division is not directly supported in ZZ.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsref.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> x = ZZ(5)\n>>> y = ZZ(2)\n>>> x // y  # floor division\n2\n>>> x % y   # modulo division (remainder)\n1\n```\n\n----------------------------------------\n\nTITLE: Applying a Function Element-wise to SymPy Matrices using applyfunc in Python\nDESCRIPTION: Illustrates applying a custom function to each element of a SymPy `Matrix` using the `applyfunc()` method. A lambda function `f = lambda x: 2*x` is defined to double each element, and then applied to the 3x3 identity matrix. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> f = lambda x: 2*x\n>>> eye(3).applyfunc(f)\n[2  0  0]\n[       ]\n[0  2  0]\n[       ]\n[0  0  2]\n```\n\n----------------------------------------\n\nTITLE: Incorporating Holonomic Constraints in Lagrange's Method\nDESCRIPTION: Demonstrates how to include holonomic constraints when initializing the LagrangesMethod object and generating equations of motion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/lagrange.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nLM = LagrangesMethod(L, [q1, q2], hol_coneqs=[q1 - q2])\nLM.form_lagranges_equations()\n```\n\n----------------------------------------\n\nTITLE: Representing Vectors as Matrices Relative to Reference Frames - SymPy - Python\nDESCRIPTION: Shows how to express a symbolic vector in matrix (column vector) form given a reference frame using the .to_matrix method. The code demonstrates mapping scalar coefficients from symbolic expressions to matrix elements. Requires SymPy, a reference frame 'N', and variable 'x'. Inputs are vector expressions and a frame; outputs are SymPy matrices.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> (x * N.x + 2 * x * N.y + 3 * x * N.z).to_matrix(N)\\nMatrix([\\n  [  x],\\n  [2*x],\\n  [3*x]])\n```\n\n----------------------------------------\n\nTITLE: Multivariate Factoring Over Algebraic Number Fields in SymPy\nDESCRIPTION: Shows how to factor a multivariate polynomial over algebraic number fields, specifically over Q(√-3), using the extension parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfactor(x**3 + y**3, extension=sqrt(-3))\n```\n\n----------------------------------------\n\nTITLE: Creating a Complete Musculotendon Model\nDESCRIPTION: Creates a musculotendon model by combining the pathway and activation dynamics with muscle-specific parameters like tendon slack length, peak force, and fiber properties.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.biomechanics import MusculotendonDeGroote2016\n\n>>> F_M_max, l_M_opt, l_T_slack = sm.symbols('F_M_max, l_M_opt, l_T_slack', real=True)\n>>> v_M_max, alpha_opt, beta = sm.symbols('v_M_max, alpha_opt, beta', real=True)\n\n>>> muscle = MusculotendonDeGroote2016.with_defaults(\n...     'muscle',\n...     muscle_pathway,\n...     muscle_activation,\n...     tendon_slack_length=l_T_slack,\n...     peak_isometric_force=F_M_max,\n...     optimal_fiber_length=l_M_opt,\n...     maximal_fiber_velocity=v_M_max,\n...     optimal_pennation_angle=alpha_opt,\n...     fiber_damping_coefficient=beta,\n... )\n...\n```\n\n----------------------------------------\n\nTITLE: Orienting and Locating New Coordinate Systems in SymPy\nDESCRIPTION: This snippet demonstrates how to create a new coordinate system that is both oriented and translated relative to an existing system. It uses the 'location' keyword argument in orientation methods.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nC = A.orient_new_axis('C', a, A.k, location=2*A.j)\nC.position_wrt(A)\nfrom sympy.vector import express\nexpress(A.position_wrt(C), C)\n```\n\n----------------------------------------\n\nTITLE: Defining Differentiation for FMA Function in Python\nDESCRIPTION: Implements the fdiff method for the fused multiply-add (FMA) function, which has multiple arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Number, symbols\nx, y, z = symbols('x y z')\nclass FMA(Function):\n    \"\"\"\n    FMA(x, y, z) = x*y + z\n    \"\"\"\n    def fdiff(self, argindex):\n        # argindex indexes the args, starting at 1\n        x, y, z = self.args\n        if argindex == 1:\n            return y\n        elif argindex == 2:\n            return x\n        elif argindex == 3:\n            return 1\n```\n\n----------------------------------------\n\nTITLE: Asserting Differential Equality in Python\nDESCRIPTION: This code snippet demonstrates a consistency check in SymPy tests. It asserts that the derivative of the expected result with respect to x equals the original expression, confirming the correctness of the integration result.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nassert diff(expected, x) == expr\n```\n\n----------------------------------------\n\nTITLE: Evaluating Finite Series Using Euler-Maclaurin Formula with Sum.evalf in SymPy - Python\nDESCRIPTION: Demonstrates fast numerical approximation of a finite series using SymPy's Sum and evalf, which applies the Euler-Maclaurin formula for rapid convergence. Ideal for evaluating a large number of terms without iterating each term explicitly. Requires symbolic variables defined in SymPy. The output is a fast, high-precision float approximation of the finite sum.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> Sum(1/k, (k, 10000000, 20000000)).evalf()\n0.693147255559946\n```\n\n----------------------------------------\n\nTITLE: Reducing a System of Inequalities for a Single Variable in Python with SymPy\nDESCRIPTION: This code demonstrates how to use reduce_inequalities to solve a system of inequalities for a single variable. It takes a list of inequality expressions and the variable to solve for, returning the solution as a logical combination of inequalities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, reduce_inequalities, pi\n>>> x = symbols('x')\n>>> reduce_inequalities([x >= 0, x**2 <= pi], x)\n(0 <= x) & (x <= sqrt(pi))\n```\n\n----------------------------------------\n\nTITLE: Complex Expression Construction\nDESCRIPTION: Creates and displays the internal representation of a more complex mathematical expression involving trigonometric functions and fractions\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nexpr = sin(x*y)/2 - x**2 + 1/y\nsrepr(expr)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Function Class in SymPy\nDESCRIPTION: Demonstrates how to create a custom function class by subclassing SymPy's Function class. This is the starting point for defining complex custom functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> class versin(Function):\n...     pass\n\n>>> versin(x)\nversin(x)\n>>> isinstance(versin(x), versin)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using rs_series Function for General Series Expansion in SymPy\nDESCRIPTION: Examples demonstrating the rs_series function which provides a user-friendly interface to expand arbitrary expressions into series. It automatically creates the appropriate ring and calls the right ring series functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.polys.ring_series import rs_series\n>>> from sympy.functions.elementary.trigonometric import sin\n>>> rs_series(sin(a + b), a, 5) # doctest: +SKIP\n1/24*sin(b)*a**4 - 1/2*sin(b)*a**2 + sin(b) - 1/6*cos(b)*a**3 + cos(b)*a\n\n>>> rs_series(sin(exp(a*b) + cos(a + c)), a, 2) # doctest: +SKIP\n-sin(c)*cos(cos(c) + 1)*a + cos(cos(c) + 1)*a*b + sin(cos(c) + 1)\n\n>>> rs_series(sin(a + b)*cos(a + c)*tan(a**2 + b), a, 2) # doctest: +SKIP\ncos(b)*cos(c)*tan(b)*a - sin(b)*sin(c)*tan(b)*a + sin(b)*cos(c)*tan(b)\n```\n\n----------------------------------------\n\nTITLE: Understanding Variable Assignment in SymPy\nDESCRIPTION: Illustrates how variable assignment works in SymPy, showing that expressions don't automatically update when their component variables change. Expressions use the values that were present at creation time.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Symbol\na = Symbol('a')  # Symbol, `a`, stored as variable \"a\"\nb = a + 1        # an expression involving `a` stored as variable \"b\"\nprint(b)\na + 1\na = 4            # \"a\" now points to literal integer 4, not Symbol('a')\nprint(a)\n4\nprint(b)          # \"b\" is still pointing at the expression involving `a`\na + 1\n```\n\n----------------------------------------\n\nTITLE: Expanding Functions in SymPy (Python)\nDESCRIPTION: Shows how to expand expressions in terms of different kinds of expressions using the func keyword in SymPy's expand() function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/rewriting.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> GoldenRatio.expand(func=True)\n1/2 + sqrt(5)/2\n```\n\n----------------------------------------\n\nTITLE: Defining Angular Velocity of Reference Frames in SymPy\nDESCRIPTION: This snippet demonstrates how to create reference frames and define their angular velocities using SymPy's physics.vector module. It shows both automatic calculation of angular velocity during frame creation and manual setting of angular velocity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Symbol, sin, cos\nfrom sympy.physics.vector import *\ninit_vprinting(pretty_print=False)\nN = ReferenceFrame('N')\nq1 = dynamicsymbols('q1')\nA = N.orientnew('A', 'Axis', [q1, N.x])\nA.ang_vel_in(N)\n\nB = ReferenceFrame('B')\nu1 = dynamicsymbols('u1')\nB.set_ang_vel(N, u1 * B.y)\nB.ang_vel_in(N)\nN.ang_vel_in(B)\n```\n\n----------------------------------------\n\nTITLE: Working with Points in SymPy Vector\nDESCRIPTION: Shows how to access the origin of a coordinate system and create new points using the locate_new method. It also demonstrates how to compute position vectors between points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nfrom sympy.abc import a, b, c\nN = CoordSys3D('N')\nN.origin\ntype(N.origin)\nP = N.origin.locate_new('P', a*N.i + b*N.j + c*N.k)\nQ = P.locate_new('Q', -b*N.j)\nP.position_wrt(Q)\nQ.position_wrt(N.origin)\nQ.express_coordinates(N)\n```\n\n----------------------------------------\n\nTITLE: Vector Operations in SymPy\nDESCRIPTION: Shows how to perform common vector operations like cross product, dot product, magnitude calculation, and normalization in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ncross(a, b)\n```\n\nLANGUAGE: python\nCODE:\n```\ndot(a, b)\n```\n\nLANGUAGE: python\nCODE:\n```\nv.magnitude()\n```\n\nLANGUAGE: python\nCODE:\n```\nv.normalize()\n```\n\n----------------------------------------\n\nTITLE: Rewriting SymPy Expression as a Single Meijer G-Function\nDESCRIPTION: Internal SymPy function that attempts to rewrite a given mathematical expression as a single Meijer G-function. It utilizes both table lookups (based on function types) and a recursive Mellin transform technique, including analytic continuation for functions without direct Mellin transforms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n_rewrite_single\n```\n\n----------------------------------------\n\nTITLE: Creating a NumPy-aware Function using lambdify in Python\nDESCRIPTION: Shows how to use `lambdify` with the 'numpy' backend to create a function that operates efficiently on NumPy arrays. This leverages NumPy's vectorized ufuncs for potential speedups with array inputs, though it introduces a slight overhead.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.abc import x\n>>> expr = sin(x)/x\n>>> f = lambdify(x, expr, \"numpy\")\n\n>>> import numpy\n>>> data = numpy.linspace(1, 10, 10000)\n>>> f(data)\n[ 0.84147098  0.84119981  0.84092844 ... -0.05426074 -0.05433146\n -0.05440211]\n```\n\n----------------------------------------\n\nTITLE: Symbolic Differentiation of Matrix Expressions - SymPy - Python\nDESCRIPTION: Demonstrates symbolic differentiation with respect to a matrix variable using MatrixSymbol objects in SymPy. Inputs are symbolic matrices (a, b, X), with differentiation of quadratic forms or with respect to itself. Outputs include simplified matrix expressions (for some cases) or higher-dimensional array expressions. Useful for advanced applications in matrix calculus and tensor algebra, with dependency on SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/expressions.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na = MatrixSymbol(\"a\", 3, 1)\nb = MatrixSymbol(\"b\", 3, 1)\n(a.T*X**2*b).diff(X)\na*b.T*X.T + X.T*a*b.T\n```\n\nLANGUAGE: python\nCODE:\n```\nX.diff(X)\nPermuteDims(ArrayTensorProduct(I, I), (3)(1 2))\n```\n\n----------------------------------------\n\nTITLE: Examining Activation Model State and Input Variables\nDESCRIPTION: Shows how to access the state variables, input variables, and parameters of the muscle activation model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle_activation.x\nMatrix([[a_muscle(t)]])\n>>> muscle_activation.r\nMatrix([[e_muscle(t)]])\n>>> muscle_activation.p\nMatrix(0, 1, [])\n```\n\n----------------------------------------\n\nTITLE: Defining and Operating on Symbolic Matrices - SymPy - Python\nDESCRIPTION: Demonstrates how to define symbolic matrix variables using MatrixSymbol and perform basic matrix algebraic operations such as transposition, multiplication, and inversion. Requires the SymPy library. Inputs are symbolic objects (e.g., X, Y), and outputs are symbolic matrix expressions. Useful for expressing algebraic identities and transformations without explicit matrix elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/expressions.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import MatrixSymbol, Matrix\nX = MatrixSymbol('X', 3, 3)\nY = MatrixSymbol('Y', 3, 3)\n(X.T*X).I*Y\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ODE Solution with Python's dsolve\nDESCRIPTION: Shows how to solve an ordinary differential equation using SymPy's dsolve function with line continuation in doctest format.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, dsolve, cos, sin\n>>> from sympy.abc import x\n>>> f = Function('f')\n>>> dsolve(cos(f(x)) - (x*sin(f(x)) - f(x)**2)*f(x).diff(x),\n... f(x), hint='1st_exact')\nEq(x*cos(f(x)) + f(x)**3/3, C1)\n```\n\n----------------------------------------\n\nTITLE: Vector Frame Derivatives\nDESCRIPTION: Illustrates vector derivatives with respect to different reference frames\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\n\\frac{^{\\mathbf{A}} d \\mathbf{e}}{d \\theta} \\neq 0\\\\\n\\frac{^{\\mathbf{B}} d \\mathbf{e}}{d \\theta} = 0\\\\\n\\frac{^{\\mathbf{A}} d \\mathbf{c}}{d \\theta} = 0\n```\n\n----------------------------------------\n\nTITLE: Parsing Expressions with Assumptions in SymPy\nDESCRIPTION: Demonstrates how to use parse_expr to create expressions with assumptions on symbols. The example shows creating an equation with a positive x and solving it.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import parse_expr\n>>> parse_expr('x**2 - 1')\nx**2 - 1\n>>> eq = parse_expr('x**2 - 1', {'x':Symbol('x', positive=True)})\n>>> solve(eq)\n[1]\n```\n\n----------------------------------------\n\nTITLE: Computing GCD and LCM of Polynomials in SymPy\nDESCRIPTION: Demonstrates the computation of greatest common divisor (GCD) and least common multiple (LCM) of polynomials in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> f = (12*x + 12)*x\n>>> g = 16*x**2\n>>> gcd(f, g)\n4*x\n\n>>> f = 3*x**2/2\n>>> g = 9*x/4\n>>> gcd(f, g)\nx\n\n>>> f = x*y/2 + y**2\n>>> g = 3*x + 6*y\n\n>>> gcd(f, g)\nx + 2*y\n\n>>> f = x*y**2 + x**2*y\n>>> g = x**2*y**2\n>>> gcd(f, g)\nx*y\n>>> lcm(f, g)\n 3  2    2  3\nx *y  + x *y\n>>> (f*g).expand()\n 4  3    3  4\nx *y  + x *y\n>>> (gcd(f, g, x, y)*lcm(f, g, x, y)).expand()\n 4  3    3  4\nx *y  + x *y\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting Polynomial with Rational Domain (QQ) in SymPy\nDESCRIPTION: This example demonstrates how to create a polynomial with rational coefficients. By default, polynomials with rational coefficients will use QQ as their domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsref.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Poly, Symbol\n>>> x = Symbol('x')\n>>> p = Poly(x**2 + x/2)\n>>> p\nPoly(x**2 + 1/2*x, x, domain='QQ')\n>>> p.domain\nQQ\n```\n\n----------------------------------------\n\nTITLE: Accessing SymPy Matrix Elements using 2D Indexing in Python\nDESCRIPTION: Shows the standard way to access elements in a SymPy `Matrix` using a pair of indices `M[row, column]`. Examples include accessing `M[1, 2]`, `M[0, 0]`, and `M[1, 1]`. Remember that indexing is 0-based. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> M[1, 2]\n6\n>>> M[0, 0]\n1\n>>> M[1, 1]\n5\n```\n\n----------------------------------------\n\nTITLE: Advanced Numerical Symbolic Simplification with nsimplify and Special Constants in SymPy - Python\nDESCRIPTION: Demonstrates advanced uses of nsimplify for reconstructing symbolic formulas involving mathematical constants and algebraic expressions. Accepts high-precision floats, trigonometric, exponential, and sum expressions as inputs, and recovers expressions involving constants like pi, e, GoldenRatio, and others. Highlights nsimplify's flexibility and ability to simplify complex symbolic results. Requires appropriate SymPy imports and definitions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> nsimplify(Float('0.130198866629986772369127970337',30), [pi, E])\n    1\n----------\n5*pi\n---- + 2*e\n 7\n>>> nsimplify(cos(atan('1/3')))\n    ____\n3*\\/ 10\n--------\n   10\n>>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n-2 + 2*GoldenRatio\n>>> nsimplify(2 + exp(2*atan('1/4')*I))\n49   8*I\n-- + ---\n17    17\n>>> nsimplify((1/(exp(3*pi*I/5)+1)))\n           ___________\n          /   ___\n1        /  \\/ 5    1\n- - I*  /   ----- + -\n2     \\/      10    4\n>>> nsimplify(I**I, [pi])\n -pi\n ----\n  2\ne\n>>> n = Symbol('n')\n>>> nsimplify(Sum(1/n**2, (n, 1, oo)), [pi])\n 2\npi\n---\n 6\n>>> nsimplify(gamma('1/4')*gamma('3/4'), [pi])\n  ___\n\\/ 2 *pi\n```\n\n----------------------------------------\n\nTITLE: Creating Forces in SymPy Mechanics\nDESCRIPTION: Shows how to create a Force object by specifying the point of application and the force vector. Forces can be applied to specific points or to rigid bodies.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import Point, ReferenceFrame, Force\n>>> N = ReferenceFrame('N')\n>>> Po = Point('Po')\n>>> Force(Po, N.x)\n(Po, N.x)\n```\n\n----------------------------------------\n\nTITLE: Including Non-Conservative Forces in Lagrange's Method\nDESCRIPTION: Demonstrates how to incorporate non-conservative forces when initializing the LagrangesMethod object and generating equations of motion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/lagrange.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nN = ReferenceFrame('N')\nP = Point('P')\nP.set_vel(N, q1d * N.x)\nFL = [(P, 7 * N.x)]\nLM = LagrangesMethod(L, [q1, q2], forcelist=FL, frame=N)\nLM.form_lagranges_equations()\n```\n\n----------------------------------------\n\nTITLE: Power Simplification with powsimp\nDESCRIPTION: Demonstrates the use of powsimp function to simplify power expressions with and without force parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npowsimp(t**c*z**c)\npowsimp(t**c*z**c, force=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Angular Velocity in Python and LaTeX\nDESCRIPTION: Shows how to represent angular velocity mathematically and potentially in code using sympy.physics.vector. Includes the definition of angular velocity and its components.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n{}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{B}} = w_x \\mathbf{\\hat{b}_x} + w_y \\mathbf{\\hat{b}_y} + w_z \\mathbf{\\hat{b}_z}\n```\n\n----------------------------------------\n\nTITLE: Solving Inequalities with Trigonometric Functions in Python with SymPy\nDESCRIPTION: This code demonstrates solving trigonometric inequalities. The results are restricted to solutions within the periodic interval, with additional solutions generated by adding multiples of the periodicity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import reduce_inequalities, cos\n>>> from sympy.abc import x, y\n>>> from sympy.calculus.util import periodicity\n>>> reduce_inequalities([2*cos(x) < 1, x > 0], x)\n(0 < x) & (x < oo) & (pi/3 < x) & (x < 5*pi/3)\n>>> periodicity(2*cos(x), x)\n2*pi\n```\n\n----------------------------------------\n\nTITLE: Solving Quadrilateral Problem with SymPy Vector\nDESCRIPTION: This snippet demonstrates how to use SymPy's vector package to solve a problem involving quadrilaterals in 3D space. It uses CoordSys3D, Point, and Vector operations to prove that two line segments are parallel.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/examples.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nSys = CoordSys3D('Sys')\n\nO = Sys.origin\n\nfrom sympy import symbols\na1, a2, a3 = symbols('a1 a2 a3')\nA = O.locate_new('A', a1*Sys.i + a2*Sys.j + a3*Sys.k)\n\nb1, b2, b3 = symbols('b1 b2 b3')\nB = O.locate_new('B', b1*Sys.i + b2*Sys.j + b3*Sys.k)\nc1, c2, c3 = symbols('c1 c2 c3')\nC = O.locate_new('C', c1*Sys.i + c2*Sys.j + c3*Sys.k)\n\nP = O.locate_new('P', A.position_wrt(O) + (O.position_wrt(A) / 2))\n\nQ = A.locate_new('Q', B.position_wrt(A) / 2)\nR = B.locate_new('R', C.position_wrt(B) / 2)\nS = O.locate_new('R', C.position_wrt(O) / 2)\n\nPQ = Q.position_wrt(P)\nSR = R.position_wrt(S)\n\nPQ.cross(SR)\n```\n\n----------------------------------------\n\nTITLE: Forming Equations of Motion with Kane's Method\nDESCRIPTION: Uses Kane's Method to form the equations of motion for the system with both muscle forces and gravity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n>>> kane = me.KanesMethod(N, (q,), (u,), kd_eqs=(u - q.diff(),))\n>>> Fr, Frs = kane.kanes_equations((block,), (muscle_loads + [gravity]))\n```\n\n----------------------------------------\n\nTITLE: Creating an ImageSet in Python using SymPy\nDESCRIPTION: Demonstrates how to create an ImageSet representing the set of squares of natural numbers using SymPy's Lambda and S.Naturals.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import ImageSet, S, Lambda\nfrom sympy.abc import x\nsquares = ImageSet(Lambda(x, x**2), S.Naturals)  # {x**2 for x in N}\n4 in squares\n```\n\n----------------------------------------\n\nTITLE: Working with Real and Complex Fields in SymPy\nDESCRIPTION: This snippet demonstrates the usage of RR and CC domains for real and complex numbers in SymPy, showing their internal representation and precision handling.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy import RR, CC\n>>> xr = RR(3)\n>>> xr\n3.0\n>>> xr._mpf_\n(0, 3, 0, 2)\n>>> zc = CC(3+1j)\n>>> zc\n(3.0 + 1.0j)\n>>> zc._mpc_\n((0, 3, 0, 2), (0, 1, 0, 1))\n```\n\n----------------------------------------\n\nTITLE: Transforming Coordinate Systems in SymPy\nDESCRIPTION: This snippet shows how to create user-defined coordinate systems using the 'transformation' parameter in CoordSys3D. It demonstrates creating spherical coordinates and custom transformations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nfrom sympy import sin, cos\nA = CoordSys3D('A', transformation='spherical')\nB = CoordSys3D('A', transformation=lambda x,y,z: (x*sin(y), x*cos(y), z))\n\nA = CoordSys3D('A')\nB = A.create_new('B', transformation='spherical')\n```\n\n----------------------------------------\n\nTITLE: Initializing State Vector for a Muscle-actuated System in Python\nDESCRIPTION: Creates a state vector from generalized coordinates, speeds, and muscle activation states. This code joins the coordinates, speeds, and muscle activation states into a single column vector that represents the complete state of the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> q, u = kane.q, kane.u\n>>> a = biceps.x.col_join(triceps.x)\n>>> x = q.col_join(u).col_join(a)\n>>> x\nMatrix([\n[       q1(t)],\n[       q2(t)],\n[       q3(t)],\n[       q4(t)],\n[       u1(t)],\n[       u2(t)],\n[       u3(t)],\n[       u4(t)],\n[ a_biceps(t)],\n[a_triceps(t)]])\n```\n\n----------------------------------------\n\nTITLE: Solving Matrix Equations Using LU Decomposition\nDESCRIPTION: Demonstrates using LU decomposition to solve a matrix equation, which is more efficient when solving multiple equations with the same coefficient matrix but different constant vectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Matrix, eye, simplify\n>>> c, d, e = symbols(\"c, d, e\")\n>>> A = Matrix([[c,d], [1, -e]])\n>>> A\n⎡c  d ⎤\n⎢     ⎥\n⎣1  -e⎦\n>>> b = Matrix([2, 0])\n>>> b\n    ⎡2⎤\n    ⎢ ⎥\n    ⎣0⎦\n>>> solution = A.LUsolve(b)\n>>> solution\n    ⎡  2⋅e  ⎤\n    ⎢───────⎥\n    ⎢c⋅e + d⎥\n    ⎢       ⎥\n    ⎢   2   ⎥\n    ⎢───────⎥\n    ⎣c⋅e + d⎦\n>>> # Demonstrate that solution is correct\n>>> simplify(A * solution)\n    ⎡2⎤\n    ⎢ ⎥\n    ⎣0⎦\n>>> b2 = Matrix([4, 0])\n>>> b2\n    ⎡4⎤\n    ⎢ ⎥\n    ⎣0⎦\n>>> solution2 = A.LUsolve(b2)\n>>> solution2\n    ⎡  4⋅e  ⎤\n    ⎢───────⎥\n    ⎢c⋅e + d⎥\n    ⎢       ⎥\n    ⎢   4   ⎥\n    ⎢───────⎥\n    ⎣c⋅e + d⎦\n>>> # Demonstrate that solution2 is correct\n>>> simplify(A * solution2)\n    ⎡4⎤\n    ⎢ ⎥\n    ⎣0⎦\n```\n\n----------------------------------------\n\nTITLE: Domain Restriction in Solutions\nDESCRIPTION: Examples of restricting solution domains to real numbers or specific intervals using both solve() and solveset() functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-equation-algebraically.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, solve, solveset\n>>> x = Symbol('x')\n>>> solve(x**4 - 256, x, dict=True)\n[{x: -4}, {x: 4}, {x: -4*I}, {x: 4*I}]\n>>> solveset(x**4 - 256, x)\n{-4, 4, -4*I, 4*I}\n\n>>> x = Symbol('x', real=True)\n>>> solve(x**4 - 256, x, dict=True)\n[{x: -4}, {x: 4}]\n```\n\n----------------------------------------\n\nTITLE: Advanced Matrix Operations\nDESCRIPTION: Demonstrates advanced matrix operations including determinant calculation, reduced row echelon form, nullspace, eigenvalues and eigenvectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nM = Matrix([[1, 0, 1], [2, -1, 3], [4, 3, 2]])\nM.det()\nM.rref()\nM.nullspace()\nM.eigenvals()\nM.eigenvects()\n```\n\n----------------------------------------\n\nTITLE: Integrating Single Polynomial over 3D Polyhedra\nDESCRIPTION: Shows how to integrate a single polynomial over 3D polyhedra (cube and octahedron) using polytope_integrate function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ncube = [[(0, 0, 0), (0, 0, 5), (0, 5, 0), (0, 5, 5), (5, 0, 0), (5, 0, 5), (5, 5, 0), (5, 5, 5)], [2, 6, 7, 3], [3, 7, 5, 1], [7, 6, 4, 5], [1, 5, 4, 0], [3, 1, 0, 2], [0, 4, 6, 2]]\npolytope_integrate(cube, x**2 + y**2 + z**2 + x*y + y*z + x*z)\n\noctahedron = [[(S(-1) / sqrt(2), 0, 0), (0, S(1) / sqrt(2), 0), (0, 0, S(-1) / sqrt(2)), (0, 0, S(1) / sqrt(2)), (0, S(-1) / sqrt(2), 0), (S(1) / sqrt(2), 0, 0)], [3, 4, 5], [3, 5, 1], [3, 1, 0], [3, 0, 4], [4, 0, 2], [4, 2, 5], [2, 0, 1], [5, 2, 1]]\npolytope_integrate(octahedron, x**2 + y**2 + z**2 + x*y + y*z + x*z)\n```\n\n----------------------------------------\n\nTITLE: Fixed-Fixed Beam Analysis with Hinge\nDESCRIPTION: Models a beam fixed at both ends with a hinge joint and point load P. Demonstrates use of symbolic variables for length and load analysis. Calculates complete beam response including reactions and deformations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> l = symbols('l', positive=True)\n>>> b1 = Beam(l ,E,I)\n>>> b2 = Beam(2*l ,E,I)\n>>> b = b1.join(b2,\"hinge\")\n>>> M1, A1, M2, A2, P = symbols('M1 A1 M2 A2 P')\n>>> b.apply_load(A1, 0, -1)\n>>> b.apply_load(M1, 0 ,-2)\n>>> b.apply_load(P, 2*l, -1)\n>>> b.apply_load(A2, 3*l, -1)\n>>> b.apply_load(M2, 3*l, -2)\n>>> b.bc_slope=[(0, 0), (3*l, 0)]\n>>> b.bc_deflection=[(0, 0), (3*l, 0)]\n>>> b.solve_for_reaction_loads(M1, A1, M2, A2)\n```\n\n----------------------------------------\n\nTITLE: Defining and Manipulating Transfer Functions in SymPy\nDESCRIPTION: Creates multiple transfer functions representing system components G1-G4 and H1-H3, then combines them using Series and Feedback operations to analyze a complex control system. Finally performs simplification and pole-zero plotting.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/control_problems.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.abc import s\nfrom sympy.physics.control import *\nG1 = TransferFunction(1, 10 + s, s)\nG2 = TransferFunction(1, 1 + s, s)\nG3 = TransferFunction(1 + s**2, 4 + 4*s + s**2, s)\nG4 = TransferFunction(1 + s, 6 + s, s)\nH1 = TransferFunction(1 + s, 2 + s, s)\nH2 = TransferFunction(2*(6 + s), 1 + s, s)\nH3 = TransferFunction(1, 1, s)\nsys1 = Series(G3, G4)\nsys2 = Feedback(sys1, H1, 1).doit()\nsys3 = Series(G2, sys2)\nsys4 = Feedback(sys3, H2).doit()\nsys5 = Series(G1, sys4)\nsys6 = Feedback(sys5, H3)\nsys6.doit(cancel=True, expand=True)\npole_zero_plot(sys6)\n```\n\n----------------------------------------\n\nTITLE: Testing Symbolic Equality using Simplification Functions in SymPy\nDESCRIPTION: Demonstrates how to check for symbolic equality by subtracting expressions and using functions like simplify(), expand() to verify if the result equals zero.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import simplify, cos, sin, expand\nsimplify((x + 1)**2 - (x**2 + 2*x + 1))\n0\neq = sin(2*x) - 2*sin(x)*cos(x)\nsimplify(eq)\n0\nexpand(eq, trig=True)\n0\n```\n\n----------------------------------------\n\nTITLE: Root Functions Implementation in SymPy\nDESCRIPTION: Implementation of various root functions including general nth root, square root, cube root, and real root calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/functions/elementary.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nroot\nsqrt\ncbrt\nreal_root\n```\n\n----------------------------------------\n\nTITLE: Performing Rational Number Operations with QQ Domain\nDESCRIPTION: This example shows basic arithmetic operations within the QQ (rational) domain. Unlike ZZ, true division is fully supported in QQ for all non-zero divisors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsref.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> x = QQ(5)\n>>> y = QQ(2)\n>>> x / y  # true division\n5/2\n```\n\n----------------------------------------\n\nTITLE: Defining Function Assumptions in SymPy\nDESCRIPTION: Shows how to define assumptions on undefined functions, which apply to the function's output (range) rather than its input (domain).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> g = Function('g', real=True)\n\n>>> g(x)\ng(x)\n>>> g(x).is_real\nTrue\n```\n\n----------------------------------------\n\nTITLE: Connecting Bodies with Joints in Multi-DOF Holonomic System using Python\nDESCRIPTION: This snippet establishes the kinematics of the system by connecting the bodies using joints. It creates a prismatic joint for the block and pin joints for the pendulums, specifying coordinates, speeds, and axes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/multi_degree_freedom_holonomic_system.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nblock_frame = ReferenceFrame('A')\nblock.masscenter.set_vel(block_frame, 0)\nslider = PrismaticJoint('J1', wall, block, coordinates=q1, speeds=u1,\n                        child_interframe=block_frame)\nrev1 = PinJoint('J2', block, compound_pend, coordinates=q2, speeds=u2,\n                joint_axis=wall.z, child_point=l*2/3*compound_pend.y,\n                parent_interframe=block_frame)\nsimple_pend_frame = ReferenceFrame('C')\nsimple_pend.masscenter.set_vel(simple_pend_frame, 0)\nrev2 = PinJoint('J3', compound_pend, simple_pend, coordinates=q3,\n                speeds=u3, joint_axis=compound_pend.z,\n                parent_point=-l/3*compound_pend.y,\n                child_point=l*simple_pend_frame.y,\n                child_interframe=simple_pend_frame)\n\nsystem.add_joints(slider, rev1, rev2)\n```\n\n----------------------------------------\n\nTITLE: Accessing Individual Matrix Elements by Index\nDESCRIPTION: Shows how to access specific elements in a matrix solution by using index notation, which is useful for working with specific components of a solution vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> solution[0]\n      2⋅e\n    ───────\n    c⋅e + d\n```\n\n----------------------------------------\n\nTITLE: Numeric Integration in SymPy\nDESCRIPTION: Demonstrates numerical integration capabilities using evalf() method with optional precision specifications.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Integral, Symbol, sqrt\nx = Symbol('x')\nintegral = Integral(sqrt(2)*x, (x, 0, 1))\nintegral.evalf()\nintegral.evalf(50)\n```\n\n----------------------------------------\n\nTITLE: Assigning Values to Individual SymPy Matrix Elements in Python\nDESCRIPTION: Demonstrates assigning new values to specific elements within a SymPy `Matrix` using standard `M[row, col] = value` syntax. Example shows setting `M[2, 2]` and `M[0, 3]` to 0. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Matrix(([1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]))\n>>> M\n[1   2   3   4 ]\n[              ]\n[5   6   7   8 ]\n[              ]\n[9   10  11  12]\n[              ]\n[13  14  15  16]\n>>> M[2,2] = M[0,3] = 0\n>>> M\n[1   2   3   0 ]\n[              ]\n[5   6   7   8 ]\n[              ]\n[9   10  0   12]\n[              ]\n[13  14  15  16]\n```\n\n----------------------------------------\n\nTITLE: Using Exact Pi Value in SymPy\nDESCRIPTION: Shows the difference between using math.pi (numerical approximation) and sympy.pi (exact value) in trigonometric calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import math\n>>> import sympy\n>>> math.pi\n3.141592653589793\n>>> sympy.sin(math.pi)\n1.22464679914735e-16\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> sympy.pi\npi\n>>> sympy.sin(sympy.pi)\n0\n```\n\n----------------------------------------\n\nTITLE: Retrieving Full Mass Matrix and Forcing Vector with Constraints\nDESCRIPTION: Shows how to obtain the full mass matrix and forcing vector for systems with constraints.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/lagrange.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nLM.mass_matrix_full\nLM.forcing_full\n```\n\n----------------------------------------\n\nTITLE: Setting Up Kinematics and Gravitational Force for a Simple Mass System in Python\nDESCRIPTION: Initializes a particle system with a single generalized coordinate and speed, establishing the position, velocity, and gravitational force acting on the mass.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> import pprint\n>>> import sympy as sm\n>>> import sympy.physics.mechanics as me\n\n>>> q, u = me.dynamicsymbols('q, u', real=True)\n>>> m, g = sm.symbols('m, g', real=True, positive=True)\n\n>>> N = me.ReferenceFrame('N')\n>>> O, P = sm.symbols('O, P', cls=me.Point)\n\n>>> P.set_pos(O, q*N.x)\n>>> O.set_vel(N, 0)\n>>> P.set_vel(N, u*N.x)\n\n>>> gravity = me.Force(P, m*g*N.x)\n\n>>> block = me.Particle('block', P, m)\n```\n\n----------------------------------------\n\nTITLE: Deriving Equations of Motion\nDESCRIPTION: Applies Kane's method to derive the equations of motion, including mass matrix formation and solving for generalized speed derivatives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nKM = KanesMethod(N, q_ind=[q1, q2, q3], u_ind=[u1, u2, u3], kd_eqs=kd)\n(fr, frstar) = KM.kanes_equations(BodyList, ForceList)\nMM = KM.mass_matrix\nforcing = KM.forcing\nrhs = MM.inv() * forcing\nkdd = KM.kindiffdict()\nrhs = rhs.subs(kdd)\nrhs.simplify()\n```\n\n----------------------------------------\n\nTITLE: Solving for Complex Roots Using solve in SymPy\nDESCRIPTION: Shows how to use the SymPy `solve` function to find complex roots of a polynomial. The `dict=True` argument returns the solutions as a list of dictionaries, mapping the variable to its root value. Note that `solve` may not explicitly show root multiplicities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve, roots, nroots, real_roots, expand, RootOf, CRootOf, Symbol\n>>> from sympy import Poly\n>>> from sympy.abc import x\n>>> expression_complex = (x**2+4)**2 * (x-3)\n>>> solve(expression_complex, x, dict=True)\n[{x: 3}, {x: -2*I}, {x: 2*I}]\n```\n\n----------------------------------------\n\nTITLE: Working with Order Terms in SymPy\nDESCRIPTION: Shows how Order terms behave when combined with other expressions. The example demonstrates that lower-order terms are absorbed when added to an Order term.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/series/series.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, Order\n>>> x = Symbol('x')\n>>> Order(x) + x**2\nO(x)\n>>> Order(x) + 1\n1 + O(x)\n```\n\n----------------------------------------\n\nTITLE: Converting Symbolic Matrix to Explicit Matrix Form - SymPy - Python\nDESCRIPTION: Shows how to convert a MatrixSymbol object into an explicit Matrix expression, resulting in a symbolic representation of its elements. Requires SymPy. The input is a symbolic matrix variable (X), and the output is a Matrix object with element-wise symbolic access (e.g., X[0,0]). Useful for applications requiring element inspection or concrete forms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/expressions.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nMatrix(X)\nMatrix([\n[X[0, 0], X[0, 1], X[0, 2]],\n[X[1, 0], X[1, 1], X[1, 2]],\n[X[2, 0], X[2, 1], X[2, 2]]])\n```\n\n----------------------------------------\n\nTITLE: Creating SymbolicSystem Instances with Different Equation Forms\nDESCRIPTION: Instantiates three SymbolicSystem objects using different representations of the equations of motion: explicit combined, implicit combined, and separate dynamics/kinematics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsymsystem1 = system.SymbolicSystem(states, comb_explicit_rhs,\n                               alg_con=alg_con_full, bodies=bodies,\n                               loads=loads)\nsymsystem2 = system.SymbolicSystem(states, comb_implicit_rhs,\n                               mass_matrix=comb_implicit_mat,\n                               alg_con=alg_con_full,\n                               coord_idxs=coord_idxs)\nsymsystem3 = system.SymbolicSystem(states, dyn_implicit_rhs,\n                               mass_matrix=dyn_implicit_mat,\n                               coordinate_derivatives=kin_explicit_rhs,\n                               alg_con=alg_con,\n                               coord_idxs=coord_idxs,\n                               speed_idxs=speed_idxs)\n```\n\n----------------------------------------\n\nTITLE: Forming Boolean Expressions with SymPy (Python)\nDESCRIPTION: This snippet demonstrates creating symbolic Boolean expressions using Python's standard bitwise operators (&, |, ~) mapped to SymPy's And, Or, and Not classes. Users must import the required functions and declare symbols before combining them. Expressions can be displayed, manipulated, and further processed with logic functions. No external dependencies are required other than SymPy. Inputs are Python variables representing Boolean symbols, and the outputs are symbolic expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/logic.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy import *\n>>> x, y = symbols('x,y')\n>>> y | (x & y)\ny | (x & y)\n>>> x | y\nx | y\n>>> ~x\n~x\n```\n\n----------------------------------------\n\nTITLE: Generating Equations of Motion for Four Bar Linkage in Python\nDESCRIPTION: This snippet specifies the independent and dependent generalized coordinates and speeds, validates the system, and generates the equations of motion using KanesMethod as the backend.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/four_bar_linkage_example.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nsystem.q_ind = [q1]\nsystem.u_ind = [u1]\nsystem.q_dep = [q2, q3]\nsystem.u_dep = [u2, u3]\nsystem.validate_system()\n\nsimplify(system.form_eoms())\n```\n\n----------------------------------------\n\nTITLE: Controlling Solve Output Format with dict and set Keywords\nDESCRIPTION: Demonstrates how to control the format of solve output using the dict and set keywords. The dict keyword returns results as a list of dictionaries, while set returns a tuple containing symbols and a set of solution tuples.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsolve(x - 1, dict=True)\n[{x: 1}]\nsolve([x**2 - y, x + y - 6], set=True)\n([x, y], {(-3, 9), (2, 4)})\n```\n\n----------------------------------------\n\nTITLE: Integrating Vector Expressions in SymPy\nDESCRIPTION: Demonstrates how to use the Integral class with vector expressions. It shows both the unevaluated integral and its evaluated form.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Integral\nv1 = a*N.i + sin(a)*N.j - N.k\nIntegral(v1, a)\nIntegral(v1, a).doit()\n```\n\n----------------------------------------\n\nTITLE: Error Example When Copying and Pasting Results\nDESCRIPTION: Shows an error that can occur when copying and pasting results with option 2 syntax, where y(t) is interpreted as y(t)(t) if y already represents y(t).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> dsolve(y(t).diff(y), y)\nTraceback (most recent call last):\n    ...\nTypeError: 'y' object is not callable\n```\n\n----------------------------------------\n\nTITLE: Initializing Matrix with Symbolic Expressions in SymPy\nDESCRIPTION: Creates a symbolic matrix using SymPy with hyperbolic and exponential expressions. Demonstrates a case where default zero testing fails to produce correct nullspace results.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nq = Symbol(\"q\", positive = True)\nm = Matrix([\n[-2*cosh(q/3),      exp(-q),            1],\n[      exp(q), -2*cosh(q/3),            1],\n[           1,            1, -2*cosh(q/3)]])\nm.nullspace() # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Basic Numerical Evaluation in Python with SymPy\nDESCRIPTION: Demonstrates basic numerical evaluation using N() and evalf() methods to convert symbolic expressions to floating-point numbers with specified precision.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> N(sqrt(2)*pi)\n4.44288293815837\n>>> (sqrt(2)*pi).evalf()\n4.44288293815837\n```\n\n----------------------------------------\n\nTITLE: Calculating Matrix Power with SymPy Matrices in Python\nDESCRIPTION: Shows how to compute the power of a square SymPy `Matrix` using the exponentiation operator (`**`). `M**2` calculates the matrix product `M * M`. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> M**2\n[30   36   42 ]\n[             ]\n[66   81   96 ]\n[             ]\n[102  126  150]\n```\n\n----------------------------------------\n\nTITLE: Optimized Common Subexpression Detection in SymPy (Python)\nDESCRIPTION: Shows how to use optimizations in SymPy's cse function for more efficient common subexpression detection and collection.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/rewriting.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> pprint(cse((x-y)*(z-y) + sqrt((x-y)*(z-y)), optimizations='basic'),\n...     use_unicode=True)\n⎛                          ⎡  ____     ⎤⎞\n⎝[(x₀, -(x - y)⋅(y - z))], ⎣╲╱ x₀  + x₀⎦⎠\n```\n\n----------------------------------------\n\nTITLE: Implementing 1-Point Theorem for Particle on Ring\nDESCRIPTION: Shows the implementation of the 1-point theorem for a particle moving on a ring. Demonstrates creation of oriented reference frames, setting angular velocities, and computing velocities using v1pt_theory and v2pt_theory.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> N = ReferenceFrame('N')\n>>> u1, u2 = dynamicsymbols('u1 u2')\n>>> q1, q2 = dynamicsymbols('q1 q2')\n>>> l = Symbol('l')\n>>> R = Symbol('R')\n>>> C = N.orientnew('C', 'Axis', [q1, N.x])\n>>> C.set_ang_vel(N, u1 * N.x)\n>>> O = Point('O')\n>>> O.set_vel(N, 0)\n>>> Q = O.locatenew('Q', -l * C.z)\n>>> P = Q.locatenew('P', R * (cos(q2) * C.x + sin(q2) * C.y))\n>>> P.set_vel(C, R * u2 * (-sin(q2) * C.x + cos(q2) * C.y))\n>>> Q.v2pt_theory(O, N, C)\nl*u1*C.y\n>>> P.v1pt_theory(Q, N, C)\n- R*u2*sin(q2)*C.x + (R*u2*cos(q2) + l*u1)*C.y + R*u1*sin(q2)*C.z\n```\n\n----------------------------------------\n\nTITLE: Symbol Handling in SymPy Functions\nDESCRIPTION: Demonstrates proper function design by passing symbols as parameters instead of hardcoding them.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef theta_operator(expr):\n    z = symbols('z')\n    return z*expr.diff(z)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef theta_operator(expr, z):\n    return z*expr.diff(z)\n```\n\n----------------------------------------\n\nTITLE: Univariate GCD, resultant and factorization operations\nDESCRIPTION: Working with univariate polynomials to compute greatest common divisors (GCD), resultants, and factorizations. These operations demonstrate polynomial manipulation for high-degree univariate polynomials over integers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 64*x**34 - 21*x**47 - 126*x**8 - 46*x**5 - 16*x**60 - 81\n>>> g = 72*x**60 - 25*x**25 - 19*x**23 - 22*x**39 - 83*x**52 + 54*x**10 + 81\n>>> h = 34*x**19 - 25*x**16 + 70*x**7 + 20*x**3 - 91*x - 86\n\n>>> gcd(f, g)\n1\n\n>>> gcd(expand(f*h), expand(g*h)) - h\n0\n\n>>> resultant(expand(f*h), expand(g*h))\n0\n\n>>> factor(expand(f*g))\n ⎛    60       47       34        8       5     ⎞ ⎛    60       52     39       25       23       10     ⎞\n-⎝16⋅x   + 21⋅x   - 64⋅x   + 126⋅x  + 46⋅x  + 81⎠⋅⎝72⋅x   - 83⋅x - 22⋅x   - 25⋅x   - 19⋅x   + 54⋅x   + 81⎠\n```\n\n----------------------------------------\n\nTITLE: Differentiating DynamicSymbols with Respect to Time - SymPy - Python\nDESCRIPTION: Demonstrates creating undefined functions of time (dynamic symbols) with dynamicsymbols, and differentiating them with respect to time using Symbol('t'). Useful in representing time-dependent coordinates and variables in symbolic mechanics. Requires sympy, sympy.physics.vector, and the definition of 'dynamicsymbols'. Inputs are dynamic symbols; outputs are Derivative expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import diff\\n>>> q1, q2, q3 = dynamicsymbols('q1 q2 q3')\\n>>> diff(q1, Symbol('t'))\\nDerivative(q1(t), t)\n```\n\n----------------------------------------\n\nTITLE: Using Contains for Symbolic Set Membership\nDESCRIPTION: This snippet demonstrates the use of the Contains class for symbolic set membership, and how it differs from the 'in' operator.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Reals, Contains\n>>> x = Symbol('x', real=True)\n>>> y = Symbol('y')\n>>> Contains(x, Reals)\nTrue\n>>> Contains(y, Reals)\nContains(y, Reals)\n>>> Contains(y, Reals).subs(y, 1)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Symbolic Boolean Results in SymPy\nDESCRIPTION: This snippet illustrates how SymPy handles inequalities, returning symbolic Boolean expressions for indeterminate cases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> xpos > 0\nTrue\n>>> xneg > 0\nFalse\n>>> x > 0\nx > 0\n>>> type(x > 0)\n<class 'sympy.core.relational.StrictGreaterThan'>\n```\n\n----------------------------------------\n\nTITLE: Forming Equations of Motion with Particles and Forces\nDESCRIPTION: Example demonstrating the complete process of forming equations of motion using Kane's method. This includes defining reference frames, points, particles, forces, and then solving for the mass matrix and forcing vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n>>> N = ReferenceFrame('N')\n>>> q, u = dynamicsymbols('q u')\n>>> qd, ud = dynamicsymbols('q u', 1)\n>>> P = Point('P')\n>>> P.set_vel(N, u * N.x)\n>>> Pa = Particle('Pa', P, 5)\n>>> BL = [Pa]\n>>> FL = [(P, 7 * N.x)]\n>>> KM = KanesMethod(N, [q], [u], [qd - u])\n>>> (fr, frstar) = KM.kanes_equations(BL, FL)\n>>> KM.mass_matrix\nMatrix([[5]])\n>>> KM.forcing\nMatrix([[7]]]\n```\n\n----------------------------------------\n\nTITLE: Joining SymPy Matrices Horizontally (Row Join) in Python\nDESCRIPTION: Demonstrates how to concatenate two SymPy `Matrix` objects horizontally (side-by-side) using the `M1.row_join(M2)` method. The matrices must have the same number of rows. Example joins an identity matrix `M1` and a zero matrix `M2`. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> M1 = eye(3)\n>>> M2 = zeros(3, 4)\n>>> M1.row_join(M2)\n[1  0  0  0  0  0  0]\n[                   ]\n[0  1  0  0  0  0  0]\n[                   ]\n[0  0  1  0  0  0  0]\n```\n\n----------------------------------------\n\nTITLE: Mass and Center of Mass Operations in SymPy\nDESCRIPTION: Shows how to access mass properties and calculate center of mass in SymPy for rigid body dynamics problems.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nB.masscenter\n```\n\nLANGUAGE: python\nCODE:\n```\nA.mass + B.mass + C.mass\n```\n\nLANGUAGE: python\nCODE:\n```\nme.functions.center_of_mass(o, p1, r)\n```\n\n----------------------------------------\n\nTITLE: Using Gaussian Integer Domain in SymPy\nDESCRIPTION: This snippet demonstrates how to use the ZZ_I domain for Gaussian integers in SymPy, creating and manipulating Gaussian integer elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy import ZZ_I, QQ_I, I\n>>> z = ZZ_I.from_sympy(1 + 2*I)\n>>> z\n(1 + 2*I)\n>>> z**2\n(-3 + 4*I)\n```\n\n----------------------------------------\n\nTITLE: Defining Tendon Force-Length Curve in SymPy\nDESCRIPTION: Creates a SymPy expression for the tendon force-length curve using dynamic symbols and constants. This implementation allows for flexible definition using either normalized or actual length values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\nl_T_tilde = me.dynamicsymbols('l_T_tilde')\nc0, c1, c2, c3 = sm.symbols('c0, c1, c2, c3')\n\nfl_T = c0*sm.exp(c3*(l_T_tilde - c1)) - c2\nfl_T\n\nl_T = me.dynamicsymbols('l_T')\nl_T_slack = sm.symbols('l_T_slack')\n\nfl_T = c0*sm.exp(c3*(l_T/l_T_slack - c1)) - c2\nfl_T\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Symbol with Implied Assumptions in Python\nDESCRIPTION: This example shows how declaring a symbol as an integer implies a suite of other predicates in SymPy's assumption system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nn = Symbol('n', integer=True)\nn.assumptions0\n```\n\n----------------------------------------\n\nTITLE: Applying SymPy Operations on Vectors\nDESCRIPTION: Shows how SymPy operations like simplify, trigsimp, diff, and factor can be applied to vector expressions. These operations work on the measure numbers of the vectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.abc import a, b, c\nfrom sympy import sin, cos, trigsimp, diff\nv = (a*b + a*c + b**2 + b*c)*N.i + N.j\nv.factor()\nv = (sin(a)**2 + cos(a)**2)*N.i - (2*cos(b)**2 - 1)*N.k\ntrigsimp(v)\nv.simplify()\ndiff(v, b)\nfrom sympy import Derivative\nDerivative(v, b).doit()\n```\n\n----------------------------------------\n\nTITLE: Custom Precision Numerical Evaluation\nDESCRIPTION: Shows how to perform numerical evaluation with custom precision levels using N() function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> N(sqrt(2)*pi, 5)\n4.4429\n>>> N(sqrt(2)*pi, 50)\n4.4428829381583662470158809900606936986146216893757\n```\n\n----------------------------------------\n\nTITLE: Creating Fully Symbolic Functions in Python using SymPy\nDESCRIPTION: Demonstrates how to create a fully symbolic function using SymPy's Function class. This approach is useful for undefined functions or symbols that depend on other symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Function\n>>> x = symbols('x')\n>>> f = Function('f')\n\n>>> f(x)\nf(x)\n>>> f(0)\nf(0)\n```\n\n----------------------------------------\n\nTITLE: Substituting Arbitrary Constants in SymPy dsolve Results (Python)\nDESCRIPTION: Illustrates how to work with arbitrary constants (like C1, C2) generated by SymPy's `dsolve`. It involves defining these constants as SymPy symbols and then using the `.subs()` method on the solution expression to substitute specific numerical values for them.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_14\n\nLANGUAGE: py\nCODE:\n```\n>>> from sympy import Function, dsolve, Derivative, symbols, pi\n>>> y = Function('y')\n>>> x, C1, C2 = symbols(\"x, C1, C2\")\n>>> result = dsolve(Derivative(y(x), x, x) + 9*y(x), y(x)).rhs\n>>> result\nC1*sin(3*x) + C2*cos(3*x)\n>>> result.subs({C1: 7, C2: pi})\n7*sin(3*x) + pi*cos(3*x)\n```\n\n----------------------------------------\n\nTITLE: Extracting Individual Relations from Inequality Solutions in Python with SymPy\nDESCRIPTION: This code snippet shows how to decompose a solution of inequalities into individual relations using relational atoms. It extracts each relation and sorts them to get a list of tuples containing the left side, operator, and right side of each relation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, reduce_inequalities, pi\n>>> from sympy.core.relational import Relational\n>>> x = symbols('x')\n>>> eq = reduce_inequalities([3*x >= 1, x**2 <= pi], x); eq\n(1/3 <= x) & (x <= sqrt(pi))\n>>> relations = [(i.lhs, i.rel_op, i.rhs) for i in [i.canonical for i in eq.atoms(Relational)]]\n>>> relations_sorted = sorted(relations, key=lambda x: float(x[2])) # Sorting relations just to ensure consistent list order for docstring testing\n>>> relations_sorted\n[(x, '>=', 1/3), (x, '<=', sqrt(pi))]\n```\n\n----------------------------------------\n\nTITLE: Proving Third Product Rule for Del Operator with SymPy Vector\nDESCRIPTION: This snippet uses SymPy's vector package to prove the third product rule for the Del operator. It demonstrates the use of CoordSys3D, Del, and symbolic functions to represent vector and scalar fields.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/examples.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D, Del\ndelop = Del()\nC = CoordSys3D('C')\n\nfrom sympy import symbols, Function\nv1, v2, v3, f = symbols('v1 v2 v3 f', cls=Function)\n\nvfield = v1(C.x, C.y, C.z)*C.i + v2(C.x, C.y, C.z)*C.j + v3(C.x, C.y, C.z)*C.k\nffield = f(C.x, C.y, C.z)\n\nlhs = (delop.dot(ffield * vfield)).doit()\n\nrhs = ((vfield.dot(delop(ffield))) + (ffield * (delop.dot(vfield)))).doit()\n\nlhs.expand().simplify() == rhs.expand().doit().simplify()\n```\n\n----------------------------------------\n\nTITLE: Detecting Unsatisfiable Systems of Inequalities in Python with SymPy\nDESCRIPTION: This example shows how SymPy handles a system of inequalities with incompatible conditions. When no solution exists, reduce_inequalities returns False.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, reduce_inequalities, pi\n>>> x = symbols('x')\n>>> reduce_inequalities([x < 0, x > pi], x)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Division and Rational Numbers\nDESCRIPTION: Shows how division behaves differently between Python integers and SymPy Integers, particularly in creating rational numbers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nInteger(1)/Integer(3)\nRational(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Incorrect eval() Implementation - Direct Expression Return\nDESCRIPTION: Example showing an incorrect implementation of eval() that always returns a direct expression. This approach prevents the function from staying unevaluated when needed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import cos\nclass versin(Function):\n    @classmethod\n    def eval(cls, x):\n        # !! Not actually a good eval() method !!\n        return 1 - cos(x)\n```\n\n----------------------------------------\n\nTITLE: Computing Divergence of Vector Field\nDESCRIPTION: Shows how to calculate the divergence of a vector field using SymPy's divergence function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.vector import ReferenceFrame\nR = ReferenceFrame('R')\nfrom sympy.physics.vector import divergence\nfield = R[0]*R[1]*R[2] * (R.x+R.y+R.z)\ndivergence(field, R)\n```\n\n----------------------------------------\n\nTITLE: Integrating Functions Involving Error Function with SymPy in Python\nDESCRIPTION: This snippet evaluates an indefinite integral involving the Gaussian error function (erf) and an exponential function using SymPy. All necessary dependencies (sympy) must be present, with a symbolic variable defined. The input is a product of exp(-x**2) and erf(x), and the output is an expression involving the square root of pi and powers of erf(x), demonstrating SymPy's ability to process some nonelementary integrals symbolically.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> integrate(exp(-x**2)*erf(x), x)\n  ____    2\n\\/ pi *erf (x)\n--------------\n      4\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Error When Applying NumPy Function to SymPy Symbol\nDESCRIPTION: This snippet shows that NumPy functions, like `np.sin`, cannot handle SymPy symbolic objects (`Symbol`). Trying to apply a NumPy ufunc to a SymPy expression results in a TypeError because NumPy does not know how to perform the operation on that type.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_18\n\nLANGUAGE: py\nCODE:\n```\n>>> x = Symbol('x')\n>>> np.sin(x) # NumPy functions do not know how to handle SymPy expressions\nTraceback (most recent call last):\n...\nTypeError: loop of ufunc does not support argument 0 of type Symbol which has no callable sin method\n```\n\n----------------------------------------\n\nTITLE: Expressing Vectors in Different Coordinate Systems in SymPy\nDESCRIPTION: This snippet demonstrates how to express vectors in different coordinate systems using the 'express' function. It shows reexpression of vectors, scalars, and dyadics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D, express\nfrom sympy.abc import a, b, c\nN = CoordSys3D('N')\nM = N.orient_new_axis('M', a, N.k)\nv1 = N.i + N.j + N.k\nexpress(v1, M)\nv2 = N.i + M.j\nexpress(v2, N)\nd = 2*(M.i | N.j) + 3* (M.j | N.k)\nexpress(d, M)\nexpress(d, M, N)\n```\n\n----------------------------------------\n\nTITLE: Recursive Tree Traversal in Python using SymPy\nDESCRIPTION: Implements a recursive pre-order traversal function to walk through a SymPy expression tree and print all arguments at each level.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef pre(expr):\n    print(expr)\n    for arg in expr.args:\n        pre(arg)\n\nexpr = x*y + 1\npre(expr)\n# Output:\n# x*y + 1\n# 1\n# x*y\n# x\n# y\n\nfor arg in preorder_traversal(expr):\n    print(arg)\n# Output:\n# x*y + 1\n# 1\n# x*y\n# x\n# y\n```\n\n----------------------------------------\n\nTITLE: Converting Elements Between Domains in Python using SymPy\nDESCRIPTION: Demonstrates how to convert elements from one domain to another using the convert_from and convert methods of Domain objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> num_zz = ZZ(3)\n>>> ZZ.of_type(num_zz)\nTrue\n>>> num_qq = QQ.convert_from(num_zz, ZZ)\n>>> ZZ.of_type(num_qq)\nFalse\n>>> QQ.of_type(num_qq)\nTrue\n>>> QQ.convert(ZZ(2))\n2\n```\n\n----------------------------------------\n\nTITLE: Specifying Coefficient Domain in Polynomial Creation\nDESCRIPTION: Shows how to explicitly specify the coefficient domain when creating polynomials, particularly useful when working with symbolic numbers that should be treated as coefficients rather than generators.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> e = (x + 2*pi)*y\n>>> e.as_poly(domain=ZZ[pi])\nPoly(x*y + 2*pi*y, x, y, domain='ZZ[pi]')\n```\n\n----------------------------------------\n\nTITLE: Evaluating Infinite Series with Symbolic Sum and evalf in SymPy - Python\nDESCRIPTION: Evaluates various infinite series with high precision using SymPy's Sum and evalf functions. These examples demonstrate symbolic summation, application of the Euler-Maclaurin formula for faster convergence, and evaluation of mathematical constants via series. Requires importing SymPy and defining symbolic variables. Outputs are floating-point approximations of the series sums.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> var('k')\nk\n>>> Sum(1/k**2, (k, 1, oo)).evalf()\n1.64493406684823\n>>> zeta(2).evalf()\n1.64493406684823\n>>> Sum(1/k-log(1+1/k), (k, 1, oo)).evalf()\n0.577215664901533\n>>> Sum(1/k-log(1+1/k), (k, 1, oo)).evalf(50)\n0.57721566490153286060651209008240243104215933593992\n>>> EulerGamma.evalf(50)\n0.57721566490153286060651209008240243104215933593992\n```\n\n----------------------------------------\n\nTITLE: Computing Vector Dot Products with Multiple Interfaces - SymPy - Python\nDESCRIPTION: Shows how to compute dot products of vectors using both method and function interfaces in sympy.physics.vector. Illustrates the recommended function interface usage for clarity and highlights the behavior when vectors are orthogonal. Requires SymPy and a reference frame 'N' with basis vectors defined. Inputs are vector basis vectors; outputs are scalars (1 for same direction, 0 otherwise).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> N.x.dot(N.x)\\n1\\n>>> N.x.dot(N.y)\\n0\\n>>> dot(N.x, N.x)\\n1\\n>>> dot(N.x, N.y)\\n0\n```\n\n----------------------------------------\n\nTITLE: Initializing and Locating New Coordinate Systems in SymPy\nDESCRIPTION: This snippet demonstrates how to create a new coordinate system M located at a specific position relative to an existing system N. It shows how to express the position of one system relative to another.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nN = CoordSys3D('N')\nM = N.locate_new('M', 3*N.i + 4*N.j + 5*N.k)\nM.position_wrt(N)\nN.origin.express_coordinates(M)\n```\n\n----------------------------------------\n\nTITLE: Univariate factoring over various domains\nDESCRIPTION: Factoring polynomials over different domains including rationals, finite fields, and algebraic number fields. This demonstrates SymPy's flexibility in handling algebraic structures.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> f = x**4 - 3*x**2 + 1\n\n>>> factor(f)\n⎛ 2        ⎞ ⎛ 2        ⎞\n⎝x  - x - 1⎠⋅⎝x  + x - 1⎠\n\n>>> factor(f, modulus=5)\n       2        2\n(x - 2) ⋅(x + 2)\n\n>>> alg = AlgebraicNumber((sqrt(5) - 1)/2, alias='alpha')\n\n>>> factor(f, extension=alg)\n(x - α)⋅(x + α)⋅(x - 1 - α)⋅(x + α + 1)\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Mechanics for Rolling Disc Simulation\nDESCRIPTION: This snippet sets up the necessary imports, symbols, and dynamicsymbols for the rolling disc simulation. It also configures the mechanics printing settings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import symbols, sin, cos, tan\nfrom sympy.physics.mechanics import *\nmechanics_printing(pretty_print=False)\nq1, q2, q3, u1, u2, u3  = dynamicsymbols('q1 q2 q3 u1 u2 u3')\nq1d, q2d, q3d, u1d, u2d, u3d = dynamicsymbols('q1 q2 q3 u1 u2 u3', 1)\nr, m, g = symbols('r m g')\n```\n\n----------------------------------------\n\nTITLE: Multivariate Polynomial Division in SymPy\nDESCRIPTION: Demonstrates division of multivariate polynomials using the div function in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> f = x*y + y*z\n>>> g = 3*x + 3*z\n\n>>> q, r = div(f, g, domain='QQ')\n>>> q\ny\n-\n3\n>>> r\n0\n```\n\n----------------------------------------\n\nTITLE: Processing Results from roots (Dictionary) in SymPy\nDESCRIPTION: Illustrates how to process the dictionary returned by the `roots` function using standard Python dictionary iteration (`.items()`). This example prints each unique root and its corresponding multiplicity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> my_roots = roots(expression)\n>>> my_roots\n{-2: 2, 3: 1}\n>>> for root, multiplicity in my_roots.items():\n...     print(f\"Root {root} has multiplicity of {multiplicity}\")\nRoot 3 has multiplicity of 1\nRoot -2 has multiplicity of 2\n```\n\n----------------------------------------\n\nTITLE: Reducing a Single Inequality in Python with SymPy\nDESCRIPTION: This code shows how to reduce a single inequality without using a list constructor. The function returns the solution as a logical combination of inequalities representing the range of values that satisfy the original inequality.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, reduce_inequalities, pi\n>>> x = symbols('x')\n>>> reduce_inequalities(x**2 <= pi, x)\n(x <= sqrt(pi)) & (-sqrt(pi) <= x)\n```\n\n----------------------------------------\n\nTITLE: Converting Expressions to Polynomials with as_poly Method\nDESCRIPTION: Demonstrates how to convert a polynomial expression into a formal Poly object using the as_poly() method. The resulting polynomial shows the expanded form with integer coefficients in the ZZ domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> e = (x + y)*(y - 2*z)\n>>> e.as_poly()\nPoly(x*y - 2*x*z + y**2 - 2*y*z, x, y, z, domain='ZZ')\n```\n\n----------------------------------------\n\nTITLE: Assigning a Matrix to a Slice of a SymPy Matrix in Python\nDESCRIPTION: Shows how to assign a new `Matrix` object to a slice of an existing SymPy `Matrix`. The example replaces the bottom-right 2x2 submatrix (`M[2:, 2:]`) with a 2x2 zero matrix created using a lambda function. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Matrix(([1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]))\n>>> M[2:,2:] = Matrix(2,2,lambda i,j: 0)\n>>> M\n[1   2   3  4]\n[            ]\n[5   6   7  8]\n[            ]\n[9   10  0  0]\n[            ]\n[13  14  0  0]\n```\n\n----------------------------------------\n\nTITLE: Applying Lagrange's Method in SymPy Mechanics\nDESCRIPTION: This code calculates the Lagrangian and forms the equations of motion using Lagrange's method for the Duffing oscillator with pendulum system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/duffing-example.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nL = me.Lagrangian(N, block_body, pendulum_body)\nLM = me.LagrangesMethod(L, [q1, q2], bodies=bodies, forcelist=loads, frame=N)\nsm.simplify(LM.form_lagranges_equations())\n```\n\n----------------------------------------\n\nTITLE: Solving Linear Systems with SymPy LinSolve in Python\nDESCRIPTION: Solves a linear system represented by matrix 'A' for variables 'x1' and 'x2' using SymPy's 'linsolve'. Requires suitable matrix 'A', variables, and SymPy import as 'sm'. Input is a tuple of variable symbols and output is a tuple of solution sets, appropriate for exact or symbolic solution of linear equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nsm.linsolve(A, (x1, x2))\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy and Creating Matrices from Lists/Tuples in Python\nDESCRIPTION: Imports necessary SymPy modules (`init_printing`, `Matrix`, `eye`, `zeros`, `ones`, `diag`, `GramSchmidt`) and demonstrates creating `Matrix` objects from nested lists, combining existing matrices with tuples, creating row vectors, and creating column vectors from a single list. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.interactive.printing import init_printing\n>>> init_printing(use_unicode=False)\n>>> from sympy.matrices import Matrix, eye, zeros, ones, diag, GramSchmidt\n>>> M = Matrix([[1,0,0], [0,0,0]]); M\n[1  0  0]\n[       ]\n[0  0  0]\n>>> Matrix([M, (0, 0, -1)])\n[1  0  0 ]\n[        ]\n[0  0  0 ]\n[        ]\n[0  0  -1]\n>>> Matrix([[1, 2, 3]])\n[1 2 3]\n>>> Matrix([1, 2, 3])\n[1]\n[ ]\n[2]\n[ ]\n[3]\n```\n\n----------------------------------------\n\nTITLE: Using FiberForceLengthPassiveDeGroote2016 Class in SymPy\nDESCRIPTION: Demonstrates the use of the FiberForceLengthPassiveDeGroote2016 class from sympy.physics.biomechanics to create a fiber passive force-length curve. Shows both custom and default parameter initialization.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_26\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.physics.biomechanics import FiberForceLengthPassiveDeGroote2016\n\nfl_M_pas2 = FiberForceLengthPassiveDeGroote2016(l_M/l_M_opt, c0, c1)\nfl_M_pas2\nfl_M_pas2.doit()\n\nfl_M_pas3 = FiberForceLengthPassiveDeGroote2016.with_defaults(l_M/l_M_opt)\nfl_M_pas3\nfl_M_pas3.doit()\n```\n\n----------------------------------------\n\nTITLE: Function Creation and Substitution in SymPy\nDESCRIPTION: Shows the difference between defining a function and a function evaluation, explaining why Function objects are callable but function evaluations are not. Demonstrates proper substitution for function evaluations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nf1 = Function('f1')\nf2 = Function('f2')('x')\nf1\nf1\nf2\nf2(x)\nf1(1)\nf1(1)\nf2(1)\nTraceback (most recent call last):\n...\nTypeError: 'f2' object is not callable\nf2.subs(x, 1)\nf2(1)\n```\n\n----------------------------------------\n\nTITLE: Using as_real_imag() and collect() for Complex Expansion in SymPy (Python)\nDESCRIPTION: Demonstrates alternative methods for complex expansion using as_real_imag() and collect() functions in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/rewriting.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> (x + I*y).as_real_imag()\n(re(x) - im(y), re(y) + im(x))\n\n>>> collect((x + I*y).expand(complex=True), I, evaluate=False)\n{1: re(x) - im(y), I: re(y) + im(x)}\n```\n\n----------------------------------------\n\nTITLE: Computing GCD of Polynomials with Integer Coefficients in SymPy\nDESCRIPTION: Shows how to compute the greatest common divisor of polynomials with integer coefficients in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 4*x**2 - 1\n>>> g = 8*x**3 + 1\n>>> gcd(f, g)\n2*x + 1\n>>> gcd(6*f, 3*g)\n6*x + 3\n```\n\n----------------------------------------\n\nTITLE: Calculating Spring-Damper Forces in SymPy Mechanics\nDESCRIPTION: Defines the logic within a hypothetical `to_loads` method of a SpringDamper class using `sympy.physics.mechanics` (`me`). It calculates the forces exerted by the spring-damper on its two attachment points (P1, P2) based on the spring constant `k`, damping coefficient `c`, relative displacement `x`, relative velocity `v`, and the normalized direction vector `dir_vec` between the points. It returns a list containing two `me.Force` objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n...         dir_vec = self.P2.pos_from(self.P1).normalize()\n...         force_P1 = me.Force(self.P1,\n...                             self.k*x*dir_vec + self.c*v*dir_vec)\n...         force_P2 = me.Force(self.P2,\n...                             -self.k*x*dir_vec - self.c*v*dir_vec)\n...         return [force_P1, force_P2]\n...\n```\n\n----------------------------------------\n\nTITLE: Setting up Translational Kinematics\nDESCRIPTION: Defines the contact point, position vector to center of mass, and calculates velocity of the disc's center.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nC = Point('C')\nC.set_vel(N, 0)\nDmc = C.locatenew('Dmc', r * L.z)\nDmc.v2pt_theory(C, N, R)\n```\n\n----------------------------------------\n\nTITLE: Numerically Evaluating CRootOf Objects\nDESCRIPTION: Demonstrates iterating through a list of solutions containing `CRootOf` objects (obtained from `solve`) and evaluating each root numerically to a specified precision using the `.n()` method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> for root in fifth_order_solved:\n...     print(root[x].n(10))\n-1.167303978\n-0.1812324445 - 1.083954101*I\n-0.1812324445 + 1.083954101*I\n0.7648844336 - 0.352471546*I\n0.7648844336 + 0.352471546*I\n```\n\n----------------------------------------\n\nTITLE: Computing Dot and Cross Products of Vectors in SymPy\nDESCRIPTION: Demonstrates how to compute dot and cross products of vectors using the dot() and cross() methods. It also shows the overloaded operators & and ^ for these operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nv1 = 2*N.i + 3*N.j - N.k\nv2 = N.i - 4*N.j + N.k\nv1.dot(v2)\nv1.cross(v2)\nv2.cross(v1)\nv1 & v2\nv1 ^ v2\n```\n\n----------------------------------------\n\nTITLE: Initializing Lagrange's Method with Generalized Coordinates in Python\nDESCRIPTION: Creates generalized coordinates and a Lagrangian, then initializes a LagrangesMethod object with these parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/lagrange.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.physics.mechanics import *\nq1, q2 = dynamicsymbols('q1 q2')\nq1d, q2d = dynamicsymbols('q1 q2', 1)\nL = q1d**2 + q2d**2\nLM = LagrangesMethod(L, [q1, q2])\n```\n\n----------------------------------------\n\nTITLE: Instantiating Fiber Force-Velocity Inverse Curve in SymPy\nDESCRIPTION: Creates instances of the FiberForceVelocityInverseDeGroote2016 class using both custom parameters and default values. This class models the inverse of the fiber force-velocity characteristic curve.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.biomechanics import FiberForceVelocityInverseDeGroote2016\n\nfv_M_sym = me.dynamicsymbols('fv_M')\nfv_M_inv = FiberForceVelocityInverseDeGroote2016(fv_M_sym, c0, c1, c2, c3)\nfv_M_inv\n\nfv_M_inv2 = FiberForceVelocityInverseDeGroote2016.with_defaults(fv_M_sym)\nfv_M_inv2\n```\n\n----------------------------------------\n\nTITLE: List of Tuples Return from Solve Function\nDESCRIPTION: Demonstrates solve returning a list of tuples when solving equations that contain nonlinear terms or when multiple symbols are provided in a specific order. Each tuple represents one solution set.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsolve(x - 1, x, y)  # more than one symbol\n[(1, y)]\nsolve([x**2], x)  # list with nonlinear equation\n[(0,)]\nsolve([x**2 - 1], x)\n[(-1,), (1,)]\nsolve([x**2 - y, x - 3], x, y)  # nonlinear and multiple symbols\n[(3, 9)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Expression Replacement in SymPy\nDESCRIPTION: Demonstrates a simple recursive function that traverses and replaces elements in a symbolic expression, showcasing how args invariants are used.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> def replace(expr, x, y):\n...     \"\"\"Replace x with y in expr\"\"\"\n...     newargs = []\n...     for arg in expr.args:\n...         if arg == x:\n...             newargs.append(y)\n...         else:\n...             newargs.append(replace(arg, x, y))\n...     return expr.func(*newargs)\n>>> replace(x + sin(x - 1), x, y)\ny + sin(y - 1)\n```\n\n----------------------------------------\n\nTITLE: Creating an Obstacle Set Pathway in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a more complex pathway with multiple points that the force follows. The ObstacleSetPathway connects points O, Q, R, and P with linear segments, calculating the length and extension velocity along this multi-segment path.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> Q, R = me.Point('Q'), me.Point('R')\n>>> Q.set_pos(O, 1*N.y)\n>>> R.set_pos(O, 1*N.x + 1*N.y)\n>>> opathway = me.ObstacleSetPathway(O, Q, R, P)\n>>> opathway.length\nsqrt((x(t) - 1)**2 + 1) + 2\n>>> opathway.extension_velocity\n(x(t) - 1)*Derivative(x(t), t)/sqrt((x(t) - 1)**2 + 1)\n>>> pprint.pprint(opathway.to_loads(-k*opathway.length))\n[Force(point=O, force=k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.y),\n Force(point=Q, force=- k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.y),\n Force(point=Q, force=k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.x),\n Force(point=R, force=- k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.x),\n Force(point=R, force=k*(sqrt((x(t) - 1)**2 + 1) + 2)*(x(t) - 1)/sqrt((x(t) - 1)**2 + 1)*N.x - k*(sqrt((x(t) - 1)**2 + 1) + 2)/sqrt((x(t) - 1)**2 + 1)*N.y),\n Force(point=P, force=- k*(sqrt((x(t) - 1)**2 + 1) + 2)*(x(t) - 1)/sqrt((x(t) - 1)**2 + 1)*N.x + k*(sqrt((x(t) - 1)**2 + 1) + 2)/sqrt((x(t) - 1)**2 + 1)*N.y)]\n```\n\n----------------------------------------\n\nTITLE: Orienting New Coordinate Systems in SymPy\nDESCRIPTION: This snippet shows how to create a new coordinate system B that is rotated with respect to system A's Z-axis by an angle theta. It demonstrates two methods: using CoordSys3D directly and using Orienter classes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nfrom sympy import Symbol\nA = CoordSys3D('A')\ntheta = Symbol('theta')\nB = A.orient_new_axis('B', theta, A.k)\n\nfrom sympy.vector import AxisOrienter\naxis_orienter = AxisOrienter(theta, A.k)\nB = A.orient_new('B', axis_orienter)\n```\n\n----------------------------------------\n\nTITLE: Defining Joints and Constraints for Four Bar Linkage in Python\nDESCRIPTION: This snippet creates pin joints between the links of the four bar linkage and adds them to the system. It then formulates the holonomic constraint to close the kinematic loop and adds it to the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/four_bar_linkage_example.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\njoint1 = PinJoint('J1', link1, link2, coordinates=q1, speeds=u1,\n                  parent_point=l1/2*link1.x,\n                  child_point=-l2/2*link2.x, joint_axis=link1.z)\njoint2 = PinJoint('J2', link2, link3, coordinates=q2, speeds=u2,\n                  parent_point=l2/2*link2.x,\n                  child_point=-l3/2*link3.x, joint_axis=link2.z)\njoint3 = PinJoint('J3', link3, link4, coordinates=q3, speeds=u3,\n                  parent_point=l3/2*link3.x,\n                  child_point=-l4/2*link4.x, joint_axis=link3.z)\nsystem.add_joints(joint1, joint2, joint3)\n\nstart_point = link1.masscenter.locatenew('start_point', -l1/2*link1.x)\nend_point = link4.masscenter.locatenew('end_point', l4/2*link4.x)\nloop = end_point.pos_from(start_point)\nsystem.add_holonomic_constraints(loop.dot(link1.x), loop.dot(link1.y))\n```\n\n----------------------------------------\n\nTITLE: Calculating Scalar Potential of Conservative Field in SymPy\nDESCRIPTION: This code snippet illustrates how to calculate the scalar potential field corresponding to a given conservative vector field using SymPy's scalar_potential function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame, scalar_potential\n>>> R = ReferenceFrame('R')\n>>> conservative_field = 4*R[0]*R[1]*R[2]*R.x + 2*R[0]**2*R[2]*R.y + 2*R[0]**2*R[1]*R.z\n>>> scalar_potential(conservative_field, R)\n2*R_x**2*R_y*R_z\n```\n\n----------------------------------------\n\nTITLE: MIMO System Analysis\nDESCRIPTION: Analyzes a Multiple Input Multiple Output (MIMO) system using transfer function matrices. Includes calculation of system matrix, pole-zero analysis, and response plotting.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/control_problems.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Matrix, laplace_transform, inverse_laplace_transform, exp, cos, sqrt, sin, pprint\nfrom sympy.abc import s, t\nfrom sympy.physics.control import *\n\ng = Matrix([[exp(-t)*(1 - t), exp(-2*t)], [5*exp((-2*t))-exp((-t)), (cos((sqrt(3)*t)/2) - 3*sqrt(3)*sin((sqrt(3)*t)/2))*exp(-t/2)]])\nG = g.applyfunc(lambda a: laplace_transform(a, t, s)[0])\nG = TransferFunctionMatrix.from_Matrix(G, s)\n```\n\n----------------------------------------\n\nTITLE: Defining Points for Bicycle Model in Python\nDESCRIPTION: Creates points representing key locations on the bicycle, such as wheel contact points, centers of mass, and the steering connection point.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> WR_cont = me.Point('WR_cont')\n>>> WR_mc = WR_cont.locatenew('WR_mc', WRrad*R.z)\n>>> Steer = WR_mc.locatenew('Steer', framelength*Frame.z)\n>>> Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1*Frame.x + framecg3*Frame.z)\n>>> Fork_mc = Steer.locatenew('Fork_mc', -forkcg1*Fork.x + forkcg3*Fork.z)\n>>> WF_mc = Steer.locatenew('WF_mc', forklength*Fork.x + forkoffset*Fork.z)\n>>> WF_cont = WF_mc.locatenew('WF_cont', WFrad*(me.dot(Fork.y, Y.z)*Fork.y - Y.z).normalize())\n```\n\n----------------------------------------\n\nTITLE: Converting Meijer G-functions to Holonomic with SymPy in Python\nDESCRIPTION: The from_meijerg function enables the conversion of Meijer G-functions into holonomic representations using the SymPy holonomic module. It operates specifically on Meijer G-function inputs recognized by SymPy, returning a holonomic form that can be manipulated by SymPy's differential operator routines. Required dependencies include the sympy.holonomic.holonomic module and Meijer G-function support.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/convert.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.holonomic.holonomic import from_meijerg\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Symbols in SymPy Mechanics\nDESCRIPTION: Examples of defining dynamic symbols (time-varying quantities) in SymPy Mechanics. This is equivalent to using 'Specified' and 'Variables' keywords in Autolev.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nphi = me.dynamicsymbols('phi')\nq, s = me.dynamicsymbols('q s')\nx = me.dynamicsymbols('x')\nxd = me.dynamicsymbols('x', 1)\n```\n\n----------------------------------------\n\nTITLE: Orienting a Reference Frame Around an Axis - SymPy - Python\nDESCRIPTION: Illustrates using the orient method to set the orientation of a reference frame 'A' with respect to another frame 'N' by a rotation about a given axis (here, N.y) by a symbolic angle x. Required are the sympy.physics.vector module and already created frames (here N and A). No direct output, but the DCM (direction cosine matrix) is updated.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> A.orient(N, 'Axis', [x, N.y])\n```\n\n----------------------------------------\n\nTITLE: Creating Numerical Functions for System Dynamics in SymPy\nDESCRIPTION: Generates lambda functions to evaluate the mass matrix, forcing vector, and activation dynamics. Uses SymPy's lambdify function with common subexpression elimination for efficiency.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> eval_diffeq = sm.lambdify((q, u, a, e, p),\n...                           (kane.mass_matrix, kane.forcing, dadt), cse=True)\n>>> eval_holonomic = sm.lambdify((q, p), holonomic, cse=True)\n```\n\n----------------------------------------\n\nTITLE: Numerically Solving a System of Equations with SymPy in Python\nDESCRIPTION: Shows how to use nsolve to solve a system of multidimensional functions. It requires supplying tuples of functions, variables to solve for, and starting values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, nsolve\n>>> x1 = Symbol('x1')\n>>> x2 = Symbol('x2')\n>>> f1 = 3 * x1**2 - 2 * x2**2 - 1\n>>> f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8\n>>> print(nsolve((f1, f2), (x1, x2), (-1, 1)))\nMatrix([[-1.19287309935246], [1.27844411169911]])\n```\n\n----------------------------------------\n\nTITLE: Optimal Implementation of Fuzzy-Bool Logic Using SymPy Functions\nDESCRIPTION: This function shows the most concise and correct way to implement fuzzy-bool logic using SymPy's fuzzy_and function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> def both_positive_best(a, b):\n...     \"\"\"ask whether a and b are both positive\"\"\"\n...     return fuzzy_and([a.is_positive, b.is_positive])\n```\n\n----------------------------------------\n\nTITLE: Constructing Domains for SymPy Expressions in Python\nDESCRIPTION: Uses the construct_domain function to automatically choose an appropriate domain for given SymPy expressions and convert them to that domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import construct_domain, Integer\n>>> elements_sympy = [Integer(3), Integer(2)]  # elements as Expr instances\n>>> elements_sympy\n[3, 2]\n>>> K, elements_K = construct_domain(elements_sympy)\n>>> K\nZZ\n>>> elements_K\n[3, 2]\n>>> type(elements_sympy[0])\n<class 'sympy.core.numbers.Integer'>\n>>> type(elements_K[0])  # doctest: +SKIP\n<class 'int'>\n```\n\n----------------------------------------\n\nTITLE: Defining Inertia Dyadic and RigidBody for Rolling Disc in Python\nDESCRIPTION: This code forms the inertia dyadic for the rolling disc and creates a RigidBody object. It specifies the mass distribution and sets up the disc as a rigid body with its center of mass, reference frame, mass, and inertia.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_lagrange.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nI = inertia(L, m / 4 * r**2, m / 2 * r**2, m / 4 * r**2)\nmprint(I)\nBodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n```\n\n----------------------------------------\n\nTITLE: Generating Centered Difference Approximation for First Derivative in Python\nDESCRIPTION: Creates a centered difference approximation for the first derivative using three points. This example demonstrates a more efficient method using only two function evaluations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom __future__ import print_function\nfrom sympy import *\nx, x0, h = symbols('x, x_i, h')\nFi, Fim1, Fip1 = symbols('F_{i}, F_{i-1}, F_{i+1}')\nn = 3\nc = symbols('c:3')\ndef P(x, x0, c, n):\n   return sum( ((1/factorial(i))*c[i] * (x-x0)**i for i in range(n)) )\nm11 = P(x0 , x0, c, n).diff(c[0])\nm12 = P(x0 , x0, c, n).diff(c[1])\nm13 = P(x0 , x0, c, n).diff(c[2])\nm21 = P(x0-h, x0, c, n).diff(c[0])\nm22 = P(x0-h, x0, c, n).diff(c[1])\nm23 = P(x0-h, x0, c, n).diff(c[2])\nm31 = P(x0+h, x0, c, n).diff(c[0])\nm32 = P(x0+h, x0, c, n).diff(c[1])\nm33 = P(x0+h, x0, c, n).diff(c[2])\nM = Matrix([[m11, m12, m13], [m21, m22, m23], [m31, m32, m33]])\nR = Matrix([[Fi], [Fim1], [Fip1]])\nX =  M.inv() * R\nprint(\"The second-order accurate approximation for the first derivative is: \")\nprint(together(X[1]))\n```\n\n----------------------------------------\n\nTITLE: Simple univariate polynomial factorization in SymPy\nDESCRIPTION: Using factor() and primitive() functions to factorize univariate polynomials. The factor() function returns the result in unevaluated form, while primitive() returns both the content and primitive part of the polynomial.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> factor(6*x - 10)\n2⋅(3⋅x - 5)\n\n>>> primitive(6*x - 10)\n(2, 3⋅x - 5)\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Symbols\nDESCRIPTION: Demonstrates how to properly create and use symbolic variables in SymPy using the symbols() function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx = symbols('x')\nx + 1\n```\n\n----------------------------------------\n\nTITLE: Extracting Constants from Inequality Solutions in Python with SymPy\nDESCRIPTION: This example shows how to extract the constants (bounds) from a solution by accessing the arguments of the solution expression. It identifies whether the variable is on the left or right side of each relation to properly extract the bounds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, reduce_inequalities, pi\n>>> x = symbols('x')\n>>> eq = reduce_inequalities([3*x >= 1, x**2 <= pi], x); eq\n(1/3 <= x) & (x <= sqrt(pi))\n>>> eq.args\n(1/3 <= x, x <= sqrt(pi))\n>>> constants = []\n>>> for arg in eq.args:\n...     if arg.lhs == x:\n...         constants.append(arg.rhs)\n...     else:\n...         constants.append(arg.lhs)\n>>> constants\n[1/3, sqrt(pi)]\n```\n\n----------------------------------------\n\nTITLE: Series Configuration Analysis\nDESCRIPTION: Computes equivalent system matrices for series configurations and closed-loop feedback systems. Shows manipulation of transfer function matrices and feedback calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/control_problems.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Matrix, pprint\nfrom sympy.abc import s, t\nfrom sympy.physics.control import *\n\nP_mat = Matrix([[1/s, 2/(2+s)], [0, 3]])\nC_mat = Matrix([[1, 1], [2, 2]])\nP = TransferFunctionMatrix.from_Matrix(P_mat, var=s)\nC = TransferFunctionMatrix.from_Matrix(C_mat, var=s)\ntfm_feedback = MIMOFeedback(P, C, sign=-1)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Symbol Substitution Issues with dynamicsymbols\nDESCRIPTION: Shows how SymPy's default substitution behavior can cause issues with dynamicsymbols by replacing symbols inside derivatives, which may be undesired in mechanics applications.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/advanced.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import dynamicsymbols\n>>> x = dynamicsymbols('x')\n>>> expr = x.diff() + x\n>>> sub_dict = {x: 1}\n>>> expr.subs(sub_dict)\nDerivative(1, t) + 1\n```\n\n----------------------------------------\n\nTITLE: Creating SymPy Matrices Using a Lambda Function in Python\nDESCRIPTION: Shows how to create a 3x4 SymPy `Matrix` using a `lambda` function. The lambda function `lambda i,j: 1 - (i+j) % 2` defines the matrix elements based on the row `i` and column `j` indices, resulting in a checkerboard pattern. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> Matrix(3, 4, lambda i,j: 1 - (i+j) % 2)\n[1  0  1  0]\n[          ]\n[0  1  0  1]\n[          ]\n[1  0  1  0]\n```\n\n----------------------------------------\n\nTITLE: Calculating Vector Magnitude and Direction in Python\nDESCRIPTION: This snippet demonstrates how to calculate the magnitude and direction of a vector in 3D space using Python-like syntax. It shows the computation for a displacement vector and its unit vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/intro.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Given displacement vector\ndisplacement = 3*i_hat + 4*j_hat + 5*k_hat\n\n# Calculate magnitude\nmagnitude = sqrt(3**2 + 4**2 + 5**2)\n\n# Calculate direction (unit vector)\nunit_vector = displacement / magnitude\n\n# Results\ndistance = magnitude  # 5*sqrt(2) m\ndirection = (3/(5*sqrt(2)))*i_hat + (4/(5*sqrt(2)))*j_hat + (5/(5*sqrt(2)))*k_hat\n```\n\n----------------------------------------\n\nTITLE: Defining System Parameters for Muscle-actuated Mechanical System\nDESCRIPTION: Creates a parameter vector containing all constant values needed for the simulation, including geometric dimensions, masses, gravity, stiffness, damping, and muscle properties. These parameters define the physical characteristics of the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> p = sm.Matrix([\n...     dx,\n...     dy,\n...     dz,\n...     lA,\n...     lC,\n...     lD,\n...     mA,\n...     mC,\n...     mD,\n...     g,\n...     k,\n...     c,\n...     r,\n...     biceps.F_M_max,\n...     biceps.l_M_opt,\n...     biceps.l_T_slack,\n...     triceps.F_M_max,\n...     triceps.l_M_opt,\n...     triceps.l_T_slack,\n... ])\n...\n>>> p\nMatrix([\n[               dx],\n[               dy],\n[               dz],\n[               lA],\n[               lC],\n[               lD],\n[               mA],\n[               mC],\n[               mD],\n[                g],\n[                k],\n[                c],\n[                r],\n[   F_M_max_biceps],\n[   l_M_opt_biceps],\n[ l_T_slack_biceps],\n[  F_M_max_triceps],\n[  l_M_opt_triceps],\n[l_T_slack_triceps]])\n```\n\n----------------------------------------\n\nTITLE: Accessing Basis Vectors in SymPy Coordinate System\nDESCRIPTION: Demonstrates how to access the basis vectors (i, j, k) of a CoordSys3D instance. These vectors are instances of the BaseVector class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nN.i\ntype(N.i)\n```\n\n----------------------------------------\n\nTITLE: Setting Up KanesMethod with Constraints\nDESCRIPTION: Comprehensive example showing how to initialize a KanesMethod object with dependent coordinates, dependent speeds, configuration constraints, and velocity constraints.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> N = ReferenceFrame('N')\n>>> q1, q2, q3, q4 = dynamicsymbols('q1 q2 q3 q4')\n>>> q1d, q2d, q3d, q4d = dynamicsymbols('q1 q2 q3 q4', 1)\n>>> u1, u2, u3, u4 = dynamicsymbols('u1 u2 u3 u4')\n>>> #Here we will assume q2 is dependent, and u2 and u3 are dependent\n>>> speed_cons = [u2 - u1, u3 - u1 - u4]\n>>> coord_cons = [q2 - q1]\n>>> q_ind = [q1, q3, q4]\n>>> q_dep = [q2]\n>>> u_ind = [u1, u4]\n>>> u_dep = [u2, u3]\n>>> kd = [q1d - u1, q2d - u2, q3d - u3, q4d - u4]\n>>> KM = KanesMethod(N, q_ind, u_ind, kd,\n...           q_dependent=q_dep,\n...           configuration_constraints=coord_cons,\n...           u_dependent=u_dep,\n...           velocity_constraints=speed_cons)\n```\n\n----------------------------------------\n\nTITLE: Simplification, Expansion, and Substitution of Expressions with SymPy in Python\nDESCRIPTION: These snippets show how to declare an expression, expand it, factor it (via Horner form), collect coefficients, substitute subexpressions, and selectively collect/extract terms according to variables. The dependencies are the 'sm' module (SymPy), symbolic variables, and SymPy expressions. Outputs are new (not in-place) transformed expressions. Limitations include the need to assign results to capture changes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nE = (x+2*y)**2 + 3*(7+x)*(x+y)\n```\n\nLANGUAGE: python\nCODE:\n```\nsm.expand(E)\n```\n\nLANGUAGE: python\nCODE:\n```\nsm.horner(E, wrt=x)\n```\n\nLANGUAGE: python\nCODE:\n```\ny.coeff(x)\n```\n\nLANGUAGE: python\nCODE:\n```\ny.subs({sm.sin(x): 3})\n```\n\nLANGUAGE: python\nCODE:\n```\ne.collect(x).coeff(x, 0)\n```\n\nLANGUAGE: python\nCODE:\n```\ne.collect(x).coeff(x, 1)\n```\n\nLANGUAGE: python\nCODE:\n```\ne.collect(y)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fu Function with Common Factor Recognition\nDESCRIPTION: Example of how the fu function can recognize and simplify terms with common factors, transforming expressions like a*cos(x)*cos(y) + a*sin(x)*sin(y) to a*cos(x-y).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> fu(a*cos(x)*cos(y) + a*sin(x)*sin(y))\na*cos(x - y)\n```\n\n----------------------------------------\n\nTITLE: Setting Point Velocity and Acceleration in SymPy\nDESCRIPTION: Shows how to create a Point object, set its velocity in a ReferenceFrame, and compute/set its acceleration. Demonstrates both automatic computation of acceleration through time derivatives and manual setting.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> O = Point('O')\n>>> O.set_vel(N, u1*N.x)\n>>> O.vel(N)\nu1*N.x\n\n>>> O.acc(N)\nu1'*N.x\n>>> O.set_acc(N, u2*u1*N.y)\n>>> O.acc(N)\nu1*u2*N.y\n```\n\n----------------------------------------\n\nTITLE: Solving ODEs Using Option 2 Syntax (Defining Function of Independent Variable)\nDESCRIPTION: Shows an alternative approach to defining functions for ODEs where the function is explicitly defined in terms of its independent variable.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Function, dsolve\n>>> t = symbols('t')\n>>> y = Function('y')(t)\n>>> y\ny(t)\n>>> yp = y.diff(t)\n>>> ypp = yp.diff(t)\n>>> eq = ypp + 2*yp + y\n>>> eq\ny(t) + 2*Derivative(y(t), t) + Derivative(y(t), (t, 2))\n>>> dsolve(eq, y)\nEq(y(t), (C1 + C2*t)*exp(-t))\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Solutions from SymPy dsolve in Python\nDESCRIPTION: Demonstrates how to process the nested list output of SymPy's `dsolve` when multiple solution sets exist for a system of ODEs. It shows two methods (a standard loop and a list comprehension) to convert the list of equality lists into a list of dictionaries, mapping each function (lhs) to its solution expression (rhs) for easier access.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_13\n\nLANGUAGE: py\nCODE:\n```\n>>> from sympy import symbols, Eq, Function, dsolve\n>>> y, z = symbols(\"y z\", cls=Function)\n>>> x = symbols(\"x\")\n>>> eqs = [Eq(y(x).diff(x)**2, z(x)**2), Eq(z(x).diff(x), z(x))]\n>>> solutions = dsolve(eqs, [y(x), z(x)])\n>>> solutions\n[[Eq(y(x), C1 - C2*exp(x)), Eq(z(x), C2*exp(x))], [Eq(y(x), C1 + C2*exp(x)), Eq(z(x), C2*exp(x))]]\n>>> # Nested list approach\n>>> solutions_list = []\n>>> for solution in solutions:\n...     solution_dict = {}\n...     for fn in solution:\n...             solution_dict.update({fn.lhs: fn.rhs})\n...     solutions_list.append(solution_dict)\n>>> solutions_list\n[{y(x): C1 - C2*exp(x), z(x): C2*exp(x)}, {y(x): C1 + C2*exp(x), z(x): C2*exp(x)}]\n>>> # Nested comprehension approach\n>>> solutions_list = [{fn.lhs:fn.rhs for fn in solution} for solution in solutions]\n>>> solutions_list\n[{y(x): C1 - C2*exp(x), z(x): C2*exp(x)}, {y(x): C1 + C2*exp(x), z(x): C2*exp(x)}]\n>>> # Extract expression for y(x)\n>>> solutions_list[0][y(x)]\nC1 - C2*exp(x)\n```\n\n----------------------------------------\n\nTITLE: Creating a HolonomicFunction for sin(x) in SymPy (Python)\nDESCRIPTION: Demonstrates instantiating a `HolonomicFunction` object in SymPy to represent the function sin(x). It first initializes the differential operator algebra `R` and the operator `D` over the polynomial ring `ZZ[x]` using `DifferentialOperators`. Then, it creates the `HolonomicFunction` instance using the annihilator `D**2 + 1` (representing the differential equation y'' + y = 0), the independent variable `x`, the point `0` for specifying initial conditions, and the initial condition values `[y(0)=0, y'(0)=1]`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/represent.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.holonomic import DifferentialOperators, HolonomicFunction\n>>> from sympy.abc import x\n>>> from sympy import ZZ\n>>> R, D = DifferentialOperators(ZZ.old_poly_ring(x), 'D')\n>>> HolonomicFunction(D**2 + 1, x, 0, [0, 1])\nHolonomicFunction((1) + (1)*D**2, x, 0, [0, 1])\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy Mechanics and SymPy in Python\nDESCRIPTION: Import statements for using SymPy Mechanics and SymPy in Python. These imports are assumed to be executed before the examples in the comparison tables.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sympy.physics.mechanics as me\nimport sympy as sm\n```\n\n----------------------------------------\n\nTITLE: Vector Algebra Operations in SymPy Physics\nDESCRIPTION: Demonstrates basic algebraic operations on basis vectors, including equality comparison, addition, and scalar multiplication.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> N.x == N.x\nTrue\n>>> N.x == N.y\nFalse\n>>> N.x + N.y\nN.x + N.y\n>>> 2 * N.x + N.y\n2*N.x + N.y\n```\n\n----------------------------------------\n\nTITLE: Solving Polynomial Roots with SymPy in Python\nDESCRIPTION: Demonstrates finding roots of a quadratic or higher-order polynomial using Poly objects and the 'sm.solve()' method. Shows both direct equation and matrix-based coefficient forms. Needs 'sm' (SymPy), symbolic or numeric coefficients, and the variable of interest. Outputs are lists of solutions/roots. Suited for symbolic or exact root computation, with links to mpmath for numerical evaluation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsm.solve(sm.Poly(a*x**2 + b*x + c))\n```\n\nLANGUAGE: python\nCODE:\n```\nsm.solve(sm.Poly(sm.Matrix([1,2,3]).reshape(3, 1), x), x)\n```\n\n----------------------------------------\n\nTITLE: Plotting Fiber Force-Velocity Curve in Python\nDESCRIPTION: This code snippet demonstrates how to plot the fiber force-velocity curve using matplotlib and SymPy's FiberForceVelocityDeGroote2016 class. It creates a plot of normalized fiber velocity vs. normalized fiber force-velocity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_32\n\nLANGUAGE: Python\nCODE:\n```\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import FiberForceVelocityDeGroote2016\n\n>>> v_M_tilde = me.dynamicsymbols('v_M_tilde')\n>>> fv_M = FiberForceVelocityDeGroote2016.with_defaults(v_M_tilde)\n>>> fv_M_callable = sm.lambdify(v_M_tilde, fv_M)\n>>> v_M_tilde_num = np.linspace(-1.0, 1.0)\n\n>>> fig, ax = plt.subplots()\n```\n\n----------------------------------------\n\nTITLE: Creating a JAX-aware Function using lambdify for JIT Compilation in Python\nDESCRIPTION: Shows how to use `lambdify` with the 'jax' backend. This leverages JAX for just-in-time (JIT) compilation to XLA, enabling acceleration on CPUs, GPUs, and TPUs. Requires the JAX library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> f = lambdify(x, expr, \"jax\")\n>>> import jax.numpy as jnp\n>>> data = jnp.linspace(1, 10, 10000)\n>>> y = f(data) # perform the computation\n>>> numpy.asarray(y) # explicitly copy to CPU / numpy array\narray([ 0.84147096,  0.8411998 ,  0.84092844, ..., -0.05426079,\n   -0.05433151, -0.05440211], dtype=float32)\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber Force-Length Active Curve in SymPy\nDESCRIPTION: This snippet demonstrates the implementation of the fiber active force-length curve using SymPy symbols and the FiberForceLengthActiveDeGroote2016 class. It shows both manual equation creation and use of the pre-defined class with custom and default parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_29\n\nLANGUAGE: Python\nCODE:\n```\n>>> constants = sm.symbols('c0:12')\n>>> c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11 = constants\n\n>>> fl_M_act = (c0*sm.exp(-(((l_M_tilde - c1)/(c2 + c3*l_M_tilde))**2)/2) + c4*sm.exp(-(((l_M_tilde - c5)/(c6 + c7*l_M_tilde))**2)/2) + c8*sm.exp(-(((l_M_tilde - c9)/(c10 + c11*l_M_tilde))**2)/2))\n>>> fl_M_act\nc0*exp(-(-c1 + l_M_tilde(t))**2/(2*(c2 + c3*l_M_tilde(t))**2)) + c4*exp(-(-c5 + l_M_tilde(t))**2/(2*(c6 + c7*l_M_tilde(t))**2)) + c8*exp(-(-c9 + l_M_tilde(t))**2/(2*(c10 + c11*l_M_tilde(t))**2))\n\n>>> from sympy.physics.biomechanics import FiberForceLengthActiveDeGroote2016\n\n>>> fl_M_act2 = FiberForceLengthActiveDeGroote2016(l_M/l_M_opt, *constants)\n>>> fl_M_act2\nFiberForceLengthActiveDeGroote2016(l_M(t)/l_M_opt, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11)\n>>> fl_M_act2.doit()\nc0*exp(-(-c1 + l_M(t)/l_M_opt)**2/(2*(c2 + c3*l_M(t)/l_M_opt)**2)) + c4*exp(-(-c5 + l_M(t)/l_M_opt)**2/(2*(c6 + c7*l_M(t)/l_M_opt)**2)) + c8*exp(-(-c9 + l_M(t)/l_M_opt)**2/(2*(c10 + c11*l_M(t)/l_M_opt)**2))\n\n>>> fl_M_act3 = FiberForceLengthActiveDeGroote2016.with_defaults(l_M/l_M_opt)\n>>> fl_M_act3\nFiberForceLengthActiveDeGroote2016(l_M(t)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)\n>>> fl_M_act3.doit()\n0.1*exp(-3.98991349867535*(-1 + l_M(t)/l_M_opt)**2) + 0.433*exp(-12.5*(-0.717 + l_M(t)/l_M_opt)**2/(-0.1495 + l_M(t)/l_M_opt)**2) + 0.814*exp(-21.4067977442463*(-1 + 0.943396226415094*l_M(t)/l_M_opt)**2/(1 + 0.390740740740741*l_M(t)/l_M_opt)**2)\n```\n\n----------------------------------------\n\nTITLE: Initializing Vector in Reference Frame\nDESCRIPTION: Creates a vector using SymPy's ReferenceFrame class with components in x, y, and z directions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.vector import ReferenceFrame\nR = ReferenceFrame('R')\nv = 3*R.x + 4*R.y + 5*R.z\n```\n\n----------------------------------------\n\nTITLE: Accessing SymPy Singleton Integer Zero via S in Python\nDESCRIPTION: This snippet illustrates accessing the singleton instance of the SymPy integer 0 using `S.Zero`. The `S` object in SymPy holds singleton instances of common mathematical objects (like 0, 1, infinity) as an optimization to save memory, ensuring only one instance exists. It requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/glossary.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nS.Zero\n```\n\n----------------------------------------\n\nTITLE: Symbol Value Persistence\nDESCRIPTION: Illustrates how SymPy symbols maintain their symbolic nature even when Python variables are reassigned.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = symbols('x')\nexpr = x + 1\nx = 2\nprint(expr)\n```\n\n----------------------------------------\n\nTITLE: Creating Force Models with Spring-Damper in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a spring-damper force model in SymPy mechanics. The example shows a particle P moving in reference frame N with a spring and damper acting on it, defining the position, velocity, and resulting forces.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import sympy as sm\n>>> import sympy.physics.mechanics as me\n\n>>> k, c = sm.symbols('k, c', real=True, nonnegative=True)\n>>> x = me.dynamicsymbols('x', real=True)\n\n>>> N = me.ReferenceFrame('N')\n>>> O, P = me.Point('O'), me.Point('P')\n\n>>> P.set_pos(O, x*N.x)\n>>> P.set_vel(N, x.diff()*N.x)\n\n>>> force_on_P = me.Force(P, -k*P.pos_from(O) - c*P.vel(N))\n>>> force_on_P\n(P, (-c*Derivative(x(t), t) - k*x(t))*N.x)\n```\n\n----------------------------------------\n\nTITLE: Series and Integral Evaluation\nDESCRIPTION: Demonstrates numerical evaluation of infinite series and integrals with arbitrary precision.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> var('n x')\n(n, x)\n>>> Sum(1/n**n, (n, 1, oo)).evalf()\n1.29128599706266\n>>> Integral(x**(-x), (x, 0, 1)).evalf()\n1.29128599706266\n```\n\n----------------------------------------\n\nTITLE: Visualizing Simulation Results for Muscle-actuated System\nDESCRIPTION: Plots the simulation results using the previously defined plotting function. Shows the time evolution of the system's generalized coordinates, velocities, and muscle activations during passive motion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> plot_traj(ts, sol.y.T, x)\n[[<Axes: ylabel='$q_{1}{\\\\left(t \\\\right)}$'>\n  <Axes: ylabel='$u_{2}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{2}{\\\\left(t \\\\right)}$'>\n  <Axes: ylabel='$u_{3}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{3}{\\\\left(t \\\\right)}$'>\n  <Axes: ylabel='$u_{4}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{4}{\\\\left(t \\\\right)}$'>\n  <Axes: ylabel='$a_{biceps}{\\\\left(t \\\\right)}$'>]]\n```\n\n----------------------------------------\n\nTITLE: Setting Angular Velocities for Bicycle Components in Python\nDESCRIPTION: Defines the angular velocities for each reference frame in the bicycle model, including yaw, roll, wheel rotations, frame pitch, and fork steering.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> Y.set_ang_vel(N, u1 * Y.z)\n>>> R.set_ang_vel(Y, u2 * R.x)\n>>> WR.set_ang_vel(Frame, u3 * Frame.y)\n>>> Frame.set_ang_vel(R, u4 * Frame.y)\n>>> Fork.set_ang_vel(Frame, u5 * Fork.x)\n>>> WF.set_ang_vel(Fork, u6 * Fork.y)\n```\n\n----------------------------------------\n\nTITLE: Nonlinear System Solving\nDESCRIPTION: Examples of solving nonlinear systems of equations using nonlinsolve, showing real, complex, and mixed solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/solvers.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na, b, c, d = symbols('a, b, c, d', real=True)\nnonlinsolve([a**2 + a, a - b], [a, b])\nnonlinsolve([x**2 + 1, y**2 + 1], [x, y])\nsystem = [x**2 - 2*y**2 -2, x*y - 2]\nnonlinsolve(system, [x, y])\n```\n\n----------------------------------------\n\nTITLE: Computing Gröbner Bases in SymPy\nDESCRIPTION: Demonstrates how to compute reduced Gröbner bases for polynomial systems using the groebner function, which is useful for solving polynomial equation systems.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nf = expand((1 - c**2)**5 * (1 - s**2)**5 * (c**2 + s**2)**10)\n```\n\nLANGUAGE: python\nCODE:\n```\ngroebner([f, c**2 + s**2 - 1])\n```\n\nLANGUAGE: python\nCODE:\n```\nlist(map(factor, _))\n```\n\nLANGUAGE: python\nCODE:\n```\nsolve([f, s**2 + c**2 - 1], c, s)\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Dyadics in SymPy\nDESCRIPTION: Demonstrates the creation of dyadics using the outer product of vectors. It shows basic operations with dyadics and how to compute dot and cross products involving dyadics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nN = CoordSys3D('N')\nN.i.outer(N.j)\nN.i|N.j\ndyad = N.i.outer(N.k)\ndyad*3\ndyad - dyad\ndyad + 2*(N.j|N.i)\nd = N.i.outer(N.j)\nd.dot(N.j|N.j)\nd.dot(N.i)\nd.dot(N.j)\nN.i.dot(d)\nN.k ^ d\n```\n\n----------------------------------------\n\nTITLE: Expression Expansion and Factoring in SymPy\nDESCRIPTION: Demonstrates SymPy's expand() and factor() functions for algebraic manipulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/intro.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import expand, factor\n>>> expanded_expr = expand(x*expr)\n>>> expanded_expr\nx**2 + 2*x*y\n>>> factor(expanded_expr)\nx*(x + 2*y)\n```\n\n----------------------------------------\n\nTITLE: Combining Vectors from Multiple Reference Frames - SymPy - Python\nDESCRIPTION: Shows how to add basis vectors from different reference frames, forming a new vector. This lays the groundwork for multi-frame manipulations but doesn't yet define their interaction for operations like multiplication. Requires SymPy and frames 'N' and 'A'. Output is a sum of basis vectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> A = ReferenceFrame('A')\\n>>> A.x + N.x\\nN.x + A.x\n```\n\n----------------------------------------\n\nTITLE: Substituting Symbols in SymPy Matrices using subs in Python\nDESCRIPTION: Shows how to perform symbolic substitution within a SymPy `Matrix` using the `subs()` method. First, a matrix `M` containing the symbol `x` is created. Then, `x` is substituted with the integer `4` and subsequently with another symbol `y`. Requires `sympy.Symbol` and `sympy.Matrix`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol\n>>> x = Symbol('x')\n>>> M = eye(3) * x\n>>> M\n[x  0  0]\n[       ]\n[0  x  0]\n[       ]\n[0  0  x]\n>>> M.subs(x, 4)\n[4  0  0]\n[       ]\n[0  4  0]\n[       ]\n[0  0  4]\n>>> y = Symbol('y')\n>>> M.subs(x, y)\n[y  0  0]\n[       ]\n[0  y  0]\n[       ]\n[0  0  y]\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules for SymbolicSystem in SymPy\nDESCRIPTION: Imports the necessary modules from SymPy for creating a SymbolicSystem, including symbols, Matrix, dynamicsymbols, and mechanics components.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import atan, symbols, Matrix\nfrom sympy.physics.mechanics import (dynamicsymbols, ReferenceFrame,\n                                      Particle, Point)\nimport sympy.physics.mechanics.system as system\nfrom sympy.physics.vector import init_vprinting\ninit_vprinting(pretty_print=False)\n```\n\n----------------------------------------\n\nTITLE: Boolean or Relational Return from Solve Function\nDESCRIPTION: Shows solve returning Boolean expressions or relational expressions when solving inequalities or mixed equation types. This behavior is equivalent to using reduce_inequalities on the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsolve([x**2 > 4, x > 0])\n(2 < x) & (x < oo)\n\nfrom sympy import Unequality as Ne\nsolve([x**2 - 4, Ne(x, -2)])\nEq(x, 2)\n\n{_.lhs: _.rhs}\n{x: 2}\n```\n\n----------------------------------------\n\nTITLE: Factoring with Exact vs Float Values\nDESCRIPTION: Illustrates how using floating-point numbers can prevent proper factorization compared to using exact values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import factor\n>>> factor(x**2.0 - 1)\nx**2.0 - 1\n>>> factor(x**2 - 1)\n(x - 1)*(x + 1)\n```\n\n----------------------------------------\n\nTITLE: Numerical Evaluation and Visualization with PyDy in Python\nDESCRIPTION: This snippet demonstrates how to use PyDy for numerical evaluation and visualization of a dynamic system. It shows setting up a System object with KanesMethod, integrating the equations of motion, and plotting the results using matplotlib.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom numpy import array, linspace, sin\nfrom pydy.system import System\n\nsys = System(kane,\n             constants = {mass: 1.0, stiffness: 1.0,\n                          damping: 0.2, gravity: 9.8},\n             specifieds = {force: lambda x, t: sin(t)},\n             initial_conditions = {position: 0.1, speed:-1.0},\n             times = linspace(0.0, 10.0, 1000))\n\ny = sys.integrate()\n\nimport matplotlib.pyplot as plt\nplt.plot(sys.times, y)\nplt.legend((str(position), str(speed)))\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Applying Finite Difference to Symbolic Lists in Python using SymPy\nDESCRIPTION: This code shows how to use SymPy's apply_finite_diff function to apply finite difference methods to symbolic lists of x and y values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> x_list = [-3, 1, 2]\n>>> y_list = symbols('a b c')\n>>> apply_finite_diff(1, x_list, y_list, 0)\n  3⋅a   b   2⋅c\n- ─── - ─ + ───\n   20   4    5\n```\n\n----------------------------------------\n\nTITLE: Creating Vector Expressions in SymPy\nDESCRIPTION: Shows how to create vector expressions using scalar multiplication, addition, and subtraction of basis vectors. The resulting objects are instances of VectorMul or VectorAdd classes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv = 2*N.i + N.j\ntype(v)\nv - N.j\ntype(v - N.j)\n```\n\n----------------------------------------\n\nTITLE: Correct Symbolic Expression Building in SymPy\nDESCRIPTION: Shows the proper way to build expressions using SymPy's symbolic objects and operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Add, Symbol\n>>> expr = Add(*[i*Symbol(f'x_{i}') for i in range(10)])\n>>> expr\nx_1 + 2*x_2 + 3*x_3 + 4*x_4 + 5*x_5 + 6*x_6 + 7*x_7 + 8*x_8 + 9*x_9\n```\n\n----------------------------------------\n\nTITLE: Computing GCD of Integers in SymPy\nDESCRIPTION: Demonstrates the use of the igcd function to compute the greatest common divisor of integers in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> igcd(2, 4)\n2\n>>> igcd(5, 10, 15)\n5\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Functions in SymPy\nDESCRIPTION: Example showing how to create and use generic function objects in SymPy, including how to differentiate between built-in and user-defined functions using atoms() method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/core.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, cos\n>>> from sympy.abc import x\n>>> f = Function('f')\n>>> f(2) + f(x)\nf(2) + f(x)\n\n>>> e = (f(x) + cos(x) + 2)\n>>> e.atoms(Function)\n{f(x), cos(x)}\n\n>>> from sympy.core.function import AppliedUndef\n>>> e.atoms(AppliedUndef)\n{f(x)}\n```\n\n----------------------------------------\n\nTITLE: Adding Two Holonomic Functions in SymPy (Python)\nDESCRIPTION: This snippet computes the sum of two holonomic functions, p and q, yielding the holonomic representation of e^x + sin(x). It assumes p and q have been correctly initialized as HolonomicFunction objects. The operation involves symbolic addition, and the output is a new HolonomicFunction representing the sum with its annihilating operator and initial conditions calculated automatically.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> p + q\\nHolonomicFunction((-1) + (1)*Dx + (-1)*Dx**2 + (1)*Dx**3, x, 0, [1, 2, 1])\n```\n\n----------------------------------------\n\nTITLE: Testing Autowrapped Matrix-Vector Product in Python\nDESCRIPTION: This snippet shows how to test the autowrapped matrix-vector product function using Python lists, which are silently converted to numpy arrays. It demonstrates the usage of the generated matvec function with a 2x2 matrix and a 2-element vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/autowrap.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nM = [[0, 1],\n     [1, 0]]\nmatvec(M, [2, 3])                              # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy and Mechanics Modules for Rolling Disc Simulation in Python\nDESCRIPTION: This snippet imports necessary SymPy modules and defines symbolic variables for the rolling disc simulation. It sets up configuration variables, their derivatives, and physical constants like radius, mass, and gravity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_lagrange.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import symbols, cos, sin\nfrom sympy.physics.mechanics import *\nmechanics_printing(pretty_print=False)\nq1, q2, q3 = dynamicsymbols('q1 q2 q3')\nq1d, q2d, q3d = dynamicsymbols('q1 q2 q3', 1)\nr, m, g = symbols('r m g')\n```\n\n----------------------------------------\n\nTITLE: Re-expressing Fields in Different Reference Frames\nDESCRIPTION: Example of expressing a field in a different reference frame using orientation relationships.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.vector import ReferenceFrame, dynamicsymbols, express\nR = ReferenceFrame('R')\nelectric_potential = 2*R[0]**2*R[1]\nq = dynamicsymbols('q')\nR1 = R.orientnew('R1', rot_type = 'Axis', amounts = [q, R.z])\nexpress(electric_potential, R1, variables=True)\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Set Unions in Python\nDESCRIPTION: Demonstrates how set unions can be treated as a combination of elements for iteration, regardless of element distinctiveness.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/sets.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n\\{a, b\\} \\cup \\{x, y\\}\n```\n\n----------------------------------------\n\nTITLE: Defining Point Locations in SymPy\nDESCRIPTION: Demonstrates how to define the location of points relative to other points or origins in SymPy. This is crucial for setting up kinematic problems.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nQ.point = O.locatenew('Qo', LA*A.x)\n```\n\nLANGUAGE: python\nCODE:\n```\nQ.point = P.point.locatenew('Qo', LA*A.x)\n```\n\n----------------------------------------\n\nTITLE: Automatic Evaluation of Floating-Point Inputs in Custom SymPy Function\nDESCRIPTION: This code snippet shows how implementing _eval_evalf enables automatic evaluation when the function is called with floating-point inputs, without needing to explicitly call evalf().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> versin(1.)\n0.459697694131860\n```\n\n----------------------------------------\n\nTITLE: Extracting Elements from a Matrix Solution\nDESCRIPTION: Demonstrates methods to extract individual elements from a matrix solution, either by iterating through the matrix or by using direct element access with subscripts.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> [element for element in solution]\n    ⎡  2⋅e       2   ⎤\n    ⎢───────, ───────⎥\n    ⎣c⋅e + d  c⋅e + d⎦\n```\n\n----------------------------------------\n\nTITLE: Setting Mass and Inertia in SymPy Mechanics\nDESCRIPTION: Shows how to set mass and inertia for physical entities in SymPy mechanics. This includes assigning symbolic mass values and creating inertia dyadics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nmB = symbols('mB')\nB.mass = mB\n\nI = me.inertia(Bf, i1, i2, i3, i12, i23, i31)\nB.inertia = (I, P)\n```\n\n----------------------------------------\n\nTITLE: Computing Electric Field from Potential in Python\nDESCRIPTION: This snippet shows how to compute an electric field (vector field) from an electric potential (scalar field) using gradient operations, and then calculate the magnitude of the electric field.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/intro.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Electric potential (scalar field)\nV = 2*x**2*y\n\n# Electric field (vector field) - gradient of potential\nE = grad(V)\n# E = 4*x*y*i_hat + 2*x**2*j_hat\n\n# Magnitude of electric field (scalar field)\nE_magnitude = sqrt(4*x**4 + 16*x**2*y**2)\n```\n\n----------------------------------------\n\nTITLE: Processing Results from real_roots (List) in SymPy\nDESCRIPTION: Demonstrates how to iterate through the list of roots returned by `real_roots` and use standard Python list processing techniques. This example substitutes each found root back into the original expression to verify it evaluates to zero.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> expression = (x+2)**2 * (x-3)\n>>> my_real_roots = real_roots(expression)\n>>> my_real_roots\n[-2, -2, 3]\n>>> for root in my_real_roots:\n...         print(f\"expression({root}) = {expression.subs(x, root)}\")\nexpression(-2) = 0\nexpression(-2) = 0\nexpression(3) = 0\n```\n\n----------------------------------------\n\nTITLE: Using Symbolic Booleans in Piecewise Functions\nDESCRIPTION: This snippet shows how symbolic Booleans can be used in SymPy's Piecewise functions, and how they evaluate when substituting values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Piecewise\n>>> p = Piecewise((1, x > 0), (2, True))\n>>> p\nPiecewise((1, x > 0), (2, True))\n>>> p.subs(x, 3)\n1\n```\n\n----------------------------------------\n\nTITLE: Checking Deduced 'is_zero' Assumption for 'versin' (Python)\nDESCRIPTION: Shows a more complex deduction by SymPy's assumption system. By defining `n` as an integer symbol, `versin(2*n*pi).is_zero` evaluates to `True`. This deduction relies on the definition of `versin`, the properties of `cos`, and the integer nature of `n`, potentially utilizing the `_eval_is_positive` handler which returns `False` for even multiples of pi.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, pi\n>>> # Assuming 'versin' class is defined as before\n>>> n = symbols('n', integer=True)\n>>> versin(2*n*pi).is_zero\nTrue\n```\n\n----------------------------------------\n\nTITLE: Plotting Fiber Force-Length Passive Curve in Python\nDESCRIPTION: This snippet demonstrates how to plot the fiber force-length passive curve using matplotlib and SymPy's FiberForceLengthPassiveDeGroote2016 class. It creates a plot of normalized fiber length vs. normalized fiber passive force-length.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_27\n\nLANGUAGE: Python\nCODE:\n```\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import FiberForceLengthPassiveDeGroote2016\n\n>>> l_M_tilde = me.dynamicsymbols('l_M_tilde')\n>>> fl_M_pas = FiberForceLengthPassiveDeGroote2016.with_defaults(l_M_tilde)\n>>> fl_M_pas_callable = sm.lambdify(l_M_tilde, fl_M_pas)\n>>> l_M_tilde_num = np.linspace(0.0, 2.0)\n\n>>> fig, ax = plt.subplots()\n>>> _ = ax.plot(l_M_tilde_num, fl_M_pas_callable(l_M_tilde_num))\n>>> _ = ax.set_xlabel('Normalized fiber length')\n>>> _ = ax.set_ylabel('Normalized fiber passive force-length')\n```\n\n----------------------------------------\n\nTITLE: Finding Only Real Roots with real_roots() in SymPy\nDESCRIPTION: Using real_roots() to find only the real roots of a polynomial, ignoring complex roots. This is useful when working with applications that require only real solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import real_roots\n>>> from sympy.abc import x\n>>> cubed = x**3 - 1\n>>> # roots() returns real and complex roots\n>>> roots(cubed)\n{1: 1, -1/2 - sqrt(3)*I/2: 1, -1/2 + sqrt(3)*I/2: 1}\n>>> # real_roots() returns only real roots\n>>> real_roots(cubed)\n[1]\n```\n\n----------------------------------------\n\nTITLE: Multi-step Color Gradients in SymPy Plots\nDESCRIPTION: Shows how to define a color gradient with multiple steps for more complex color schemes. This example creates a four-step color gradient.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngradient = [ 0.0, (0.1,0.1,0.9), 0.3, (0.1,0.9,0.1),\n             0.7, (0.9,0.9,0.1), 1.0, (1.0,0.0,0.0) ]\np[1].color = (Fx**2 + Fy**2 + Fz**2)**(0.5), gradient\n```\n\n----------------------------------------\n\nTITLE: Computing Groebner Bases with SymPy\nDESCRIPTION: Examples of computing Groebner bases for polynomial systems using different orderings (lex and grevlex).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> groebner([x**2 + 1, y**4*x + x**3], x, y, order='lex')\n                 /[ 2       4    ]                            \\\nGroebnerBasis\\[x  + 1, y  - 1], x, y, domain=ZZ, order=lex/\n\n>>> groebner([x**2 + 1, y**4*x + x**3, x*y*z**3], x, y, z, order='grevlex')\n                 /[ 4       3   2    ]                                   \\\nGroebnerBasis\\[y  - 1, z , x  + 1], x, y, z, domain=ZZ, order=grevlex/\n```\n\n----------------------------------------\n\nTITLE: Implementing 2-Point Theorem for Translating Rotating Disc\nDESCRIPTION: Demonstrates the implementation of the 2-point theorem for a translating, rotating disc. Shows how to set up reference frames, points, and compute velocities and accelerations using v2pt_theory and a2pt_theory.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> N = ReferenceFrame('N')\n>>> u1, u2, u3 = dynamicsymbols('u1 u2 u3')\n>>> R = Symbol('R')\n>>> B = ReferenceFrame('B')\n>>> O = Point('O')\n>>> O.set_vel(N, u1 * N.x + u2 * N.y)\n>>> P = O.locatenew('P', R * B.x)\n>>> B.set_ang_vel(N, u3 * B.z)\n>>> P.v2pt_theory(O, N, B)\nu1*N.x + u2*N.y + R*u3*B.y\n>>> P.a2pt_theory(O, N, B)\nu1'*N.x + u2'*N.y - R*u3**2*B.x + R*u3'*B.y\n```\n\n----------------------------------------\n\nTITLE: Defining Physical Entities in SymPy Mechanics\nDESCRIPTION: Demonstrates how to define physical entities like bodies, frames, particles, and points using SymPy's mechanics module. It shows the equivalent SymPy code for Autolev's Bodies, Frames, and Particles declarations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nm = sm.symbols('m')\nAo = sm.symbols('Ao')\nAf = me.ReferenceFrame('Af')\nI = me.outer(Af.x,Af.x)\nP = me.Point('P')\nA = me.RigidBody('A', Ao, Af, m, (I, P))\n\nA = me.ReferenceFrame('A')\nv1 = x1*A.x + x2*A.y\n\nN = me.ReferenceFrame('N')\n\nm = sm.symbols('m')\nPo = me.Point('Po')\nC = me.Particle('C', Po, m)\n\nP = me.Point('P')\nQ = me.Point('Q')\n```\n\n----------------------------------------\n\nTITLE: Manual Linearization for Improved Performance in Python\nDESCRIPTION: This snippet demonstrates a manual approach to linearization that can be faster for large symbolic systems. It evaluates the matrices without solving for A and B, then applies the operating point and solves manually.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> M, A, B = linearizer.linearize()\n>>> M_op = msubs(M, op_point)\n>>> A_op = msubs(A, op_point)\n>>> perm_mat = linearizer.perm_mat\n>>> A_lin = perm_mat.T * M_op.LUsolve(A_op)\n>>> A_lin\nMatrix([\n[     0, 1],\n[-g/L, 0]])\n```\n\n----------------------------------------\n\nTITLE: Initializing Symbols for Multi-DOF Holonomic System in Python\nDESCRIPTION: This snippet defines the necessary symbols for the system, including generalized coordinates, speeds, forces, and system parameters using SymPy's dynamicsymbols and symbols functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/multi_degree_freedom_holonomic_system.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import zeros, symbols\nfrom sympy.physics.mechanics import *\nq1, q2, q3, u1, u2, u3 = dynamicsymbols('q1, q2, q3, u1, u2, u3')\nF, T = dynamicsymbols('F, T')\nl, k, c, g, kT = symbols('l, k, c, g, kT')\nma, mb, mc, IBzz= symbols('ma, mb, mc, IBzz')\n```\n\n----------------------------------------\n\nTITLE: Implementing divides() with doit() Method in SymPy\nDESCRIPTION: Implementation of a custom divides() function with both eval() and doit() methods. The doit() method handles symbolic evaluation of divisibility using assumptions, while eval() handles basic integer cases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_30\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Integer\nclass divides(Function):\n    @classmethod\n    def eval(cls, m, n):\n        if isinstance(m, Integer) and isinstance(n, Integer):\n            return int(n % m == 0)\n\n        if m.is_integer is False or n.is_integer is False:\n            raise TypeError(\"m and n should be integers\")\n\n    def doit(self, deep=False, **hints):\n        m, n = self.args\n        if deep:\n           m, n = m.doit(deep=deep, **hints), n.doit(deep=deep, **hints)\n\n        isint = (n/m).is_integer\n        if isint is True:\n            return Integer(1)\n        elif isint is False:\n            return Integer(0)\n        else:\n            return divides(m, n)\n```\n\n----------------------------------------\n\nTITLE: Creating Inertia Dyadics using the inertia() Function\nDESCRIPTION: Demonstrates how to create inertia dyadics using the inertia() function, which allows specification of moments of inertia for both symmetrical and asymmetrical objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import ReferenceFrame, inertia\n>>> N = ReferenceFrame('N')\n\n>>> # Supply a reference frame and the moments of inertia if the object\n>>> # is symmetrical:\n>>> inertia(N, 1, 2, 3)\n(N.x|N.x) + 2*(N.y|N.y) + 3*(N.z|N.z)\n\n>>> # Supply a reference frame along with the products and moments of inertia\n>>> # for a general object:\n>>> inertia(N, 1, 2, 3, 4, 5, 6)\n(N.x|N.x) + 4*(N.x|N.y) + 6*(N.x|N.z) + 4*(N.y|N.x) + 2*(N.y|N.y) + 5*(N.y|N.z) + 6*(N.z|N.x) + 5*(N.z|N.y) + 3*(N.z|N.z)\n```\n\n----------------------------------------\n\nTITLE: List of Dictionaries Return from Solve Function\nDESCRIPTION: Shows solve returning a list of dictionaries when the solution order would be ambiguous, such as when no symbols are specified or symbols are passed as a set. Each dictionary represents one solution set.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsolve(x - y)\n[{x: y}]\nsolve([exp(x) - 1, x*(x - 1)])\n[{x: 0}]\nsystem = [x + y - z, x**2 - y + z, exp(z) + 1/x + 1/y - 2]\nsol = solve(system[:2]); sol\n[{x: -1, y: z + 1}, {x: 0, y: z}]\n```\n\n----------------------------------------\n\nTITLE: Revealing Noncontributing Forces in Four Bar Linkage System using Python\nDESCRIPTION: This snippet introduces auxiliary speeds and forces to reveal noncontributing forces at the closing joint. It modifies the velocity constraints, adds noncontributing forces, and solves for their values in a simple configuration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/four_bar_linkage_example.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nuaux1, uaux2 = dynamicsymbols('uaux1:3')\nend_point_aux = end_point.locatenew('end_point_aux', 0)\nend_point_aux.set_vel(N, end_point.vel(N) + uaux1*N.x + uaux2*N.y)\n\nsystem.velocity_constraints = [\n   end_point_aux.vel(N).dot(N.x), end_point_aux.vel(N).dot(N.y)]\n\nfaux1, faux2 = dynamicsymbols('faux1:3')\nend_point_forces = end_point.locatenew('end_point_forces', 0)\nend_point_forces.set_vel(N, uaux1*N.x + uaux2*N.y)\nnoncontributing_forces = [Force(end_point_forces, faux1*N.x + faux2*N.y)]\n\nsystem.add_loads(*noncontributing_forces)\nsystem.u_aux = [uaux1, uaux2]\n\ng = symbols('g')\nsystem.apply_uniform_gravity(-g*N.y)\nsystem.validate_system()\neoms = system.form_eoms()\n\nauxiliary_eqs = system.eom_method.auxiliary_eqs\nforces_eqs = Matrix.LUsolve(\n  *linear_eq_to_matrix(auxiliary_eqs, [faux1, faux2]))\nsubs = {\n  l1: 2, l2: 1, l3: 2, l4: 1,\n  rho: 5, g: 9.81,\n  q1: pi/2, q2: pi/2, q3: pi/2,\n  u1: 0, u2: 0, u3: 0, u1.diff(): 0, u2.diff(): 0, u3.diff(): 0,\n}\nforces_eqs.xreplace(subs)\n```\n\n----------------------------------------\n\nTITLE: Inconsistent Symbol Assumptions in SymPy\nDESCRIPTION: Demonstrates the potential issues that can arise when the same symbol name is defined with different assumptions, leading to unequal symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> z1 = symbols('z')\n>>> z2 = symbols('z', positive=True)\n>>> z1 == z2\nFalse\n>>> z1 + z2\nz + z\n```\n\n----------------------------------------\n\nTITLE: Kinematic Differential Equations and Momentum in SymPy\nDESCRIPTION: Shows how to generate kinematic differential equations and calculate linear momentum in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nKM.kindiffdict()\n```\n\nLANGUAGE: python\nCODE:\n```\nlinear_momentum(N, B1, B2 ...)\n```\n\n----------------------------------------\n\nTITLE: Property-Based Testing with Hypothesis in SymPy\nDESCRIPTION: Example of property-based testing using Hypothesis library to test modular arithmetic. The test generates random integers and verifies that SymPy's Mod function behaves correctly for various inputs.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom hypothesis import given\nfrom hypothesis import strategies as st\nfrom sympy import symbols\nfrom sympy import Mod\n\n\n@given(a = st.integers(), p = st.integers().filter(lambda p: p != 0), i = st.integers(),\nj = st.integers().filter(lambda j: j != 0))\ndef test_modular(a, p, i, j):\n    x, y = symbols('x y')\n    value = Mod(x, y).subs({x: a, y: p})\n    assert value == a % p\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reference Frames and Angular Velocities\nDESCRIPTION: This code defines the reference frames, their orientations, and sets the angular velocities for the rolling disc simulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nN = ReferenceFrame('N')\nY = N.orientnew('Y', 'Axis', [q1, N.z])\nL = Y.orientnew('L', 'Axis', [q2, Y.x])\nR = L.orientnew('R', 'Axis', [q3, L.y])\nw_R_N_qd = R.ang_vel_in(N)\nR.set_ang_vel(N, u1 * L.x + u2 * L.y + u3 * L.z)\n```\n\n----------------------------------------\n\nTITLE: Handling Overconstrained Systems\nDESCRIPTION: Shows an example of an overconstrained system of equations (more equations than unknowns) that has no solution. SymPy returns an empty list for such cases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x, y, z\n>>> solve([x + y - z, x - (z + 1), 2*x - y], [x, y], dict=True)\n[]\n```\n\n----------------------------------------\n\nTITLE: Creating a Reference Frame in SymPy Physics\nDESCRIPTION: Demonstrates how to import the physics.vector module and create a ReferenceFrame object representing a reference frame N.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.physics.vector import *\n>>> N = ReferenceFrame('N')\n```\n\n----------------------------------------\n\nTITLE: Using TendonForceLengthInverseDeGroote2016 Class in SymPy\nDESCRIPTION: Shows how to use the TendonForceLengthInverseDeGroote2016 class to create the inverse of the tendon force-length curve. This is useful for deriving equations describing musculotendon dynamics with elastic tendons.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_24\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.physics.biomechanics import TendonForceLengthInverseDeGroote2016\n\nfl_T_sym =me.dynamicsymbols('fl_T')\nfl_T_inv = TendonForceLengthInverseDeGroote2016(fl_T_sym, c0, c1, c2, c3)\nfl_T_inv\n\nfl_T_inv2 = TendonForceLengthInverseDeGroote2016.with_defaults(fl_T_sym)\nfl_T_inv2\n```\n\n----------------------------------------\n\nTITLE: Computing Vector Cross Products with Multiple Interfaces - SymPy - Python\nDESCRIPTION: Demonstrates how to compute cross products between vectors using both method and function interfaces in sympy.physics.vector. The code includes cases involving same and orthogonal vectors and showcases linearity over vector sums. Requires SymPy and properly initialized reference frame 'N'. Outputs are vectors, possibly in negative direction. Parentheses grouping is recommended when mixing vector operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> N.x.cross(N.x)\\n0\\n>>> N.x.cross(N.z)\\n- N.y\\n>>> cross(N.x, N.y)\\nN.z\\n>>> cross(N.x, (N.y + N.z))\\n- N.y + N.z\n```\n\n----------------------------------------\n\nTITLE: Numerical Evaluation in SymPy\nDESCRIPTION: Using evalf method for numerical evaluation of expressions with arbitrary precision and handling of numerical substitutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/basic_operations.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nexpr = sqrt(8)\nexpr.evalf()\n\npi.evalf(100)\n\nexpr = cos(2*x)\nexpr.evalf(subs={x: 2.4})\n\none = cos(1)**2 + sin(1)**2\n(one - 1).evalf()\n(one - 1).evalf(chop=True)\n```\n\n----------------------------------------\n\nTITLE: Power Expansion with expand_power_base\nDESCRIPTION: Shows how to expand power expressions using expand_power_base function, demonstrating both default behavior and forced expansion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nexpand_power_base((z*t)**c)\nexpand_power_base((z*t)**c, force=True)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Obstacle Pathway Forces in SymPy Mechanics\nDESCRIPTION: Shows how to simplify the forces generated by an obstacle pathway by substituting a specific value for the coordinate. This makes it easier to verify that the collection of forces is correct.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> for load in opathway.to_loads(-k*opathway.length):\n...     pprint.pprint(me.Force(load[0], load[1].subs({x: 1})))\nForce(point=O, force=3*k*N.y)\nForce(point=Q, force=- 3*k*N.y)\nForce(point=Q, force=3*k*N.x)\nForce(point=R, force=- 3*k*N.x)\nForce(point=R, force=- 3*k*N.y)\nForce(point=P, force=3*k*N.y)\n```\n\n----------------------------------------\n\nTITLE: Initializing Symbols and Bodies for Four Bar Linkage in Python\nDESCRIPTION: This snippet defines the necessary symbols and bodies for a four bar linkage system. It creates dynamicsymbols for angles and angular velocities, and symbols for link lengths and density. It then initializes rigid bodies for each link and creates a System object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/four_bar_linkage_example.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Matrix, linear_eq_to_matrix, pi, simplify, symbols\nfrom sympy.physics.mechanics import *\nmechanics_printing(pretty_print=False)\nq1, q2, q3, u1, u2, u3 = dynamicsymbols('q1:4, u1:4')\nl1, l2, l3, l4, rho = symbols('l1:5, rho')\n\nN = ReferenceFrame('N')\nmass_centers = [Point(f'mc{i}') for i in range(1, 5)]\ninertias = [Inertia.from_inertia_scalars(P, N, 0, 0, rho*l**3/12)\n            for P, l in zip(mass_centers, (l1, l2, l3, l4))]\nlink1 = RigidBody('Link1', frame=N, mass=rho*l1,\n                  masscenter=mass_centers[0], inertia=inertias[0])\nlink2 = RigidBody('Link2', mass=rho*l2, masscenter=mass_centers[1],\n                  inertia=inertias[1])\nlink3 = RigidBody('Link3', mass=rho*l3, masscenter=mass_centers[2],\n                  inertia=inertias[2])\nlink4 = RigidBody('Link4', mass=rho*l4, masscenter=mass_centers[3],\n                  inertia=inertias[3])\nsystem = System.from_newtonian(link1)\n```\n\n----------------------------------------\n\nTITLE: Common Subexpression Detection and Collection in SymPy (Python)\nDESCRIPTION: Demonstrates the use of SymPy's cse function for identifying and collecting common subexpressions in large expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/rewriting.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import cse, sqrt, sin, pprint\n>>> from sympy.abc import x\n\n>>> pprint(cse(sqrt(sin(x))), use_unicode=True)\n⎛    ⎡  ________⎤⎞\n⎝[], ⎣╲╱ sin(x) ⎦⎠\n\n>>> pprint(cse(sqrt(sin(x)+5)*sqrt(sin(x)+4)), use_unicode=True)\n⎛                ⎡  ________   ________⎤⎞\n⎝[(x₀, sin(x))], ⎣╲╱ x₀ + 4 ⋅╲╱ x₀ + 5 ⎦⎠\n\n>>> pprint(cse(sqrt(sin(x+1) + 5 + cos(y))*sqrt(sin(x+1) + 4 + cos(y))),\n...     use_unicode=True)\n⎛                             ⎡  ________   ________⎤⎞\n⎝[(x₀, sin(x + 1) + cos(y))], ⎣╲╱ x₀ + 4 ⋅╲╱ x₀ + 5 ⎦⎠\n\n>>> pprint(cse((x-y)*(z-y) + sqrt((x-y)*(z-y))), use_unicode=True)\n⎛                          ⎡  ____     ⎤⎞\n⎝[(x₀, (x - y)⋅(-y + z))], ⎣╲╱ x₀  + x₀⎦⎠\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Custom expreal Function with Special Values (Python)\nDESCRIPTION: This snippet shows the evaluation of the previously defined `expreal` function. When called with `1`, it remains unevaluated as `expreal(1)` because `1` doesn't match any special cases in `eval`. When called with `0`, `-oo` (negative infinity), or `oo` (positive infinity), the `eval` method simplifies the expression to `1`, `0`, and `oo` respectively, based on the assumption checks.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import oo\n>>> expreal(1)\nexpreal(1)\n>>> expreal(0)\n1\n>>> expreal(-oo)\n0\n>>> expreal(oo)\noo\n```\n\n----------------------------------------\n\nTITLE: Attempting Single G-Function Rewrite in SymPy Integration\nDESCRIPTION: Internal SymPy helper function within the Meijer G-function integration module. It coordinates the process of trying to rewrite the input expression as a single G-function, primarily by calling `_rewrite_single`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n_rewrite1\n```\n\n----------------------------------------\n\nTITLE: Substituting and Evaluating Expressions with SymPy in Python\nDESCRIPTION: These code examples use SymPy's substitution and evaluation functions to assign values to variables within expressions and compute their numerical (floating point) equivalents. Dependencies include 'sm' (SymPy) and necessary symbolic variables. Inputs are variable-value pairs, outputs are replaced or numerically evaluated expressions. The '.evalf()' method is shown for explicit numeric conversion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nE.subs([(x, a), (y, 2)])\n```\n\nLANGUAGE: python\nCODE:\n```\nE.evalf((a + sm.pi).subs({a: 3}))\n```\n\n----------------------------------------\n\nTITLE: Solving Equation with Aversin Function in Python\nDESCRIPTION: Demonstrates solving an equation involving the aversin function using the solve function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import solve\nsolve(aversin(x) - y, x)\n```\n\n----------------------------------------\n\nTITLE: Component-wise Color Specification in SymPy Plots\nDESCRIPTION: Demonstrates specifying colors by assigning different functions to red, green, and blue components. Multiple syntax options are shown.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\np[1].color = z,y,x, (0.4,0.4,0.4), (0.9,0.9,0.9)\n```\n\n----------------------------------------\n\nTITLE: Handling Multi-Variable Inequalities with Single Variable of Interest in Python with SymPy\nDESCRIPTION: This code demonstrates how SymPy can solve a system of inequalities with multiple variables if there is only one symbol of interest per inequality. The result includes constraints on the other variables.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import reduce_inequalities, symbols\n>>> x, y = symbols(\"x y\")\n>>> reduce_inequalities([x + y > 1, y > 0], x)\n(0 < y) & (y < oo) & (x > 1 - y)\n```\n\n----------------------------------------\n\nTITLE: Implementing Rigid Tendon Musculotendon Dynamics in SymPy\nDESCRIPTION: Defines symbols and calculates muscle fiber length, velocity, force characteristics, and tendon force for a rigid tendon model. This implementation follows the DeGroote 2016 musculotendon model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nl_MT, v_MT, a = me.dynamicsymbols('l_MT, v_MT, a')\nl_T_slack, l_M_opt, F_M_max = sm.symbols('l_T_slack, l_M_opt, F_M_max')\nv_M_max, alpha_opt, beta = sm.symbols('v_M_max, alpha_opt, beta')\n\nl_M = sm.sqrt((l_MT - l_T_slack)**2 + (l_M_opt*sm.sin(alpha_opt))**2)\nl_M\n\nv_M = v_MT*(l_MT - l_T_slack)/l_M\nv_M\n\nfl_M_pas = FiberForceLengthPassiveDeGroote2016.with_defaults(l_M/l_M_opt)\nfl_M_pas\n\nfl_M_act = FiberForceLengthActiveDeGroote2016.with_defaults(l_M/l_M_opt)\nfl_M_act\n\nfv_M = FiberForceVelocityDeGroote2016.with_defaults(v_M/v_M_max)\nfv_M\n\nF_M = a*fl_M_act*fv_M + fl_M_pas + beta*v_M/v_M_max\nF_M\n\nF_T = F_M_max*F_M*sm.sqrt(1 - sm.sin(alpha_opt)**2)\nF_T\n```\n\n----------------------------------------\n\nTITLE: Initializing Matrix-Vector Product with Autowrap in Python\nDESCRIPTION: This snippet demonstrates how to set up a binary routine for a matrix-vector product using SymPy's autowrap module and Indexed classes. It defines symbolic matrices and vectors, creates an equation for the product, and uses autowrap to generate and compile the code.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/autowrap.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.utilities.autowrap import autowrap\nfrom sympy import symbols, IndexedBase, Idx, Eq\nA, x, y = map(IndexedBase, ['A', 'x', 'y'])\nm, n = symbols('m n', integer=True)\ni = Idx('i', m)\nj = Idx('j', n)\ninstruction = Eq(y[i], A[i, j]*x[j]); instruction\nmatvec = autowrap(instruction)                 # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Creating an Inertia Object in SymPy Mechanics\nDESCRIPTION: Shows how to create an Inertia object that consists of a dyadic and a reference point. The dyadic represents the inertia tensor and the point specifies where the inertia is defined.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import ReferenceFrame, Point, outer, Inertia\n>>> A = ReferenceFrame('A')\n>>> P = Point('P')\n>>> Inertia(P, outer(A.x, A.x))\n((A.x|A.x), P)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unsolvable ODE System (Double Pendulum) with SymPy dsolve (Python)\nDESCRIPTION: Demonstrates attempting to solve the system of non-linear differential equations describing a double pendulum using SymPy's `dsolve`. This system is known to be chaotic and lacks a closed-form symbolic solution. As expected, `dsolve` raises a `NotImplementedError`, signifying its inability to find an analytical solution for this complex system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_17\n\nLANGUAGE: py\nCODE:\n```\n>>> from sympy import symbols, Function, cos, sin, dsolve\n>>> theta1, theta2 = symbols('theta1 theta2', cls=Function)\n>>> g, t = symbols('g t')\n>>> eq1 = 2*theta1(t).diff(t, t) + theta2(t).diff(t, t)*cos(theta1(t) - theta2(t)) + theta2(t).diff(t)**2*sin(theta1(t) - theta2(t)) + 2*g*sin(theta1(t))\n>>> eq2 = theta2(t).diff(t, t) + theta1(t).diff(t, t)*cos(theta1(t) - theta2(t)) - theta1(t).diff(t)**2*sin(theta1(t) - theta2(t)) + g*sin(theta2(t))\n>>> dsolve([eq1, eq2], [theta1(t), theta2(t)])\nTraceback (most recent call last):\n...\nNotImplementedError\n```\n\n----------------------------------------\n\nTITLE: Creating Symbols with Unusual Names in SymPy\nDESCRIPTION: Shows how to use the Symbol() constructor directly to create symbols with unusual characters in their names or when creating symbols programmatically.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol\n>>> x_y = Symbol('x y') # This creates a single symbol named 'x y'\n```\n\n----------------------------------------\n\nTITLE: Initializing KanesMethod Object in Python with Basic System Parameters\nDESCRIPTION: Creates a KanesMethod object by specifying an inertial reference frame, coordinates, and speeds. This is the basic starting point for applying Kane's method in sympy.physics.mechanics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.physics.mechanics import *\n>>> N = ReferenceFrame('N')\n>>> q1, q2, u1, u2 = dynamicsymbols('q1 q2 u1 u2')\n>>> q1d, q2d, u1d, u2d = dynamicsymbols('q1 q2 u1 u2', 1)\n>>> KM = KanesMethod(N, [q1, q2], [u1, u2])\n```\n\n----------------------------------------\n\nTITLE: Differentiating the FMA Function in SymPy\nDESCRIPTION: Examples demonstrating how to take derivatives of the FMA function with respect to different variables, showcasing the implementation of the fdiff method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n>>> FMA(x, x, y).diff(x)\n2*x\n>>> FMA(x, y, x).diff(x)\ny + 1\n```\n\n----------------------------------------\n\nTITLE: Calculating Momenta in a Dynamic System\nDESCRIPTION: Demonstrates a complete example of setting up a dynamic system with a particle and rigid body, including the creation of reference frames, points, and velocity calculations for momentum analysis.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import dynamicsymbols, ReferenceFrame\n>>> from sympy.physics.mechanics import RigidBody, Particle, Point, outer\n>>> from sympy.physics.mechanics import linear_momentum, angular_momentum\n>>> from sympy.physics.vector import init_vprinting\n>>> init_vprinting(pretty_print=False)\n>>> m, M, l1 = symbols('m M l1')\n>>> q1d = dynamicsymbols('q1d')\n>>> N = ReferenceFrame('N')\n>>> O = Point('O')\n>>> O.set_vel(N, 0 * N.x)\n>>> Ac = O.locatenew('Ac', l1 * N.x)\n>>> P = Ac.locatenew('P', l1 * N.x)\n>>> a = ReferenceFrame('a')\n>>> a.set_ang_vel(N, q1d * N.z)\n>>> Ac.v2pt_theory(O, N, a)\nl1*q1d*N.y\n>>> P.v2pt_theory(O, N, a)\n2*l1*q1d*N.y\n>>> Pa = Particle('Pa', P, m)\n>>> I = outer(N.z, N.z)\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy and Setting Up Symbolic Variables\nDESCRIPTION: Initializes the SymPy environment by importing all components and creating symbolic variables x, y, and z. The init_printing function configures the output display format.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> x, y, z = symbols('x,y,z')\n>>> init_printing(use_unicode=False)\n```\n\n----------------------------------------\n\nTITLE: Building Expressions with SymPy Functions in Python\nDESCRIPTION: These snippets combine various SymPy mathematical functions—absolute value, sine, and arccosine—on symbolic variables to demonstrate construction of composite expressions. Dependencies include 'sm' alias for SymPy and symbolic input variables. Outputs are unevaluated symbolic expressions suitable for further transformation or evaluation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsm.abs(x)**3 + sm.sin(x)**2 + sm.acos(x)\n```\n\n----------------------------------------\n\nTITLE: Checking Solenoidal Vector Field in SymPy\nDESCRIPTION: This snippet demonstrates how to check if a vector field is solenoidal using SymPy's is_solenoidal function. It also shows that the divergence of a solenoidal field is zero.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame, is_solenoidal\n>>> R = ReferenceFrame('R')\n>>> field = R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z\n>>> is_solenoidal(field)\nTrue\n>>> divergence(field, R)\n0\n```\n\n----------------------------------------\n\nTITLE: Setting Initial State Values\nDESCRIPTION: Defines the initial state values for position, velocity, and activation of the muscle. Position is set to optimal length plus slack length, velocity to zero, and activation to a small non-zero value.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nx_vals = np.array([\n    p_vals[3] + p_vals[4],  # q [m]\n    0.0,  # u [m/s]\n    0.1,  # a [unitless]\n])\n```\n\n----------------------------------------\n\nTITLE: Examining Root Properties with SymPy RootOf Objects\nDESCRIPTION: Demonstrates how to analyze root properties using RootOf objects, including numerical approximation, checking if roots are real, and finding conjugate pairs. Shows how RootOf objects preserve exact relationships between roots.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> r0.n()\n-1.16730397826142\n>>> r0.is_real\nTrue\n>>> r1.n()\n-0.181232444469875 - 1.08395410131771*I\n>>> r2.n()\n-0.181232444469875 + 1.08395410131771*I\n>>> r1\n        / 5           \\\nCRootOf\\x  - x + 1, 1/\n>>> r1.conjugate()\n        / 5           \\\nCRootOf\\x  - x + 1, 2/\n>>> r1.is_real\nFalse\n```\n\n----------------------------------------\n\nTITLE: Complex FpGroup Construction Example in Python\nDESCRIPTION: Shows how to create a more complex finitely presented group with multiple generators and relations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/fp_groups.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nF, r, s, t = free_group(\"r, s, t\")\nG = FpGroup(F, [r**2, s**2, t**2, r*s*t*r**-1*t**-1*s**-1, s*t*r*s**-1*r**-1*t**-1])\n```\n\n----------------------------------------\n\nTITLE: Integrating Polynomial Functions with SymPy in Python\nDESCRIPTION: This snippet demonstrates how to import SymPy, define a symbolic variable, and compute the indefinite integral of a polynomial function using the integrate function. It requires the sympy package and initializes pretty-printing for readable outputs. Inputs are symbolic expressions; the output is the symbolic antiderivative expressed with polynomial terms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> init_printing(use_unicode=False)\n>>> x = Symbol('x')\n>>> integrate(x**2 + x + 1, x)\n 3    2\nx    x\n-- + -- + x\n3    2\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Variables and Dependencies in Python with SymPy\nDESCRIPTION: Imports required SymPy modules and defines basic coordinates and generalized speeds for the biomechanical model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sympy as sm\nimport sympy.physics.mechanics as me\nimport sympy.physics.biomechanics as bm\n\nq1, q2, q3, q4 = me.dynamicsymbols('q1, q2, q3, q4', real=True)\nu1, u2, u3, u4 = me.dynamicsymbols('u1, u2, u3, u4', real=True)\n```\n\n----------------------------------------\n\nTITLE: Substituting Numerical Solutions into Expressions with SymPy in Python\nDESCRIPTION: Demonstrates best practices for substituting numerical solutions back into expressions using evalf. It shows why evalf is preferred over subs for numerical substitutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import cos, nsolve, Symbol\n>>> x = Symbol('x')\n>>> f = cos(x) - x\n>>> x_value = nsolve(f, x, 1); x_value\n0.739085133215161\n>>> f.evalf(subs={x: x_value})\n-5.12757857962640e-17\n>>> f.subs(x, x_value)\n0\n>>> y = Symbol('y')\n>>> z = Symbol('z')\n>>> g = x * y**2\n>>> values = {x: x_value, y: 1}\n>>> (x + y - z).evalf(subs=values)\n1.73908513321516 - z\n```\n\n----------------------------------------\n\nTITLE: Disabling Solution Simplification in solve for Performance\nDESCRIPTION: This example demonstrates using simplify=False to skip the simplification step in solve(), which can improve performance when simplified solutions are not needed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x, y\n>>> expr = x**2 - (y**5 - 3*y**3 + y**2 - 3)\n>>> solve(expr, x, dict=True)\n[{x: -sqrt(y**5 - 3*y**3 + y**2 - 3)}, {x: sqrt(y**5 - 3*y**3 + y**2 - 3)}]\n>>> solve(expr, x, dict=True, simplify=False)\n[{x: -sqrt((y + 1)*(y**2 - 3)*(y**2 - y + 1))}, {x: sqrt((y + 1)*(y**2 - 3)*(y**2 - y + 1))}]\n```\n\n----------------------------------------\n\nTITLE: Initializing Dynamic and Constant Symbols for Pendulum System\nDESCRIPTION: Creates dynamic symbols for position (x, y), velocity (u, v), and Lagrange multiplier (lambda), along with constant symbols for mass, length, and gravity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx, y, u, v, lam = dynamicsymbols('x y u v lambda')\nm, l, g = symbols('m l g')\n```\n\n----------------------------------------\n\nTITLE: Calculating System Momentum in SymPy\nDESCRIPTION: Demonstrates calculations of linear and angular momentum for different components of the mechanical system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nlinear_momentum(N,A)\nM*l1*q1d*N.y\nangular_momentum(O, N, Pa)\n4*l1**2*m*q1d*N.z\nlinear_momentum(N, A, Pa)\n(M*l1*q1d + 2*l1*m*q1d)*N.y\nangular_momentum(O, N, A, Pa)\n(M*l1**2*q1d + 4*l1**2*m*q1d + q1d)*N.z\n```\n\n----------------------------------------\n\nTITLE: Using TendonForceLengthDeGroote2016 Class in SymPy\nDESCRIPTION: Demonstrates the use of the TendonForceLengthDeGroote2016 class from sympy.physics.biomechanics to create a tendon force-length curve. Shows both custom and default parameter initialization.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.physics.biomechanics import TendonForceLengthDeGroote2016\n\nfl_T2 = TendonForceLengthDeGroote2016(l_T/l_T_slack, c0, c1, c2, c3)\nfl_T2\n\nfl_T2.doit()\n\nfl_T3 = TendonForceLengthDeGroote2016.with_defaults(l_T/l_T_slack)\nfl_T3\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Rational Function Fields\nDESCRIPTION: Shows how to create and work with rational function fields, which allow division operations and automatic cancellation between numerator and denominator.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> K = QQ.frac_field(x)\n>>> xk = K(x)\n>>> f = xk / (K.one + xk**2)\n>>> f\nx/(x**2 + 1)\n>>> p1 = xk**2 - 1\n>>> p2 = xk - 1\n>>> p1 / p2\nx + 1\n```\n\n----------------------------------------\n\nTITLE: Comparing Integration Outputs with and without holonomic Conversion - sympy.holonomic - Python\nDESCRIPTION: This short example compares the result of integrating sin(x) processed through expr_to_holonomic and then converted back to expression, versus integrating sin(x) directly. It illustrates that the holonomic workflow can produce an indefinite integral with a different integration constant than the direct sympy approach (here, 1 - cos(x) vs -cos(x)), because the holonomic approach defaults to a definite integral anchored at the initial condition point. This difference is essential for users concerned with offset constants in symbolic integrals. The code presumes imported symbols and the sympy and sympy.holonomic packages.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/uses.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> expr_to_holonomic(sin(x)).integrate(x).to_expr()\n1 - cos(x)\n>>> sin(x).integrate(x)\n-cos(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Fiber Passive Force-Length Curve in SymPy\nDESCRIPTION: Creates a SymPy expression for the fiber passive force-length curve using dynamic symbols and constants. Demonstrates implementation using both normalized and actual length values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_25\n\nLANGUAGE: Python\nCODE:\n```\nl_M_tilde = me.dynamicsymbols('l_M_tilde')\nc0, c1 = sm.symbols('c0, c1')\n\nfl_M_pas = (sm.exp(c1*(l_M_tilde - 1)/c0) - 1)/(sm.exp(c1) - 1)\nfl_M_pas\n\nl_M = me.dynamicsymbols('l_M')\nl_M_opt = sm.symbols('l_M_opt')\n\nfl_M_pas2 = (sm.exp(c1*(l_M/l_M_opt - 1)/c0) - 1)/(sm.exp(c1) - 1)\nfl_M_pas2\n```\n\n----------------------------------------\n\nTITLE: Using Zero Vector in SymPy\nDESCRIPTION: Demonstrates the use of the zero vector, which is accessed through Vector.zero. It shows how the zero vector behaves in vector operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import Vector\nVector.zero\ntype(Vector.zero)\nN.i + Vector.zero\nVector.zero == 2*Vector.zero\n```\n\n----------------------------------------\n\nTITLE: Expanding expressions and factoring back\nDESCRIPTION: Demonstrating how to work with expressions in both expanded and factored forms. The example shows differentiating a polynomial and factoring the result, with the same outcome regardless of the initial form.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> f = expand((x + 1)**20)\n\n>>> g = diff(f, x)\n\n>>> factor(g)\n          19\n20⋅(x + 1)\n\n>>> diff((x + 1)**20, x)\n          19\n20⋅(x + 1)\n```\n\n----------------------------------------\n\nTITLE: Comparing Separate and Combined Inequality Reductions in Python with SymPy\nDESCRIPTION: This code demonstrates that solving inequalities for multiple variables together is mathematically equivalent to solving them separately and combining the results with a logical AND operation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/reduce-inequalities-algebraically.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import And\n>>> x_reduced = reduce_inequalities(x > 1, x); x_reduced\n(1 < x) & (x < oo)\n>>> y_reduced = reduce_inequalities(y > 0, y); y_reduced\n(0 < y) & (y < oo)\n>>> And(x_reduced, y_reduced) == x_y_reduced\nTrue\n```\n\n----------------------------------------\n\nTITLE: Defining Point Velocity and Acceleration in LaTeX\nDESCRIPTION: Demonstrates how to define and calculate position vector, velocity vector, and acceleration vector for a point in a reference frame.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\mathbf{r}^{OP} = q_x \\mathbf{\\hat{n}_x} + q_y \\mathbf{\\hat{n}_y}\n\n{}^{\\mathbf{N}}\\mathbf{v}^P = \\frac{{}^{\\mathbf{N}} d \\mathbf{r}^{OP}}{dt}\n\n{}^{\\mathbf{N}}\\mathbf{v}^P = \\dot{q}_x\\mathbf{\\hat{n}_x} + \\dot{q}_y\\mathbf{\\hat{n}_y}\n\n{}^{\\mathbf{N}}\\mathbf{a}^P = \\frac{{}^{\\mathbf{N}} d {}^{\\mathbf{N}}\\mathbf{v}^P}{dt}\n\n{}^{\\mathbf{N}}\\mathbf{a}^P = \\ddot{q}_x\\mathbf{\\hat{n}_x} + \\ddot{q}_y\\mathbf{\\hat{n}_y}\n```\n\n----------------------------------------\n\nTITLE: Dense Multivariate Polynomial Representation\nDESCRIPTION: Demonstrates the dense representation format when using multiple generators in polynomial construction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\np = Poly(x**2*y + z, x, y, z)\np\np.rep\n```\n\n----------------------------------------\n\nTITLE: Solving Absolute Value Equation with Solveset in Python\nDESCRIPTION: This snippet shows how solveset handles the equation |x| = n, ensuring correctness by including the domain condition for n.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import symbols, S, pprint, solveset\nx, n = symbols('x, n')\npprint(solveset(abs(x) - n, x, domain=S.Reals), use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Creating PinJoint Connection in SymPy Mechanics\nDESCRIPTION: Demonstrates the creation of a PinJoint between two rigid bodies with specified position vectors and joint axis. Shows joint properties including kinematic differential equations, position vectors, and velocity relationships.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/joints.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import *\nmechanics_printing(pretty_print=False)\nq, u = dynamicsymbols('q, u')\nparent = RigidBody('parent')\nchild = RigidBody('child')\njoint = PinJoint(\n    'hinge', parent, child, coordinates=q, speeds=u,\n    parent_point=3 * parent.frame.x,\n    child_point=-3 * child.frame.x,\n    joint_axis=parent.frame.z)\njoint.kdes\nMatrix([[u - q']])\njoint.parent_point.pos_from(parent.masscenter)\n3*parent_frame.x\njoint.parent_interframe\nparent_frame\njoint.joint_axis.express(child.frame)\nchild_frame.z\nchild.masscenter.pos_from(parent.masscenter)\n3*parent_frame.x + 3*child_frame.x\nchild.masscenter.vel(parent.frame)\n3*u*child_frame.y\n```\n\n----------------------------------------\n\nTITLE: Defining a SpringDamper using ForceActuator in SymPy\nDESCRIPTION: Defines a `SpringDamper` class inheriting from `sympy.physics.mechanics.ForceActuator` (`me.ForceActuator`). The constructor accepts a `pathway` object, `spring_constant`, and `damper_constant`. It calculates the scalar actuator force based on the pathway's length and extension velocity and assigns it to the `self.force` attribute, adhering to the `ForceActuator` interface for integration with pathway mechanics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> class SpringDamper(me.ForceActuator):\n...     \n...     # positive x spring is in tension\n...     # negative x spring is in compression\n...     def __init__(self, pathway, spring_constant, damper_constant):\n...         self.pathway = pathway\n...         self.force = (-spring_constant*pathway.length -\n...                       damper_constant*pathway.extension_velocity)\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing FMA (Fused Multiply-Add) with doit() in SymPy\nDESCRIPTION: Implementation of a Fused Multiply-Add function that evaluates to x*y + z. The doit() method allows explicit evaluation while eval() handles numeric cases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Number\nclass FMA(Function):\n    \"\"\"\n    FMA(x, y, z) = x*y + z\n    \"\"\"\n    @classmethod\n    def eval(cls, x, y, z):\n        if all(isinstance(i, Number) for i in [x, y, z]):\n           return x*y + z\n\n    def doit(self, deep=True, **hints):\n        x, y, z = self.args\n        if deep:\n            x = x.doit(deep=deep, **hints)\n            y = y.doit(deep=deep, **hints)\n            z = z.doit(deep=deep, **hints)\n        return x*y + z\n```\n\n----------------------------------------\n\nTITLE: Plotting Tendon Force-Length Curve with Matplotlib\nDESCRIPTION: Uses lambdify to create a callable function from the TendonForceLengthDeGroote2016 instance and plots the curve using Matplotlib. This demonstrates how to visualize the tendon force-length relationship.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sympy.physics.biomechanics import TendonForceLengthDeGroote2016\n\nl_T_tilde = me.dynamicsymbols('l_T_tilde')\nfl_T = TendonForceLengthDeGroote2016.with_defaults(l_T_tilde)\nfl_T_callable = sm.lambdify(l_T_tilde, fl_T)\nl_T_tilde_num = np.linspace(0.95, 1.05)\n\nfig, ax = plt.subplots()\n_ = ax.plot(l_T_tilde_num, fl_T_callable(l_T_tilde_num))\n_ = ax.set_xlabel('Normalized tendon length')\n_ = ax.set_ylabel('Normalized tendon force-length')\n```\n\n----------------------------------------\n\nTITLE: Normalizing Vectors and Calculating Magnitude - SymPy - Python\nDESCRIPTION: Provides examples for normalizing a vector to unit length and computing its magnitude using the .normalize and .magnitude methods. Employs vector sum expressions and demonstrates use of symbolic square roots. Inputs are vector expressions; outputs are either normalized vectors or their magnitude. Requires SymPy and defined reference frame.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> (N.x + N.y).normalize()\\nsqrt(2)/2*N.x + sqrt(2)/2*N.y\\n>>> (N.x + N.y).magnitude()\\nsqrt(2)\n```\n\n----------------------------------------\n\nTITLE: Using rs_sin Function with Rational Domain in SymPy\nDESCRIPTION: Example demonstrating how to use the rs_sin function to compute a sine series expansion with rational coefficients. The example creates a polynomial ring with rational coefficients and variables x and y, then computes the sine series of x*y up to order 5 in x.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.polys import ring, QQ, RR\n>>> from sympy.polys.ring_series import rs_sin\n>>> R, x, y = ring('x, y', QQ)\n>>> rs_sin(x*y, x, 5)\n-1/6*x**3*y**3 + x*y\n```\n\n----------------------------------------\n\nTITLE: Preparing Single G-Function for Saxena's Theorem in SymPy\nDESCRIPTION: Internal SymPy function used before applying the Meijer G-function integration theorem (Saxena's generalization). It performs substitutions to normalize the argument of a single G-function, typically reducing the exponent of the argument variable to unity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n_rewrite_saxena_1\n```\n\n----------------------------------------\n\nTITLE: Using Partial Solutions with Numerical Solving in SymPy\nDESCRIPTION: Demonstrates how to use partial symbolic solutions with numerical solvers to find complete solutions to a system. This technique substitutes symbolic solutions into remaining equations to create single-variable equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import nsolve\n[system[-1].subs(s) for s in sol]\n[exp(z) - 3 + 1/(z + 1), exp(z) + zoo + 1/z]\nz_eq = _[0]\nzsol = nsolve(z_eq, 1); zsol\n0.906425478894557\nsol0 = {k: v.subs(z, zsol) for k, v in sol[0].items()}\nsol0[z] = zsol; sol0\n{x: -1, y: 1.90642547889456, z: 0.906425478894557}\n```\n\n----------------------------------------\n\nTITLE: Working with Ideals in Local Rings\nDESCRIPTION: Demonstrates creating ideals in a local ring and checking equality between them. This example verifies that the nodal cubic is singular at the origin by showing the maximal ideal is not principal.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> I = lr.ideal(x, y)\n>>> I == lr.ideal(x)\nFalse\n\n>>> I == lr.ideal(y)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Evaluating SymPy Expression using subs/evalf in Python\nDESCRIPTION: Demonstrates the basic method of substituting a numerical value for a symbol and evaluating the expression using SymPy's `evalf` method. This approach is simple but computationally slow, suitable for prototyping or occasional evaluations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.abc import x\n>>> expr = sin(x)/x\n>>> expr.evalf(subs={x: 3.14})\n0.000507214304613640\n```\n\n----------------------------------------\n\nTITLE: Checking Polynomial Hypergeometric Terms in Python using SymPy\nDESCRIPTION: Demonstrates how to check if a polynomial sequence is hypergeometric using the is_hypergeometric() method from SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/concrete.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nn, k = symbols('n,k')\n(n**2 + 1).is_hypergeometric(n)\n```\n\n----------------------------------------\n\nTITLE: Solving Equations with Physical Quantities using SymPy Units (Python)\nDESCRIPTION: This snippet illustrates how to solve a physics equation (Kepler's third law) involving physical quantities using SymPy. It defines symbolic variables and `Quantity` objects for Venus's semi-major axis (`a`) and the Sun's mass (`M`), assigning them dimensions and scale factors within the SI system. It then sets up Kepler's law as a SymPy `Eq`, solves for the orbital period (`T`), and finally converts the resulting quantity to days using `convert_to`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/examples.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve, symbols, pi, Eq\n>>> from sympy.physics.units import Quantity, length, mass\n>>> from sympy.physics.units import day, gravitational_constant as G\n>>> from sympy.physics.units import meter, kilogram\n>>> T = symbols(\"T\")\n>>> a = Quantity(\"venus_a\")\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> SI.set_quantity_dimension(a, length)\n>>> SI.set_quantity_scale_factor(a, 108208000e3*meter)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Quantity(\"solar_mass\")\n>>> SI.set_quantity_dimension(M, mass)\n>>> SI.set_quantity_scale_factor(M, 1.9891e30*kilogram)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> eq = Eq(T**2 / a**3, 4*pi**2 / G / M)\n>>> eq\nEq(T**2/venus_a**3, 4*pi**2/(gravitational_constant*solar_mass))\n>>> q = solve(eq, T)[1]\n>>> q\n2*pi*venus_a**(3/2)/(sqrt(gravitational_constant)*sqrt(solar_mass))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.units import convert_to\n>>> convert_to(q, day)\n71.5112118495813*pi*day\n>>> convert_to(q, day).n()\n224.659097795948*day\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reference Frames for Bicycle Model in Python\nDESCRIPTION: Creates and orients reference frames for different components of the bicycle, including inertial, yaw, roll, wheels, frame, and fork frames.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> N = me.ReferenceFrame('N')\n>>> Y = N.orientnew('Y', 'Axis', [q1, N.z])\n>>> R = Y.orientnew('R', 'Axis', [q2, Y.x])\n>>> Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n>>> WR = me.ReferenceFrame('WR')\n>>> TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n>>> Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n>>> TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n>>> WF = me.ReferenceFrame('WF')\n```\n\n----------------------------------------\n\nTITLE: Pretty-Printing DynamicSymbols and Their Derivatives - SymPy - Python\nDESCRIPTION: Shows use of vprint for improved readability of dynamic symbols and their derivatives. Demonstrates the difference between standard print and vprint representations. Requires sympy.physics.vector and dynamically created time-dependent symbols. Inputs are dynamic symbols or their derivatives; outputs are readable console representations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> q1\\nq1(t)\\n>>> q1d = diff(q1, Symbol('t'))\\n>>> vprint(q1)\\nq1\\n>>> vprint(q1d)\\nq1'\n```\n\n----------------------------------------\n\nTITLE: Constructing Algebraic Extension Fields in Python using SymPy\nDESCRIPTION: Demonstrates the use of the extension=True option in construct_domain to create algebraic extension fields for irrational but algebraic inputs.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import sqrt\n>>> construct_domain([sqrt(2)])[0]\nEX\n>>> construct_domain([sqrt(2)], extension=True)[0]\nQQ<sqrt(2)>\n>>> construct_domain([sqrt(2), sqrt(3)], extension=True)[0]\nQQ<sqrt(2) + sqrt(3)>\n```\n\n----------------------------------------\n\nTITLE: Generating Dot Format Output in SymPy\nDESCRIPTION: Demonstrates how to use dotprint() function to generate Dot format output for SymPy expressions, which can be rendered with Graphviz.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.printing.dot import dotprint\nfrom sympy.abc import x\nprint(dotprint(x+2))\n```\n\n----------------------------------------\n\nTITLE: Sorting Symbolic Objects in SymPy\nDESCRIPTION: Shows that using Python's sorted() function with symbolic objects will fail as it relies on comparison operators internally.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> sorted([x, 0])\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational\n```\n\n----------------------------------------\n\nTITLE: Implementing _eval_evalf Method for Numerical Evaluation in Custom SymPy Functions\nDESCRIPTION: This code snippet demonstrates how to implement the _eval_evalf method in a custom SymPy function class called 'versin'. The method enables numerical evaluation by recursively evaluating the expression 2*sin(x/2)^2, which is a numerically stable way to compute 1-cos(x).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import sin\n>>> class versin(Function):\n...     def _eval_evalf(self, prec):\n...         return (2*sin(self.args[0]/2)**2)._eval_evalf(prec)\n```\n\n----------------------------------------\n\nTITLE: Computing Taylor Series Sum in SymPy\nDESCRIPTION: Calculates a Taylor series sum up to n terms using factorial and power operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreturn sum( ((1/factorial(i))*c[i] * (x-x0)**i for i in range(n)) )\n```\n\n----------------------------------------\n\nTITLE: Using ForceActuator-based SpringDamper with Complex Pathway\nDESCRIPTION: Instantiates the `ForceActuator`-based `SpringDamper` class using a more complex pathway object `wpathway`, spring constant `k`, and damping coefficient `c`. It then calls `to_loads()` and pretty-prints the symbolic `Force` objects applied at the pathway's connection points (`P`, `Q`, `O`), demonstrating the actuator's applicability to different pathway kinematics. Depends on `sympy.physics.mechanics` (`me`), `pprint`, and the custom `SpringDamper` class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> spring_damper3 = SpringDamper(wpathway, k, c)\n>>> pprint.pprint(spring_damper3.to_loads())\n[Force(point=P, force=r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*N.y + (-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))/sqrt(r**2*theta(t)**2 + 1)*N.z),\n Force(point=Q, force=- (-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))/sqrt(r**2*theta(t)**2 + 1)*N.z - r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*A.y),\n Force(point=O, force=- r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*N.y + r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*A.y)]\n```\n\n----------------------------------------\n\nTITLE: Checking Numerical Evaluability with is_number in SymPy (Python)\nDESCRIPTION: This snippet demonstrates the `is_number` property (lowercase) in SymPy. This property checks if an expression can be fully evaluated to a floating-point complex number using `.evalf()`. `expr1` (sqrt(2) + I) returns `True` because it contains no free symbols and evaluates numerically. `expr2` (1 + x) returns `False` because the presence of the symbol `x` prevents full numerical evaluation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import I, sqrt # Assuming sqrt was imported earlier or implicitly available\n>>> expr1 = I + sqrt(2)\n>>> expr1\nsqrt(2) + I\n>>> expr1.is_number\nTrue\n>>> expr1.evalf()\n1.4142135623731 + 1.0*I\n>>> x = Symbol('x')\n>>> expr2 = 1 + x\n>>> expr2\nx + 1\n>>> expr2.is_number\nFalse\n>>> expr2.evalf()\nx + 1.0\n```\n\n----------------------------------------\n\nTITLE: Defining Differentiation for Versine Function in Python\nDESCRIPTION: Implements the fdiff method for the versine function, which returns the derivative sin(x) with respect to x.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nclass versin(Function):\n    def fdiff(self, argindex=1):\n        # argindex indexes the args, starting at 1\n        return sin(self.args[0])\n```\n\n----------------------------------------\n\nTITLE: Working with Polynomial Ring Elements in Python using SymPy\nDESCRIPTION: Shows how to create and manipulate elements of a polynomial ring, demonstrating the use of the parent method to identify the domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ZZ, Symbol\n>>> x = Symbol('x')\n>>> K = ZZ[x]\n>>> K\nZZ[x]\n>>> p = K(x) + K.one\n>>> p\nx + 1\n>>> type(p)\n<class 'sympy.polys.rings.PolyElement'>\n>>> p.parent()\nZZ[x]\n>>> p.parent() == K\nTrue\n```\n\n----------------------------------------\n\nTITLE: Initializing Simple Pendulum System with Kane's Method in Python\nDESCRIPTION: Sets up a simple pendulum system using SymPy mechanics, defining coordinates, reference frames, points and forming Kane's equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Matrix\n>>> from sympy.physics.mechanics import *\n>>> q1 = dynamicsymbols('q1')                     # Angle of pendulum\n>>> u1 = dynamicsymbols('u1')                     # Angular velocity\n>>> q1d = dynamicsymbols('q1', 1)\n>>> L, m, t, g = symbols('L, m, t, g')\n\n>>> # Compose world frame\n>>> N = ReferenceFrame('N')\n>>> pN = Point('N*')\n>>> pN.set_vel(N, 0)\n\n>>> # A.x is along the pendulum\n>>> A = N.orientnew('A', 'axis', [q1, N.z])\n>>> A.set_ang_vel(N, u1*N.z)\n\n>>> # Locate point P relative to the origin N*\n>>> P = pN.locatenew('P', L*A.x)\n>>> vel_P = P.v2pt_theory(pN, N, A)\n>>> pP = Particle('pP', P, m)\n\n>>> # Create Kinematic Differential Equations\n>>> kde = Matrix([q1d - u1])\n\n>>> # Input the force resultant at P\n>>> R = m*g*N.x\n\n>>> # Solve for eom with kanes method\n>>> KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n>>> fr, frstar = KM.kanes_equations([pP], [(P, R)])\n```\n\n----------------------------------------\n\nTITLE: Defining Custom 'divides' Function with Input Validation (Python)\nDESCRIPTION: Defines a custom SymPy function `divides(m, n)` that checks if `m` divides `n`. The `eval` class method handles evaluation for explicit integers and performs type checking for symbolic arguments. It raises a `TypeError` if `m` or `n` is known *not* to be an integer (`is_integer is False`), but allows cases where the assumption is unknown (`is_integer is None`).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, Integer, symbols\n>>> m = symbols('m', integer=True) # Define m as an integer symbol\n>>> class divides(Function):\n...     @classmethod\n...     def eval(cls, m, n):\n...         # Evaluate for explicit integer m and n. This part is fine.\n...         if isinstance(m, Integer) and isinstance(n, Integer):\n...             return int(n % m == 0)\n...         \n...         # For symbolic arguments, require m and n to be integer.\n...         # This is the better way to write this logic.\n...         if m.is_integer is False or n.is_integer is False:\n...             raise TypeError(\"m and n should be integers\")\n```\n\n----------------------------------------\n\nTITLE: Using Python Context Manager for SymPy Assumptions\nDESCRIPTION: Demonstrates how to use the 'assuming' context manager to set predicate assumptions for multiple symbols and evaluate expressions based on those assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/assumptions/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> x = Symbol('x')\n>>> y = Symbol('y')\n>>> facts = Q.positive(x), Q.positive(y)\n>>> with assuming(*facts):\n...     print(ask(Q.positive(2*x + y)))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using the ZerothOrderActivation Class in SymPy Biomechanics\nDESCRIPTION: Imports the `ZerothOrderActivation` class from `sympy.physics.biomechanics`. It instantiates the class, providing a unique name 'zeroth'. Accessing the `.excitation` and `.activation` attributes shows the automatically generated dynamic symbols, which are identical (`e_zeroth(t)`) reflecting the nature of the zeroth-order model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.biomechanics import ZerothOrderActivation\n>>> actz = ZerothOrderActivation('zeroth')\n>>> actz\nZerothOrderActivation('zeroth')\n>>> actz.excitation\ne_zeroth(t)\n>>> actz.activation\ne_zeroth(t)\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Symbols and Defining Taylor Series Polynomial in Python\nDESCRIPTION: Sets up SymPy symbols and defines a function to generate a Taylor series polynomial of degree n. This is used as the basis for finite difference approximations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom __future__ import print_function\nfrom sympy import *\nx, x0, h = symbols('x, x_0, h')\nFi, Fip1, Fip2 = symbols('F_{i}, F_{i+1}, F_{i+2}')\nn = 3 # there are the coefficients c_0=Fi, c_1=dF/dx, c_2=d**2F/dx**2\nc = symbols('c:3')\ndef P(x, x0, c, n):\n    return sum( ((1/factorial(i))*c[i] * (x-x0)**i for i in range(n)) )\n```\n\n----------------------------------------\n\nTITLE: Testing for common zeros with resultant function\nDESCRIPTION: Using the resultant function to determine if two polynomials have common roots. When the resultant vanishes, it indicates the polynomials have a common zero, which can be verified by factoring.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> x = var('x')\n>>> resultant(3*x**4 + 3*x**3 + x**2 - x - 2, x**3 - 3*x**2 + x + 5)\n0\n\n>>> factor(3*x**4 + 3*x**3 + x**2 - x - 2)\n        ⎛   3        ⎞\n(x + 1)⋅⎝3⋅x  + x - 2⎠\n\n>>> factor(x**3 - 3*x**2 + x + 5)\n        ⎛ 2          ⎞\n(x + 1)⋅⎝x  - 4⋅x + 5⎠\n```\n\n----------------------------------------\n\nTITLE: Initializing Rigid Body System in SymPy\nDESCRIPTION: Creates a rigid body system with reference frame, point, and body definitions for mechanical calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nA = RigidBody('A', Ac, a, M, (I, Ac))\n```\n\n----------------------------------------\n\nTITLE: Exploring Field and Ring Relationships in SymPy Domains\nDESCRIPTION: This example demonstrates the relationship between ZZ (integers) and QQ (rationals) domains. ZZ is the ring of integers of QQ, and QQ is the field of fractions of ZZ.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsref.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ZZ, QQ\n>>> ZZ.get_field()\nQQ\n>>> QQ.get_ring()\nZZ\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic Continued Fraction in Python with SymPy\nDESCRIPTION: This snippet demonstrates how to create a symbolic continued fraction using SymPy's symbols function. It then converts the symbolic fraction to a standard rational function form using the cancel function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n>>> syms = symbols('a0:5')\n>>> syms\n(a₀, a₁, a₂, a₃, a₄)\n>>> a0, a1, a2, a3, a4 = syms\n>>> frac = list_to_frac(syms)\n>>> frac\n             1\na₀ + ─────────────────\n               1\n     a₁ + ────────────\n                  1\n          a₂ + ───────\n                    1\n               a₃ + ──\n                    a₄\n\n>>> frac = cancel(frac)\n>>> frac\na₀⋅a₁⋅a₂⋅a₃⋅a₄ + a₀⋅a₁⋅a₂ + a₀⋅a₁⋅a₄ + a₀⋅a₃⋅a₄ + a₀ + a₂⋅a₃⋅a₄ + a₂ + a₄\n─────────────────────────────────────────────────────────────────────────\n                 a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n```\n\n----------------------------------------\n\nTITLE: Initializing Pretty Printing in SymPy\nDESCRIPTION: Demonstrates how to use init_printing() to enable the best available printer in the current environment.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import init_printing\ninit_printing() # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Testing Linear Argument Variations in SymPy\nDESCRIPTION: Shows testing hypergeometric properties of functions with linear integer arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/concrete.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfactorial(2*n).is_hypergeometric(n)\nbinomial(3*n+1, k).is_hypergeometric(n)\nrf(n+1, k-1).is_hypergeometric(n)\nff(n-1, k+1).is_hypergeometric(n)\ngamma(5*n).is_hypergeometric(n)\n(2**(n-7)).is_hypergeometric(n)\n```\n\n----------------------------------------\n\nTITLE: Differentiation Examples for Unevaluated Derivative Function in Python\nDESCRIPTION: Demonstrates the behavior of the diff method on the function f(x, y) with unevaluated derivative.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nf(x, y).diff(x)\nf(x, y).diff(y)\n```\n\n----------------------------------------\n\nTITLE: Using poly Function in SymPy for Inequality Solving\nDESCRIPTION: The poly function is used to transform expressions into polynomials without changing their mathematical meaning. It's often used in the context of solving inequalities in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/inequalities.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import poly\n\n# Example usage of poly (not shown in the original text)\nexpression = x**2 + 2*x + 1\npolynomial = poly(expression)\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting Polynomial with Integer Domain (ZZ) in SymPy\nDESCRIPTION: This example shows how to create a polynomial with integer coefficients and inspect its domain. By default, a polynomial with integer coefficients will use ZZ as its domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsref.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Poly, Symbol\n>>> x = Symbol('x')\n>>> p = Poly(x**2 + 1)\n>>> p\nPoly(x**2 + 1, x, domain='ZZ')\n>>> p.domain\nZZ\n```\n\n----------------------------------------\n\nTITLE: Basic Domain Inference in SymPy Poly Construction\nDESCRIPTION: Demonstrates how domains are automatically inferred when constructing polynomials using the Poly class, including field and extension handling.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import sqrt\nPoly(x**2 + 1, x)\nPoly(x**2 + 1, x, field=True)\nPoly(x**2/2 + 1, x)\nPoly(x**2 + sqrt(2), x)\nPoly(x**2 + sqrt(2), x, extension=True)\n```\n\n----------------------------------------\n\nTITLE: Sparse Polynomial Representation in SymPy\nDESCRIPTION: This snippet demonstrates the sparse polynomial representation, which uses a dictionary to map nonzero monomial terms to their coefficients, making it more efficient for polynomials with many zero terms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> Poly(7*x**20 + 8*x + 9).rep.rep  # doctest: +SKIP\n[7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9]\n>>> Poly(7*x**20 + 8*x + 9).as_dict()\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Printing for Matrix Display\nDESCRIPTION: Sets up SymPy's pretty printing to use Unicode characters for better matrix visualization in interactive environments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import init_printing\n>>> init_printing(use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for Galois Groups\nDESCRIPTION: ReStructuredText documentation defining the structure and autodoc directives for Galois group implementations in SymPy. Contains class and function documentation directives for transitive subgroups and specific group constructors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/galois.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _combinatorics-galois:\\n\\nGalois Groups\\n=============\\n\\n.. automodule:: sympy.combinatorics.galois\\n\\n.. autoclass:: S6TransitiveSubgroups\\n\\n.. autoclass:: S5TransitiveSubgroups\\n\\n.. autoclass:: S4TransitiveSubgroups\\n\\n.. autoclass:: S3TransitiveSubgroups\\n\\n.. autoclass:: S2TransitiveSubgroups\\n\\n.. autoclass:: S1TransitiveSubgroups\\n\\n.. autofunction:: four_group\\n\\n.. autofunction:: M20\\n\\n.. autofunction:: S3_in_S6\\n\\n.. autofunction:: A4_in_S6\\n\\n.. autofunction:: S4m\\n\\n.. autofunction:: S4p\\n\\n.. autofunction:: A4xC2\\n\\n.. autofunction:: S4xC2\\n\\n.. autofunction:: G18\\n\\n.. autofunction:: G36m\\n\\n.. autofunction:: G36p\\n\\n.. autofunction:: G72\\n\\n.. autofunction:: PSL2F5\\n\\n.. autofunction:: PGL2F5\\n\\n.. autofunction:: find_transitive_subgroups_of_S6\n```\n\n----------------------------------------\n\nTITLE: Square-free Factorization in SymPy\nDESCRIPTION: Shows how to perform square-free factorization of univariate polynomials using the sqf_list and sqf functions in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 2*x**2 + 5*x**3 + 4*x**4 + x**5\n\n>>> sqf_list(f)\n                   2\n(1, [(x + 2, 1), (x  + x, 2)])\n\n>>> sqf(f)\n                2\n        / 2    \\\n(x + 2)*\\x  + x/\n```\n\n----------------------------------------\n\nTITLE: Defining Custom LaTeX Printing for Divides Function in Python\nDESCRIPTION: Implements a custom _latex method for the divides function to print it as an Iverson bracket in LaTeX.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import latex\nclass divides(Function):\n    def _latex(self, printer):\n        m, n = self.args\n        _m, _n = printer._print(m), printer._print(n)\n        return r'\\left [ %s \\middle | %s \\right ]' % (_m, _n)\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple Reference Frame Rotations with DCM Extraction - SymPy - Python\nDESCRIPTION: Constructs multiple reference frames and orients each relative to the previous using sequential axes and symbolic angles. Demonstrates both the 'Axis' and 'Body' orientation types and the retrieval of direction cosine matrices (DCMs) using .dcm. Requires sympy.physics.vector, defined frames, and symbolic variables. Inputs are frame objects and angles; output is a SymPy Matrix representing DCM.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> N = ReferenceFrame('N')\\n>>> Bp = ReferenceFrame('Bp')\\n>>> Bpp = ReferenceFrame('Bpp')\\n>>> B = ReferenceFrame('B')\\n>>> q1,q2,q3 = symbols('q1 q2 q3')\\n>>> Bpp.orient(N,'Axis', [q1, N.x])\\n>>> Bp.orient(Bpp,'Axis', [q2, Bpp.y])\\n>>> B.orient(Bp,'Axis', [q3, Bp.z])\\n>>> N.dcm(B)\\nMatrix([\\n[                          cos(q2)*cos(q3),                           -sin(q3)*cos(q2),          sin(q2)],\\n[sin(q1)*sin(q2)*cos(q3) + sin(q3)*cos(q1), -sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), -sin(q1)*cos(q2)],\\n[sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1),  cos(q1)*cos(q2)]])\\n>>> B.orient(N,'Body',[q1,q2,q3],'XYZ')\\n>>> N.dcm(B)\\nMatrix([\\n[                          cos(q2)*cos(q3),                           -sin(q3)*cos(q2),          sin(q2)],\\n[sin(q1)*sin(q2)*cos(q3) + sin(q3)*cos(q1), -sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), -sin(q1)*cos(q2)],\\n[sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1),  cos(q1)*cos(q2)]])\n```\n\n----------------------------------------\n\nTITLE: Defining Constants in SymPy\nDESCRIPTION: Examples of defining constants in SymPy, including simple constants, non-negative constants, and non-positive constants. This is equivalent to using the 'Constants' keyword in Autolev.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na, b = sm.symbols('a b', real=True)\nc = sm.symbols('c', real=True, nonnegative=True)\nd = sm.symbols('d', real=True, nonpositive=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Reference Frames for Rolling Disc Kinematics in Python\nDESCRIPTION: This code defines the kinematics of the rolling disc using a series of simple rotations. It creates reference frames for each rotation, using a 3-1-2 (Z-X-Y) rotation sequence to fully describe the disc's orientation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_lagrange.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nN = ReferenceFrame('N')\nY = N.orientnew('Y', 'Axis', [q1, N.z])\nL = Y.orientnew('L', 'Axis', [q2, Y.x])\nR = L.orientnew('R', 'Axis', [q3, L.y])\n```\n\n----------------------------------------\n\nTITLE: Vector Addition Mathematics Example\nDESCRIPTION: Demonstrates vector addition with basis vectors and mathematical notation\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\mathbf{a} + \\mathbf{b} = (a_x + b_x)\\mathbf{\\hat{n}_x} + (a_y + b_y)\\mathbf{\\hat{n}_y} + (a_z + b_z) \\mathbf{\\hat{n}_z}\n```\n\n----------------------------------------\n\nTITLE: Generator Selection with Multiple Variables\nDESCRIPTION: Shows how polynomial ring domains are created when dealing with multiple symbols and generators.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\np = Poly(x**2*y + z, x)\np\np.gens\np.domain\np.domain == ZZ[y,z]\np.domain == ZZ.poly_ring(y, z)\np.domain == ZZ.old_poly_ring(y, z)\n```\n\n----------------------------------------\n\nTITLE: Using ECM for Integer Factorization in SymPy (Python)\nDESCRIPTION: These code snippets demonstrate the use of the ecm function from sympy.ntheory to factor large integers using the Elliptic Curve Method (ECM). The first example factors a product of two large numbers, returning their set of prime factors. The second example showcases ECM factoring a much larger (87-digit) number with several 15-digit factors. Dependencies: sympy.ntheory must be installed and imported. Inputs include the integer to be factored, and optional B1, B2 bounds. Output is a set containing the integer's prime factors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/ntheory.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.ntheory import ecm\n>>> ecm(7060005655815754299976961394452809, B1=100000, B2=1000000)\n{6988699669998001, 1010203040506070809}\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> ecm(122921448543883967430908091422761898618349713604256384403202282756086473494959648313841, B1=100000, B2=1000000)\n{15154262241479,\n 15423094826093,\n 799333555511111,\n 809709509409109,\n 888888877777777,\n 914148152112161}\n```\n\n----------------------------------------\n\nTITLE: Checking Conservative Vector Field in SymPy\nDESCRIPTION: This code snippet shows how to check if a vector field is conservative using SymPy's is_conservative function. It also demonstrates that the curl of a conservative field is zero.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame, is_conservative\n>>> R = ReferenceFrame('R')\n>>> field = R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z\n>>> is_conservative(field)\nTrue\n>>> curl(field, R)\n0\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Scalar Field using SymPy\nDESCRIPTION: This snippet demonstrates how to calculate the gradient of a scalar field using SymPy's physics.vector module. It creates a reference frame, defines a scalar field, and computes its gradient.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> from sympy.physics.vector import gradient\n>>> scalar_field = R[0]*R[1]*R[2]\n>>> gradient(scalar_field, R)\nR_y*R_z*R.x + R_x*R_z*R.y + R_x*R_y*R.z\n```\n\n----------------------------------------\n\nTITLE: Representing Dimensions as Vectors in Linear Space\nDESCRIPTION: Mathematical representation of dimensions (Length, Mass, Time) as vectors in a linear space, showing how base dimensions are represented in the MKS system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/philosophy.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nL =\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ 0\n\\end{pmatrix}, \\qquad\nM =\n\\begin{pmatrix}\n0 \\\\ 1 \\\\ 0\n\\end{pmatrix}, \\qquad\nT =\n\\begin{pmatrix}\n0 \\\\ 0 \\\\ 1\n\\end{pmatrix}.\n```\n\n----------------------------------------\n\nTITLE: Setting Up KanesMethod with Independent Coordinates and Speeds\nDESCRIPTION: Example showing how to initialize a KanesMethod object when some coordinates are dependent. In this case, q2 is dependent, and u2 and u3 are dependent speeds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> q1, q2, q3, q4 = dynamicsymbols('q1 q2 q3 q4')\n>>> u1, u2, u3, u4 = dynamicsymbols('u1 u2 u3 u4')\n>>> # Here we will assume q2 is dependent, and u2 and u3 are dependent\n>>> # We need the constraint equations to enter them though\n>>> KM = KanesMethod(N, [q1, q3, q4], [u1, u4])\n```\n\n----------------------------------------\n\nTITLE: Creating Reference Frames for Kane's Method\nDESCRIPTION: Establishes the world reference frame N and oriented frame A for the pendulum system. Sets up the coordinate frames needed to describe the pendulum's motion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/lin_pend_nonmin_example.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Compose world frame\nN = ReferenceFrame('N')\npN = Point('N*')\npN.set_vel(N, 0)\n\n# A.x is along the pendulum\ntheta1 = atan(q2/q1)\nA = N.orientnew('A', 'axis', [theta1, N.z])\n```\n\n----------------------------------------\n\nTITLE: Initializing Coordinates and Speeds for Bicycle Model in Python\nDESCRIPTION: Defines generalized coordinates and speeds for the bicycle model using SymPy's dynamicsymbols. This includes yaw, roll, wheel rotations, frame pitch, and steering angles.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> q1, q2, q3, q4, q5 = me.dynamicsymbols('q1 q2 q3 q4 q5')\n>>> q1d, q2d, q4d, q5d = me.dynamicsymbols('q1 q2 q4 q5', 1)\n>>> u1, u2, u3, u4, u5, u6 = me.dynamicsymbols('u1 u2 u3 u4 u5 u6')\n>>> u1d, u2d, u3d, u4d, u5d, u6d = me.dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n```\n\n----------------------------------------\n\nTITLE: Indirect Assumption Resolution and Caching\nDESCRIPTION: Shows how indirect queries trigger evaluation of related properties and how None results are cached for unresolvable queries.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nb = A()\nb.is_algebraic    # called _eval_is_rational indirectly\n!!! calling _eval_is_rational\nTrue\nc = A()\nprint(c.is_prime)   # called _eval_is_rational indirectly\n!!! calling _eval_is_rational\nNone\nc._assumptions   # prime now shows as None\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'irrational': False,\n 'negative': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'prime': None,\n 'rational': True,\n 'real': True,\n 'transcendental': False,\n 'zero': False}\n```\n\n----------------------------------------\n\nTITLE: Initializing SymEngine Backend Symbol in Python\nDESCRIPTION: Example showing how to create a Symbol object using SymPy's SymEngine backend. The Symbol will be a SymEngine object if USE_SYMENGINE environment variable is set, otherwise it will be a regular SymPy Symbol object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/dependencies.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.core.backend import Symbol\n>>> # This will create a SymEngine Symbol object if the USE_SYMENGINE\n>>> # environment variable is configured. Otherwise it will be an ordinary\n>>> # SymPy Symbol object.\n>>> x = Symbol('x')\n```\n\n----------------------------------------\n\nTITLE: Solving Diophantine Equation with No Solution using SymPy\nDESCRIPTION: This code snippet demonstrates the use of SymPy's diophantine function to solve a Diophantine equation that has no solution. It imports the necessary functions, defines integer symbols, and attempts to solve the equation 2x + 4y - 3 = 0, which returns an empty set due to no possible integer solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> x, y = symbols(\"x, y\", integer=True)\n>>> diophantine(2*x + 4*y - 3, syms=(x, y))\nset()\n```\n\n----------------------------------------\n\nTITLE: Integer Partitions in SymPy\nDESCRIPTION: Demonstration of using the partitions() function to generate integer partitions with specific constraints. Shows filtering partitions by size.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/iterables.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.utilities.iterables import partitions\n>>> [p.copy() for s, p in partitions(7, m=2, size=True) if s == 2]\n[{1: 1, 6: 1}, {2: 1, 5: 1}, {3: 1, 4: 1}]\n```\n\n----------------------------------------\n\nTITLE: Testing Simplification with Custom Functions in SymPy\nDESCRIPTION: This code snippet demonstrates how implementing _eval_rewrite enables simplify() to work with expressions containing the custom function. The example shows simplifying versin(x) + cos(x) to 1.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import simplify\n>>> simplify(versin(x) + cos(x))\n1\n```\n\n----------------------------------------\n\nTITLE: Python Expression String Representation\nDESCRIPTION: Examples demonstrating the difference between repr() and srepr() for SymPy expressions, showing the more detailed internal representation provided by srepr().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n>>> repr(5*x**3 + sin(x))\n'5*x**3 + sin(x)'\n\n>>> srepr(5*x**3 + sin(x))\n\"Add(Mul(Integer(5), Pow(Symbol('x'), Integer(3))), sin(Symbol('x')))\"\n```\n\n----------------------------------------\n\nTITLE: Creating Dyads in SymPy\nDESCRIPTION: Illustrates how to create dyads (tensor products of vectors) in SymPy using the outer product method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndyad = 3*me.outer(a.x,a.x) + me.outer(a.y,a.y) + 2*me.outer(a.z,a.z)\n```\n\n----------------------------------------\n\nTITLE: Matrix Constructor Functions\nDESCRIPTION: Shows built-in matrix constructor functions including eye() for identity matrices, zeros(), ones(), and diag() for diagonal matrices.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\neye(3)\nzeros(2, 3)\nones(3, 2)\ndiag(1, 2, 3)\ndiag(-1, ones(2, 2), Matrix([5, 7, 5]))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Matrix Element Derivatives\nDESCRIPTION: Shows how derivatives of indexed objects work without expr_free_symbols, using examples with Indexed and MatrixSymbol objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Indexed, MatrixSymbol, diff\n>>> a = Indexed(\"A\", 0)\n>>> diff(a**2, a)\n2*A[0]\n>>> X = MatrixSymbol(\"X\", 3, 3)\n>>> diff(X[0, 0]**2, X[0, 0])\n2*X[0, 0]\n```\n\n----------------------------------------\n\nTITLE: Getting Periodicity of a Meijer G-Function in SymPy\nDESCRIPTION: SymPy function associated with Meijer G-functions (`meijerg` module). It determines the period of a given G-function with respect to multiplication of its argument by `Exp(2*pi*I)`. This information is crucial for correctly handling branch cuts and applying integration theorems by reducing the argument to its principal value when necessary.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmeijerg.get_period()\n```\n\n----------------------------------------\n\nTITLE: Converting Ampere in Different Unit Systems using SymPy\nDESCRIPTION: This snippet demonstrates how the convert_to function behaves differently in SI and CGS-Gauss unit systems when converting ampere to base units.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.units.systems.si import SI\nfrom sympy.physics.units.systems.cgs import cgs_gauss\nfrom sympy.physics.units import ampere, gram, second\nconvert_to(ampere, [meter, gram, second], SI)\nconvert_to(ampere, [meter, gram, second], cgs_gauss)\n```\n\n----------------------------------------\n\nTITLE: Basic Fortran Code Printing in SymPy\nDESCRIPTION: Examples of using fcode function to translate SymPy expressions to Fortran code. These examples demonstrate basic expression conversion and complex number handling.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy import *\n>>> x = symbols(\"x\")\n>>> fcode(sqrt(1-x**2))\n'      sqrt(1 - x**2)'\n>>> fcode((3 + 4*I)/(1 - conjugate(x)))\n'      (cmplx(3,4))/(1 - conjg(x))'\n```\n\n----------------------------------------\n\nTITLE: Defining Static Assumptions on Custom 'divides' Function (Python)\nDESCRIPTION: Extends the custom `divides` function definition by adding static assumptions directly as class attributes. `is_integer = True` indicates the function's result is always an integer (0 or 1), and `is_negative = False` indicates it's never negative. These assumptions hold regardless of the input.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function\n>>> class divides(Function):\n...     # Previous eval method assumed here...\n...     is_integer = True\n...     is_negative = False\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Algebraic Number Fields in SymPy\nDESCRIPTION: This snippet shows how to create algebraic number fields using QQ.algebraic_field() in SymPy and perform operations with their elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\n>>> K = QQ.algebraic_field(sqrt(2))\n>>> K\nQQ<sqrt(2)>\n>>> b = K.one + K.from_sympy(sqrt(2))\n>>> b  # doctest: +SKIP\nANP([1, 1], [1, 0, -2], QQ)\n>>> K.to_sympy(b)\n1 + sqrt(2)\n>>> b ** 2  # doctest: +SKIP\nANP([2, 3], [1, 0, -2], QQ)\n>>> K.to_sympy(b**2)\n2*sqrt(2) + 3\n```\n\n----------------------------------------\n\nTITLE: Differentiating Vectors with Respect to Symbols and Reference Frames - SymPy - Python\nDESCRIPTION: Demonstrates differentiating vector expressions with respect to a symbol and a reference frame using the .diff method. Highlights the difference from SymPy's generic diff, showing that both with-respect-to variable and frame must be specified. Requires SymPy, a reference frame 'N', and symbol 'x'. Inputs are vectors, variable, and frame; output is another vector.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> (x * N.x + N.y).diff(x, N)\\nN.x\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Set Intersections in Python\nDESCRIPTION: Explains the challenges of iterating over set intersections when the result is not clearly defined.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/sets.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n\\{a, b\\} \\cap \\{x, y\\}\n```\n\n----------------------------------------\n\nTITLE: Defining Real and Imaginary Parts for Versine Function in Python\nDESCRIPTION: Implements the as_real_imag method for the versine function to split it into real and imaginary parts.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nclass versin(Function):\n    def as_real_imag(self, deep=True, **hints):\n        return (1 - cos(self.args[0])).as_real_imag(deep=deep, **hints)\n```\n\n----------------------------------------\n\nTITLE: Accessing Polynomial Coefficients using Recommended DMP.to_list() in Python\nDESCRIPTION: Shows the recommended way to access polynomial coefficients using the DMP.to_list() method in SymPy. This method is compatible with both older and newer versions of SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> p.rep.to_list()\n[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Using Exact Rational Numbers in SymPy\nDESCRIPTION: Demonstrates how to properly use exact rational numbers instead of floating-point numbers in SymPy expressions for more accurate symbolic manipulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> expression = x**2 + 0.5*x + 1\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Rational\n>>> expression = x**2 + Rational(1, 2)*x + 1\n>>> expression = x**2 + x/2 + 1 # Equivalently\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Constants in SymPy\nDESCRIPTION: Examples of defining multiple constants in SymPy, including indexed constants and matrix-like constants. This is equivalent to using array notation in Autolev for constants.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nk1, k2, k3, k4 = sm.symbols('k1 k2 k3 k4', real=True)\na2, a3, a4 = sm.symbols('a2 a3 a4', real=True)\nb11, b12, b21, b22 = sm.symbols('b11 b12 b21 b22', real=True)\n```\n\n----------------------------------------\n\nTITLE: Converting Pathways to Forces in SymPy Mechanics\nDESCRIPTION: Shows how to generate forces from a linear pathway using the to_loads method, which takes a force magnitude and returns a list of forces acting on the pathway's endpoints with the correct directions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import pprint\n>>> pprint.pprint(lpathway.to_loads(-k*x - k*x.diff()))\n[Force(point=O, force=(k*x(t) + k*Derivative(x(t), t))*x(t)/Abs(x(t))*N.x),\n Force(point=P, force=(-k*x(t) - k*Derivative(x(t), t))*x(t)/Abs(x(t))*N.x)]\n```\n\n----------------------------------------\n\nTITLE: Handling Symbolic Constants in Polynomial Conversion\nDESCRIPTION: Demonstrates how symbolic numbers like π are treated in polynomial conversion. By default, they are considered generators, but they can be explicitly included in the coefficient domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> e = (x + 2*pi)*y\n>>> e.as_poly()\nPoly(x*y + 2*y*pi, x, y, pi, domain='ZZ')\n>>> e.as_poly(x, y)\nPoly(x*y + 2*pi*y, x, y, domain='ZZ[pi]')\n```\n\n----------------------------------------\n\nTITLE: Defining Inertia and RigidBody Objects for Bicycle Components in SymPy\nDESCRIPTION: Creates inertia objects for the frame, fork, and wheels, then defines RigidBody containers for each component of the bicycle. This sets up the physical properties of the bicycle model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nFrame_I = (me.inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0,\n                      Iframe31), Frame_mc)\nFork_I = (me.inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\nWR_I = (me.inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\nWF_I = (me.inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n\nBodyFrame = me.RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\nBodyFork = me.RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\nBodyWR = me.RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\nBodyWF = me.RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\nbodies = [BodyFrame, BodyFork, BodyWR, BodyWF]\n```\n\n----------------------------------------\n\nTITLE: Expanding Complex Valued Expressions in SymPy (Python)\nDESCRIPTION: Shows how to expand complex valued expressions and put them into a normal form using SymPy's expand() function with the complex keyword.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/rewriting.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> (x + I*y).expand(complex=True)\nre(x) + I*re(y) + I*im(x) - im(y)\n\n>>> sin(x + I*y).expand(complex=True)\nsin(re(x) - im(y))*cosh(re(y) + im(x)) + I*cos(re(x) - im(y))*sinh(re(y) + im(x))\n```\n\n----------------------------------------\n\nTITLE: Defining Inertia and Rigid Bodies in SymPy Mechanics\nDESCRIPTION: This code defines the inertia and rigid bodies for the Duffing oscillator block and the pendulum, assuming a simple pendulum model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/duffing-example.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nI_block = M / 12 * me.inertia(N, h**2 + d**2, w**2 + d**2, w**2 + h**2)\nI_pendulum = 2*m*r**2/5*me.inertia(B, 1, 0, 1)\nblock_body = me.RigidBody('block', block_point, N, M, (I_block, block_point))\npendulum_body = me.RigidBody('pendulum', pendulum_point, B, m, (I_pendulum, pendulum_point))\n```\n\n----------------------------------------\n\nTITLE: Querying Symbol Assumptions in SymPy\nDESCRIPTION: Shows how to create a symbol with multiple assumptions (positive and integer) and query its properties. Also demonstrates accessing the full set of assumptions using the assumptions0 attribute.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> x = Symbol('x', positive=True, integer=True)\n>>> x.is_positive\nTrue\n>>> x.is_integer\nTrue\n>>> x.assumptions0\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'integer': True,\n 'irrational': False,\n 'negative': False,\n 'noninteger': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'rational': True,\n 'real': True,\n 'transcendental': False,\n 'zero': False}\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy Polynomial Functions\nDESCRIPTION: This snippet shows the autofunction directives for importing various polynomial-related functions from SymPy. These functions are likely implemented in C or Cython for performance reasons.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: sdm_monomial_divides\n.. autofunction:: sdm_LC\n.. autofunction:: sdm_to_dict\n.. autofunction:: sdm_from_dict\n.. autofunction:: sdm_add\n.. autofunction:: sdm_LM\n.. autofunction:: sdm_LT\n.. autofunction:: sdm_mul_term\n.. autofunction:: sdm_zero\n.. autofunction:: sdm_deg\n.. autofunction:: sdm_from_vector\n.. autofunction:: sdm_to_vector\n```\n\n----------------------------------------\n\nTITLE: Converting Speed of Light to Meters and Seconds in Python using SymPy\nDESCRIPTION: This snippet demonstrates how to use the convert_to function from SymPy's physics.units module to express the speed of light in terms of meters and seconds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.units import speed_of_light, meter, second\nfrom sympy.physics.units import convert_to\nconvert_to(speed_of_light, [meter, second])\n```\n\n----------------------------------------\n\nTITLE: Calculating Greatest Common Divisor with ZZ Domain\nDESCRIPTION: This example shows how to compute the greatest common divisor (GCD) of two integers using the ZZ domain's gcd method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsref.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> ZZ.gcd(ZZ(10), ZZ(2))\n2\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing Differential Operators in SymPy (Python)\nDESCRIPTION: This snippet imports necessary SymPy modules and initializes symbols, differential operators, and a polynomial ring for constructing holonomic functions. Dependencies include sympy.holonomic.holonomic (for HolonomicFunction and DifferentialOperators), sympy.polys.domains (for QQ), and sympy (for symbols). The main parameters are the polynomial variable x, and the differential operator ring R and its derivation Dx. The expected output is the operator ring and differential operator configurations for further holonomic function construction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.holonomic.holonomic import HolonomicFunction, DifferentialOperators\\n>>> from sympy.polys.domains import QQ\\n>>> from sympy import symbols\\n>>> x = symbols('x')\\n>>> R, Dx = DifferentialOperators(QQ.old_poly_ring(x),'Dx')\n```\n\n----------------------------------------\n\nTITLE: Computing Final Basis Change Matrix\nDESCRIPTION: Mathematical representation of the change of basis matrix between MKS system and natural system, obtained by taking the inverse of the previous matrix.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/philosophy.rst#2025-04-22_snippet_5\n\nLANGUAGE: math\nCODE:\n```\nP =\n\\begin{pmatrix}\n0 & 1 & 0 \\\\\n1 & 0 & 1 \\\\\n0 & -2 & -1\n\\end{pmatrix}.\n```\n\n----------------------------------------\n\nTITLE: Generators Module Documentation\nDESCRIPTION: Module containing functions to generate common permutation groups including symmetric, cyclic, alternating, and dihedral groups.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/permutations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsympy.combinatorics.generators\n```\n\n----------------------------------------\n\nTITLE: Creating FpGroup with Free Group Generators in Python\nDESCRIPTION: Demonstrates how to create a finitely presented group representing the symmetric group of degree 4 using free group generators and relations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/fp_groups.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nF, a, b = free_group(\"a, b\")\nG = FpGroup(F, [a**2, b**3, (a*b)**4])\nG\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Finite Field Domains in SymPy\nDESCRIPTION: This snippet shows how to create a finite field of prime order using GF or FF in SymPy and perform operations with its elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy import GF\n>>> K = GF(5)\n>>> two = K(2)\n>>> two #doctest: +SKIP\n2 mod 5\n>>> two ** 2A #doctest: +SKIP\n4 mod 5\n>>> two ** 3 #doctest: +SKIP\n3 mod 5\n```\n\n----------------------------------------\n\nTITLE: Converting Musculotendon Forces to Loads on the System\nDESCRIPTION: Demonstrates how to generate the force loads that the musculotendon applies to the attachment points in the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle_loads = muscle.to_loads()\n>>> pprint.pprint(muscle_loads)\n[Force(point=O, force=F_M_max*(beta*(-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)) + a_muscle(t)*FiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)*FiberForceVelocityDeGroote2016((-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)), -0.318, -8.149, -0.374, 0.886) + FiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.6, 4.0))*q(t)*cos(alpha_opt)/Abs(q(t))*N.x),\n Force(point=P, force=- F_M_max*(beta*(-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)) + a_muscle(t)*FiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)*FiberForceVelocityDeGroote2016((-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)), -0.318, -8.149, -0.374, 0.886) + FiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.6, 4.0))*q(t)*cos(alpha_opt)/Abs(q(t))*N.x)]\n```\n\n----------------------------------------\n\nTITLE: Creating New Oriented Reference Frames Using orientnew - SymPy - Python\nDESCRIPTION: Shows how to create a new reference frame oriented relative to an existing one in a single step using the orientnew method. Demonstrates the flexibility to choose orientation schemes and axes. Requires sympy.physics.vector and existing frame (here 'N'). The result is a new frame with rotational relationship to its parent.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> C = N.orientnew('C', 'Axis', [q1, N.x])\n```\n\n----------------------------------------\n\nTITLE: Implementing Muscle Excitation and Dynamics Evaluation Functions\nDESCRIPTION: Creates functions for muscle excitation over time and for evaluating the right-hand side of the differential equations. These functions integrate with SciPy's ODE solver to simulate the system dynamics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> def eval_r(t):\n...     \"\"\"Returns the muscles' excitation as a function of time.\"\"\"\n...     e = np.array([0.0, 0.0])\n...     return e\n...\n>>> def eval_rhs(t, x, r, p):\n...     \"\"\"Returns the time derivative of the state.\n...\n...     Parameters\n...     ==========\n...     t : float\n...         Time in seconds.\n...     x : array_like, shape(10,)\n...         State vector.\n...     r : function\n...         Function f(t) that evaluates e.\n...     p : array_like, shape(?, )\n...         Parameter vector.\n...\n...     Returns\n...     =======\n...     dxdt : ndarray, shape(10,)\n...       Time derivative of the state.\n...\n...     \"\"\"\n...\n...     q = x[0:4]\n...     u = x[4:8]\n...     a = x[8:10]\n...\n...     e = r(t)\n...\n...     qd = u\n...     m, f, ad = eval_diffeq(q, u, a, e, p)\n...     ud = np.linalg.solve(m, f).squeeze()\n...\n...     return np.hstack((qd, ud, ad.squeeze()))\n...\n```\n\n----------------------------------------\n\nTITLE: Working with Parameters in Diophantine Solutions\nDESCRIPTION: Demonstrates how to substitute specific values for the parameters to generate concrete solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> my_syms = (a, b, c)\n>>> pythag = a**2 + b**2 - c**2\n>>> d = diophantine(pythag, syms=my_syms)\n>>> solution_list = list(d)\n>>> p, q = symbols(\"p, q\", integer=True)\n>>> solution_p4q3 = dict(zip(my_syms, [var.subs({p:4, q:3}) for var in solution_list[0]]))\n>>> solution_p4q3\n{a: 24, b: 7, c: 25}\n```\n\n----------------------------------------\n\nTITLE: Extracting Differential Equations from the System\nDESCRIPTION: Extracts the specific differential equations for position, velocity, and muscle activation that govern the system dynamics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n>>> dqdt = u\n>>> dudt = kane.forcing[0]/m\n>>> dadt = muscle.rhs()[0]\n```\n\n----------------------------------------\n\nTITLE: Using noqa to Suppress Flake8 Warnings\nDESCRIPTION: Example of using the noqa comment to suppress flake8 warnings for multiple dispatch function definitions that would otherwise trigger F811 (redefinition) errors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n@dispatch(...)\ndef funcname(arg1, arg2): # noqa: F811\n    ...\n\n@dispatch(...)\ndef funcname(arg1, arg2): # noqa: F811\n    ...\n```\n\n----------------------------------------\n\nTITLE: Manipulating Series Expansions with Order Terms in Python using SymPy\nDESCRIPTION: This snippet demonstrates how to create and manipulate series expansions with order terms in SymPy. It shows the automatic absorption of higher-order terms and the removal of order terms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> x + x**3 + x**6 + O(x**4)\n     3    ⎛ 4⎞\nx + x  + O⎝x ⎠\n>>> x*O(1)\nO(x)\n\n>>> expr.series(x, 0, 4).removeO()\n 2\nx\n── + x + 1\n2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Simplified Matrix Class Hierarchy in Python\nDESCRIPTION: Shows the new simplified inheritance hierarchy for matrix classes in SymPy as of version 1.13. This change improves code maintainability and performance by reducing complexity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass MatrixBase(Printable):\nclass RepMatrix(MatrixBase):\nclass DenseMatrix(RepMatrix):\nclass MutableRepMatrix(RepMatrix):\nclass MutableDenseMatrix(DenseMatrix, MutableRepMatrix):\n```\n\n----------------------------------------\n\nTITLE: Accessing Expression Components in Python using SymPy\nDESCRIPTION: Demonstrates how to access the func and args attributes of a SymPy expression, showing how expressions are constructed internally.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nexpr = Add(x, x)\nexpr.func\n# Output: <class 'sympy.core.mul.Mul'>\n\nexpr\n# Output: 2*x\n\nInteger(2).func\n# Output: <class 'sympy.core.numbers.Integer'>\nInteger(0).func\n# Output: <class 'sympy.core.numbers.Zero'>\nInteger(-1).func\n# Output: <class 'sympy.core.numbers.NegativeOne'>\n```\n\n----------------------------------------\n\nTITLE: Creating a Wrapping Pathway with Cylinder Geometry in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a pathway that wraps around a cylindrical surface. The forces follow lines tangent to the geodesic connecting two points on the cylinder surface, which is useful for modeling muscles wrapping around bones.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> r = sm.symbols('r', real=True, nonegative=True)\n>>> theta = me.dynamicsymbols('theta', real=True)\n>>> O, P, Q = sm.symbols('O, P, Q', cls=me.Point)\n>>> A = me.ReferenceFrame('A')\n\n>>> A.orient_axis(N, theta, N.z)\n\n>>> P.set_pos(O, r*N.x)\n>>> Q.set_pos(O, N.z + r*A.x)\n\n>>> cyl = me.WrappingCylinder(r, O, N.z)\n>>> wpathway = me.WrappingPathway(P, Q, cyl)\n>>> pprint.pprint(wpathway.to_loads(-k*wpathway.length))\n[Force(point=P, force=- k*r*Abs(theta(t))*N.y - k*N.z),\n Force(point=Q, force=k*N.z + k*r*Abs(theta(t))*A.y),\n Force(point=O, force=k*r*Abs(theta(t))*N.y - k*r*Abs(theta(t))*A.y)]\n```\n\n----------------------------------------\n\nTITLE: Automatic Generator Selection in SymPy Poly\nDESCRIPTION: Shows how SymPy automatically selects generators for polynomial expressions, including handling of transcendental functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import pi, exp\nPoly(x**2*y + z)\nPoly(exp(x) + exp(2*x) + 1)\nPoly(pi*x)\nPoly(pi*x, x)\n```\n\n----------------------------------------\n\nTITLE: Creating a First-Order Muscle Activation Model\nDESCRIPTION: Sets up a first-order differential equation model for muscle activation dynamics that relates excitation to activation with delay.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.biomechanics import FirstOrderActivationDeGroote2016\n>>> muscle_activation = FirstOrderActivationDeGroote2016.with_defaults('muscle')\n```\n\n----------------------------------------\n\nTITLE: Extracting Parameter Symbols\nDESCRIPTION: Shows how to programmatically extract the auto-generated parameter symbols from a solution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> a, b, c, p, q = symbols(\"a, b, c, p, q\", integer=True)\n>>> my_syms = (a, b, c)\n>>> pythag = a**2 + b**2 - c**2\n>>> solution, = diophantine(pythag, syms=my_syms)\n>>> set().union(*(s.free_symbols for s in solution))\n{p, q}\n```\n\n----------------------------------------\n\nTITLE: Defining Lagrangian System Components\nDESCRIPTION: Creates the necessary points, particles and constraints for the Lagrangian formulation. Sets up the holonomic constraint maintaining constant pendulum length.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/lin_pend_nonmin_example.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Create point P, the pendulum mass\nP = pN.locatenew('P1', q1*N.x + q2*N.y)\nP.set_vel(N, P.pos_from(pN).dt(N))\npP = Particle('pP', P, m)\n\n# Holonomic Constraint Equations\nf_c = Matrix([q1**2 + q2**2 - L**2])\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration and RHS Usage\nDESCRIPTION: Shows how variables are declared and RHS expressions are handled differently in Autolev versus SymPy, including inertia declarations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/autolev_parser.rst#2025-04-22_snippet_4\n\nLANGUAGE: autolev\nCODE:\n```\nVARIABLES X, Y\nE = X + Y\nX = 2*Y\n\nRHS_X = RHS(X)\n\nI1 = X\nI2 = Y\nI3 = X + Y\n\nINERTIA B,I1,I2,I3\n```\n\nLANGUAGE: python\nCODE:\n```\nx,y = me.dynamicsymbols('x y')\ne = x + y  # No symbol is made out of 'e'\n\n# an entry like {x:2*y} is stored in an rhs dictionary\n\nrhs_x = 2*y\n\ni1 = x  # again these are not made into SymPy symbols\ni2 = y\ni3 = x + y\n\nbody_b.inertia = (me.inertia(body_b_f, i1, i2, i3), b_cm)\n```\n\n----------------------------------------\n\nTITLE: Defining Symbols with Assumptions using symbols() (Python)\nDESCRIPTION: Illustrates how to define symbols with specific assumptions (like `positive=True`) using the `symbols` function when they are not common symbols available in `sympy.abc` or require specific properties.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, sqrt\n>>> a, b = symbols('a b', positive=True)\n>>> sqrt((a + b)**2)\na + b\n```\n\n----------------------------------------\n\nTITLE: Verifying Pappus' Hexagon Theorem using SymPy Geometry in Python\nDESCRIPTION: Demonstrates how to use the SymPy geometry module to verify Pappus' Hexagon Theorem. It defines two lines (`l1`, `l2`), a helper function `subs_point` to create specific points on a line using its parametric representation, generates two sets of collinear points (`p11`-`p13` on `l1`, `p21`-`p23` on `l2`), constructs lines connecting pairs of points from the two sets according to the theorem, calculates the intersection points (`pp1`, `pp2`, `pp3`) of these lines, and finally uses `Point.is_collinear` to confirm that these intersection points are collinear, thus verifying the theorem.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/geometry/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.geometry import *\n>>>\n>>> l1 = Line(Point(0, 0), Point(5, 6))\n>>> l2 = Line(Point(0, 0), Point(2, -2))\n>>>\n>>> def subs_point(l, val):\n...    \"\"\"Take an arbitrary point and make it a fixed point.\"\"\"\n...    t = Symbol('t', real=True)\n...    ap = l.arbitrary_point()\n...    return Point(ap.x.subs(t, val), ap.y.subs(t, val))\n...\n>>> p11 = subs_point(l1, 5)\n>>> p12 = subs_point(l1, 6)\n>>> p13 = subs_point(l1, 11)\n>>>\n>>> p21 = subs_point(l2, -1)\n>>> p22 = subs_point(l2, 2)\n>>> p23 = subs_point(l2, 13)\n>>>\n>>> ll1 = Line(p11, p22)\n>>> ll2 = Line(p11, p23)\n>>> ll3 = Line(p12, p21)\n>>> ll4 = Line(p12, p23)\n>>> ll5 = Line(p13, p21)\n>>> ll6 = Line(p13, p22)\n>>>\n>>> pp1 = intersection(ll1, ll3)[0]\n>>> pp2 = intersection(ll2, ll5)[0]\n>>> pp3 = intersection(ll4, ll6)[0]\n>>>\n>>> Point.is_collinear(pp1, pp2, pp3)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Evaluating Symbolic Expressions and Constants with SymPy in Python\nDESCRIPTION: These snippets show evaluating symbolic expressions, such as multiplying constants (e.g., '2*pi'), and computing their floating point value using the '.evalf()' method. Required dependencies: SymPy import as 'sm'. Inputs are symbolic constants and variables; outputs are either symbolic expressions or numeric values, with no side effects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntina = 2*sm.pi\n```\n\nLANGUAGE: python\nCODE:\n```\ntina = tina.evalf()\n```\n\n----------------------------------------\n\nTITLE: Forming Logical Implications in SymPy (Python)\nDESCRIPTION: This snippet shows how to form implication relationships between Boolean symbols using the >> and << operators, which SymPy maps to Implies objects. Users must initialize symbols and then use these operators to create direct and reverse implications. Dependencies include the SymPy library, and all variable inputs are symbolic Boolean variables. The outputs are symbolic Implies objects representing logical relationships.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/logic.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> x >> y\nImplies(x, y)\n>>> x << y\nImplies(y, x)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Plot Elements using Keyword Arguments in Python\nDESCRIPTION: Demonstrates the recommended way to add custom plot elements like markers, annotations, fill, and rectangles using keyword arguments in SymPy's plotting functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\np = plot(x,\n  markers=[{\"args\":[[0, 1], [0, 1]], \"marker\": \"*\", \"linestyle\": \"none\"}],\n  annotations=[{\"text\": \"test\", \"xy\": (0, 0)}],\n  fill={\"x\": [0, 1, 2, 3], \"y1\": [0, 1, 2, 3]},\n  rectangles=[{\"xy\": (0, 0), \"width\": 5, \"height\": 1}])\n```\n\n----------------------------------------\n\nTITLE: Polynomial Factorization Examples\nDESCRIPTION: Demonstrates polynomial factorization using factor() and factor_list() functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfactor(x**3 - x**2 + x - 1)\nfactor(x**2*z + 4*x*y*z + 4*y**2*z)\nfactor_list(x**2*z + 4*x*y*z + 4*y**2*z)\n```\n\n----------------------------------------\n\nTITLE: Creating Conda Virtual Environment for SymPy Development\nDESCRIPTION: Command to create a Conda virtual environment for SymPy development with required dependencies.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nconda create -n sympy-dev -c conda-forge --file requirements-dev.txt\n```\n\n----------------------------------------\n\nTITLE: Basic Symbolic Boolean Implementation in Python\nDESCRIPTION: Initial implementation of both_positive function using basic conditional logic. Returns symbolic Boolean values but fails with undefined symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef both_positive(a, b):\n    \"\"\"ask whether a and b are both positive\"\"\"\n    if a > 0 and b > 0:\n        return S.true\n    else:\n        return S.false\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Numbers with SymPy in Python\nDESCRIPTION: These snippets illustrate how to define and use the imaginary unit with SymPy ('sm.I'), and construct a complex symbolic expression. Dependencies include SymPy imported as 'import sympy as sm'. Inputs are symbolic variables, and outputs are symbolic expressions that can be manipulated further. The imaginary unit 'I' allows construction of complex values, which can be used across SymPy computations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nj = sm.I\n```\n\nLANGUAGE: python\nCODE:\n```\nz = x + I*y\n```\n\n----------------------------------------\n\nTITLE: Free Group Creation Examples in Python\nDESCRIPTION: Demonstrates different methods for creating free groups using free_group and vfree_group functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/fp_groups.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nF, x, y = free_group(\"x, y\")\n\nF = vfree_group(\"x, y\")\nF\n\nF = xfree_group(\"x, y\")\nF\nx**2\n```\n\n----------------------------------------\n\nTITLE: Simplifying Unit Ratios in Python using SymPy\nDESCRIPTION: This example shows how to simplify ratios of units using the .simplify() method and the quantity_simplify() function from SymPy's physics.units.util module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.units.util import quantity_simplify\nfrom sympy.physics.units import kilometer\nmeter/kilometer\n(meter/kilometer).simplify()\nquantity_simplify(meter/kilometer)\n```\n\n----------------------------------------\n\nTITLE: Configuring Reference Frame with Custom LaTeX Strings\nDESCRIPTION: Shows how to create a ReferenceFrame with custom LaTeX string representations for each basis vector, overriding default formatting.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/advanced.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame, vlatex\n>>> N = ReferenceFrame('N', latexs=['n1','\\\\mathbf{n}_2','cat'])\n>>> vlatex(N.x)\n'n1'\n>>> vlatex(N.y)\n'\\\\mathbf{n}_2'\n>>> vlatex(N.z)\n'cat'\n```\n\n----------------------------------------\n\nTITLE: Logarithm Combination with logcombine\nDESCRIPTION: Demonstrates the use of logcombine function to combine logarithmic expressions, showing both default and forced combination.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nlogcombine(n*log(z))\nlogcombine(n*log(z), force=True)\n```\n\n----------------------------------------\n\nTITLE: Initializing Bodies and Loads for the System\nDESCRIPTION: Creates lists to hold the physical components (bodies) and forces (loads) acting on the system, with a single particle and gravitational force.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbodies = [Pa]\nloads = [(P, g * m * N.x)]\n```\n\n----------------------------------------\n\nTITLE: Cloning SymPy Git repository\nDESCRIPTION: This command clones the SymPy Git repository for contributing or getting the latest updates.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/sympy/sympy.git\n```\n\n----------------------------------------\n\nTITLE: Evaluating CRootOf Objects Numerically with evalf in Python\nDESCRIPTION: This example shows how to numerically evaluate CRootOf objects, which represent complex roots of a polynomial that cannot be expressed in a simpler form.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x\n>>> solutions = solve(x**5 - x - 1, x, dict=True)\n>>> solutions\n[{x: CRootOf(x**5 - x - 1, 0)}, {x: CRootOf(x**5 - x - 1, 1)}, {x: CRootOf(x**5 - x - 1, 2)}, {x: CRootOf(x**5 - x - 1, 3)}, {x: CRootOf(x**5 - x - 1, 4)}]\n>>> [solution[x].evalf(3) for solution in solutions]\n[1.17, -0.765 - 0.352*I, -0.765 + 0.352*I, 0.181 - 1.08*I, 0.181 + 1.08*I]\n```\n\n----------------------------------------\n\nTITLE: Calculating Muscle Pathway Length and Velocity\nDESCRIPTION: Shows how to retrieve the muscle pathway's length and extension velocity between attachment points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle_pathway.length\nAbs(q(t))\n>>> muscle_pathway.extension_velocity\nsign(q(t))*Derivative(q(t), t)\n```\n\n----------------------------------------\n\nTITLE: Three-Valued Logic in SymPy Assumptions\nDESCRIPTION: Shows how assumption queries can return True, False, or None using three-valued fuzzy logic.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x')\ny = Symbol('y', positive=True)\nz = Symbol('z', negative=True)\nprint(x.is_positive)\nprint(y.is_positive)\nprint(z.is_positive)\n```\n\n----------------------------------------\n\nTITLE: Using rs_series with Fractional Exponents in SymPy\nDESCRIPTION: Example demonstrating how to use rs_series with expressions containing fractional exponents. The series=True flag is implicitly used by rs_series to allow rational exponents.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> rs_series(sin(a**QQ(1, 3)), a, 3)\n-1/5040*a**(7/3) + 1/120*a**(5/3) - 1/6*a + a**(1/3)\n```\n\n----------------------------------------\n\nTITLE: Using FirstOrderActivationDeGroote2016 Class in SymPy\nDESCRIPTION: Imports `FirstOrderActivationDeGroote2016` from `sympy.physics.biomechanics`. It instantiates the class with a unique name 'first' and the previously defined symbolic parameters `tau_a`, `tau_d`, and `b`. Accessing the `.excitation` and `.activation` attributes shows the distinct, automatically generated dynamic symbols `e_first(t)` and `a_first(t)` associated with this model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.biomechanics import FirstOrderActivationDeGroote2016\n>>> actf = FirstOrderActivationDeGroote2016('first', tau_a, tau_d, b)\n>>> actf.excitation\ne_first(t)\n>>> actf.activation\na_first(t)\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Environment\nDESCRIPTION: Sets up basic SymPy environment by importing required modules and defining symbolic variables x, y, z with unicode printing enabled.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols('x y z')\ninit_printing(use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Custom expreal Function with Assumed Symbols (Python)\nDESCRIPTION: Demonstrates how the `expreal` function's `eval` method uses the assumptions system on symbolic arguments. A symbol `x` is created with assumptions `extended_negative=True` and `infinite=True`. When `expreal(x)` is called, the `eval` method checks these properties (`x.is_infinite` and `x.is_extended_negative` will be True) and correctly evaluates the result to `0`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> x = Symbol('x', extended_negative=True, infinite=True)\n>>> x\nx\n>>> expreal(x)\n0\n```\n\n----------------------------------------\n\nTITLE: Deleting Rows and Columns from SymPy Matrices in Python\nDESCRIPTION: Demonstrates the in-place removal of rows and columns from a SymPy `Matrix` using `M.row_del(index)` and `M.col_del(index)`. These methods modify the matrix directly and do not return a new matrix. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> M.row_del(0)\n>>> M\n[4  5  6]\n[       ]\n[7  8  9]\n>>> M.col_del(1)\n>>> M\n[4  6]\n[    ]\n[7  9]\n```\n\n----------------------------------------\n\nTITLE: Running SymPy Tests with Random Seed in Bash\nDESCRIPTION: This bash command shows how to run SymPy tests with a specific random seed. It's useful for reproducing random test failures by ensuring the same randomization is used across test runs.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n./bin/test --seed 7357232\n```\n\n----------------------------------------\n\nTITLE: Accessing Muscle Activation Variable\nDESCRIPTION: Shows how to access the muscle activation variable from the musculotendon model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n>>> a = muscle.a\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Conditions with Option 2 Syntax\nDESCRIPTION: Demonstrates how to specify initial conditions when using the alternative approach (option 2) where functions are defined with their independent variable.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> dsolve(eq, y, ics={y.subs(t, 0): 0})\nEq(y(t), C2*t*exp(-t))\n```\n\n----------------------------------------\n\nTITLE: Uploading SymPy Release to GitHub and PyPI\nDESCRIPTION: This command uses rever to upload the release to both GitHub and PyPI. It requires appropriate access to both platforms.\nSOURCE: https://github.com/sympy/sympy/blob/master/release/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrever VERSION -a upload\n```\n\n----------------------------------------\n\nTITLE: Using ForceActuator-based SpringDamper with Linear Pathway\nDESCRIPTION: Instantiates the `ForceActuator`-based `SpringDamper` class (defined previously) using a linear pathway object `lpathway`, spring constant `k`, and damping coefficient `c`. It subsequently calls the inherited `to_loads()` method and pretty-prints the resulting symbolic `Force` objects applied at the pathway's endpoints (`O` and `P`). Depends on `sympy.physics.mechanics` (`me`), `pprint`, and the custom `SpringDamper` class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> spring_damper2 = SpringDamper(lpathway, k, c)\n>>> pprint.pprint(spring_damper2.to_loads())\n[Force(point=O, force=(c*sign(x(t))*Derivative(x(t), t) + k*Abs(x(t)))*x(t)/Abs(x(t))*N.x),\n Force(point=P, force=(-c*sign(x(t))*Derivative(x(t), t) - k*Abs(x(t)))*x(t)/Abs(x(t))*N.x)]\n```\n\n----------------------------------------\n\nTITLE: Spring-Mass System Transfer Function\nDESCRIPTION: Calculates transfer function for a spring-mass dampening system using differential equations and Laplace transforms. Demonstrates conversion from time domain to frequency domain analysis.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/control_problems.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Function, laplace_transform, laplace_initial_conds, laplace_correspondence, diff, Symbol, solve\nfrom sympy.abc import s, t\nfrom sympy.physics.control import TransferFunction\ny = Function('y')\nY = Function('Y')\nu = Function('u')\nU = Function('U')\nk = Symbol('k') # Spring Constant\nc = Symbol('c') # Damper\nm = Symbol('m') # Mass of block\n\nf = m*diff(y(t), t, t) + c*diff(y(t), t) + k*y(t) - u(t)\nF = laplace_transform(f, t, s, noconds=True)\nF = laplace_correspondence(F, {u: U, y: Y})\nF = laplace_initial_conds(F, t, {y: [0, 0]})\nt = (solve(F, Y(s))[0])/U(s)\ntf = TransferFunction.from_rational_expression(t, s)\n```\n\n----------------------------------------\n\nTITLE: Retrieving ODE RHS for ZerothOrderActivation in SymPy\nDESCRIPTION: Calls the `rhs()` method on an instance (`actz`) of the `ZerothOrderActivation` class. Since zeroth-order activation is an algebraic relationship (`a(t) = e(t)`) and not defined by a differential equation for `da/dt`, the method correctly returns an empty SymPy Matrix, indicating no state derivatives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> actz.rhs()\nMatrix(0, 1, [])\n```\n\n----------------------------------------\n\nTITLE: Displaying State-Space Matrices for a Pendulum System in SymPy\nDESCRIPTION: Shows the result of a linearization operation that produced the A and B matrices for what appears to be a pendulum system. The A matrix shows the relationship between position, velocity and acceleration with gravity (g) and pendulum length (L) parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/lin_pend_nonmin_example.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]])\n>>> B\nMatrix(0, 0, [])\n```\n\n----------------------------------------\n\nTITLE: Subtraction Representation\nDESCRIPTION: Demonstrates how subtraction is internally represented as addition with multiplication by -1\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsrepr(x - y)\n```\n\n----------------------------------------\n\nTITLE: Initializing Custom Reference Frame with Indices in Python\nDESCRIPTION: Creates a ReferenceFrame with custom indices for basis vectors, demonstrating alternate ways to access the frame's components and custom LaTeX output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/advanced.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import ReferenceFrame, vprint, vpprint, vlatex\n>>> N = ReferenceFrame('N', indices=['i', 'j', 'k'])\n>>> N['i']\nN['i']\n>>> N.x\nN['i']\n>>> vlatex(N.x)\n'\\\\mathbf{\\\\hat{n}_{i}}'\n```\n\n----------------------------------------\n\nTITLE: Using the FMA Function for Basic Evaluation and Transformation\nDESCRIPTION: Examples of using the FMA function in SymPy, showing unevaluated expressions, explicit evaluation with doit(), rewriting, and numerical evaluation with evalf().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n>>> x, y, z = symbols('x y z')\n>>> FMA(2, 3, 4)\n10\n>>> FMA(x, y, z)\nFMA(x, y, z)\n>>> FMA(x, y, z).doit()\nx*y + z\n>>> FMA(x, y, z).rewrite(Add)\nx*y + z\n>>> FMA(2, pi, 1).evalf()\n7.28318530717959\n```\n\n----------------------------------------\n\nTITLE: Establishing Translational Kinematics for Rolling Disc in Python\nDESCRIPTION: This snippet defines the translational kinematics of the rolling disc. It creates a contact point with no velocity, forms a position vector to the disc's center of mass, and calculates the velocity of the disc's center.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_lagrange.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nC = Point('C')\nC.set_vel(N, 0)\nDmc = C.locatenew('Dmc', r * L.z)\nDmc.v2pt_theory(C, N, R)\n```\n\n----------------------------------------\n\nTITLE: Generating LaTeX Output in SymPy\nDESCRIPTION: Demonstrates how to use latex() function to generate LaTeX representation of SymPy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(latex(Integral(sqrt(1/x), x)))\n```\n\n----------------------------------------\n\nTITLE: Initializing Simple Pendulum System with Lagrange's Method in Python\nDESCRIPTION: Sets up a simple pendulum system using SymPy mechanics for Lagrange's method, redefining angles and creating Lagrangian equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> # Redefine A and P in terms of q1d, not u1\n>>> A = N.orientnew('A', 'axis', [q1, N.z])\n>>> A.set_ang_vel(N, q1d*N.z)\n>>> P = pN.locatenew('P', L*A.x)\n>>> vel_P = P.v2pt_theory(pN, N, A)\n>>> pP = Particle('pP', P, m)\n\n>>> # Solve for eom with Lagrange's method\n>>> Lag = Lagrangian(N, pP)\n>>> LM = LagrangesMethod(Lag, [q1], forcelist=[(P, R)], frame=N)\n>>> lag_eqs = LM.form_lagranges_equations()\n```\n\n----------------------------------------\n\nTITLE: Example of Rewriting Sin to Cos in SymPy\nDESCRIPTION: This code snippet demonstrates SymPy's built-in rewrite capabilities by showing how sin(x) can be rewritten in terms of cos using the rewrite method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> sin(x).rewrite(cos)\ncos(x - pi/2)\n```\n\n----------------------------------------\n\nTITLE: Polynomial Division in SymPy\nDESCRIPTION: Shows how to use the div function from SymPy to perform polynomial division and obtain quotient and remainder.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 5*x**2 + 10*x + 3\n>>> g = 2*x + 2\n\n>>> q, r = div(f, g, domain='QQ')\n>>> q\n5*x   5\n--- + -\n 2    2\n>>> r\n-2\n>>> (q*g + r).expand()\n   2\n5*x  + 10*x + 3\n```\n\n----------------------------------------\n\nTITLE: Cross-Version Compatible to_int Function for SymPy GF Domains - Python\nDESCRIPTION: Defines a helper function ensuring compatible modular integer conversion across SymPy versions by checking for the domain's to_int method. Dependencies include sympy.GF. Inputs are the domain and the element; output is the integer representative. Properly handles older and current API behaviors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef to_int(K, a):\n    if hasattr(K, 'to_int'):\n        return K.to_int(a)\n    else:\n        return a.to_int()\n```\n\n----------------------------------------\n\nTITLE: Custom Color Functions for SymPy Plots\nDESCRIPTION: Shows how to apply custom coloring to plots based on mathematical functions. This example colors a saddle surface by the magnitude of its gradient.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfz = x**2-y**2\nFx, Fy, Fz = fz.diff(x), fz.diff(y), 0\np[1] = fz, 'style=solid'\np[1].color = (Fx**2 + Fy**2 + Fz**2)**(0.5)\n```\n\n----------------------------------------\n\nTITLE: Querying Static Assumptions of 'divides' Function (Python)\nDESCRIPTION: Demonstrates querying the assumptions defined on the `divides` function. `divides(m, n).is_integer` returns `True` directly from the class attribute. `divides(m, n).is_nonnegative` also returns `True`, which SymPy deduces from `is_negative = False`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> n, m = symbols('n m')\n>>> # Assuming 'divides' class includes is_integer=True, is_negative=False\n>>> divides(m, n).is_integer\nTrue\n>>> divides(m, n).is_nonnegative # Deduced from is_negative = False\nTrue\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeroth-Order Activation via Substitution in SymPy\nDESCRIPTION: Creates separate dynamic symbols `a` (activation) and `e` (excitation) using `sympy.physics.mechanics.dynamicsymbols`. It then defines a Python dictionary `zeroth_order_activation` mapping `a` to `e` to represent the zeroth-order relationship. Finally, it demonstrates applying this relationship by substituting `e` for `a` using the `.subs()` method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> a = me.dynamicsymbols('a')\n>>> zeroth_order_activation = {a: e}\n>>> a.subs(zeroth_order_activation)\ne(t)\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Creation and Precision Control\nDESCRIPTION: Shows creation of Float instances with custom precision and handling of decimal numbers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> Float(0.1)\n0.100000000000000\n>>> Float(0.1, 10)\n0.1000000000\n>>> Float(0.125, 30)\n0.125000000000000000000000000000\n>>> Float(0.1, 30)\n0.100000000000000005551115123126\n```\n\n----------------------------------------\n\nTITLE: Preferred Doctest Style: Showing Actual Output (Python)\nDESCRIPTION: Demonstrates the recommended way to write the previous doctest example. It shows the direct output of `trigsimp(sin(x)*cos(x))`, which is `sin(2*x)/2`, making the example much clearer for documentation purposes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# BETTER\n>>> from sympy import sin, cos, trigsimp, symbols\n>>> x = symbols('x')\n>>> trigsimp(sin(x)*cos(x))\nsin(2*x)/2\n```\n\n----------------------------------------\n\nTITLE: Documenting Vector Class in SymPy Physics Vector Module\nDESCRIPTION: Autodoc directive for the Vector class from sympy.physics.vector.vector module. It includes all members of the class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/vector/api/classes.rst#2025-04-22_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: sympy.physics.vector.vector.Vector\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment for SymPy Development\nDESCRIPTION: Commands to create and set up a Python virtual environment using venv and pip for SymPy development.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd sympy\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements-dev.txt\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber Force-Length Passive Inverse in SymPy\nDESCRIPTION: This code snippet shows how to implement the inverse of the fiber passive force-length characteristic curve using SymPy's FiberForceLengthPassiveInverseDeGroote2016 class. It demonstrates both custom parameter initialization and using default values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_28\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.physics.biomechanics import FiberForceLengthPassiveInverseDeGroote2016\n\n>>> fl_M_pas_sym =me.dynamicsymbols('fl_M_pas')\n>>> fl_M_pas_inv = FiberForceLengthPassiveInverseDeGroote2016(fl_M_pas_sym, c0, c1)\n>>> fl_M_pas_inv\nFiberForceLengthPassiveInverseDeGroote2016(fl_M_pas(t), c0, c1)\n\n>>> fl_M_pas_inv2 = FiberForceLengthPassiveInverseDeGroote2016.with_defaults(fl_M_pas_sym)\n>>> fl_M_pas_inv2\nFiberForceLengthPassiveInverseDeGroote2016(fl_M_pas(t), 0.6, 4.0)\n```\n\n----------------------------------------\n\nTITLE: Representing All Roots Implicitly using solve and CRootOf\nDESCRIPTION: Shows how `solve` can represent all roots of a polynomial, even those not expressible in radicals, using `CRootOf` (ComplexRootOf) objects. Each `CRootOf` instance represents one of the roots, indexed by the second argument.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> fifth_order_solved = solve(fifth_order, x, dict=True)\n>>> fifth_order_solved\n[{x: CRootOf(x**5 - x + 1, 0)},\n{x: CRootOf(x**5 - x + 1, 1)},\n{x: CRootOf(x**5 - x + 1, 2)},\n{x: CRootOf(x**5 - x + 1, 3)},\n{x: CRootOf(x**5 - x + 1, 4)}]\n```\n\n----------------------------------------\n\nTITLE: Alternative Component-wise Color Syntax for SymPy Plots\nDESCRIPTION: Shows an alternative syntax for specifying component-wise color functions, allowing for more explicit control over each color component.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\np[1].color = z,(0.4,0.9), y,(0.4,0.9), x,(0.4,0.9)\n```\n\n----------------------------------------\n\nTITLE: Using Assumptions in SymPy Integration\nDESCRIPTION: Illustrates the importance of using assumptions when defining symbols, showing how it affects the result of integration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import integrate, exp, oo\n>>> a = symbols('a') # no assumptions\n>>> integrate(exp(-a*x), (x, 0, oo))\nPiecewise((1/a, Abs(arg(a)) < pi/2), (Integral(exp(-a*x), (x, 0, oo)), True))\n\n>>> a = symbols('a', positive=True)\n>>> integrate(exp(-a*x), (x, 0, oo))\n1/a\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments in expreal() Function with evaluate=False in Python\nDESCRIPTION: This example demonstrates that argument validation in expreal() is not performed when evaluate=False is passed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> expreal(I, evaluate=False)\nexpreal(I)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for SymPy Commutator Module\nDESCRIPTION: This snippet uses the Sphinx `automodule` directive in reStructuredText format to automatically generate documentation for the Python module `sympy.physics.quantum.commutator`. The `:members:` option ensures that all public members (functions, classes, etc.) defined within that module are included in the generated documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/commutator.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========\nCommutator\n==========\n\n.. automodule:: sympy.physics.quantum.commutator\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Assessing Accuracy of Centered Difference Approximation in Python\nDESCRIPTION: Evaluates the accuracy of the centered difference approximation by substituting a higher-order polynomial expansion and simplifying the result.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nd = symbols('c:8')\ndfdxcheck = (P(x0+h, x0, d, 8) - P(x0-h, x0, d, 8))/(2*h)\nprint(simplify(dfdxcheck))\n```\n\n----------------------------------------\n\nTITLE: Documenting Deprecated Classes with Sphinx (reST)\nDESCRIPTION: This snippet shows how to use Sphinx reStructuredText directives to announce the deprecation of Python classes in a documentation file. It applies the '.. deprecated::' directive to indicate which version the classes Body and JointsMethod became deprecated, and uses '.. autoclass::' directives to include the classes' full API documentation. This snippet requires Sphinx and the presence of the relevant Python objects in the documented module for automatic signature and docstring extraction. Inputs are the class paths, and outputs are sections in the generated documentation referencing all members (including inherited ones). Limitations: This does not remove functionality but only adds a visible warning and guidance for users through documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/deprecated_classes.rst#2025-04-22_snippet_0\n\nLANGUAGE: reST\nCODE:\n```\n===============================\nDeprecated Classes (Docstrings)\n===============================\n\n.. deprecated:: 1.13\n    :class:`~.Body` and :class:`~.JointsMethod` have been deprecated. The\n    functionality of :class:`~.Body` is fully captured by :class:`~.RigidBody`\n    and :class:`~.Particle` and the functionality of :class:`~.JointsMethod` is\n    fully captured by :class:`~.System`.\n\n.. autoclass:: sympy.physics.mechanics.body.Body\n    :members:\n    :inherited-members:\n\n.. autoclass:: sympy.physics.mechanics.jointsmethod.JointsMethod\n    :members:\n    :inherited-members:\n\n```\n\n----------------------------------------\n\nTITLE: Multiset Partitions in SymPy\nDESCRIPTION: Examples of using multiset_partitions() to generate partitions of both numbered sequences and lists with repeated elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/iterables.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.utilities.iterables import multiset_partitions\n>>> [p for p in multiset_partitions(3, 2)]\n[[[0, 1], [2]], [[0, 2], [1]], [[0], [1, 2]]]\n>>> [p for p in multiset_partitions([1, 1, 1, 2], 2)]\n[[[1, 1, 1], [2]], [[1, 1, 2], [1]], [[1, 1], [1, 2]]]\n```\n\n----------------------------------------\n\nTITLE: Declaring Dynamic Variables with SymPy Mechanics in Python\nDESCRIPTION: These snippets show how to declare dynamic variables and their derivatives (position, velocity) using the SymPy mechanics module (aliased as 'me'). The 'dynamicsymbols' function is used to create time-dependent variables. Required dependencies include an import like 'import sympy.physics.mechanics as me'. Parameters include variable names and optional derivative orders. Outputs are symbolic functions suitable for differentiation and further calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nxd2 = me.dynamicsymbols('x', 2)\n```\n\nLANGUAGE: python\nCODE:\n```\ny1 = me.dynamicsymbols('y1')\n```\n\nLANGUAGE: python\nCODE:\n```\ny2 = me.dynamicsymbols('y2')\n```\n\nLANGUAGE: python\nCODE:\n```\ny1d = me.dynamicsymbols('y1', 1)\n```\n\nLANGUAGE: python\nCODE:\n```\ny2d = me.dynamicsymbols('y2', 1)\n```\n\nLANGUAGE: python\nCODE:\n```\nu1 = me.dynamicsymbols('u1')\n```\n\nLANGUAGE: python\nCODE:\n```\nu2 = me.dynamicsymbols('u2')\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy nightly build\nDESCRIPTION: This command installs the latest development version of SymPy from the nightly builds using pip.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple sympy\n```\n\n----------------------------------------\n\nTITLE: Accessing SymPy Matrix Elements using 1D Indexing in Python\nDESCRIPTION: Demonstrates accessing an element of a SymPy `Matrix` using a single index, treating the matrix storage as a flat, 1-dimensional list (row-major order). Accessing `M[4]` retrieves the element at the 5th position in the flattened list. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Matrix(2, 3, [1, 2, 3, 4, 5, 6])\n>>> M[4]\n5\n```\n\n----------------------------------------\n\nTITLE: Configuring KanesMethod with Auxiliary Speeds\nDESCRIPTION: Demonstrates how to configure a KanesMethod object with auxiliary speeds. In this example, u4 is specified as an auxiliary speed, which is a speed not directly related to the time derivatives of coordinates.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> KM = KanesMethod(N, [q1, q3, q4], [u1, u2, u3], u_auxiliary=[u4])\n```\n\n----------------------------------------\n\nTITLE: Quaternion Class Documentation Reference\nDESCRIPTION: ReStructuredText directive for auto-generating documentation for the Quaternion class and its members.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/algebras.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: Quaternion\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating a Function to Plot State Trajectories in Python\nDESCRIPTION: Defines a function for visualizing the time evolution of the system state variables. Creates a multi-panel plot showing the positions, velocities, and muscle activations over time.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> import matplotlib.pyplot as plt\n\n>>> def plot_traj(t, x, syms):\n...     \"\"\"Simple plot of state trajectories.\n...\n...     Parameters\n...     ==========\n...     t : array_like, shape(n,)\n...         Time values.\n...     x : array_like, shape(n, m)\n...         State values at each time value.\n...     syms : sequence of Symbol, len(m)\n...         SymPy symbols associated with state.\n...\n...     \"\"\"\n...\n...     fig, axes = plt.subplots(5, 2, sharex=True)\n...\n...     for ax, traj, sym in zip(axes.T.flatten(), x.T, syms):\n...         if not sym.name.startswith('a'):\n...             traj = np.rad2deg(traj)\n...         ax.plot(t, traj)\n...         ax.set_ylabel(sm.latex(sym, mode='inline'))\n...\n...     for ax in axes[-1, :]:\n...         ax.set_xlabel('Time [s]')\n...\n...     fig.tight_layout()\n...\n...     return axes\n...\n```\n\n----------------------------------------\n\nTITLE: ExtensionElement Class Reference (Python)\nDESCRIPTION: Class representing elements in a finite extension of a ring. This class likely provides methods for arithmetic operations and conversions between different representations of extension elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: ExtensionElement\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Preferred Conversion Methods for ModularInteger Domain Elements - SymPy GF - Python\nDESCRIPTION: Shows two preferred approaches for converting modular integer elements to int: domain's to_int(element) and the built-in int(). Dependencies: sympy.GF. Demonstrates both approaches with expected input and output, clarifying that use of the domain instance is the new best practice.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> K.to_int(a)\n2\n>>> int(a)\n2\n```\n\n----------------------------------------\n\nTITLE: Defining Reference Frames and Angular Velocity\nDESCRIPTION: Creates reference frames through a series of rotations (3-1-2 series) and defines the angular velocity of the rolling disc.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nN = ReferenceFrame('N')\nY = N.orientnew('Y', 'Axis', [q1, N.z])\nL = Y.orientnew('L', 'Axis', [q2, Y.x])\nR = L.orientnew('R', 'Axis', [q3, L.y])\nw_R_N_qd = R.ang_vel_in(N)\nR.set_ang_vel(N, u1 * L.x + u2 * L.y + u3 * L.z)\n```\n\n----------------------------------------\n\nTITLE: Displaying Polynomial Domains in SymPy\nDESCRIPTION: This snippet demonstrates how to create polynomial objects in SymPy and how the domain information is displayed. One polynomial has integer coefficients (ZZ domain) while the other has rational coefficients (QQ domain).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, Poly\n>>> x = Symbol('x')\n>>> Poly(x**2 + x)\nPoly(x**2 + x, x, domain='ZZ')\n>>> Poly(x**2 + x/2)\nPoly(x**2 + 1/2*x, x, domain='QQ')\n```\n\n----------------------------------------\n\nTITLE: Representing Infinite Solutions with ImageSet in Python\nDESCRIPTION: This snippet demonstrates how to use the ImageSet class to represent infinite solutions in the real domain, specifically for the equation sin(x) = 0.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import ImageSet, Lambda, pi, S, Dummy, pprint\nn = Dummy('n')\npprint(ImageSet(Lambda(n, 2*pi*n), S.Integers), use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Creating Local Ring of a Nodal Cubic\nDESCRIPTION: Creates the local ring of the nodal cubic y^2 = x^3 at the origin over the rational field. The example demonstrates how to create a polynomial ring and quotient it by an ideal to represent an algebraic variety.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> lr = QQ.old_poly_ring(x, y, order=\"ilex\") / [y**2 - x**3]\n>>> lr\nℚ[x, y, order=ilex]\n───────────────────\n    ╱   3    2╲\n    ╲- x  + y ╱\n```\n\n----------------------------------------\n\nTITLE: Importing DirectProduct from SymPy Combinatorics in Python\nDESCRIPTION: This snippet shows how to import the DirectProduct function from the sympy.combinatorics.group_constructs module. DirectProduct is used for constructing the direct product of multiple groups.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/group_constructs.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.combinatorics.group_constructs import DirectProduct\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing with Indexed Objects\nDESCRIPTION: Examples showing how fcode handles indexed objects to generate loops in Fortran. This demonstrates array operations and summation through repeated indices.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n>>> A, B = map(IndexedBase, ['A', 'B'])\n>>> m = Symbol('m', integer=True)\n>>> i = Idx('i', m)\n>>> print(fcode(2*B[i], assign_to=A[i]))\n    do i = 1, m\n        A(i) = 2*B(i)\n    end do\n>>> print(fcode(A[i, i], assign_to=x))\n      x = 0\n      do i = 1, m\n          x = x + A(i, i)\n      end do\n```\n\n----------------------------------------\n\nTITLE: Initializing Kane's Method Pendulum Setup\nDESCRIPTION: Sets up the initial dynamicsymbols, coordinates and system parameters for modeling a pendulum using Kane's method. Creates generalized coordinates (q1,q2) and speeds (u1,u2) representing x,y positions and velocities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/lin_pend_nonmin_example.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import *\nfrom sympy import symbols, atan, Matrix, solve\n# Create generalized coordinates and speeds for this non-minimal realization\n# q1, q2 = N.x and N.y coordinates of pendulum\n# u1, u2 = N.x and N.y velocities of pendulum\nq1, q2 = dynamicsymbols('q1:3')\nq1d, q2d = dynamicsymbols('q1:3', level=1)\nu1, u2 = dynamicsymbols('u1:3')\nu1d, u2d = dynamicsymbols('u1:3', level=1)\nL, m, g, t = symbols('L, m, g, t')\n```\n\n----------------------------------------\n\nTITLE: Implementing RC Circuit State-Space Model in Python\nDESCRIPTION: Creates a state-space representation of an RC circuit network using SymPy's StateSpace class. Models the system using two state variables and applies Kirchhoff's Current Law.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/electrical_problems.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import symbols, Matrix\nfrom sympy.physics.control import *\nR, C = symbols('R C')\nA = Matrix([[-2/(R*C), 1/(R*C)], [1/(R*C), -1/(R*C)]])\nB = Matrix([[1/(R*C)], [0]])\nC = Matrix([[0, 1]])\nss = StateSpace(A, B, C)\n```\n\n----------------------------------------\n\nTITLE: Robust XFAIL Test for Future Integration in Python\nDESCRIPTION: This code snippet demonstrates a more robust way to write an XFAIL test for an integral that is expected to be implemented in the future. It checks that the result of integrate() does not contain an Integral object, which will cause the test to XPASS once the integration starts working.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.testing.pytest import XFAIL\n\n@XFAIL\ndef test_failing_integral():\n    # Should be x*sqrt(x**2 + x**(-2))*(sqrt(x**4 + 1) - atanh(sqrt(x**4 + 1)))/(2*sqrt(x**4 + 1))\n    assert not integrate(sqrt(x**2 + 1/x**2), x).has(Integral)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating TR11 Function for Reducing Double Angles\nDESCRIPTION: Example showing how TR11 transform rewrites double angles as smaller angles without additional simplification. Requires separate powsimp to fully simplify the expression.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> TR11(sin(2)**a*cos(1)**(-a), 1)\n(2*sin(1)*cos(1))**a/cos(1)**a\n>>> powsimp(_)\n(2*sin(1))**a\n```\n\n----------------------------------------\n\nTITLE: Autofunction References for Multiset Partitions in Python\nDESCRIPTION: These lines reference autodoc functions for multiset partitions, factoring visitor, and list visitor. These functions are part of the enumerative module and are used for various operations related to multiset partitions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/enumerative.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: multiset_partitions_taocp\n.. autofunction:: factoring_visitor\n.. autofunction:: list_visitor\n```\n\n----------------------------------------\n\nTITLE: Retrieving Kinematic Differential Equations Dictionary\nDESCRIPTION: Demonstrates how to get the dictionary of kinematic differential equations from the KanesMethod object, which maps time derivatives of coordinates to expressions in terms of generalized speeds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> mechanics_printing(pretty_print=False)\n>>> KM.kindiffdict()\n{q1': u1, q2': u2, q3': u3, q4': u4}\n```\n\n----------------------------------------\n\nTITLE: Comparing Integral Object Classes\nDESCRIPTION: Shows how SymPy classes represent programmatic structures but don't distinguish mathematical differences. The example demonstrates that integrals of different mathematical objects (a number and a matrix) share the same class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import MatrixSymbol, Integral\n>>> A = MatrixSymbol('A', 2, 2)\n>>> type(Integral(1, x))\n<class 'sympy.integrals.integrals.Integral'>\n>>> type(Integral(A, x))\n<class 'sympy.integrals.integrals.Integral'>\n```\n\n----------------------------------------\n\nTITLE: Running SymPy Quality Tests Locally\nDESCRIPTION: Command to run the local quality checks in the SymPy project. This checks for basic code quality issues like trailing whitespace.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\n./bin/test quality\n```\n\n----------------------------------------\n\nTITLE: Checking Collinearity with Symbolic Points in SymPy (Python)\nDESCRIPTION: Illustrates a limitation of the SymPy geometry module when dealing with symbolic coordinates. It creates three Point objects (`p1`, `p2`, `p3`) with symbolic coordinates (`x`, `y`, `z`). When `Point.is_collinear` is called on these points, it returns `False`. This highlights that the current implementation might not simplify symbolic expressions sufficiently to determine collinearity, even if the points could be collinear under specific conditions (e.g., if `z - y - 2*y*z + 2*y**2 == 0`). This suggests an area for future improvement.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/geometry/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.geometry import *\n>>> x,y,z = map(Symbol, 'xyz')\n>>> p1,p2,p3 = Point(x, y), Point(y, z), Point(2*x*y, y)\n>>> Point.is_collinear(p1, p2, p3)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Creating a Linear Pathway in SymPy Mechanics\nDESCRIPTION: Demonstrates the use of LinearPathway to establish a line of action between two points. The example calculates the length between points and extension velocity, showing how the pathway handles both positive and negative coordinate values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> lpathway = me.LinearPathway(O, P)\n>>> lpathway\nLinearPathway(O, P)\n>>> lpathway.length\nAbs(x(t))\n>>> lpathway.extension_velocity\nsign(x(t))*Derivative(x(t), t)\n```\n\n----------------------------------------\n\nTITLE: Documenting SymPy Functions with LaTeX and Code\nDESCRIPTION: Demonstrates how to document a SymPy function using a combination of LaTeX math and code formatting in the docstring.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/documentation-style-guide.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nclass loggamma(Function):\n    r\"\"\"\n    The ``loggamma`` function implements the logarithm of the gamma\n    function (i.e, $\\log\\Gamma(x)$).\n\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Checking Object Class in SymPy\nDESCRIPTION: Demonstrates how to determine the class of a SymPy expression using Python's built-in type() function and checking class membership with isinstance(). This example creates an addition expression and checks its type.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Add\n>>> from sympy.abc import x,y\n>>> type(x + y)\n<class 'sympy.core.add.Add'>\n>>> isinstance(x + y, Add)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Autogenerating Documentation for the DimensionSystem Class\nDESCRIPTION: This Sphinx directive (`autoclass`) instructs Sphinx to automatically generate documentation for the `DimensionSystem` class, similar to the `Dimension` class directive. It resides within the module context (likely `sympy.physics.units.dimensions`). The `:members:` option ensures that documentation for the public members of the `DimensionSystem` class is included.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/dimensions.rst#2025-04-22_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: DimensionSystem\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Explicitly Specifying the Variable to Solve For in SymPy\nDESCRIPTION: These examples show the importance of explicitly specifying which variable to solve for in multi-variable equations, ensuring SymPy solves for the desired variable.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x, y\n>>> from sympy import solve\n>>> solve(x**2 - y, dict=True)\n[{y: x**2}]\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x, y\n>>> from sympy import solve\n>>> solve(x**2 - y, x, dict=True)\n[{x: -sqrt(y)}, {x: sqrt(y)}]\n```\n\n----------------------------------------\n\nTITLE: Defining Physical Constants and Parameters\nDESCRIPTION: Declares constant parameters for the mechanical system including lengths, masses, and physical coefficients.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndx, dy, dz = sm.symbols('dx, dy, dz', real=True, nonnegative=True)\nlA, lC, lD = sm.symbols('lA, lC, lD', real=True, positive=True)\nmA, mC, mD = sm.symbols('mA, mC, mD', real=True, positive=True)\ng, k, c, r = sm.symbols('g, k, c, r', real=True, positive=True)\n```\n\n----------------------------------------\n\nTITLE: Domain-Dependent Integer Conversion for Symmetric and Unsymmetric GF Domains - SymPy - Python\nDESCRIPTION: Illustrates conversion of modular integers to Python ints for both symmetric and unsymmetric domains. Dependencies: sympy.GF. Inputs are field elements created in both symmetric and non-symmetric modes; outputs demonstrate differences in representation. This clarifies how GF(p, symmetric=True/False) affects output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> KS = GF(5, symmetric=True)\n>>> KU = GF(5, symmetric=False)\n>>> [KS.to_int(KS(n)) for n in range(10)]\n[0, 1, 2, -2, -1, 0, 1, 2, -2, -1]\n>>> [KU.to_int(KU(n)) for n in range(10)]\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n>>> [int(KS(n)) for n in range(10)]\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n>>> [int(KU(n)) for n in range(10)]\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Calculating Intersection of Triangle Medians Symbolically in Python\nDESCRIPTION: Illustrates using symbolic variables with the SymPy geometry module. It defines two positive symbols 'a' and 'b', creates Point objects with coordinates involving these symbols, forms a Triangle using these points, calculates its symbolic area, retrieves a specific median (as a Segment), and finds the intersection point of all three medians symbolically using the `intersection` function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/geometry/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.geometry import Point, Triangle, intersection\n\n>>> a, b = symbols(\"a,b\", positive=True)\n\n>>> x = Point(0, 0)\n>>> y = Point(a, 0)\n>>> z = Point(2*a, b)\n>>> t = Triangle(x, y, z)\n\n>>> t.area\na*b/2\n\n>>> t.medians[x]\nSegment2D(Point2D(0, 0), Point2D(3*a/2, b/2))\n\n>>> intersection(t.medians[x], t.medians[y], t.medians[z])\n[Point2D(a, b/3)]\n```\n\n----------------------------------------\n\nTITLE: Unifying Domains in Python using SymPy\nDESCRIPTION: Demonstrates how to use the unify method to find a common domain that can represent elements from two different domains, and how to convert elements to the unified domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> x1, K1 = ZZ(2), ZZ\n>>> y2, K2 = QQ(3, 2), QQ\n>>> K1\nZZ\n>>> K2\nQQ\n>>> K3 = K1.unify(K2)\n>>> K3\nQQ\n>>> x3 = K3.convert_from(x1, K1)\n>>> y3 = K3.convert_from(y2, K2)\n>>> x3 + y3\n7/2\n```\n\n----------------------------------------\n\nTITLE: Optimized Symbolic Boolean Implementation Using And Operation\nDESCRIPTION: Final optimized version that uses SymPy's And operation to handle all cases automatically with proper simplification.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef both_positive_best(a, b):\n    \"\"\"ask whether a and b are both positive\"\"\"\n    return And(a > 0, b > 0)\n```\n\n----------------------------------------\n\nTITLE: Setting Velocities and Accelerations in SymPy\nDESCRIPTION: Shows how to set and retrieve velocities and accelerations of points in SymPy. This includes linear and angular velocities and accelerations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nO.set_vel(N, u1*N.x + u2*N.y)\n```\n\nLANGUAGE: python\nCODE:\n```\nO.partial_velocity(N, u3)\n```\n\nLANGUAGE: python\nCODE:\n```\nO.set_acc(N, 0)\n```\n\nLANGUAGE: python\nCODE:\n```\nB.set_ang_vel(N, qBd*Bf.z)\n```\n\nLANGUAGE: python\nCODE:\n```\nB.set_ang_acc(N, diff(B.ang_vel_in(N)))\n```\n\n----------------------------------------\n\nTITLE: Documenting Partition Class in reStructuredText\nDESCRIPTION: Autoclass directive for the Partition class, which is part of the sympy.combinatorics.partitions module. It includes all members of the class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: Partition\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Using the func Attribute for Expression Tree Traversal\nDESCRIPTION: Demonstrates the func attribute which provides the head of a SymPy object, used for recursing over expression trees. The examples show how func can return different objects depending on expression simplification.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> Add(x + y).func\n<class 'sympy.core.add.Add'>\n>>> Add(x + x).func\n<class 'sympy.core.mul.Mul'>\n>>> Q.even(x).func\n<class 'sympy.assumptions.assume.AppliedPredicate'>\n```\n\n----------------------------------------\n\nTITLE: Testing ODE and Force Functions\nDESCRIPTION: Demonstrates the use of the numerical ODE and force evaluation functions with the specified parameters, initial state, and excitation inputs.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\neval_eom(x_vals, r_vals, p_vals)\n(0.0, 7.817106179880225, 92.30769105034035)\neval_force(x_vals, p_vals)\n-0.9964469100598874\n```\n\n----------------------------------------\n\nTITLE: Initializing Lagrange's Method Pendulum Setup\nDESCRIPTION: Sets up the initial dynamicsymbols and system parameters for modeling a pendulum using Lagrange's method. Creates generalized coordinates q1,q2 representing x,y positions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/lin_pend_nonmin_example.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import *\nfrom sympy import symbols, atan, Matrix\nq1, q2 = dynamicsymbols('q1:3')\nq1d, q2d = dynamicsymbols('q1:3', level=1)\nL, m, g, t = symbols('L, m, g, t')\n```\n\n----------------------------------------\n\nTITLE: Optional Git Configuration Settings\nDESCRIPTION: Example of a Git configuration file with helpful aliases and user information.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n[user]\n    name = Firstname Lastname\n    email = your_email@youremail.com\n\n# Some helpful aliases to save on typing\n[alias]\n    ci = commit\n    di = diff --color-words\n    st = status\n    co = checkout\n    log1 = log --pretty=oneline --abbrev-commit\n    logs = log --stat\n```\n\n----------------------------------------\n\nTITLE: Example 2: Overhanging Beam Analysis\nDESCRIPTION: Analyzes an overhanging beam with distributed and point loads. Includes calculations for loads, shear force, bending moment, slope and deflection.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.continuum_mechanics.beam import Beam\nfrom sympy import symbols\nE,I,M,V = symbols('E I M V')\nb = Beam(8, E, I)\nE,I,R1,R2 = symbols('E I R1 R2')\nb.apply_load(R1, 1, -1)\nb.apply_load(R2, 7, -1)\nb.apply_load(10, 0, 0, end=2)\nb.apply_load(20, 5, -1)\nb.apply_load(8, 7.5, -1)\nb.solve_for_reaction_loads(R1, R2)\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Deprecated Behaviors in Python\nDESCRIPTION: Example demonstrating how to test multiple deprecated behaviors separately using multiple warns_deprecated_sympy context blocks to ensure each emits its own warning.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwith warns_deprecated_sympy():\n    <deprecated behavior1>\nwith warns_deprecated_sympy():\n    <deprecated behavior2>\n```\n\n----------------------------------------\n\nTITLE: Importing codegen Function from SymPy\nDESCRIPTION: Shows how to import the codegen function from the sympy.utilities.codegen module. This import is required since codegen is not included in the main sympy namespace.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/codegen.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.utilities.codegen import codegen\n```\n\n----------------------------------------\n\nTITLE: Implementing expand() for Versine Function in SymPy\nDESCRIPTION: Implementation of _eval_expand_trig method for the versine function to enable trigonometric expansion via the expand() function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_32\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import expand_trig\ny = symbols('y')\nclass versin(Function):\n   def _eval_expand_trig(self, **hints):\n       x = self.args[0]\n       return expand_trig(1 - cos(x))\n```\n\n----------------------------------------\n\nTITLE: Using Unicode Pretty Printer in SymPy\nDESCRIPTION: Shows how to use pprint() with Unicode characters for pretty printing SymPy expressions in terminals that support Unicode.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npprint(Integral(sqrt(1/x), x), use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Writing Regression Tests for SymPy in Python\nDESCRIPTION: These code snippets demonstrate how to write regression tests for SymPy. They include tests for the tangent function's leading term and expressions involving complex numbers, addressing specific GitHub issues.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef test_tan():\n    ...\n    # https://github.com/sympy/sympy/issues/21177\n    f = tan(pi*(x + S(3)/2))/(3*x)\n    assert f.as_leading_term(x) == -1/(3*pi*x**2)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef test_as_leading_term():\n    ...\n    # https://github.com/sympy/sympy/issues/21177\n    f = -3*x + (x + Rational(3, 2) - sqrt(3)*S.ImaginaryUnit/2)**2\\\n        - Rational(3, 2) + 3*sqrt(3)*S.ImaginaryUnit/2\n    assert f.as_leading_term(x) == \\\n        (3*sqrt(3)*x - 3*S.ImaginaryUnit*x)/(sqrt(3) + 3*S.ImaginaryUnit)\n\n    # https://github.com/sympy/sympy/issues/21245\n    f = 1 - x - x**2\n    fi = (1 + sqrt(5))/2\n    assert f.subs(x, y + 1/fi).as_leading_term(y) == \\\n        (-36*sqrt(5)*y - 80*y)/(16*sqrt(5) + 36)\n```\n\n----------------------------------------\n\nTITLE: Using ASCII Pretty Printer in SymPy\nDESCRIPTION: Demonstrates how to use pprint() and pretty() with ASCII characters for pretty printing SymPy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npprint(Integral(sqrt(1/x), x), use_unicode=False)\npretty(Integral(sqrt(1/x), x), use_unicode=False)\nprint(pretty(Integral(sqrt(1/x), x), use_unicode=False))\n```\n\n----------------------------------------\n\nTITLE: Basic Square Root Simplification in Python with SymPy\nDESCRIPTION: Demonstrates how sqrt(x^2) simplifies differently for concrete numbers versus symbolic variables.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import sqrt\nsqrt(2**2)\nsqrt((-2)**2)\nx = 2\nsqrt(x**2)\nsqrt(x**2) == x\ny = -2\nsqrt(y**2) == y\nsqrt(y**2) == -y\n```\n\n----------------------------------------\n\nTITLE: Alternative Sampling Methods\nDESCRIPTION: Demonstrates recommended alternatives to the deprecated numsamples parameter using list comprehension and size parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n>>> [sample(X) for i in range(3)] # doctest: +SKIP\n[5, 4, 3]\n>>> sample(X, size=(3,)) # doctest: +SKIP\narray([6, 6, 1])\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Assumptions of a Basic Subclass in Python\nDESCRIPTION: This snippet demonstrates how to access the default assumptions of a Basic subclass, showing the StdFactKB instance that stores precomputed assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> type(A.default_assumptions)\n<class 'sympy.core.assumptions.StdFactKB'>\n>>> A.default_assumptions\n{'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'negative': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'real': True,\n 'zero': False}\n```\n\n----------------------------------------\n\nTITLE: Performing Scalar Multiplication on SymPy Matrices in Python\nDESCRIPTION: Shows how to multiply a SymPy `Matrix` by a scalar value. Examples demonstrate multiplying the 3x3 identity matrix `M` by 2 and 3. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> M = eye(3)\n>>> 2*M\n[2  0  0]\n[       ]\n[0  2  0]\n[       ]\n[0  0  2]\n>>> 3*M\n[3  0  0]\n[       ]\n[0  3  0]\n[       ]\n[0  0  3]\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Numerical Data to SymPy Plots using Matplotlib in Python\nDESCRIPTION: Demonstrates how to add custom numerical data to SymPy plots by retrieving the Matplotlib figure and axes objects and using Matplotlib's API directly.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# plot symbolic expression\np = plot(cos(x))\n# retrieve Matplotlib's figure and axes object\nfig, ax = p._backend.fig, p._backend.ax[0]\n# add the desired numerical data using Matplotlib's API\nax.plot([0, 1, 2], [0, 1, -1], \"*\")\nax.axhline(0.5)\n# visualize the figure\nfig\n```\n\n----------------------------------------\n\nTITLE: Generating MathML Output in SymPy\nDESCRIPTION: Shows how to use print_mathml() and mathml() functions to generate MathML representation of SymPy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.printing.mathml import print_mathml\nprint_mathml(Integral(sqrt(1/x), x))\n```\n\n----------------------------------------\n\nTITLE: Creating Polynomials with Rational Coefficients\nDESCRIPTION: Shows how expressions with non-integer coefficients are automatically converted to appropriate domains. Division by integers leads to rational coefficients in the QQ (rational) domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> e = (3*x/2 + y)*(z - 1)\n>>> e.as_poly()\nPoly(3/2*x*z - 3/2*x + y*z - y, x, y, z, domain='QQ')\n```\n\n----------------------------------------\n\nTITLE: Using the Kind Property in SymPy\nDESCRIPTION: Demonstrates how to use the .kind property to determine what mathematical object a SymPy expression represents. This example shows the difference between number integrals and matrix integrals.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> Integral(1, x).kind\nNumberKind\n>>> Integral(A, x).kind\nMatrixKind(NumberKind)\n```\n\n----------------------------------------\n\nTITLE: Plotting Beam Properties in Python\nDESCRIPTION: This snippet shows how to plot shear force, bending moment, slope, and deflection for a beam using SymPy's plotting functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nb.plot_shear_force()  # doctest: +SKIP\nb.plot_bending_moment()  # doctest: +SKIP\nb.plot_slope(subs={E: 20E9, I: 3.25E-6})  # doctest: +SKIP\nb.plot_deflection(subs={E: 20E9, I: 3.25E-6})  # doctest: +SKIP\nb.plot_loading_results(subs={E: 20E9, I: 3.25E-6})  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Comparing Modular Integers Using Ordered Comparisons - SymPy GF Domain - Python\nDESCRIPTION: Illustrates ordered comparisons (like <) between modular integer elements using SymPy's GF domain, which was previously possible. Required dependency: sympy.GF. These comparisons are now deprecated with non-flint ground types and cause TypeError with flint. Inputs are GF elements; output was a boolean result, but usage is deprecated.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import GF\n>>> F5 = GF(5)\n>>> F5(2) < F5(3) # doctest: +SKIP\nTrue\n```\n\n----------------------------------------\n\nTITLE: Initializing Symbols and Defining Basic Functions in Python with SymPy\nDESCRIPTION: This snippet sets up the basic symbols and functions needed for working with continued fractions in SymPy. It defines variables x, y, z, k, m, and n as symbols, and introduces the factorial, binomial, gamma, and hypergeometric functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n>>> x, y, z = symbols('x y z')\n>>> k, m, n = symbols('k m n')\n\n>>> factorial(n)\nn!\n\n>>> binomial(n, k)\n⎛n⎞\n⎜ ⎟\n⎝k⎠\n\n>>> gamma(z)\nΓ(z)\n\n>>> hyper([1, 2], [3], z)\n ┌─  ⎛1, 2 │  ⎞\n ├─  ⎜     │ z⎟\n2╵ 1 ⎝ 3   │  ⎠\n```\n\n----------------------------------------\n\nTITLE: Querying Basic Assumptions in SymPy\nDESCRIPTION: Demonstrates how assumptions are initially checked and cached. Shows the transition from default assumptions to instance-specific assumptions after the first query.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\na = A()\na._assumptions is A.default_assumptions\nTrue\na.is_rational\n!!! calling _eval_is_rational\nTrue\na._assumptions is A.default_assumptions\nFalse\na._assumptions   # rational now shows as True\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'irrational': False,\n 'negative': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'rational': True,\n 'real': True,\n 'transcendental': False,\n 'zero': False}\n```\n\n----------------------------------------\n\nTITLE: Converting Symbolic Expressions to Holonomic with SymPy in Python\nDESCRIPTION: The expr_to_holonomic function is designed to convert general symbolic expressions into holonomic representations within the SymPy system. This function takes symbolic expressions as input, and outputs a corresponding holonomic object, relying on sympy.holonomic.holonomic. Inputs must be valid SymPy expressions; the output enables holonomic manipulation, assuming the expression falls into a convertible category.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/convert.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.holonomic.holonomic import expr_to_holonomic\n```\n\n----------------------------------------\n\nTITLE: Formatting Math Expressions in SymPy Documentation\nDESCRIPTION: Demonstrates how to format mathematical expressions using LaTeX syntax within SymPy documentation. Math should be enclosed in dollar signs for proper rendering.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/documentation-style-guide.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nThe Bessel $J$ function of order $\\nu$ is defined to be the function\nsatisfying Bessel's differential equation.\n```\n\n----------------------------------------\n\nTITLE: Creating and Operating with Polynomial Ring Domain\nDESCRIPTION: Demonstrates creating a polynomial ring domain ZZ[x] and performing basic operations like addition, subtraction, multiplication and exponentiation with polynomial elements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ZZ, symbols\n>>> x = symbols('x')\n>>> K = ZZ[x]\n>>> K\nZZ[x]\n>>> x_dom = K(x)\n>>> x_dom + K.one\nx + 1\n>>> p = x_dom + K.one\n>>> p + p\n2*x + 2\n>>> p - p\n0\n>>> p * p\nx**2 + 2*x + 1\n>>> p ** 3\nx**3 + 3*x**2 + 3*x + 1\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for SymPy Hydrogen Module (RST)\nDESCRIPTION: This ReStructuredText snippet uses the Sphinx `automodule` directive to automatically generate documentation for the Python module `sympy.physics.hydrogen`. The `:members:` option ensures that documentation for all public members (functions, classes, variables) defined within that module is included. This directive relies on the Sphinx documentation generator and its `autodoc` extension being correctly set up, as well as the availability of the specified Python module in the environment.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/hydrogen.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.hydrogen\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Using parse_expr for String Parsing in SymPy\nDESCRIPTION: Demonstrates the correct way to handle string inputs when necessary using parse_expr function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import parse_expr\n>>> string_input = \"(x**2 + x)/x\"\n>>> expr = parse_expr(string_input)\n>>> expand(expr)\nx + 1\n```\n\n----------------------------------------\n\nTITLE: Creating RigidBody and Particle Instead of Deprecated Body Class\nDESCRIPTION: Example of how to replace the deprecated Body class from sympy.physics.mechanics with the recommended RigidBody and Particle classes. These classes provide more specialized and accurate representations than the general Body class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import RigidBody, Particle\n>>> RigidBody(\"rigid_body\")\nrigid_body\n>>> Particle(\"particle\")\nparticle\n```\n\n----------------------------------------\n\nTITLE: Proper Test Using Symbolic Fractions\nDESCRIPTION: Example showing the preferred way to write tests with fractions, using SymPy's S() wrapper to ensure exact arithmetic.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# GOOD\nassert expand((x + S(1)/2)**2) == x**2 + x + S(1)/4\n```\n\n----------------------------------------\n\nTITLE: Working with Symbolic Matrices\nDESCRIPTION: Demonstrates working with fully symbolic matrices using MatrixSymbol and computing their determinants, which can be computationally intensive as dimension increases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import MatrixSymbol\n>>> A = MatrixSymbol('A', 4, 4).as_explicit()\n>>> A\n⎡A₀₀  A₀₁  A₀₂  A₀₃⎤\n⎢                  ⎥\n⎢A₁₀  A₁₁  A₁₂  A₁₃⎥\n⎢                  ⎥\n⎢A₂₀  A₂₁  A₂₂  A₂₃⎥\n⎢                  ⎥\n⎣A₃₀  A₃₁  A₃₂  A₃₃⎦\n>>> A.det()\nA₀₀⋅A₁₁⋅A₂₂⋅A₃₃ - A₀₀⋅A₁₁⋅A₂₃⋅A₃₂ - A₀₀⋅A₁₂⋅A₂₁⋅A₃₃ + A₀₀⋅A₁₂⋅A₂₃⋅A₃₁ +\nA₀₀⋅A₁₃⋅A₂₁⋅A₃₂ - A₀₀⋅A₁₃⋅A₂₂⋅A₃₁ - A₀₁⋅A₁₀⋅A₂₂⋅A₃₃ + A₀₁⋅A₁₀⋅A₂₃⋅A₃₂ +\nA₀₁⋅A₁₂⋅A₂₀⋅A₃₃ - A₀₁⋅A₁₂⋅A₂₃⋅A₃₀ - A₀₁⋅A₁₃⋅A₂₀⋅A₃₂ + A₀₁⋅A₁₃⋅A₂₂⋅A₃₀ +\nA₀₂⋅A₁₀⋅A₂₁⋅A₃₃ - A₀₂⋅A₁₀⋅A₂₃⋅A₃₁ - A₀₂⋅A₁₁⋅A₂₀⋅A₃₃ + A₀₂⋅A₁₁⋅A₂₃⋅A₃₀ +\nA₀₂⋅A₁₃⋅A₂₀⋅A₃₁ - A₀₂⋅A₁₃⋅A₂₁⋅A₃₀ - A₀₃⋅A₁₀⋅A₂₁⋅A₃₂ + A₀₃⋅A₁₀⋅A₂₂⋅A₃₁ +\nA₀₃⋅A₁₁⋅A₂₀⋅A₃₂ - A₀₃⋅A₁₁⋅A₂₂⋅A₃₀ - A₀₃⋅A₁₂⋅A₂₀⋅A₃₁ + A₀₃⋅A₁₂⋅A₂₁⋅A₃₀\n```\n\n----------------------------------------\n\nTITLE: Defining Reference Frames and Points in SymPy Mechanics\nDESCRIPTION: This snippet sets up the reference frames and points for the Duffing oscillator and pendulum system, including their positions and velocities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/duffing-example.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nN = me.ReferenceFrame('N')\nB = N.orientnew('B', 'axis', (q2, N.z))\nO = me.Point('O')\nblock_point = O.locatenew('block', q1 * N.y)\npendulum_point = block_point.locatenew('pendulum', l * B.y)\nO.set_vel(N, 0)\nblock_point.set_vel(N, q1d * N.y)\npendulum_point.v2pt_theory(block_point, N, B)\n```\n\n----------------------------------------\n\nTITLE: Installing mpmath dependency\nDESCRIPTION: These commands show how to install mpmath, a dependency of SymPy, using pip or conda.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npip install mpmath\n```\n\nLANGUAGE: bash\nCODE:\n```\nconda install mpmath\n```\n\n----------------------------------------\n\nTITLE: Querying Assumptions in SymPy\nDESCRIPTION: Demonstrates how to query assumptions on symbols and expressions using is_* attributes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x', positive=True)\nx.is_positive\nexpr = 1 + x**2\nexpr.is_positive\nexpr.is_negative\n```\n\n----------------------------------------\n\nTITLE: Finding Polynomial Roots using solve() without Multiplicities in SymPy\nDESCRIPTION: Using SymPy's solve() function to find roots of polynomials without returning their multiplicities. Works with both concrete and symbolic expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> solve(expression, x, dict=True)\n[{x: -2}, {x: 3}]\n>>> solve(symbolic, x, dict=True)\n[{x: -a}, {x: b}]\n```\n\n----------------------------------------\n\nTITLE: Extracting Solutions Using Dictionary Mapping\nDESCRIPTION: Shows how to extract individual variable expressions from the solution set using a dictionary mapping approach.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> a, b, c = symbols(\"a, b, c\", integer=True)\n>>> my_syms = (a, b, c)\n>>> pythag = a**2 + b**2 - c**2\n>>> solution, = diophantine(pythag, syms=my_syms)\n>>> solution_dict = dict(zip(my_syms, solution))\n>>> solution_dict[a]\n2*p*q\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Plot Elements using Deprecated Attribute Setting in Python\nDESCRIPTION: Shows the deprecated way of adding custom plot elements by setting attributes on the plot object in SymPy. This method will raise warnings and should be avoided.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\np = plot(x, show=False)\np.markers = [{\"args\":[[0, 1], [0, 1]], \"marker\": \"*\", \"linestyle\": \"none\"}]\np.annotations = [{\"text\": \"test\", \"xy\": (0, 0)}]\np.fill = {\"x\": [0, 1, 2, 3], \"y1\": [0, 1, 2, 3]}\np.rectangles = [{\"xy\": (0, 0), \"width\": 5, \"height\": 1}]\np.show()\n```\n\n----------------------------------------\n\nTITLE: Defining Holonomic Functions for e^x and sin(x) in SymPy (Python)\nDESCRIPTION: This snippet creates two holonomic functions, p and q, representing e^x and sin(x), respectively, via their annihilating differential equations. It requires initialization of the differential operator Dx and variable x as set up in previous steps. The main parameters are the differential operators (Dx - 1 for e^x, Dx**2 + 1 for sin(x)), initial point 0, and initial conditions [1] (for e^x) and [0, 1] (for sin(x)). The output is two holonomic function instances suitable for symbolic computation and further manipulations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> p = HolonomicFunction(Dx - 1, x, 0, [1])\\n>>> q = HolonomicFunction(Dx**2 + 1, x, 0, [0, 1])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fu Function's Selective Factoring\nDESCRIPTION: Shows how fu doesn't factor expressions if it doesn't help with trigonometric simplification, preserving the original form when appropriate.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> fu(a*cos(x)*cos(y) + a*sin(x)*sin(z))\na*sin(x)*sin(z) + a*cos(x)*cos(y)\n```\n\n----------------------------------------\n\nTITLE: Representing Complex Roots using RootOf in SymPy\nDESCRIPTION: Shows how to represent roots (including complex ones) using SymPy's `RootOf` object. Each `RootOf(expression, index)` represents a specific root. Note that multiple indices might point to the same root value if there are multiplicities, as seen here for the root -2*I.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> [RootOf(expression_complex, n) for n in range(0,3)]\n[3, -2*I, -2*I]\n```\n\n----------------------------------------\n\nTITLE: Using rs_sin Function with Real Domain in SymPy\nDESCRIPTION: Example showing how to use the rs_sin function with a Real domain. The example creates a polynomial ring with real coefficients and variables x and y, then computes the sine series of x*y up to order 5 in x.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> R, x, y = ring('x, y', RR)\n>>> rs_sin(x*y, x, 5)\n-0.166666666666667*x**3*y**3 + x*y\n```\n\n----------------------------------------\n\nTITLE: Specifying ANTLR Runtime Installation via pip - reStructuredText\nDESCRIPTION: This snippet provides a shell command for installing the necessary Python runtime dependency (antlr4) required for the ANTLR-based LaTeX parser in SymPy. The command uses pip to install a specific version of antlr4-python3-runtime, which must match the parser's expectations. Users must ensure they have pip available.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/parsing.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n\"    $ pip install antlr4-python3-runtime==4.11\\n\"\n```\n\n----------------------------------------\n\nTITLE: Extracting the Solution from dsolve Results\nDESCRIPTION: Shows how to extract the right-hand side of the solution equation returned by dsolve using the rhs property of the Equality object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, dsolve, Derivative\n>>> from sympy.abc import x\n>>> y = Function('y')\n>>> result = dsolve(Derivative(y(x), x, x) + 9*y(x), y(x))\n>>> result\nEq(y(x), C1*sin(3*x) + C2*cos(3*x))\n>>> result.rhs\nC1*sin(3*x) + C2*cos(3*x)\n```\n\n----------------------------------------\n\nTITLE: Handling Tracebacks in Doctests (Python)\nDESCRIPTION: Demonstrates the convention for representing expected tracebacks in doctests. The intermediate lines between `Traceback (most recent call last):` and the final error message should be replaced with `...`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Integer\n>>> Integer('a')\nTraceback (most recent call last):\n...\nValueError: invalid literal for int() with base 10: 'a'\n```\n\n----------------------------------------\n\nTITLE: Enabling Pretty Printing in Interactive Sessions - SymPy - Python\nDESCRIPTION: Illustrates enabling specialized pretty printing for dynamic symbols in an interactive console using the init_vprinting function. Demonstrates effect on output display for both dynamic symbols and their derivatives. Requires sympy.physics.vector and a session where init_vprinting can be called.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.vector import init_vprinting\\n>>> init_vprinting(pretty_print=False)\\n>>> q1\\nq1\\n>>> q1d\\nq1'\n```\n\n----------------------------------------\n\nTITLE: Computing Derivatives of Hypergeometric Function in SymPy\nDESCRIPTION: This snippet demonstrates how to compute derivatives of a hypergeometric function expression using SymPy. It calculates the first derivative of B0 with respect to z using the operator z*d/dz.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/hyperexpand.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Symbol, sqrt, exp, I, pi, fresnelc, root, diff, expand\nz = Symbol(\"z\")\nB0 = sqrt(pi)*exp(-I*pi/4)*fresnelc(2*root(z,4)*exp(I*pi/4)/sqrt(pi))/\\\n         (2*root(z,4))\nz * diff(B0, z)\nexpand(_)\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy on Fedora-based Linux systems\nDESCRIPTION: This command installs SymPy using the dnf package manager on Fedora-based Linux distributions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndnf install sympy\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for SymPy Vector Orienters\nDESCRIPTION: ReStructuredText documentation defining the class structure and member documentation for various orienter classes in the SymPy vector package. Includes autoclass and automethod directives for class and constructor documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/api/orienterclasses.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=============================\nOrienter classes (docstrings)\n=============================\n\n.. autoclass:: sympy.vector.orienters.Orienter\n   :members:\n\n.. autoclass:: sympy.vector.orienters.AxisOrienter\n   :members:\n\n   .. automethod:: sympy.vector.orienters.AxisOrienter.__init__\n\n.. autoclass:: sympy.vector.orienters.BodyOrienter\n   :members:\n\n   .. automethod:: sympy.vector.orienters.BodyOrienter.__init__\n\n.. autoclass:: sympy.vector.orienters.SpaceOrienter\n   :members:\n\n   .. automethod:: sympy.vector.orienters.SpaceOrienter.__init__\n\n.. autoclass:: sympy.vector.orienters.QuaternionOrienter\n   :members:\n\n   .. automethod:: sympy.vector.orienters.QuaternionOrienter.__init__\n```\n\n----------------------------------------\n\nTITLE: Polynomial Expansion Operations\nDESCRIPTION: Shows how to expand polynomial expressions using the expand() function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nexpand((x + 1)**2)\nexpand((x + 2)*(x - 3))\nexpand((x + 1)*(x - 2) - (x - 1)*x)\n```\n\n----------------------------------------\n\nTITLE: Using Ellipsis (...) for Variable Output (Python)\nDESCRIPTION: Shows how to use the ellipsis `...` in the expected output of a doctest to match parts that vary between runs, such as memory addresses in function representations. This allows the doctest to pass consistently while indicating that part of the output is variable.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import simplify\n>>> simplify\n<function simplify at ...>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reference Frames and Points\nDESCRIPTION: Establishes reference frames and key points for the biomechanical model including mass centers and joint locations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nN, A, B, C, D = sm.symbols('N, A, B, C, D', cls=me.ReferenceFrame)\nO, P1, P2, P3, P4 = sm.symbols('O, P1, P2, P3, P4 ', cls=me.Point)\nAo, Co, Cm, Dm, Do = sm.symbols('Ao, Co, Cm, Dm, Do', cls=me.Point)\n```\n\n----------------------------------------\n\nTITLE: Defining Scalar and Vector Fields in Python\nDESCRIPTION: This snippet illustrates how scalar and vector fields might be represented in Python. It includes examples of a temperature field (scalar) and a gravitational field (vector).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/intro.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Scalar field (temperature)\ndef T(x, y, z):\n    return f(x, y, z)  # Some function of x, y, z\n\n# Vector field (gravitational acceleration)\ndef g(x, y, z):\n    return Vector(gx(x,y,z), gy(x,y,z), gz(x,y,z))  # Vector function of x, y, z\n```\n\n----------------------------------------\n\nTITLE: Multiplying Two Holonomic Functions in SymPy (Python)\nDESCRIPTION: This snippet computes the product of two holonomic functions, p and q, generating the holonomic function representing e^x * sin(x). Prerequisites are prior definition of p and q as HolonomicFunction instances. The multiplication is handled symbolically, and it outputs a new HolonomicFunction whose operator and initial conditions encode the product.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> p * q\\nHolonomicFunction((2) + (-2)*Dx + (1)*Dx**2, x, 0, [0, 1])\n```\n\n----------------------------------------\n\nTITLE: Declaring Default Module for Sympy Sparse Matrices Documentation (reStructuredText)\nDESCRIPTION: This Sphinx directive sets the default Python module context to `sympy.matrices.sparse` for subsequent documentation generation directives like `autoclass` within this reStructuredText file. It helps Sphinx locate the specified classes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparse.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. module:: sympy.matrices.sparse\n```\n\n----------------------------------------\n\nTITLE: Using 'divides' Function with Symbolic and Uncertain Inputs (Python)\nDESCRIPTION: Demonstrates calling the custom `divides` function with symbolic arguments. First, it shows that `divides(2, (m**2 + m)/2)` remains symbolic because `(m**2 + m)/2` has an `is_integer` value of `None`. Substitution (`subs`) works correctly. Second, it shows that calling `divides` with generic symbols `m` and `n` (without integer assumptions) also returns a symbolic expression, as the `is_integer` properties are `None`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> # Assuming m is still integer=True from previous snippets\n>>> divides(2, (m**2 + m)/2)\ndivides(2, m**2/2 + m/2)\n>>> _.subs(m, 2) # Substitute m=2, (2**2+2)/2 = 3. divides(2, 3) -> 0\n0\n>>> n, m = symbols('n m') # Redefine n and m without the integer assumption\n>>> divides(m, n)\ndivides(m, n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Multiplying SymPy Symbols and Vectors - Python\nDESCRIPTION: Demonstrates how to create SymPy symbols and multiply them by vector basis components using SymPy's Symbol object. Also shows distributive property of symbols over vectors. Requires the sympy module and a defined reference frame 'N'. Inputs are symbols and vector basis vectors; outputs are symbolic vector expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, symbols\\n>>> x = Symbol('x')\\n>>> x * N.x\\nx*N.x\\n>>> x*(N.x + N.y)\\nx*N.x + x*N.y\n```\n\n----------------------------------------\n\nTITLE: Providing API Documentation for Lie Algebra Structures using Sphinx (reStructuredText)\nDESCRIPTION: This reStructuredText snippet uses Sphinx autodoc directives (.. automodule::, .. autoclass::, .. autofunction::) to generate documentation for the key classes and functions in the sympy.liealgebras package. Dependencies include Sphinx with autodoc enabled and access to the sympy.liealgebras Python modules. The snippets list root systems, Lie algebra types (A, B, C, D, E, F, G), Weyl groups, Cartan types, Cartan matrices, and Dynkin diagram functions for documentation; no input/output is needed as this is purely for generating docs. Limitation: Requires correct Sphinx setup and assumes Python API signatures are available for autodocumentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/liealgebras/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _lie-algebras:\n\n===========\nLie Algebra\n===========\n\n.. automodule:: sympy.liealgebras\n\n.. autoclass:: sympy.liealgebras.root_system.RootSystem\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_a.TypeA\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_b.TypeB\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_c.TypeC\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_d.TypeD\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_e.TypeE\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_f.TypeF\n   :members:\n\n.. autoclass:: sympy.liealgebras.type_g.TypeG\n   :members:\n\n.. autoclass:: sympy.liealgebras.weyl_group.WeylGroup\n   :members:\n\n.. autoclass:: sympy.liealgebras.cartan_type.CartanType_generator\n   :members:\n\n.. autoclass:: sympy.liealgebras.cartan_type.Standard_Cartan\n   :members:\n\n.. autofunction:: sympy.liealgebras.dynkin_diagram.DynkinDiagram\n\n.. autofunction:: sympy.liealgebras.cartan_matrix.CartanMatrix\n\n```\n\n----------------------------------------\n\nTITLE: Implementing versin Function Evaluation in Python\nDESCRIPTION: Demonstrates how to create a custom versin function that automatically evaluates for integer multiples of pi. Uses the @classmethod decorator and implements eval() to handle special cases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import pi, Integer\n>>> class versin(Function):\n...    @classmethod\n...    def eval(cls, x):\n...        # If x is an integer multiple of pi, x/pi will cancel and be an Integer\n...        n = x/pi\n...        if isinstance(n, Integer):\n...            return 1 - (-1)**n\n```\n\n----------------------------------------\n\nTITLE: Defining Bodies and Initializing System for Multi-DOF Holonomic System in Python\nDESCRIPTION: This code defines the rigid bodies and particles in the system, and initializes the System object. It sets up the wall, block, compound pendulum, and simple pendulum with their respective properties.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/multi_degree_freedom_holonomic_system.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nwall = RigidBody('N')\nblock = Particle('A', mass=ma)\ncompound_pend = RigidBody('B', mass=mb)\ncompound_pend.central_inertia = inertia(compound_pend.frame, 0, 0, IBzz)\nsimple_pend = Particle('C', mass=mc)\nsystem = System.from_newtonian(wall)\nsystem.add_bodies(block, compound_pend, simple_pend)\n```\n\n----------------------------------------\n\nTITLE: Running Local Live Server for Auto-Rebuilding Documentation\nDESCRIPTION: Commands to start a live server locally that monitors document changes, rebuilds automatically, and reloads the browser. This is an alternative to the Docker approach.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd doc\n\nmake livehtml\n```\n\n----------------------------------------\n\nTITLE: Using ModularInteger.to_int() and Alternatives - SymPy GF Domains - Python\nDESCRIPTION: Demonstrates creation of modular integer elements in SymPy GF domain and the usage of the deprecated .to_int() method. Dependencies include sympy.GF. This method is deprecated in favor of domain-based methods such as K.to_int(a) or using int(a). The snippet showcases the typical instantiation and conversion process.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import GF\n>>> K = GF(5)\n>>> a = K(7)\n>>> a # doctest: +SKIP\n2 mod 5\n```\n\n----------------------------------------\n\nTITLE: Creating Muscle Force Evaluation Function\nDESCRIPTION: Creates a numerical function to evaluate muscle force by replacing the derivative of position with velocity and using SymPy's lambdify to convert the symbolic expression to a numerical function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nforce = muscle.force.xreplace({q.diff(): u})\neval_force = sm.lambdify((state, constants), force)\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Assumptions for Custom 'versin' Function (Python)\nDESCRIPTION: Defines a custom `versin(x)` function (`1 - cos(x)`) and implements dynamic assumption handlers `_eval_is_nonnegative` and `_eval_is_positive`. These methods determine the function's properties based on the properties of its argument `x`, accessed via `self.args[0]`. It uses `x.is_real`, `x.as_independent(pi)` to check the structure, and `fuzzy_and`/`fuzzy_not` for correct three-valued logic handling (`True`, `False`, `None`).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, pi, symbols\n>>> from sympy.core.logic import fuzzy_and, fuzzy_not\n>>> class versin(Function):\n...     # Assumes standard Function setup; eval, etc. might be defined elsewhere\n...     def _eval_is_nonnegative(self):\n...         # versin(x) is nonnegative if x is real\n...         x = self.args[0]\n...         if x.is_real is True:\n...             return True\n...         # Returns None otherwise implicitly\n...\n...     def _eval_is_positive(self):\n...         # versin(x) is positive if x is real and not an even multiple of pi\n...         x = self.args[0]\n...\n...         # x.as_independent(pi, as_Add=False) will split x as a Mul of the\n...         # form coeff*pi\n...         coeff, pi_ = x.as_independent(pi, as_Add=False)\n...         # If pi_ = pi, x = coeff*pi. Otherwise x is not (structurally) of\n...         # the form coeff*pi.\n...         if pi_ == pi:\n...             # Check if coeff is even using fuzzy logic\n...             return fuzzy_and([x.is_real, fuzzy_not(coeff.is_even)])\n...         elif x.is_real is False:\n...             # If x is definitely not real, versin(x) might be non-positive\n...             # Returning False might be too strong, None might be safer depending on definition.\n...             # The example code returns False here, assuming complex cases are not positive.\n...             return False \n...         # else: return None. We do not know for sure whether x is an even\n...         # multiple of pi or if x is real.\n...         # Returns None implicitly\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber Force-Velocity Curve in SymPy\nDESCRIPTION: This snippet shows the implementation of the fiber force-velocity curve using SymPy symbols and the FiberForceVelocityDeGroote2016 class. It demonstrates both manual equation creation and use of the pre-defined class with custom and default parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\n>>> v_M_tilde = me.dynamicsymbols('v_M_tilde')\n>>> c0, c1, c2, c3 = sm.symbols('c0, c1, c2, c3')\n\n>>> fv_M = c0*sm.log(c1*v_M_tilde + c2 + sm.sqrt((c1*v_M_tilde + c2)**2 + 1)) + c3\n>>> fv_M\nc0*log(c1*v_M_tilde(t) + c2 + sqrt((c1*v_M_tilde(t) + c2)**2 + 1)) + c3\n\n>>> v_M = me.dynamicsymbols('v_M')\n>>> v_M_max = sm.symbols('v_M_max')\n\n>>> fv_M_pas2 = c0*sm.log(c1*v_M/v_M_max + c2 + sm.sqrt((c1*v_M/v_M_max + c2)**2 + 1)) + c3\n>>> fv_M_pas2\nc0*log(c1*v_M(t)/v_M_max + c2 + sqrt((c1*v_M(t)/v_M_max + c2)**2 + 1)) + c3\n\n>>> from sympy.physics.biomechanics import FiberForceVelocityDeGroote2016\n\n>>> fv_M2 = FiberForceVelocityDeGroote2016(v_M/v_M_max, c0, c1, c2, c3)\n>>> fv_M2\nFiberForceVelocityDeGroote2016(v_M(t)/v_M_max, c0, c1, c2, c3)\n>>> fv_M2.doit()\nc0*log(c1*v_M(t)/v_M_max + c2 + sqrt((c1*v_M(t)/v_M_max + c2)**2 + 1)) + c3\n\n>>> fv_M3 = FiberForceVelocityDeGroote2016.with_defaults(v_M/v_M_max)\n>>> fv_M3\nFiberForceVelocityDeGroote2016(v_M(t)/v_M_max, -0.318, -8.149, -0.374, 0.886)\n>>> fv_M3.doit()\n0.886 - 0.318*log(8.149*sqrt((-0.0458952018652595 - v_M(t)/v_M_max)**2 + 0.0150588346410601) - 0.374 - 8.149*v_M(t)/v_M_max)\n```\n\n----------------------------------------\n\nTITLE: Old Joint Position Specification\nDESCRIPTION: Example showing the deprecated way of specifying joint attachment points using parent_joint_pos and child_joint_pos arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import PinJoint, RigidBody\nparent, child = RigidBody('parent'), RigidBody('child')\npin = PinJoint('pin', parent, child, parent_joint_pos=parent.frame.x,\n               child_joint_pos=-child.frame.x)   # doctest: +SKIP\npin.parent_point.pos_from(parent.masscenter)   # doctest: +SKIP\npin.child_point.pos_from(child.masscenter)   # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Integer Division Float Conversion in SymPy\nDESCRIPTION: Shows how Python's default integer division behavior converts to float, affecting SymPy expressions. Using 1/2 directly results in 0.5 being added to x.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx + 1/2\n```\n\n----------------------------------------\n\nTITLE: Testing Symbolic vs Exact Equality in SymPy\nDESCRIPTION: Shows how double equals (==) tests for exact equality rather than symbolic equality. To test symbolic equality, expressions should be subtracted and simplified to check if they equal zero.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n(x + 1)**2 == x**2 + 2*x + 1\nFalse\n(x + 1)**2 == (x + 1)**2\nTrue\n```\n\n----------------------------------------\n\nTITLE: Setting up Interactive SymPy Session\nDESCRIPTION: Shows how to use init_session() to set up an interactive SymPy session with imported symbols and pretty printing.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import init_session\ninit_session() # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Handling Inconsistent Assumptions in Python\nDESCRIPTION: This snippet demonstrates that combining inconsistent predicates when creating a symbol will raise an InconsistentAssumptions error in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x', commutative=False, real=True)\n```\n\n----------------------------------------\n\nTITLE: Skipping a Doctest with # doctest:+SKIP (Python)\nDESCRIPTION: Demonstrates how to prevent a specific doctest line from being executed by adding the comment `# doctest:+SKIP` at the end of the input line. This is used sparingly, typically when a test is impossible to run reliably (e.g., due to randomness), and the output should still be manually verified. The comment is hidden in rendered HTML documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> import random\n>>> random.random()      # doctest: +SKIP\n0.6868680200532414\n```\n\n----------------------------------------\n\nTITLE: Accessing Out-of-Bounds Columns in SymPy Matrices using Slicing in Python\nDESCRIPTION: Contrasts accessing a non-existent single column element (`M[:, 10]`, which raises an `IndexError`) with slicing a non-existent column (`M[:, 10:11]`, which returns an empty matrix) and slicing up to a non-existent column (`M[:, :10]`, which returns the original matrix columns). Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> M[:, 10] # the 10-th column (not there)\nTraceback (most recent call last):\n...\nIndexError: Index out of range: a[[0, 10]]\n>>> M[:, 10:11] # the 10-th column (if there)\n[]\n>>> M[:, :10] # all columns up to the 10-th\n[1  2  3]\n[       ]\n[4  5  6]\n```\n\n----------------------------------------\n\nTITLE: Converting Inertia Dyadic to Matrix Form\nDESCRIPTION: Shows how to convert an inertia dyadic to matrix form using the to_matrix() method, which requires a reference frame to extract the measure numbers from the dyadic.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> inertia(N, 1, 2, 3, 4, 5, 6).to_matrix(N)\nMatrix([\n[1, 4, 6],\n[4, 2, 5],\n[6, 5, 3]])\n```\n\n----------------------------------------\n\nTITLE: Division Operations in SymPy Domains\nDESCRIPTION: Demonstrates division operations in ZZ and QQ domains, showing differences between field and non-field behavior.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import QQ\n>>> q1 = QQ(1, 2)\n>>> q1\n1/2\n>>> q2 = QQ(2, 3)\n>>> q2\n2/3\n>>> q1 / q2\n3/4\n>>> type(q1)  # doctest: +SKIP\n<class 'sympy.external.pythonmpq.PythonMPQ'>\n```\n\n----------------------------------------\n\nTITLE: Improved Implementation of Fuzzy-Bool Logic\nDESCRIPTION: This function shows a correct way to handle fuzzy-bool logic, properly accounting for True, False, and None cases.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> def both_positive_better(a, b):\n...     \"\"\"ask whether a and b are both positive\"\"\"\n...     if a.is_positive is False or b.is_positive is False:\n...         return False\n...     elif a.is_positive is True and b.is_positive is True:\n...         return True\n...     else:\n...         return None\n```\n\n----------------------------------------\n\nTITLE: System Solution for Finite Differences\nDESCRIPTION: Solves the system of equations for finite differences by constructing and inverting matrices.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nM = Matrix([[m11, m12, m13], [m21, m22, m23], [m31, m32, m33]])\n# matrix of the function values...actually a vector of right hand sides\nR = Matrix([[FN], [FNm1], [FNm2]])\nX = M.inv() * R\nprint(\"The first derivative centered at the last point on the right is:\")\nprint(together(X[1]))\n```\n\n----------------------------------------\n\nTITLE: Linearizing Kane's Equations Using Linearizer Class in Python\nDESCRIPTION: Demonstrates linearization of Kane's equations using the Linearizer class, including obtaining matrices M, A, B and evaluating at operating points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/linearize.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> linearizer = KM.to_linearizer()\n\n>>> M, A, B = linearizer.linearize()\n>>> M\nMatrix([\n[1,       0],\n[0, -L**2*m]])\n>>> A\nMatrix([\n[                 0, 1],\n[L*g*m*cos(q1(t)), 0]])\n>>> B\nMatrix(0, 0, [])\n\n>>> A, B = linearizer.linearize(A_and_B=True)\n>>> A\nMatrix([\n[                0, 1],\n[-g*cos(q1(t))/L, 0]])\n>>> B\nMatrix(0, 0, [])\n\n>>> op_point = {q1: 0, u1: 0}\n>>> A_op, B_op = linearizer.linearize(A_and_B=True, op_point=op_point)\n>>> A_op\nMatrix([\n[     0, 1],\n[-g/L, 0]])\n```\n\n----------------------------------------\n\nTITLE: Incorrect Assumptions Handler Implementation\nDESCRIPTION: Example of an incorrect implementation of an assumptions handler that could lead to infinite recursion by checking assumptions on self.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# BAD\n\nclass f(Function):\n    def _eval_is_integer(self):\n        # Quick return if self is not real (do not do this).\n        if self.is_real is False:\n            return False\n        return self.args[0].is_integer\n```\n\n----------------------------------------\n\nTITLE: Differentiation Examples for Versine Function in Python\nDESCRIPTION: Demonstrates the usage of the diff method on the versine function with various arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nversin(x).diff(x)\nversin(x**2).diff(x)\nversin(x + y).diff(x)\n```\n\n----------------------------------------\n\nTITLE: Incorrect eval() Implementation - Excessive Automatic Evaluation\nDESCRIPTION: Example demonstrating problematic automatic evaluation of trig identities in eval(). Shows how automatic expansion can lead to undesired complexity and performance issues.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Add, sin\nclass versin(Function):\n    @classmethod\n    def eval(cls, x):\n        # !! Not actually a good eval() method !!\n        if isinstance(x, Add):\n            a, b = x.as_two_terms()\n            return (versin(a)*versin(b) - versin(a) - versin(b)\n                    - sin(a)*sin(b) + 1)\n```\n\n----------------------------------------\n\nTITLE: Using Posify for Positive Assumptions\nDESCRIPTION: Shows how to use posify to replace symbols with positive versions to enable simplification.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import posify, exp\nx = Symbol('x')\nexpr = exp(sqrt(x**2))\nexpr\nposify(expr)\nexpr2, rep = posify(expr)\nexpr2\nexpr2.subs(rep)\n```\n\n----------------------------------------\n\nTITLE: Configuring Frame Orientations and Angular Velocities\nDESCRIPTION: Defines the orientations and angular velocities of the reference frames in the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nA.orient_axis(N, q1, N.z)\nB.orient_axis(N, q2, N.y)\nC.orient_axis(B, q3, B.z)\nD.orient_axis(C, q4, C.y)\nA.set_ang_vel(N, u1*N.z)\nB.set_ang_vel(N, u2*N.y)\nC.set_ang_vel(B, u3*B.z)\nD.set_ang_vel(C, u4*C.y)\n```\n\n----------------------------------------\n\nTITLE: Defining Public API in SymPy\nDESCRIPTION: Lists elements that are generally considered part of SymPy's public API, which require deprecation notices when changed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{admonition} Public API\n- Function names.\n- Keyword argument names.\n- Keyword argument default values.\n- Positional argument order.\n- Submodule names.\n- The mathematical conventions used to define a function.\n```\n```\n\n----------------------------------------\n\nTITLE: Vector Multiplication Operations\nDESCRIPTION: Shows scalar multiplication, dot product, and cross product operations in basis vector notation\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n\\alpha \\mathbf{b} = \\alpha b_x \\mathbf{\\hat{n}_x} + \\alpha b_y\\mathbf{\\hat{n}_y} + \\alpha b_z \\mathbf{\\hat{n}_z}\\\\\n\\mathbf{a} \\cdot \\mathbf{b} = a_x b_x + a_y b_y + a_z b_z\\\\\n\\mathbf{a} \\times \\mathbf{b} = \\textrm{det }\\begin{bmatrix} \\mathbf{\\hat{n}_x} & \\mathbf{\\hat{n}_y} & \\mathbf{\\hat{n}_z} \\\\ a_x & a_y & a_z \\\\ b_x & b_y & b_z \\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Defining Contact Point Velocity and Disc Properties\nDESCRIPTION: This snippet sets up the velocity of the contact point, defines the disc's center of mass, and calculates its velocity and inertia properties.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nC = Point('C')\nC.set_vel(N, u4 * L.x + u5 * cross(Y.z, L.x) + u6 * Y.z)\nDmc = C.locatenew('Dmc', r * L.z)\nvel = Dmc.v2pt_theory(C, N, R)\nI = inertia(L, m / 4 * r**2, m / 2 * r**2, m / 4 * r**2)\nkd = [dot(R.ang_vel_in(N) - w_R_N_qd, uv) for uv in L]\n```\n\n----------------------------------------\n\nTITLE: Factoring Large Semiprimes using QS in SymPy (Python)\nDESCRIPTION: This example illustrates use of the Quadratic Sieve (qs) function from sympy.ntheory to factor a semiprime integer (product of two different large primes). It calls qs with the integer and factor base bounds. The expected output is a set of the two prime factors. Requires sympy.ntheory, and the target integer should be within practical size limits for the QS algorithm (up to ~100 digits). Optional parameters set sieve interval limits for efficiency.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/ntheory.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.ntheory import qs\n>>> qs(5915587277*3267000013, 1000, 10000)\n{3267000013, 5915587277}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reference Frames, Points, and Particles for the System\nDESCRIPTION: Creates the reference frames, defines the pendulum angle, sets up the pivot point and particle position, and establishes velocity relationships for the physical representation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntheta = atan(x/y)\nomega = dynamicsymbols('omega')\nN = ReferenceFrame('N')\nA = N.orientnew('A', 'Axis', [theta, N.z])\nA.set_ang_vel(N, omega * N.z)\nO = Point('O')\nO.set_vel(N, 0)\nP = O.locatenew('P', l * A.x)\nP.v2pt_theory(O, N, A)\nl*omega*A.y\nPa = Particle('Pa', P, m)\n```\n\n----------------------------------------\n\nTITLE: Deprecation Warning in Sphinx Format\nDESCRIPTION: Shows how to format a deprecation warning in a docstring using Sphinx directives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. deprecated:: 1.1\n\n   The ``simplify_this`` function is deprecated. Use :func:`simplify`\n   instead. See its documentation for more information.\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Series Module\nDESCRIPTION: ReStructuredText documentation layout defining the structure and navigation for SymPy's series module documentation, including table of contents with links to submodules.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/series/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _series-docs:\n\n======\nSeries\n======\n\nThe series module implements series expansions as a function and many related\nfunctions.\n\nContents\n========\n\n.. toctree::\n   :titlesonly:\n\n   series.rst\n   sequences.rst\n   fourier.rst\n   formal.rst\n   limitseq.rst\n```\n\n----------------------------------------\n\nTITLE: Autoclass Reference for MultisetPartitionTraverser in Python\nDESCRIPTION: This snippet provides an autoclass reference for the MultisetPartitionTraverser class, which extends and generalizes the approach of the multiset_partitions_taocp function. It lists the class's member functions for counting and enumerating partitions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/enumerative.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: MultisetPartitionTraverser\n   :members: count_partitions,\n             enum_all,\n             enum_large,\n             enum_range,\n             enum_small\n```\n\n----------------------------------------\n\nTITLE: High-Precision Summation of Hypergeometric Series (Ramanujan Formula) with N in SymPy - Python\nDESCRIPTION: Uses SymPy to compute a high-precision approximation of pi using the Ramanujan hypergeometric series formula. Demonstrates use of factorials, symbolic sums, and the N function for evaluating to thousands of digits. Requires importing Symbol, factorial, sqrt, Sum, and N from SymPy and defining symbolic variables. The output is a numerical value for pi to a specified precision; can be extended to thousands of digits.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> f = factorial\n>>> n = Symbol('n', integer=True)\n>>> R = 9801/sqrt(8)/Sum(f(4*n)*(1103+26390*n)/f(n)**4/396**(4*n),\n...                         (n, 0, oo))\n>>> N(R, 10000) #doctest: +SKIP\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208\n99862803482534211706798214808651328230664709384460955058223172535940812848111745\n02841027019385211055596446229489549303819644288109756659334461284756482337867831\n...\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated Functionality in SymPy\nDESCRIPTION: Example showing how to test deprecated functionality using warns_deprecated_sympy context manager, specifically testing the expr_free_symbols deprecation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.testing.pytest import warns_deprecated_sympy\nx = symbols('x')\n\n# expr_free_symbols is deprecated\ndef test_deprecated_expr_free_symbols():\n    with warns_deprecated_sympy():\n        assert x.expr_free_symbols == {x}\n```\n\n----------------------------------------\n\nTITLE: Creating and Positioning Points in SymPy\nDESCRIPTION: This snippet illustrates how to create Point objects and define their positions relative to other points using SymPy's physics.vector module. It shows both the creation of new points and setting positions of existing points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nO = Point('O')\nP = O.locatenew('P', 3 * N.x + N.y)\nP.pos_from(O)\nQ = Point('Q')\nQ.set_pos(P, N.z)\nQ.pos_from(P)\nQ.pos_from(O)\n```\n\n----------------------------------------\n\nTITLE: Joining SymPy Matrices Vertically (Column Join) in Python\nDESCRIPTION: Demonstrates how to concatenate two SymPy `Matrix` objects vertically (one above the other) using the `M1.col_join(M3)` method. The matrices must have the same number of columns. Example joins an identity matrix `M1` and a zero matrix `M3`. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> M3 = zeros(4, 3)\n>>> M1.col_join(M3)\n[1  0  0]\n[       ]\n[0  1  0]\n[       ]\n[0  0  1]\n[       ]\n[0  0  0]\n[       ]\n[0  0  0]\n[       ]\n[0  0  0]\n[       ]\n[0  0  0]\n```\n\n----------------------------------------\n\nTITLE: Mass Calculation Examples\nDESCRIPTION: Examples of calculating mass for a triangular lamina and cylinder with varying density functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/vector_integration.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntriangle = ParametricRegion((x, y), (x, 0, 5), (y, 0, 5 - x))\nvector_integrate(C.x*C.y, triangle)\n\na, h = symbols('a h', positive=True)\ncylinder = ParametricRegion((r*cos(theta), r*sin(theta), z),\n                    (theta, 0, 2*pi), (z, 0, h), (r, 0, a))\nvector_integrate(C.x**2 + C.y**2, cylinder)\n```\n\n----------------------------------------\n\nTITLE: Basic Vector Integration Setup in Python\nDESCRIPTION: Initial setup and imports for vector integration examples using SymPy. Sets up coordinate system and imports necessary functions and symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/vector_integration.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import sin, cos, exp, pi, symbols\nfrom sympy.vector import CoordSys3D, ParametricRegion, ImplicitRegion, vector_integrate\nfrom sympy.abc import r, x, y, z, theta, phi\nC = CoordSys3D('C')\n```\n\n----------------------------------------\n\nTITLE: Finding Square Root Patterns in SymPy\nDESCRIPTION: Demonstrates using Wild patterns to find square root expressions in SymPy formulas\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n(y + sqrt(x)).find(Wild('w')**S.Half)\n(y + 1/sqrt(x)).find(Wild('w')**-S.Half)\n```\n\n----------------------------------------\n\nTITLE: Initializing Variables and Symbols for Rolling Disc\nDESCRIPTION: Sets up the necessary dynamical symbols and constants for the rolling disc simulation, including configuration variables, speed variables, and physical parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import symbols, sin, cos, tan\nfrom sympy.physics.mechanics import *\nq1, q2, q3, u1, u2, u3  = dynamicsymbols('q1 q2 q3 u1 u2 u3')\nq1d, q2d, q3d, u1d, u2d, u3d = dynamicsymbols('q1 q2 q3 u1 u2 u3', 1)\nr, m, g = symbols('r m g')\nmechanics_printing(pretty_print=False)\n```\n\n----------------------------------------\n\nTITLE: Defining Homomorphisms in AGCA Module (Python)\nDESCRIPTION: The 'homomorphism' function is used to define homomorphisms between arbitrary modules in the AGCA module. It implements the operations described for creating homomorphisms between free modules and extending them to arbitrary modules.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n.. currentmodule:: sympy.polys.agca.homomorphisms\n.. autofunction:: homomorphism\n```\n\n----------------------------------------\n\nTITLE: Creating a RigidBody in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a RigidBody object with mass, center of mass, reference frame, and inertia properties. The inertia can be specified as a tuple containing a dyadic and a point.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol\n>>> from sympy.physics.mechanics import ReferenceFrame, Point, RigidBody\n>>> from sympy.physics.mechanics import outer\n>>> m = Symbol('m')\n>>> A = ReferenceFrame('A')\n>>> P = Point('P')\n>>> I = outer(A.x, A.x)\n>>> # create a rigid body\n>>> B = RigidBody('B', P, A, m, (I, P))\n```\n\n----------------------------------------\n\nTITLE: Distinguishing Concrete Numbers with is_Number in SymPy (Python)\nDESCRIPTION: This snippet illustrates the `is_Number` property in SymPy, which checks if an object is an instance of a concrete number class (like `Integer`, `Rational`, `Float`). It contrasts `is_Number` with `isinstance(obj, Number)`. A `Rational` instance `x` returns `True` for both. However, a symbol `y` declared with `rational=True` (a semantic property) is not a concrete `Number` instance, so `is_Number` and the `isinstance` check return `False`. This highlights `is_Number` as a structural check.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Number, Rational\n>>> x = Rational(1, 2)\n>>> isinstance(x, Number)\nTrue\n>>> x.is_Number\nTrue\n>>> y = Symbol('y', rational=True)\n>>> isinstance(y, Number)\nFalse\n>>> y.is_Number\nFalse\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Deprecated Matrix Mixin Classes Hierarchy in Python\nDESCRIPTION: Shows the old inheritance hierarchy for matrix classes in SymPy before version 1.13, which is now deprecated. This complex hierarchy has been simplified to improve maintainability and performance.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass MatrixRequired:\nclass MatrixShaping(MatrixRequired):\nclass MatrixSpecial(MatrixRequired):\nclass MatrixProperties(MatrixRequired):\nclass MatrixOperations(MatrixRequired):\nclass MatrixArithmetic(MatrixRequired):\nclass MatrixCommon(\n    MatrixArithmetic,\n    MatrixOperations,\n    MatrixProperties,\n    MatrixSpecial,\n    MatrixShaping):\nclass MatrixDeterminant(MatrixCommon):\nclass MatrixReductions(MatrixDeterminant):\nclass MatrixSubspaces(MatrixReductions):\nclass MatrixEigen(MatrixSubspaces)\nclass MatrixCalculus(MatrixCommon):\nclass MatrixDeprecated(MatrixCommon):\nclass MatrixBase(MatrixDeprecated,\n   MatrixCalculus,\n   MatrixEigen,\n   MatrixCommon,\n   Printable):\nclass RepMatrix(MatrixBase):\nclass DenseMatrix(RepMatrix):\nclass MutableRepMatrix(RepMatrix):\nclass MutableDenseMatrix(DenseMatrix, MutableRepMatrix):\n```\n\n----------------------------------------\n\nTITLE: Defining Additional Quantities for Constraint Forces\nDESCRIPTION: This snippet introduces extra dynamicsymbols needed to find the constraint forces in the rolling disc simulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nu4, u5, u6, f1, f2, f3 = dynamicsymbols('u4 u5 u6 f1 f2 f3')\n```\n\n----------------------------------------\n\nTITLE: Single Dictionary Return from Solve Function\nDESCRIPTION: Shows solve returning a single dictionary when equations are linear in the symbols or when using undetermined-coefficients for a single equation. Keys are symbols and values are solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsolve([x + y - 2, x - y + 2], x, y)\n{x: 0, y: 2}\neq = a*x - 2*x + b - 5\nsolve(eq, {a, b})  # undetermined coefficients\n{a: 2, b: 5}\nsolve([eq], {a, b})  # algebraic\n{a: -b/x + (2*x + 5)/x}\n```\n\n----------------------------------------\n\nTITLE: Enabling SymPy Debug Mode in Unix-like Systems\nDESCRIPTION: This command sets the SYMPY_DEBUG environment variable to True and starts the interactive SymPy shell (isympy) in debug mode. This allows for enhanced debugging capabilities, such as printed trees for functions like limit().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/debug.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ SYMPY_DEBUG=True bin/isympy\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents Directive\nDESCRIPTION: Hidden toctree directive that defines the documentation structure and references to subsection files.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :maxdepth: 2\n\n   public/basics/index.rst\n   public/codegeneration/index.rst\n   public/logic/index.rst\n   public/matrices/index.rst\n   public/numbertheory/index.rst\n   public/physics/index.rst\n   public/utilities/index.rst\n   public/topics/index.rst\n```\n\n----------------------------------------\n\nTITLE: Using FirstOrderActivationDeGroote2016 with Default Constants\nDESCRIPTION: Demonstrates using the default numerical constants for the DeGroote 2016 model. First, it instantiates `FirstOrderActivationDeGroote2016` using the `with_defaults` class method and retrieves the ODE's right-hand side using `rhs()`. Second, it defines a dictionary `constants` containing the default floating-point values and substitutes these into the symbolic `rhs()` expression obtained from the symbolically parameterized instance (`actf`), showing the resulting expression with numerical coefficients.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> actf2 = FirstOrderActivationDeGroote2016.with_defaults('first')\n>>> actf2.rhs()\nMatrix([[((1/2 - tanh(10.0*a_first(t) - 10.0*e_first(t))/2)/(0.0225*a_first(t) + 0.0075) + 16.6666666666667*(3*a_first(t)/2 + 1/2)*(tanh(10.0*a_first(t) - 10.0*e_first(t))/2 + 1/2))*(-a_first(t) + e_first(t))]])\n>>> constants = {tau_a: sm.Float('0.015'), tau_d: sm.Float('0.060'), b: sm.Float('10.0')}\n>>> actf.rhs().subs(constants)\nMatrix([[(66.6666666666667*(1/2 - tanh(10.0*a_first(t) - 10.0*e_first(t))/2)/(3*a_first(t)/2 + 1/2) + 16.6666666666667*(3*a_first(t)/2 + 1/2)*(tanh(10.0*a_first(t) - 10.0*e_first(t))/2 + 1/2))*(-a_first(t) + e_first(t))]])\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments in the Custom expreal Function (Python)\nDESCRIPTION: This snippet shows the argument validation implemented within the `expreal.eval` method. When `expreal` is called with a non-extended-real argument like `I` (the imaginary unit), the check `x.is_extended_real is False` evaluates to `True`, triggering the `ValueError` defined in the `eval` method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> expreal(I)\nTraceback (most recent call last):\n...\nValueError: non-real argument to expreal\n```\n\n----------------------------------------\n\nTITLE: Creating Coefficient Matrix for Finite Difference Approximation in Python\nDESCRIPTION: Constructs a matrix of coefficients for the finite difference approximation using the Taylor series polynomial. This matrix is used to solve for the derivative approximation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nR = Matrix([[Fi], [Fip1], [Fip2]])\n\nm11 = P(x0 , x0, c, n).diff(c[0])\nm12 = P(x0 , x0, c, n).diff(c[1])\nm13 = P(x0 , x0, c, n).diff(c[2])\n\nm21 = P(x0+h, x0, c, n).diff(c[0])\nm22 = P(x0+h, x0, c, n).diff(c[1])\nm23 = P(x0+h, x0, c, n).diff(c[2])\n\nm31 = P(x0+2*h, x0, c, n).diff(c[0])\nm32 = P(x0+2*h, x0, c, n).diff(c[1])\nm33 = P(x0+2*h, x0, c, n).diff(c[2])\n\nM = Matrix([[m11, m12, m13], [m21, m22, m23], [m31, m32, m33]])\n```\n\n----------------------------------------\n\nTITLE: Viewing Changes to .mailmap File\nDESCRIPTION: Using git diff to view the changes made to the .mailmap file after adding a new author entry.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ git diff\n```\n\n----------------------------------------\n\nTITLE: Querying Dynamic Assumptions of 'versin' Function (Python)\nDESCRIPTION: Tests the dynamic assumption handlers defined for the `versin` function. It checks `is_nonnegative` for a real input (`versin(1)`), and `is_positive` for inputs that are even (`versin(2*pi)`) and odd (`versin(3*pi)`) multiples of pi, demonstrating the logic implemented in `_eval_is_nonnegative` and `_eval_is_positive`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import pi\n>>> # Assuming 'versin' class is defined as in the previous snippet\n>>> versin(1).is_nonnegative\nTrue\n>>> versin(2*pi).is_positive\nFalse\n>>> versin(3*pi).is_positive\nTrue\n```\n\n----------------------------------------\n\nTITLE: Defining Inertia and Forces\nDESCRIPTION: Creates the inertia dyadic for the disc and defines the gravitational force acting on the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nI = inertia(L, m / 4 * r**2, m / 2 * r**2, m / 4 * r**2)\nForceList = [(Dmc, - m * g * Y.z)]\nBodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\nBodyList = [BodyD]\n```\n\n----------------------------------------\n\nTITLE: Using the Interactive Plot Interface in SymPy\nDESCRIPTION: Demonstrates interactive manipulation of plots through the Plot class. This example shows how to create, modify, and display plots of a function and its derivatives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\np = Plot(visible=False)\nf = x**2\np[1] = f\np[2] = f.diff(x)\np[3] = f.diff(x).diff(x)\np\n[1]: x**2, 'mode=cartesian'\n[2]: 2*x, 'mode=cartesian'\n[3]: 2, 'mode=cartesian'\np.show()\np.clear()\np\n<blank plot>\np[1] =  x**2+y**2\np[1].style = 'solid'\np[2] = -x**2-y**2\np[2].style = 'wireframe'\np[1].color = z, (0.4,0.4,0.9), (0.9,0.4,0.4)\np[1].style = 'both'\np[2].style = 'both'\np.close()\n```\n\n----------------------------------------\n\nTITLE: Configuring Git User Name and Email\nDESCRIPTION: Commands to set up Git with user name and email for commit tracking and GitHub association.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit config --global user.name \"Firstname Lastname\"\ngit config --global user.email \"your_email@youremail.com\"\n```\n\n----------------------------------------\n\nTITLE: Importing and Using SymPy Enumeration Functions\nDESCRIPTION: Example showing how to import and use combinatorial enumeration functions from SymPy. This demonstrates importing nC, nP, and nT functions for calculating combinations, permutations, and other combinatorial operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/functions/combinatorial.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.functions.combinatorial.numbers import nC, nP, nT\nitems = 'baby'\n```\n\n----------------------------------------\n\nTITLE: Differentiation Examples for FMA Function in Python\nDESCRIPTION: Demonstrates the usage of the diff method on the FMA function with various arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nFMA(x, y, z).diff(x)\nFMA(x, y, z).diff(y)\nFMA(x, y, z).diff(z)\nFMA(x**2, x + 1, y).diff(x)\n```\n\n----------------------------------------\n\nTITLE: Force and Torque Application in SymPy\nDESCRIPTION: Demonstrates how to apply forces and torques between bodies in SymPy using force lists.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfL.append((P, -1*v), (Q, v))\n```\n\nLANGUAGE: python\nCODE:\n```\nfL.append((A, -1*v), (B, v))\n```\n\n----------------------------------------\n\nTITLE: Testing Binomial and Factorial Variations in SymPy\nDESCRIPTION: Demonstrates testing hypergeometric properties of binomial coefficients and factorials with respect to the second argument k.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/concrete.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nbinomial(n, k).is_hypergeometric(k)\nrf(n, k).is_hypergeometric(k)\nff(n, k).is_hypergeometric(k)\n```\n\n----------------------------------------\n\nTITLE: Verifying Diophantine Solutions\nDESCRIPTION: Shows how to verify solutions by substituting values back into the original equation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> a, b, c, p, q = symbols(\"a, b, c, p, q\", integer=True)\n>>> my_syms = (a, b, c)\n>>> pythag = a**2 + b**2 - c**2\n>>> d = diophantine(pythag, syms=my_syms)\n>>> solution_list = list(d)\n>>> solution_p4q3 = dict(zip(my_syms, [var.subs({p:4, q:3}) for var in solution_list[0]]))\n>>> pythag.subs({a: solution_p4q3[a], b: solution_p4q3[b], c: solution_p4q3[c]})\n0\n```\n\n----------------------------------------\n\nTITLE: Module Functions - Groebner Basis\nDESCRIPTION: Function declarations for distributed module operations in Groebner basis computations, including spoly operations, ecart calculations, and Mora normal form.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nsdm_spoly\nsdm_ecart\nsdm_nf_mora\nsdm_groebner\n```\n\n----------------------------------------\n\nTITLE: Emulating evaluate=True in differentiate_finite in Python\nDESCRIPTION: Shows how to achieve the behavior of the deprecated evaluate flag in differentiate_finite. This method expands intermediate derivatives before computing differences, which may not satisfy the product rule.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ndiff(expr, x).replace(\n    lambda arg: arg.is_Derivative,\n    lambda arg: arg.as_finite_difference())\n```\n\n----------------------------------------\n\nTITLE: Class Structure Overview - SymPy Stats Python Code\nDESCRIPTION: Core class hierarchy illustrating the relationship between RandomDomain, PSpace, and specialized probability space implementations for handling different types of random variables and distributions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/stats.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass RandomDomain:\n    pass\n\nclass PSpace:\n    pass\n\nclass RandomSymbol:\n    pass\n\nclass SinglePSpace:\n    pass\n\nclass SingleDomain:\n    pass\n\nclass ProductDomain:\n    pass\n\nclass ProductPSpace:\n    pass\n\nclass ConditionalDomain:\n    pass\n\nclass FiniteDomain:\n    pass\n\nclass FinitePSpace:\n    pass\n\nclass ContinuousDomain:\n    pass\n\nclass ContinuousPSpace:\n    pass\n\nclass DiePSpace:\n    pass\n\nclass NormalPSpace:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Creating ANTLR4 Executable Script in Bash\nDESCRIPTION: Shell script to create an executable wrapper for the ANTLR4 Java-based parser generator. This script allows users to run the ANTLR4 tool from the command line when working on SymPy's LaTeX parser.\nSOURCE: https://github.com/sympy/sympy/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\njava -jar /usr/local/lib/antlr-4.11.1-complete.jar \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Error When Applying math Function to SymPy Symbol\nDESCRIPTION: This snippet shows that functions from the standard Python `math` module, like `math.sin`, cannot operate on SymPy symbolic expressions. They expect float inputs and raise a TypeError when given a SymPy `Symbol`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_22\n\nLANGUAGE: py\nCODE:\n```\n>>> x = Symbol('x')\n>>> math.sin(x)\nTraceback (most recent call last):\n...\nTypeError: Cannot convert expression to float\n```\n\n----------------------------------------\n\nTITLE: Handling Transcendental Functions in Domain Construction with SymPy\nDESCRIPTION: Shows how construct_domain handles algebraically independent transcendentals and potentially dependent transcendentals when constructing domains.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import sin, cos\n>>> construct_domain([sin(x), y])[0]\nZZ[y,sin(x)]\n>>> construct_domain([sin(x), cos(x)])[0]\nEX\n```\n\n----------------------------------------\n\nTITLE: New Joint Position Specification with Points\nDESCRIPTION: Example showing how to specify joint attachment points using explicit Point objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import PinJoint, Point, RigidBody\nparent, child = RigidBody('parent'), RigidBody('child')\nparent_point = parent.masscenter.locatenew('parent_point', parent.frame.x)\nchild_point = child.masscenter.locatenew('child_point', -child.frame.x)\npin = PinJoint('pin', parent, child, parent_point=parent_point,\n               child_point=child_point)\npin.parent_point.pos_from(parent.masscenter)\npin.child_point.pos_from(child.masscenter)\n```\n\n----------------------------------------\n\nTITLE: Documenting SymPy Exceptions Module\nDESCRIPTION: RestructuredText directive to auto-generate documentation for all members of the sympy.utilities.exceptions module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/exceptions.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: sympy.utilities.exceptions\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Double Pendulum System Definition in Autolev\nDESCRIPTION: Defines a double pendulum system using Autolev syntax. It includes motion variables, constants, frames, rotations, points, particles, and equations of motion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/autolev_parser.rst#2025-04-22_snippet_1\n\nLANGUAGE: autolev\nCODE:\n```\nMOTIONVARIABLES' Q{2}', U{2}'\nCONSTANTS L,M,G\nNEWTONIAN N\nFRAMES A,B\nSIMPROT(N, A, 3, Q1)\nSIMPROT(N, B, 3, Q2)\nW_A_N>=U1*N3>\nW_B_N>=U2*N3>\nPOINT O\nPARTICLES P,R\nP_O_P> = L*A1>\nP_P_R> = L*B1>\nV_O_N> = 0>\nV2PTS(N, A, O, P)\nV2PTS(N, B, P, R)\nMASS P=M, R=M\nQ1' = U1\nQ2' = U2\nGRAVITY(G*N1>)\nZERO = FR() + FRSTAR()\nKANE()\nINPUT M=1,G=9.81,L=1\nINPUT Q1=.1,Q2=.2,U1=0,U2=0\nINPUT TFINAL=10, INTEGSTP=.01\nCODE DYNAMICS() some_filename.c\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Assumptions Processing in Basic Subclass in Python\nDESCRIPTION: This example shows how Basic.__init_subclass__ processes assumptions-related attributes in subclasses, creating default assumptions and inferring additional properties.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Expr\n...\n>>> class A(Expr):\n...     is_positive = True\n...\n...     def _eval_is_rational(self):\n...         # Let's print something to see when this method is called...\n...         print('!!! calling _eval_is_rational')\n...         return True\n...\n>>> A.is_positive\nTrue\n>>> A.is_real  # inferred from is_positive\nTrue\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Variables\nDESCRIPTION: Basic setup for SymPy usage by importing the library and creating symbolic variables x, y, z.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/solvers.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols('x y z')\ninit_printing(use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Using hypersimp() Function in SymPy\nDESCRIPTION: Shows usage of hypersimp() function to simplify combinatorial expressions and determine if they are hypergeometric.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/concrete.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nhypersimp(factorial(2*n), n)\nhypersimp(factorial(n**2), n)\n```\n\n----------------------------------------\n\nTITLE: Solving Vector Equations with Reference Frames\nDESCRIPTION: Shows how to solve equations involving vectors by converting them to scalar equations and using SymPy's solve function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/advanced.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import pi, symbols, solve\n>>> from sympy.physics.vector import ReferenceFrame\n>>> N = ReferenceFrame(\"N\")\n>>> A = ReferenceFrame(\"A\")\n>>> A.orient_axis(N, pi / 6, N.z)\n>>> v1x, v1y, v1z = symbols(\"v1x v1y v1z\")\n>>> v2x, v2y, v2z = symbols(\"v2x v2y v2z\")\n>>> v1 = v1x * N.x + v1y * N.y + v1z * N.z\n>>> v2 = v2x * A.x + v2y * A.y + v2z * A.z\n>>> solve((v1 - v2).to_matrix(N), [v2x, v2y, v2z])\n{v2x: sqrt(3)*v1x/2 + v1y/2, v2y: -v1x/2 + sqrt(3)*v1y/2, v2z: v1z}\n```\n\n----------------------------------------\n\nTITLE: Representing Piecewise Functions in SymPy\nDESCRIPTION: Shows how to represent a piecewise function using SymPy's Piecewise class, which handles symbolic values correctly.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Piecewise, Eq, pprint\n>>> f = Piecewise((0, Eq(x, 0)), (x + 1, True))\n\n>>> pprint(f, use_unicode=True)\n⎧  0    for x = 0\n⎨\n⎩x + 1  otherwise\n>>> f.subs(x, 0)\n0\n>>> f.subs(x, 1)\n2\n```\n\n----------------------------------------\n\nTITLE: Skipping Tests with Optional Dependencies in Python\nDESCRIPTION: This code snippet demonstrates how to skip a test when an optional dependency (in this case, NumPy) is not installed. It uses the import_module function from sympy.external and the skip function from sympy.testing.pytest.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.external import import_module\n\n# numpy will be None if NumPy is not installed\nnumpy = import_module('numpy')\n\ndef test_func():\n    if not numpy:\n       skip('numpy is not installed')\n\n    assert func(...) == ...\n```\n\n----------------------------------------\n\nTITLE: List of Values Return from Solve Function\nDESCRIPTION: Demonstrates solve returning a list of values when the symbol to solve for is unambiguous, either because the equation is univariate or because a single symbol was specified as being of interest.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsolve(x**2 - 4)\n[-2, 2]\nsolve(x - y - 1, x)\n[y + 1]\n```\n\n----------------------------------------\n\nTITLE: Computing Subword Index\nDESCRIPTION: Shows how to compute the starting and ending indices of a subword within a word in a polycyclic group.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/pc_groups.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.named_groups import SymmetricGroup\nfrom sympy.combinatorics.free_groups import free_group\nG = SymmetricGroup(4)\nPcGroup = G.polycyclic_group()\ncollector = PcGroup.collector\nF, x1, x2 = free_group(\"x1, x2\")\nword = x2**2*x1**7\nw = x2**2*x1\ncollector.subword_index(word, w)\nw = x1**7\ncollector.subword_index(word, w)\n```\n\n----------------------------------------\n\nTITLE: Attempting Incompatible Unit Conversion in Python using SymPy\nDESCRIPTION: This example shows that when attempting to convert a quantity to incompatible units, the original quantity is returned unchanged.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nconvert_to(speed_of_light, [meter])\n```\n\n----------------------------------------\n\nTITLE: Automating Module Documentation with Sphinx automodule\nDESCRIPTION: This reStructuredText snippet employs the Sphinx `automodule` directive to automatically generate documentation for the Python module `sympy.physics.quantum.operator`. The `:members:` option ensures that documentation for all public members (functions, classes, etc.) within this module is included. This requires Sphinx and the SymPy library to be correctly installed and configured.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/operator.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.quantum.operator\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing with Line Wrapping in SymPy\nDESCRIPTION: Example showing how fcode handles long expressions with line wrapping in Fortran. This demonstrates printing a series expansion with proper line continuation characters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> expr = sqrt(1-x**2).series(x,n=20).removeO()\n>>> print(fcode(expr))\n    -715.0d0/65536.0d0*x**18 - 429.0d0/32768.0d0*x**16 - 33.0d0/\n    @ 2048.0d0*x**14 - 21.0d0/1024.0d0*x**12 - 7.0d0/256.0d0*x**10 -\n    @ 5.0d0/128.0d0*x**8 - 1.0d0/16.0d0*x**6 - 1.0d0/8.0d0*x**4 - 1.0d0\n    @ /2.0d0*x**2 + 1\n```\n\n----------------------------------------\n\nTITLE: Generating Equations of Motion using Kane's Method\nDESCRIPTION: Uses Kane's Method to generate the equations of motion for the system with holonomic constraints. Handles dependent coordinates and velocities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nkane = me.KanesMethod(\n    N,\n    (q1,),\n    (u1,),\n    kd_eqs=(\n        u1 - q1.diff(),\n        u2 - q2.diff(),\n        u3 - q3.diff(),\n        u4 - q4.diff(),\n    ),\n    q_dependent=(q2, q3, q4),\n    configuration_constraints=holonomic,\n    velocity_constraints=holonomic.diff(me.dynamicsymbols._t),\n    u_dependent=(u2, u3, u4),\n)\n\nFr, Frs = kane.kanes_equations((lever, u_arm, l_arm), loads)\n```\n\n----------------------------------------\n\nTITLE: Documenting RGS_enum Function in reStructuredText\nDESCRIPTION: Autofunction directive for the RGS_enum function, which is part of the sympy.combinatorics.partitions module. This function likely enumerates restricted growth strings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_4\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: RGS_enum\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy Basic Setup\nDESCRIPTION: Sets up SymPy environment with symbol definitions and pretty printing configuration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols('x y z')\ninit_printing(use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Basic Domain Operations in SymPy\nDESCRIPTION: Shows basic arithmetic operations with ZZ domain elements, including type checking and domain membership testing.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ZZ\n>>> z1 = ZZ(2)\n>>> z1\n2\n>>> z1 + z1\n4\n>>> type(z1)  # doctest: +SKIP\n<class 'int'>\n>>> z1 in ZZ\nTrue\n```\n\n----------------------------------------\n\nTITLE: Pin Joint Definition with Parent/Child Axis\nDESCRIPTION: Example showing the previous way to define a PinJoint that rotates the child body about parent.z and -child.z axes using parent_axis and child_axis arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import PinJoint, RigidBody\nparent, child = RigidBody('parent'), RigidBody('child')\npin = PinJoint('pin', parent, child, parent_axis=parent.z,\n               child_axis=-child.z)   # doctest: +SKIP\nparent.dcm(child)   # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Setting Up Constraints for Bicycle Model in Python\nDESCRIPTION: Defines nonholonomic and holonomic constraints for the bicycle model, including no-slip conditions and ground contact constraints for the wheels.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n>>> conlist_speed = [me.dot(WF_cont.vel(N), Y.x),\n...                  me.dot(WF_cont.vel(N), Y.y),\n...                  me.dot(WF_cont.vel(N), Y.z)]\n\n>>> conlist_coord = [me.dot(WF_cont.pos_from(WR_cont), Y.z)]\n```\n\n----------------------------------------\n\nTITLE: Expressing Mass and Time in Natural System\nDESCRIPTION: Mathematical representation of Mass and Time dimensions expressed in terms of the natural system basis (Action, Length, Velocity).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/philosophy.rst#2025-04-22_snippet_3\n\nLANGUAGE: math\nCODE:\n```\nT = L V^{-1}, \\qquad\nM = A V^{-2},\\\\\nT =\n\\begin{pmatrix}\n0 \\\\ 1 \\\\ -1\n\\end{pmatrix}, \\qquad\nM =\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ -2\n\\end{pmatrix}.\n```\n\n----------------------------------------\n\nTITLE: Alternative Expression Format for Diophantine Equations\nDESCRIPTION: Shows how to solve a Diophantine equation expressed as an expression equal to zero rather than using the Eq function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> a, b, c = symbols(\"a, b, c\", integer=True)\n>>> my_syms = (a, b, c)\n>>> pythag = a**2 + b**2 - c**2\n>>> diophantine(pythag, syms=my_syms)\n{(2*p*q, p**2 - q**2, p**2 + q**2)}\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Hinged Beam with Multiple Supports using SymPy\nDESCRIPTION: This example demonstrates the analysis of a beam with a hinge connector in the middle, fixed at one end and supported by rollers. It shows how to calculate reaction forces, shear forces, bending moments, and deflections for a multi-segment beam.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E I')\n>>> l = symbols('l', positive=True)\n>>> R1, M1, R2, R3, P = symbols('R1 M1 R2 R3 P')\n>>> b1 = Beam(2*l, E, I)\n>>> b2 = Beam(2*l, E, I)\n>>> b = b1.join(b2, \"hinge\")\n>>> b.apply_load(M1, 0, -2)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, l, -1)\n>>> b.apply_load(R3, 4*l, -1)\n>>> b.apply_load(P, 3*l, -1)\n>>> b.bc_slope = [(0, 0)]\n>>> b.bc_deflection = [(0, 0), (l, 0), (4*l, 0)]\n>>> b.solve_for_reaction_loads(M1, R1, R2, R3)\n>>> b.reaction_loads\n⎧    -P⋅l       3⋅P      -5⋅P       -P ⎫\n⎨M₁: ─────, R₁: ───, R₂: ─────, R₃: ───⎬\n⎩      4         4         4         2 ⎭\n\n>>> b.load\n        2           -3          -2          -1               -1                                -1\n  13⋅P⋅l ⋅<-2⋅l + x>     P⋅l⋅<x>     3⋅P⋅<x>     5⋅P⋅<-l + x>                 -1   P⋅<-4⋅l + x>\n- ──────────────────── - ───────── + ───────── - ────────────── + P⋅<-3⋅l + x>   - ──────────────\n           48                4           4             4                                 2\n\n>>> b.shear_force()\n      2           -2          -1          0               0                               0\n13⋅P⋅l ⋅<-2⋅l + x>     P⋅l⋅<x>     3⋅P⋅<x>    5⋅P⋅<-l + x>                0   P⋅<-4⋅l + x>\n──────────────────── + ───────── - ──────── + ───────────── - P⋅<-3⋅l + x>  + ─────────────\n         48                4          4             4                               2\n\n>>> b.bending_moment()\n      2           -1          0          1               1                               1\n13⋅P⋅l ⋅<-2⋅l + x>     P⋅l⋅<x>    3⋅P⋅<x>    5⋅P⋅<-l + x>                1   P⋅<-4⋅l + x>\n──────────────────── + ──────── - ──────── + ───────────── - P⋅<-3⋅l + x>  + ─────────────\n         48               4          4             4                               2\n\n>>> b.slope()\n ⎛      2           0          1          2               2               2               2⎞\n ⎜13⋅P⋅l ⋅<-2⋅l + x>    P⋅l⋅<x>    3⋅P⋅<x>    5⋅P⋅<-l + x>    P⋅<-3⋅l + x>    P⋅<-4⋅l + x> ⎟\n-⎜─────────────────── + ──────── - ──────── + ───────────── - ───────────── + ─────────────⎟\n ⎝        48               4          8             8               2               4      ⎠\n─────────────────────────────────────────────────────────────────────────────────────────────\n                                         E⋅I\n>>> b.deflection()\n ⎛      2           1          2        3               3               3               3⎞\n ⎜13⋅P⋅l ⋅<-2⋅l + x>    P⋅l⋅<x>    P⋅<x>    5⋅P⋅<-l + x>    P⋅<-3⋅l + x>    P⋅<-4⋅l + x> ⎟\n-⎜─────────────────── + ──────── - ────── + ───────────── - ───────────── + ─────────────⎟\n ⎝        48               8         8           24               6              12      ⎠\n───────────────────────────────────────────────────────────────────────────────────────────\n                                        E⋅I\n```\n\n----------------------------------------\n\nTITLE: Constructing Collector with Polycyclic Presentation\nDESCRIPTION: Shows how to create a Collector object from a polycyclic group and access its free group and presentation properties.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/pc_groups.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.named_groups import SymmetricGroup\nG = SymmetricGroup(3)\nPcGroup = G.polycyclic_group()\nCollector = PcGroup.collector\nCollector.free_group\nCollector.pc_presentation\n```\n\n----------------------------------------\n\nTITLE: Real and Imaginary Parts Example for Versine Function in Python\nDESCRIPTION: Demonstrates the usage of the as_real_imag method and expand_complex function on the versine function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nversin(x).as_real_imag()\nversin(x).expand(complex=True)\n```\n\n----------------------------------------\n\nTITLE: Sphinx AutoModule Directive for Wigner Symbols Documentation\nDESCRIPTION: A reStructuredText directive that instructs Sphinx to automatically generate documentation for all members in the sympy.physics.wigner module, which contains implementations of Wigner symbols and related functions for quantum mechanics calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/wigner.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.wigner\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Using sring Function for Symbolic Ring Creation in SymPy\nDESCRIPTION: Example showing how the sring function works to determine the appropriate ring for a given expression. It can handle symbolic terms as generators to ensure that exponents are natural numbers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.polys.rings import sring\n>>> R, expr = sring(1/a**3 + a**QQ(3, 7)); R\nPolynomial ring in 1/a, a**(1/7) over ZZ with lex order\n\n>>> expr*R(1/a)\n(1/a)**4 + (1/a)*(a**(1/7))**3\n```\n\n----------------------------------------\n\nTITLE: Pin Joint with Vector-Based Intermediate Frames\nDESCRIPTION: Example demonstrating how to define a PinJoint using vectors for parent_interframe and child_interframe to automatically align the joint axis.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import PinJoint, RigidBody\nparent, child = RigidBody('parent'), RigidBody('child')\npin = PinJoint('pin', parent, child, parent_interframe=parent.z,\n               child_interframe=-child.z)\nparent.frame.dcm(child.frame)\n```\n\n----------------------------------------\n\nTITLE: Substitution and Atom Extraction on Boolean Expressions (SymPy, Python)\nDESCRIPTION: This snippet illustrates two key operations on Boolean expressions in SymPy: substituting Boolean values for symbols using the subs() method, and extracting atomic symbols with atoms(). After forming logical expressions, users can substitute assignments and query all variables involved. The dependencies are only SymPy, and input expressions and substitution dictionaries are required. Outputs are evaluated Boolean values or sets of symbol objects. This supports manipulation and analysis of Boolean formulas.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/logic.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> (y & x).subs({x: True, y: True})\nTrue\n>>> (x | y).atoms()\n{x, y}\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Logic Documentation in reStructuredText\nDESCRIPTION: This snippet creates a table of contents for the Logic section of SymPy documentation using reStructuredText syntax. It includes a header and links to the logic and sets modules.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/logic/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _logic:\n\n======\nLogic\n======\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/logic.rst\n   ../../../modules/sets.rst\n```\n\n----------------------------------------\n\nTITLE: Setting up SymPy environment for polynomial operations\nDESCRIPTION: Basic setup for importing SymPy functions and initializing variables for polynomial manipulation. This enables unicode printing and defines common symbolic variables for the examples.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n\n>>> init_printing(use_unicode=True)\n\n>>> var('x,y,z,s,c')\n(x, y, z, s, c)\n```\n\n----------------------------------------\n\nTITLE: Asserting Trigonometric Series Expansion in Python\nDESCRIPTION: This snippet demonstrates how to write a test case for the series expansion of the cosine function in SymPy. It asserts that the series expansion of cos(x) up to the 9th term matches the expected result.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_cos_series():\n    assert cos(x).series(x, 0, 9) == \\\n        1 - x**2/2 + x**4/24 - x**6/720 + x**8/40320 + O(x**9)\n```\n\n----------------------------------------\n\nTITLE: Setting Plot Mode and Color in SymPy\nDESCRIPTION: Demonstrates how to specify plot mode and color using option strings. This example creates a spherical plot with a z-fading color scheme.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nPlot(1, 'mode=spherical; color=zfade4')\n```\n\n----------------------------------------\n\nTITLE: ModuleHomomorphism Class Reference (Python)\nDESCRIPTION: Detailed reference for the ModuleHomomorphism class in the AGCA module. This class represents homomorphisms between modules and provides various methods for manipulating and analyzing them.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: ModuleHomomorphism\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Dense Univariate Polynomial (DUP) Representation in SymPy\nDESCRIPTION: This snippet demonstrates how polynomials can be represented in the dense univariate polynomial (DUP) format, where coefficients are stored in a list. It accesses the internal representation of a polynomial to show this format.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> p = Poly(x**4 + x + 1)\n>>> p.rep.rep  # doctest: +SKIP\n[1, 0, 0, 1, 1]\n```\n\n----------------------------------------\n\nTITLE: Testing Warnings in Python with Context Manager\nDESCRIPTION: Example demonstrating how to test warning messages using the warns context manager, including pattern matching for warning messages.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.testing.pytest import warns\nwith warns(UserWarning):\n    function_that_emits_a_warning()\n\nwith warns(UserWarning, match=r'warning'):\n    function_that_emits_a_warning()\n```\n\n----------------------------------------\n\nTITLE: Proper Test for Assumptions Using Explicit Comparison\nDESCRIPTION: Example showing the preferred way to test assumptions by explicitly comparing against True, False, or None.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n# GOOD\nassert x.is_real is False\n```\n\n----------------------------------------\n\nTITLE: Setting Up Lagrangian for Rolling Disc Simulation in Python\nDESCRIPTION: This snippet sets the potential energy of the rolling disc and determines its Lagrangian. It considers the gravitational potential energy and uses the Lagrangian function from the mechanics module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_lagrange.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nBodyD.potential_energy = - m * g * r * cos(q2)\nLag = Lagrangian(N, BodyD)\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents for SymPy Codegen Module\nDESCRIPTION: ReStructuredText markup defining the documentation structure for the code generation module, including a reference label and table of contents directive pointing to the main documentation file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/codegeneration/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _codegen_module:\n\n===============\nCode Generation\n===============\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/codegen.rst\n```\n\n----------------------------------------\n\nTITLE: Documenting Function Parameters in SymPy\nDESCRIPTION: Shows how to properly format function parameters and mathematical expressions in SymPy documentation, using italics for parameters and LaTeX for math.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/documentation-style-guide.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef stirling(n, k, d=None, kind=2, signed=False):\n    \"\"\"\n    ...\n\n    The first kind of Stirling number counts the number of permutations of\n    *n* distinct items that have *k* cycles; the second kind counts the\n    ways in which *n* distinct items can be partitioned into *k* parts.\n    If *d* is given, the \"reduced Stirling number of the second kind\" is\n    returned: $S^{d}(n, k) = S(n - d + 1, k - d + 1)$ with $n \\ge k \\ge d$.\n    This counts the ways to partition $n$ consecutive integers into $k$\n    groups with no pairwise difference less than $d$.\n\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Equivalent Symbol Declarations in Python\nDESCRIPTION: This example shows that declaring a symbol as positive implicitly makes it real, demonstrating that redundant predicates are not necessary when creating symbols with assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nx1 = Symbol('x1', positive=True, real=True)\nx2 = Symbol('x2', positive=True)\nx1.is_real\nx2.is_real\nx1.assumptions0 == x2.assumptions0\n```\n\n----------------------------------------\n\nTITLE: Using Deprecated carmichael Symbolic Function from Old Import Location - SymPy - Python\nDESCRIPTION: Demonstrates the deprecated usage pattern for importing and using the carmichael function from SymPy's old combinatorial numbers location. Dependencies: SymPy. Inputs include an integer (561); output is a boolean indicating if it is a Carmichael number. Usage is deprecated and triggers a warning.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import carmichael\n>>> carmichael.is_carmichael(561) # doctest: +SKIP\nTrue\n```\n\n----------------------------------------\n\nTITLE: Applying Gravitational Forces to Bicycle Components in SymPy\nDESCRIPTION: Defines a list of gravitational forces applied to each body of the bicycle model at its center of mass. This sets up the external forces acting on the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nforces = [(Frame_mc, -mframe * g * Y.z),\n          (Fork_mc, -mfork * g * Y.z),\n          (WF_mc, -mwf * g * Y.z),\n          (WR_mc, -mwr * g * Y.z)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for SymPy Beam Module (reStructuredText)\nDESCRIPTION: This reStructuredText directive instructs Sphinx's `autodoc` extension to generate documentation for the Python module `sympy.physics.continuum_mechanics.beam`. The `:members:` option ensures that documentation for all public members (classes, functions, attributes, etc.) within the specified module is automatically pulled and formatted.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/continuum_mechanics/beam.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.continuum_mechanics.beam\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Testing Documentation in reStructuredText\nDESCRIPTION: This snippet creates a table of contents for the testing documentation using the toctree directive. It includes links to specific testing-related topics such as pytest, randtest, and runtests.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/testing/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :titlesonly:\n\n   pytest.rst\n   randtest.rst\n   runtests.rst\n```\n\n----------------------------------------\n\nTITLE: Computing Collected Word\nDESCRIPTION: Demonstrates how to compute and verify collected words in a polycyclic group presentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/pc_groups.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.named_groups import SymmetricGroup\nfrom sympy.combinatorics.perm_groups import PermutationGroup\nfrom sympy.combinatorics.free_groups import free_group\nG = SymmetricGroup(4)\nPcGroup = G.polycyclic_group()\ncollector = PcGroup.collector\nF, x0, x1, x2, x3 = free_group(\"x0, x1, x2, x3\")\nword = x3*x2*x1*x0\ncollected_word = collector.collected_word(word)\n```\n\n----------------------------------------\n\nTITLE: Basic Docstring Example in Python\nDESCRIPTION: Demonstrates the basic structure of a docstring for a function that returns the first derivative of a Heaviside Function, including examples section with doctests.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef fdiff(self, argindex=1):\n    \"\"\"\n    Returns the first derivative of a Heaviside Function.\n\n    Examples\n    ========\n\n    >>> from sympy import Heaviside, diff\n    >>> from sympy.abc import x\n\n    >>> Heaviside(x).fdiff()\n    DiracDelta(x)\n\n    >>> Heaviside(x**2 - 1).fdiff()\n    DiracDelta(x**2 - 1)\n\n    >>> diff(Heaviside(x)).fdiff()\n    DiracDelta(x, 1)\n\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Polynomial Representations in SymPy\nDESCRIPTION: Demonstrates creating and accessing polynomial representations using multiple generators, showing both sparse and dense formats.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import prod\n>>> gens = symbols('x:10')\n>>> gens\n(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n>>> p = Poly(prod(gens))\n>>> p\nPoly(x0*x1*x2*x3*x4*x5*x6*x7*x8*x9, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, domain='ZZ')\n>>> p.rep.rep  # doctest: +SKIP\n[[[[[[[[[[1, 0], []], [[]]], [[[]]]], [[[[]]]]], [[[[[]]]]]], [[[[[[]]]]]]], [[[[[[[]]]]]]]], [[[[[[[[]]]]]]]]], [[[[[[[[[]]]]]]]]]]]\n>>> p.as_dict()\n{(1, 1, 1, 1, 1, 1, 1, 1, 1, 1): 1}\n```\n\n----------------------------------------\n\nTITLE: Documenting the fourier_series function in reStructuredText\nDESCRIPTION: reStructuredText directive for auto-documenting the fourier_series function from the sympy.series.fourier module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/series/fourier.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: sympy.series.fourier::fourier_series\n```\n\n----------------------------------------\n\nTITLE: Importing Moved Mechanics Functions from New Locations - SymPy Physics - Python\nDESCRIPTION: Shows the updated way to import the moved mechanics functions from their new locations within SymPy. Requires SymPy version after the change. 'inertia' and 'inertia_of_point_mass' are now imported from sympy.physics.mechanics, while 'gravity' comes from sympy.physics.mechanics.loads. This pattern avoids circular imports and clarifies the source of each function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import inertia, inertia_of_point_mass\n>>> from sympy.physics.mechanics.loads import gravity\n```\n\n----------------------------------------\n\nTITLE: Defining Kinematic Differential Equations\nDESCRIPTION: Example of defining kinematic differential equations for a KanesMethod object. These equations relate the time derivatives of coordinates to the generalized speeds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/kane.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> kd = [q1d - u1, q2d - u2]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Test Using String Comparison\nDESCRIPTION: Example of an anti-pattern that tests string representation rather than mathematical equivalence, making tests brittle to printer changes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n# BAD\nassert str(expand((x + 2)**3)) == 'x**3 + 6*x**2 + 12*x + 8'\n```\n\n----------------------------------------\n\nTITLE: Combinatorics Module Functions Reference (RST)\nDESCRIPTION: ReStructuredText documentation defining the utility functions available in the sympy.combinatorics.util module. Lists autofunction directives for core combinatorial computation utilities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/util.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.combinatorics.util\n\n.. autofunction:: _base_ordering\n\n.. autofunction:: _check_cycles_alt_sym\n\n.. autofunction:: _distribute_gens_by_base\n\n.. autofunction:: _handle_precomputed_bsgs\n\n.. autofunction:: _orbits_transversals_from_bsgs\n\n.. autofunction:: _remove_gens\n\n.. autofunction:: _strip\n\n.. autofunction:: _strong_gens_from_distr\n```\n\n----------------------------------------\n\nTITLE: Calculating Angular Acceleration in LaTeX\nDESCRIPTION: Shows how to calculate angular acceleration from angular velocity, including the use of the derivative theorem when angular velocity is defined in a body-fixed frame.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n{}^{\\mathbf{N}}\\boldsymbol{\\alpha}^{\\mathbf{B}} = \\frac{{}^{\\mathbf{N}} d{}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{B}}}{dt}\n\n{}^{\\mathbf{N}}\\boldsymbol{\\alpha}^{\\mathbf{B}} = \\frac{{}^{\\mathbf{B}} d{}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{B}}}{dt} +{}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{B}} \\times {}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{B}}\n\n{}^{\\mathbf{N}}\\boldsymbol{\\alpha}^{\\mathbf{B}}= \\dot{w_x}\\mathbf{\\hat{b}_x} + \\dot{w_y}\\mathbf{\\hat{b}_y} + \\dot{w_z}\\mathbf{\\hat{b}_z}\n```\n\n----------------------------------------\n\nTITLE: Converting SymPy Expression to Typed Aesara Function (Deprecated)\nDESCRIPTION: Shows how to provide type and dimension information when converting a SymPy expression to an Aesara function using `aesara_function`. This allows Aesara to optimize the computational graph more effectively. This feature is deprecated as of SymPy 1.14.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> f = aesara_function([x], [expr], dims={x: 1}, dtypes={x: 'float64'})\n```\n\n----------------------------------------\n\nTITLE: Example SymPy Doctest for dsolve (Python)\nDESCRIPTION: Demonstrates a standard SymPy doctest structure. It includes necessary imports (`Function`, `dsolve`, `cos`, `sin`, `sympy.abc.x`), defines a function symbol `f`, calls `dsolve` to solve a differential equation, and shows the exact expected output (`Eq(...)`) as it would appear in a Python console session.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Function, dsolve, cos, sin\n>>> from sympy.abc import x\n>>> f = Function('f')\n>>> dsolve(cos(f(x)) - (x*sin(f(x)) - f(x)**2)*f(x).diff(x),\n...        f(x), hint='1st_exact')\nEq(x*cos(f(x)) + f(x)**3/3, C1)\n```\n\n----------------------------------------\n\nTITLE: Correct Assumptions Handler Implementation\nDESCRIPTION: Proper implementation of an assumptions handler that only checks properties of the function arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n# GOOD\n\nclass f(Function):\n    def _eval_is_integer(self):\n        return self.args[0].is_integer\n```\n\n----------------------------------------\n\nTITLE: Documenting SymPy Misc Utilities Module with Sphinx RST\nDESCRIPTION: ReStructuredText directive to automatically generate documentation for all members of the sympy.utilities.misc module using Sphinx automodule.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/misc.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=============\nMiscellaneous\n=============\n\n.. automodule:: sympy.utilities.misc\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Importing Enumerative Module in Python\nDESCRIPTION: This snippet shows how to import the enumerative module from SymPy's utilities package. The module provides functionality for enumerating and counting multiset partitions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/enumerative.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. module:: sympy.utilities.enumerative\n```\n\n----------------------------------------\n\nTITLE: Evaluating 'versin' for Complex Input (Python)\nDESCRIPTION: Calculates the value of `versin(x) = 1 - cos(x)` for a complex input `x = pi + I*pi`. This demonstrates that the function can produce positive real results even for non-real inputs, which is relevant when defining assumptions like non-negativity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import I, pi, cos, cosh\n>>> 1 - cos(pi + I*pi)\n1 + cosh(pi)\n>>> (1 - cos(pi + I*pi)).evalf()\n12.5919532755215\n```\n\n----------------------------------------\n\nTITLE: Defining Tutorials Section in reStructuredText\nDESCRIPTION: This snippet defines the main tutorials section using reStructuredText syntax. It sets up the page title and provides a brief introduction to the purpose of tutorials in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _tutorials:\n\n=========\nTutorials\n=========\n\nTutorials are the best place to start for anyone new to SymPy or one of SymPy's\nfeatures.\n```\n\n----------------------------------------\n\nTITLE: Polynomial Division with Integer Coefficients in SymPy\nDESCRIPTION: Shows polynomial division with integer coefficients using the div function in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> q, r = div(f, g, domain='ZZ')\n>>> q\n0\n>>> r\n   2\n5*x  + 10*x + 3\n\n>>> g = 5*x + 1\n\n>>> q, r = div(f, g, domain='ZZ')\n>>> q\nx\n>>> r\n9*x + 3\n>>> (q*g + r).expand()\n   2\n5*x  + 10*x + 3\n```\n\n----------------------------------------\n\nTITLE: Documenting IntegerPartition Class in reStructuredText\nDESCRIPTION: Autoclass directive for the IntegerPartition class, which is part of the sympy.combinatorics.partitions module. It includes all members of the class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: IntegerPartition\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Performing Integer Division with SymPy\nDESCRIPTION: Demonstrates the use of the built-in divmod function with SymPy Integers to perform division and obtain quotient and remainder.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> divmod(Integer(53), Integer(7))\n(7, 4)\n```\n\n----------------------------------------\n\nTITLE: Using Factored Expression Results in SymPy\nDESCRIPTION: Shows how to utilize the factored form of a polynomial obtained from `sympy.factor`. The resulting expression can be manipulated like any other SymPy expression, for example, by substituting variables (`subs`) with symbolic or numeric values. Assumes `expression_expanded` is a predefined expanded SymPy polynomial.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import y\n>>> factored = factor(expression_expanded)\n>>> factored\n(x - 3)*(x + 2)**2\n>>> factored.subs(x, 2*y)\n(2*y - 3)*(2*y + 2)**2\n>>> factored.subs(x, 7)\n324\n```\n\n----------------------------------------\n\nTITLE: Documenting the FourierSeries class in reStructuredText\nDESCRIPTION: reStructuredText directive for auto-documenting the FourierSeries class from the sympy.series.fourier module. It includes all class members in the documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/series/fourier.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: sympy.series.fourier::FourierSeries\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Implementing ExtensorPathway Class in Python with SymPy Mechanics\nDESCRIPTION: Defines a custom pathway class that models how a muscle wraps around a pin joint. The class handles muscle origin, insertion points, joint axis, and calculates pathway length and forces. Key functionality includes length calculation, extension velocity, and force load generation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nclass ExtensorPathway(me.PathwayBase):\n\n    def __init__(self, origin, insertion, axis_point, axis, parent_axis,\n                 child_axis, radius, coordinate):\n        super().__init__(origin, insertion)\n\n        self.origin = origin\n        self.insertion = insertion\n        self.axis_point = axis_point\n        self.axis = axis.normalize()\n        self.parent_axis = parent_axis.normalize()\n        self.child_axis = child_axis.normalize()\n        self.radius = radius\n        self.coordinate = coordinate\n\n        self.origin_distance = axis_point.pos_from(origin).magnitude()\n        self.insertion_distance = axis_point.pos_from(insertion).magnitude()\n        self.origin_angle = sm.asin(self.radius/self.origin_distance)\n        self.insertion_angle = sm.asin(self.radius/self.insertion_distance)\n```\n\n----------------------------------------\n\nTITLE: New Mathematica Parser Usage\nDESCRIPTION: Example showing the new way of using the Mathematica parser with functional replacements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.parsing.mathematica import parse_mathematica\nfrom sympy import Function, Max, Min\nparse_mathematica(\"F[7,5,3]\").replace(Function(\"F\"), lambda *x: Max(*x)*Min(*x))\n```\n\n----------------------------------------\n\nTITLE: Working with Expressions as Polynomials in SymPy\nDESCRIPTION: Shows how to manipulate multivariate polynomial expressions efficiently using the expand=False option for factorization to avoid unnecessary expansion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nf = expand((x - 2*y**2 + 3*z**3)**20)\n```\n\nLANGUAGE: python\nCODE:\n```\nfactor(f, expand=False)\n```\n\nLANGUAGE: python\nCODE:\n```\ng = expand((sin(x) - 2*cos(y)**2 + 3*tan(z)**3)**20)\n```\n\nLANGUAGE: python\nCODE:\n```\nfactor(g, expand=False)\n```\n\n----------------------------------------\n\nTITLE: Converting Hypergeometric Functions to Holonomic with SymPy in Python\nDESCRIPTION: The from_hyper function converts a hypergeometric function to its equivalent holonomic representation within the SymPy library. It requires the sympy.holonomic.holonomic module and operates on objects recognized as hypergeometric expressions. The main input is a hypergeometric function, and the output is a holonomic object suitable for further symbolic manipulation or solution. Ensure that all input expressions are compatible with SymPy's symbolic engine.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/convert.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.holonomic.holonomic import from_hyper\n```\n\n----------------------------------------\n\nTITLE: Importing and Documenting Unit Prefixes Module in reStructuredText\nDESCRIPTION: This reStructuredText snippet sets up documentation for the unit prefixes module in SymPy's physics package. It creates a section for unit prefixes and uses directives to auto-document the module and the Prefix class with its members.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/prefixes.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=============\nUnit prefixes\n=============\n\n.. automodule:: sympy.physics.units.prefixes\n\n.. autoclass:: Prefix\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Complex Number Evaluation\nDESCRIPTION: Demonstrates evaluation of complex numbers with specified precision.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/evalf.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> N(1/(pi + I), 20)\n0.28902548222223624241 - 0.091999668350375232456*I\n```\n\n----------------------------------------\n\nTITLE: Using Keyword Arguments in SymPy\nDESCRIPTION: Demonstrates keyword argument usage including Symbol assumptions and powsimp options\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nsqrt(x**2)\nx = Symbol('x', positive=True)\nsqrt(x**2)\npowsimp(x**n*x**m*y**n*y**m)\npowsimp(x**n*x**m*y**n*y**m, combine='exp')\npowsimp(x**n*x**m*y**n*y**m, combine='base')\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for sympy.physics.quantum.spin using automodule in reStructuredText\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `automodule` directive to automatically incorporate documentation from the specified Python module (`sympy.physics.quantum.spin`). The `:members:` option ensures that documentation for all public members (functions, classes, methods, etc.) within that module is included in the generated output. This requires the Sphinx documentation generator and the `sympy` library to be installed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/spin.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.quantum.spin\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Incorrect eval() Implementation - Strict Assumption Checking\nDESCRIPTION: Example showing incorrect handling of input assumptions in eval() that forces explicit assumption definition and fails on None values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass divides(Function):\n    @classmethod\n    def eval(cls, m, n):\n        # !! Not actually a good eval() method !!\n\n        # Evaluate for explicit integer m and n. This part is fine.\n        if isinstance(m, Integer) and isinstance(n, Integer):\n            return int(n % m == 0)\n\n        # For symbolic arguments, require m and n to be integer.\n        # If we write the logic this way, we will run into trouble.\n        if not m.is_integer or not n.is_integer:\n            raise TypeError(\"m and n should be integers\")\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy Testing Module in reStructuredText\nDESCRIPTION: This snippet imports the SymPy testing module using the automodule directive in reStructuredText. It sets up the documentation structure for the testing module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/testing/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.testing\n```\n\n----------------------------------------\n\nTITLE: Importing Common Symbol Setup in SymPy\nDESCRIPTION: Shows the standard imports and symbol definitions that isympy provides automatically, defining commonly used symbols and functions with appropriate assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import division\nfrom sympy import *\nx, y, z, t = symbols('x y z t')\nk, m, n = symbols('k m n', integer=True)\nf, g, h = symbols('f g h', cls=Function)\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents for Function Types\nDESCRIPTION: ReStructuredText toctree directive organizing function documentation into three main categories: elementary, combinatorial, and special functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/functions/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :titlesonly:\n\n   elementary.rst\n   combinatorial.rst\n   special.rst\n```\n\n----------------------------------------\n\nTITLE: Checking Set Emptiness using is_empty in SymPy (Python)\nDESCRIPTION: This snippet demonstrates the use of the `is_empty` property for SymPy Set objects. It creates a `FiniteSet` `S1` which is definitely not empty (`is_empty` is `False`). It then creates an `Intersection` `S2` whose emptiness depends on the symbolic value `x`. Since the emptiness cannot be determined without knowing `x`, `S2.is_empty` returns `None`, illustrating the fuzzy-boolean nature of some properties outside the core assumptions system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import FiniteSet, Intersection\n>>> S1 = FiniteSet(1, 2)\n>>> S1\n{1, 2}\n>>> print(S1.is_empty)\nFalse\n>>> S2 = Intersection(FiniteSet(1), FiniteSet(Symbol('x')))\n>>> S2\nIntersection({1}, {x})\n>>> print(S2.is_empty)\nNone\n```\n\n----------------------------------------\n\nTITLE: BibTeX Entry for Citing SymPy in LaTeX\nDESCRIPTION: This BibTeX entry provides the necessary citation information for the SymPy paper published in PeerJ Computer Science. It includes details such as authors, title, journal, volume, pages, and DOI.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/citing.md#2025-04-22_snippet_0\n\nLANGUAGE: bibtex\nCODE:\n```\n@article{10.7717/peerj-cs.103,\n     title = {SymPy: symbolic computing in Python},\n     author = {Meurer, Aaron and Smith, Christopher P. and Paprocki, Mateusz and \\v{C}ert\\'{i}k, Ond\\v{r}ej and Kirpichev, Sergey B. and Rocklin, Matthew and Kumar, AMiT and Ivanov, Sergiu and Moore, Jason K. and Singh, Sartaj and Rathnayake, Thilina and Vig, Sean and Granger, Brian E. and Muller, Richard P. and Bonazzi, Francesco and Gupta, Harsh and Vats, Shivam and Johansson, Fredrik and Pedregosa, Fabian and Curry, Matthew J. and Terrel, Andy R. and Rou\\v{c}ka, \\v{S}t\\v{e}p\\'{a}n and Saboo, Ashutosh and Fernando, Isuru and Kulal, Sumith and Cimrman, Robert and Scopatz, Anthony},\n     year = 2017,\n     month = jan,\n     keywords = {Python, Computer algebra system, Symbolics},\n     abstract = {\n                SymPy is an open source computer algebra system written in pure Python. It is built with a focus on extensibility and ease of use, through both interactive and programmatic applications. These characteristics have led SymPy to become a popular symbolic library for the scientific Python ecosystem. This paper presents the architecture of SymPy, a description of its features, and a discussion of select submodules. The supplementary material provide additional examples and further outline details of the architecture and features of SymPy.\n             },\n     volume = 3,\n     pages = {e103},\n     journal = {PeerJ Computer Science},\n     issn = {2376-5992},\n     url = {https://doi.org/10.7717/peerj-cs.103},\n     doi = {10.7717/peerj-cs.103}\n    }\n```\n\n----------------------------------------\n\nTITLE: Documenting RGS_generalized Function in reStructuredText\nDESCRIPTION: Autofunction directive for the RGS_generalized function, which is part of the sympy.combinatorics.partitions module. This function likely deals with generalized restricted growth strings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: RGS_generalized\n```\n\n----------------------------------------\n\nTITLE: Finding Non-Empty Domains with SymPy's not_empty_in Function\nDESCRIPTION: Demonstrates the use of the not_empty_in function to find domains where a FiniteSet intersected with an Interval is not empty. This is useful for dealing with symbolic parameters in equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, FiniteSet, Interval, not_empty_in, sqrt, oo\n>>> from sympy.abc import x\n>>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)\nInterval(0, 2)\n>>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)\nUnion(Interval(1, 2), Interval(-sqrt(2), -1))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SymPy Matrix Slices are Copies in Python\nDESCRIPTION: Shows that slicing a SymPy `Matrix` creates a copy, not a view. A full slice `M[:, :]` is assigned to `M2`. Modifying an element in `M2` (`M2[0, 0] = 100`) does not affect the original matrix `M`. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> M2 = M[:, :]\n>>> M2[0, 0] = 100\n>>> M[0, 0] == 100\nFalse\n```\n\n----------------------------------------\n\nTITLE: Using R Code Printer in SymPy\nDESCRIPTION: Example showing how to use print_rcode function to convert SymPy expressions to R code. This demonstrates printing expressions, assigning results to variables, and handling mathematical functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.printing import print_rcode\n>>> from sympy.functions import sin, cos, Abs\n>>> from sympy.abc import x\n>>> print_rcode(sin(x)**2 + cos(x)**2)\nsin(x)^2 + cos(x)^2\n>>> print_rcode(2*x + cos(x), assign_to=\"result\")\nresult = 2*x + cos(x);\n>>> print_rcode(Abs(x**2))\nabs(x^2)\n```\n\n----------------------------------------\n\nTITLE: Converting Python Objects to SymPy with Assumptions\nDESCRIPTION: Shows how to convert regular Python objects to SymPy objects to use the assumptions system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import S\nx = 2\nx = S(2)\ntype(x)\nx.is_positive\n```\n\n----------------------------------------\n\nTITLE: Piecewise Integration Method Implementation in SymPy\nDESCRIPTION: Internal method for evaluating integrals of piecewise functions in SymPy's elementary functions module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/functions/elementary.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n_eval_integral\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for MutableSparseMatrix Class (reStructuredText)\nDESCRIPTION: This Sphinx `autoclass` directive instructs the documentation generator to include documentation for the `MutableSparseMatrix` class from the default module (`sympy.matrices.sparse`). The `:members:` option ensures that documentation for the class's public members is also included.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparse.rst#2025-04-22_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: MutableSparseMatrix\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Using Expression-Dependent Methods in SymPy Vector\nDESCRIPTION: This snippet demonstrates the use of methods that depend on the coordinate system being used, such as 'to_matrix' for vectors and 'express_coordinates' for points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/coordsys.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nP = R.origin.locate_new('P', a*R.i + b*R.j + c*R.k)\nP.express_coordinates(N)\nP.express_coordinates(R)\nv = N.i + N.j + N.k\nv.to_matrix(M)\nv.to_matrix(N)\n```\n\n----------------------------------------\n\nTITLE: Creating a New Git Branch for SymPy Development\nDESCRIPTION: Git commands for creating a new branch after pulling upstream changes. This ensures your development branch starts from the latest master and keeps your changes isolated.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Pull any upstream changes from the main SymPy repo first\ngit checkout master\ngit pull\n\ngit branch <your-branch-name>\ngit checkout <your-branch-name>\n```\n\n----------------------------------------\n\nTITLE: Versin Function Usage Examples\nDESCRIPTION: Shows example usage of the versin function with different pi multiples and demonstrates automatic evaluation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> versin(pi)\n2\n>>> versin(2*pi)\n0\n```\n\n----------------------------------------\n\nTITLE: Controlling solve()'s Output Format for High-Degree Polynomials in SymPy\nDESCRIPTION: Example demonstrating how to control the output of solve() for higher-degree polynomials. By setting quartics=False, solve() returns RootOf objects instead of complex radical expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve\n>>> from sympy.abc import x\n>>> # By default, solve() uses the radical formula, yielding very complex terms\n>>> solve(x**4 - x + 1, x)\n[-sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3))/2 - sqrt(-2*(1/16 + sqrt(687)*I/144)**(1/3) - 2/sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3)) - 2/(3*(1/16 + sqrt(687)*I/144)**(1/3)))/2,\n sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3))/2 - sqrt(-2*(1/16 + sqrt(687)*I/144)**(1/3) + 2/sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3)) - 2/(3*(1/16 + sqrt(687)*I/144)**(1/3)))/2,\n sqrt(-2*(1/16 + sqrt(687)*I/144)**(1/3) - 2/sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3)) - 2/(3*(1/16 + sqrt(687)*I/144)**(1/3)))/2 - sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3))/2,\n sqrt(-2*(1/16 + sqrt(687)*I/144)**(1/3) + 2/sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3)) - 2/(3*(1/16 + sqrt(687)*I/144)**(1/3)))/2 + sqrt(2/(3*(1/16 + sqrt(687)*I/144)**(1/3)) + 2*(1/16 + sqrt(687)*I/144)**(1/3))/2]\n>>> # If you set quartics=False, solve() uses RootOf()\n>>> solve(x**4 - x + 1, x, quartics=False)\n[CRootOf(x**4 - x + 1, 0),\n CRootOf(x**4 - x + 1, 1),\n CRootOf(x**4 - x + 1, 2),\n CRootOf(x**4 - x + 1, 3)]\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for smith_normal_form using reST autofunction\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the Python function `smith_normal_form`. It pulls the signature and docstring from the specified function within the current module (`sympy.matrices.normalforms`), rendering it as part of the final documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/normalforms.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: smith_normal_form\n```\n\n----------------------------------------\n\nTITLE: Solving Holonomic Constraints for Consistent Initial Configuration\nDESCRIPTION: Uses SciPy's fsolve to find consistent values for the dependent coordinates based on the independent lever angle. This ensures the initial configuration satisfies the geometric constraints of the system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from scipy.optimize import fsolve\n\n>>> q_vals = np.array([\n...     np.deg2rad(5.0),  # q1 [rad]\n...     np.deg2rad(-10.0),  # q2 [rad]\n...     np.deg2rad(0.0),  # q3 [rad]\n...     np.deg2rad(75.0),  # q4 [rad]\n... ])\n...\n\n>>> def eval_holo_fsolve(x):\n...     q1 = q_vals[0]  # specified\n...     q2, q3, q4 = x\n...     return eval_holonomic((q1, q2, q3, q4), p_vals).squeeze()\n...\n\n>>> q_vals[1:] = fsolve(eval_holo_fsolve, q_vals[1:])\n\n>>> np.rad2deg(q_vals)\n[ 5.         -0.60986636  9.44918589 88.68812842]\n```\n\n----------------------------------------\n\nTITLE: Uploading SymPy Release to GitHub\nDESCRIPTION: This command uses rever to create a GitHub release for the specified version and upload the release files. It requires GitHub authentication.\nSOURCE: https://github.com/sympy/sympy/blob/master/release/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrever VERSION -a GitHub_release\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymPy Hilbert Module using Sphinx\nDESCRIPTION: This Sphinx directive instructs the documentation generator (Sphinx with the autodoc extension) to automatically include documentation for all public members (:members:) found within the specified Python module 'sympy.physics.quantum.hilbert'. This relies on the module's docstrings and the overall Sphinx project configuration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/hilbert.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.quantum.hilbert\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Working with Powers in SymPy\nDESCRIPTION: Demonstrates how power expressions are represented internally using the Pow class\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsrepr(x**2)\nPow(x, 2)\n```\n\n----------------------------------------\n\nTITLE: Accessing Polynomial Internal Representation in SymPy\nDESCRIPTION: This snippet shows how to access the internal representation of a Poly object including its domain and coefficient representation. It demonstrates the relationship between the polynomial domain and the implementation of coefficients.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> p = Poly(x**2 + x/2)\n>>> p\nPoly(x**2 + 1/2*x, x, domain='QQ')\n>>> p.domain\nQQ\n>>> p.rep  # doctest: +SKIP\nDMP_Python([1, 1/2, 0], QQ)\n>>> p.rep.rep  # doctest: +SKIP\n[1, 1/2, 0]\n>>> type(p.rep.rep[0])  # doctest: +SKIP\n<class 'sympy.external.pythonmpq.PythonMPQ'>\n```\n\n----------------------------------------\n\nTITLE: Attempting to Find Exact Roots of a Quintic Polynomial with roots\nDESCRIPTION: Shows that the `roots` function may return an empty dictionary `{}` for higher-order polynomials (like this quintic) because it cannot express all roots in radicals (due to the Abel-Ruffini theorem).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> roots(fifth_order, x)\n{}\n```\n\n----------------------------------------\n\nTITLE: Converting and Working with Elements in a Local Ring\nDESCRIPTION: Shows how to convert ordinary SymPy objects into objects understood by the AGCA module, and demonstrates how the relation y^2 = x^3 is automatically enforced in the ring.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> X, Y = lr.convert(x), lr.convert(y) ; X\n    ╱   3    2╲\nx + ╲- x  + y ╱\n\n>>> x**3 == y**2\nFalse\n\n>>> X**3 == Y**2\nTrue\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing with User-Defined Functions\nDESCRIPTION: Examples showing how fcode handles user-defined functions and unsupported functions in Fortran. This demonstrates various options for controlling function naming and error handling.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fcode(1 - gamma(x)**2, user_functions={'gamma': 'mygamma'}))\n      1 - mygamma(x)**2\n>>> print(fcode(1 - gamma(x)**2, strict=False))\nC     Not supported in Fortran:\nC     gamma\n      1 - gamma(x)**2\n>>> print(fcode(1 - gamma(x)**2, allow_unknown_functions=True))\n      1 - gamma(x)**2\n```\n\n----------------------------------------\n\nTITLE: Setting Up Muscle Excitation Inputs in SymPy\nDESCRIPTION: Creates a symbolic matrix representing the excitation inputs for biceps and triceps muscles. The excitation inputs serve as the control signals that will drive the muscle activation dynamics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> e = biceps.r.col_join(triceps.r)\n>>> e\nMatrix([\n[ e_biceps(t)],\n[e_triceps(t)]])\n```\n\n----------------------------------------\n\nTITLE: Warning Example for Invalid Cross-References\nDESCRIPTION: Example showing warning message format when Sphinx encounters invalid cross-references in documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nWARNING: py:obj reference target not found: expand\n```\n\n----------------------------------------\n\nTITLE: Solving a Complex Beam Problem with Multiple Supports in Python\nDESCRIPTION: This code demonstrates solving a more complex beam problem with multiple supports, point loads, and moments using SymPy's Beam class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.continuum_mechanics.beam import Beam\nfrom sympy import symbols\nE, I = symbols('E, I')\nR1, R2 = symbols('R1, R2')\nb = Beam(30, E, I)\nb.apply_load(8, 0, -1)\nb.apply_load(R1, 10, -1)\nb.apply_load(R2, 30, -1)\nb.apply_load(120, 30, -2)\nb.bc_deflection.append((10, 0))\nb.bc_deflection.append((30, 0))\nb.solve_for_reaction_loads(R1, R2)\nprint(b.reaction_loads)\nprint(b.load)\nprint(b.shear_force())\nprint(b.bending_moment())\nprint(b.slope())\nprint(b.deflection())\n```\n\n----------------------------------------\n\nTITLE: SOLVE Command Implementation\nDESCRIPTION: Demonstrates how the Autolev SOLVE command is implemented in SymPy, including handling of solution indexing.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/autolev_parser.rst#2025-04-22_snippet_5\n\nLANGUAGE: autolev\nCODE:\n```\nSOLVE(ZERO,X,Y)\nA = RHS(X)*2 + RHS(Y)\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(sm.solve(zero,x,y))\n# Behind the scenes the rhs of x\n# is set to sm.solve(zero,x,y)[x].\na = sm.solve(zero,x,y)[x]*2 + sm.solve(zero,x,y)[y]\n```\n\n----------------------------------------\n\nTITLE: Setting potential energy for Particle and RigidBody (Python)\nDESCRIPTION: Demonstrates the new way of setting potential energy for Particle and RigidBody objects using property assignment, replacing the deprecated set_potential_energy() method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nP.potential_energy = scalar\n```\n\n----------------------------------------\n\nTITLE: Demonstrating TR10i Function for Collecting Sin-Cos Arguments\nDESCRIPTION: Example showing how TR10i transform recognizes and simplifies terms in the form cos(x)*cos(y) + sin(x)*sin(y) to cos(x-y). The transformation requires the expression to be in a suitable form for recognition.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.simplify.fu import fu, L, TR9, TR10i, TR11\n>>> from sympy import factor, sin, cos, powsimp\n>>> from sympy.abc import x, y, z, a\n>>> from time import time\n\n>>> eq = cos(x + y)/cos(x)\n>>> TR10i(eq.expand(trig=True))\n-sin(x)*sin(y)/cos(x) + cos(y)\n\n>>> TR10i(_.normal())\ncos(x + y)/cos(x)\n```\n\n----------------------------------------\n\nTITLE: Running Code Quality Checks in SymPy\nDESCRIPTION: Commands to run code quality checks locally before submitting a pull request. These checks verify that the code meets SymPy's style and quality standards.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./bin/test quality\nflake8 sympy/\n```\n\n----------------------------------------\n\nTITLE: Applying Loads to Rigid Bodies\nDESCRIPTION: Shows how to apply forces and torques to rigid bodies. When a rigid body is specified, the force is applied to its center of mass and the torque to its associated frame.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import RigidBody\n>>> rb = RigidBody('rb')\n>>> Force(rb, 3 * N.x)\n(rb_masscenter, 3*N.x)\n>>> Torque(rb, 4 * N.x)\n(rb_frame, 4*N.x)\n```\n\n----------------------------------------\n\nTITLE: Splitting SymPy Integrand into Two Factors for G-Function Representation\nDESCRIPTION: Internal SymPy function used when attempting to represent an integrand `f` as a product of *two* Meijer G-functions. It finds inequivalent ways to split `f` into `f1*f2`, prioritizing splits that minimize powers and distinct functions within each factor.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n_mul_as_two_parts(f)\n```\n\n----------------------------------------\n\nTITLE: Function Autodoc Declarations in RST\nDESCRIPTION: Sphinx autodoc declarations for utility functions related to integration curves, metrics, and geometric transformations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/diffgeom.rst#2025-04-22_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: intcurve_series\n\n.. autofunction:: intcurve_diffequ\n\n.. autofunction:: vectors_in_basis\n\n.. autofunction:: twoform_to_matrix\n\n.. autofunction:: metric_to_Christoffel_1st\n\n.. autofunction:: metric_to_Christoffel_2nd\n\n.. autofunction:: metric_to_Riemann_components\n\n.. autofunction:: metric_to_Ricci_components\n```\n\n----------------------------------------\n\nTITLE: Evaluating System Dynamics Numerically in Python\nDESCRIPTION: Demonstrates how to use the lambdified functions to evaluate the system's dynamics given specific state and parameter values. Returns the mass matrix, forcing vector, and muscle activation derivatives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> eval_diffeq(q_vals, u_vals, a_vals, e_vals, p_vals)\n([[ 0.00333333 -0.15174161 -0.00109772 -0.00152436]\n [ 0.19923894  0.31       -0.04923615  0.00996712]\n [ 0.01743115  0.          0.29585191  0.0011276 ]\n [ 0.         -0.29256885 -0.0005241  -0.29983226]], [[-0.9121071]\n [ 0.       ]\n [-0.       ]\n [ 0.       ]], [[0.]\n [0.]])\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Combinatorics Module in reStructuredText\nDESCRIPTION: This snippet defines the table of contents for the Combinatorics module documentation using reStructuredText syntax. It includes links to various submodules and topics related to combinatorics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _combinatiorics-docs:\n\n=============\nCombinatorics\n=============\n\nContents\n========\n\n.. toctree::\n   :titlesonly:\n\n   partitions.rst\n   permutations.rst\n   perm_groups.rst\n   polyhedron.rst\n   prufer.rst\n   subsets.rst\n   graycode.rst\n   named_groups.rst\n   galois.rst\n   group_numbers.rst\n   util.rst\n   group_constructs.rst\n   testutil.rst\n   tensor_can.rst\n   fp_groups.rst\n   pc_groups.rst\n```\n\n----------------------------------------\n\nTITLE: Testing Residue Function Regression in Python\nDESCRIPTION: Regression test example checking residue calculations for complex functions, specifically testing the residue() function and ensuring consistent results between different computational approaches.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef test_issue_21177():\n    r = -sqrt(3)*tanh(sqrt(3)*pi/2)/3\n    a = residue(cot(pi*x)/((x - 1)*(x - 2) + 1), x, S(3)/2 - sqrt(3)*I/2)\n    b = residue(cot(pi*x)/(x**2 - 3*x + 3), x, S(3)/2 - sqrt(3)*I/2)\n    assert a == r\n    assert (b - a).cancel() == 0\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Number Theory Module in reStructuredText\nDESCRIPTION: This snippet defines the table of contents for the Number Theory module documentation using reStructuredText directives. It includes a link to the main ntheory.rst file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/numbertheory/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _numtheory_module:\n\n===============\nNumber Theory\n===============\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/ntheory.rst\n```\n\n----------------------------------------\n\nTITLE: Forcing Field Domain Construction in Python using SymPy\nDESCRIPTION: Shows how to use the field=True option in construct_domain to force the construction of a field domain, even when expressions can be represented in a non-field ring.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> construct_domain([1, 2], field=True)[0]\nQQ\n>>> construct_domain([2*x, 3], field=True)[0]\nZZ(x)\n>>> construct_domain([x/2, 3], field=True)[0]\nZZ(x)\n>>> construct_domain([2/x, 3], field=True)[0]\nZZ(x)\n>>> construct_domain([x, y], field=True)[0]\nZZ(x,y)\n```\n\n----------------------------------------\n\nTITLE: Domain Element Type Checking in SymPy\nDESCRIPTION: Shows how to properly check types of domain elements and convert between domain elements and sympy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> z = ZZ(2)\n>>> type(z)  # doctest: +SKIP\n<class 'int'>\n>>> ZZ.dtype  # doctest: +SKIP\n<class 'int'>\n>>> ZZ.of_type(z)\nTrue\n```\n\n----------------------------------------\n\nTITLE: LaTeX Printing Example for Divides Function in Python\nDESCRIPTION: Demonstrates the custom LaTeX printing for the divides function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nprint(latex(divides(m, n)))\n```\n\n----------------------------------------\n\nTITLE: Comparing Symbolic Booleans with Python Booleans\nDESCRIPTION: This snippet demonstrates the difference between SymPy's symbolic Booleans and Python's built-in booleans using the 'is' operator.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import S\n>>> xpos.is_positive is True\nTrue\n>>> xpos.is_positive is S.true\nFalse\n>>> (xpos > 0) is True\nFalse\n>>> (xpos > 0) is S.true\nTrue\n```\n\n----------------------------------------\n\nTITLE: Initializing Parameter Values for Muscle-actuated System Simulation\nDESCRIPTION: Defines numerical values for system parameters including dimensions, masses, gravity, stiffness, damping, and muscle properties. These values are used in the numerical simulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n\n>>> p_vals = np.array([\n...     0.31,  # dx [m]\n...     0.15,  # dy [m]\n...     -0.31,  # dz [m]\n...     0.2,   # lA [m]\n...     0.3,  # lC [m]\n...     0.3,  # lD [m]\n...     1.0,  # mA [kg]\n...     2.3,  # mC [kg]\n...     1.7,  # mD [kg]\n...     9.81,  # g [m/s/s]\n...     5.0,  # k [Nm/rad]\n...     0.5,  # c [Nms/rad]\n...     0.03,  # r [m]\n...     500.0,  # biceps F_M_max [?]\n...     0.6*0.3,  # biceps l_M_opt [?]\n...     0.55*0.3,  # biceps l_T_slack [?]\n...     500.0,  # triceps F_M_max [?]\n...     0.6*0.3,  # triceps l_M_opt [?]\n...     0.65*0.3,  # triceps l_T_slack [?]\n... ])\n...\n```\n\n----------------------------------------\n\nTITLE: Motion Variables Declaration Example\nDESCRIPTION: Demonstrates how motion variables are declared in both Autolev and their equivalent SymPy code, including kinematic differential equations setup.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/autolev_parser.rst#2025-04-22_snippet_3\n\nLANGUAGE: autolev\nCODE:\n```\nMOTIONVARIABLES' Q{2}', U{2}'\n% ----- OTHER LINES ----\nQ1' = U1\nQ2' = U2\n----- OTHER LINES ----\nZERO = FR() + FRSTAR()\n```\n\nLANGUAGE: python\nCODE:\n```\nq1, q2, u1, u2 = me.dynamicsymbols('q1 q2 u1 u2')\nq1d, q2d, u1d, u2d = me.dynamicsymbols('q1 q2 u1 u2', 1)\n\n# ------- other lines -------\n\nkd_eqs = [q1d - u1, q2d - u2]\nkane = me.KanesMethod(frame_n, q_ind=[q1,q2], u_ind=[u1, u2], kd_eqs = kd_eqs)\nfr, frstar = kane.kanes_equations([particle_p, particle_r], forceList)\nzero = fr+frstar\n```\n\n----------------------------------------\n\nTITLE: Importing Euclidean Algorithm Functions\nDESCRIPTION: This snippet shows the autofunction directives for importing functions related to the Euclidean algorithm and its variants for polynomial GCD computation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: dmp_half_gcdex\n.. autofunction:: dmp_gcdex\n.. autofunction:: dmp_invert\n.. autofunction:: dmp_euclidean_prs\n```\n\n----------------------------------------\n\nTITLE: Creating a Coordinate Ring of Affine Space\nDESCRIPTION: Demonstrates creating the coordinate ring of three-dimensional affine space A^3 over the rational numbers without any quotient relations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> ar = QQ.old_poly_ring(x, y, z); ar\nℚ[x, y, z]\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for banded (reStructuredText)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `automethod` to automatically pull documentation for the `sympy.matrices.sparsetools.banded` method. This SymPy function is likely used to construct a banded sparse matrix based on specified diagonals or bandwidth.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparsetools.rst#2025-04-22_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automethod:: sympy.matrices.sparsetools::banded\n```\n\n----------------------------------------\n\nTITLE: Viewing All Git Branches\nDESCRIPTION: Command to list all git branches with the current branch highlighted, useful for tracking your development workspace in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit branch\n```\n\n----------------------------------------\n\nTITLE: Hypergeometric Differential Equation Derivation\nDESCRIPTION: The mathematical derivation of the hypergeometric differential equation. This equation is fundamental for manipulating hypergeometric functions through differential operators.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/hyperexpand.rst#2025-04-22_snippet_1\n\nLANGUAGE: mathematical notation\nCODE:\n```\n\\left[ z\\frac{\\mathrm{d}}{dz} \\prod_{j=1}^q \\left(z\\frac{\\mathrm{d}}{dz} + b_j-1 \\right) - z \\prod_{i=1}^p \\left( z\\frac{\\mathrm{d}}{\\mathrm{d}z} + a_i \\right) \\right] {}_p F_q\\left({a_p \\atop b_q} \\middle| z\\right) = 0\n```\n\n----------------------------------------\n\nTITLE: Silencing SymPy Deprecation Warnings Using Python's warnings Module\nDESCRIPTION: This code shows how to use Python's warnings module to suppress SymPy deprecation warnings. It demonstrates the proper way to filter specific warnings by message and module scope, with optional regex patterns to target specific messages.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\nfrom sympy.utilities.exceptions import SymPyDeprecationWarning\n\nwarnings.filterwarnings(\n    # replace \"ignore\" with \"error\" to make the warning raise an exception.\n    # This useful if you want to test you aren't using deprecated code.\n    \"ignore\",\n\n    # message may be omitted to filter all SymPyDeprecationWarnings\n    message=r\"(?s).*<regex matching the warning message>\",\n\n    category=SymPyDeprecationWarning,\n    module=r\"<regex matching your module>\"\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymPy's Timing Utilities Module\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the sympy.utilities.timeutils module. This approach ensures comprehensive documentation of the module's functions and classes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/timeutils.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.utilities.timeutils\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Algebraically Dependent Generators Example\nDESCRIPTION: Illustrates potential issues when using algebraically dependent generators in polynomial construction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import sin, cos, sqrt\nPoly(x*exp(x))\nPoly(sin(x)+cos(x))\nPoly(x + sqrt(x))\np1 = Poly(x, x, sqrt(x))\np2 = Poly(sqrt(x), x, sqrt(x))\np3 = p1 - p2**2\np3\np3.as_expr()\n```\n\n----------------------------------------\n\nTITLE: Module Reference - Tensor Canonicalization\nDESCRIPTION: RestructuredText directive defining the documentation module reference for tensor canonicalization functions\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/tensor_can.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. module:: sympy.combinatorics.tensor_can\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for ImmutableSparseMatrix Class (reStructuredText)\nDESCRIPTION: This Sphinx `autoclass` directive instructs the documentation generator to include documentation for the `ImmutableSparseMatrix` class, explicitly specifying its full path `sympy.matrices.immutable::ImmutableSparseMatrix`. The `:members:` option ensures documentation for its public members is also included.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparse.rst#2025-04-22_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: sympy.matrices.immutable::ImmutableSparseMatrix\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Initializing Expression Domain (EX) in Python using SymPy\nDESCRIPTION: Demonstrates how to create an Expression Domain (EX) element from a SymPy expression. EX is used as a fallback when no other domain is appropriate.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import EX\n>>> p = EX.from_sympy(1 + x)\n>>> p\nEX(x + 1)\n>>> type(p)\n<class 'sympy.polys.domains.expressiondomain.ExpressionDomain.Expression'>\n>>> p.ex\nx + 1\n>>> type(p.ex)\n<class 'sympy.core.add.Add'>\n```\n\n----------------------------------------\n\nTITLE: Kinematic Calculations in SymPy\nDESCRIPTION: Illustrates various kinematic calculations in SymPy, including velocity and acceleration of points in different reference frames.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nQ.v1pt_theory(P, A, B)\n```\n\nLANGUAGE: python\nCODE:\n```\nQ.v2pt_theory(P, A, B)\n```\n\nLANGUAGE: python\nCODE:\n```\nQ.a1pt_theory(P, A, B)\n```\n\nLANGUAGE: python\nCODE:\n```\nQ.a2pt_theory(P, A, B)\n```\n\nLANGUAGE: python\nCODE:\n```\nB.ang_vel_in(A)\n```\n\n----------------------------------------\n\nTITLE: Linking to Physics Tutorial in reStructuredText\nDESCRIPTION: This snippet creates a reference to the physics tutorial using reStructuredText syntax. It includes a hidden toctree directive for the physics tutorial's index file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n:ref:`Physics Tutorial <physics_tutorials>`\n===========================================\n\nFor physics features in SymPy, start here.\n\n.. toctree::\n   :hidden:\n\n   physics/index.rst\n```\n\n----------------------------------------\n\nTITLE: Creating Free Modules and Submodules\nDESCRIPTION: Shows how to create a free module of rank 4 over a polynomial ring and define a submodule within it using basis elements represented as Python lists.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> F = ar.free_module(4) ; F\n          4\nℚ[x, y, z]\n\n>>> S = F.submodule([1, x, x**2, x**3], [0, 1, 0, y]) ; S\n╱⎡       2   3⎤              ╲\n╲⎣1, x, x , x ⎦, [0, 1, 0, y]╱\n```\n\n----------------------------------------\n\nTITLE: Initializing Velocity and Activation States for System Simulation\nDESCRIPTION: Sets initial values for generalized speeds and muscle activation states to zero, representing a system at rest. These values define the initial velocity and activation conditions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> u_vals = np.array([\n...     0.0,  # u1, [rad/s]\n...     0.0,  # u2, [rad/s]\n...     0.0,  # u3, [rad/s]\n...     0.0,  # u4, [rad/s]\n... ])\n...\n\n>>> a_vals = np.array([\n...     0.0,  # a_bicep, nondimensional\n...     0.0,  # a_tricep, nondimensional\n... ])\n```\n\n----------------------------------------\n\nTITLE: Documenting Function Deprecation in Markdown\nDESCRIPTION: Example showing how to document a deprecated function in the active-deprecations.md file with proper formatting and explanations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n(simplify-this-deprecation)=\n### `simplify_this()`\n\nThe `sympy.simplify.simplify_this()` function is deprecated. It has been\nreplaced with the {func}`~.simplify` function. Code using `simplify_this()`\ncan be fixed by replacing `simplfiy_this(expr)` with `simplify(expr)`. The\nbehavior of the two functions is otherwise identical.\n\nThis change was made because `simplify` is a much more Pythonic name than\n`simplify_this`.\n```\n\n----------------------------------------\n\nTITLE: Setting Up Mechanical System in SymPy\nDESCRIPTION: Initializes the complete mechanical system with symbols, reference frames, points, and rigid bodies for energy calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import symbols\nfrom sympy.physics.mechanics import dynamicsymbols, ReferenceFrame, outer\nfrom sympy.physics.mechanics import RigidBody, Particle\nfrom sympy.physics.mechanics import kinetic_energy, potential_energy, Point\nfrom sympy.physics.vector import init_vprinting\ninit_vprinting(pretty_print=False)\nm, M, l1, g, h, H = symbols('m M l1 g h H')\nomega = dynamicsymbols('omega')\nN = ReferenceFrame('N')\nO = Point('O')\nO.set_vel(N, 0 * N.x)\nAc = O.locatenew('Ac', l1 * N.x)\nP = Ac.locatenew('P', l1 * N.x)\na = ReferenceFrame('a')\na.set_ang_vel(N, omega * N.z)\nAc.v2pt_theory(O, N, a)\nl1*omega*N.y\nP.v2pt_theory(O, N, a)\n2*l1*omega*N.y\nPa = Particle('Pa', P, m)\nI = outer(N.z, N.z)\nA = RigidBody('A', Ac, a, M, (I, Ac))\n```\n\n----------------------------------------\n\nTITLE: Power Nesting with powdenest\nDESCRIPTION: Demonstrates the use of powdenest function for handling nested power expressions, showing both default behavior and forced nesting.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npowdenest((z**a)**b)\npowdenest((z**a)**b, force=True)\n```\n\n----------------------------------------\n\nTITLE: Example of Function Documentation with Parameters\nDESCRIPTION: Demonstrates proper documentation format for a function including parameters section with types and descriptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef opt_cse(exprs, order='canonical'):\n    \"\"\"\n    Find optimization opportunities in Adds, Muls, Pows and negative\n    coefficient Muls.\n\n    Parameters\n    ==========\n\n    exprs : list of sympy expressions\n        The expressions to optimize.\n    order : string, 'none' or 'canonical'\n        The order by which Mul and Add arguments are processed. For large\n        expressions where speed is a concern, use the setting order='none'.\n\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Right-Hand Side of Activation Differential Equation\nDESCRIPTION: Gets the right-hand side of the differential equation that governs muscle activation dynamics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle_activation.rhs()\nMatrix([[((1/2 - tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2)/(0.0225*a_muscle(t) + 0.0075) + 16.6666666666667*(3*a_muscle(t)/2 + 1/2)*(tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2 + 1/2))*(-a_muscle(t) + e_muscle(t))]])\n```\n\n----------------------------------------\n\nTITLE: Running Docker Live Server for Auto-Rebuilding Documentation\nDESCRIPTION: Commands to start a live server using Docker that monitors document changes, rebuilds automatically, and reloads the browser. Includes options for both interactive and detached modes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it \\\n     -v /absolute/path/to/sympy:/sympy \\\n     -p 8000:80 \\\n     sympy_htmldoc live\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -d --name=sympy-livehtml \\\n     -v /absolute/path/to/sympy:/sympy \\\n     -p 8000:80 \\\n     sympy_htmldoc live\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker stop sympy-livehtml\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated Behavior in Python with warns_deprecated_sympy\nDESCRIPTION: Example showing how to test deprecated functionality using the warns_deprecated_sympy context manager to verify deprecation warnings are emitted correctly.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.testing.pytest import warns_deprecated_sympy\n\nwith warns_deprecated_sympy():\n    <deprecated behavior>\n```\n\n----------------------------------------\n\nTITLE: Enabling SymPy Debug Mode in Windows\nDESCRIPTION: These commands set the SYMPY_DEBUG environment variable to True and start the interactive SymPy shell (isympy) in debug mode on Windows. This enables enhanced debugging features, such as printed trees for functions like limit().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/debug.rst#2025-04-22_snippet_1\n\nLANGUAGE: batch\nCODE:\n```\n> set SYMPY_DEBUG=True\n> python bin/isympy\n```\n\n----------------------------------------\n\nTITLE: Derivative Theorem for Vector Quantities in LaTeX\nDESCRIPTION: Presents the derivative theorem, which provides an alternative method to calculate the time derivative of a vector in a reference frame.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\frac{{}^{\\mathbf{N}} d \\mathbf{v}}{dt} = \\frac{{}^{\\mathbf{B}} d \\mathbf{v}}{dt} +{}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{B}} \\times \\mathbf{v}\n```\n\n----------------------------------------\n\nTITLE: Sphere Volume Calculation\nDESCRIPTION: Calculates volume of a solid sphere using parametric equations and triple integration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/vector_integration.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsolidsphere = ParametricRegion((r*sin(phi)*cos(theta),r*sin(phi)*sin(theta), r*cos(phi)),\n                            (phi, 0, pi), (theta, 0, 2*pi), (r, 0, 3))\nvector_integrate(1, solidsphere)\n```\n\n----------------------------------------\n\nTITLE: LaTeX Definition of Omega Parameters\nDESCRIPTION: Definition of omega parameters using complex exponential functions in LaTeX notation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_15\n\nLANGUAGE: latex\nCODE:\n```\n\\omega_{\\pm} = b e^{\\pm i \\Re(c) \\frac{\\pi}{2}}\n```\n\n----------------------------------------\n\nTITLE: Checking Deduced 'is_real' Assumption for 'versin' (Python)\nDESCRIPTION: Demonstrates that SymPy's assumption system can automatically deduce certain properties. Even though `_eval_is_real` was not explicitly defined for the `versin` function, `versin(1).is_real` correctly returns `True`. This is likely deduced from the `_eval_is_nonnegative` handler returning `True` for real inputs, and the general implication `nonnegative -> real`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> # Assuming 'versin' class is defined as before\n>>> versin(1).is_real\nTrue\n```\n\n----------------------------------------\n\nTITLE: Defining Curve Module Documentation in RST\nDESCRIPTION: Sphinx documentation directives for the Curve class in SymPy's geometry module. Sets up module reference and auto-documentation for the Curve class with its members.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/geometry/curves.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. module:: sympy.geometry.curve\n\n.. autoclass:: Curve\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy from Conda Forge\nDESCRIPTION: This command installs the Conda Forge version of SymPy, which is typically updated faster than the Anaconda distribution version.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nconda install --channel conda-forge sympy\n```\n\n----------------------------------------\n\nTITLE: Using Reidemeister Presentation in SymPy for Subgroup Generation\nDESCRIPTION: Demonstrates how to use the reidemeister_presentation function to find presentations of subgroups. Takes a group G and a list of generators Y as input, and returns a tuple containing generators and relations for the subgroup presentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/fp_groups.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.fp_groups import reidemeister_presentation\nF, x, y = free_group(\"x, y\")\nf = FpGroup(F, [x**3, y**5, (x*y)**2])\nH = [x*y, x**-1*y**-1*x*y*x]\np1 = reidemeister_presentation(f, H)\np1\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Unpacking with Lambda in Python\nDESCRIPTION: Demonstrates the new way of using Lambda with tuple unpacking in SymPy. This allows for more flexible argument handling in Lambda expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Lambda, symbols\n>>> x, y, z = symbols('x y z')\n>>> f = Lambda((x, (y, z)), x + y + z)\n>>> f(1, (2, 3))\n6\n```\n\n----------------------------------------\n\nTITLE: Automating Module Documentation Using Sphinx in reStructuredText\nDESCRIPTION: This snippet uses the .. automodule:: directive in reStructuredText to automatically include the members of the sympy.physics.quantum.represent Python module in the generated documentation. This requires the Sphinx documentation generator as a dependency and expects the specified Python module to be importable within the documentation build environment. It takes no user-supplied parameters but generates API documentation for all module members, streamlining ongoing documentation efforts. No inputs or outputs are produced at runtime, as this is a documentation configuration file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/represent.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.physics.quantum.represent\\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Deprecated: Mixing Poly and non-polynomial expressions (Python)\nDESCRIPTION: Shows the deprecated way of combining Poly with Expr objects using binary operations, and suggests alternatives using as_poly() or as_expr() methods.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nPoly(x)*sin(x) # DEPRECATED\n```\n\n----------------------------------------\n\nTITLE: SymPy Set Operations and Kind Incompatibility\nDESCRIPTION: Demonstrates the incompatibility between SymPy's Set objects and the kind system. While sets can check subset relationships, they cannot interact directly with kind objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import S\n>>> from sympy.core.kind import NumberKind\n>>> S.Reals.is_subset(S.Complexes)\nTrue\n>>> S.Reals.is_subset(NumberKind)\nTraceback (most recent call last):\n...\nValueError: Unknown argument 'NumberKind'\n```\n\n----------------------------------------\n\nTITLE: Using roots with strict=True for Unsolvable Polynomials\nDESCRIPTION: Demonstrates that calling `roots` with the `strict=True` flag will raise an `UnsolvableFactorError` if the function cannot find a complete list of roots expressible in radicals for the given polynomial.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> roots(x**5 - x + 1, x, strict=True)\nTraceback (most recent call last):\n...\nsympy.polys.polyerrors.UnsolvableFactorError: Strict mode: some factors cannot be solved in radicals, so a complete\nlist of solutions cannot be returned. Call roots with strict=False to\nget solutions expressible in radicals (if there are any).\n```\n\n----------------------------------------\n\nTITLE: Working with Dynamic Symbols and Time Variables\nDESCRIPTION: Demonstrates the configuration of dynamic symbols including time variable customization and derivative notation settings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/advanced.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.physics.vector import dynamicsymbols, vprint\n>>> q1 = dynamicsymbols('q1')\n>>> q1\nq1(t)\n>>> dynamicsymbols._t = symbols('T')\n>>> q2 = dynamicsymbols('q2')\n>>> q2\nq2(T)\n>>> q1\nq1(t)\n>>> q1d = dynamicsymbols('q1', 1)\n>>> vprint(q1d)\nq1'\n>>> dynamicsymbols._str = 'd'\n>>> vprint(q1d)\nq1d\n>>> dynamicsymbols._str = '\\''\n>>> dynamicsymbols._t = symbols('t')\n```\n\n----------------------------------------\n\nTITLE: Documenting Dyadic Class in SymPy Physics Vector Module\nDESCRIPTION: Autodoc directive for the Dyadic class from sympy.physics.vector.dyadic module. It includes all members of the class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/vector/api/classes.rst#2025-04-22_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: sympy.physics.vector.dyadic.Dyadic\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Piecewise Expression Functions in SymPy\nDESCRIPTION: Helper functions for handling piecewise expressions including exclusive conditions and folding operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/functions/elementary.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\npiecewise_exclusive\npiecewise_fold\n```\n\n----------------------------------------\n\nTITLE: Documenting SymPy Control Module Index in reStructuredText\nDESCRIPTION: This snippet provides the reST syntax for the main index of SymPy's physics.control module documentation. It sets a section header, references the Python module, includes an abstract, and creates a toctree for navigation to related documentation files. Dependencies include Sphinx (for directive support) and the relevant .rst files (control.rst, lti.rst, control_plots.rst). The file is intended to be used as the top-level entry for module documentation. Inputs are static doc directives; no outputs except rendered documentation. No code execution occurs within this documentation context.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/control/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n=======\nControl\n=======\n\n.. module:: sympy.physics.control\n\n.. topic:: Abstract\n\n    Contains docstrings of Physics-Control module\n\n\n.. toctree::\n   :titlesonly:\n\n   control.rst\n   lti.rst\n   control_plots.rst\n\n```\n\n----------------------------------------\n\nTITLE: RST Module Declaration for SymPy Functions\nDESCRIPTION: ReStructuredText directive declaring the sympy.functions module and documenting autoclass inheritance from Function base class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/functions/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.functions\n\n.. autoclass:: sympy.core.function.Function\n   :noindex:\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Building SymPy Documentation Locally\nDESCRIPTION: Commands to build the HTML documentation locally after installing the required dependencies. This uses the makefile in the doc subdirectory to generate HTML files.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd doc\n\nmake html\n```\n\n----------------------------------------\n\nTITLE: Defining automodule directive for sympy.abc in RestructuredText\nDESCRIPTION: Uses the automodule directive to automatically generate documentation for the sympy.abc module. This directive instructs documentation tools like Sphinx to include all documentation from the specified module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/abc.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.abc\n```\n\n----------------------------------------\n\nTITLE: Slicing Empty SymPy Matrices in Python\nDESCRIPTION: Demonstrates that slicing an empty SymPy `Matrix` (e.g., one created with 0 rows) works correctly, returning an empty `Matrix`, provided a slice is used for the dimension with zero size. Example shows slicing column 1 from a 0x3 matrix. Requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/matrices.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> Matrix(0, 3, [])[:, 1]\n[]\n```\n\n----------------------------------------\n\nTITLE: Converting SymPy Expression to Aesara Function (Deprecated)\nDESCRIPTION: Illustrates the basic usage of `aesara_function` to translate a SymPy expression into an Aesara computational graph. This feature is deprecated as of SymPy 1.14 and requires the Aesara library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/numeric-computation.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> from sympy.abc import x\n>>> expr = sin(x)/x\n\n>>> from sympy.printing.aesaracode import aesara_function\n>>> f = aesara_function([x], [expr])\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Commutative/Noncommutative Symbols in SymPy (Python)\nDESCRIPTION: This snippet demonstrates how to declare symbols in SymPy using `symbols` and `Symbol`. It specifically shows how to set the `commutative` flag to `False` for `x` and `y`, while `z` defaults to `commutative=True`. It then illustrates the effect of commutativity on multiplication: `x*y` does not commute with `y*x`, but `x*z` commutes with `z*x` because `z` is commutative.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> x, y = symbols('x, y', commutative=False)\n>>> z = Symbol('z')  # defaults to commutative=True\n>>> x*y + y*x\nx*y + y*x\n>>> x*z + z*x\n2*z*x\n```\n\n----------------------------------------\n\nTITLE: Creating State Variables and Coordinate/Speed Indexes\nDESCRIPTION: Defines the state variables of the system and specifies which indexes correspond to coordinates versus speeds, which allows SymbolicSystem to differentiate between them.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nstates = (x, y, u, v, lam)\ncoord_idxs = (0, 1)\nspeed_idxs = (2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Forces and Rigid Body for Kane's Method\nDESCRIPTION: This code sets up the force list, including constraint forces, and defines the rigid body for use in Kane's method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example_kane_constraints.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nForceList = [(Dmc, - m * g * Y.z), (C, f1 * L.x + f2 * cross(Y.z, L.x) + f3 * Y.z)]\nBodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\nBodyList = [BodyD]\n```\n\n----------------------------------------\n\nTITLE: Documenting ReferenceFrame Class in SymPy Physics Vector Module\nDESCRIPTION: Autodoc directive for the ReferenceFrame class from sympy.physics.vector.frame module. It includes all members except 'orient_explicit'.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/vector/api/classes.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: sympy.physics.vector.frame.ReferenceFrame\n   :members:\n   :exclude-members: orient_explicit\n```\n\n----------------------------------------\n\nTITLE: Creating ProductSet from iterables (Python)\nDESCRIPTION: Shows the correct way to create a ProductSet from an iterable using unpacking, as opposed to the deprecated method of passing a single iterable.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ProductSet\n>>> sets = [{i} for i in range(3)]\n>>> ProductSet(*sets)\nProductSet({0}, {1}, {2})\n>>> ProductSet({1, 2}, {1})\nProductSet({1, 2}, {1})\n```\n\n----------------------------------------\n\nTITLE: Working with Unevaluated Derivatives\nDESCRIPTION: Shows how to create and work with unevaluated derivatives using the Derivative class and doit() method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nderiv = Derivative(expr, x, y, y, z, 4)\nderiv\nderiv.doit()\n```\n\n----------------------------------------\n\nTITLE: Finding Exact Symbolic Roots of a Quartic Polynomial with roots in SymPy\nDESCRIPTION: Shows how to find the exact symbolic roots of a fourth-order (quartic) polynomial using the SymPy `roots` function. The example highlights that the resulting symbolic expressions can be very complex. It implicitly uses the variable `x` defined via `from sympy.abc import x` or similar.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> rq0, rq1, rq2, rq3 = roots(x**4 + 3*x**2 + 2*x + 1)\n>>> rq0\nsqrt(-4 - 2*(-1/8 + sqrt(237)*I/36)**(1/3) + 4/sqrt(-2 + 7/(6*(-1/8 + sqrt(237)*I/36)**(1/3)) + 2*(-1/8 + sqrt(237)*I/36)**(1/3)) - 7/(6*(-1/8 + sqrt(237)*I/36)**(1/3)))/2 - sqrt(-2 + 7/(6*(-1/8 + sqrt(237)*I/36)**(1/3)) + 2*(-1/8 + sqrt(237)*I/36)**(1/3))/2\n```\n\n----------------------------------------\n\nTITLE: Defining RestructuredText Section for Classical Mechanics\nDESCRIPTION: Sets up the main section header for the Classical Mechanics documentation using RestructuredText syntax. It includes a reference label and a top-level header.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. _classical_mechanics_explanations:\n\n===================\nClassical Mechanics\n===================\n```\n\n----------------------------------------\n\nTITLE: Calculating Point Velocities for Bicycle Model in Python\nDESCRIPTION: Computes the velocities of various points on the bicycle using the 2-point theorem. This includes wheel contact points, centers of mass, and the steering connection.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> WR_cont.set_vel(N, 0)\n>>> WR_mc.v2pt_theory(WR_cont, N, WR)\n>>> Steer.v2pt_theory(WR_mc, N, Frame)\n>>> Frame_mc.v2pt_theory(WR_mc, N, Frame)\n>>> Fork_mc.v2pt_theory(Steer, N, Fork)\n>>> WF_mc.v2pt_theory(Steer, N, Fork)\n>>> WF_cont.v2pt_theory(WF_mc, N, WF)\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy via pip\nDESCRIPTION: This command installs SymPy using pip, the recommended Python package installer.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install sympy\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Public API in SymPy\nDESCRIPTION: Lists elements that are generally not considered part of SymPy's public API, which typically don't require deprecation notices when changed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```{admonition} Not Public API\n- The precise form of an expression. In general, functions may be changed to\n  return a different but mathematically equivalent form of the same\n  expression. This includes a function returning a value which it was not able\n  to compute previously.\n- Functions and methods that are private, i.e., for internal use only. Such\n  things should generally be prefixed with an underscore `_`, although this\n  convention is not currently universally adhered to in the SymPy codebase.\n- Anything explicitly marked as \"experimental\".\n- Changes to behavior that were mathematically incorrect previously (in\n  general, bug fixes are not considered breaking changes, because despite the\n  saying, bugs in SymPy are not features).\n- Anything that was added before the most recent release. Code that has not\n  yet made it into a release does not need to be deprecated. If you are going\n  to change the API of new code, it is best to do it before a release is made\n  so that no deprecations are necessary for future releases.\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python List Output Wrapping\nDESCRIPTION: Illustrates how line-wrapped output is handled in doctests using a range function example.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> list(range(30))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n21, 22, 23, 24, 25, 26, 27, 28, 29]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Issues with 'in' Operator for Symbolic Set Membership\nDESCRIPTION: This snippet shows how the 'in' operator can raise exceptions for indeterminate set membership, unlike the Contains class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import I\n>>> 2 in Reals\nTrue\n>>> I in Reals\nFalse\n>>> x in Reals\nTrue\n>>> y in Reals\nTraceback (most recent call last):\n...\nTypeError: did not evaluate to a bool: (-oo < y) & (y < oo)\n```\n\n----------------------------------------\n\nTITLE: Defining Tensor Module Structure in reStructuredText\nDESCRIPTION: This snippet outlines the structure of the Tensor module documentation using reStructuredText directives. It includes a module reference, section headers, and a table of contents linking to various submodules.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/tensor/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _tensor_module:\n\n======\nTensor\n======\n\n.. automodule:: sympy.tensor\n\nContents\n========\n\n.. toctree::\n   :titlesonly:\n\n   array.rst\n   array_expressions.rst\n   indexed.rst\n   index_methods.rst\n   tensor.rst\n   toperators.rst\n```\n\n----------------------------------------\n\nTITLE: Using Exact Symbolic Values in SymPy Instead of Python's Numeric Approximations\nDESCRIPTION: These examples demonstrate the difference between using exact symbolic values from SymPy (like pi) versus using Python's numerical approximations. Symbolic values preserve the exactness of solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, solve, pi\n>>> x = symbols('x')\n>>> solve(x**2 - pi, x, dict=True)\n[{x: -sqrt(pi)}, {x: sqrt(pi)}]\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, solve\n>>> from math import pi\n>>> x = symbols('x')\n>>> solve(x**2 - pi, x, dict=True)\n[{x: -1.77245385090552}, {x: 1.77245385090552}]\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, solve, sqrt\n>>> x = symbols('x')\n>>> eq = x**sqrt(2) - 2\n>>> solve(eq, x, dict=True)\n[{x: 2**(sqrt(2)/2)}]\n```\n\n----------------------------------------\n\nTITLE: Using SymPy S Object as Shorthand for sympify in Python\nDESCRIPTION: This snippet demonstrates using the SymPy `S` object as a callable shorthand for the `sympify()` function. `S(a)` is equivalent to `sympify(a)`, converting the input `a` (which could be a Python number, string, etc.) into an appropriate SymPy expression. This is often used to ensure numbers within expressions are SymPy types, avoiding potential issues with standard Python integer division. It requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/glossary.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nS(a)\n```\n\n----------------------------------------\n\nTITLE: Formatting LaTeX Math in SymPy Documentation\nDESCRIPTION: Shows the correct and incorrect ways to format LaTeX math expressions in SymPy documentation, emphasizing simplicity and readability.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/documentation-style-guide.rst#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\int \\sin(x)\\,dx\n```\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\int \\sin{\\left( x\\right)}\\, dx\n```\n\n----------------------------------------\n\nTITLE: Computing Matrix M Entries for Hypergeometric Expansion in SymPy\nDESCRIPTION: These code snippets calculate the entries of matrix M used in hypergeometric function expansion. They demonstrate the computation of derivatives for different basis elements B1 and B2 using SymPy's symbolic manipulation capabilities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/hyperexpand.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Symbol, cosh, sqrt, diff\nz = Symbol(\"z\")\nB1 = cosh(2*sqrt(z))\nz * diff(B1, z)\n```\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import Symbol, sinh, sqrt, expand, diff\nz = Symbol(\"z\")\nB2 = sinh(2*sqrt(z))*sqrt(z)\nexpand(z * diff(B2, z))\n```\n\n----------------------------------------\n\nTITLE: Citing SymPy Using BibTeX Format\nDESCRIPTION: BibTeX entry for citing SymPy in LaTeX documents. Includes full author list, publication details, DOI, and abstract for the 2017 PeerJ Computer Science paper.\nSOURCE: https://github.com/sympy/sympy/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bibtex\nCODE:\n```\n@article{10.7717/peerj-cs.103,\n title = {SymPy: symbolic computing in Python},\n author = {Meurer, Aaron and Smith, Christopher P. and Paprocki, Mateusz and \\v{C}ert\\'{i}k, Ond\\v{r}ej and Kirpichev, Sergey B. and Rocklin, Matthew and Kumar, Amit and Ivanov, Sergiu and Moore, Jason K. and Singh, Sartaj and Rathnayake, Thilina and Vig, Sean and Granger, Brian E. and Muller, Richard P. and Bonazzi, Francesco and Gupta, Harsh and Vats, Shivam and Johansson, Fredrik and Pedregosa, Fabian and Curry, Matthew J. and Terrel, Andy R. and Rou\\v{c}ka, \\v{S}t\\v{e}p\\'{a}n and Saboo, Ashutosh and Fernando, Isuru and Kulal, Sumith and Cimrman, Robert and Scopatz, Anthony},\n year = 2017,\n month = Jan,\n keywords = {Python, Computer algebra system, Symbolics},\n abstract = {\n            SymPy is an open-source computer algebra system written in pure Python. It is built with a focus on extensibility and ease of use, through both interactive and programmatic applications. These characteristics have led SymPy to become a popular symbolic library for the scientific Python ecosystem. This paper presents the architecture of SymPy, a description of its features, and a discussion of select submodules. The supplementary material provides additional examples and further outlines details of the architecture and features of SymPy.\n         },\n volume = 3,\n pages = {e103},\n journal = {PeerJ Computer Science},\n issn = {2376-5992},\n url = {https://doi.org/10.7717/peerj-cs.103},\n doi = {10.7717/peerj-cs.103}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Assumptions Queries on expreal() Instances in Python\nDESCRIPTION: This snippet shows various assumptions queries on instances of expreal(), demonstrating how the assumptions system resolves these queries using handlers and implication rules.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> expreal(2)\nexpreal(2)\n>>> expreal(2).is_finite\nTrue\n>>> expreal(2).is_integer\nFalse\n>>> expreal(2).is_rational\nFalse\n>>> expreal(2).is_algebraic\nFalse\n>>> z = expreal(-oo, evaluate=False)\n>>> z\nexpreal(-oo)\n>>> z.is_integer\nTrue\n>>> x = Symbol('x', real=True)\n>>> expreal(x)\nexpreal(x)\n>>> expreal(x).is_nonnegative\nTrue\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Deprecation in Python\nDESCRIPTION: Example demonstrating how to deprecate a function parameter with proper warning message and docstring updates.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef is_this_zero(x, y=0):\n    \"\"\"\n    Determine if x = 0.\n\n    Parameters\n    ==========\n\n    x : Expr\n      The expression to check.\n\n    y : Expr, optional\n      If provided, check if x = y.\n\n      .. deprecated:: 1.1\n\n         The ``y`` argument to ``is_this_zero`` is deprecated. Use\n         ``is_this_zero(x - y)`` instead. See\n         :ref:`is-this-zero-y-deprecated` for more details.\n\n    \"\"\"\n    if y != 0:\n        sympy_deprecation_warning(\"\"\"\\\nThe y argument to is_zero() is deprecated. Use is_zero(x - y) instead.\"\"\",\n            deprecated_since_version=\"1.1\",\n            active_deprecations_target='is-this-zero-y-deprecation')\n    return simplify(x - y) == 0\n```\n\n----------------------------------------\n\nTITLE: Using Relocated is_carmichael Function from Top-Level SymPy Import - Python\nDESCRIPTION: Presents the updated, preferred import method for the is_carmichael function at SymPy's top level. Dependencies: SymPy >= version with relocation. Input is an integer (561); output is a boolean. Demonstrates API migration best practices.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import is_carmichael\n>>> is_carmichael(561)\nTrue\n```\n\n----------------------------------------\n\nTITLE: RST Module Documentation Reference\nDESCRIPTION: Sphinx documentation directive for importing and documenting the array expressions module and its core classes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/tensor/array_expressions.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=======================\nN-dim array expressions\n=======================\n\n.. automodule:: sympy.tensor.array.expressions\n\n.. autoclass:: sympy.tensor.array.expressions.ArrayTensorProduct\n.. autoclass:: sympy.tensor.array.expressions.ArrayContraction\n.. autoclass:: sympy.tensor.array.expressions.ArrayDiagonal\n.. autoclass:: sympy.tensor.array.expressions.PermuteDims\n```\n\n----------------------------------------\n\nTITLE: Sphinx Automodule Directive for sympy.physics.quantum.cg\nDESCRIPTION: This directive instructs Sphinx to automatically generate documentation for the Python module `sympy.physics.quantum.cg`. The `:members:` option ensures that documentation for all public members (functions, classes, etc.) within that module is included in the generated output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/cg.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.physics.quantum.cg\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Exposing LTI Control System APIs via Sphinx Directives (reStructuredText)\nDESCRIPTION: This snippet uses reStructuredText and Sphinx directives to automatically generate documentation entries for classes and functions from the sympy.physics.control.lti submodule. By referencing each class with .. autoclass:: and each function with .. autofunction::, it instructs Sphinx to include full member documentation in the generated API docs. The approach enables documentation that tracks the source code, updating automatically as the underlying Python module changes. Required dependencies: Sphinx with the autodoc extension and SymPy installed in the documentation build environment.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/control/lti.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nlti\n===\n\n.. module:: sympy.physics.control.lti\n\n.. autoclass:: TransferFunction\n   :members:\n\n.. autoclass:: Series\n   :members:\n\n.. autoclass:: Parallel\n   :members:\n\n.. autoclass:: Feedback\n   :members:\n\n.. autoclass:: TransferFunctionMatrix\n   :members:\n\n.. autoclass:: PIDController\n   :members:\n\n.. autoclass:: MIMOSeries\n   :members:\n\n.. autoclass:: MIMOParallel\n   :members:\n\n.. autoclass:: MIMOFeedback\n   :members:\n\n.. autoclass:: StateSpace\n   :members:\n\n.. autofunction:: gbt\n\n.. autofunction:: bilinear\n\n.. autofunction:: forward_diff\n\n.. autofunction:: backward_diff\n```\n\n----------------------------------------\n\nTITLE: Incorrect String Expression Building in SymPy\nDESCRIPTION: Demonstrates the incorrect approach of building expressions by manipulating strings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> expression_str = '+'.join([f'{i}*x_{i}' for i in range(10)])\n>>> expr = parse_expr(expression_str)\n>>> expr\nx_1 + 2*x_2 + 3*x_3 + 4*x_4 + 5*x_5 + 6*x_6 + 7*x_7 + 8*x_8 + 9*x_9\n```\n\n----------------------------------------\n\nTITLE: Deprecated Usage of .to_int() on Modular Integer Elements - SymPy - Python\nDESCRIPTION: Exemplifies the now-deprecated pattern of converting a modular integer element to a Python int using the .to_int() method on the element. Dependencies include sympy.GF. Key input is a modular integer; output is its integer representative. Usage will trigger a deprecation warning in newer SymPy versions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> # this is deprecated:\n>>> a.to_int()  # doctest: +SKIP\n2\n```\n\n----------------------------------------\n\nTITLE: Importing Named Groups Module in Python\nDESCRIPTION: Module import reference showing the path to access named group functions in SymPy's combinatorics package.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/named_groups.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.named_groups import *\n```\n\n----------------------------------------\n\nTITLE: Documenting Parameter Deprecation in Markdown\nDESCRIPTION: Example demonstrating how to document a deprecated parameter in the active-deprecations.md file with code examples and rationale.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n(is-this-zero-y-deprecation)=\n### `is_this_zero()` second argument\nThe second argument to {func}`~.is_this_zero()` is deprecated. Previously\n`is_this_zero(x, y)` would check if x = y. However, this was removed because\nit is trivially equivalent to `is_this_zero(x - y)`. Furthermore, allowing\nto check $x=y$ in addition to just $x=0$ is is confusing given the function\nis named \"is this zero\".\n\nIn particular, replace\n\n```py\nis_this_zero(expr1, expr2)\n```\n\nwith\n\n```py\nis_this_zero(expr1 - expr2)\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SymPy's Limitation with Transcendental Equations in Python\nDESCRIPTION: This code snippet illustrates SymPy's inability to solve a transcendental equation (cos(x) - x = 0). It imports necessary functions from SymPy, defines the equation, and attempts to solve it, resulting in a NotImplementedError.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-equation-algebraically.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import cos, solve\n>>> from sympy.abc import x\n>>> solve(cos(x) - x, x, dict=True)\nTraceback (most recent call last):\n    ...\nNotImplementedError: multiple generators [x, cos(x)]\nNo algorithms are implemented to solve equation -x + cos(x)\n```\n\n----------------------------------------\n\nTITLE: Generating Table of Contents for SymPy Contributing Guide in Markdown\nDESCRIPTION: This code snippet uses a Markdown directive to create a table of contents for the SymPy contributing guide. It includes links to various important sections of the guide, helping contributors navigate the documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/index.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{toctree}\n:titlesonly: true\n\nintroduction-to-contributing.md\nnew-contributors-guide/index.md\ndependencies.md\ndebug.rst\ndocstring.rst\ndocumentation-style-guide.rst\ndeprecations.md\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Physics Module Structure in RST\nDESCRIPTION: This RST code defines the structure of the physics module documentation. It includes a title, automodule directive, and a table of contents with links to various submodules and topics.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/physics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _physics-docs:\n\n=======\nPhysics\n=======\n\n.. automodule:: sympy.physics\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/physics/vector/api/index.rst\n   ../../../modules/physics/mechanics/api/index.rst\n   ../../../modules/physics/biomechanics/api/index.rst\n   ../../../modules/physics/control/index.rst\n   ../../../modules/physics/optics/index.rst\n   ../../../modules/physics/units/index.rst\n   ../../../modules/physics/continuum_mechanics/index.rst\n   ../../../modules/physics/hep/index.rst\n   ../../../modules/physics/quantum/index.rst\n   ../../../modules/physics/hydrogen.rst\n   ../../../modules/physics/matrices.rst\n   ../../../modules/physics/paulialgebra.rst\n   ../../../modules/physics/qho_1d.rst\n   ../../../modules/physics/secondquant.rst\n   ../../../modules/physics/sho.rst\n   ../../../modules/physics/wigner.rst\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents in reStructuredText for SymPy Special Topics\nDESCRIPTION: This snippet defines a table of contents (toctree) in reStructuredText format that links to advanced SymPy documentation pages. It sets the maximum depth to 2 and references two specific documentation files: finite_diff_derivatives.rst and classification.rst.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   finite_diff_derivatives.rst\n   classification.rst\n```\n\n----------------------------------------\n\nTITLE: Importing Vector Module in Python\nDESCRIPTION: This snippet shows how to import the vector module from SymPy. It's a crucial first step for using the vector tools in a Python script or interactive session.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. module:: sympy.vector\n```\n\n----------------------------------------\n\nTITLE: Basic Symbol Definition with Assumptions in SymPy\nDESCRIPTION: Creates SymPy symbols with specific assumptions - x and y as positive numbers, a and b as real numbers, and z, t, c as complex numbers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx, y = symbols('x y', positive=True)\na, b = symbols('a b', real=True)\nz, t, c = symbols('z t c')\n```\n\n----------------------------------------\n\nTITLE: Specifying ANTLR Runtime Installation via conda - reStructuredText\nDESCRIPTION: This snippet demonstrates how to install the required ANTLR runtime for the parser using conda, suitable for environments managed by conda or Anaconda. The package is installed from the conda-forge channel, specifically matching the version expected by the parser. Conda must be set up prior to use.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/parsing.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n\"    $ conda install -c conda-forge antlr-python-runtime==4.11\\n\"\n```\n\n----------------------------------------\n\nTITLE: Mathematical Representation of Linearized System Using LaTeX\nDESCRIPTION: Presents the mathematical form of the linearized system using LaTeX notation, showing the state-space equation for the independent coordinate q₂ and its derivatives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/lin_pend_nonmin_example.rst#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{bmatrix} \\dot{q_2} \\\\ \\ddot{q_2} \\end{bmatrix} =\n\\begin{bmatrix} 0 & 1 \\\\ \\frac{-g}{L} & 0 \\end{bmatrix}\n\\begin{bmatrix} q_2 \\\\ \\dot{q_2} \\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Accessing Polynomial Leading Coefficient in Python\nDESCRIPTION: The dmp_LC function retrieves the leading coefficient of a dense multivariate polynomial. It takes the polynomial, number of variables, and ground domain as parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndmp_LC(f, u, K)\n```\n\n----------------------------------------\n\nTITLE: Generating Module Documentation with Sphinx Automodule (reStructuredText)\nDESCRIPTION: This reStructuredText directive instructs the Sphinx documentation generator to use the `automodule` feature. It targets the `sympy.physics.quantum.qapply` Python module and automatically includes documentation for all its members (`:members:`) by extracting docstrings and signatures from the source code.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/qapply.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.quantum.qapply\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Expanding Arithmetic Expressions in SymPy (Python)\nDESCRIPTION: Demonstrates how to expand arithmetic expressions involving products and powers using SymPy's expand() function with the basic keyword.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/rewriting.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> x, y, z = symbols('x,y,z')\n>>> ((x + y)*(x - y)).expand(basic=True)\nx**2 - y**2\n>>> ((x + y + z)**2).expand(basic=True)\nx**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n```\n\n----------------------------------------\n\nTITLE: Automating Module Documentation with Sphinx automodule (reStructuredText)\nDESCRIPTION: This reStructuredText snippet employs the Sphinx `automodule` directive to command the documentation generator to automatically fetch and format documentation from the specified Python module, `sympy.physics.mechanics.pathway`. The included `:members:` option ensures that all public members (functions, classes, variables, etc.) of the target module are documented based on their respective docstrings. This relies on the Sphinx documentation tool and the presence of the target Python module with valid docstrings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/pathway.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.mechanics.pathway\n   :members:\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for SymPy Tensor Arrays\nDESCRIPTION: ReStructuredText documentation defining the structure and auto-documentation directives for tensor array classes and functions in the sympy.tensor.array module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/tensor/array.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _tensor-array:\n\nN-dim array\n===========\n\n.. automodule:: sympy.tensor.array\n\n\nClasses\n-------\n\n.. autoclass:: ImmutableDenseNDimArray\n   :members:\n\n.. autoclass:: ImmutableSparseNDimArray\n   :members:\n\n.. autoclass:: MutableDenseNDimArray\n   :members:\n\n.. autoclass:: MutableSparseNDimArray\n   :members:\n\n\nFunctions\n---------\n\n.. autofunction:: derive_by_array\n\n.. autofunction:: permutedims\n\n.. autofunction:: tensorcontraction\n\n.. autofunction:: tensorproduct\n\n.. autofunction:: tensordiagonal\n```\n\n----------------------------------------\n\nTITLE: Adding Personal Fork as Remote\nDESCRIPTION: Command to add the personal fork of SymPy as a remote named 'github' in the local repository.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add github git@github.com:<your-github-username>/sympy.git\n```\n\n----------------------------------------\n\nTITLE: Defining ReStructuredText Document Structure\nDESCRIPTION: ReStructuredText code that defines the documentation structure including title, section headers, and table of contents tree for SymPy's explanation documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _explanations:\n\n==============\n Explanations\n==============\n\n\nExplanations provide in-depth discussions about select SymPy features. These\ntopic guides talk about things like the motivation behind design decisions,\ntechnical implementation details, and opinionated recommendations.\n\n**Content**\n\n.. toctree::\n   :maxdepth: 2\n\n   best-practices.md\n   gotchas.rst\n   solve_output.rst\n   modules/physics/index.rst\n   special_topics/index.rst\n   active-deprecations.md\n   glossary.md\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymPy Arch Module using Sphinx Autodoc\nDESCRIPTION: This reStructuredText directive instructs Sphinx, a documentation generator, to automatically pull documentation from the specified Python module (`sympy.physics.continuum_mechanics.Arch`). The `:members:` option ensures that documentation for all public members (functions, classes, variables) within that module is included in the generated output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/continuum_mechanics/arches.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.continuum_mechanics.Arch\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Class Documentation Directives\nDESCRIPTION: Sphinx documentation directives for auto-documenting core sympy.vector classes including CoordSys3D, Vector, Dyadic, Del operator, and various region and integral classes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/api/classes.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: sympy.vector.coordsysrect.CoordSys3D\n   :members:\n\n   .. automethod:: sympy.vector.coordsysrect.CoordSys3D.__init__\n\n.. autoclass:: sympy.vector.vector.Vector\n   :members:\n\n.. autoclass:: sympy.vector.dyadic.Dyadic\n   :members:\n\n.. autoclass:: sympy.vector.deloperator.Del\n   :members:\n\n.. autoclass:: sympy.vector.parametricregion.ParametricRegion\n   :members:\n\n.. autoclass:: sympy.vector.implicitregion.ImplicitRegion\n   :members:\n\n.. autoclass:: sympy.vector.integrals.ParametricIntegral\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Adding Author Entry to .mailmap File\nDESCRIPTION: Example of adding a new author entry to the .mailmap file. This associates the author's name and email with their git commit metadata.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nJoe Bloggs <joe@bloggs.com>  joeb <joe@bloggs.com>\n```\n\n----------------------------------------\n\nTITLE: G-Function Integration Formula\nDESCRIPTION: Complex integral formula involving two Meijer G-functions and their transformation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_12\n\nLANGUAGE: latex\nCODE:\n```\n\\int_0^\\infty G_{u, v}^{s, t} \\left.\\left(\\begin{matrix} c_1, \\cdots, c_u \\\\ d_1, \\cdots, d_v \\end{matrix} \\right| \\sigma x \\right) G_{p, q}^{m, n} \\left.\\left(\\begin{matrix} a_1, \\cdots, a_p \\\\ b_1, \\cdots, b_q \\end{matrix} \\right| \\omega x \\right) \\mathrm{d}x = G_{v+p, u+q}^{m+t, n+s} \\left.\\left( \\begin{matrix} a_1, \\cdots, a_n, -d_1, \\cdots, -d_v, a_{n+1}, \\cdots, a_p \\\\ b_1, \\cdots, b_m, -c_1, \\cdots, -c_u, b_{m+1}, \\cdots, b_q \\end{matrix} \\right| \\frac{\\omega}{\\sigma} \\right)\n```\n\n----------------------------------------\n\nTITLE: Proper Test Using Expression Comparison\nDESCRIPTION: Example showing the preferred way to test expressions by comparing the actual expression objects rather than their string representations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# GOOD\nassert expand((x + 2)**3) == x**3 + 6*x**2 + 12*x + 8\n```\n\n----------------------------------------\n\nTITLE: Splitting Multiplicative Powers in SymPy Integrand\nDESCRIPTION: Internal SymPy function used in the Meijer G-function integration process. It splits an integrand `f(x)` into the form `x^s * g(x)`, separating the multiplicative power `x^s` which can be absorbed into the G-function representation later. The remaining part `g(x)` is typically simpler.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n_split_mul(f, x)\n```\n\n----------------------------------------\n\nTITLE: Defining Tutorial Structure in reStructuredText\nDESCRIPTION: This code snippet defines the structure of the SymPy introductory tutorial using reStructuredText syntax. It includes the title, goals, and table of contents for the tutorial.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. _intro-tutorial:\n\n=====================\nIntroductory Tutorial\n=====================\n\nThis tutorial aims to give an introduction to SymPy for someone who has not\nused the library before.  Many features of SymPy will be introduced in this\ntutorial, but they will not be exhaustive. In fact, virtually every\nfunctionality shown in this tutorial will have more options or capabilities\nthan what will be shown.  The rest of the SymPy documentation serves as API\ndocumentation, which extensively lists every feature and option of each\nfunction.\n\nThese are the goals of this tutorial:\n\n.. NB: This is mainly here for you, the person who is editing and adding to\n   this tutorial. Try to keep these principles in mind.\n\n- To give a guide, suitable for someone who has never used SymPy (but who has\n  used Python and knows the necessary mathematics).\n\n- To be written in a narrative format, which is both easy and fun to follow.\n  It should read like a book.\n\n- To give insightful examples and exercises, to help the reader learn and to\n  make it entertaining to work through.\n\n- To introduce concepts in a logical order.\n\n.. In other words, don't try to get ahead of yourself.\n\n- To use good practices and idioms, and avoid antipatterns.  Functions or\n  methodologies that tend to lead to antipatterns are avoided. Features that\n  are only useful to advanced users are not shown.\n\n- To be consistent.  If there are multiple ways to do it, only the best way is\n  shown.\n\n.. For example, there are at least five different ways to create Symbols.\n   ``symbols`` is the only one that is general and doesn't lead to\n   antipatterns, so it is the only one used.\n\n- To avoid unnecessary duplication, it is assumed that previous sections of\n  the tutorial have already been read.\n\nFeedback on this tutorial, or on SymPy in general is always welcome. Just\nwrite to our `mailing list\n<https://groups.google.com/forum/?fromgroups#!forum/sympy>`_.\n\n\n**Content**\n\n.. toctree::\n   :maxdepth: 2\n\n   preliminaries.rst\n   intro.rst\n   gotchas.rst\n   features.rst\n   next.rst\n```\n\n----------------------------------------\n\nTITLE: Installing Clang and LFortran for C/Fortran Parsers - reStructuredText\nDESCRIPTION: This shell command snippet shows the installation of dependencies for SymPy's C and Fortran code parsers, namely clang and LFortran, via conda. Both dependencies are available from the conda-forge channel and must be present for the respective parsers to function. The command is suitable for users working in conda-managed environments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/parsing.rst#2025-04-22_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n\"    $ conda install -c conda-forge lfortran clang\\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy via Conda\nDESCRIPTION: This command installs SymPy using Conda, a package manager for Anaconda or Miniconda environments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconda install sympy\n```\n\n----------------------------------------\n\nTITLE: LaTeX Mathematical Expression for Complex Power\nDESCRIPTION: Mathematical expression showing the asymptotic behavior of a complex power function using LaTeX notation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_14\n\nLANGUAGE: latex\nCODE:\n```\nz^{x + iy} \\sim |\\tau|^x e^{i y \\log{|\\tau|}} e^{\\pm x i \\frac{\\pi}{2}}\n```\n\n----------------------------------------\n\nTITLE: Auto-documenting SymPy Optics Utilities with Sphinx\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `automodule` directive to automatically generate documentation for the Python module `sympy.physics.optics.utils`. The `:members:` option ensures that documentation for all public members (functions, classes, attributes) defined within that module is included in the generated output. This relies on the Sphinx build environment having access to the SymPy library and its docstrings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/optics/utils.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.optics.utils\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for hermite_normal_form using reST autofunction\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the Python function `hermite_normal_form`. It retrieves the function's signature and docstring from the `sympy.matrices.normalforms` module and includes it in the generated documentation output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/normalforms.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hermite_normal_form\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymPy Utilities Decorator Module\nDESCRIPTION: This code snippet uses Sphinx directives to automatically generate documentation for the sympy.utilities.decorator module. It includes all members except for the 'deprecated' decorator, which is documented separately.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/decorator.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.utilities.decorator\n   :members:\n   :exclude-members: deprecated\n```\n\n----------------------------------------\n\nTITLE: Empty List Return from Solve Function\nDESCRIPTION: Shows examples of solve returning an empty list when no solution exists. This happens when the equation has no valid solutions, as in the case of sqrt(x) + 1 = 0.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/solve_output.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsolve(sqrt(x) + 1)  # or solve(sqrt(x) + 1, dict=True)\n[]\nsolve(sqrt(x) + 1, set=True)\n([x], set())\n```\n\n----------------------------------------\n\nTITLE: Formatting Code in SymPy Documentation\nDESCRIPTION: Illustrates how to format code snippets within SymPy documentation using double backticks for inline code.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/documentation-style-guide.rst#2025-04-22_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\nTo use this class, define the ``_rewrite()`` and ``_expand()`` methods.\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SparseMatrix Class (reStructuredText)\nDESCRIPTION: This Sphinx `autoclass` directive instructs the documentation generator to include documentation for the `SparseMatrix` class from the default module (`sympy.matrices.sparse`). The `:members:` option ensures that documentation for the class's public members (methods, attributes) is also included.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparse.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: SparseMatrix\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting the Deprecated Decorator in SymPy\nDESCRIPTION: This directive generates documentation specifically for the 'deprecated' decorator in the sympy.utilities.decorator module. It uses the autodecorator directive, which is likely a custom Sphinx extension for documenting decorators.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/decorator.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autodecorator:: sympy.utilities.decorator.deprecated\n```\n\n----------------------------------------\n\nTITLE: Mapping GitHub Web UI Commit Author Info in .mailmap (Plaintext)\nDESCRIPTION: This snippet demonstrates a `.mailmap` entry mapping a GitHub username ('joeb') and a GitHub-generated noreply email ('1785690389+joeb@users.noreply.github.com'), often used by the web UI, to the correct author details ('Joe Bloggs <joe@bloggs.com>') for consistent AUTHORS file attribution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\nJoe Bloggs <joe@bloggs.com> joeb <1785690389+joeb@users.noreply.github.com>\n```\n\n----------------------------------------\n\nTITLE: Auto-generating Documentation for sympy.physics.mechanics.find_dynamicsymbols (reStructuredText)\nDESCRIPTION: This reStructuredText directive employs the Sphinx `autofunction` command to automatically pull and render the docstring associated with the `sympy.physics.mechanics.find_dynamicsymbols` function within the documentation output. Dependencies include Sphinx and the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/expr_manip.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: sympy.physics.mechanics.find_dynamicsymbols\n```\n\n----------------------------------------\n\nTITLE: Defining Chebyshev Polynomials in SymPy\nDESCRIPTION: Illustrates the correct spelling and formatting for documenting the Chebyshev polynomial function in SymPy, including LaTeX math.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/documentation-style-guide.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nclass chebyshevt(OrthogonalPolynomial):\n    r\"\"\"\n    Chebyshev polynomial of the first kind, $T_n(x)$\n    ...\n\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Linear Muscle Pathway in SymPy Biomechanics\nDESCRIPTION: Defines a linear pathway for a muscle connecting two points in space, which will be used as part of a musculotendon model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics.pathway import LinearPathway\n\n>>> muscle_pathway = LinearPathway(O, P)\n```\n\n----------------------------------------\n\nTITLE: Running Flake8 Code Quality Checks\nDESCRIPTION: Command to run flake8 on the SymPy codebase to check for code errors like undefined variables. This requires flake8 to be installed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nflake8 sympy\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Mechanics Tutorials in reStructuredText\nDESCRIPTION: This snippet defines a table of contents for mechanics tutorials using reStructuredText syntax. It specifies the maximum depth of the table and lists the individual tutorial files to be included.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   duffing-example.rst\n   rollingdisc_example.rst\n   multi_degree_freedom_holonomic_system.rst\n   lin_pend_nonmin_example.rst\n   four_bar_linkage_example.rst\n   bicycle_example.rst\n```\n\n----------------------------------------\n\nTITLE: Examining Musculotendon Model Properties\nDESCRIPTION: Shows how to access the dynamics, state variables, inputs, and parameters of the complete musculotendon model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle.musculotendon_dynamics\n0\n>>> muscle.x\nMatrix([[a_muscle(t)]])\n>>> muscle.r\nMatrix([[e_muscle(t)]])\n>>> muscle.p\nMatrix([\n[l_T_slack],\n[  F_M_max],\n[  l_M_opt],\n[  v_M_max],\n[alpha_opt],\n[     beta]])\n>>> muscle.rhs()\nMatrix([[((1/2 - tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2)/(0.0225*a_muscle(t) + 0.0075) + 16.6666666666667*(3*a_muscle(t)/2 + 1/2)*(tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2 + 1/2))*(-a_muscle(t) + e_muscle(t))]])\n```\n\n----------------------------------------\n\nTITLE: Auto-generating Documentation for sympy.physics.mechanics.msubs (reStructuredText)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autofunction` feature to automatically incorporate the documentation string (docstring) from the `sympy.physics.mechanics.msubs` function into the generated documentation. It requires a properly configured Sphinx environment and the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/expr_manip.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: sympy.physics.mechanics.msubs\n```\n\n----------------------------------------\n\nTITLE: Accessing Basis Vectors in SymPy Physics\nDESCRIPTION: Shows how to access the x, y, and z basis vectors of a ReferenceFrame object N.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> N.x\nN.x\n>>> N.y\nN.y\n>>> N.z\nN.z\n```\n\n----------------------------------------\n\nTITLE: Base Class Autoclass Declarations in RST\nDESCRIPTION: Sphinx autodoc declarations for the core differential geometry classes including Manifold, Patch, CoordSystem, and related geometric entities.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/diffgeom.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: Manifold\n   :members:\n\n.. autoclass:: Patch\n   :members:\n\n.. autoclass:: CoordSystem\n   :members:\n\n.. autoclass:: CoordinateSymbol\n   :members:\n\n.. autoclass:: Point\n   :members:\n\n.. autoclass:: BaseScalarField\n   :members:\n\n.. autoclass:: BaseVectorField\n   :members:\n\n.. autoclass:: Commutator\n   :members:\n\n.. autoclass:: Differential\n   :members:\n\n.. autoclass:: TensorProduct\n   :members:\n\n.. autoclass:: WedgeProduct\n   :members:\n\n.. autoclass:: LieDerivative\n   :members:\n\n.. autoclass:: BaseCovarDerivativeOp\n   :members:\n\n.. autoclass:: CovarDerivativeOp\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Incorrect String Input Example in SymPy\nDESCRIPTION: Demonstrates the incorrect approach of using string input for SymPy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import expand\n>>> expand(\"(x**2 + x)/x\")\nx + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Matrices Documentation in reStructuredText\nDESCRIPTION: This snippet defines the structure for the matrices documentation in SymPy using reStructuredText. It creates a table of contents with links to matrices, tensor, and vector module documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/matrices/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _matrices_modules:\n\n========\nMatrices\n========\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/matrices/index.rst\n   ../../../modules/tensor/index.rst\n   ../../../modules/vector/index.rst\n```\n\n----------------------------------------\n\nTITLE: Documenting SymPy Assumptions Module with Sphinx\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the sympy.assumptions.assume module. It includes all functions, classes, and other members defined in the module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/assumptions/assume.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.assumptions.assume\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Referencing SymPy Sequence Limit Functions in reStructuredText Documentation\nDESCRIPTION: Documentation references for sequence limit functions in SymPy's series module. The referenced functions help compute the limit of terms having sequences at infinity, including difference delta calculation, determining dominant terms, and evaluating sequence limits.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/series/limitseq.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: sympy.series.limitseq::difference_delta\n\n.. autofunction:: sympy.series.limitseq::dominant\n\n.. autofunction:: sympy.series.limitseq::limit_seq\n```\n\n----------------------------------------\n\nTITLE: Logarithm Expansion with expand_log\nDESCRIPTION: Shows usage of expand_log function to expand logarithmic expressions, demonstrating both default behavior and forced expansion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nexpand_log(log(z**2))\nexpand_log(log(z**2), force=True)\n```\n\n----------------------------------------\n\nTITLE: Permutations Module Documentation\nDESCRIPTION: Core permutations module containing Permutation and Cycle classes for handling mathematical permutations and cycle notation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/permutations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsympy.combinatorics.permutations\n```\n\n----------------------------------------\n\nTITLE: Demonstration of Independent Variables in SymPy\nDESCRIPTION: Shows how variable relationships must be explicitly managed in SymPy since assignments don't create dependencies between variables. Values are computed based on the state at the time of expression creation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import var\nr, t, d = var('rate time short_life')\nd = r*t\nprint(d)\nrate*time\nr = 80\nt = 2\nprint(d)        # We haven't changed d, only r and t\nrate*time\nd = r*t\nprint(d)        # Now d is using the current values of r and t\n160\n```\n\n----------------------------------------\n\nTITLE: Using GTK Printer Example\nDESCRIPTION: Example showing how to print mathematical expressions using the GTK printer which renders MathML in a GTK widget.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import *\nprint_gtk(x**2 + 2*exp(x**3))\n```\n\n----------------------------------------\n\nTITLE: Modular GCD Functions\nDESCRIPTION: Function declarations for modular GCD algorithms including univariate, bivariate, multivariate and function field implementations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nmodgcd_univariate\nmodgcd_bivariate\nmodgcd_multivariate\n_modgcd_multivariate_p\nfunc_field_modgcd\n```\n\n----------------------------------------\n\nTITLE: Discrete Fourier Transform Replacement\nDESCRIPTION: Shows the deprecated mdft function and its replacement using the DFT class from matrices.expressions.fourier.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.matrices.expressions.fourier import DFT\n>>> DFT(3)\nDFT(3)\n>>> DFT(3).as_explicit()\nMatrix([\n[sqrt(3)/3,                sqrt(3)/3,                sqrt(3)/3],\n[sqrt(3)/3, sqrt(3)*exp(-2*I*pi/3)/3,  sqrt(3)*exp(2*I*pi/3)/3],\n[sqrt(3)/3,  sqrt(3)*exp(2*I*pi/3)/3, sqrt(3)*exp(-2*I*pi/3)/3]])\n```\n\n----------------------------------------\n\nTITLE: Setting Muscle Excitation Inputs to Zero for Initial Simulation\nDESCRIPTION: Initializes muscle excitation values to zero, indicating no active control signals applied to the muscles. This setup represents a passive system with no muscle activation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> e_vals = np.array([\n...     0.0,\n...     0.0,\n... ])\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents for SymPy Basic Modules\nDESCRIPTION: reStructuredText markup defining the table of contents structure and links to basic SymPy module documentation pages. Uses toctree directive to organize documentation hierarchy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/basics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _basic_modules:\n\n=======\nBasics\n=======\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/assumptions/index.rst\n   ../../../modules/calculus/index.rst\n   ../../../modules/combinatorics/index.rst\n   ../../../modules/functions/index.rst\n   ../../../modules/integrals/index.rst\n   ../../../modules/series/index.rst\n   ../../../modules/simplify/index.rst\n   ../../../modules/solvers/index.rst\n   ../../../modules/abc.rst\n   ../../../modules/algebras.rst\n   ../../../modules/concrete.rst\n   ../../../modules/core.rst\n   ../../../modules/discrete.rst\n   ../../../modules/evalf.rst\n   ../../../modules/numeric-computation.rst\n   ../../../modules/rewriting.rst\n```\n\n----------------------------------------\n\nTITLE: Auto-Documenting sympy.physics.sho Module using Sphinx (reStructuredText)\nDESCRIPTION: This reStructuredText snippet employs the Sphinx `automodule` directive to automatically generate documentation from the specified Python module, `sympy.physics.sho`. The `:members:` option instructs Sphinx to include documentation for all public members (functions, classes, variables) defined within that module. Successful execution depends on having Sphinx installed and the SymPy library available in the Python path.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/sho.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.sho\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Activating Conda Virtual Environment\nDESCRIPTION: Command to activate the Conda virtual environment for SymPy development.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nconda activate sympy-dev\n```\n\n----------------------------------------\n\nTITLE: Using msubs Function for Improved Substitution in Mechanics\nDESCRIPTION: Demonstrates the msubs function, which handles substitution of dynamicsymbols properly by not replacing symbols inside derivatives, making it more appropriate for mechanics applications.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/advanced.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import msubs\n>>> msubs(expr, sub_dict)\nDerivative(x(t), t) + 1\n```\n\n----------------------------------------\n\nTITLE: Python Printer Example\nDESCRIPTION: Example demonstrating Python code printing functionality using print_python() to generate executable Python code from SymPy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy import print_python, sin\n>>> from sympy.abc import x\n\n>>> print_python(5*x**3 + sin(x))\nx = Symbol('x')\ne = 5*x**3 + sin(x)\n```\n\n----------------------------------------\n\nTITLE: K-bin Partitioning in SymPy\nDESCRIPTION: Demonstration of the kbins() function for generating different types of partitions with various ordering options. Shows how the ordered parameter affects the output combinations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/iterables.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.utilities.iterables import kbins\n>>> def show(k):\n...     rv = []\n...     for p in k:\n...         rv.append(','.join([''.join(j) for j in p]))\n...     return sorted(rv)\n...\n>>> show(kbins(\"ABCD\", 2))\n['A,BCD', 'AB,CD', 'ABC,D']\n>>> show(kbins(\"ABC\", 2))\n['A,BC', 'AB,C']\n>>> show(kbins(\"ABC\", 2, ordered=0))\n['A,BC', 'AB,C', 'AC,B']\n>>> show(kbins(\"ABC\", 2, ordered=1))\n['A,BC', 'A,CB',\n 'B,AC', 'B,CA',\n 'C,AB', 'C,BA']\n>>> show(kbins(\"ABC\", 2, ordered=10))\n['A,BC', 'AB,C', 'AC,B',\n 'B,AC', 'BC,A',\n 'C,AB']\n>>> show(kbins(\"ABC\", 2, ordered=11))\n['A,BC', 'A,CB', 'AB,C', 'AC,B',\n 'B,AC', 'B,CA', 'BA,C', 'BC,A',\n 'C,AB', 'C,BA', 'CA,B', 'CB,A']\n```\n\n----------------------------------------\n\nTITLE: Toctree Configuration in RestructuredText\nDESCRIPTION: RestructuredText directive that specifies the table of contents structure for the contributor guide, listing the main documentation pages with titles only.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/index.md#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n{toctree}\n:titlesonly: true\n\ndev-setup.md\nworkflow-process.md\nwriting-tests.md\nbuild-docs.rst\n```\n\n----------------------------------------\n\nTITLE: Importing and Documenting SymPy Source Inspection Module\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the sympy.utilities.source module. It includes all public classes, functions, and attributes in the module documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/source.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.utilities.source\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining PermutationGroup Documentation in reStructuredText\nDESCRIPTION: This snippet defines the documentation structure for the PermutationGroup class using reStructuredText directives. It sets up the module reference and autoclass directive to generate comprehensive documentation for the PermutationGroup class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/perm_groups.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _combinatorics-perm_groups:\n\nPermutation Groups\n==================\n\n.. module:: sympy.combinatorics.perm_groups\n\n.. autoclass:: PermutationGroup\n   :members:\n   :private-members:\n   :special-members:\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Table of Contents\nDESCRIPTION: Defines the structure and navigation for SymPy features documentation using ReStructuredText directives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/features.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _features:\n\n================\n SymPy Features\n================\n\nThis section discusses the common and advanced SymPy operations and features.\n\n**Content**\n\n.. toctree::\n   :maxdepth: 2\n\n   basic_operations.rst\n   printing.rst\n   simplification.rst\n   calculus.rst\n   solvers.rst\n   matrices.rst\n   manipulation.rst\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for SymPy Documentation\nDESCRIPTION: Commands to build a Docker image containing all dependencies required for generating SymPy documentation. This creates a reusable environment for documentation building.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd doc\n\ndocker build -f Dockerfile.htmldoc -t sympy_htmldoc .\n```\n\n----------------------------------------\n\nTITLE: Creating Meijer G-Function Formula Lookup Table in SymPy\nDESCRIPTION: Internal SymPy function responsible for creating the lookup table used during Meijer G-function integration. This table maps tuples of function types (generated by `_mytype`) to lists of potentially applicable Meijer G-function formulae.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n_create_lookup_table()\n```\n\n----------------------------------------\n\nTITLE: Defining Prufer Module Documentation with reStructuredText\nDESCRIPTION: reStructuredText directives defining documentation structure for the Prufer sequences module and class in SymPy combinatorics package.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/prufer.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _combinatorics-prufer:\n\nPrufer Sequences\n================\n\n.. module:: sympy.combinatorics.prufer\n\n.. autoclass:: Prufer\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Incorrect Symbol Creation in SymPy using S()\nDESCRIPTION: Demonstrates an incorrect way of creating symbols using S() or sympify(), which can lead to errors and is not recommended.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import S\n>>> x = S(\"x\") # DO NOT DO THIS\n```\n\n----------------------------------------\n\nTITLE: Linking to Introductory Tutorial in reStructuredText\nDESCRIPTION: This snippet creates a reference to the introductory tutorial using reStructuredText syntax. It includes a hidden toctree directive for the tutorial's index file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n:ref:`Introductory Tutorial <intro-tutorial>`\n=============================================\n\nIf you are new to SymPy, start here.\n\n.. toctree::\n   :hidden:\n\n   intro-tutorial/index.rst\n```\n\n----------------------------------------\n\nTITLE: Parsing Equation Strings Using SymPy parse_expr (Python)\nDESCRIPTION: This snippet demonstrates how to parse a string representing a mathematical equation into a SymPy Eq object using the parse_expr function with extensive transformations enabled. It imports required modules from SymPy, defines an algebraic equation as a string, and converts the expression for further symbolic manipulation, ensuring that mathematical notations like '^' are interpreted as exponentiation. Inputs are equation strings, and outputs are SymPy equation objects. It requires the sympy Python library and transformations such as equals handling and symbol creation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import parse_expr, solve, solveset\\n>>> from sympy.abc import x\\n>>> expr = \"Eq(x^2, y)\"\\n>>> parsed = parse_expr(expr, transformations=\"all\")\\n>>> parsed\\nEq(x**2, y)\n```\n\n----------------------------------------\n\nTITLE: Creating Symbol Objects Directly\nDESCRIPTION: Shows alternative ways to create Symbol objects in SymPy using both symbols() and Symbol() constructor\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = symbols('x')\n\n# Alternative way\nx = Symbol('x')\n```\n\n----------------------------------------\n\nTITLE: Defining Excitation Input\nDESCRIPTION: Sets the excitation value for the muscle to its maximum (1.0) as input to the model. Excitation represents the neural input to the muscle.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nr_vals = np.array([\n    1.0,  # e\n])\n```\n\n----------------------------------------\n\nTITLE: Angular Velocity Addition Theorem in LaTeX\nDESCRIPTION: Demonstrates the addition theorem for angular velocities, showing how to relate angular velocities of multiple bodies and frames.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n{}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{D}} = {}^{\\mathbf{N}}\\boldsymbol{\\omega}^{\\mathbf{A}} + {}^{\\mathbf{A}}\\boldsymbol{\\omega}^{\\mathbf{B}} + {}^{\\mathbf{B}}\\boldsymbol{\\omega}^{\\mathbf{C}} + {}^{\\mathbf{C}}\\boldsymbol{\\omega}^{\\mathbf{D}}\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Sympy Geometry Module\nDESCRIPTION: ReStructuredText documentation defining the module structure for sympy.geometry.ellipse and its two main classes - Ellipse and Circle. Uses sphinx autoclass directive to automatically generate class documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/geometry/ellipses.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.geometry.ellipse\n\n.. autoclass:: Ellipse\n   :members:\n\n.. autoclass:: Circle\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting RGS_unrank Function in reStructuredText\nDESCRIPTION: Autofunction directive for the RGS_unrank function, which is part of the sympy.combinatorics.partitions module. This function likely converts a rank to a restricted growth string.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_5\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: RGS_unrank\n```\n\n----------------------------------------\n\nTITLE: Product Gamma Function Expression\nDESCRIPTION: Mathematical expression showing a product of Gamma functions with specific index ranges and parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_11\n\nLANGUAGE: latex\nCODE:\n```\n\\prod_{j=m+1}^q \\Gamma(-b_j) \\prod_{j=n+1}^p \\Gamma(a_j + 1)\n```\n\n----------------------------------------\n\nTITLE: Testing Factorial Rewrite with Dummy Variables\nDESCRIPTION: Example showing how to test expressions containing Dummy variables using the dummy_eq() method for proper comparison.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef test_factorial_rewrite():\n    n = Symbol('n', integer=True)\n    k = Symbol('k', integer=True, nonnegative=True)\n\n    assert factorial(n).rewrite(gamma) == gamma(n + 1)\n    _i = Dummy('i')\n    assert factorial(k).rewrite(Product).dummy_eq(Product(_i, (_i, 1, k)))\n    assert factorial(n).rewrite(Product) == factorial(n)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for _csrtodok (reStructuredText)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `automethod` to automatically pull documentation for the `sympy.matrices.sparsetools._csrtodok` method. This SymPy method is likely used internally to convert a sparse matrix from Compressed Sparse Row (CSR) format to Dictionary of Keys (DOK) format.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparsetools.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automethod:: sympy.matrices.sparsetools::_csrtodok\n```\n\n----------------------------------------\n\nTITLE: Triangle Perimeter Calculation\nDESCRIPTION: Shows how to calculate triangle perimeter using geometry module's Polygon class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/vector_integration.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.geometry import Point, Polygon\ntriangle = Polygon(Point(1, 2), (3, 5), (1,6))\nvector_integrate(1, triangle)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Automodule for sympy.physics.optics.medium\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `automodule` directive to automatically document the Python module located at `sympy.physics.optics.medium`. The `:members:` option ensures that all public members (functions, classes, etc.) within that module are included in the generated documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/optics/medium.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.optics.medium\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Continued Fraction from Canceled Form in Python with SymPy\nDESCRIPTION: This code demonstrates how to reconstruct a continued fraction from its canceled form using SymPy's apart function. It recursively extracts terms to build the list representation of the continued fraction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\n>>> l = []\n>>> frac = apart(frac, a0)\n>>> frac\n                a₂⋅a₃⋅a₄ + a₂ + a₄\na₀ + ───────────────────────────────────────\n     a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n>>> l.append(a0)\n>>> frac = 1/(frac - a0)\n>>> frac\na₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n───────────────────────────────────────\n           a₂⋅a₃⋅a₄ + a₂ + a₄\n\n# ... (repeated for a1, a2, a3, a4)\n\n>>> list_to_frac(l)\n             1\na₀ + ─────────────────\n               1\n     a₁ + ────────────\n                  1\n          a₂ + ───────\n                    1\n               a₃ + ──\n                    a₄\n```\n\n----------------------------------------\n\nTITLE: Testing Exception Handling in Python with raises\nDESCRIPTION: Example showing how to test for expected exceptions using sympy.testing.pytest.raises, demonstrating both lambda and context manager approaches.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.testing.pytest.raises\nraises(TypeError, lambda: cos(x, y)\n```\n\n----------------------------------------\n\nTITLE: Examining Symbol with Negative=False Assumption in Python\nDESCRIPTION: This example shows that setting negative=False alone does not imply much about a symbol in SymPy's assumption system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x', negative=False)\nprint(x.is_negative)\nprint(x.is_nonnegative)\nprint(x.is_real)\nprint(x.is_complex)\nprint(x.is_finite)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymPy Testing Module in reStructuredText\nDESCRIPTION: This snippet uses the automodule directive to automatically generate documentation for all members of the sympy.testing.runtests module. It's typically used in Sphinx documentation to create API references.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/testing/runtests.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: sympy.testing.runtests\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting random_integer_partition Function in reStructuredText\nDESCRIPTION: Autofunction directive for the random_integer_partition function, which is part of the sympy.combinatorics.partitions module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: random_integer_partition\n```\n\n----------------------------------------\n\nTITLE: Doctest with Skip Directive\nDESCRIPTION: Example showing how to skip testing of a random function in doctests using special comment.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import random\n>>> random.random()      # doctest: +SKIP\n0.6868680200532414\n```\n\n----------------------------------------\n\nTITLE: Illustrating Antipattern: Storing SymPy Objects in NumPy Arrays\nDESCRIPTION: This snippet demonstrates an antipattern: storing SymPy objects (even numerical ones like `sympy.Float`) within a NumPy array. This results in an array with `dtype=object`. Applying NumPy functions like `np.sin` to such arrays fails with a TypeError because NumPy functions are not designed to operate on SymPy objects.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n>>> import sympy\n>>> a = np.asarray([sympy.Float(1.0), sympy.Float(0.0)]) # Do not do this\n>>> print(repr(a)) # Note that the dtype is 'object'\narray([1.00000000000000, 0.0], dtype=object)\n>>> np.sin(a)\nTraceback (most recent call last):\n...\nTypeError: loop of ufunc does not support argument 0 of type Float which has no callable sin method\n```\n\n----------------------------------------\n\nTITLE: Finite Difference Differentiation in Python using SymPy\nDESCRIPTION: This snippet demonstrates how to use SymPy's differentiate_finite function to perform finite difference differentiation on symbolic expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> f, g = symbols('f g', cls=Function)\n>>> differentiate_finite(f(x)*g(x))\n-f(x - 1/2)⋅g(x - 1/2) + f(x + 1/2)⋅g(x + 1/2)\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Continuum Mechanics Tutorials in reStructuredText\nDESCRIPTION: This snippet defines a table of contents for continuum mechanics tutorials using reStructuredText syntax. It sets the maximum depth to 2 and includes a link to the 'beam_problems.rst' file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   beam_problems.rst\n```\n\n----------------------------------------\n\nTITLE: Building SymPy Documentation with Docker\nDESCRIPTION: Command to build the SymPy documentation using a pre-built Docker image. This mounts the local SymPy directory into the container and runs the documentation build process.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -v /absolute/path/to/sympy:/sympy sympy_htmldoc\n```\n\n----------------------------------------\n\nTITLE: Symbol Assignment Variations\nDESCRIPTION: Shows different ways to assign SymPy symbols to variables, including multiple symbol creation and mismatched naming.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx, y, z = symbols('x y z')\na, b = symbols('b a')\ncrazy = symbols('unrelated')\n```\n\n----------------------------------------\n\nTITLE: Referencing Holonomic API Functions with Sphinx Directives - reStructuredText\nDESCRIPTION: This snippet uses the .. autofunction:: directive to include the documentation for two internal functions, sympy.holonomic.holonomic._create_table and sympy.holonomic.holonomic._convert_poly_rat_alg, within Sphinx-generated documentation. There are no required code dependencies; the prerequisites are the Sphinx documentation tool and valid Python object paths. The input is the fully-qualified Python function path, and the output is the automatic inclusion of the function's docstring in the generated documentation. This is only suitable for use within reStructuredText-based documentation sources.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/holonomic/internal.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: sympy.holonomic.holonomic._create_table\n\n.. autofunction:: sympy.holonomic.holonomic._convert_poly_rat_alg\n```\n\n----------------------------------------\n\nTITLE: Importing Common Symbols from sympy.abc (Python)\nDESCRIPTION: Shows the standard practice of importing common, predefined symbols like `x` and `y` directly from `sympy.abc` for use in doctest examples.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x, y\n>>> x + y\nx + y\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Deprecation in Python\nDESCRIPTION: Example showing how to deprecate a function using the @deprecated decorator and proper docstring formatting with Sphinx directives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/deprecations.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@deprecated(\"\"\"\\\nThe simplify_this(expr) function is deprecated. Use simplify(expr)\ninstead.\"\"\", deprecated_since_version=\"1.1\",\nactive_deprecations_target='simplify-this-deprecation')\ndef simplify_this(expr):\n    \"\"\"\n    Simplify ``expr``.\n\n    .. deprecated:: 1.1\n\n       The ``simplify_this`` function is deprecated. Use :func:`simplify`\n       instead. See its documentation for more information. See\n       :ref:`simplify-this-deprecation` for details.\n\n    \"\"\"\n    return simplify(expr)\n```\n\n----------------------------------------\n\nTITLE: Multiple Target Warning Example\nDESCRIPTION: Example showing warning message when multiple targets are found for a cross-reference in Sphinx documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nWARNING: more than one target found for cross-reference 'subs()':\nsympy.core.basic.Basic.subs, sympy.matrices.matrixbase.MatrixBase.subs,\nsympy.physics.vector.vector.Vector.subs,\nsympy.physics.vector.dyadic.Dyadic.subs\n```\n\n----------------------------------------\n\nTITLE: Handling Symbolic Inequalities in SymPy\nDESCRIPTION: Demonstrates how symbolic inequalities behave differently from numeric ones, showing that boolean evaluation will fail on symbolic inequalities with a TypeError.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> x > 0\nx > 0\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> bool(x > 0)\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational\n```\n\nLANGUAGE: python\nCODE:\n```\nif x > 0:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Workaround for sympy.mpmath import\nDESCRIPTION: This Python code snippet provides a workaround for code that still uses sympy.mpmath instead of mpmath directly.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport mpmath\nsys.modules['sympy.mpmath'] = mpmath\n```\n\n----------------------------------------\n\nTITLE: Retrieving ODE RHS for FirstOrderActivationDeGroote2016\nDESCRIPTION: Calls the `rhs()` method on an instance (`actf`) of `FirstOrderActivationDeGroote2016` created with symbolic parameters. The method returns a 1x1 SymPy Matrix containing the symbolic expression for the time derivative of activation (`da_first/dt`), which represents the right-hand side of the governing first-order ODE according to the DeGroote 2016 model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> actf.rhs()\nMatrix([[((1/2 - tanh(b*(-a_first(t) + e_first(t)))/2)*(3*a_first(t)/2 + 1/2)/tau_d + (tanh(b*(-a_first(t) + e_first(t)))/2 + 1/2)/(tau_a*(3*a_first(t)/2 + 1/2)))*(-a_first(t) + e_first(t))]])\n```\n\n----------------------------------------\n\nTITLE: Kind System with Complex and Real Numbers\nDESCRIPTION: Shows how the kind system does not distinguish between real and complex numbers, as both have NumberKind. This demonstrates the limitations of the kind system in set-theoretic classifications.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import pi, I\n>>> pi.kind\nNumberKind\n>>> I.kind\nNumberKind\n```\n\n----------------------------------------\n\nTITLE: Incorrect Test Using String Parsing\nDESCRIPTION: Example of an anti-pattern that creates expressions by parsing strings, which is less clear than direct expression construction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n# BAD\nexpr = sympify('a*b*c*d*e')\nassert expr.count_ops() == 4\n```\n\n----------------------------------------\n\nTITLE: Normalizing Arguments in Custom SymPy Classes\nDESCRIPTION: Shows how SymPy classes can normalize arguments while maintaining the ability to reconstruct the object, using Integral as an example.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Integral\n>>> expr = Integral(sin(x), x)\n>>> expr.args # args are normalized\n(sin(x), (x,))\n>>> Integral(sin(x), (x,)) # Also accepted\nIntegral(sin(x), x)\n```\n\n----------------------------------------\n\nTITLE: Handling ImportError for mpmath in Python\nDESCRIPTION: This code snippet shows the error message that occurs when mpmath is not installed correctly. It explains that SymPy now depends on mpmath as an external library and provides a link for more information on installation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/dependencies.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nImportError: SymPy now depends on mpmath as an external library. See\nhttps://docs.sympy.org/latest/install.html#mpmath for more information.\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered and Unordered FiniteSets in Python using SymPy\nDESCRIPTION: Shows how to create unordered and ordered FiniteSets in SymPy, demonstrating that a FiniteSet with a tuple as its only argument becomes ordered.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import FiniteSet\nFiniteSet(1, 2, 3)   # Unordered\nFiniteSet((1, 2, 3))  # Ordered\n```\n\n----------------------------------------\n\nTITLE: Demonstrating expreal() Function with Symbol and Complex Expression in Python\nDESCRIPTION: This snippet shows how the expreal() function handles different inputs, including symbols and complex expressions. It demonstrates that expreal() allows arguments where is_extended_real is None.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> x = Symbol('x')\n>>> print(x.is_extended_real)\nNone\n>>> expreal(x)\nexpreal(x)\n>>> expr = (1 + I)/sqrt(2) + (1 - I)/sqrt(2)\n>>> print(expr.is_extended_real)\nNone\n>>> expr.expand()\nsqrt(2)\n>>> expr.expand().is_extended_real\nTrue\n>>> expreal(expr)\nexpreal(sqrt(2)*(1 - I)/2 + sqrt(2)*(1 + I)/2)\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Parameter Values\nDESCRIPTION: Shows how to iterate through different parameter values to generate multiple solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols\n>>> a, b, c, p, q = symbols(\"a, b, c, p, q\", integer=True)\n>>> my_syms = (a, b, c)\n>>> pythag = a**2 + b**2 - c**2\n>>> d = diophantine(pythag, syms=my_syms)\n>>> solution_list = list(d)\n>>> for p_val in range(-1,2):\n...     for q_val in range(-1,2):\n...         pythag_vals = dict(zip(my_syms, [var.subs({p:p_val, q:q_val}) for var in solution_list[0]]))\n...         print(f\"p: {p_val}, q: {q_val} -> {pythag_vals}\")\n```\n\n----------------------------------------\n\nTITLE: Defining ReStructuredText Table of Contents\nDESCRIPTION: RST directive that defines the table of contents structure for the how-to guides section, specifying a maximum depth of 1 level and listing the included guide documents.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   assumptions.rst\n   booleans.rst\n   custom-functions.md\n   physics/index.rst\n   solving/index.md\n   logo.rst\n   ../citing.md\n```\n\n----------------------------------------\n\nTITLE: Univariate factoring over Gaussian numbers\nDESCRIPTION: Factoring polynomials over the Gaussian integer domain using the gaussian keyword. This enables finding complex factors for polynomials with integer coefficients.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 4*x**4 + 8*x**3 + 77*x**2 + 18*x + 153\n\n>>> factor(f, gaussian=True)\n  ⎛    3⋅ⅈ⎞ ⎛    3⋅ⅈ⎞\n4⋅⎜x - ───⎟⋅⎜x + ───⎟⋅(x + 1 - 4⋅ⅈ)⋅(x + 1 + 4⋅ⅈ)\n  ⎝     2 ⎠ ⎝     2 ⎠\n\n>>> factor(f, extension=I)\n  ⎛    3⋅ⅈ⎞ ⎛    3⋅ⅈ⎞\n4⋅⎜x - ───⎟⋅⎜x + ───⎟⋅(x + 1 - 4⋅ⅈ)⋅(x + 1 + 4⋅ⅈ)\n  ⎝     2 ⎠ ⎝     2 ⎠\n```\n\n----------------------------------------\n\nTITLE: Defining Numerical Values for Bicycle Model Parameters in SymPy\nDESCRIPTION: Creates a dictionary of numerical values for various parameters of the bicycle model, including geometric measurements, inertia values, and masses. These values are based on a benchmark paper for validation purposes.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nv = sm.Symbol('v')\nval_dict = {\n    WFrad: PaperRadFront,\n    WRrad: PaperRadRear,\n    htangle: HTA,\n    forkoffset: rake,\n    forklength: PaperForkL,\n    framelength: FrameLength,\n    forkcg1: ForkCGPar,\n    forkcg3: ForkCGNorm,\n    framecg1: FrameCGNorm,\n    framecg3: FrameCGPar,\n    Iwr11: 0.0603,\n    Iwr22: 0.12,\n    Iwf11: 0.1405,\n    Iwf22: 0.28,\n    Ifork11: 0.05892,\n    Ifork22: 0.06,\n    Ifork33: 0.00708,\n    Ifork31: 0.00756,\n    Iframe11: 9.2,\n    Iframe22: 11,\n    Iframe33: 2.8,\n    Iframe31: -2.4,\n    mfork: 4,\n    mframe: 85,\n    mwf: 3,\n    mwr: 2,\n    g: 9.81,\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unsolvable ODE with SymPy dsolve (Python)\nDESCRIPTION: Shows an example of a third-order non-linear ordinary differential equation (`y'''(x) - y(x)**2 = 0`) that SymPy's `dsolve` function cannot solve symbolically. Attempting to solve this equation results in a `NotImplementedError`, indicating the solver lacks a method for this specific type of ODE.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_16\n\nLANGUAGE: py\nCODE:\n```\n>>> from sympy import Function, dsolve, Derivative, symbols\n>>> y = Function('y')\n>>> x, C1, C2 = symbols(\"x, C1, C2\")\n>>> dsolve(Derivative(y(x), x, 3) - (y(x)**2), y(x)).rhs\nTraceback (most recent call last):\n    ...\nNotImplementedError: solve: Cannot solve -y(x)**2 + Derivative(y(x), (x, 3))\n```\n\n----------------------------------------\n\nTITLE: Running SymPy Doctests (Shell)\nDESCRIPTION: This shell command is used from the SymPy project root directory to execute all doctests within the library. It can accept arguments to target specific files or submodules, similar to the main test runner.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n./bin/doctest\n```\n\n----------------------------------------\n\nTITLE: Generating Class Documentation with Sphinx Autoclass (reStructuredText)\nDESCRIPTION: This Sphinx `autoclass` directive automatically generates documentation for the `MatrixKind` class located within the module defined by the preceding `.. module::` directive. The options `:members:`, `:special-members:`, and `:inherited-members:` instruct Sphinx to include documentation for the class's regular members, special methods (e.g., `__init__`, `__repr__`), and members inherited from its base classes, respectively, based on introspection and docstrings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/kind.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: MatrixKind\n   :members:\n   :special-members:\n   :inherited-members:\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy and Mechanics Modules in Python\nDESCRIPTION: This snippet imports the necessary SymPy modules and initializes vector printing for mechanics calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/duffing-example.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport sympy as sm\nimport sympy.physics.mechanics as me\nme.init_vprinting()\n```\n\n----------------------------------------\n\nTITLE: Checking Integer Assumption in SymPy (Python)\nDESCRIPTION: Demonstrates querying the `is_integer` assumption property for a symbolic expression `(m**2 + m)/2` in SymPy. This highlights that SymPy's assumption system may return `None` when it cannot definitively determine the property, even if the expression is mathematically always an integer for integer `m`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Integer\n>>> m = symbols('m', integer=True) # Define m as an integer symbol\n>>> print(((m**2 + m)/2).is_integer)\nNone\n```\n\n----------------------------------------\n\nTITLE: Custom Square Root Pattern Matching in SymPy\nDESCRIPTION: Shows how to create a custom lambda function to match any power with denominator 2\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsq = lambda s: s.is_Pow and s.exp.is_Rational and s.exp.q == 2\n(y + sqrt(x)**3).find(sq)\n```\n\n----------------------------------------\n\nTITLE: Proper Test Using Direct Expression Construction\nDESCRIPTION: Example showing the preferred way to create test expressions by directly using symbol objects rather than parsing strings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# GOOD\na, b, c, d, e = symbols('a b c d e')\nexpr = a*b*c*d*e\nassert expr.count_ops() == 4\n```\n\n----------------------------------------\n\nTITLE: Computing Basis Change Matrix for Dimension Systems\nDESCRIPTION: Mathematical representation of the inverse change of basis matrix between MKS system and natural system, created by combining the vectors expressed in the old basis.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/philosophy.rst#2025-04-22_snippet_4\n\nLANGUAGE: math\nCODE:\n```\nP^{-1} =\n\\begin{pmatrix}\n2 & 1 & 1 \\\\\n1 & 0 & 0 \\\\\n-2 & 0 & -1\n\\end{pmatrix}.\n```\n\n----------------------------------------\n\nTITLE: Creating Dependent Relationships with Functions in SymPy\nDESCRIPTION: Demonstrates how to create expressions with dependency relationships using Python functions, allowing values to be calculated dynamically based on current variable values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nc, d = var('c d')\nprint(c)\nc\nprint(d)\nd\ndef ctimesd():\n    \"\"\"\n    This function returns whatever c is times whatever d is.\n    \"\"\"\n    return c*d\n\nctimesd()\nc*d\nc = 2\nprint(c)\n2\nctimesd()\n2*d\n```\n\n----------------------------------------\n\nTITLE: Incorrect Test for Assumptions Using Truthiness\nDESCRIPTION: Example of an anti-pattern for testing assumptions that relies on Python's truthiness, which can be problematic when None is involved.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n# BAD\nassert not x.is_real\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error with Fuzzy-Bool in Piecewise\nDESCRIPTION: This snippet shows that using a fuzzy-bool (which can be None) in a Piecewise function results in an error.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> p2 = Piecewise((1, x.is_positive), (2, True))\nTraceback (most recent call last):\n...\nTypeError: Second argument must be a Boolean, not `NoneType`\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing with Mathematical Constants\nDESCRIPTION: Examples showing how fcode handles mathematical constants like pi and E, with control over precision and parameter definitions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fcode(x - pi**2 - E))\n      parameter (E = 2.7182818284590452d0)\n      parameter (pi = 3.1415926535897932d0)\n      x - pi**2 - E\n>>> print(fcode(x - pi**2 - E, precision=25))\n      parameter (E = 2.718281828459045235360287d0)\n      parameter (pi = 3.141592653589793238462643d0)\n      x - pi**2 - E\n>>> print(fcode(N(x - pi**2, 25)))\n      x - 9.869604401089358618834491d0\n```\n\n----------------------------------------\n\nTITLE: Marking Test as Expected to Fail in Python\nDESCRIPTION: This example shows how to mark a test as expected to fail (XFAIL) in SymPy. It uses the XFAIL decorator from sympy.testing.pytest to indicate that the test is known to fail but should pass in the future when the functionality is implemented.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.testing.pytest import XFAIL\n\n@XFAIL\ndef test_failing_integral():\n    assert integrate(sqrt(x**2 + 1/x**2), x) == x*sqrt(x**2 + x**(-2))*(sqrt(x**4 + 1) - atanh(sqrt(x**4 + 1)))/(2*sqrt(x**4 + 1))\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymbolicSystem Class in SymPy (reStructuredText)\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `autoclass` directive to automatically pull documentation for the `SymbolicSystem` class, found within the `sympy.physics.mechanics.system` module. The `:members:` option ensures that documentation for all public members (methods, attributes) of the class is included. Requires Sphinx and the SymPy library to be correctly configured.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/system.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: sympy.physics.mechanics.system.SymbolicSystem\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation of Fuzzy-Bool Logic\nDESCRIPTION: This function demonstrates an incorrect way to handle fuzzy-bool logic, failing to account for the None case.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> def both_positive(a, b):\n...     \"\"\"ask whether a and b are both positive\"\"\"\n...     if a.is_positive and b.is_positive:\n...         return True\n...     else:\n...         return False\n```\n\n----------------------------------------\n\nTITLE: Generating LaTeX Output with UnevaluatedExpr in SymPy (Python)\nDESCRIPTION: This snippet demonstrates how to use UnevaluatedExpr in SymPy to generate LaTeX output for unevaluated expressions. It shows the difference between the unevaluated and evaluated forms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import latex\n>>> uexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\n>>> print(latex(uexpr))\n\\frac{5}{7} \\cdot \\frac{3}{4}\n\n>>> print(latex(uexpr.doit()))\n\\frac{15}{28}\n```\n\n----------------------------------------\n\nTITLE: Discouraged Doctest Style: Checking Equality (Python)\nDESCRIPTION: Illustrates an undesirable way to write a doctest where the result is checked using `== True` instead of showing the actual output. While this passes the doctester, it's less clear for a user reading the documentation as an example.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# BAD\n>>> from sympy import sin, cos, trigsimp, symbols\n>>> x = symbols('x')\n>>> result = trigsimp(sin(x)*cos(x))\n>>> result == sin(2*x)/2\nTrue\n```\n\n----------------------------------------\n\nTITLE: Checking Structural Equality of SymPy Objects with == in Python\nDESCRIPTION: This refers to the use of Python's standard equality operator `==` to check for *structural equality* between two SymPy objects. Structural equality means the objects have identical internal representations (expression trees), distinct from *symbolic equality* (mathematical equivalence, checked with `Eq`). The `==` operator always returns a Python boolean (`True` or `False`). It requires the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/glossary.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n==\n```\n\n----------------------------------------\n\nTITLE: Division Representation\nDESCRIPTION: Shows how division is represented internally using negative powers\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nexpr = x/y\nsrepr(expr)\n```\n\n----------------------------------------\n\nTITLE: Using str() for String Representation in SymPy\nDESCRIPTION: Demonstrates how to use str() to get a string representation of a SymPy expression, which is also the form produced by print().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols('x y z')\nstr(Integral(sqrt(1/x), x))\nprint(Integral(sqrt(1/x), x))\n```\n\n----------------------------------------\n\nTITLE: Showing None Output in Doctests (Python)\nDESCRIPTION: Illustrates the technique for explicitly showing that an expression evaluates to `None` in a doctest. Since `None` doesn't produce output by itself in the interactive interpreter, `print()` must be used to display it.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol\n>>> x = Symbol('x', positive=True)\n>>> x.is_real\nTrue\n>>> x = Symbol('x', real=True)\n>>> x.is_positive # Shows nothing, because it is None\n>>> print(x.is_positive)\nNone\n```\n\n----------------------------------------\n\nTITLE: Polynomial Construction with SymPy Poly in Python\nDESCRIPTION: Shows how to construct a polynomial using SymPy's Poly class and a coefficient vector represented by a Matrix, reshaped as needed. Dependencies: 'sm' representing SymPy, input matrix of coefficients, and a variable 'x'. The result is a Poly object representing the polynomial for root finding or algebraic manipulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\np = sm.Poly(sm.Matrix([a, b, c]).reshape(1, 3), x)\n```\n\n----------------------------------------\n\nTITLE: Unevaluated Versin Example\nDESCRIPTION: Demonstrates how the versin function remains unevaluated when the input is not an integer multiple of pi.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> versin(x*pi)\nversin(pi*x)\n```\n\n----------------------------------------\n\nTITLE: Testing Unchanged Expressions in SymPy\nDESCRIPTION: Example demonstrating how to properly test that SymPy expressions remain unchanged/unevaluated using the unchanged helper function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.core.expr import unchanged\n\ndef test_sin_1_unevaluated():\n    assert unchanged(sin, 1)\n```\n\n----------------------------------------\n\nTITLE: Automatic Sorting by Doctester (Python)\nDESCRIPTION: Demonstrates that the SymPy doctester automatically sorts the items in dictionaries and sets, and the terms within expressions, before comparing the output. This ensures that doctests pass regardless of the internal ordering during execution.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> {'b': 1, 'a': 2}\n{'a': 2, 'b': 1}\n>>> {'b', 'a'}\n{'a', 'b'}\n>>> y + x\nx + y\n```\n\n----------------------------------------\n\nTITLE: Pin Joint Definition with Intermediate Frame\nDESCRIPTION: Example showing the new way to define a PinJoint using intermediate reference frames and explicit joint axis specification.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import pi\nfrom sympy.physics.mechanics import PinJoint, ReferenceFrame, RigidBody\nparent, child, = RigidBody('parent'), RigidBody('child')\nint_frame = ReferenceFrame('int_frame')\nint_frame.orient_axis(child.frame, child.y, pi)\npin = PinJoint('pin', parent, child, joint_axis=parent.z,\n               child_interframe=int_frame)\nparent.frame.dcm(child.frame)\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Vector API Documentation in reStructuredText\nDESCRIPTION: This snippet creates a table of contents for the Vector API documentation using reStructuredText syntax. It includes links to separate files for classes, orienter classes, and vector functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/api/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nVector API\n==========\n\n.. toctree::\n   :titlesonly:\n\n   classes.rst\n   orienterclasses.rst\n   vectorfunctions.rst\n```\n\n----------------------------------------\n\nTITLE: Documenting Essential Functions in sympy.vector using Sphinx\nDESCRIPTION: This code snippet uses Sphinx autodoc directives to generate documentation for key functions in the sympy.vector module. It covers various vector operations and calculus concepts.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/api/vectorfunctions.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: sympy.vector.matrix_to_vector\n\n.. autofunction:: sympy.vector.express\n\n.. autofunction:: sympy.vector.curl\n\n.. autofunction:: sympy.vector.divergence\n\n.. autofunction:: sympy.vector.gradient\n\n.. autofunction:: sympy.vector.is_conservative\n\n.. autofunction:: sympy.vector.is_solenoidal\n\n.. autofunction:: sympy.vector.scalar_potential\n\n.. autofunction:: sympy.vector.scalar_potential_difference\n\n.. autofunction:: sympy.vector.integrals.vector_integrate\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Simplify Module in reStructuredText\nDESCRIPTION: This code snippet defines a table of contents for the Simplify module documentation using reStructuredText syntax. It includes three main sections: simplify, hyperexpand, and fu.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n========\nSimplify\n========\n\n.. toctree::\n   :titlesonly:\n\n   simplify.rst\n   hyperexpand.rst\n   fu.rst\n```\n\n----------------------------------------\n\nTITLE: Incorrect Test Using Float Values\nDESCRIPTION: Example showing incorrect test pattern that uses Python's floating-point division which should be avoided in SymPy tests unless specifically testing floating-point behavior.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# BAD\nassert expand((x + 1/2)**2) == x**2 + x + 1/4\n```\n\n----------------------------------------\n\nTITLE: Mapping Incorrect Commit Author Info in .mailmap (Plaintext)\nDESCRIPTION: This example shows a line in the `.mailmap` file. It maps an incorrect author name ('joeb') and email ('wrong@email.com') used in a commit to the desired canonical author name ('Joe Bloggs') and email ('joe@bloggs.com') that should appear in the AUTHORS file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\nJoe Bloggs <joe@bloggs.com> joeb <wrong@email.com>\n```\n\n----------------------------------------\n\nTITLE: Auto-documenting SymPy Optics Polarization Module using Sphinx\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `automodule` directive to automatically generate documentation for the specified Python module (`sympy.physics.optics.polarization`). The `:members:` option ensures that documentation for all public members (functions, classes, etc.) within the module is included in the generated output. This requires Sphinx and the SymPy library to be installed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/optics/polarization.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.optics.polarization\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Example 3: Cantilever Beam Analysis\nDESCRIPTION: Analyzes a cantilever beam with distributed constant load, ramp load, and point load. Calculates reaction loads and beam response.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.continuum_mechanics.beam import Beam\nfrom sympy import symbols\nE,I,M,V = symbols('E I M V')\nb = Beam(6, E, I)\nb.apply_load(V, 0, -1)\nb.apply_load(M, 0, -2)\nb.apply_load(4, 0, 0, end=2)\nb.apply_load(12, 4, -1)\nb.apply_load(1, 3, 1, end=6)\nb.solve_for_reaction_loads(V, M)\n```\n\n----------------------------------------\n\nTITLE: Speeding Up solve by Including Solutions Making Denominators Zero\nDESCRIPTION: This example shows how to use check=False to include solutions that make denominators zero, which can speed up solve() at the risk of obtaining invalid solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, sin, solve\n>>> x = Symbol(\"x\")\n>>> solve(sin(x)/x, x, dict=True) # 0 is excluded\n[{x: pi}]\n>>> solve(sin(x)/x, x, dict=True, check=False) # 0 is not excluded\n[{x: 0}, {x: pi}]\n```\n\n----------------------------------------\n\nTITLE: Auto-documenting a SymPy Module with Sphinx\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `automodule` directive to automatically generate documentation for the specified Python module (`sympy.physics.optics.waves`). The `:members:` option ensures that documentation for all public members (functions, classes, variables) within that module is included in the output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/optics/waves.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.optics.waves\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Using System Class Instead of Deprecated JointsMethod\nDESCRIPTION: Example showing how to replace the deprecated JointsMethod with the System class for mechanical systems modeling. The System class offers better design and integration with other parts of the mechanics module for forming equations of motion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import (\n...   Particle, PinJoint, PrismaticJoint, RigidBody, System)\n>>> g, l = symbols(\"g l\")\n>>> wall = RigidBody(\"wall\")\n>>> cart = RigidBody(\"cart\")\n>>> pendulum = RigidBody(\"Pendulum\")\n>>> slider = PrismaticJoint(\"s\", wall, cart, joint_axis=wall.x)\n>>> pin = PinJoint(\"j\", cart, pendulum, joint_axis=cart.z,\n...                child_point=l * pendulum.y)\n>>> system = System.from_newtonian(wall)\n>>> system.add_joints(slider, pin)\n>>> system.apply_uniform_gravity(-g * wall.y)\n>>> system.form_eoms()\nMatrix([\n[ Pendulum_mass*l*u_j(t)**2*sin(q_j(t)) - Pendulum_mass*l*cos(q_j(t))*Derivative(u_j(t), t) - (Pendulum_mass + cart_mass)*Derivative(u_s(t), t)],\n[-Pendulum_mass*g*l*sin(q_j(t)) - Pendulum_mass*l*cos(q_j(t))*Derivative(u_s(t), t) - (Pendulum_izz + Pendulum_mass*l**2)*Derivative(u_j(t), t)]])\n```\n\n----------------------------------------\n\nTITLE: Comparing Modular Integers in Non-Ordered Contexts - SymPy GF Domain - Python\nDESCRIPTION: Provides an example of an invalid ordered comparison in a finite field context using SymPy's GF. Dependencies: sympy.GF. Highlights that such comparisons, though previously allowed, lack mathematical sense and are now discouraged, yielding a boolean output that is not meaningful in this context.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> e = F5(4)\n>>> e + 1 > e # doctest: +SKIP\nFalse\n```\n\n----------------------------------------\n\nTITLE: Defining System Variables in SymPy\nDESCRIPTION: This code defines the symbolic variables and dynamicsymbols for the Duffing oscillator and pendulum system, including masses, lengths, spring constants, and generalized coordinates.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/duffing-example.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nM, m, l, k1, k2, c1, g, h, w, d, r = sm.symbols('M, m, l, k1, k2, c1, g, h, w, d, r')\nq1, q2 = me.dynamicsymbols('q1 q2')\nq1d = me.dynamicsymbols('q1', 1)\n```\n\n----------------------------------------\n\nTITLE: Building PDF Documentation for SymPy\nDESCRIPTION: Command to build the PDF version of the SymPy documentation after installing the required LaTeX dependencies. This generates a comprehensive PDF file of the entire documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd doc\n\nmake pdf\n```\n\n----------------------------------------\n\nTITLE: Function Documentation References\nDESCRIPTION: RestructuredText directives referencing the documentation for key tensor canonicalization functions\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/tensor_can.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: canonicalize\n\n.. autofunction:: double_coset_can_rep\n\n.. autofunction:: get_symmetric_group_sgs\n\n.. autofunction:: bsgs_direct_product\n```\n\n----------------------------------------\n\nTITLE: Factoring polynomials into linear factors (unimplemented feature)\nDESCRIPTION: Demonstrating an unimplemented feature for factoring polynomials into linear factors using the split parameter. This would automatically infer a splitting field, but is not yet implemented.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> factor(x**3 + x**2 - 7, split=True)\nTraceback (most recent call last):\n...\nNotImplementedError: 'split' option is not implemented yet\n```\n\n----------------------------------------\n\nTITLE: Representing Natural System Dimensions\nDESCRIPTION: Mathematical representation of base dimensions (Action, Length, Velocity) as vectors in the natural system (ħ, m, c), showing an alternative basis for the dimension space.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/philosophy.rst#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\nA =\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ 0\n\\end{pmatrix}, \\qquad\nL =\n\\begin{pmatrix}\n0 \\\\ 1 \\\\ 0\n\\end{pmatrix}, \\qquad\nV =\n\\begin{pmatrix}\n0 \\\\ 0 \\\\ 1\n\\end{pmatrix},\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Suboptimal Simplification Paths\nDESCRIPTION: Example showing how certain orderings of transformations can lead to suboptimal results that resist further simplification, highlighting the challenges of trigonometric simplification algorithms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> TR9(-cos(x)**2*cos(y + z) + 3*cos(y - z)/2 +\n...     cos(y + z)/2 + cos(-2*x + y + z)/4 - cos(2*x + y + z)/4)\nsin(2*x)*sin(y + z)/2 - cos(x)**2*cos(y + z) + 3*cos(y - z)/2 + cos(y + z)/2\n\n>>> a = sin(x)*sin(z)*cos(x)*cos(y) + sin(x)*sin(y)*cos(x)*cos(z)\n>>> TR10i(a)\nsin(x)*sin(y + z)*cos(x)\n>>> newa = _\n>>> TR10i(expr - a)  # this combines two more of the remaining terms\nsin(x)**2*cos(y)*cos(z) + sin(y)*sin(z)*cos(x)**2 + cos(y - z)\n>>> TR10i(_ + newa) == _ + newa  # but now there is no more simplification\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating a Git Branch with Checkout Shorthand\nDESCRIPTION: A shortened git command that combines branch creation and checkout into a single operation for SymPy development.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b <your-branch-name>\n```\n\n----------------------------------------\n\nTITLE: Configuring Permutation printing (Python)\nDESCRIPTION: Demonstrates how to configure Permutation printing using init_printing() with the perm_cyclic flag, as an alternative to the deprecated print_cyclic attribute.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import init_printing\n>>> init_printing(perm_cyclic=False) # Makes Permutation print in array form # doctest: +SKIP\n>>> from sympy.combinatorics import Permutation\n>>> Permutation(1, 2)(3, 4) # doctest: +SKIP\n⎛0 1 2 3 4⎞\n⎝0 2 1 4 3⎠\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for SymPy Utilities in reStructuredText\nDESCRIPTION: This snippet defines the structure and content of the utilities documentation using reStructuredText directives. It includes a title, a table of contents directive, and links to various utility module documentation files.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/utilities/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _utilities:\n\n==========\nUtilities\n==========\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/testing/index.rst\n   ../../../modules/utilities/index.rst\n   ../../../modules/interactive.rst\n   ../../../modules/parsing.rst\n   ../../../modules/printing.rst\n```\n\n----------------------------------------\n\nTITLE: SymPy Algebras Module Import Reference\nDESCRIPTION: ReStructuredText directive showing the module import path for the SymPy Algebras module documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/algebras.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.algebras\n```\n\n----------------------------------------\n\nTITLE: Creating Numerical ODE Functions with SymPy lambdify\nDESCRIPTION: Converts symbolic ordinary differential equations to numerical functions using SymPy's lambdify. The function takes state, inputs, and constants as parameters and returns the derivatives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\neval_eom = sm.lambdify((state, inputs, constants), (dqdt, dudt, dadt))\n```\n\n----------------------------------------\n\nTITLE: Integrating Rational Functions with SymPy in Python\nDESCRIPTION: This example calculates the indefinite integral of a rational function using SymPy's integrate function. The required dependency is sympy, and it assumes a symbolic variable x has been defined. The input is a rational function, and the output features logarithmic and rational terms. Limitations include symbolic-only operation, not numeric evaluation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> integrate(x/(x**2+2*x+1), x)\n               1\nlog(x + 1) + -----\n             x + 1\n```\n\n----------------------------------------\n\nTITLE: Accessing Polynomial Coefficients using Deprecated DMP.rep in Python\nDESCRIPTION: Demonstrates the deprecated way of accessing polynomial coefficients using the DMP.rep attribute in SymPy. This method is no longer recommended and will be removed in future versions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Poly\n>>> x = symbols('x')\n>>> p = Poly(x**2 + 2*x + 3)\n>>> p\nPoly(x**2 + 2*x + 3, x, domain='ZZ')\n>>> p.rep  # doctest: +SKIP\nDMP([1, 2, 3], ZZ)\n>>> p.rep.rep  # doctest: +SKIP\n[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Avoiding Excessive Automatic Evaluation in SymPy Custom Functions\nDESCRIPTION: This snippet demonstrates poor practices in automatic evaluation for a custom SymPy function. It shows checking general assumptions and applying symbolic identities in the eval method, which should be avoided.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nclass f(Function):\n    @classmethod\n    def eval(cls, x):\n        if x.is_integer: # Bad (checking general assumptions)\n            return 0\n        if isinstance(x, Add): # Bad (applying symbolic identities)\n            return Add(*[f(i) for i in x.args])\n\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for SymPy Assumptions Refine Module\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for all members of the sympy.assumptions.refine module. It includes the module path and the :members: option to ensure comprehensive documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/assumptions/refine.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.assumptions.refine\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Importing Primitive Polynomial Remainder Sequence Function\nDESCRIPTION: This snippet shows the autofunction directive for importing the function that computes the primitive polynomial remainder sequence.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: dmp_primitive_prs\n```\n\n----------------------------------------\n\nTITLE: Importing Moved Mechanics Functions - SymPy Physics - Python\nDESCRIPTION: Demonstrates the old import style for mechanics functions before their relocation in SymPy. Dependencies include SymPy and its physics.mechanics.functions module. This is a usage example for previous codebases and is now deprecated due to the new module structure.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics.functions import inertia, inertia_of_point_mass, gravity\n```\n\n----------------------------------------\n\nTITLE: Symbol Assumption Example in SymPy\nDESCRIPTION: Shows how string inputs can lead to incorrect results when working with symbol assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import diff\n>>> z = symbols('z', positive=True)\n>>> diff('z**2', z)\n0\n```\n\n----------------------------------------\n\nTITLE: Matrix Operations in SymPy\nDESCRIPTION: Shows how to perform various matrix operations in SymPy, including determinant, inverse, trace, transpose, and eigenvalue calculations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nM.det()\nM**-1\nsm.trace(A)\nA.T\nsm.diag(1,1,1,1)\nA.eigenvals()\neigval = A.eigenvals()\neigvec = A.eigenvects()\n```\n\n----------------------------------------\n\nTITLE: Building and Pushing SymPy Release Docker Image\nDESCRIPTION: These commands build the Docker image for SymPy releases and push it to Dockerhub. This is necessary if the Dockerfile has been modified.\nSOURCE: https://github.com/sympy/sympy/blob/master/release/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -f Dockerfile . -t sympy/sympy-release\ndocker push sympy/sympy-release\n```\n\n----------------------------------------\n\nTITLE: Creating Hidden Table of Contents in reStructuredText\nDESCRIPTION: This snippet creates a hidden table of contents using the toctree directive in reStructuredText. It lists the main sections of the SymPy documentation without displaying them directly on the page.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :hidden:\n\n   install.md\n   tutorials/index.rst\n   guides/index.rst\n   explanation/index.rst\n   reference/index.rst\n   contributing/index.rst\n```\n\n----------------------------------------\n\nTITLE: Executing SymPy Release Script with Docker\nDESCRIPTION: This command runs the release script using Docker, specifying the release branch and version. It creates release tarballs and puts them in a new directory.\nSOURCE: https://github.com/sympy/sympy/blob/master/release/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./release.sh <BRANCH> <VERSION>\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy for Beam Calculations in Python\nDESCRIPTION: This code snippet sets up SymPy for beam calculations by importing necessary functions and symbols, and enabling pretty printing.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols('x y z')\ninit_printing(use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Tagging SymPy Release in Git\nDESCRIPTION: These commands create an annotated git tag for the SymPy release and push it to the remote repository. The tag name must follow the convention 'sympy-VERSION'.\nSOURCE: https://github.com/sympy/sympy/blob/master/release/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit tag sympy-VERSION -a\ngit push origin sympy-VERSION\n```\n\n----------------------------------------\n\nTITLE: Unifying Complex Domains in Python using SymPy\nDESCRIPTION: Shows how to unify more complex domains, including polynomial rings, algebraic fields, and rational function fields.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> ZZ[x].unify(ZZ[y])\nZZ[x,y]\n>>> ZZ[x,y].unify(ZZ[y])\nZZ[x,y]\n>>> ZZ[x].unify(QQ)\nQQ[x]\n>>> K1 = QQ.algebraic_field(sqrt(2))[x]\n>>> K2 = QQ.algebraic_field(sqrt(3))[y]\n>>> K1\nQQ<sqrt(2)>[x]\n>>> K2\nQQ<sqrt(3)>[y]\n>>> K1.unify(K2)\nQQ<sqrt(2) + sqrt(3)>[x,y]\n>>> QQ.frac_field(x).unify(ZZ[y])\nZZ(x,y)\n```\n\n----------------------------------------\n\nTITLE: SymPy Glossary Markdown Block\nDESCRIPTION: A markdown block defining the glossary structure using MyST markdown syntax. Contains term definitions using the glossary directive.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/glossary.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{glossary}\n\nAntiderivative\n\n    An *antiderivative* of a function $f(x)$ with respect to $x$ is a function\n    $F(x)$ such that $\\frac{d}{dx}F(x) = f(x).$ It is also sometimes called an\n    \"indefinite integral\" of $f(x)$, and written as $\\int f(x)\\,dx.$\n    Antiderivatives in SymPy can be computed with {func}`~.integrate`. Note\n    some sources call this the \"primitive\" of $f(x)$, but this terminology is\n    not used in SymPy because it is not as universally used as\n    \"antiderivative\", and because \"primitive\" has other meanings in\n    mathematics and in {func}`SymPy <sympy.polys.polytools.primitive>`.\n\n`args`\n\n    The *`args`* property of a SymPy {term}`expression` is a tuple of the\n    top-level {term}`subexpressions <subexpression>` used to create it. They\n    are the arguments to the class used to create the expression. The args of\n    any expression can be obtained by the `.args` attribute. For example,\n    `(1 + x*y).args` is `(1, x*y)`, because it equals `Add(1, x*y)`. The `args`\n    together with {term}`func` completely define an expression. It is always\n    possible to walk the {term}`expression tree` and extract any subexpression\n    of a SymPy expression by repeated use of `.args`. Every SymPy expression\n    can be rebuilt exactly with `func` and `args`, that is,\n    `expr.func(*expr.args) == expr` will always be true of any SymPy\n    expression `expr`. The args of an expression may be the empty tuple `()`,\n    meaning the expression is an {term}`atom`.\n```\n```\n\n----------------------------------------\n\nTITLE: Creating RestructuredText Table of Contents for Guide\nDESCRIPTION: Defines a table of contents tree for the Classical Mechanics guide using RestructuredText directives. It specifies the depth and lists the included documentation files.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   masses.rst\n   kane.rst\n   lagrange.rst\n   joints.rst\n   symsystem.rst\n   linearize.rst\n   reference.rst\n   autolev_parser.rst\n   sympy_mechanics_for_autolev_users.rst\n   advanced.rst\n```\n\n----------------------------------------\n\nTITLE: Working with Tuples in SymPy\nDESCRIPTION: Shows tuple creation and usage, including integration with limits using tuples\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nt = (1, 2, x)\nt[0]\n(x,)\n(x)\nx,y\nx,\n()\nintegrate(x**2, (x, 0, 1))\nintegrate(x**2, [x, 0, 1])\n```\n\n----------------------------------------\n\nTITLE: Configuring Subset Class Documentation in RST\nDESCRIPTION: RST directive for auto-generating documentation for the Subset class from the sympy.combinatorics.subsets module, including all its members.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/subsets.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.combinatorics.subsets\n\n.. autoclass:: Subset\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Git Commands for Committing Changes in SymPy\nDESCRIPTION: A series of Git commands demonstrating how to check file status, view changes, add new files, and commit changes in the SymPy project. These commands are essential for contributing to the project.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit status\n\ngit diff\n\ngit add new_file.py\n\ngit commit\n\ngit commit -a\n\ngit commit --interactive\n```\n\n----------------------------------------\n\nTITLE: Creating Row and Column Matrices in SymPy\nDESCRIPTION: Demonstrates how to create row and column matrices in SymPy, which is different from the Autolev syntax. SymPy uses the Matrix class for both types.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nrow_matrix = sm.Matrix([[1],[2],[3],[4]])\ncol_matrix = sm.Matrix([1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: Calculating Energy in SymPy Mechanics\nDESCRIPTION: Shows how to calculate kinetic energy, potential energy, and Lagrangian for the mechanical system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nkinetic_energy(N, Pa)\n2*l1**2*m*omega**2\nkinetic_energy(N, Pa, A)\nM*l1**2*omega**2/2 + 2*l1**2*m*omega**2 + omega**2/2\nPa.potential_energy = m * g * h\nA.potential_energy = M * g * H\npotential_energy(A, Pa)\nH*M*g + g*h*m\nfrom sympy.physics.mechanics import Lagrangian\nfrom sympy.physics.vector import init_vprinting\ninit_vprinting(pretty_print=False)\nLagrangian(N, Pa, A)\n-H*M*g + M*l1**2*omega**2/2 - g*h*m + 2*l1**2*m*omega**2 + omega**2/2\n```\n\n----------------------------------------\n\nTITLE: Creating Torques in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a Torque object by specifying a reference frame and the torque vector. Torques can be applied to reference frames or to rigid bodies.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/masses.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.mechanics import Torque\n>>> Torque(N, 2 * N.x)\n(N, 2*N.x)\n```\n\n----------------------------------------\n\nTITLE: Installing Git on Linux Systems\nDESCRIPTION: Commands to install Git on Linux-like systems using package managers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyum install git\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install git\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for _doktocsr (reStructuredText)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `automethod` to automatically pull documentation for the `sympy.matrices.sparsetools._doktocsr` method. This SymPy method is likely used internally to convert a sparse matrix from Dictionary of Keys (DOK) format to Compressed Sparse Row (CSR) format.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/sparsetools.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automethod:: sympy.matrices.sparsetools::_doktocsr\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Vector Module\nDESCRIPTION: ReStructuredText markup defining the documentation structure for the Vector module, including section headers, references, and table of contents.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _physics_vector_explanation:\n\n======\nVector\n======\n\nIn this documentation the components of the sympy.physics.vector\nhave been discussed. :mod:`sympy.physics.vector` has been written to\nfacilitate the operations pertaining to 3-dimensional vectors, as functions\nof time or otherwise, in :obj:`sympy.physics`.\n\n\nReferences for Physics/Vector\n================================\n\n.. [WikiDyadics] \"Dyadics.\" Wikipedia, the Free Encyclopedia. Web. 05 Aug.\n        2011. <https://en.wikipedia.org/wiki/Dyadics>.\n.. [WikiDyadicProducts] \"Dyadic Product.\" Wikipedia, the Free Encyclopedia.\n        Web. 05 Aug. 2011. <https://en.wikipedia.org/wiki/Dyadic_product>.\n.. [Likins1973] Likins, Peter W. Elements of Engineering Mechanics.\n        McGraw-Hill, Inc. 1973. Print.\n\nGuide to Vector\n===============\n\n.. toctree::\n   :maxdepth: 2\n\n   vectors/vectors.rst\n   kinematics/kinematics.rst\n   fields.rst\n   advanced.rst\n```\n\n----------------------------------------\n\nTITLE: Module Declaration in RST\nDESCRIPTION: Sphinx documentation module declaration for the sympy.diffgeom package.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/diffgeom.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.diffgeom\n```\n\n----------------------------------------\n\nTITLE: Generating Test Coverage Report in SymPy\nDESCRIPTION: Command to run test coverage analysis using coverage.py tool. The script will execute the test suite and analyze which lines of code are covered by tests.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\n./bin/coverage_report.py\n```\n\n----------------------------------------\n\nTITLE: Improved Symbolic Boolean Implementation with Error Handling\nDESCRIPTION: Enhanced version of both_positive that handles undefined symbols by checking against S.true and S.false explicitly.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef both_positive_better(a, b):\n    \"\"\"ask whether a and b are both positive\"\"\"\n    if (a > 0) is S.false or (b > 0) is S.false:\n        return S.false\n    elif (a > 0) is S.true and (b > 0) is S.true:\n        return S.true\n    else:\n        return And(a > 0, b > 0)\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using SpringDamper in SymPy\nDESCRIPTION: Demonstrates creating an instance of a custom `SpringDamper` class connecting points `O` and `P` with spring constant `k` and damping coefficient `c`. It then calls the `to_loads()` method (defined previously) and uses `pprint` to display the resulting list of symbolic `Force` objects acting on `O` and `P`. Depends on `sympy.physics.mechanics` (`me`), `pprint`, and the assumed `SpringDamper` class definition.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> spring_damper = SpringDamper(O, P, k, c)\n>>> pprint.pprint(spring_damper.to_loads())\n[Force(point=O, force=(c*x(t)*sign(x(t))*Derivative(x(t), t)/Abs(x(t)) + k*x(t))*N.x),\n Force(point=P, force=(-c*x(t)*sign(x(t))*Derivative(x(t), t)/Abs(x(t)) - k*x(t))*N.x)]\n```\n\n----------------------------------------\n\nTITLE: Defining SymPy Module in reStructuredText\nDESCRIPTION: This snippet defines the SymPy module using reStructuredText directives. It sets up the documentation structure and provides a reference for the SymPy module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _documentation:\n\n.. module:: sympy\n```\n\n----------------------------------------\n\nTITLE: Updating SymPy from Git\nDESCRIPTION: This command updates the local SymPy repository to the latest version from the master branch.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit pull origin master\n```\n\n----------------------------------------\n\nTITLE: Defining Zeroth-Order Activation Manually in SymPy\nDESCRIPTION: Creates a dynamic symbol `e` representing excitation using `sympy.physics.mechanics.dynamicsymbols` (`me.dynamicsymbols`). It then defines the activation symbol `a` as being directly equal to `e`, symbolically representing the zeroth-order activation dynamics model where activation instantaneously matches excitation (`a(t) = e(t)`).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> e = me.dynamicsymbols('e')\n>>> e\ne(t)\n>>> a = e\n>>> a\ne(t)\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Documentation Structure for SymPy Calculus\nDESCRIPTION: ReStructuredText configuration defining the documentation structure for SymPy's calculus modules. Includes automodule directives for euler, singularities, finite differences, and utility functions with member inclusion.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/calculus/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n========\nCalculus\n========\n\n.. automodule:: sympy.calculus\n\n.. automodule:: sympy.calculus.euler\n    :members:\n\n.. automodule:: sympy.calculus.singularities\n    :members:\n\n.. _finite_diff:\n\n.. automodule:: sympy.calculus.finite_diff\n    :members:\n\n.. automodule:: sympy.calculus.util\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Defining System Parameters for Bicycle Model in Python\nDESCRIPTION: Declares constant parameters for the bicycle model, including geometric measurements, inertia values, and masses for different components of the bicycle.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> WFrad, WRrad, htangle, forkoffset = sm.symbols('WFrad WRrad htangle forkoffset')\n>>> forklength, framelength, forkcg1 = sm.symbols('forklength framelength forkcg1')\n>>> forkcg3, framecg1, framecg3, Iwr11 = sm.symbols('forkcg3 framecg1 framecg3 Iwr11')\n>>> Iwr22, Iwf11, Iwf22, Iframe11 = sm.symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n>>> Iframe22, Iframe33, Iframe31, Ifork11 = sm.symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n>>> Ifork22, Ifork33, Ifork31, g = sm.symbols('Ifork22 Ifork33 Ifork31 g')\n>>> mframe, mfork, mwf, mwr = sm.symbols('mframe mfork mwf mwr')\n```\n\n----------------------------------------\n\nTITLE: Checking .mailmap File with mailmap_check.py Script\nDESCRIPTION: Using the mailmap_check.py script to verify the .mailmap file and identify any missing author entries.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ python bin/mailmap_check.py\n```\n\n----------------------------------------\n\nTITLE: Fixed-Fixed Beam with Rotation Hinge\nDESCRIPTION: Demonstrates use of apply_rotation_hinge() and apply_support() methods for beam analysis. Shows alternative approach to modeling the same beam configuration as Example 10.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> l = symbols('l', positive=True)\n>>> b = Beam(3*l, E, I)\n>>> r0,m0 = b.apply_support(0, type='fixed')\n>>> r3l,m3l = b.apply_support(3*l, type='fixed')\n>>> F = symbols('F')\n>>> p1 = b.apply_rotation_hinge(l)\n>>> b.apply_load(F, 2*l, -1)\n>>> b.solve_for_reaction_loads(r0,m0,r3l,m3l)\n```\n\n----------------------------------------\n\nTITLE: Example of Good Branch Names for SymPy Development\nDESCRIPTION: Examples of recommended branch naming patterns that are concise and descriptive of the changes being made.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfix-solve-bug\ntypo-fix\ncore-improvements\nadd-simplify-tests\n```\n\n----------------------------------------\n\nTITLE: Internal Representation of Polynomial Elements\nDESCRIPTION: Shows how polynomial elements are represented internally as Python dictionaries mapping monomial exponents to coefficients, contrasting with the tree structure of regular SymPy expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> x = symbols('x')\n>>> K = ZZ[x]\n>>> x_dom = K(x)\n>>> p_dom = K(3)*x_dom**2 + K(2)*x_dom + K(7)\n>>> p_dom\n3*x**2 + 2*x + 7\n>>> dict(p_dom)\n{(0,): 7, (1,): 2, (2,): 3}\n```\n\n----------------------------------------\n\nTITLE: Plotting Geometric Entities with SymPy\nDESCRIPTION: Demonstrates how to plot 2D geometric entities using the plot_implicit function. This example plots a circle centered at the origin with radius 2 units.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx,y = symbols('x y')\nplot_implicit(Eq(x**2+y**2, 4))\n```\n\n----------------------------------------\n\nTITLE: Series Expansion in SymPy\nDESCRIPTION: Demonstrates computing series expansions of functions around a point using series() method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nexpr = exp(sin(x))\nexpr.series(x, 0, 4)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Precision Issues with math.pi in SymPy\nDESCRIPTION: This snippet illustrates why using the standard library `math.pi` (a float) with SymPy can lead to unexpected results due to precision limitations. `math.pi` is an approximation, so `sympy.sin(math.pi)` evaluates to a very small non-zero number instead of the exact zero.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_20\n\nLANGUAGE: py\nCODE:\n```\n>>> import math\n>>> math.pi # a float\n3.141592653589793\n>>> import sympy\n>>> sympy.sin(math.pi)\n1.22464679914735e-16\n```\n\n----------------------------------------\n\nTITLE: Exploring Tree Representation of Expressions in SymPy\nDESCRIPTION: This snippet demonstrates how symbolic expressions are represented as trees in SymPy using the srepr function. It shows the internal structure of expressions with nested operations like addition, multiplication, and exponentiation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, srepr\n>>> x = Symbol('x')\n>>> e = 1 + 1/(2 + x**2)\n>>> e\n1 + 1/(x**2 + 2)\n>>> print(srepr(e))\nAdd(Integer(1), Pow(Add(Pow(Symbol('x'), Integer(2)), Integer(2)), Integer(-1)))\n```\n\n----------------------------------------\n\nTITLE: Viewing Git Remote Configuration\nDESCRIPTION: Command to view the configured remote repositories for the local SymPy project.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit remote -v\n```\n\n----------------------------------------\n\nTITLE: Comparing SymPy's evalf() Precision with math Module Functions\nDESCRIPTION: This snippet demonstrates the higher precision capabilities of SymPy's `evalf()` method compared to standard `math` functions. `evalf()` uses arbitrary-precision arithmetic and allows specifying the desired number of digits, providing more accurate numerical results than the fixed-precision floats used by the `math` module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_23\n\nLANGUAGE: py\nCODE:\n```\n>>> sympy.sin(1).evalf(30)\n0.841470984807896506652502321630\n>>> math.sin(1)\n0.8414709848078965\n```\n\n----------------------------------------\n\nTITLE: Coset Enumeration with Max Cosets Limit in Python\nDESCRIPTION: Example showing coset enumeration with a maximum coset limit parameter to prevent runaway computations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/fp_groups.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nF, a, b = free_group(\"a, b\")\nCox = FpGroup(F, [a**6, b**6, (a*b)**2, (a**2*b**2)**2, (a**3*b**3)**5])\nC_r = coset_enumeration_r(Cox, [a], max_cosets=50)\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy in editable mode from Git\nDESCRIPTION: This command installs SymPy in editable mode, allowing the installed version to always point to the version in the Git directory.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install --editable .\n```\n\n----------------------------------------\n\nTITLE: Working with symbolic exponents in SymPy\nDESCRIPTION: Demonstrating polynomial manipulations with symbolic exponents. Results may depend on the assumptions about the base, as shown with the GCD examples where variable assumptions affect the outcome.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> n = var('n')\n>>> gcd(x**n - x**(2*n), x**n)\n n\nx\n\n>>> gcd(x**(n + 4), x**(n + 1) + 3*x**n)\n1\n>>> x = var('x', positive=True)\n>>> gcd(x**(n + 4), x**(n + 1) + 3*x**n)\n n\nx\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy Memoization Module for Documentation\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the sympy.utilities.memoization module. This includes functions, classes, and other objects defined in the module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/memoization.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.utilities.memoization\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Symbol Name Typo Example in SymPy\nDESCRIPTION: Illustrates how string inputs can mask typos in function names, while symbolic manipulation catches them.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import expand_trig\n>>> expand_trig(\"sine(x + y)\")\nsine(x + y)\n```\n\n----------------------------------------\n\nTITLE: Basic Structural Equality Example in Python\nDESCRIPTION: Demonstrates that SymPy uses structural equality rather than mathematical equality for the == operator.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> x*(x - 1) == x**2 - x\nFalse\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Module Documentation\nDESCRIPTION: ReStructuredText directives for documenting the named_groups module and its core functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/named_groups.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.combinatorics.named_groups\n\n.. autofunction:: SymmetricGroup\n\n.. autofunction:: CyclicGroup\n\n.. autofunction:: DihedralGroup\n\n.. autofunction:: AlternatingGroup\n\n.. autofunction:: AbelianGroup\n```\n\n----------------------------------------\n\nTITLE: Documenting ksubsets Method in RST\nDESCRIPTION: RST directive for auto-generating documentation for the ksubsets method from the sympy.combinatorics.subsets module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/subsets.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automethod:: sympy.combinatorics.subsets.ksubsets\n```\n\n----------------------------------------\n\nTITLE: Creating Musculotendon Actuator Model in Python\nDESCRIPTION: Instantiates the triceps pathway and musculotendon actuator using the ExtensorPathway class. Sets up activation dynamics and combines with the biceps model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ntriceps_pathway = ExtensorPathway(Cm, Dm, P3, B.y, -C.z, D.z, r, q4)\ntriceps_activation = bm.FirstOrderActivationDeGroote2016.with_defaults('triceps')\ntriceps = bm.MusculotendonDeGroote2016.with_defaults('triceps', triceps_pathway, triceps_activation)\n\nloads = biceps.to_loads() + triceps.to_loads() + [lever_resistance, gravC, gravD]\n```\n\n----------------------------------------\n\nTITLE: Converting List to Continued Fraction in Python with SymPy\nDESCRIPTION: This function converts a list representation of a continued fraction to its actual fraction form using SymPy. It works backwards through the list to construct the fraction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n>>> def list_to_frac(l):\n...     expr = Integer(0)\n...     for i in reversed(l[1:]):\n...         expr += i\n...         expr = 1/expr\n...     return l[0] + expr\n>>> list_to_frac([x, y, z])\n      1\nx + ─────\n        1\n    y + ─\n        z\n\n>>> list_to_frac([1, 2, 3, 4])\n43\n──\n30\n```\n\n----------------------------------------\n\nTITLE: Importing Docstrings with Sphinx RST Directives\nDESCRIPTION: Example showing how to import docstrings from the geometry module into Sphinx documentation using module, autofunction, and autoclass directives.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/docstring.rst#2025-04-22_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\nUtils\n=====\n\n.. module:: sympy.geometry.util\n\n.. autofunction:: intersection\n\n.. autofunction:: convex_hull\n\n.. autofunction:: are_similar\n\nPoints\n======\n\n.. module:: sympy.geometry.point\n\n.. autoclass:: Point\n   :members:\n\nLines\n=====\n\n.. module:: sympy.geometry.line\n\n.. autoclass:: LinearEntity\n   :members:\n\n.. autoclass:: Line\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Randomizing Continued Fraction for Exercise in Python with SymPy\nDESCRIPTION: This snippet sets up an exercise for reconstructing a continued fraction. It creates a list of symbols, randomizes them, and generates a canceled continued fraction for practice.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\n>>> import random\n>>> l = list(symbols('a0:5'))\n>>> random.shuffle(l)\n>>> orig_frac = frac = cancel(list_to_frac(l))\n>>> del l\n```\n\n----------------------------------------\n\nTITLE: Importing SymPy and Setting Up Basic Symbols\nDESCRIPTION: Demonstrates the basic imports and setup needed to use the AGCA module, including importing SymPy, defining symbolic variables, and initializing pretty printing with Unicode support.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> x, y, z = symbols('x,y,z')\n>>> init_printing(use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Working with Lists in SymPy\nDESCRIPTION: Examples of creating and manipulating lists with SymPy expressions\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\na = [x, 1]  # A simple list of two items\na[0]  # This is the first item\na[0] = 2  # You can change values of lists\nprint(solve(x**2 + 2*x - 1, x)) # Some functions return lists\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Functions in SymPy\nDESCRIPTION: Demonstrates how to properly create symbolic functions in SymPy using the Function class, showing the difference between callable function objects and function evaluations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Function\nf = Function('f')\nx = Symbol('x')\nf(x)\nf(x)\n```\n\n----------------------------------------\n\nTITLE: Solving Algebraic Equations with SymPy\nDESCRIPTION: This snippet demonstrates how to use the solve function from SymPy's solvers module to solve a simple quadratic equation. It creates a Symbol object for the variable x and then solves the equation x^2 - 1 = 0.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solvers.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers import solve\n>>> from sympy import Symbol\n>>> x = Symbol('x')\n>>> solve(x**2 - 1, x)\n[-1, 1]\n```\n\n----------------------------------------\n\nTITLE: Defining Polyhedron Module and Class in reStructuredText\nDESCRIPTION: This snippet defines the Polyhedron module and class using reStructuredText directives. It sets up the module path and uses autoclass to generate documentation for the Polyhedron class and its members.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/polyhedron.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. module:: sympy.combinatorics.polyhedron\n\n.. autoclass:: Polyhedron\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Installing Python Virtual Environment for Documentation\nDESCRIPTION: Creates a Python virtual environment and activates it, providing an isolated environment for installing documentation dependencies without affecting the system Python installation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/build-docs.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv /path/to/my/venv  # create the venv\n```\n\nLANGUAGE: bash\nCODE:\n```\nsource /path/to/my/venv/bin/activate  # need to rerun this each time you open a new terminal\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Error When Applying SymPy Function to NumPy Array\nDESCRIPTION: This snippet demonstrates that SymPy functions, like `sympy.sin`, are not designed to operate directly on NumPy arrays. Attempting to do so results in an AttributeError because the NumPy array object does not have the methods expected by SymPy functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_17\n\nLANGUAGE: py\nCODE:\n```\n>>> import numpy as np\n>>> import sympy\n>>> a = np.array([0., 1., 2.])\n>>> sympy.sin(a)\nTraceback (most recent call last):\n...\nAttributeError: 'ImmutableDenseNDimArray' object has no attribute 'as_coefficient'\n```\n\n----------------------------------------\n\nTITLE: Using srepr() for Detailed Expression Representation in SymPy\nDESCRIPTION: Shows how to use srepr() to get a detailed string representation of a SymPy expression, useful for understanding its internal structure.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/printing.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsrepr(Integral(sqrt(1/x), x))\n```\n\n----------------------------------------\n\nTITLE: Defining Unevaluated Derivative for Custom Function in Python\nDESCRIPTION: Implements a function f(x, y) that is linear in the first argument and has an unevaluated derivative on the second argument.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.core.function import ArgumentIndexError\nclass f(Function):\n   @classmethod\n   def eval(cls, x, y):\n       pass\n\n   def fdiff(self, argindex):\n       if argindex == 1:\n          return 1\n       raise ArgumentIndexError(self, argindex)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Group Numbers Module\nDESCRIPTION: ReStructuredText documentation layout defining the module reference and function autodoc directives for the group numbers functionality in SymPy's combinatorics package.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/group_numbers.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _combinatorics-group_numbers:\n\nNumber of groups\n================\n\n.. module:: sympy.combinatorics.group_numbers\n\n.. autofunction:: is_nilpotent_number\n\n.. autofunction:: is_abelian_number\n\n.. autofunction:: is_cyclic_number\n\n.. autofunction:: groups_count\n```\n\n----------------------------------------\n\nTITLE: Revealing Roots in Polynomial Rings with factor() in SymPy\nDESCRIPTION: Using factor() to reveal roots that lie in a specific polynomial ring. This example shows how factorization can identify roots that are polynomial functions of a parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import expand, factor\n>>> from sympy.abc import x, a\n>>> p = expand((x - a**2)*(x + a + a**3))\n>>> p\n-a**5 + a**3*x - a**3 - a**2*x + a*x + x**2\n>>> factor(p)\n(-a**2 + x)*(a**3 + a + x)\n```\n\n----------------------------------------\n\nTITLE: Creating Electric Potential Field\nDESCRIPTION: Demonstrates how to create a scalar electric potential field using base scalars in a reference frame.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.vector import ReferenceFrame\nR = ReferenceFrame('R')\nelectric_potential = 2*R[0]**2*R[1]\nprint(electric_potential)\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Simply Supported Beam with Multiple Loads using SymPy\nDESCRIPTION: This example demonstrates how to analyze a beam with point loads and distributed loads. It calculates the reaction forces, load distribution, shear force, bending moment, slope, and deflection for a beam with multiple supports and loads.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> E, I = symbols('E, I')\n>>> b = Beam(11, E, I)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(2, 2, 0, end=6)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(5, 11, -2)\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.reaction_loads\n{R₁: -37/8, R₂: -27/8}\n>>> b.load\n      -1                                       -1\n37⋅<x>              0            0   27⋅<x - 8>               -2\n- ──────── + 2⋅<x - 2>  - 2⋅<x - 6>  - ──────────── + 5⋅<x - 11>\n     8                                      8\n>>> b.shear_force()\n      0                                       0\n37⋅<x>             1            1   27⋅<x - 8>              -1\n─────── - 2⋅<x - 2>  + 2⋅<x - 6>  + ─────────── - 5⋅<x - 11>\n   8                                     8\n>>> b.bending_moment()\n      1                                   1\n37⋅<x>           2          2   27⋅<x - 8>              0\n─────── - <x - 2>  + <x - 6>  + ─────────── - 5⋅<x - 11>\n   8                                 8\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.slope()\n      2          3          3             2\n37⋅<x>    <x - 2>    <x - 6>    27⋅<x - 8>              1\n- ─────── + ──────── - ──────── - ─────────── + 5⋅<x - 11>  + 36\n     16        3          3            16\n────────────────────────────────────────────────────────────────\n                              E⋅I\n>>> b.deflection()\n             3          4          4            3             2\n       37⋅<x>    <x - 2>    <x - 6>    9⋅<x - 8>    5⋅<x - 11>\n36⋅x - ─────── + ──────── - ──────── - ────────── + ───────────\n          48        12         12          16            2\n───────────────────────────────────────────────────────────────\n                              E⋅I\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in SymPy\nDESCRIPTION: Demonstrates how to create vectors in SymPy using components and unit vectors. It shows the conversion from traditional vector notation to SymPy's object-oriented approach.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nvec = (Qo.pos_from(O))/L\n```\n\nLANGUAGE: python\nCODE:\n```\nvec = u1*N.x + u2*N.y\n```\n\n----------------------------------------\n\nTITLE: Generating SymPy Logos using Make Command\nDESCRIPTION: This command generates SymPy's collection of official logos. It requires the user to first install the necessary dependencies and then run the make command in the doc directory. The generated logos will be stored in the _build/logo subdirectory.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/logo.rst#2025-04-22_snippet_0\n\nLANGUAGE: none\nCODE:\n```\n$ cd doc\n\n$ make logo # will be stored in the _build/logo subdirectory\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Module Documentation Directive\nDESCRIPTION: Sphinx documentation directive to automatically generate API documentation for the sympy.tensor.indexed module, including all members.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/tensor/indexed.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n===============\nIndexed Objects\n===============\n\n.. automodule:: sympy.tensor.indexed\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Variable Argument Function Usage\nDESCRIPTION: Demonstrates how arguments are stored in the .args property for functions with variable arguments.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> f(1).args\n(1,)\n>>> f(1, 2).args\n(1, 2)\n>>> f(1, 2, 3).args\n(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Identifying Function Types in SymPy Integrand\nDESCRIPTION: Internal SymPy helper function for Meijer G-function integration. It analyzes an expression `f` with variable `x` and assembles a tuple representing the types of mathematical functions present (e.g., `(cos, exp)` for `exp(x)*cos(x)`). This tuple is used for table lookups.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n_mytype(f, x)\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic Inequalities with SymPy in Python\nDESCRIPTION: This snippet demonstrates the creation of a symbolic inequality (x < 0) in SymPy. Unlike symbolic equality which requires `Eq()`, inequality relations like less than (`<`), less than or equal to (`<=`), greater than (`>`), and greater than or equal to (`>=`) can be created directly using the standard Python operators when applied to SymPy symbols or expressions. It requires the SymPy library and assumes `x` is a defined SymPy symbol.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/glossary.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx < 0\n```\n\n----------------------------------------\n\nTITLE: Correct Syntax for Differential Equation with Option 2\nDESCRIPTION: Shows the correct syntax for specifying a differential equation when using option 2 syntax, where y already represents y(t).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> dsolve(y.diff(t), y)\nEq(y(t), C1)\n```\n\n----------------------------------------\n\nTITLE: Defining Forces and Torques in SymPy\nDESCRIPTION: Illustrates how to define forces and torques in SymPy using force lists. This approach is used for input to SymPy's dynamics solvers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfL.append((O, f1*N.x + f2*N.y))\n```\n\nLANGUAGE: python\nCODE:\n```\nfl.append((A, -c*qAd*A.z))\n```\n\n----------------------------------------\n\nTITLE: Using Dictionaries in SymPy\nDESCRIPTION: Demonstrates dictionary usage with SymPy including roots function that returns root multiplicities\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nd = {'a': 1, 'b': 2}\nd['a']\nroots((x - 1)**2*(x - 2), x)\nroots((x - 5)**2*(x + 3), x)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Beam with Variable Moment of Inertia\nDESCRIPTION: Creates a combined beam with different moments of inertia (1.5*I and I) and analyzes its response to a 20N point load at the free end. Calculates reaction forces, shear force, bending moment, and slope.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b1 = Beam(2, E, 1.5*I)\n>>> b2 = Beam(2, E, I)\n>>> b = b1.join(b2, \"fixed\")\n>>> b.apply_load(20, 4, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 0, -2)\n>>> b.bc_slope = [(0, 0)]\n>>> b.bc_deflection = [(0, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n```\n\n----------------------------------------\n\nTITLE: Using Piecewise for Conditional Symbolic Expressions\nDESCRIPTION: Demonstrates how to use SymPy's Piecewise to represent conditional expressions symbolically instead of using Python if-else statements.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nif x > 0:\n    expr = 1\nelse:\n    expr = 0\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Piecewise, pprint\n>>> expr = Piecewise((1, x > 0), (0, True))\n>>> pprint(expr, use_unicode=True)\n⎧1  for x > 0\n⎨\n⎩0  otherwise\n>>> expr.subs(x, 1)\n1\n>>> expr.subs(x, -1)\n0\n```\n\n----------------------------------------\n\nTITLE: Converting Ring Series to SymPy Expression in SymPy\nDESCRIPTION: Example showing how to convert a polynomial ring series (PolyElement) back to a standard SymPy expression (Expr) using the as_expr() method. This allows using the series with other SymPy types.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.polys.ring_series import rs_exp\n>>> from sympy.abc import a, b, c\n>>> series = rs_exp(x, x, 5)\n>>> a + series.as_expr()\na + x**4/24 + x**3/6 + x**2/2 + x + 1\n```\n\n----------------------------------------\n\nTITLE: Basic Equation Solving with solve() and solveset()\nDESCRIPTION: Demonstrates basic usage of solve() and solveset() functions to solve x^2 = y for x. Shows how solutions can be returned as dictionaries or sets.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-equation-algebraically.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.abc import x, y\n>>> from sympy import solve\n>>> solve(x**2 - y, x, dict=True)\n[{x: -sqrt(y)}, {x: sqrt(y)}]\n\n>>> from sympy import solveset\n>>> from sympy.abc import x, y\n>>> solveset(x**2 - y, x)\n{-sqrt(y), sqrt(y)}\n```\n\n----------------------------------------\n\nTITLE: Using Sets and Assumptions for Mathematical Classification\nDESCRIPTION: Shows how to use SymPy's sets and assumptions for strict mathematical classification of objects. Examples demonstrate set membership checking and logical deduction with assumptions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/classification.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ask, Q\n>>> S.One in S.Reals\nTrue\n>>> ask(Q.even(2*x), Q.odd(x))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Computing Curl of Vector Field\nDESCRIPTION: Demonstrates calculation of curl operator on a vector field using SymPy's curl function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.vector import ReferenceFrame\nR = ReferenceFrame('R')\nfrom sympy.physics.vector import curl\nfield = R[0]*R[1]*R[2]*R.x\ncurl(field, R)\n```\n\n----------------------------------------\n\nTITLE: Handling Equations with No Solution in SymPy's nsolve in Python\nDESCRIPTION: Illustrates how nsolve handles equations with no solution, such as e^x = 0. In such cases, SymPy typically returns an error indicating that no root could be found within the given tolerance.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import nsolve, exp\n>>> from sympy.abc import x\n>>> nsolve(exp(x), x, 1, prec=20)\nTraceback (most recent call last):\n...\nValueError: Could not find root within given tolerance. (5.4877893607115270300540019e-18 > 1.6543612251060553497428174e-24)\nTry another starting point or tweak arguments.\n```\n\n----------------------------------------\n\nTITLE: Plotting Normalized Fiber Force-Velocity Curve in Python\nDESCRIPTION: Creates a plot of the normalized fiber force-velocity characteristics using matplotlib. This visualizes the relationship between normalized fiber velocity and the resulting normalized force.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n_ = ax.plot(l_M_tilde_num, fv_M_callable(v_M_tilde_num))\n_ = ax.set_xlabel('Normalized fiber velocity')\n_ = ax.set_ylabel('Normalized fiber force-velocity')\n```\n\n----------------------------------------\n\nTITLE: Representing Complex Solutions with ComplexRegion in Python\nDESCRIPTION: This snippet shows how to use the ComplexRegion class to represent infinite solutions in the complex domain, specifically for the equation |z| = 1 (unit circle).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import ComplexRegion, FiniteSet, Interval, pi, pprint\npprint(ComplexRegion(FiniteSet(1)*Interval(0, 2*pi), polar=True), use_unicode=True)\n```\n\n----------------------------------------\n\nTITLE: Cloning the SymPy Repository\nDESCRIPTION: Command to clone the SymPy repository from GitHub to the local machine.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/dev-setup.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/sympy/sympy\n```\n\n----------------------------------------\n\nTITLE: Type Conversion with sympify\nDESCRIPTION: Shows how SymPy converts Python types to SymPy types using the sympify function\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntype(2)\ntype(sympify(2))\n```\n\n----------------------------------------\n\nTITLE: Set Comprehension in SymPy\nDESCRIPTION: Demonstrates the use of set comprehension in SymPy, which is consistent with symbolic set processing methods.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/sets.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nFiniteSet(*s)\n```\n\nLANGUAGE: Python\nCODE:\n```\nFiniteSet(*simplify(s))\n```\n\n----------------------------------------\n\nTITLE: Integrating Exponential-Polynomial Combinations with SymPy in Python\nDESCRIPTION: This code snippet illustrates how to symbolically integrate an expression composed of polynomial, exponential, and trigonometric (cosine) terms using SymPy. Prerequisites are the sympy package and a properly defined symbolic variable. Inputs are multiplicative combinations of functions, and the output is a symbolic combination involving polynomial, exponential, trigonometric, and rational terms. The output remains symbolic and suitable for further manipulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> integrate(x**2 * exp(x) * cos(x), x)\n 2  x           2  x                         x           x\nx *e *sin(x)   x *e *cos(x)      x          e *sin(x)   e *cos(x)\n------------ + ------------ - x*e *sin(x) + --------- - ---------\n     2              2                           2           2\n```\n\n----------------------------------------\n\nTITLE: Complex Mathematical Equations in LaTeX\nDESCRIPTION: Collection of LaTeX formatted mathematical equations describing various conditions and relationships for G-functions and their inverse Laplace transforms. Includes parameters p, q, u, v, and various constraints.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_13\n\nLANGUAGE: latex\nCODE:\n```\n.. math:: p = q \\wedge v < u \\wedge 0 \\leq b^{*} \\wedge c^{*} = 0 \\wedge 0 < \\omega \\wedge \\Re{\\mu} < 1 \\wedge C_{1} \\wedge C_{2} \\wedge C_{3} \\wedge C_{7} \\wedge C_{11}\n```\n\nLANGUAGE: latex\nCODE:\n```\n.. math:: f(t) = \\frac{1}{2\\pi i} \\int_{c-i\\infty}^{c+i\\infty} e^{zt} G(bz^a) \\mathrm{d}z\n```\n\nLANGUAGE: latex\nCODE:\n```\n.. math :: G(z) = \\frac{1}{2\\pi i} \\int_L \\Delta(s) z^s \\mathrm{d}s\n```\n\nLANGUAGE: latex\nCODE:\n```\n.. math :: f(t) = \\frac{1}{t} \\frac{1}{2\\pi i} \\int_L \\Delta(s) \\frac{1}{\\Gamma(-as)} \\left(\\frac{b}{t^a}\\right)^s \\mathrd{s}\n```\n\n----------------------------------------\n\nTITLE: Defining Kinematic Differential Equations for Bicycle Model in Python\nDESCRIPTION: Sets up the kinematic differential equations that relate the time derivatives of generalized coordinates to the generalized speeds.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n>>> kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n```\n\n----------------------------------------\n\nTITLE: Example of dsolve Error When Using a Variable Instead of a Function\nDESCRIPTION: Demonstrates the error that occurs when trying to use dsolve with a variable (x) rather than a function (y(x)) as the second argument.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> dsolve(Derivative(y(x), x, x) + 9*y(x), x)\nTraceback (most recent call last):\n    ...\nValueError: dsolve() and classify_ode() only work with functions of one variable, not x\n```\n\n----------------------------------------\n\nTITLE: Handling Negative Powers in Polynomial Conversion\nDESCRIPTION: Shows how negative powers of variables are treated when converting to polynomials. The reciprocal of a variable is handled as an algebraically independent generator.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> e = x - 1/x\n>>> e.as_poly()\nPoly(x - (1/x), x, 1/x, domain='ZZ')\n```\n\n----------------------------------------\n\nTITLE: Specifying Algebraic Constraint Indexes for DAE Systems\nDESCRIPTION: Defines which rows in the equations represent algebraic constraints, which is required information for differential algebraic equation (DAE) solvers.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nalg_con = [2]\nalg_con_full = [4]\n```\n\n----------------------------------------\n\nTITLE: Using Puiseux Ring for Laurent and Puiseux Series in SymPy\nDESCRIPTION: Example demonstrating how to use puiseux_ring to create a ring that supports Laurent and Puiseux series (with fractional exponents). The example computes cosine and tangent series using rs_cos and rs_tan functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.polys.ring_series import rs_cos, rs_tan\n>>> from sympy.polys.puiseux import puiseux_ring\n>>> R, x, y = puiseux_ring('x, y', QQ)\n\n>>> rs_cos(x + x*y, x, 3)/x**3\nx**(-3) + -1/2*x**(-1) + -1*x**(-1)*y + -1/2*x**(-1)*y**2\n\n>>> rs_tan(x**QQ(2, 5)*y**QQ(1, 2), x, 2)\nx**(2/5)*y**(1/2) + 1/3*x**(6/5)*y**(3/2)\n```\n\n----------------------------------------\n\nTITLE: Multivariate Polynomial Rings\nDESCRIPTION: Demonstrates construction and usage of multivariate polynomial rings, including nested polynomial rings and their internal representations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> x, y = symbols('x, y')\n>>> K = ZZ[x,y]\n>>> xk = K(x)\n>>> yk = K(y)\n>>> xk**2*yk + xk + yk\nx**2*y + x + y\n>>> K = ZZ[x][y]\n>>> p = K(x**2 + x*y + y**2)\n>>> dict(p)\n{(0,): x**2, (1,): x, (2,): 1}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Stats Sampling\nDESCRIPTION: Shows the deprecated numsamples parameter usage in stats.sample() and provides alternative approaches using list comprehension and size parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.stats import Die, sample\n>>> X = Die('X', 6)\n>>> sample(X, numsamples=3) # doctest: +SKIP\n[3, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Comparing Different Tree Representations of Equivalent Expressions\nDESCRIPTION: This snippet shows how the same mathematical expression can have different tree representations in SymPy. It demonstrates the expansion of an expression and shows the different srepr outputs for equivalent forms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> e = x*(x + 1)\n>>> e\nx*(x + 1)\n>>> e.expand()\nx**2 + x\n>>> print(srepr(e))\nMul(Symbol('x'), Add(Symbol('x'), Integer(1)))\n>>> print(srepr(e.expand()))\nAdd(Pow(Symbol('x'), Integer(2)), Symbol('x'))\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoModule Documentation for Tensor Operators\nDESCRIPTION: RST directive to automatically generate documentation for all members of the sympy.tensor.toperators module using Sphinx.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/tensor/toperators.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.tensor.toperators\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Proper Rational Number Creation in SymPy\nDESCRIPTION: Demonstrates correct ways to create rational numbers using Rational() and S() to preserve exact values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/best-practices.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> x + 2/7 # The exact value of 2/7 is lost\nx + 0.2857142857142857\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Rational, S\n>>> x + Rational(2, 7)\nx + 2/7\n>>> x + S(2)/7 # Equivalently\nx + 2/7\n```\n\n----------------------------------------\n\nTITLE: Using Rational Constructor in SymPy\nDESCRIPTION: Demonstrates the correct way to create rational numbers in SymPy using the Rational constructor to maintain symbolic representation instead of floating point values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nx + Rational(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Updating SymPy Websites for Release\nDESCRIPTION: This command updates docs.sympy.org and sympy.org with the new release information. It requires local clones and push access to these repositories.\nSOURCE: https://github.com/sympy/sympy/blob/master/release/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nrever VERSION -a update_websites\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for sympy.physics.quantum.state using Sphinx Automodule\nDESCRIPTION: This Sphinx reStructuredText directive employs `automodule` to automatically generate documentation by inspecting the specified Python module (`sympy.physics.quantum.state`). The `:members:` option ensures that documentation for all public classes, methods, and functions within the module is included in the output. This relies on docstrings present in the target Python module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/state.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: sympy.physics.quantum.state\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Polycyclic Group from Symmetric Group\nDESCRIPTION: Demonstrates how to create a polycyclic group from a symmetric group and access its basic properties like pcgs length, pc_series, and relative order.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/pc_groups.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.named_groups import SymmetricGroup\nG = SymmetricGroup(4)\nPcGroup = G.polycyclic_group()\nlen(PcGroup.pcgs)\npc_series = PcGroup.pc_series\npc_series[0].equals(G)  # use equals, not literal `==`\ngen = pc_series[len(pc_series) - 1].generators[0]\ngen.is_identity\nPcGroup.relative_order\n```\n\n----------------------------------------\n\nTITLE: Factoring in terms of cyclotomic polynomials\nDESCRIPTION: Using SymPy to decompose polynomials of the form x^n ± 1 in terms of cyclotomic polynomials. This shows SymPy's efficiency in handling special polynomial forms.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> factor(x**15 - 1)\n        ⎛ 2        ⎞ ⎛ 4    3    2        ⎞ ⎛ 8    7    5    4    3       ⎞\n(x - 1)⋅⎝x  + x + 1⎠⋅⎝x  + x  + x  + x + 1⎠⋅⎝x  - x  + x  - x  + x - x + 1⎠\n```\n\n----------------------------------------\n\nTITLE: Initializing Polynomial Expressions in SymPy for Root Finding\nDESCRIPTION: Setup code creating polynomial expressions with known roots for demonstration. Creates both a concrete polynomial (x+2)²(x-3) and a symbolic polynomial (x+a)²(x-b).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import solve, roots, real_roots, factor, nroots, RootOf, expand\n>>> from sympy import Poly\n>>> expression = (x+2)**2 * (x-3)\n>>> symbolic = (x+a)**2 * (x-b)\n```\n\n----------------------------------------\n\nTITLE: Symbol Definition in SymPy\nDESCRIPTION: Demonstrates the necessity of defining symbols before use in SymPy expressions, showing how to use the var() function to create standard symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\nz**2  # z is not defined yet #doctest: +SKIP\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'z' is not defined\nsympy.var('z')  # This is the easiest way to define z as a standard symbol\nz\nz**2\nz**2\n```\n\n----------------------------------------\n\nTITLE: Circle Perimeter Calculation\nDESCRIPTION: Demonstrates calculating circle perimeter using both parametric and implicit equations with vector integration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/vector_integration.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nparam_circle = ParametricRegion((4*cos(theta), 4*sin(theta)), (theta, 0, 2*pi))\nimplicit_circle = ImplicitRegion((x, y), x**2 + y**2 - 4)\nvector_integrate(1, param_circle)\nvector_integrate(1, implicit_circle)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for SymPy Polynomial Solvers Module\nDESCRIPTION: Restructured Text (RST) documentation defining the structure and available functions in the polynomial solvers module of SymPy. It includes autofunction directives to generate documentation for several key functions used for solving systems of linear equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/solvers.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _poly_solvers-docs:\n\nPoly solvers\n============\n\nThis module provides functions for solving systems of linear equations that\nare used internally in sympy.\n\n.. module::sympy.polys.solvers\n\n.. automodule:: sympy.polys.solvers\n\n.. autofunction:: sympy.polys.solvers.solve_lin_sys\n\n.. autofunction:: sympy.polys.solvers.eqs_to_matrix\n\n.. autofunction:: sympy.polys.solvers.sympy_eqs_to_ring\n\n.. autofunction:: sympy.polys.solvers._solve_lin_sys\n\n.. autofunction:: sympy.polys.solvers._solve_lin_sys_component\n```\n\n----------------------------------------\n\nTITLE: Attempting Two G-Function Rewrite in SymPy Integration\nDESCRIPTION: Internal SymPy helper function for Meijer G-function integration. It orchestrates the process of attempting to rewrite the input expression as a product of two G-functions, utilizing helpers like `_mul_as_two_parts` and `_rewrite_single` on the factors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n_rewrite2\n```\n\n----------------------------------------\n\nTITLE: Expression Substitution in SymPy\nDESCRIPTION: Examples of performing substitution operations on SymPy expressions, including point evaluation and subexpression replacement.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/basic_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nexpr = cos(x) + 1\nexpr.subs(x, y)\n\nexpr.subs(x, 0)\n\nexpr = x**y\nexpr = expr.subs(y, x**y)\nexpr = expr.subs(y, x**x)\n```\n\n----------------------------------------\n\nTITLE: Examining Muscle Pathway Properties\nDESCRIPTION: Demonstrates how to access the attachment points, length, and extension velocity of a muscle pathway object.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle_pathway.attachments\n(O, P)\n```\n\n----------------------------------------\n\nTITLE: Polynomial Factorization Using Dense Univariate Polynomial Representation\nDESCRIPTION: This snippet demonstrates the factorization of a polynomial using both the high-level factor function and the low-level dup_factor_list function that operates on the DUP representation with integer coefficients.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import factor\n>>> from sympy.polys.factortools import dup_factor_list\n>>> e = 2*x**3 + 10*x**2 + 16*x + 8\n>>> e\n2*x**3 + 10*x**2 + 16*x + 8\n>>> factor(e)\n2*(x + 1)*(x + 2)**2\n>>> from sympy import ZZ\n>>> p = [ZZ(2), ZZ(10), ZZ(16), ZZ(8)]\n>>> p\n[2, 10, 16, 8]\n>>> dup_factor_list(p, ZZ)\n(2, [([1, 1], 1), ([1, 2], 2)])\n```\n\n----------------------------------------\n\nTITLE: Multivariate GCD and factorization in SymPy\nDESCRIPTION: Computing greatest common divisors and factorizations for multivariate polynomials in Z[x,y,z]. These operations handle complex expressions with multiple variables and high exponents.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> f = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5\n>>> g = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z\n>>> h = 11*x**12*y**7*z**13 - 23*x**2*y**8*z**10 + 47*x**17*y**5*z**8\n\n>>> gcd(f, g)\n1\n\n>>> gcd(expand(f*h), expand(g*h)) - h\n0\n\n>>> factor(expand(f*g))\n    7   ⎛   9  9  3       7  6       5    12       7⎞ ⎛   22       17  5  8      15  9  2         19  8    ⎞\n-2⋅y ⋅z⋅⎝6⋅x ⋅y ⋅z  + 10⋅x ⋅z  + 17⋅x ⋅y⋅z   + 40⋅y ⎠⋅⎝3⋅x   + 47⋅x  ⋅y ⋅z  - 6⋅x  ⋅y ⋅z  - 24⋅x⋅y  ⋅z  - 5⎠\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Lambdify Module in Python\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the sympy.utilities.lambdify module. This includes functions, classes, and other objects defined in the module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/lambdify.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: sympy.utilities.lambdify\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Computing with automatic field extensions\nDESCRIPTION: Using the extension parameter with cancel to recognize algebraic properties of irrational numbers. This example shows how setting extension=True finds the minimal algebraic domain for coefficients.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> f = x**3 + (sqrt(2) - 2)*x**2 - (2*sqrt(2) + 3)*x - 3*sqrt(2)\n>>> g = x**2 - 2\n\n>>> cancel(f/g)\n 3      2       2\nx  - 2⋅x  + √2⋅x  - 3⋅x - 2⋅√2⋅x - 3⋅√2\n───────────────────────────────────────\n                  2\n                 x  - 2\n\n>>> cancel(f/g, extension=True)\n 2\nx  - 2⋅x - 3\n────────────\n   x - √2\n\n>>> cancel(f/g, extension=sqrt(2))\n 2\nx  - 2⋅x - 3\n────────────\n   x - √2\n```\n\n----------------------------------------\n\nTITLE: Multiplying Sparse Distributed Monomials in Python\nDESCRIPTION: The sdm_monomial_mul function multiplies two monomials in a sparse distributed representation. It takes the two monomials as parameters and returns their product.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nsdm_monomial_mul(A, B)\n```\n\n----------------------------------------\n\nTITLE: Transfer Function Analysis with SymPy Control\nDESCRIPTION: Demonstrates calculation of transfer function from pole-zero plot, stability analysis, and impulse response. Uses SymPy's Control module to analyze system characteristics including DC gain and time domain response.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/control_problems.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import symbols, I, limit, pprint, solve, oo\nfrom sympy.physics.control import TransferFunction\n\ns, k = symbols('s k')\ngain = k                        # Let unknown gain be k\na = [-3]                        # Zero at -3 in S plane\nb = [-1, -2-I, -2+I]            # Poles at -1, (-2, j) and (-2, -j) in S plane\ntf = TransferFunction.from_zpk(a, b, gain, s)\npprint(tf)\ngain = tf.dc_gain()\nprint(gain)\nK = solve(gain - 20, k)[0]               # Solve for k\ntf = tf.subs({k: K})                     # Reconstruct the TransferFunction using .subs()\n```\n\n----------------------------------------\n\nTITLE: Trigonometric Function Manipulation\nDESCRIPTION: Examples of trigonometric simplification using trigsimp() and expand_trig() functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/simplification.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntrigsimp(sin(x)**2 + cos(x)**2)\ntrigsimp(sin(x)**4 - 2*cos(x)**2*sin(x)**2 + cos(x)**4)\nexpand_trig(sin(x + y))\nexpand_trig(tan(2*x))\n```\n\n----------------------------------------\n\nTITLE: Implementing Muscle Pathways and Activation\nDESCRIPTION: Creates muscle pathway and activation models for the biceps using DeGroote2016 parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/biomechanics/biomechanical-model-example.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbiceps_pathway = me.LinearPathway(Cm, Dm)\nbiceps_activation = bm.FirstOrderActivationDeGroote2016.with_defaults('biceps')\nbiceps = bm.MusculotendonDeGroote2016.with_defaults('biceps', biceps_pathway, biceps_activation)\n```\n\n----------------------------------------\n\nTITLE: Linearizing Bicycle Model Equations of Motion in SymPy\nDESCRIPTION: Linearizes the equations of motion about an equilibrium point, which represents the upright, straight-ahead configuration of the bicycle. This step is crucial for stability analysis.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/bicycle_example.rst#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\neq_point = {\n    u1d: 0,\n    u2d: 0,\n    u3d: 0,\n    u4d: 0,\n    u5d: 0,\n    u6d: 0,\n    q1: 0,\n    q2: 0,\n    q4: 0,\n    q5: 0,\n    u1: 0,\n    u2: 0,\n    u3: v/PaperRadRear,\n    u4: 0,\n    u5: 0,\n    u6: v/PaperRadFront,\n}\n\nAmat, _, _ = kane.linearize(A_and_B=True, op_point=eq_point, linear_solver='CRAMER')\nAmat = me.msubs(Amat, val_dict)\n```\n\n----------------------------------------\n\nTITLE: Running SymPy Tests Using Bash Commands\nDESCRIPTION: Commands for running various types of tests in the SymPy project using the bin/test script. These examples show how to run all tests, tests for specific files or modules, and code quality tests.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ./bin/test\n\n$ ./bin/test test_basic\n\n$ ./bin/test /core /utilities\n\n$ ./bin/test code_quality\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Zero Test with Warnings in SymPy\nDESCRIPTION: Implements a custom zero testing function that raises warnings when expressions cannot be definitively evaluated to zero. Used to debug zero testing issues in matrix operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/matrices.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\ndef my_iszero(x):\n    result = x.is_zero\n\n    # Warnings if evaluated into None\n    if result is None:\n        warnings.warn(\"Zero testing of {} evaluated into None\".format(x))\n    return result\n\nm.nullspace(iszerofunc=my_iszero) # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Solving for Reaction Loads and Calculating Beam Properties in Python\nDESCRIPTION: This code solves for reaction loads and calculates shear force, bending moment, slope, and deflection for a beam using SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nb.solve_for_reaction_loads(R, M)\nprint(b.reaction_loads)\nprint(b.load)\nprint(b.shear_force())\nprint(b.bending_moment())\nprint(b.slope())\nprint(b.deflection())\n```\n\n----------------------------------------\n\nTITLE: Handling Transcendental Equations\nDESCRIPTION: Demonstrates that SymPy cannot solve systems containing transcendental equations algebraically. It shows the resulting error and suggests using nsolve for numerical solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-system-of-equations-algebraically.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import cos, solve\n>>> from sympy.abc import x, y, z\n>>> solve([x - y, cos(x) - y], [x, y], dict=True)\nTraceback (most recent call last):\n    ...\nNotImplementedError: could not solve -y + cos(y)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import cos, nsolve\n>>> from sympy.abc import x, y, z\n>>> nsolve([x - y, cos(x) - y], [x, y], [1,1])\n    Matrix([\n    [0.739085133215161],\n    [0.739085133215161]])\n```\n\n----------------------------------------\n\nTITLE: Extracting Only Real Roots using real_roots in SymPy\nDESCRIPTION: Demonstrates the use of SymPy's `real_roots` function to find only the real roots of a polynomial, even if it has complex roots. This can be more efficient than finding all roots if only real ones are needed.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/find-roots-polynomial.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> real_roots(expression_complex)\n[3]\n```\n\n----------------------------------------\n\nTITLE: Creating and Demonstrating ImmutableMatrix in SymPy (Python)\nDESCRIPTION: This Python snippet demonstrates how to create an `ImmutableMatrix` from a standard mutable `Matrix` in SymPy. It initializes a mutable `Matrix`, modifies an element, converts it to an `ImmutableMatrix`, and then attempts to modify the immutable version, which correctly raises a `TypeError` illustrating the immutable nature.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/immutablematrices.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Matrix, ImmutableMatrix\n>>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n>>> M[1, 1] = 0\n>>> IM = ImmutableMatrix(M)\n>>> IM\nMatrix([\n[1, 2, 3],\n[4, 0, 6],\n[7, 8, 9]])\n>>> IM[1, 1] = 5\nTraceback (most recent call last):\n...\nTypeError: Can not set values in Immutable Matrix. Use Matrix instead.\n```\n\n----------------------------------------\n\nTITLE: Multiple Substitutions in SymPy\nDESCRIPTION: Demonstrates how to perform multiple substitutions simultaneously using lists of (old, new) pairs and list comprehensions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/basic_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nexpr = x**3 + 4*x*y - z\nexpr.subs([(x, 2), (y, 4), (z, 0)])\n\nexpr = x**4 - 4*x**3 + 4*x**2 - 2*x + 3\nreplacements = [(x**i, y**i) for i in range(5) if i % 2 == 0]\nexpr.subs(replacements)\n```\n\n----------------------------------------\n\nTITLE: Defining SymPy Utilities Documentation Structure in reStructuredText\nDESCRIPTION: This snippet defines the structure of the SymPy utilities documentation using reStructuredText. It sets up the document title, includes an automodule directive for sympy.utilities, and creates a table of contents with links to various utility components.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _utilities-docs:\n\n=========\nUtilities\n=========\n\n.. automodule:: sympy.utilities\n\nContents:\n\n.. toctree::\n   :titlesonly:\n\n   autowrap.rst\n   codegen.rst\n   decorator.rst\n   enumerative.rst\n   exceptions.rst\n   iterables.rst\n   lambdify.rst\n   memoization.rst\n   misc.rst\n   source.rst\n   timeutils.rst\n```\n\n----------------------------------------\n\nTITLE: Integrating Single Polynomial over 2D Polygon\nDESCRIPTION: Demonstrates how to integrate a single polynomial over a 2D polygon using polytope_integrate function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\npolytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), x)\npolytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), x + x*y + y**2)\n```\n\n----------------------------------------\n\nTITLE: Matrix Construction for Finite Differences\nDESCRIPTION: Creates a matrix of coefficients for finite difference calculations by evaluating derivatives at different points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/special_topics/finite_diff_derivatives.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nm11 = P(xN , xN, c, n).diff(c[0])\nm12 = P(xN, xN, c, n).diff(c[1])\nm13 = P(xN , xN, c, n).diff(c[2])\n# coefficients of c_i evaluated at x_i - h\nm21 = P(xN-h, xN, c, n).diff(c[0])\nm22 = P(xN-h, xN, c, n).diff(c[1])\nm23 = P(xN-h, xN, c, n).diff(c[2])\n# coefficients of c_i evaluated at x_i + h\nm31 = P(xN-2*h, xN, c, n).diff(c[0])\nm32 = P(xN-2*h, xN, c, n).diff(c[1])\nm33 = P(xN-2*h, xN, c, n).diff(c[2])\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing for Piecewise Functions\nDESCRIPTION: Examples showing how fcode handles piecewise functions in Fortran 77 and Fortran 95. This demonstrates conditional statements and the merge function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fcode(Piecewise((x,x<1),(x**2,True)), assign_to=\"var\"))\n      if (x < 1) then\n        var = x\n      else\n        var = x**2\n      end if\n>>> print(fcode(Piecewise((x,x<1),(x**2,True)), standard=95))\n      merge(x, x**2, x < 1)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Docstring in Python for SymPy\nDESCRIPTION: Example of a well-structured docstring for a SymPy function, including a description, examples (doctests), and proper imports. This docstring demonstrates how to document the fdiff method of the Heaviside function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef fdiff(self, argindex=1):\n    \"\"\"\n    Returns the first derivative of a Heaviside Function.\n\n    Examples\n    ========\n\n    >>> from sympy import Heaviside, diff\n    >>> from sympy.abc import x\n\n    >>> Heaviside(x).fdiff()\n    DiracDelta(x)\n\n    >>> Heaviside(x**2 - 1).fdiff()\n    DiracDelta(x**2 - 1)\n\n    >>> diff(Heaviside(x)).fdiff()\n    DiracDelta(x, 1)\n\n    \"\"\"\n    if argindex == 1:\n        return DiracDelta(self.args[0])\n    else:\n        raise ArgumentIndexError(self, argindex)\n```\n\n----------------------------------------\n\nTITLE: Performance Comparison between rs_series and Traditional Series in SymPy\nDESCRIPTION: Example demonstrating the speed difference between rs_series and traditional series method in SymPy. The rs_series function is significantly faster, especially for larger expansion orders.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/ringseries.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> %timeit ((sin(a) + cos(a))**10).series(a, 0, 5) # doctest: +SKIP\n1 loops, best of 3: 1.33 s per loop\n\n>>> %timeit rs_series((sin(a) + cos(a))**10, a, 5) # doctest: +SKIP\n100 loops, best of 3: 4.13 ms per loop\n\n>>> %timeit rs_series((sin(a) + cos(a))**10, a, 100) # doctest: +SKIP\n10 loops, best of 3: 32.8 ms per loop\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Symbols with Combined Assumptions\nDESCRIPTION: Demonstrates creating Symbol objects with multiple assumptions and querying combined predicates using fuzzy logic.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nx = Symbol('x', integer=True, positive=True)\nx.is_positive\nTrue\nx.is_integer\nTrue\nfuzzy_and([x.is_positive, x.is_integer])\nTrue\nx.is_positive and x.is_integer\nTrue\nfuzzy_or([x.is_positive, x.is_integer])\nTrue\n```\n\n----------------------------------------\n\nTITLE: Generating Pytest Module Documentation in RST\nDESCRIPTION: This RST code snippet uses the automodule directive to automatically generate documentation for all members of the sympy.testing.pytest module. It includes a title for the module and specifies that all members should be documented.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/testing/pytest.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n======\npytest\n======\n\n.. automodule:: sympy.testing.pytest\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements of Symbolic Matrix Products - SymPy - Python\nDESCRIPTION: Illustrates element-wise access to the result of a symbolic matrix multiplication using MatrixSymbol objects. The code demands SymPy as a prerequisite. Input matrices are symbolic, and the indices specify which entry to access; the output is the symbolic sum representing the matrix product entry. Useful for extracting specific elements in symbolic matrix computations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/expressions.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n(X*Y)[1, 2]\nX[1, 0]*Y[0, 2] + X[1, 1]*Y[1, 2] + X[1, 2]*Y[2, 2]\n```\n\n----------------------------------------\n\nTITLE: Example of an ODE with Implicit Solution\nDESCRIPTION: Demonstrates a case where an ODE cannot be solved explicitly for the function f(x), resulting in an implicit solution involving the exponential integral function Ei.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import dsolve, exp, symbols, Function\n>>> f = symbols(\"f\", cls=Function)\n>>> x = symbols(\"x\")\n>>> dsolve(f(x).diff(x) + exp(-f(x))*f(x))\nEq(Ei(f(x)), C1 - x)\n```\n\n----------------------------------------\n\nTITLE: Creating a Beam Object and Applying Loads in Python\nDESCRIPTION: This snippet demonstrates how to create a Beam object, apply various loads including point loads, moments, and distributed loads, and set boundary conditions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.continuum_mechanics.beam import Beam\nE, I = symbols('E, I')\nb = Beam(9, E, I)\nb.apply_load(12, 9, -1)\nb.apply_load(50, 5, -2)\nb.apply_load(8, 0, 0, end=5)\nb.bc_deflection.append((0, 0))\nb.bc_slope.append((0, 0))\nR, M = symbols('R, M')\nb.apply_load(R, 0, -1)\nb.apply_load(M, 0, -2)\n```\n\n----------------------------------------\n\nTITLE: Computing Principal Branch of a Polar Number in SymPy\nDESCRIPTION: SymPy function located in `functions/elementary/complexes.py`. Given a polar number `z` (representing a value on the Riemann surface of the logarithm) and its known `period` under multiplication by `Exp(2*pi*I)`, this function computes its principal branch representation on the complex plane (argument in `(-pi, pi]`). This is used within the Meijer G integration code to handle periodicity and branch cuts identified using `meijerg.get_period()`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nprincipal_branch(z, period)\n```\n\n----------------------------------------\n\nTITLE: Using SymPy's Fuzzy Logic Functions\nDESCRIPTION: This snippet demonstrates the use of SymPy's internal fuzzy logic functions for correct handling of fuzzy-bools.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.core.logic import fuzzy_not, fuzzy_and\n>>> print(fuzzy_not(True))\nFalse\n>>> print(fuzzy_not(False))\nTrue\n>>> print(fuzzy_not(None))\nNone\n>>> print(fuzzy_and([True, True]))\nTrue\n>>> print(fuzzy_and([True, None]))\nNone\n>>> print(fuzzy_and([False, None]))\nFalse\n```\n\n----------------------------------------\n\nTITLE: Preparing Product of Two G-Functions for Saxena's Theorem in SymPy\nDESCRIPTION: Internal SymPy function used before applying the Meijer G-function integration theorem (Saxena's generalization) to a product of two G-functions. It performs substitutions to normalize the arguments, typically reducing the exponent of the argument variable in both G-functions to unity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/g-functions.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n_rewrite_saxena\n```\n\n----------------------------------------\n\nTITLE: Testing 'divides' Function with Non-Integer Input (Python)\nDESCRIPTION: Shows the result of calling the custom `divides` function with a floating-point number (1.5). As expected from the `eval` method's type check, this raises a `TypeError` because 1.5 is explicitly not an integer.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> divides(1.5, 1)\nTraceback (most recent call last):\n...\nTypeError: m and n should be integers\n```\n\n----------------------------------------\n\nTITLE: Autogenerating Documentation for sympy.physics.units.dimensions Module\nDESCRIPTION: This Sphinx directive (`automodule`) instructs Sphinx to automatically pull documentation from the specified Python module (`sympy.physics.units.dimensions`). It will typically include the module's docstring and potentially documentation for members defined within it, depending on Sphinx configuration.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/dimensions.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.units.dimensions\n```\n\n----------------------------------------\n\nTITLE: Auto-Generating Dense Matrix Class Documentation with Sphinx (reStructuredText)\nDESCRIPTION: This snippet demonstrates the use of Sphinx autodoc 'autoclass' directives in reStructuredText to generate API documentation for several classes in the sympy.matrices dense matrix hierarchy. It references sympy.matrices.dense.Matrix, DenseMatrix, MutableDenseMatrix, and sympy.matrices.immutable.ImmutableDenseMatrix, exposing their members for each. The :noindex: option prevents the ImmutableDenseMatrix class from being included in the search index. This snippet requires Sphinx and a properly configured autodoc extension, along with the accessible SymPy package in the Python path.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/dense.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: sympy.matrices.dense::Matrix\n   :members:\n\n.. autoclass:: sympy.matrices.dense::DenseMatrix\n   :members:\n.. autoclass:: sympy.matrices.dense::MutableDenseMatrix\n   :members:\n\n.. autoclass:: sympy.matrices.immutable::ImmutableDenseMatrix\n   :members:\n   :noindex:\n```\n\n----------------------------------------\n\nTITLE: New Joint Position Specification with Vectors\nDESCRIPTION: Example showing the new way to specify joint attachment points using parent_point and child_point arguments with vectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.mechanics import PinJoint, RigidBody\nparent, child = RigidBody('parent'), RigidBody('child')\npin = PinJoint('pin', parent, child, parent_point=parent.frame.x,\n               child_point=-child.frame.x)\npin.parent_point.pos_from(parent.masscenter)\npin.child_point.pos_from(child.masscenter)\n```\n\n----------------------------------------\n\nTITLE: Using Code Printers with the FMA Function\nDESCRIPTION: Examples of generating C and C++ code representations of the FMA function using SymPy's code printers, demonstrating the _ccode and _cxxcode methods.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import ccode, cxxcode\n>>> ccode(FMA(x, y, z))\n'fma(x, y, z)'\n>>> cxxcode(FMA(x, y, z))\n'std::fma(x, y, z)'\n```\n\n----------------------------------------\n\nTITLE: Simulating Muscle Dynamics with SciPy's solve_ivp\nDESCRIPTION: Uses SciPy's solve_ivp function to perform numerical integration of the muscle dynamics over a specified time range, starting from the initial state values.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.integrate import solve_ivp\nt0, tf = 0.0, 6.0\ntimes = np.linspace(t0, tf, num=601)\nsol = solve_ivp(eval_rhs,\n                (t0, tf),\n                x_vals, t_eval=times)\n```\n\n----------------------------------------\n\nTITLE: Color Gradients in SymPy Plots\nDESCRIPTION: Demonstrates how to create custom color gradients for plots. The example shows defining gradients with multiple color steps and applying them to a surface.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/plotting.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\np[1].color = (Fx**2 + Fy**2 + Fz**2)**(0.5), (0.1,0.1,0.9), (0.9,0.1,0.1)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fuzzy-Bool Results in SymPy\nDESCRIPTION: This snippet shows how SymPy's assumption queries return fuzzy-bool results (True, False, or None) for different types of symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/booleans.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Symbol, symbols\n>>> xpos = Symbol('xpos', positive=True)\n>>> xneg = Symbol('xneg', negative=True)\n>>> x = Symbol('x')\n>>> print(xpos.is_positive)\nTrue\n>>> print(xneg.is_positive)\nFalse\n>>> print(x.is_positive)\nNone\n```\n\n----------------------------------------\n\nTITLE: Example 1: Beam with Combined Loading Analysis\nDESCRIPTION: Analyzes a beam with distributed load, point moment and reactions. Calculates reaction loads, shear force, bending moment, slope and deflection using SymPy's Beam class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/continuum_mechanics/beam_problems.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.continuum_mechanics.beam import Beam\nfrom sympy import symbols, plot, S\nE, I = symbols('E, I')\nR1, R2 = symbols('R1, R2')\nb = Beam(6, E, I)\nb.apply_load(R1, 0, -1)\nb.apply_load(-S(3)/2, 3, -2)\nb.apply_load(3, 3, 0)\nb.apply_load(1, 3, 1)\nb.apply_load(R2, 6, -1)\nb.bc_deflection.append((0, 0))\nb.bc_deflection.append((6, 0))\nb.solve_for_reaction_loads(R1, R2)\n```\n\n----------------------------------------\n\nTITLE: Testing Numerical Evaluation with evalf() in Custom SymPy Function\nDESCRIPTION: This code snippet demonstrates how to use the evalf() method with the custom versin function after implementing _eval_evalf. It shows the numerical evaluation of versin(1) to a floating-point value.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> versin(1).evalf()\n0.459697694131860\n```\n\n----------------------------------------\n\nTITLE: Differentiating Electric Potential\nDESCRIPTION: Shows how to differentiate an electric potential field with respect to a coordinate variable.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/fields.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.physics.vector import ReferenceFrame\nR = ReferenceFrame('R')\nelectric_potential = 2*R[0]**2*R[1]\nfrom sympy import diff\ndiff(electric_potential, R[0])\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing with Assignment in SymPy\nDESCRIPTION: Example showing how to use the assign_to parameter with fcode for line wrapping with variable assignment. This ensures proper formatting of long expressions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(fcode(expr, assign_to=\"var\"))\n      var = -715.0d0/65536.0d0*x**18 - 429.0d0/32768.0d0*x**16 - 33.0d0/\n     @ 2048.0d0*x**14 - 21.0d0/1024.0d0*x**12 - 7.0d0/256.0d0*x**10 -\n     @ 5.0d0/128.0d0*x**8 - 1.0d0/16.0d0*x**6 - 1.0d0/8.0d0*x**4 - 1.0d0\n     @ /2.0d0*x**2 + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Forces in SymPy Mechanics\nDESCRIPTION: This snippet defines the forces acting on the system, including the Duffing spring, damper, and gravitational forces on both bodies.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/duffing-example.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\npath = me.LinearPathway(O, block_point)\nspring = me.DuffingSpring(k1, k2, path, 0)\ndamper = me.LinearDamper(c1, path)\nloads = spring.to_loads() + damper.to_loads()\nbodies = [block_body, pendulum_body]\nfor body in bodies:\n    loads.append(me.Force(body, body.mass * g * N.y))\n```\n\n----------------------------------------\n\nTITLE: Computing Minimal Uncollected Subword\nDESCRIPTION: Demonstrates computation of minimal uncollected subwords in a polycyclic group using the Collector class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/pc_groups.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.named_groups import SymmetricGroup\nfrom sympy.combinatorics.free_groups import free_group\nG = SymmetricGroup(4)\nPcGroup = G.polycyclic_group()\ncollector = PcGroup.collector\nF, x1, x2 = free_group(\"x1, x2\")\nword = x2**2*x1**7\ncollector.minimal_uncollected_subword(word)\n```\n\n----------------------------------------\n\nTITLE: Defining ReStructuredText Module Documentation\nDESCRIPTION: ReStructuredText markup defining the documentation structure for combinatorics test utilities, including function references for permutation list comparison, centralizer calculation, BSGS verification, and normal closure verification.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/testutil.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _combinatorics-testutil:\n\nTest Utilities\n==============\n\n.. module:: sympy.combinatorics.testutil\n\n.. autofunction:: _cmp_perm_lists\n\n.. autofunction:: _naive_list_centralizer\n\n.. autofunction:: _verify_bsgs\n\n.. autofunction:: _verify_centralizer\n\n.. autofunction:: _verify_normal_closure\n```\n\n----------------------------------------\n\nTITLE: Documenting RGS_rank Function in reStructuredText\nDESCRIPTION: Autofunction directive for the RGS_rank function, which is part of the sympy.combinatorics.partitions module. This function likely converts a restricted growth string to its rank.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/partitions.rst#2025-04-22_snippet_6\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: RGS_rank\n```\n\n----------------------------------------\n\nTITLE: Preventing Expression Evaluation in Python using SymPy\nDESCRIPTION: Demonstrates two methods to prevent automatic evaluation of SymPy expressions: using evaluate=False and UnevaluatedExpr.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Add, sympify, UnevaluatedExpr, S\nfrom sympy.abc import x, y, z\n\nAdd(x, x, evaluate=False)\n# Output: x + x\n\nsympify(\"x + x\", evaluate=False)\n# Output: x + x\n\nexpr = x + UnevaluatedExpr(x)\nexpr\n# Output: x + x\nx + expr\n# Output: 2*x + x\n\nuexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\nuexpr\n# Output: (5/7)*(3/4)\n\nUnevaluatedExpr(sympify(\"x + x\", evaluate=False)) + y\n# Output: y + (x + x)\n```\n\n----------------------------------------\n\nTITLE: Old Mathematica Parser Usage\nDESCRIPTION: Example showing the deprecated way of using the Mathematica parser with additional translations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.parsing.mathematica import mathematica\nmathematica('F[7,5,3]', {'F[*x]': 'Max(*x)*Min(*x)'})   # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Parsing Autolev Code to SymPy in Python\nDESCRIPTION: Demonstrates how to use the parse_autolev function to convert Autolev code to SymPy code. It reads an Autolev file and generates equivalent SymPy mechanics code, with an option to include PyDy simulation code.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/autolev_parser.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.parsing.autolev import parse_autolev\nsympy_code = parse_autolev(open('double_pendulum.al'), include_numeric=True)\nprint(sympy_code)\n```\n\n----------------------------------------\n\nTITLE: Constructing Complex Domains in Python using SymPy\nDESCRIPTION: Demonstrates how construct_domain chooses more complex domains for various types of mathematical expressions, including rationals, polynomials, and multivariate polynomials.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Rational, symbols\n>>> x, y = symbols('x, y')\n>>> construct_domain([Rational(1, 2), Integer(3)])[0]\nQQ\n>>> construct_domain([2*x, 3])[0]\nZZ[x]\n>>> construct_domain([x/2, 3])[0]\nQQ[x]\n>>> construct_domain([2/x, 3])[0]\nZZ(x)\n>>> construct_domain([x, y])[0]\nZZ[x,y]\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Control Tutorials\nDESCRIPTION: ReStructuredText markup defining the structure of control system tutorials documentation, including a table of contents for different problem types.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/control/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _control_tutorial:\\n\\n=============================\\nControl Tutorials\\n=============================\\n\\n.. toctree::\\n   :maxdepth: 1\\n\\n   control_problems.rst\\n   electrical_problems.rst\\n   mechanics_problems.rst\n```\n\n----------------------------------------\n\nTITLE: Differentiating and Computing Time Derivatives of Vectors Composed with DynamicSymbols - SymPy - Python\nDESCRIPTION: Presents how to differentiate and take time-derivatives of vectors composed of dynamic symbols within a reference frame. Emphasizes that outputs preserve the frames of input vector components. Requires sympy.physics.vector, dynamicsymbols, frames N and B, and dynamic variables q1, q2. Inputs are vector expressions with dynamic symbols; outputs are derived or time-differentiated vectors.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/vectors/vectors.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> N = ReferenceFrame('N')\\n>>> B = N.orientnew('B', 'Axis', [q1, N.x])\\n>>> (B.y*q2 + B.z).diff(q2, N)\\nB.y\\n>>> (B.y*q2 + B.z).dt(N)\\n(-q1' + q2')*B.y + q2*q1'*B.z\\n\\n>>> (B.y*q2 + B.z + q2*N.x).diff(q2, N)\\nN.x + B.y\n```\n\n----------------------------------------\n\nTITLE: Initializing Symbols and Creating Basic Expression\nDESCRIPTION: Creates symbolic variables x, y, z and demonstrates how to construct a basic expression x^2 + xy\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/manipulation.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import *\nx, y, z = symbols('x y z')\n\nexpr = x**2 + x*y\nsrepr(expr)\n```\n\n----------------------------------------\n\nTITLE: Converting Force Magnitude to Loads on Attachment Points\nDESCRIPTION: Demonstrates how the pathway converts a force magnitude to forces acting on the attachment points, accounting for direction.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n>>> muscle_pathway.to_loads(m*g)\n[(O, - g*m*q(t)/Abs(q(t))*N.x), (P, g*m*q(t)/Abs(q(t))*N.x)]\n```\n\n----------------------------------------\n\nTITLE: Sphinx Directives for SymPy Joint Class Documentation\nDESCRIPTION: This snippet contains Sphinx reStructuredText directives used to automatically generate documentation for classes within the `sympy.physics.mechanics.joint` module. The `.. module::` directive specifies the target Python module. The `.. autoclass::` directives instruct Sphinx to document the specified classes (`Joint`, `PinJoint`, `PrismaticJoint`, `CylindricalJoint`, `PlanarJoint`, `SphericalJoint`, `WeldJoint`), including their members, by extracting their docstrings.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/joint.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.physics.mechanics.joint\n\n.. autoclass:: Joint\n   :members:\n\n.. autoclass:: PinJoint\n   :members:\n\n.. autoclass:: PrismaticJoint\n   :members:\n\n.. autoclass:: CylindricalJoint\n   :members:\n\n.. autoclass:: PlanarJoint\n   :members:\n\n.. autoclass:: SphericalJoint\n   :members:\n\n.. autoclass:: WeldJoint\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Converting SymPy Expressions to Domain Elements\nDESCRIPTION: This snippet shows how to convert SymPy expressions to elements of the ZZ (integer) domain and perform calculations within that domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nexpressions_dom = [ZZ.from_sympy(e) for e in expressions_sympy]\n\n# Perform calculations in the domain\nresult_dom = ZZ.zero\nfor e_dom in expressions_dom:\n    result_dom += e_dom\n\n# Convert the result back to Expr\nresult_sympy = ZZ.to_sympy(result_dom)\nreturn result_sympy\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Matrices in SymPy\nDESCRIPTION: Shows how to create a matrix with symbolic elements, assign values to specific elements, and perform basic matrix operations in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nMO = sm.Matrix([[a, b], [c, 0]])\nMO[1, 1] = d\nA + B*C\n```\n\n----------------------------------------\n\nTITLE: Calculating Finite Difference Weights in Python using SymPy\nDESCRIPTION: This snippet demonstrates how to manually calculate finite difference weights using SymPy's finite_diff_weights function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> finite_diff_weights(2, [-3, -1, 2], 0)[-1][-1]\n[1/5, -1/3, 2/15]\n```\n\n----------------------------------------\n\nTITLE: Initializing SymPy and Importing Polytope Integration Functions\nDESCRIPTION: This snippet shows how to import the necessary functions from SymPy's integrals.intpoly module and initialize pretty printing.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy.integrals.intpoly import *\ninit_printing(use_unicode=False)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Rolling Disc\nDESCRIPTION: ReStructuredText documentation layout defining the structure of rolling disc examples using different mechanical methods (Kane's method and Lagrange's method).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/physics/mechanics/rollingdisc_example.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==============\nA rolling disc\n==============\n\nThe disc is assumed to be infinitely thin, in contact with the ground at only 1\npoint, and it is rolling without slip on the ground. See the image below.\n\n.. raw:: html\n   :file: rollingdisc.svg\n\nWe model the rolling disc in three different ways, to show more of the\nfunctionality of this module.\n\n.. toctree::\n    :maxdepth: 1\n\n    rollingdisc_example_kane.rst\n    rollingdisc_example_kane_constraints.rst\n    rollingdisc_example_lagrange.rst\n```\n\n----------------------------------------\n\nTITLE: Finite Difference Approximation of Derivatives in Python using SymPy\nDESCRIPTION: This code shows how to use SymPy's as_finite_difference method to generate finite difference approximations of derivatives to arbitrary order.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> f = Function('f')\n>>> dfdx = f(x).diff(x)\n>>> dfdx.as_finite_difference()\n-f(x - 1/2) + f(x + 1/2)\n\n>>> f = Function('f')\n>>> d2fdx2 = f(x).diff(x, 2)\n>>> h = Symbol('h')\n>>> d2fdx2.as_finite_difference([-3*h,-h,2*h])\nf(-3⋅h)   f(-h)   2⋅f(2⋅h)\n─────── - ───── + ────────\n     2        2        2\n  5⋅h      3⋅h     15⋅h\n```\n\n----------------------------------------\n\nTITLE: Computing All Monomials up to Maximum Degree for 2D Polygon\nDESCRIPTION: Demonstrates how to compute integrals for all monomials up to a specified maximum degree over a 2D polygon.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/integrals/integrals.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\npolytope_integrate(Polygon((0, 0), (0, 1), (1, 0)),max_degree=3)\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in reStructuredText for SymPy Documentation\nDESCRIPTION: This snippet creates a table of contents using reStructuredText directives. It defines a 'Topics' section and lists various SymPy modules and topics as subsections, linking to their respective documentation files.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/reference/public/topics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _topics:\n\n======\nTopics\n======\n\n**Contents**\n\n.. toctree::\n   :titlesonly:\n\n   ../../../modules/geometry/index.rst\n   ../../../modules/holonomic/index.rst\n   ../../../modules/liealgebras/index.rst\n   ../../../modules/polys/index.rst\n   ../../../modules/categories.rst\n   ../../../modules/crypto.rst\n   ../../../modules/diffgeom.rst\n   ../../../modules/plotting.rst\n   ../../../modules/stats.rst\n```\n\n----------------------------------------\n\nTITLE: Generated SymPy Mechanics Code for Double Pendulum\nDESCRIPTION: Shows the SymPy mechanics code generated by the Autolev parser for the double pendulum system. It includes imports, symbol definitions, frame setups, point and particle definitions, and equations of motion using Kane's method.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/autolev_parser.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sympy.physics.mechanics as me\nimport sympy as sm\nimport math as m\nimport numpy as np\n\nq1, q2, u1, u2 = me.dynamicsymbols('q1 q2 u1 u2')\nq1d, q2d, u1d, u2d = me.dynamicsymbols('q1 q2 u1 u2', 1)\nl, m, g=sm.symbols('l m g', real=True)\nframe_n=me.ReferenceFrame('n')\nframe_a=me.ReferenceFrame('a')\nframe_b=me.ReferenceFrame('b')\nframe_a.orient(frame_n, 'Axis', [q1, frame_n.z])\nframe_b.orient(frame_n, 'Axis', [q2, frame_n.z])\nframe_a.set_ang_vel(frame_n, u1*frame_n.z)\nframe_b.set_ang_vel(frame_n, u2*frame_n.z)\npoint_o=me.Point('o')\nparticle_p=me.Particle('p', me.Point('p_pt'), sm.Symbol('m'))\nparticle_r=me.Particle('r', me.Point('r_pt'), sm.Symbol('m'))\nparticle_p.point.set_pos(point_o, l*frame_a.x)\nparticle_r.point.set_pos(particle_p.point, l*frame_b.x)\npoint_o.set_vel(frame_n, 0)\nparticle_p.point.v2pt_theory(point_o,frame_n,frame_a)\nparticle_r.point.v2pt_theory(particle_p.point,frame_n,frame_b)\nparticle_p.mass = m\nparticle_r.mass = m\nforce_p = particle_p.mass*(g*frame_n.x)\nforce_r = particle_r.mass*(g*frame_n.x)\nkd_eqs = [q1d - u1, q2d - u2]\nforceList = [(particle_p.point,particle_p.mass*(g*frame_n.x)), (particle_r.point,particle_r.mass*(g*frame_n.x))]\nkane = me.KanesMethod(frame_n, q_ind=[q1,q2], u_ind=[u1, u2], kd_eqs = kd_eqs)\nfr, frstar = kane.kanes_equations([particle_p, particle_r], forceList)\nzero = fr+frstar\n\n#---------PyDy code for integration----------\nfrom pydy.system import System\nsys = System(kane, constants = {l:1, m:1, g:9.81},\nspecifieds={},\ninitial_conditions={q1:.1, q2:.2, u1:0, u2:0},\ntimes = np.linspace(0.0, 10, 10/.01))\n\ny=sys.integrate()\n```\n\n----------------------------------------\n\nTITLE: Declaring Module for Sphinx Documentation (reStructuredText)\nDESCRIPTION: This Sphinx directive specifies the Python module (`sympy.matrices.kind`) that the following documentation elements belong to. It sets the context for subsequent directives like `autoclass`.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/matrices/kind.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: sympy.matrices.kind\n```\n\n----------------------------------------\n\nTITLE: Verifying SymPy installation\nDESCRIPTION: This Python code snippet demonstrates how to import SymPy and perform basic operations to verify the installation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import *\n>>> x = Symbol('x')\n>>> limit(sin(x)/x, x, 0)\n1\n>>> integrate(1/x, x)\nlog(x)\n```\n\n----------------------------------------\n\nTITLE: Dense Multivariate Polynomial (DMP) Representation in SymPy\nDESCRIPTION: This snippet shows how multivariate polynomials are represented using the dense multivariate polynomial (DMP) format, which uses nested lists for coefficients of different variables.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols\n>>> x, y = symbols('x, y')\n>>> p = Poly(x**2*y + x**2 + x*y + y + 1)\n>>> p\nPoly(x**2*y + x**2 + x*y + y + 1, x, y, domain='ZZ')\n>>> p.rep.rep  # doctest: +SKIP\n[[1, 1], [1, 0], [1, 1]]\n```\n\n----------------------------------------\n\nTITLE: Importing PDE Solver Functions in Python\nDESCRIPTION: This snippet demonstrates how to import PDE solver functions into the global namespace in Python using SymPy. It shows the recommended import statement for user-level functions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/pde.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import *\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Hypergeometric Functions in SymPy\nDESCRIPTION: Shows various common mathematical functions being tested for hypergeometric properties using is_hypergeometric().\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/concrete.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfactorial(n).is_hypergeometric(n)\nbinomial(n, k).is_hypergeometric(n)\nrf(n, k).is_hypergeometric(n)\nff(n, k).is_hypergeometric(n)\ngamma(n).is_hypergeometric(n)\n(2**n).is_hypergeometric(n)\n```\n\n----------------------------------------\n\nTITLE: Implementing _eval_rewrite Method for Custom SymPy Functions\nDESCRIPTION: This code snippet demonstrates how to implement the _eval_rewrite method in a custom SymPy function to enable rewriting expressions in terms of other functions. The example shows rewriting versin(x) as 1-cos(x).\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> class versin(Function):\n...     def _eval_rewrite(self, rule, args, **hints):\n...         if rule == cos:\n...             return 1 - cos(*args)\n>>> versin(x).rewrite(cos)\n1 - cos(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Muscle and Physical Parameters\nDESCRIPTION: Sets up an array of physical parameters for the muscle model including mass, gravity, maximum force, optimal length, and other muscle-specific constants needed for the simulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\np_vals = np.array([\n    0.5,  # m [kg]\n    9.81,  # g [m/s/s]\n    10.0,  # F_M_max [N]\n    0.18,  # l_M_opt [m]\n    0.17,  # l_T_slack [m]\n    10.0,  # v_M_max [m/s]\n    0.0,  # alpha_opt\n    0.1,  # beta\n])\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Spring-Damper Actuator in SymPy Mechanics\nDESCRIPTION: Demonstrates how to create a custom actuator by subclassing the ActuatorBase class. This example begins implementing a SpringDamper class that will generate the appropriate forces when to_loads is called.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> N = me.ReferenceFrame('N')\n>>> O, P = me.Point('O'), me.Point('P')\n>>> P.set_pos(O, x*N.x)\n\n>>> class SpringDamper(me.ActuatorBase):\n...\n...     # positive x spring is in tension\n...     # negative x spring is in compression\n...     def __init__(self, P1, P2, spring_constant, damper_constant):\n...         self.P1 = P1\n...         self.P2 = P2\n...         self.k = spring_constant\n...         self.c = damper_constant\n...\n...     def to_loads(self):\n...         x = self.P2.pos_from(self.P1).magnitude()\n...         v = x.diff(me.dynamicsymbols._t)\n```\n\n----------------------------------------\n\nTITLE: Using solveset for Complex and Real Domains in Python with SymPy\nDESCRIPTION: Demonstrates how to use solveset to solve equations in both complex and real domains, showing the difference in output based on the specified domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/solvers/solveset.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import solveset, S\nfrom sympy.abc import x\nsolveset(x**2 + 1, x) # domain=S.Complexes is default\nsolveset(x**2 + 1, x, domain=S.Reals)\n```\n\n----------------------------------------\n\nTITLE: Frame Rotations and Gravity in SymPy\nDESCRIPTION: Shows how to define simple rotations between frames and apply gravity forces in SymPy dynamics problems.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nB.orient(A, 'Axis', qA, A.x)\n```\n\nLANGUAGE: python\nCODE:\n```\nfL.extend(gravity(g*N.x, P1, P2, ...))\n```\n\n----------------------------------------\n\nTITLE: Basic Diophantine Equation Solving with SymPy\nDESCRIPTION: Demonstrates solving the Pythagorean equation (a^2 + b^2 = c^2) using SymPy's diophantine solver. Shows how to set up symbols and solve for parameterized solutions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-diophantine-equation.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.solvers.diophantine import diophantine\n>>> from sympy import symbols, Eq\n>>> a, b, c = symbols(\"a, b, c\", integer=True)\n>>> my_syms = (a, b, c)\n>>> pythag_eq = Eq(a**2 + b**2, c**2)\n>>> # Solve Diophantine equation\n>>> d = diophantine(pythag_eq, syms=my_syms)\n>>> d\n{(2*p*q, p**2 - q**2, p**2 + q**2)}\n```\n\n----------------------------------------\n\nTITLE: Creating Equal and Opposite Forces in SymPy Mechanics\nDESCRIPTION: Shows how to create an equal and opposite force acting on point O to balance the force on point P in a spring-damper system, following Newton's third law.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> force_on_O = me.Force(O, k*P.pos_from(O) + c*P.vel(N))\n>>> force_on_O\n(O, (c*Derivative(x(t), t) + k*x(t))*N.x)\n```\n\n----------------------------------------\n\nTITLE: Using dict=True for Consistent Output Format from solve in SymPy\nDESCRIPTION: This example demonstrates using the dict=True parameter with solve() to get a consistent output format, making it easier to extract solutions programmatically.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solving-guidance.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import parse_expr, solve, solveset\n>>> from sympy.abc import x\n>>> expr = \"x^2 = y\"\n>>> parsed = parse_expr(expr, transformations=\"all\")\n>>> parsed\nEq(x**2, y)\n>>> solutions = solve(parsed, x, dict=True)\n>>> [solution[x] for solution in solutions]\n[-sqrt(y), sqrt(y)]\n>>> solveset(parsed, x)\n{-sqrt(y), sqrt(y)}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Conditions for Derivatives in SymPy\nDESCRIPTION: Shows how to solve an ODE with an initial condition on the derivative of the function (f'(1) = 2) using the ics parameter.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> eqn = Eq(f(x).diff(x), f(x))\n>>> dsolve(eqn, f(x), ics={f(x).diff(x).subs(x, 1): 2})\nEq(f(x), 2*exp(-1)*exp(x))\n```\n\n----------------------------------------\n\nTITLE: Extracting Multiple Function Solutions from a System of ODEs\nDESCRIPTION: Shows how to extract solutions for multiple functions from the results of dsolve when solving a system of ODEs, using both loop and list comprehension approaches.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-ode.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, Eq, Function, dsolve\n>>> y, z = symbols(\"y z\", cls=Function)\n>>> x = symbols(\"x\")\n>>> eqs_one_soln_set = [Eq(y(x).diff(x), z(x)**2), Eq(z(x).diff(x), z(x))]\n>>> solutions_one_soln_set = dsolve(eqs_one_soln_set, [y(x), z(x)])\n>>> solutions_one_soln_set\n[Eq(y(x), C1 + C2**2*exp(2*x)/2), Eq(z(x), C2*exp(x))]\n>>> # Loop through list approach\n>>> solution_one_soln_set_dict = {}\n>>> for fn in solutions_one_soln_set:\n...         solution_one_soln_set_dict.update({fn.lhs: fn.rhs})\n>>> solution_one_soln_set_dict\n{y(x): C1 + C2**2*exp(2*x)/2, z(x): C2*exp(x)}\n>>> # List comprehension approach\n>>> solution_one_soln_set_dict = {fn.lhs:fn.rhs for fn in solutions_one_soln_set}\n>>> solution_one_soln_set_dict\n{y(x): C1 + C2**2*exp(2*x)/2, z(x): C2*exp(x)}\n>>> # Extract expression for y(x)\n>>> solution_one_soln_set_dict[y(x)]\nC1 + C2**2*exp(2*x)/2\n```\n\n----------------------------------------\n\nTITLE: Writing Trigonometric Function Tests in SymPy\nDESCRIPTION: Example of a test function for the cosine series expansion in SymPy, demonstrating the pattern for writing mathematical tests with assertions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# from sympy/functions/elementary/tests/test_trigonometric.py\n\ndef test_cos_series():\n    assert cos(x).series(x, 0, 9) == \\\n        1 - x**2/2 + x**4/24 - x**6/720 + x**8/40320 + O(x**9)\n```\n\n----------------------------------------\n\nTITLE: Installing SymPy on Debian-based Linux systems\nDESCRIPTION: This command installs SymPy using the apt package manager on Debian-based Linux distributions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/install.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\napt install python-sympy\n```\n\n----------------------------------------\n\nTITLE: Caution when Overriding SymPy Built-ins\nDESCRIPTION: Shows the dangers of overriding built-in SymPy functions and constants, which can lead to unexpected behavior. Python doesn't prevent such overrides, making careful naming important.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncos(pi)  # cos and pi are a built-in sympy names.\n-1\npi = 3   # Notice that there is no warning for overriding pi.\ncos(pi)\ncos(3)\ndef cos(x):  # No warning for overriding built-in functions either.\n    return 5*x\n\ncos(pi)\n15\nfrom sympy import cos  # reimport to restore normal behavior\n```\n\n----------------------------------------\n\nTITLE: Fortran Code Printing with Machine-Processable Output\nDESCRIPTION: Examples showing how to use fcode with human=False to generate machine-processable output for post-processing. Returns a tuple containing parameter definitions, unsupported functions, and code.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n>>> fcode(1 - gamma(x)**2, human=False)\n(set(), {gamma(x)}, '      1 - gamma(x)**2')\n>>> fcode(1 - sin(x)**2, human=False)\n(set(), set(), '      1 - sin(x)**2')\n>>> fcode(x - pi**2, human=False)\n({(pi, '3.1415926535897932d0')}, set(), '      x - pi**2')\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for SymPy Gray Code Module\nDESCRIPTION: RST directives for documenting the GrayCode class and related utility functions in the sympy.combinatorics.graycode module. Includes class documentation and method references for binary conversions and subset operations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/graycode.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _combinatorics-graycode:\n\nGray Code\n=========\n\n.. module:: sympy.combinatorics.graycode\n\n.. autoclass:: GrayCode\n   :members:\n\n.. automethod:: sympy.combinatorics.graycode.random_bitstring\n\n.. automethod:: sympy.combinatorics.graycode.gray_to_bin\n\n.. automethod:: sympy.combinatorics.graycode.bin_to_gray\n\n.. automethod:: sympy.combinatorics.graycode.get_subset_from_bitstring\n\n.. automethod:: sympy.combinatorics.graycode.graycode_subsets\n```\n\n----------------------------------------\n\nTITLE: Factoring Polynomials Over Finite Fields in SymPy\nDESCRIPTION: Demonstrates how to factor a univariate polynomial over a finite field F_65537 using both symmetric and non-symmetric representations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nf = x**11 + x + 1\n```\n\nLANGUAGE: python\nCODE:\n```\nfactor(f, modulus=65537)\n```\n\nLANGUAGE: python\nCODE:\n```\nexpand(_)\n```\n\nLANGUAGE: python\nCODE:\n```\nfactor(f, modulus=65537, symmetric=False)\n```\n\nLANGUAGE: python\nCODE:\n```\ntrunc(expand(_), 65537)\n```\n\n----------------------------------------\n\nTITLE: Computing Limits with SymPy\nDESCRIPTION: Shows how to compute limits using limit() function, including one-sided limits and handling of infinity.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/calculus.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nlimit(sin(x)/x, x, 0)\nexpr = x**2/exp(x)\nlimit(expr, x, oo)\nlimit(1/x, x, 0, '+')\nlimit(1/x, x, 0, '-')\n```\n\n----------------------------------------\n\nTITLE: Hypergeometric Function Definition in Mathematical Notation\nDESCRIPTION: The mathematical definition of the hypergeometric function as an infinite series. This is the foundational formula for the hypergeometric function showing how it depends on its parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/hyperexpand.rst#2025-04-22_snippet_0\n\nLANGUAGE: mathematical notation\nCODE:\n```\n{}_pF_q\\left(\\begin{matrix} a_1, \\cdots, a_p \\\\ b_1, \\cdots, b_q \\end{matrix} \\middle| z \\right) = \\sum_{n=0}^\\infty \\frac{(a_1)_n \\cdots (a_p)_n}{(b_1)_n \\cdots (b_q)_n} \\frac{z^n}{n!}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for sympy.physics.quantum.grover\nDESCRIPTION: This reStructuredText directive utilizes Sphinx's `automodule` feature to automatically generate documentation from the specified Python module (`sympy.physics.quantum.grover`). The `:members:` option instructs Sphinx to include documentation for all public members (functions, classes, attributes, etc.) defined within that module in the final output.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/quantum/grover.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.quantum.grover\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Initializing Cartesian Coordinate System in SymPy\nDESCRIPTION: Creates a 3D Cartesian coordinate system using the CoordSys3D class from sympy.vector. The system is named 'N' and can be used to access unit vectors and coordinate variables.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/vector/basics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.vector import CoordSys3D\nN = CoordSys3D('N')\n```\n\n----------------------------------------\n\nTITLE: Finding Complex Roots of Real Functions with SymPy in Python\nDESCRIPTION: Shows how to use nsolve to find complex roots of real functions by specifying a non-real initial point. It demonstrates cases with purely imaginary and complex initial points.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-numerically.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import nsolve\n>>> from sympy.abc import x\n>>> nsolve(x**2 + 2, 1) # Real initial point returns no root\nTraceback (most recent call last):\n    ...\nValueError: Could not find root within given tolerance. (4.18466446988997098217 > 2.16840434497100886801e-19)\nTry another starting point or tweak arguments.\n>>> from sympy import I\n>>> nsolve(x**2 + 2, I) # Imaginary initial point returns a complex root\n1.4142135623731*I\n>>> nsolve(x**2 + 2, 1 + I) # Complex initial point returns a complex root\n1.4142135623731*I\n```\n\n----------------------------------------\n\nTITLE: Equality Testing in SymPy\nDESCRIPTION: Demonstrates different methods for testing equality between symbolic expressions, including exact structural equality and mathematical equality.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/gotchas.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nEq(x + 1, 4)\na = (x + 1)**2\nb = x**2 + 2*x + 1\nsimplify(a - b)\n```\n\n----------------------------------------\n\nTITLE: Defining First-Order Activation ODE Manually in SymPy\nDESCRIPTION: Defines standard SymPy symbols (`sm.symbols`) for the activation time constant `tau_a`, deactivation time constant `tau_d`, and smoothing coefficient `b`. It also uses dynamic symbols (`me.dynamicsymbols`) for activation `a` and excitation `e`. It then constructs the symbolic expression `dadt` representing the right-hand side of the first-order ordinary differential equation for activation dynamics based on the DeGroote 2016 model.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> tau_a, tau_d, b = sm.symbols('tau_a, tau_d, b')\n>>> f = sm.tanh(b*(e - a))/2\n>>> dadt = ((1/(tau_a*(1 + 3*a)))*(1 + 2*f) + ((1 + 3*a)/(4*tau_d))*(1 - 2*f))*(e - a)\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic Equality with SymPy Eq in Python\nDESCRIPTION: This snippet shows how to represent a symbolic mathematical equality (like x=0) in SymPy using the `Eq` class. It takes two arguments, the left-hand side and the right-hand side of the equation. This is necessary because the standard `==` operator checks for structural equality, not symbolic equality. It requires the SymPy library and assumes `x` is a defined SymPy symbol.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/glossary.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nEq(x, 0)\n```\n\n----------------------------------------\n\nTITLE: Testing Nonlinear Arguments in SymPy\nDESCRIPTION: Demonstrates that functions with nonlinear arguments are not hypergeometric.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/concrete.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfactorial(n**2).is_hypergeometric(n)\n(2**(n**3 + 1)).is_hypergeometric(n)\n```\n\n----------------------------------------\n\nTITLE: Documentation Configuration for Index Methods Module\nDESCRIPTION: RST directive that automatically generates documentation for all members of the sympy.tensor.index_methods module.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/tensor/index_methods.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.tensor.index_methods\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Deriving Dimensions from Base Dimensions\nDESCRIPTION: Mathematical representation of derived dimensions (Velocity and Action) in terms of base dimensions (Length, Mass, Time) in the MKS system.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/philosophy.rst#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\nV = L T^{-1},  \\qquad\nA = M L^2 T^{-2},\\\\\nV =\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ -1\n\\end{pmatrix}, \\qquad\nA =\n\\begin{pmatrix}\n2 \\\\ 1 \\\\ -2\n\\end{pmatrix}.\n```\n\n----------------------------------------\n\nTITLE: Deprecated Matrix Usage\nDESCRIPTION: Shows deprecated usage of non-Expr objects in Matrix class and its limitations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> M = Matrix([[(1, 2), {}]]) # doctest: +SKIP\n>>> M + M # doctest: +SKIP\nTraceback (most recent call last)...\nTypeError: unsupported operand type(s) for +: 'Dict' and 'Dict'\n```\n\n----------------------------------------\n\nTITLE: Low Index Subgroups Computation in Python\nDESCRIPTION: Demonstrates finding all subgroups up to index 4 in a finitely presented group using low_index_subgroups function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/combinatorics/fp_groups.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy.combinatorics.fp_groups import low_index_subgroups\nF, a, b = free_group(\"a, b\")\nG = FpGroup(F, [a**2, b**3, (a*b)**4])\nl = low_index_subgroups(G, 4)\nfor coset_table in l:\n    print(coset_table.table)\n```\n\n----------------------------------------\n\nTITLE: Line Breaking Long Output in Doctests (Python)\nDESCRIPTION: Illustrates how to handle long output lines in doctests for better readability in source code and HTML documentation. The doctester ignores whitespace differences, including newlines, allowing output to be split across lines.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/writing-tests.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> ((x + 1)**10).expand()\nx**10 + 10*x**9 + 45*x**8 + 120*x**7 + 210*x**6 + 252*x**5 + 210*x**4 +\n120*x**3 + 45*x**2 + 10*x + 1\n```\n\n----------------------------------------\n\nTITLE: Distinguishing Matrix and Scalar Zero in Python\nDESCRIPTION: This example shows the difference between the 'zero' predicate for scalars and the 'is_zero_matrix' property for matrices in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/assumptions.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Matrix\nM = Matrix([[0, 0], [0, 0]])\nM.is_zero\nM.is_zero_matrix\n```\n\n----------------------------------------\n\nTITLE: Handling Circular Dependencies in SymPy\nDESCRIPTION: Shows what happens when circular function dependencies are created in SymPy, resulting in maximum recursion depth errors when functions attempt to call each other infinitely.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/gotchas.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef a():\n    return b()\n\ndef b():\n    return a()\n\na() #doctest: +SKIP\nTraceback (most recent call last):\n  File \"...\", line ..., in ...\n    compileflags, 1) in test.globs\n  File \"<...>\", line 1, in <module>\n    a()\n  File \"<...>\", line 2, in a\n    return b()\n  File \"<...>\", line 2, in b\n    return a()\n  File \"<...>\", line 2, in a\n    return b()\n...\nRuntimeError: maximum recursion depth exceeded\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for System Class in SymPy (reStructuredText)\nDESCRIPTION: This reStructuredText snippet employs the Sphinx `autoclass` directive to generate documentation for the `System` class from the `sympy.physics.mechanics.system` module. By specifying the `:members:` option, it directs Sphinx to include documentation for all public members associated with this class. This requires a working Sphinx setup and the SymPy library.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/mechanics/api/system.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: sympy.physics.mechanics.system.System\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Accessing Expression Nodes Example\nDESCRIPTION: Demonstrates how to access expression nodes in derivative objects without using expr_free_symbols.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Derivative, symbols, Function\n>>> x = symbols('x')\n>>> f = Function('f')\n>>> Derivative(f(x), x).expr\nf(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Equation Matrices for Different Forms of Equations of Motion\nDESCRIPTION: Creates matrices representing the equations of motion in three different forms: implicit dynamic equations, implicit combined equations, and explicit kinematic equations.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/symsystem.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndyn_implicit_mat = Matrix([[1, 0, -x/m],\n                       [0, 1, -y/m],\n                       [0, 0, l**2/m]])\ndyn_implicit_rhs = Matrix([0, 0, u**2 + v**2 - g*y])\ncomb_implicit_mat = Matrix([[1, 0, 0, 0, 0],\n                        [0, 1, 0, 0, 0],\n                        [0, 0, 1, 0, -x/m],\n                        [0, 0, 0, 1, -y/m],\n                        [0, 0, 0, 0, l**2/m]])\ncomb_implicit_rhs = Matrix([u, v, 0, 0, u**2 + v**2 - g*y])\nkin_explicit_rhs = Matrix([u, v])\ncomb_explicit_rhs = comb_implicit_mat.LUsolve(comb_implicit_rhs)\n```\n\n----------------------------------------\n\nTITLE: Frame Orientations and Transformations in SymPy\nDESCRIPTION: Demonstrates how to define orientations between reference frames and perform transformations in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/mechanics/sympy_mechanics_for_autolev_users.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nB.orient(A, 'DCM', M)\n```\n\nLANGUAGE: python\nCODE:\n```\nD = A.dcm(B)*2 + 1\n```\n\n----------------------------------------\n\nTITLE: MonogenicFiniteExtension Class Reference (Python)\nDESCRIPTION: Class representing monogenic finite extensions of rings in the AGCA module. These are extensions generated by a single element satisfying a monic polynomial relation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/agca.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n.. currentmodule:: sympy.polys.agca.extensions\n\n.. autoclass:: MonogenicFiniteExtension\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Variations in Python using SymPy\nDESCRIPTION: Examples of using the variations() function to generate sequence variations with and without repetition. The function takes a sequence and size parameter, with an optional boolean parameter for allowing repetitions.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/utilities/iterables.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy.utilities.iterables import variations\n>>> list(variations([1,2,3], 2))\n[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]\n>>> list(variations([1,2,3], 2, True))\n[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]\n```\n\n----------------------------------------\n\nTITLE: Plotting Fiber Force-Length Active Curve in Python\nDESCRIPTION: This code snippet demonstrates how to plot the fiber force-length active curve using matplotlib and SymPy's FiberForceLengthActiveDeGroote2016 class. It creates a plot of normalized fiber length vs. normalized fiber active force-length.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/biomechanics/biomechanics.rst#2025-04-22_snippet_30\n\nLANGUAGE: Python\nCODE:\n```\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import FiberForceLengthActiveDeGroote2016\n\n>>> l_M_tilde = me.dynamicsymbols('l_M_tilde')\n>>> fl_M_act = FiberForceLengthActiveDeGroote2016.with_defaults(l_M_tilde)\n>>> fl_M_act_callable = sm.lambdify(l_M_tilde, fl_M_act)\n>>> l_M_tilde_num = np.linspace(0.0, 2.0)\n\n>>> fig, ax = plt.subplots()\n>>> _ = ax.plot(l_M_tilde_num, fl_M_act_callable(l_M_tilde_num))\n>>> _ = ax.set_xlabel('Normalized fiber length')\n>>> _ = ax.set_ylabel('Normalized fiber active force-length')\n```\n\n----------------------------------------\n\nTITLE: Committing Changes to .mailmap File\nDESCRIPTION: Git commands to stage and commit the changes made to the .mailmap file.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/contributing/new-contributors-guide/workflow-process.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ngit add .mailmap\ngit commit -m 'author: add Joe Bloggs to .mailmap'\n```\n\n----------------------------------------\n\nTITLE: Documenting CoordinateSym Class in SymPy Physics Vector Module\nDESCRIPTION: Autodoc directive for the CoordinateSym class from sympy.physics.vector.frame module. It includes all members of the class.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/vector/api/classes.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: sympy.physics.vector.frame.CoordinateSym\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Using C++ Code Printer in SymPy\nDESCRIPTION: Example showing how to use cxxcode function to convert SymPy expressions to C++ code. This demonstrates handling special functions like Min and gamma using C++11 standard.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/printing.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> from sympy.printing import cxxcode\n>>> from sympy.functions import Min, gamma\n>>> from sympy.abc import x\n>>> print(cxxcode(Min(gamma(x) - 1, x), standard='C++11'))\nstd::min(x, std::tgamma(x) - 1)\n```\n\n----------------------------------------\n\nTITLE: Calculating Second Derivative of Hypergeometric Function in SymPy\nDESCRIPTION: This code snippet computes the second derivative of a hypergeometric function expression using SymPy. It builds upon the previous calculation and demonstrates the use of multiple SymPy functions for symbolic manipulation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/hyperexpand.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom sympy import (Symbol, cosh, sqrt, pi, exp, I, fresnelc, root,\n                   diff, expand)\nz = Symbol(\"z\")\nB1prime = cosh(2*sqrt(z))/4 - sqrt(pi)*exp(-I*pi/4)*\\\n          fresnelc(2*root(z,4)*exp(I*pi/4)/sqrt(pi))/(8*root(z,4))\nz * diff(B1prime, z)\nexpand(_)\n```\n\n----------------------------------------\n\nTITLE: Polynomial Division with Symbolic Coefficients in SymPy\nDESCRIPTION: Shows how to perform polynomial division with symbolic coefficients using the div function in SymPy.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/basics.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> a, b, c = symbols('a,b,c')\n>>> f = a*x**2 + b*x + c\n>>> g = 3*x + 2\n>>> q, r = div(f, g, domain='QQ')\n>>> q\na*x   2*a   b\n--- - --- + -\n 3     9    3\n\n>>> r\n4*a   2*b\n--- - --- + c\n 9     3\n```\n\n----------------------------------------\n\nTITLE: Autogenerating Documentation for the Dimension Class\nDESCRIPTION: This Sphinx directive (`autoclass`) instructs Sphinx to automatically generate documentation for the `Dimension` class located within the module context (likely `sympy.physics.units.dimensions` established by a preceding `automodule`). The `:members:` option ensures that documentation for the public members (methods, attributes) of the class is also included.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/units/dimensions.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: Dimension\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for Gaussian Optics Module\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `automodule` directive to automatically generate documentation for the Python module `sympy.physics.optics.gaussopt`. The `:members:` option ensures that all public members (functions, classes, etc.) within that module are included in the documentation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/physics/optics/gaussopt.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: sympy.physics.optics.gaussopt\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Inverse Function for Aversin in Python\nDESCRIPTION: Implements the inverse method for the aversin (inverse versine) function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/custom-functions.md#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nclass aversin(Function):\n    def inverse(self, argindex=1):\n        return versin\n```\n\n----------------------------------------\n\nTITLE: Verifying Matrix Solutions with Simplification\nDESCRIPTION: Shows how to verify the correctness of a matrix equation solution by multiplying the coefficient matrix by the solution vector and comparing to the original constant vector using simplification.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/guides/solving/solve-matrix-equation.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import symbols, simplify\n>>> from sympy.matrices import Matrix\n>>> c, d, e = symbols(\"c, d, e\")\n>>> A = Matrix([[c,d], [1, -e]])\n>>> b = Matrix([2, 0])\n>>> solution = A.solve(b)\n>>> solution\n    ⎡  2⋅e  ⎤\n    ⎢───────⎥\n    ⎢c⋅e + d⎥\n    ⎢       ⎥\n    ⎢   2   ⎥\n    ⎢───────⎥\n    ⎣c⋅e + d⎦\n>>> # Not immediately obvious whether this result is a zeroes vector\n>>> (A * solution) - b\n    ⎡ 2⋅c⋅e      2⋅d      ⎤\n    ⎢─────── + ─────── - 2⎥\n    ⎢c⋅e + d   c⋅e + d    ⎥\n    ⎢                     ⎥\n    ⎣          0          ⎦\n>>> # simplify reveals that this result is a zeroes vector\n>>> simplify((A * solution) - b)\n    ⎡0⎤\n    ⎢ ⎥\n    ⎣0⎦\n```\n\n----------------------------------------\n\nTITLE: Calculating Angular Velocities in Multiple Reference Frames\nDESCRIPTION: This example shows how to define and calculate angular velocities for multiple interconnected reference frames using SymPy. It demonstrates the chaining of angular velocities through multiple frames.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/modules/physics/vector/kinematics/kinematics.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nN = ReferenceFrame('N')\nA = ReferenceFrame('A')\nB = ReferenceFrame('B')\nC = ReferenceFrame('C')\nD = ReferenceFrame('D')\nu1, u2, u3 = dynamicsymbols('u1 u2 u3')\nA.set_ang_vel(N, 0)\nB.set_ang_vel(A, u1 * A.x)\nC.set_ang_vel(B, -u2 * B.z)\nD.set_ang_vel(C, u3 * C.y)\nD.ang_vel_in(N)\n```\n\n----------------------------------------\n\nTITLE: Examining Poly Internals in Python using SymPy\nDESCRIPTION: Demonstrates the internal representation of a Poly object, showing how it uses DMP (Dense Multivariate Polynomial) to represent polynomials as lists of coefficients with an associated domain.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/domainsintro.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> from sympy import Poly, symbols, ZZ\n>>> x, y, z, t = symbols('x, y, z, t')\n>>> p = Poly(x**2 + 1, x, domain=ZZ)\n>>> p\nPoly(x**2 + 1, x, domain='ZZ')\n>>> p.gens\n(x,)\n>>> p.domain\nZZ\n>>> p.all_coeffs()\n[1, 0, 1]\n>>> p.as_expr()\nx**2 + 1\n>>> d = p.rep  # internal representation of Poly\n>>> d  # doctest: +SKIP\nDMP_Python([1, 0, 1], ZZ)\n>>> d.rep      # internal representation of DMP  # doctest: +SKIP\n[1, 0, 1]\n>>> type(d.rep)  # doctest: +SKIP\n<class 'list'>\n>>> type(d.rep[0])  # doctest: +SKIP\n<class 'int'>\n>>> d.dom\nZZ\n```\n\n----------------------------------------\n\nTITLE: Evaluating Polynomial at Multiple Points in Python\nDESCRIPTION: The gf_multi_eval function evaluates a univariate polynomial over a finite field at multiple points. It takes the polynomial, list of evaluation points, and field characteristic as parameters.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/internals.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ngf_multi_eval(f, x, p)\n```\n\n----------------------------------------\n\nTITLE: Creating ConditionSet with boolean condition (Python)\nDESCRIPTION: Shows how to create a ConditionSet using a boolean condition instead of the deprecated set condition, using And() and Eq() to construct the boolean expression.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/explanation/active-deprecations.md#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nConditionSet((x, y), Eq(x + 1, 0) & Eq(x + y, 0), S.Reals)\n```\n\n----------------------------------------\n\nTITLE: String to SymPy Expression Conversion\nDESCRIPTION: Converting string representations of mathematical expressions to SymPy expressions using sympify function.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/tutorials/intro-tutorial/basic_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstr_expr = \"x**2 + 3*x - 1/2\"\nexpr = sympify(str_expr)\nexpr.subs(x, 2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fu Function's Optimal Simplification\nDESCRIPTION: Example showing how fu can sometimes find the optimal simplification path for complex trigonometric expressions, reducing the number of terms significantly.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> expr = (sin(x)**2*cos(y)*cos(z) + sin(x)*sin(y)*cos(x)*cos(z) +\n... sin(x)*sin(z)*cos(x)*cos(y) + sin(y)*sin(z)*cos(x)**2 + sin(y)*sin(z) +\n... cos(y)*cos(z))\n>>> args = expr.args\n\n>>> fu(expr)\n3*cos(y - z)/2 - cos(2*x + y + z)/2\n```\n\n----------------------------------------\n\nTITLE: Measuring Performance of Trigonometric Transformations\nDESCRIPTION: Example showing how to measure performance when transforming complex trigonometric expressions, demonstrating the trade-offs between factoring and direct transformation.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/simplify/fu.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> expr=((15*sin(2*x) + 19*sin(x + y) + 17*sin(x + z) + 19*cos(x - z) +\n... 25)*(20*sin(2*x) + 15*sin(x + y) + sin(y + z) + 14*cos(x - z) +\n... 14*cos(y - z))*(9*sin(2*y) + 12*sin(y + z) + 10*cos(x - y) + 2*cos(y -\n... z) + 18)).expand(trig=True).expand()\n\n>>> L(expr)\n932\n\n>>> def clock(f, n=2):\n...    t=time(); f(); return round(time()-t, n)\n...\n>>> clock(lambda: factor(expr))  # doctest: +SKIP\n0.86\n>>> clock(lambda: TR10i(expr), 3)  # doctest: +SKIP\n0.016\n\n>>> clock(lambda: TR10i(expr), 2)  # doctest: +SKIP\n0.28\n```\n\n----------------------------------------\n\nTITLE: Partial Fraction Decomposition in SymPy\nDESCRIPTION: Demonstrates how to decompose a rational function into partial fractions using the apart function, and how to convert back using together and cancel.\nSOURCE: https://github.com/sympy/sympy/blob/master/doc/src/modules/polys/wester.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nf = (x**2 + 2*x + 3)/(x**3 + 4*x**2 + 5*x + 2)\n```\n\nLANGUAGE: python\nCODE:\n```\napart(f)\n```\n\nLANGUAGE: python\nCODE:\n```\ncancel(together(_))\n```"
  }
]