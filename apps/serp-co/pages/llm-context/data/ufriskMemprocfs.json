[
  {
    "owner": "ufrisk",
    "repo": "memprocfs",
    "content": "TITLE: Mounting Memory Dumps via MemProcFS Command-Line - Shell\nDESCRIPTION: These shell commands illustrate various ways of mounting a memory dump as a virtual file system with MemProcFS. The examples assume the presence of memprocfs.exe (Windows) or ./memprocfs (Linux) and valid memory dump files. Key options include setting the device path, the mount point or letter, verbosity ('-v'), enabling forensics mode, performing Yara scans, and specifying pagefiles. Some commands mount live memory sources such as WinPMEM or FPGA. Inputs: CLI arguments including file paths and options. Outputs: a mounted file system exposing analyzed memory contents. Platform-dependent; some features require compatible drivers, e.g., WinPMEM or FPGA devices.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device c:\\temp\\win10x64-dump.raw\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device c:\\temp\\win10x64-dump.raw -v\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device c:\\temp\\win10x64-dump.raw -forensic 1\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device c:\\temp\\win10x64-dump.raw -forensic 1 -forensic-yara-rules c:\\yara\\rules\\windows_malware_index.yar\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./memprocfs -mount /home/pi/linux -device /dumps/win10x64-dump.raw\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -mount s -device c:\\temp\\win10x64-dump.raw\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device pmem\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device fpga -memmap auto\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmemprocfs.exe -device unknown-x64-dump.raw -pagefile0 pagefile.sys -pagefile1 swapfile.sys\n```\n\n----------------------------------------\n\nTITLE: Initializing MemProcFS on Linux and Listing Processes\nDESCRIPTION: This snippet demonstrates initializing MemProcFS on a Linux system using a PCILeech PCIe FPGA device for live memory analysis of a Windows system. It initializes the `Vmm` struct with specified arguments, lists all processes, and prints their PID and name.  Dependencies include the `memprocfs` crate and a functional PCILeech setup.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/vmmrust/memprocfs/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// Initialize MemProcFS on Linux targeting a live Windows system\n// by reading memory using a PCILeech PCIe FPGA hardware device.\n// After initialization list all processes.\nlet mut args = [\"-printf\", \"-device\", \"fpga\"].to_vec();\nlet vmm = Vmm::new(\"/home/user/memprocfs/vmm.so\", &args)?\nif let Ok(process_all) = vmm.process_list() {\n    for process in &*process_all {\n        println!(\"{}\", process.pid, process.info()?.name);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MemProcFS on Windows and Listing VFS Content\nDESCRIPTION: This snippet shows how to initialize MemProcFS on a Windows system, analyzing a memory dump file. It configures forensic mode and searches for VMs. It then lists all files and directories within the virtual file system directory `/name/`.  This requires the `memprocfs` crate and a memory dump file, along with a compatible `vmm.dll`.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/vmmrust/memprocfs/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// Initialize MemProcFS on Windows - analyzing a memory dump file.\n// Also trigger the forensic mode and scan for VMs.\n// List all processes in the virtual file system directory /name/.\nlet mut args = [\"-printf\", \"-forensic\", \"1\", \"-vm\",\n                \"-device\", \"C:\\\\dumps\\\\memory.dmp\"].to_vec();\nlet vmm = Vmm::new(\"C:\\\\MemProcFS\\\\vmm.dll\", &args)?\nif let Ok(vfs_all) = vmm.vfs_list(\"/name/\") {\n    println!(\"Number of files/directories: {}.\", vfs_all.len());\n    for vfs in &*vfs_all {\n        println!(\"{vfs}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Using Vmmsharp to Analyze Memory Dump and Read Process Memory in C#\nDESCRIPTION: This code demonstrates initializing Vmmsharp, loading native MemProcFS libraries, attaching to a process ('explorer.exe'), retrieving a module's base address ('kernel32.dll'), and reading the first 256 bytes of that module's memory. It showcases how to perform memory analysis tasks programmatically in C# for forensic investigations.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/vmmsharp/README.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing Vmmsharp;\n\nnamespace vmmsharp_example {\n    class VmmsharpExample {\n        static void Main(string[] args) {\n            // Pre-load the native MemProcFS libraries.\n            // (This is recommended if the libraries are not already on the PATH.)\n            Vmm.LoadNativeLibrary(\"C:\\\\MemProcFS\\\\\");\n\n            // Initialize MemProcFS (Vmm object) with arguments.\n            // (A physical memory dump file in this example.)\n            Vmm vmm = new Vmm(\"-device\", \"c:\\\\dumps\\\\memorydump.raw\");\n\n            // Get the process object for explorer.exe:\n            VmmProcess explorerProcess = vmm.Process(\"explorer.exe\");\n\n            // Get the base address of kernel32.dll in the explorer process:\n            ulong kernel32Base = explorerProcess.GetModuleBase(\"kernel32.dll\");\n            Console.WriteLine(\"Base address of kernel32.dll in explorer.exe: {0:X}\", kernel32Base);\n\n            // Read the first 256 bytes of kernel32.dll in the explorer process:\n            byte[] memReadData = explorerProcess.MemRead(kernel32Base, 0x100);\n            string memReadHexDump = Vmm.UtilFillHexAscii(memReadData);\n            Console.WriteLine(\"Read from explorer.exe!kernel32.dll: \\n{0}\", memReadHexDump);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Physical Memory with MemProcFS Python API - Python\nDESCRIPTION: This Python snippet demonstrates reading 0x20 bytes from physical memory at address 0x1000 using the MemProcFS API. The 'memprocfs' Python package must be installed ('pip install memprocfs'), and a compatible memory dump must be available. The 'Vmm' class is initialized with the '-device' argument pointing to the memory dump file; 'memory.read(addr, size)' reads a specific memory region, and 'hex' formats the output for display. Inputs: memory dump file path, address, and size. Output: a hexadecimal string representation of memory bytes. Requires a supported platform and correct file paths; does not require macFuse if run via API.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport memprocfs\nvmm = memprocfs.Vmm(['-device', 'c:/temp/win10_memdump.raw'])\nprint(vmm.hex( vmm.memory.read(0x1000, 0x20) ))\n0000    e9 4d 06 00 01 00 00 00  01 00 00 00 3f 00 18 10   .M..........?...\n0010    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................\n```\n\n----------------------------------------\n\nTITLE: Exporting Server Certificate to .pfx with OpenSSL\nDESCRIPTION: This command exports the server TLS certificate and key into a .pfx file using OpenSSL. The .pfx file is password-protected with 'test'. The server-tls.key and server-tls.crt files are required as input.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/files/Certs/readme.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nopenssl pkcs12 -export -out server-tls.p12 -inkey server-tls.key -in server-tls.crt -password pass:test\n```\n\n----------------------------------------\n\nTITLE: Exporting Client Certificate to .pfx with OpenSSL\nDESCRIPTION: This command exports the client TLS certificate and key into a .pfx file using OpenSSL. The .pfx file is password-protected with 'test'. The client-tls.key and client-tls.crt files are required as input.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/files/Certs/readme.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nopenssl pkcs12 -export -out client-tls.p12 -inkey client-tls.key -in client-tls.crt -password pass:test\n```\n\n----------------------------------------\n\nTITLE: Generating Server TLS Certificate with OpenSSL\nDESCRIPTION: This command generates a server-side TLS certificate and key using OpenSSL. It creates a self-signed certificate valid for 365 days. The -subj parameter sets the Common Name (CN) to 'localhost'.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/files/Certs/readme.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nopenssl req -x509 -newkey rsa:2048 -keyout server-tls.key -out server-tls.crt -days 365 -nodes -subj \"/CN=localhost\"\n```\n\n----------------------------------------\n\nTITLE: Generating Client TLS Certificate with OpenSSL\nDESCRIPTION: This command generates a client-side TLS certificate and key using OpenSSL. It creates a self-signed certificate valid for 365 days. The -subj parameter sets the Common Name (CN) to 'localhost'.\nSOURCE: https://github.com/ufrisk/memprocfs/blob/master/files/Certs/readme.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nopenssl req -x509 -newkey rsa:2048 -keyout client-tls.key -out client-tls.crt -days 365 -nodes -subj \"/CN=localhost\"\n```"
  }
]