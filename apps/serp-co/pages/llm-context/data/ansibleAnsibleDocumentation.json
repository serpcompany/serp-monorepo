[
  {
    "owner": "ansible",
    "repo": "ansible-documentation",
    "content": "TITLE: Creating a Starter Ansible Playbook in YAML\nDESCRIPTION: This YAML snippet demonstrates the structure of a basic Ansible playbook. It defines plays and tasks, including the use of modules for essential operations such as pinging hosts and displaying messages. Required: Ansible must be installed, with a suitable inventory file present. 'playbook.yaml' should be placed within the working project directory. Inputs: the YAML playbook file; Outputs: Ansible executes specified tasks across managed nodes. Constraints: Ensure valid YAML formatting and appropriate indentation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_playbook.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: Example Play\n  hosts: all\n  tasks:\n    - name: Ping hosts\n      ansible.builtin.ping:\n    - name: Print Hello World\n      ansible.builtin.debug:\n        msg: \"Hello world\"\n```\n\n----------------------------------------\n\nTITLE: Marking Sensitive Module Options to Prevent Logging\nDESCRIPTION: The `no_log=True` parameter should be set for module options that handle sensitive data (like passwords or API keys). Ansible automatically strips the values of such options from logs and standard module return values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nno_log=True\n```\n\n----------------------------------------\n\nTITLE: Conditionally Importing Tasks Based on OS Family in Ansible Role (YAML)\nDESCRIPTION: Demonstrates importing platform-specific task files within a role's `tasks/main.yml`. It uses `import_tasks` with a `when` condition based on `ansible_facts['os_family']` to load either `redhat.yml` (using `yum`) or `debian.yml` (using `apt`) for web server installation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# roles/example/tasks/main.yml\n- name: Install the correct web server for RHEL\n  import_tasks: redhat.yml\n  when: ansible_facts['os_family']|lower == 'redhat'\n\n- name: Install the correct web server for Debian\n  import_tasks: debian.yml\n  when: ansible_facts['os_family']|lower == 'debian'\n```\n\nLANGUAGE: yaml\nCODE:\n```\n# roles/example/tasks/redhat.yml\n- name: Install web server\n  ansible.builtin.yum:\n    name: \"httpd\"\n    state: present\n```\n\nLANGUAGE: yaml\nCODE:\n```\n# roles/example/tasks/debian.yml\n- name: Install web server\n  ansible.builtin.apt:\n    name: \"apache2\"\n    state: present\n```\n\n----------------------------------------\n\nTITLE: Specifying Target Hosts in Ansible Plays (YAML)\nDESCRIPTION: Shows the `hosts:` keyword used at the beginning of an Ansible play. This keyword, also known as the host specifier, defines the target hosts or groups on which the tasks within the play will be executed. It can select single hosts, multiple hosts, groups, or combinations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nhosts:\n```\n\n----------------------------------------\n\nTITLE: Updating Web and Database Servers using Ansible Playbooks (YAML)\nDESCRIPTION: This YAML code snippet demonstrates an Ansible playbook containing two plays: one for updating web servers and one for database servers. Each play specifies a target host group, remote user, and a sequence of tasks using built-in modules like ansible.builtin.yum, ansible.builtin.template, and ansible.builtin.service. Dependencies include Ansible itself, appropriate host inventories (webservers, databases), and required modules. Inputs are the target hosts and playbook parameters; outputs are updated servers with ensured services. This example assumes root SSH access to the hosts and requires the relevant software (httpd, postgresql) to be available in the repositories.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_intro.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: Update web servers\n  hosts: webservers\n  remote_user: root\n\n  tasks:\n  - name: Ensure apache is at the latest version\n    ansible.builtin.yum:\n      name: httpd\n      state: latest\n\n  - name: Write the apache config file\n    ansible.builtin.template:\n      src: /srv/httpd.j2\n      dest: /etc/httpd.conf\n\n- name: Update db servers\n  hosts: databases\n  remote_user: root\n\n  tasks:\n  - name: Ensure postgresql is at the latest version\n    ansible.builtin.yum:\n      name: postgresql\n      state: latest\n\n  - name: Ensure that postgresql is started\n    ansible.builtin.service:\n      name: postgresql\n      state: started\n\n```\n\n----------------------------------------\n\nTITLE: Defining an Ansible Playbook to Render a Template - YAML\nDESCRIPTION: This snippet shows an Ansible playbook that writes the server hostname to a file using the template module with a Jinja2 source. The playbook applies to all hosts, contains a single task, and references an external Jinja2 template file. Dependencies include Ansible on the control node and the presence of the referenced template. The src parameter specifies the path to the template, while dest sets the output file destination. The playbook expects ansible_facts to provide the hostname variable, and outputs the rendered file to /tmp/hostname per host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_templating.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: Write hostname\\n  hosts: all\\n  tasks:\\n  - name: write hostname using jinja2\\n    ansible.builtin.template:\\n       src: templates/test.j2\\n       dest: /tmp/hostname\\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Apache Installation with Handlers in Ansible (YAML)\nDESCRIPTION: Demonstrates a complete Ansible playbook that ensures Apache (httpd) is installed, configures it, and uses a handler to restart the service only if the configuration changes. The playbook illustrates handler definition and notification using the notify keyword, with dependencies on ansible.builtin.yum, template, and service modules. Variables include http_port and max_clients; the play applies to webservers with root as remote_user. Key outputs include updated service state and configuration, limited to changes detected by Ansible tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: Verify apache installation\\n  hosts: webservers\\n  vars:\\n    http_port: 80\\n    max_clients: 200\\n  remote_user: root\\n  tasks:\\n    - name: Ensure apache is at the latest version\\n      ansible.builtin.yum:\\n        name: httpd\\n        state: latest\\n\\n    - name: Write the apache config file\\n      ansible.builtin.template:\\n        src: /srv/httpd.j2\\n        dest: /etc/httpd.conf\\n      notify:\\n        - Restart apache\\n\\n    - name: Ensure apache is running\\n      ansible.builtin.service:\\n        name: httpd\\n        state: started\\n\\n  handlers:\\n    - name: Restart apache\\n      ansible.builtin.service:\\n        name: httpd\\n        state: restarted\\n\n```\n\n----------------------------------------\n\nTITLE: Batched Asynchronous Playbook Tasks with Bulk Polling (YAML+Jinja/Ansible)\nDESCRIPTION: Demonstrates executing multiple asynchronous tasks by batching input items, launching them in groups, and polling for completion. main.yml defines a loop that breaks input (sleep durations) into batches for execution. execute_batch.yml launches tasks with 'poll: 0', collects their job IDs, and then checks their status with async_status in a loop. Relies on advanced looping and 'register' constructs in Ansible. Useful for controlling concurrency and resource load across many tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n#####################\n# main.yml\n#####################\n- name: Run items asynchronously in batch of two items\n  vars:\n    sleep_durations:\n      - 1\n      - 2\n      - 3\n      - 4\n      - 5\n    durations: \"{{ item }}\"\n  include_tasks: execute_batch.yml\n  loop: \"{{ sleep_durations | batch(2) | list }}\"\n\n#####################\n# execute_batch.yml\n#####################\n- name: Async sleeping for batched_items\n  ansible.builtin.command: sleep {{ async_item }}\n  async: 45\n  poll: 0\n  loop: \"{{ durations }}\"\n  loop_control:\n    loop_var: \"async_item\"\n  register: async_results\n\n- name: Check sync status\n  async_status:\n    jid: \"{{ async_result_item.ansible_job_id }}\"\n  loop: \"{{ async_results.results }}\"\n  loop_control:\n    loop_var: \"async_result_item\"\n  register: async_poll_results\n  until: async_poll_results.finished\n  retries: 30\n```\n\n----------------------------------------\n\nTITLE: Using Single Quotes For Variables in Windows Paths (YAML/Jinja)\nDESCRIPTION: This playbook snippet demonstrates using Jinja2 variables and single quotes in YAML for Ansible's win_copy module to copy a configuration file to a Windows host. The destination path utilizes a variable (tc_home) and Windows-style backslashes, showing best practice for path interpolation and backslash handling in YAML. Prerequisites are Ansible, YAML, and proper definition of the tc_home variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_9\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n---\n- name: Copy tomcat config\n  win_copy:\n    src: log4j.xml\n    dest: '{{tc_home}}\\lib\\log4j.xml'\n```\n\n----------------------------------------\n\nTITLE: Defining a Dictionary from Variable Lists Using Jinja2 Lookups - Ansible - YAML+Jinja\nDESCRIPTION: Demonstrates the use of Ansible 'vars' with Jinja2 filters and lookups to create a dictionary ('mydict') dynamically from variables whose names match a prefix (xyz_). Uses 'varnames' and 'vars' lookups, 'regex_replace', 'zip', and 'dict' to zip variable names with their values. Prerequisites: The variable names (e.g., xyz_stuff, xyz_morestuff) must be pre-defined in the scope. Input is a variable prefix pattern, and the output is a dictionary mapping the trimmed variable names to their respective values. Limitations: assumes matching variables exist and are set.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_13\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\nvars:\n    xyz_stuff: 1234\n    xyz_morestuff: 567\n    myvarnames: \"{{ q('varnames', '^xyz_') }}\"\n    mydict: \"{{ dict(myvarnames|map('regex_replace', '^xyz_', '')|list | zip(q('vars', *myvarnames))) }}\"\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Modules via CLI - Ansible - shell-session\nDESCRIPTION: Demonstrates the execution of various Ansible modules (such as 'service', 'ping', and 'command') on 'webservers' group hosts using the CLI. Key parameters include module name (-m) and arguments (-a). This pattern requires Ansible to be installed and configured with an inventory group called 'webservers'. Outputs from the modules are returned in JSON format. Typical use cases involve service state management, connectivity testing, and executing commands remotely.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/module_plugin_guide/modules_intro.rst#_snippet_0\n\nLANGUAGE: shell-session\nCODE:\n```\nansible webservers -m service -a \"name=httpd state=started\"\nansible webservers -m ping\nansible webservers -m command -a \"/sbin/reboot -t now\"\n```\n\n----------------------------------------\n\nTITLE: Using Registered Variable Output in a Loop (YAML)\nDESCRIPTION: This Ansible play retrieves a list of home directories using `ansible.builtin.command` and registers the result in `home_dirs`. The second task uses the `ansible.builtin.file` module to create symlinks in a backup spool directory. It iterates over the list of directories obtained from `home_dirs.stdout_lines` (which splits the standard output into a list of lines) using the `loop` keyword.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Registered variable usage as a loop list\n  hosts: all\n  tasks:\n\n    - name: Retrieve the list of home directories\n      ansible.builtin.command: ls /home\n      register: home_dirs\n\n    - name: Add home dirs to the backup spooler\n      ansible.builtin.file:\n        path: /mnt/bkspool/{{ item }}\n        src: /home/{{ item }}\n        state: link\n      loop: \"{{ home_dirs.stdout_lines }}\"\n      # same as loop: \"{{ home_dirs.stdout.split() }}\"\n```\n\n----------------------------------------\n\nTITLE: Using Custom Facts in Ansible Conditionals\nDESCRIPTION: This example shows a pattern for using custom facts. The first task runs a custom module (`site_facts`) to gather facts. The second task uses `ansible.builtin.command` and its execution is controlled by a `when` condition that checks the value of a custom fact gathered in the previous step.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n    - name: Gather site specific fact data\n      action: site_facts\n\n    - name: Use a custom fact\n      ansible.builtin.command: /usr/bin/thingy\n      when: my_custom_fact_just_retrieved_from_the_remote_system == '1234'\n```\n\n----------------------------------------\n\nTITLE: Using Recommended Regexp `'^'` with `lineinfile` Module (Ansible)\nDESCRIPTION: This represents the recommended regular expression `'^'` to use with the Ansible `lineinfile` module when the intent is to match every line in a file. Using an empty string for the regexp is deprecated as of Ansible 2.6 because it could lead to unintended behavior (replacing only the last line) and now triggers a warning. Use `'^'` instead for clarity and to avoid the warning.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.6.rst#_snippet_2\n\nLANGUAGE: ansible\nCODE:\n```\n'^'\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a List Variable with `loop` in Ansible\nDESCRIPTION: This YAML+Jinja snippet shows how to use the `loop` keyword to iterate over a list defined as a variable (e.g., in `vars` or an external file). The variable `somelist` is expected to contain the list of items to iterate over.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    loop: \"{{ somelist }}\"\n```\n\n----------------------------------------\n\nTITLE: Merging Dictionaries with combine Filter - Ansible - YAML\nDESCRIPTION: Illustrates merging two YAML dictionary variables (dict1 and dict2) using the combine Jinja2 filter within the set_fact module in a task. This requires the ansible.builtin.set_fact module and uses the ansible.builtin.combine filter. Takes dictionaries as inputs and combines their key-value pairs into a new merged_dict variable. Both dicts must exist. Dictionary keys in dict2 will override keys in dict1 if duplicated.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  dict1:\n    name: Leeroy Jenkins\n    age: 25\n    occupation: Astronaut\n\n  dict2:\n    location: Galway\n    country: Ireland\n    postcode: H71 1234\n\ntasks:\n- name: Combine dict1 and dict2 into a merged_dict var\n  ansible.builtin.set_fact:\n    merged_dict: \"{{ dict1 | ansible.builtin.combine(dict2) }}\"\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a Simple Inline List with `loop` in Ansible\nDESCRIPTION: This YAML+Jinja task uses the `ansible.builtin.user` module to add multiple users. It demonstrates iterating over a simple list of strings defined directly within the `loop` keyword. The `item` variable holds the current list element during each iteration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - name: Add several users\n      ansible.builtin.user:\n        name: \"{{ item }}\"\n        state: present\n        groups: \"wheel\"\n      loop:\n         - testuser1\n         - testuser2\n```\n\n----------------------------------------\n\nTITLE: Grouping Hosts Dynamically by OS using group_by (Reference)\nDESCRIPTION: This reStructuredText directive includes an external Ansible playbook (`yaml/tip_group_by.yaml`). The referenced playbook demonstrates using the `group_by` module to create dynamic host groups based on the target system's operating system name (likely derived from Ansible facts). This allows subsequent plays or tasks to target hosts based on their OS without predefining these groups in the inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/ansible_tips_tricks.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. literalinclude:: yaml/tip_group_by.yaml\n      :language: yaml\n```\n\n----------------------------------------\n\nTITLE: Looping Over Dictionary Items Portably in Ansible (YAML/Jinja2)\nDESCRIPTION: Shows how to iterate over key-value pairs in a dictionary in an Ansible task, making the playbook compatible with both Python2 and Python3 by applying the list filter to hosts.items() in the loop directive. The snippet contrasts the deprecated Python2-only approach (using hosts.iteritems()) with the cross-compatible method recommended for both Python versions. It depends on Ansible and Jinja2, with 'hosts' defined as a variable. The loop provides each dictionary item tuple to the task, which can be used in the debug message. Application is limited to environments where hosts is a dictionary.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_python_version.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    vars:\n      hosts:\n        testhost1: 127.0.0.2\n        testhost2: 127.0.0.3\n    tasks:\n      - debug:\n          msg: '{{ item }}'\n        # Only works with Python 2\n        #loop: \"{{ hosts.iteritems() }}\"\n        # Works with both Python 2 and Python 3\n        loop: \"{{ hosts.items() | list }}\"\n```\n\n----------------------------------------\n\nTITLE: Quoting User Input for Unsafe Shell Execution\nDESCRIPTION: Requires wrapping any variables originating from user input with `pipes.quote(x)` before passing them to `module.run_command` when `use_unsafe_shell=True` is specified. This prevents shell injection vulnerabilities by properly escaping characters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npipes.quote(x)\n```\n\n----------------------------------------\n\nTITLE: Templating Configuration Files Based on OS Distribution (YAML)\nDESCRIPTION: This Ansible task utilizes the `ansible.builtin.template` module to generate a configuration file `/etc/myapp/foo.conf`. It employs the `first_found` lookup plugin within a `loop` to dynamically determine the source template (`src`). The lookup searches first for a template named after the host's distribution (e.g., `CentOS.conf`, derived from `ansible_facts['distribution']`), then for a `default.conf` file, across the specified `paths` list. This allows for OS-specific template selection without complex inline conditionals. It depends on Ansible facts being available and the template files existing in the specified search locations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_31\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Template a file\n  ansible.builtin.template:\n    src: \"{{ item }}\"\n    dest: /etc/myapp/foo.conf\n  loop: \"{{ query('first_found', { 'files': myfiles, 'paths': mypaths}) }}\"\n  vars:\n    myfiles:\n      - \"{{ ansible_facts['distribution'] }}.conf\"\n      -  default.conf\n    mypaths: ['search_location_one/somedir/', '/opt/other_location/somedir/']\n```\n\n----------------------------------------\n\nTITLE: Complex Pattern Example in Playbook - Ansible Playbooks (YAML)\nDESCRIPTION: This YAML snippet demonstrates a complex Ansible host pattern that combines groups, intersections, and exclusions. The pattern 'webservers:dbservers:&staging:!phoenix' targets all hosts in 'webservers' and 'dbservers' that are also in 'staging', excluding those in 'phoenix'. Requires populated inventory groups matching these names.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nwebservers:dbservers:&staging:!phoenix\n```\n\n----------------------------------------\n\nTITLE: Installing Roles and Collections with ansible-galaxy (Bash)\nDESCRIPTION: This snippet shows the Bash command used to install both roles and collections defined within a `requirements.yml` file. The `ansible-galaxy install -r requirements.yml` command processes the specified file and installs all listed roles and collections according to their definitions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_multiple_collections.txt#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy install -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Comprehensive YAML Example Structure\nDESCRIPTION: Provides a combined example showcasing various YAML features: top-level key-value pairs, boolean values, lists (foods), nested dictionaries (languages), and a multiline string using the literal block scalar (education).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# An employee record\nname: Martin D'vloper\njob: Developer\nskill: Elite\nemployed: True\nfoods:\n  - Apple\n  - Orange\n  - Strawberry\n  - Mango\nlanguages:\n  perl: Elite\n  python: Elite\n  pascal: Lame\neducation: |\n  4 GCSEs\n  3 A-Levels\n  BSc in the Internet of Things\n```\n\n----------------------------------------\n\nTITLE: Referencing a Simple Variable in an Ansible Task using Jinja2\nDESCRIPTION: This YAML snippet demonstrates using Jinja2 syntax `{{ variable_name }}` to reference the previously defined `remote_install_path` variable within the `dest` parameter of the `ansible.builtin.template` module. This allows dynamic path construction based on variable values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    ansible.builtin.template:\n      src: foo.cfg.j2\n      dest: '{{ remote_install_path }}/foo.cfg'\n```\n\n----------------------------------------\n\nTITLE: Combining Block, Rescue, and Always for Complex Error Handling in Ansible YAML\nDESCRIPTION: This comprehensive Ansible example demonstrates using 'block', 'rescue', and 'always' sections together for robust error handling. The 'block' contains the primary tasks. If a failure occurs, the 'rescue' section attempts recovery. The 'always' section executes unconditionally after the 'block' and 'rescue' sections have completed, regardless of their outcome.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_blocks.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Attempt and graceful roll back demo\n    block:\n      - name: Print a message\n        ansible.builtin.debug:\n          msg: 'I execute normally'\n\n      - name: Force a failure\n        ansible.builtin.command: /bin/false\n\n      - name: Never print this\n        ansible.builtin.debug:\n          msg: 'I never execute, due to the above task failing, :-('\n    rescue:\n      - name: Print when errors\n        ansible.builtin.debug:\n          msg: 'I caught an error'\n\n      - name: Force a failure in middle of recovery! >:-)\n        ansible.builtin.command: /bin/false\n\n      - name: Never print this\n        ansible.builtin.debug:\n          msg: 'I also never execute :-('\n    always:\n      - name: Always do this\n        ansible.builtin.debug:\n          msg: \"This always executes\"\n```\n\n----------------------------------------\n\nTITLE: Asserting File Existence and Directory Type with Ansible Stat and Assert Modules in YAML\nDESCRIPTION: Shows how to use the 'stat' module to gather file metadata, register it to a variable, then assert file existence and directory type. This is helpful for checking non-Ansible-managed files, and leverages Ansible variables and fact structure ('p.stat.exists', 'p.stat.isdir'). Requires the target path to be readable and Ansible's stat/assert module capabilities.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n   - ansible.builtin.stat:\n       path: /path/to/something\n     register: p\n\n   - ansible.builtin.assert:\n       that:\n         - p.stat.exists and p.stat.isdir\n```\n\n----------------------------------------\n\nTITLE: Forcing a Task to Always Notify Handlers via changed_when in Ansible (YAML)\nDESCRIPTION: Demonstrates the use of changed_when: True to ensure a handler is notified on every execution of a task, regardless of file state. The example copies a configuration file and always reports the task as changed, ensuring the restart apache handler is invoked. Useful for forcing restarts or actions despite idempotency checks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n  - name: Copy httpd configuration\\n    ansible.builtin.copy:\\n      src: ./new_httpd.conf\\n      dest: /etc/httpd/conf/httpd.conf\\n    # The task is always reported as changed\\n    changed_when: True\\n    notify: Restart apache\\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Task Execution Based on Registered Variable Content (YAML)\nDESCRIPTION: This Ansible play first executes a shell command (`cat /etc/motd`) and registers its output in the `motd_contents` variable using the `register` keyword. The second task then executes another shell command conditionally, using a `when` statement that checks if the string 'hi' is found within the `stdout` of the registered `motd_contents` variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Test play\n  hosts: all\n\n  tasks:\n\n      - name: Register a variable\n        ansible.builtin.shell: cat /etc/motd\n        register: motd_contents\n\n      - name: Use the variable in conditional statement\n        ansible.builtin.shell: echo \"motd contains the word hi\"\n        when: motd_contents.stdout.find('hi') != -1\n```\n\n----------------------------------------\n\nTITLE: Passing Extra Variables from Files - Ansible - CLI\nDESCRIPTION: Demonstrates use of the @filename syntax to load extra variables from JSON or YAML files with ansible-playbook --extra-vars. This allows providing large or complex variable sets without the hassle of shell escaping. Inputs are file paths to JSON/YAML files; outputs are in-playbook variables. Files must exist and be valid; incompatible formats or missing files will cause errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_19\n\nLANGUAGE: text\nCODE:\n```\nansible-playbook release.yml --extra-vars \"@some_file.json\"\nansible-playbook release.yml --extra-vars \"@some_file.yaml\"\n```\n\n----------------------------------------\n\nTITLE: Deleting File or Directory with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Removes a file or directory (recursively, if it's a directory) from remote hosts using the `ansible.builtin.file` module. Setting `state=absent` ensures the target path (`dest=/path/to/c`) does not exist on the 'webservers'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.file -a \"dest=/path/to/c state=absent\"\n```\n\n----------------------------------------\n\nTITLE: Parsing Network Command Output with pyATS in Ansible\nDESCRIPTION: This Ansible task executes the `show interface` command on a network device and uses `ansible.utils.cli_parse` with the `ansible.netcommon.pyats` parser. This parser utilizes the Cisco pyATS library to parse the command output based on the device's `ansible_network_os` (automatically mapped) or a specified OS. The resulting structured data is stored in the `interfaces` fact.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"Run command and parse with pyats\"\n  ansible.utils.cli_parse:\n    command: show interface\n    parser:\n      name: ansible.netcommon.pyats\n    set_fact: interfaces\n```\n\n----------------------------------------\n\nTITLE: Copying Files with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Transfers a local file (`src=/etc/hosts`) to a remote destination (`dest=/tmp/hosts`) on all servers in the 'atlanta' group using the `ansible.builtin.copy` module (`-m ansible.builtin.copy`). This provides a parallel SCP capability.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible atlanta -m ansible.builtin.copy -a \"src=/etc/hosts dest=/tmp/hosts\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping Main Execution in Ansible Module - Python\nDESCRIPTION: This snippet demonstrates the recommended practice of defining a main function and then invoking it under the '__main__' guard. This allows the module code to be imported in unit tests without automatically running the main logic. There are no external dependencies; it simply shows idiomatic Python to support testability and direct execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nif __name__ == '__main__':\\n    main()\n```\n\n----------------------------------------\n\nTITLE: Conditionally Executing Task Based on Empty Registered Variable Output (YAML)\nDESCRIPTION: This Ansible play first lists the contents of a directory 'mydir' using `ansible.builtin.command` and registers the output in the `contents` variable. The second task uses `ansible.builtin.debug` to print a message, but only runs (`when`) if the standard output (`stdout`) of the `contents` variable is an empty string, indicating the directory was empty.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- name: check registered variable for emptiness\n  hosts: all\n\n  tasks:\n\n      - name: List contents of directory\n        ansible.builtin.command: ls mydir\n        register: contents\n\n      - name: Check contents for emptiness\n        ansible.builtin.debug:\n          msg: \"Directory is empty\"\n        when: contents.stdout == \"\"\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbooks with Check and Diff Mode via Console\nDESCRIPTION: This console command executes an Ansible playbook with both check and diff modes enabled and limited to a single host. 'Check' mode simulates changes, while 'diff' displays before-and-after differences for supported modules. Use this for detailed, host-specific playbook validation. Requires Ansible installed and network access to specified hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_checkmode.rst#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\nansible-playbook foo.yml --check --diff --limit foo.example.com\n```\n\n----------------------------------------\n\nTITLE: Defining Role Argument Specification (argument_specs.yml) - Ansible - YAML\nDESCRIPTION: Shows a sample argument specification for a custom role ('myapp') in roles/myapp/meta/argument_specs.yml, including options of various types (int, str, list, list of dicts, dict with suboptions) with default values, descriptions, and constraints. Requires Ansible 2.11+, as older versions may not support argument validation via argument_specs.yml. Inputs: dictionary of role parameters to validate. Outputs: tasks will fail if validation does not pass. Limitations: Only Ansible 2.11+ fully supports this file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n  # roles/myapp/meta/argument_specs.yml\n  ---\n  argument_specs:\n    # roles/myapp/tasks/main.yml entry point\n    main:\n      short_description: Main entry point for the myapp role\n      description:\n        - This is the main entrypoint for the C(myapp) role.\n        - Here we can describe what this entrypoint does in lengthy words.\n        - Every new list item is a new paragraph. You can have multiple sentences\n          per paragraph.\n      author:\n        - Daniel Ziegenberg\n      options:\n        myapp_int:\n          type: \"int\"\n          required: false\n          default: 42\n          description:\n            - \"The integer value, defaulting to 42.\"\n            - \"This is a second paragraph.\"\n\n        myapp_str:\n          type: \"str\"\n          required: true\n          description: \"The string value\"\n\n        myapp_list:\n          type: \"list\"\n          elements: \"str\"\n          required: true\n          description: \"A list of string values.\"\n          version_added: 1.3.0\n\n        myapp_list_with_dicts:\n          type: \"list\"\n          elements: \"dict\"\n          required: false\n          default:\n            - myapp_food_kind: \"meat\"\n              myapp_food_boiling_required: true\n              myapp_food_preparation_time: 60\n            - myapp_food_kind: \"fruits\"\n              myapp_food_preparation_time: 5\n          description: \"A list of dicts with a defined structure and with default a value.\"\n          options:\n            myapp_food_kind:\n              type: \"str\"\n              choices:\n                - \"vegetables\"\n                - \"fruits\"\n                - \"grains\"\n                - \"meat\"\n              required: false\n              description: \"A string value with a limited list of allowed choices.\"\n\n            myapp_food_boiling_required:\n              type: \"bool\"\n              required: false\n              default: false\n              description: \"Whether the kind of food requires boiling before consumption.\"\n\n            myapp_food_preparation_time:\n              type: int\n              required: true\n              description: \"Time to prepare a dish in minutes.\"\n\n        myapp_dict_with_suboptions:\n          type: \"dict\"\n          required: false\n          default:\n            myapp_host: \"bar.foo\"\n            myapp_exclude_host: true\n            myapp_path: \"/etc/myapp\"\n          description: \"A dict with a defined structure and default values.\"\n          options:\n            myapp_host:\n              type: \"str\"\n              choices:\n                - \"foo.bar\"\n                - \"bar.foo\"\n                - \"ansible.foo.bar\"\n              required: true\n              description: \"A string value with a limited list of allowed choices.\"\n\n            myapp_exclude_host:\n```\n\n----------------------------------------\n\nTITLE: Recommended: Accessing Dictionary Parameters Individually: Ansible Playbook YAML Syntax\nDESCRIPTION: This recommended YAML snippet shows accessing individual dictionary parameters using Jinja2 template syntax in module arguments. It highlights improved safety and clarity by referencing 'msg' explicitly ('{{debug_params['msg']}}'), eliminating ambiguity present in the deprecated approach. Required dependencies include the debug module and Jinja2 templating.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: localhost\n  gather_facts: no\n  vars:\n    debug_params:\n      msg: \"hello there\"\n  tasks:\n    - debug:\n      msg: \"{{debug_params['msg']}}\"\n```\n\n----------------------------------------\n\nTITLE: Ensuring Service State with become - Ansible YAML\nDESCRIPTION: This YAML playbook task ensures that the 'httpd' service is running by using the 'service' module with 'become: true' to escalate privileges. It requires Ansible and access to the remote target as a non-root user. The key parameter is 'become', which enables privilege escalation (typically to root). Inputs: the service name ('httpd') and desired state ('started'). Output: the service will be started if not already running. Limitations: requires correct privilege escalation configuration and target system compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Ensure the httpd service is running\\n  service:\\n    name: httpd\\n    state: started\\n  become: true\n```\n\n----------------------------------------\n\nTITLE: Enabling Privilege Mode for an Entire Play in Ansible YAML\nDESCRIPTION: This YAML snippet illustrates setting privilege escalation (`become: true` with `become_method: enable`) at the play level in an Ansible playbook. This configuration ensures all tasks within the play targeting `eos-switches` will execute in enable mode, like the example task using `arista.eos.eos_facts`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: eos-switches\n  become: true\n  become_method: enable\n  tasks:\n    - name: Gather facts (eos)\n      arista.eos.eos_facts:\n        gather_subset:\n          - \"!hardware\"\n```\n\n----------------------------------------\n\nTITLE: Quoting Ansible Variables in YAML\nDESCRIPTION: Highlights the necessity of quoting scalar values in YAML when they begin with '{', specifically when using Ansible variables like '{{ variable }}'. Failing to quote will cause YAML to interpret it as the start of a dictionary, leading to errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\nfoo: \"{{ variable }}\"\n```\n\n----------------------------------------\n\nTITLE: Installing Roles using ansible-galaxy Command (Bash)\nDESCRIPTION: This Bash command demonstrates how to use `ansible-galaxy role install` with the `-r` flag to install all roles defined in a specified `requirements.yml` file. This command processes the root requirements file, including any roles specified via the `include` directive.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role install -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Setting Universal Default Variables - Ansible YAML\nDESCRIPTION: Common variables for all hosts are declared in group_vars/all. These provide baseline settings, ensuring every host in every group receives default 'ntp' and 'backup' values unless explicitly overridden. Intended for global settings applicable across the environment, with no dependencies beyond the default variable precedence rules in Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: group_vars/all\\nntp: ntp-boston.example.com\\nbackup: backup-boston.example.com\n```\n\n----------------------------------------\n\nTITLE: Ignoring Task Failures in Ansible (YAML)\nDESCRIPTION: This Ansible task demonstrates using the `ignore_errors: true` directive. When set to true, Ansible will continue executing the playbook on the specific host even if this task fails (returns a non-zero exit code or signals failure). This prevents a single task failure from halting the entire play for that host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Do not count this as a failure\n  ansible.builtin.command: /bin/false\n  ignore_errors: true\n```\n\n----------------------------------------\n\nTITLE: Accessing Facts from Another Host via `hostvars` using Jinja\nDESCRIPTION: This Jinja2 snippet demonstrates how to access facts (specifically 'os_family') belonging to a different host ('asdf.example.com') using the special `hostvars` variable. This is particularly useful when fact caching is enabled, allowing access to information about hosts not currently targeted in the play.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_6\n\nLANGUAGE: jinja\nCODE:\n```\n{{ hostvars['asdf.example.com']['ansible_facts']['os_family'] }}\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters Dynamically with include_role in Ansible (YAML)\nDESCRIPTION: Shows the beginning of an example demonstrating how to pass parameters, such as variables and tags, when using `include_role` for dynamic role execution within the `tasks` section of an Ansible playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\n```\n\n----------------------------------------\n\nTITLE: Direct Parameter Assignment to Ansible Modules (YAML)\nDESCRIPTION: Provides examples of direct assignment, where parameters are passed directly to an Ansible module or action plugin within a task definition. The `debug` module receives the `msg` parameter, and the `ping` module receives the `data` parameter directly. This is the most common way to configure module behavior within a task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- debug: msg='this is a direct assignment option to an action plugin'\n\n- ping:\n    data: also a direct assignment\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Ansible Playbook to Get Network Configuration using YAML\nDESCRIPTION: This YAML file defines a simple Ansible playbook named \"Network Getting Started First Playbook\". It targets all hosts defined in the inventory, specifies `ansible.netcommon.network_cli` as the connection method, and includes two tasks: one to gather device facts using the `vyos.vyos.vyos_facts` module and another to display the collected hostname and OS using the `debug` module. This demonstrates structuring basic automation steps within a playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Network Getting Started First Playbook\n  hosts: all\n  gather_facts: false\n  connection: ansible.netcommon.network_cli\n\n  tasks:\n\n    - name: Get config for VyOS devices\n      vyos.vyos.vyos_facts:\n        gather_subset: '!all'\n        gather_network_resources:\n          - config\n\n    - name: Display the config\n      debug:\n        msg: \"The hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}\"\n```\n\n----------------------------------------\n\nTITLE: Conditionally Configuring SELinux with Ansible (YAML)\nDESCRIPTION: This Ansible task uses the `ansible.posix.seboolean` module to configure the `mysql_connect_any` SELinux boolean. The task only runs when the `ansible_selinux.status` fact equals \"enabled\", demonstrating a simple conditional execution based on a system fact using the `when` clause.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Configure SELinux to start mysql on any port\n    ansible.posix.seboolean:\n      name: mysql_connect_any\n      state: true\n      persistent: true\n    when: ansible_selinux.status == \"enabled\"\n    # all variables can be used directly in conditionals without double curly braces\n```\n\n----------------------------------------\n\nTITLE: Using the Notify Keyword in Ansible Tasks (YAML)\nDESCRIPTION: Highlights the `notify` keyword used within an Ansible task. This keyword triggers associated handlers, but only if the task reports a change in the system's state. It's commonly used to restart services only when their configuration files are modified.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nnotify\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Local Ansible Collection Installation Adjacent to Playbooks\nDESCRIPTION: This text block shows a recommended project layout where Ansible collections are stored locally within the project directory under `./collections/ansible_collections/`. This structure keeps the playbook (`play.yml`) and its specific collection dependencies (`my_namespace/my_collection`) together, enhancing project portability, ensuring consistent versions, and simplifying version control.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n./\n├── play.yml\n├── collections/\n│   └── ansible_collections/\n│               └── my_namespace/\n│                   └── my_collection/<collection structure lives here>\n```\n\n----------------------------------------\n\nTITLE: Parsing Network Command Output with Custom TextFSM Template in Ansible\nDESCRIPTION: This Ansible task runs the `show interface` command and uses `ansible.utils.cli_parse` with the `ansible.utils.textfsm` parser. This parser requires the `textfsm` Python library and uses a TextFSM template (like the custom one shown previously) to parse the command output. The location of the template is typically inferred based on `ansible_network_os` or can be explicitly provided. The parsed data is stored in the `interfaces` fact.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"Run command and parse with textfsm\"\n  ansible.utils.cli_parse:\n    command: show interface\n    parser:\n      name: ansible.utils.textfsm\n    set_fact: interfaces\n```\n\n----------------------------------------\n\nTITLE: Grouping Inventory by Platform with Common Variables - YAML\nDESCRIPTION: This sample YAML inventory demonstrates grouping devices by platform and assigning platform-specific group variables at the 'network' and 'webservers' group level. The 'network' group contains both leaf and spine groups, and variables like connection plugin, network OS, and SSH user are set for all contained hosts through group inheritance. This structure is useful for large, heterogeneous environments and requires only standard Ansible inventory support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\nleafs:\n  hosts:\n    leaf01:\n      ansible_host: 10.16.10.11\n    leaf02:\n      ansible_host: 10.16.10.12\n\nspines:\n  hosts:\n    spine01:\n      ansible_host: 10.16.10.13\n    spine02:\n      ansible_host: 10.16.10.14\n\nnetwork:\n  children:\n    leafs:\n    spines:\n  vars:\n    ansible_connection: ansible.netcommon.network_cli\n    ansible_network_os: vyos.vyos.vyos\n    ansible_user: my_vyos_user\n\nwebservers:\n  hosts:\n    webserver01:\n      ansible_host: 10.16.10.15\n    webserver02:\n      ansible_host: 10.16.10.16\n  vars:\n    ansible_user: my_server_user\n\ndatacenter:\n  children:\n    network:\n    webservers:\n\n```\n\n----------------------------------------\n\nTITLE: Running Sanity, Unit, and Integration Tests using Ansible-test (Shell)\nDESCRIPTION: This trio of shell commands demonstrates execution of different Ansible test suites: sanity (static analysis), units (unit tests), and integration (functional module testing) with optional verbosity or targeting. Requires an initialized environment and the ansible-test tool. Input is the test category (e.g., integration -v ping); output is detailed console test results.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nansible-test sanity\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration -v ping\n```\n\n----------------------------------------\n\nTITLE: Looping Over All Inventory Hosts using 'query' and 'inventory_hostnames'\nDESCRIPTION: This snippet demonstrates using the `query` function with the `inventory_hostnames` lookup plugin to retrieve a list of all hosts in the inventory ('all'). The `ansible.builtin.debug` module then prints each hostname obtained from the loop.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_19\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Show all the hosts in the inventory\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ query('inventory_hostnames', 'all') }}\"\n```\n\n----------------------------------------\n\nTITLE: Setting API Authentication Defaults using Module Defaults in Ansible YAML\nDESCRIPTION: This Ansible playbook illustrates a practical use case for `module_defaults` by setting default authentication parameters (`force_basic_auth`, `user`, `password`) for the `ansible.builtin.uri` module. This avoids repeating authentication details in multiple tasks that interact with the same API.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\n- hosts: localhost\n  module_defaults:\n    ansible.builtin.uri:\n      force_basic_auth: true\n      user: some_user\n      password: some_password\n  tasks:\n    - name: Interact with a web service\n      ansible.builtin.uri:\n        url: http://some.api.host/v1/whatever1\n\n    - name: Interact with a web service\n      ansible.builtin.uri:\n        url: http://some.api.host/v1/whatever2\n\n    - name: Interact with a web service\n      ansible.builtin.uri:\n        url: http://some.api.host/v1/whatever3\n```\n\n----------------------------------------\n\nTITLE: Testing PostgreSQL User Creation and Query Assertions with Ansible YAML\nDESCRIPTION: This YAML code block lays out a sequence of integration test tasks for the 'community.postgresql.postgresql_user' and 'community.postgresql.postgresql_query' modules. The primary goals are to verify creation of a user with an underscored name, assert the expected change result, query the database to check the presence of the user, and confirm the correct row count in the result set. Dependencies include the Ansible 'community.postgresql' collection and a running database. Key parameters include the user name, SQL queries, and registered variables for assertion. Expected inputs are variable names and module options; expected outputs are assertion results and query row counts. The code assumes necessary modules and environment are properly configured. Limitations may include reliance on test database state and prerequisites.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_updating.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# https://github.com/ansible-collections/community.postgresql/issues/NUM\n- name: Test username containing underscore\n  community.postgresql.postgresql_user:\n    name: underscored_user\n  register: result\n\n- name: Check the module returns what we expect\n  assert:\n    that:\n      - result is changed\n\n- name: Query the database if the user exists\n  community.postgresql.postgresql_query:\n    query: SELECT * FROM pg_authid WHERE rolename = 'underscored_user'\n  register: result\n\n- name: Check the database returns one row\n  assert:\n    that:\n      - result.query_result.rowcount == 1\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook from the Command Line using Bash\nDESCRIPTION: This command executes the Ansible playbook stored in the 'first_playbook.yml' file. It specifies the target host directly via the inventory flag (`-i vyos.example.net,`), sets the SSH username (`-u ansible`), prompts for the SSH password (`-k`), and provides the required network OS type as an extra variable (`-e ansible_network_os=vyos.vyos.vyos`). This shows the standard way to run a playbook file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -i vyos.example.net, -u ansible -k -e ansible_network_os=vyos.vyos.vyos first_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Fetching and Parsing Interface State with Ansible Playbook (YAML)\nDESCRIPTION: This Ansible playbook task connects to Cisco NXOS devices using `ansible.netcommon.network_cli`, executes the 'show interface' command, and parses the output into structured data using the `ansible.utils.cli_parse` module with the `ansible.netcommon.pyats` parser. The structured data is stored in the `nxos_pyats_show_interface` variable. A subsequent task prints the parsed data. Requires the `ansible.netcommon` and `ansible.utils` collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/validate.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: nxos\n  connection: ansible.netcommon.network_cli\n  gather_facts: false\n  vars:\n    ansible_network_os: cisco.nxos.nxos\n    ansible_user: \"changeme\"\n    ansible_password: \"changeme\"\n\n  tasks:\n  - name: \"Fetch interface state and parse with pyats\"\n    ansible.utils.cli_parse:\n      command: show interface\n      parser:\n        name: ansible.netcommon.pyats\n    register: nxos_pyats_show_interface\n\n  - name: print structured interface state data\n    ansible.builtin.debug:\n      msg: \"{{ nxos_pyats_show_interface['parsed'] }}\"\n```\n\n----------------------------------------\n\nTITLE: Limiting Task Workers using Throttle in Ansible Playbook (YAML)\nDESCRIPTION: Shows how to restrict task concurrency using the 'throttle' keyword set to 1, ensuring only a single worker executes the specified command at a time. This should be applied to CPU/IO-intensive or limited resources. Can only reduce effective parallelism below other limits (such as 'forks' or 'serial'). No special dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n- command: /path/to/cpu_intensive_command\\n  throttle: 1\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Module Main and Patching Exit Methods - Python\nDESCRIPTION: Demonstrates setting up a unit test that patches AnsibleModule methods (such as exit_json) using pytest's monkeypatch, sets module arguments, and invokes the module's main function. This ensures the module is properly isolated and testable, supporting end-to-end functional validation in test environments using monkeypatch or equivalent setups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# This test is based around pytest's features for individual test functions\\nimport pytest\\nimport ansible.modules.module.group.my_module as my_module\\n\\ndef test_main_function(monkeypatch):\\n    monkeypatch.setattr(my_module.AnsibleModule, \"exit_json\", fake_exit_json)\\n    set_module_args({\\n        'activationkey': 'key',\\n        'username': 'user',\\n        'password': 'pass',\\n    })\\n    my_module.main()\n```\n\n----------------------------------------\n\nTITLE: Extracting Nested Dictionary Values with Jinja2 Filters in Ansible\nDESCRIPTION: This Ansible task uses the `debug` module to display extracted data. It demonstrates chaining Jinja2 filters (`map`, `extract`, `attribute`, `flatten`) to retrieve the 'type' attribute from nested dictionaries within `chains_config`, based on the keys present in the `chains` list. The `vars` section defines the input data structures.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_2\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\ntasks:\n  - name: Show extracted list of keys from a list of dictionaries\n    ansible.builtin.debug:\n      msg: \"{{ chains | map('extract', chains_config) | map(attribute='configs') | flatten | map(attribute='type') | flatten }}\"\n    vars:\n      chains: [1, 2]\n      chains_config:\n          1:\n              foo: bar\n              configs:\n                  - type: routed\n                    version: 0.1\n                  - type: bridged\n                    version: 0.2\n          2:\n              foo: baz\n              configs:\n                  - type: routed\n                    version: 1.0\n                  - type: bridged\n                    version: 1.1\n```\n\n----------------------------------------\n\nTITLE: Using Roles at the Play Level in Ansible Playbook (YAML)\nDESCRIPTION: Shows the standard method of applying roles (`common`, `webservers`) to hosts within a play using the `roles` keyword. These roles are processed statically during playbook parsing before the main `tasks` section.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - common\n    - webservers\n```\n\n----------------------------------------\n\nTITLE: Upgrading Ansible with pip\nDESCRIPTION: Upgrades an existing Ansible installation (installed via pip for the current user) to the latest released version. The '--upgrade' flag tells pip to fetch and install the newest version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_13\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --upgrade --user ansible\n```\n\n----------------------------------------\n\nTITLE: Looping Over a Subset of Inventory Hosts using 'query' and Patterns\nDESCRIPTION: This task shows how to loop over a specific subset of hosts defined by an inventory pattern ('all:!www', meaning all hosts except those in the 'www' group). It uses the `query` function with the `inventory_hostnames` lookup plugin and the pattern, then prints each matching hostname using `ansible.builtin.debug`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_20\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Show all the hosts matching the pattern, ie all but the group www\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ query('inventory_hostnames', 'all:!www') }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Ansible Inventory (YAML)\nDESCRIPTION: Presents the equivalent of the basic INI inventory file but using YAML syntax. Hosts are defined under the `hosts:` key within each group definition. Hosts without an explicit group are shown under the `ungrouped` group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nungrouped:\n  hosts:\n    mail.example.com:\nwebservers:\n  hosts:\n    foo.example.com:\n    bar.example.com:\ndbservers:\n  hosts:\n    one.example.com:\n    two.example.com:\n    three.example.com:\n```\n\n----------------------------------------\n\nTITLE: Ensuring List Input for Loops using 'lookup' with 'wantlist=True'\nDESCRIPTION: This snippet demonstrates an alternative method to ensure list input for `loop`. It uses the `lookup` function with the `inventory_hostnames` plugin and explicitly sets `wantlist=True` to force the lookup to return a list instead of a comma-separated string.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_22\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nloop: \"{{ lookup('inventory_hostnames', 'all', wantlist=True) }}\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Nested Variables - Ansible - YAML+Jinja\nDESCRIPTION: Presents two examples for accessing deeply nested values (e.g., network interface IP addresses) in Ansible data structures using both bracket and dot notation with Jinja2 template syntax. No dependencies besides Jinja2 variable rendering. Inputs are nested dictionaries (such as ansible_facts); outputs are scalar or compound values extracted from these structures. Fails if any intermediate key is missing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_12\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n'{{ ansible_facts[\"eth0\"][\"ipv4\"][\"address\"] }}'\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n{{ ansible_facts.eth0.ipv4.address }}\n```\n\n----------------------------------------\n\nTITLE: Prompting for Variables in Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet shows how to prompt users for input (e.g., username and password) interactively using the 'vars_prompt' feature in an Ansible playbook. The configuration includes settings for visibility (the 'private' parameter) and demonstrates injecting user-supplied values into a task. Dependencies: Ansible installed. Parameters: 'name' for variable, 'prompt' for the message, 'private' for input visibility. Inputs: user answers at runtime; Outputs: assigned variables accessible in tasks. Implements secure or visible input prompts within playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_prompts.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- hosts: all\\n  vars_prompt:\\n\\n    - name: username\\n      prompt: What is your username?\\n      private: false\\n\\n    - name: password\\n      prompt: What is your password?\\n\\n  tasks:\\n\\n    - name: Print a message\\n      ansible.builtin.debug:\\n        msg: 'Logging in as {{ username }}'\n```\n\n----------------------------------------\n\nTITLE: Defining Default Role Variables in Ansible Roles - YAML\nDESCRIPTION: This code sets a default variable http_port in the defaults directory of an Ansible role (roles/x/defaults/main.yml). Any play or host using this role will inherit http_port:80 unless it is overridden in inventory, variables, or by extra-vars. This provides a reliable fallback and helps avoid undefined-variable errors; no special dependencies except proper role structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: roles/x/defaults/main.yml\\n# if no other value is supplied in inventory or as a parameter, this value will be used\\nhttp_port: 80\n```\n\n----------------------------------------\n\nTITLE: Asserting Desired State with Ansible Service Module in YAML\nDESCRIPTION: This YAML snippet demonstrates the use of Ansible's built-in 'service' module to ensure a service (e.g., 'foo') is started and enabled on the target system. It showcases declarative infrastructure testing, where playbooks assert rather than verify service state, capitalizing on Ansible's fail-fast mechanism. Requirements include Ansible installed and inventory configured; key parameters include 'name' (service name), 'state' (desired status), and 'enabled' (startup behavior).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - ansible.builtin.service:\n      name: foo\n      state: started\n      enabled: true\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Ansible Callback Plugin in Python\nDESCRIPTION: Shows the fundamental structure for creating an Ansible callback plugin. It involves importing `CallbackBase` from `ansible.plugins.callback` and defining a new class `CallbackModule` that inherits from it. Further functionality is added by overriding methods from the base class, particularly those starting with `v2` for Ansible 2.0+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.callback import CallbackBase\n\nclass CallbackModule(CallbackBase):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Running Ad Hoc Commands with Patterns - Ansible (Bash)\nDESCRIPTION: This snippet demonstrates the basic structure of an ad hoc Ansible command, specifying the pattern, module, and arguments. It requires Ansible to be installed and an inventory defined. The <pattern> targets hosts/groups; <module_name> indicates the Ansible module; and <module options> delivers module arguments. Output and effect depend on the pattern and module used.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible <pattern> -m <module_name> -a \"<module options>\"\n```\n\n----------------------------------------\n\nTITLE: Defining Metagroups and Group Hierarchies in Inventory - yaml\nDESCRIPTION: This YAML snippet demonstrates creation of metagroups, allowing logical grouping of multiple subgroups. The 'datacenter' group aggregates the 'network' group and web servers, showing advanced grouping for complex topologies. Recommended for large deployments. Requires Ansible YAML inventory and proper group naming.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ndatacenter:\\n  children:\\n    network:\\n    webservers:\n```\n\n----------------------------------------\n\nTITLE: Specifying Collections in a Playbook for Plugin Resolution (YAML+Jinja)\nDESCRIPTION: Illustrates use of the 'collections' keyword in a playbook to control search paths for modules and plugins, including role imports and tasks referencing modules by short names. Inputs include the inventory, the list of collections, and any additional variables used in Jinja expressions. Dependencies are the relevant collection(s) installed on the system. Roles called by the playbook define their own collections context, so this does not affect them.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n     - name: Run a play using the collections keyword\\n       hosts: all\\n       collections:\\n         - my_namespace.my_collection\\n\\n       tasks:\\n\\n         - name: Import a role\\n           ansible.builtin.import_role:\\n             name: role1\\n\\n         - name: Run a module not specifying FQCN\\n           my_module:\\n             option1: value\\n\\n         - name: Run a debug task\\n           ansible.builtin.debug:\\n             msg: '{{ lookup(\"my_namespace.my_collection.lookup1\", \"param1\")| my_namespace.my_collection.filter1 }}'\n```\n\n----------------------------------------\n\nTITLE: Optimally Passing a List to the `yum` Module in Ansible\nDESCRIPTION: This YAML+Jinja task demonstrates the preferred, optimal method for installing multiple packages using the `ansible.builtin.yum` module. It passes the entire list of packages (stored in the `list_of_packages` variable) directly to the `name` parameter, which is more efficient than looping.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_7\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n   - name: Optimal yum\n     ansible.builtin.yum:\n       name: \"{{ list_of_packages }}\"\n       state: present\n```\n\n----------------------------------------\n\nTITLE: Importing a Role Statically in a Play - Ansible - YAML\nDESCRIPTION: Demonstrates static role inclusion in an Ansible playbook using 'import_role'. The play prints messages before and after importing the 'example' role, ensuring deterministic static task loading. Requires Ansible and the 'example' role to be present. Accepts no parameters. Output: all tasks from the 'example' role are executed between the 'debug' messages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  tasks:\n    - name: Print a message\n      ansible.builtin.debug:\n        msg: \"before we run our role\"\n\n    - name: Import the example role\n      import_role:\n        name: example\n\n    - name: Print a message\n      ansible.builtin.debug:\n        msg: \"after we ran our role\"\n```\n\n----------------------------------------\n\nTITLE: Loading OS-Specific Variables in Ansible Playbook (YAML)\nDESCRIPTION: This Ansible playbook demonstrates dynamically loading variable files using `vars_files`. It attempts to load a file named after the host's OS family (e.g., `vars/RedHat.yml`), obtained from `ansible_facts['os_family']`, and falls back to `vars/os_defaults.yml` if the OS-specific file isn't found. It then uses a variable (`apache`) defined in one of these files to ensure the Apache service is started via the `ansible.builtin.service` module. This requires Ansible facts to be gathered and the specified variable files to exist in the defined paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_30\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  remote_user: root\n  vars_files:\n    - \"vars/common.yml\"\n    - [ \"vars/{{ ansible_facts['os_family'] }}.yml\", \"vars/os_defaults.yml\" ]\n  tasks:\n  - name: Make sure apache is started\n    ansible.builtin.service:\n      name: '{{ apache }}'\n      state: started\n```\n\n----------------------------------------\n\nTITLE: Running a Command as Another User with become - Ansible YAML\nDESCRIPTION: This YAML task runs an arbitrary command ('somecommand') as the 'apache' user by enabling 'become' and setting 'become_user' to 'apache'. Requires Ansible, remote system access, and sufficient permissions for the operator. Key parameters: 'command' (the command to execute), 'become' (enables privilege escalation), and 'become_user' (specifies the target user). Input: any executable command. Output: command executes as the specified non-root user. Limitation: actual command and target user must exist, privileges must allow switching.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run a command as the apache user\\n  command: somecommand\\n  become: true\\n  become_user: apache\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Role Requirements File Format (YAML)\nDESCRIPTION: Provides an example `requirements.yml` file demonstrating various ways to specify roles for installation using `ansible-galaxy install -r`. It includes examples for installing from Galaxy (`namespace.role_name`), local Git repositories (`git+file://`), remote Git repositories (GitHub, BitBucket, GitLab via HTTPS or SSH), and web servers (tarballs), showcasing attributes like `src`, `name`, `version`, and `scm`. The file must end with `.yml` or `.yaml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n# from galaxy\n- name: yatesr.timezone\n\n# from locally cloned Git repository (git+file:// requires full paths)\n- src: git+file:///home/bennojoy/nginx\n\n# from GitHub\n- src: https://github.com/bennojoy/nginx\n\n# from GitHub, overriding the name and specifying a specific tag\n- name: nginx_role\n  src: https://github.com/bennojoy/nginx\n  version: main\n\n# from GitHub, specifying a specific commit hash\n- src: https://github.com/bennojoy/nginx\n  version: \"ee8aa41\"\n\n# from a webserver, where the role is packaged in a tar.gz\n- name: http-role-gz\n  src: https://some.webserver.example.com/files/main.tar.gz\n\n# from a webserver, where the role is packaged in a tar.bz2\n- name: http-role-bz2\n  src: https://some.webserver.example.com/files/main.tar.bz2\n\n# from a webserver, where the role is packaged in a tar.xz (Python 3.x only)\n- name: http-role-xz\n  src: https://some.webserver.example.com/files/main.tar.xz\n\n# from Bitbucket\n- src: git+https://bitbucket.org/willthames/git-ansible-galaxy\n  version: v1.4\n\n# from Bitbucket, alternative syntax and caveats\n- src: https://bitbucket.org/willthames/hg-ansible-galaxy\n  scm: hg\n\n# from GitLab or other git-based scm, using git+ssh\n- src: git@gitlab.company.com:mygroup/ansible-core.git\n  scm: git\n  version: \"0.1\"  # quoted, so YAML doesn't parse this as a floating-point value\n```\n\n----------------------------------------\n\nTITLE: Nested Loops via 'include_tasks' (Outer Loop)\nDESCRIPTION: This is the main playbook (`main.yml`) demonstrating nested loops using `include_tasks`. It defines an outer loop iterating over `[1, 2, 3]`. Crucially, `loop_control` with `loop_var: outer_item` renames the loop variable for this outer loop to `outer_item`, preventing it from being overwritten by the inner loop's default `item` variable when `inner.yml` is included.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_31\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# main.yml\n- include_tasks: inner.yml\n  loop:\n    - 1\n    - 2\n    - 3\n  loop_control:\n    loop_var: outer_item\n```\n\n----------------------------------------\n\nTITLE: Tagging Dynamic Role Includes - Ansible include_role Tagging (YAML)\nDESCRIPTION: Shows how to assign tags to the inclusion of a role at runtime using 'include_role'. This assigns the tag to the include itself, not to tasks inside the included role, allowing granular control over role execution. Parameters include 'tasks', 'include_role', 'name', and 'tags'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  tasks:\n    - name: Include the bar role\n      include_role:\n        name: bar\n      tags:\n        - foo\n\n```\n\n----------------------------------------\n\nTITLE: Defining Argument Specification for AnsibleModule (Python)\nDESCRIPTION: Demonstrates how to define the `argument_spec` dictionary when initializing the `AnsibleModule` helper class in an Ansible module. This example shows a nested structure with a top-level dictionary argument (`top_level`) containing another boolean argument (`second_level`) with a default value, illustrating how to specify types and options for module parameters. This structure is used by AnsibleModule for argument validation and parsing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmodule = AnsibleModule(argument_spec=dict(\n    top_level=dict(\n        type='dict',\n        options=dict(\n            second_level=dict(\n                default=True,\n                type='bool',\n            )\n        )\n    )\n))\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbooks in Check Mode with Console Commands\nDESCRIPTION: This snippet shows how to execute an Ansible playbook in check mode using a console command. Check mode simulates changes without actually applying them and is useful for validating playbooks' planned actions. Replace 'foo.yml' with your playbook filename; this command requires Ansible installed and configured.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_checkmode.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nansible-playbook foo.yml --check\n```\n\n----------------------------------------\n\nTITLE: Installing Kerberos Libraries (Bash)\nDESCRIPTION: This set of bash commands demonstrates how to install core Kerberos libraries and Python development headers using the native package manager for RHEL/Fedora, Debian/Ubuntu, Arch Linux, and FreeBSD. The commands should be run from a shell with root privileges or using sudo. The primary purpose is to ensure all Kerberos client utilities and libraries are present for later steps involving authentication setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo dnf install krb5-devel krb5-libs krb5-workstation python3-devel\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install krb5-user libkrb5-dev python3-dev\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo pacman -S krb5\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo pkg install heimdal\n```\n\n----------------------------------------\n\nTITLE: Parameter Type Change for `filter` in `setup` Module\nDESCRIPTION: The `filter` parameter in the `setup` module has changed its type from `string` to `list` to allow specifying multiple filters. While using a single `string` is still supported for backward compatibility, using a `list` is the standard way to apply multiple filters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_11\n\nLANGUAGE: YAML\nCODE:\n```\n# Old way (still works for single filter):\n# - name: Gather subset of facts (string)\n#   ansible.builtin.setup:\n#     filter: 'ansible_distribution*'\n\n# New way (list for one or more filters):\n- name: Gather multiple subsets of facts\n  ansible.builtin.setup:\n    filter:\n      - 'ansible_distribution*'\n      - 'ansible_processor*'\n```\n\n----------------------------------------\n\nTITLE: Complete Skeleton for Mocked Ansible Module Unit Test - Python\nDESCRIPTION: Presents an integrated test skeleton that defines custom set_module_args, mocked exit/fail exceptions, and mock implementations for get_bin_path. Also structures a unittest.TestCase with setUp cleanup logic and example tests for missing arguments and command checks. This complete setup forms a template for robust Ansible module unit tests, emulating Ansible runtime behavior and error handling through custom mocks and patches.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport json\\n\\nfrom units.compat import unittest\\nfrom units.compat.mock import patch\\nfrom ansible.module_utils import basic\\nfrom ansible.module_utils.common.text.converters import to_bytes\\nfrom ansible.modules.namespace import my_module\\n\\n\\ndef set_module_args(args):\\n    \"\"\"prepare arguments so that they will be picked up during module creation\"\"\"\\n    args = json.dumps({'ANSIBLE_MODULE_ARGS': args})\\n    basic._ANSIBLE_ARGS = to_bytes(args)\\n\\n\\nclass AnsibleExitJson(Exception):\\n    \"\"\"Exception class to be raised by module.exit_json and caught by the test case\"\"\"\\n    pass\\n\\n\\nclass AnsibleFailJson(Exception):\\n    \"\"\"Exception class to be raised by module.fail_json and caught by the test case\"\"\"\\n    pass\\n\\n\\ndef exit_json(*args, **kwargs):\\n    \"\"\"function to patch over exit_json; package return data into an exception\"\"\"\\n    if 'changed' not in kwargs:\\n        kwargs['changed'] = False\\n    raise AnsibleExitJson(kwargs)\\n\\n\\ndef fail_json(*args, **kwargs):\\n    \"\"\"function to patch over fail_json; package return data into an exception\"\"\"\\n    kwargs['failed'] = True\\n    raise AnsibleFailJson(kwargs)\\n\\n\\ndef get_bin_path(self, arg, required=False):\\n    \"\"\"Mock AnsibleModule.get_bin_path\"\"\"\\n    if arg.endswith('my_command'):\\n        return '/usr/bin/my_command'\\n    else:\\n        if required:\\n            fail_json(msg='%r not found !' % arg)\\n\\n\\nclass TestMyModule(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.mock_module_helper = patch.multiple(basic.AnsibleModule,\\n                                                 exit_json=exit_json,\\n                                                 fail_json=fail_json,\\n                                                 get_bin_path=get_bin_path)\\n        self.mock_module_helper.start()\\n        self.addCleanup(self.mock_module_helper.stop)\\n\\n    def test_module_fail_when_required_args_missing(self):\\n        with self.assertRaises(AnsibleFailJson):\\n            set_module_args({})\\n            my_module.main()\\n\\n\\n    def test_ensure_command_called(self):\\n        set_module_args({\\n            'param1': 10,\\n            'param2': 'test',\\n        })\n```\n\n----------------------------------------\n\nTITLE: Configuring Privilege Escalation for Network Devices with Ansible (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to configure privilege escalation using the 'become' mechanism for network automation in Ansible. It sets the connection type to 'ansible.netcommon.network_cli' and specifies the network OS and privilege escalation settings required for devices like Cisco IOS. These parameters should be defined in a group_vars file and require 'ansible.netcommon' and the appropriate network collection, with variables set according to the network device being managed. The configuration enables escalated access (similar to sudo) during playbook or ad hoc command execution, with required parameters being 'ansible_connection', 'ansible_network_os', 'ansible_become', and 'ansible_become_method'. The expected effect is that Ansible tasks will run in privileged ('enable') mode on supported network devices.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_differences.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: cisco.ios.ios\nansible_become: true\nansible_become_method: enable\n```\n\n----------------------------------------\n\nTITLE: Extracting Ansible Module Code using the Wrapper Script\nDESCRIPTION: This command uses the Python interpreter to run the Ansible wrapper script (e.g., 'AnsiballZ_ping.py') located in the temporary directory with the 'explode' argument. This extracts the actual module code, required module utilities, and arguments into a subdirectory named 'debug_dir', allowing for inspection and modification.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/debugging.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ python AnsiballZ_ping.py explode\nModule expanded into:\n/home/badger/.ansible/tmp/ansible-tmp-1461434734.35-235318071810595/debug_dir\n```\n\n----------------------------------------\n\nTITLE: Using --upgrade Flag for Collection Upgrades (Ansible CLI)\nDESCRIPTION: Highlights the `--upgrade` option for the `ansible-galaxy collection install` command, enabling the upgrade of Ansible collections from Galaxy servers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_28\n\nLANGUAGE: plaintext\nCODE:\n```\n--upgrade\n```\n\n----------------------------------------\n\nTITLE: Aborting Play on First Error using any_errors_fatal (Block Level) (YAML)\nDESCRIPTION: This Ansible task snippet shows using `any_errors_fatal: true` within a `block` construct. If any task inside this specific block (including tasks included via `include_tasks`) fails on any host, Ansible will stop executing tasks *within this block* for all hosts after completing the current batch for the failing task. However, execution *may* continue with tasks defined *after* the block, unless the failure triggered a play-level abort or other error handling stopped it. A `rescue` section could potentially handle the error within the block.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n - hosts: somehosts\n   tasks:\n     - block:\n         - include_tasks: mytasks.yml\n       any_errors_fatal: true\n```\n\n----------------------------------------\n\nTITLE: Raising Errors with to_native in Ansible Plugins (Python)\nDESCRIPTION: Demonstrates standardized exception handling in Ansible plugins by raising AnsibleError with a message converted using to_native. Ensures error strings are appropriately encoded across Python versions. Requires importing Ansible's to_native converter and raising errors with informative messages; input is an encountered Exception and output is a unicode error message.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.common.text.converters import to_native\n\ntry:\n    cause_an_exception()\nexcept Exception as e:\n    raise AnsibleError('Something happened, this was original exception: %s' % to_native(e))\n```\n\n----------------------------------------\n\nTITLE: Declarative Option Requirements with required_by in Ansible Modules (Python)\nDESCRIPTION: This code demonstrates using the `required_by` field in an Ansible module, mapping one option to other required options. If `force` is specified, `force_reason` must be defined; if `path` is specified, so must `mode`, `owner`, and `group`. This pattern enforces hierarchical validation. The input is a dictionary mapping of root options to dependent options. No special dependencies beyond AnsibleModule are required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nrequired_by={\n  'force': 'force_reason',\n  'path': ('mode', 'owner', 'group'),\n},\n```\n\n----------------------------------------\n\nTITLE: Conditional Reboot Based on CPU Temperature Fact (YAML)\nDESCRIPTION: This Ansible playbook snippet first uses `set_fact` to store the CPU temperature fact in a variable named `temperature`. The second task then uses the `shell` module to reboot the system, but only runs (`when`) if the stored `temperature`, converted to a float using the `float` filter, is greater than 90.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n    - name: Get the CPU temperature\n      set_fact:\n        temperature: \"{{ ansible_facts['cpu_temperature'] }}\"\n\n    - name: Restart the system if the temperature is too high\n      when: temperature | float > 90\n      shell: \"reboot\"\n```\n\n----------------------------------------\n\nTITLE: Downloading Multiple Collections with Requirements File - Ansible Galaxy - Bash\nDESCRIPTION: Illustrates how to use ansible-galaxy to download multiple collections and their dependencies by referencing a requirements.yml file. The command parses the requirements file to determine which collections to download. Ansible must be installed and the requirements file formatted as documented. The resulting downloads include all specified collections and dependencies bundled as tarballs with an auto-generated requirements.yml.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection download -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Group Variables for Cisco IOS Connection (YAML)\nDESCRIPTION: This YAML snippet shows an example configuration typically placed in `group_vars/ios.yml`. It defines essential parameters for Ansible to connect to Cisco IOS devices using the `network_cli` connection plugin. It specifies the network OS, user credentials (potentially using Ansible Vault for passwords), enables privilege escalation (`enable` mode), and includes an optional SSH argument for connecting via a bastion host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ios.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: cisco.ios.ios\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nansible_become_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Enabling Inventory Cache via Environment Variable in Shell\nDESCRIPTION: Enables the inventory caching feature in Ansible by setting the `ANSIBLE_INVENTORY_CACHE` environment variable to `True` in a shell. Inventory caching is disabled by default and must be explicitly enabled for an inventory cache plugin to function.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_INVENTORY_CACHE=True\n```\n\n----------------------------------------\n\nTITLE: Using Predefined AWS Module Default Group in Ansible Playbook YAML\nDESCRIPTION: This Ansible playbook shows how to use a predefined module default group (`group/aws`) to set common parameters for a wide range of AWS modules. In this example, it sets the default `region` to `us-west-2` for all modules within the `aws` group, which is then implicitly used by `aws_s3_bucket_info` and `ec2_ami_info` tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_7\n\nLANGUAGE: YAML\nCODE:\n```\n# example_play.yml\n- hosts: localhost\n  module_defaults:\n    group/aws:\n      region: us-west-2\n  tasks:\n  - name: Get info\n    aws_s3_bucket_info:\n\n  # now the region is shared between both info modules\n\n  - name: Get info\n    ec2_ami_info:\n      filters:\n        name: 'RHEL*7.5*'\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Registered Task Status (YAML)\nDESCRIPTION: These Ansible tasks demonstrate conditional execution based on the status of a preceding task. The first task runs `/bin/false` (which fails), registers the result in `result`, and uses `ignore_errors: true` to allow the play to continue. Subsequent tasks use `when` conditions with `result is failed`, `result is succeeded`, `result is skipped`, and `result is changed` to run commands only if the first task met that specific status.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Register a variable, ignore errors and continue\n    ansible.builtin.command: /bin/false\n    register: result\n    ignore_errors: true\n\n  - name: Run only if the task that registered the \"result\" variable fails\n    ansible.builtin.command: /bin/something\n    when: result is failed\n\n  - name: Run only if the task that registered the \"result\" variable succeeds\n    ansible.builtin.command: /bin/something_else\n    when: result is succeeded\n\n  - name: Run only if the task that registered the \"result\" variable is skipped\n    ansible.builtin.command: /bin/still/something_else\n    when: result is skipped\n\n  - name: Run only if the task that registered the \"result\" variable changed something.\n    ansible.builtin.command: /bin/still/something_else\n    when: result is changed\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Failure Percentage per Batch in Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet demonstrates the use of 'max_fail_percentage' and 'serial' to control rolling updates in an Ansible playbook. By setting 'max_fail_percentage: 30' alongside 'serial: 10', the play will abort if more than 3 hosts out of a 10-host batch fail, providing fine-grained control over playbook resilience during batch operations. Prerequisites include Ansible and an appropriate inventory defining the 'webservers' group. Key parameters are 'max_fail_percentage' to limit tolerable failures, and 'serial' to define batch sizes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- hosts: webservers\\n  max_fail_percentage: 30\\n  serial: 10\n```\n\n----------------------------------------\n\nTITLE: Conditional Task Execution/Failure Based on Variable Definition in Ansible\nDESCRIPTION: This snippet demonstrates using Jinja2's `defined` and `undefined` tests within `when` conditions. The first task runs an echo command only if the variable 'foo' is defined. The second task uses `ansible.builtin.fail` to stop the playbook execution if the variable 'bar' is not defined.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n    - name: Run the command if \"foo\" is defined\n      ansible.builtin.shell: echo \"I've got '{{ foo }}' and am not afraid to use it!\"\n      when: foo is defined\n\n    - name: Fail if \"bar\" is undefined\n      ansible.builtin.fail: msg=\"Bailing out. This play requires 'bar'\"\n      when: bar is undefined\n```\n\n----------------------------------------\n\nTITLE: Example Structure of Ansible Facts Data in JSON\nDESCRIPTION: This JSON snippet illustrates the typical structure and content of data returned as Ansible facts when the `setup` module is executed. It contains key-value pairs detailing various system attributes such as network interfaces (`ansible_default_ipv4`), OS details (`ansible_distribution`), hardware information (`ansible_devices`, `ansible_architecture`), date/time (`ansible_date_time`), and environment variables (`ansible_env`). Note that sensitive data like IP addresses is redacted in this example.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ansible_all_ipv4_addresses\": [\n        \"REDACTED IP ADDRESS\"\n    ],\n    \"ansible_all_ipv6_addresses\": [\n        \"REDACTED IPV6 ADDRESS\"\n    ],\n    \"ansible_apparmor\": {\n        \"status\": \"disabled\"\n    },\n    \"ansible_architecture\": \"x86_64\",\n    \"ansible_bios_date\": \"11/28/2013\",\n    \"ansible_bios_version\": \"4.1.5\",\n    \"ansible_cmdline\": {\n        \"BOOT_IMAGE\": \"/boot/vmlinuz-3.10.0-862.14.4.el7.x86_64\",\n        \"console\": \"ttyS0,115200\",\n        \"no_timer_check\": true,\n        \"nofb\": true,\n        \"nomodeset\": true,\n        \"ro\": true,\n        \"root\": \"LABEL=cloudimg-rootfs\",\n        \"vga\": \"normal\"\n    },\n    \"ansible_date_time\": {\n        \"date\": \"2018-10-25\",\n        \"day\": \"25\",\n        \"epoch\": \"1540469324\",\n        \"hour\": \"12\",\n        \"iso8601\": \"2018-10-25T12:08:44Z\",\n        \"iso8601_basic\": \"20181025T120844109754\",\n        \"iso8601_basic_short\": \"20181025T120844\",\n        \"iso8601_micro\": \"2018-10-25T12:08:44.109968Z\",\n        \"minute\": \"08\",\n        \"month\": \"10\",\n        \"second\": \"44\",\n        \"time\": \"12:08:44\",\n        \"tz\": \"UTC\",\n        \"tz_offset\": \"+0000\",\n        \"weekday\": \"Thursday\",\n        \"weekday_number\": \"4\",\n        \"weeknumber\": \"43\",\n        \"year\": \"2018\"\n    },\n    \"ansible_default_ipv4\": {\n        \"address\": \"REDACTED\",\n        \"alias\": \"eth0\",\n        \"broadcast\": \"REDACTED\",\n        \"gateway\": \"REDACTED\",\n        \"interface\": \"eth0\",\n        \"macaddress\": \"REDACTED\",\n        \"mtu\": 1500,\n        \"netmask\": \"255.255.255.0\",\n        \"network\": \"REDACTED\",\n        \"type\": \"ether\"\n    },\n    \"ansible_default_ipv6\": {},\n    \"ansible_device_links\": {\n        \"ids\": {},\n        \"labels\": {\n            \"xvda1\": [\n                \"cloudimg-rootfs\"\n            ],\n            \"xvdd\": [\n                \"config-2\"\n            ]\n        },\n        \"masters\": {},\n        \"uuids\": {\n            \"xvda1\": [\n                \"cac81d61-d0f8-4b47-84aa-b48798239164\"\n            ],\n            \"xvdd\": [\n                \"2018-10-25-12-05-57-00\"\n            ]\n        }\n    },\n    \"ansible_devices\": {\n        \"xvda\": {\n            \"holders\": [],\n            \"host\": \"\",\n            \"links\": {\n                \"ids\": [],\n                \"labels\": [],\n                \"masters\": [],\n                \"uuids\": []\n            },\n            \"model\": null,\n            \"partitions\": {\n                \"xvda1\": {\n                    \"holders\": [],\n                    \"links\": {\n                        \"ids\": [],\n                        \"labels\": [\n                            \"cloudimg-rootfs\"\n                        ],\n                        \"masters\": [],\n                        \"uuids\": [\n                            \"cac81d61-d0f8-4b47-84aa-b48798239164\"\n                        ]\n                    },\n                    \"sectors\": \"83883999\",\n                    \"sectorsize\": 512,\n                    \"size\": \"40.00 GB\",\n                    \"start\": \"2048\",\n                    \"uuid\": \"cac81d61-d0f8-4b47-84aa-b48798239164\"\n                }\n            },\n            \"removable\": \"0\",\n            \"rotational\": \"0\",\n            \"sas_address\": null,\n            \"sas_device_handle\": null,\n            \"scheduler_mode\": \"deadline\",\n            \"sectors\": \"83886080\",\n            \"sectorsize\": \"512\",\n            \"size\": \"40.00 GB\",\n            \"support_discard\": \"0\",\n            \"vendor\": null,\n            \"virtual\": 1\n        },\n        \"xvdd\": {\n            \"holders\": [],\n            \"host\": \"\",\n            \"links\": {\n                \"ids\": [],\n                \"labels\": [\n                    \"config-2\"\n                ],\n                \"masters\": [],\n                \"uuids\": [\n                    \"2018-10-25-12-05-57-00\"\n                ]\n            },\n            \"model\": null,\n            \"partitions\": {},\n            \"removable\": \"0\",\n            \"rotational\": \"0\",\n            \"sas_address\": null,\n            \"sas_device_handle\": null,\n            \"scheduler_mode\": \"deadline\",\n            \"sectors\": \"131072\",\n            \"sectorsize\": \"512\",\n            \"size\": \"64.00 MB\",\n            \"support_discard\": \"0\",\n            \"vendor\": null,\n            \"virtual\": 1\n        },\n        \"xvde\": {\n            \"holders\": [],\n            \"host\": \"\",\n            \"links\": {\n                \"ids\": [],\n                \"labels\": [],\n                \"masters\": [],\n                \"uuids\": []\n            },\n            \"model\": null,\n            \"partitions\": {\n                \"xvde1\": {\n                    \"holders\": [],\n                    \"links\": {\n                        \"ids\": [],\n                        \"labels\": [],\n                        \"masters\": [],\n                        \"uuids\": []\n                    },\n                    \"sectors\": \"167770112\",\n                    \"sectorsize\": 512,\n                    \"size\": \"80.00 GB\",\n                    \"start\": \"2048\",\n                    \"uuid\": null\n                }\n            },\n            \"removable\": \"0\",\n            \"rotational\": \"0\",\n            \"sas_address\": null,\n            \"sas_device_handle\": null,\n            \"scheduler_mode\": \"deadline\",\n            \"sectors\": \"167772160\",\n            \"sectorsize\": \"512\",\n            \"size\": \"80.00 GB\",\n            \"support_discard\": \"0\",\n            \"vendor\": null,\n            \"virtual\": 1\n        }\n    },\n    \"ansible_distribution\": \"CentOS\",\n    \"ansible_distribution_file_parsed\": true,\n    \"ansible_distribution_file_path\": \"/etc/redhat-release\",\n    \"ansible_distribution_file_variety\": \"RedHat\",\n    \"ansible_distribution_major_version\": \"7\",\n    \"ansible_distribution_release\": \"Core\",\n    \"ansible_distribution_version\": \"7.5.1804\",\n    \"ansible_dns\": {\n        \"nameservers\": [\n            \"127.0.0.1\"\n        ]\n    },\n    \"ansible_domain\": \"\",\n    \"ansible_effective_group_id\": 1000,\n    \"ansible_effective_user_id\": 1000,\n    \"ansible_env\": {\n        \"HOME\": \"/home/zuul\",\n        \"LANG\": \"en_US.UTF-8\",\n        \"LESSOPEN\": \"||/usr/bin/lesspipe.sh %s\",\n        \"LOGNAME\": \"zuul\",\n        \"MAIL\": \"/var/mail/zuul\",\n        \"PATH\": \"/usr/local/bin:/usr/bin\",\n        \"PWD\": \"/home/zuul\",\n        \"SELINUX_LEVEL_REQUESTED\": \"\",\n        \"SELINUX_ROLE_REQUESTED\": \"\",\n        \"SELINUX_USE_CURRENT_RANGE\": \"\",\n        \"SHELL\": \"/bin/bash\",\n        \"SHLVL\": \"2\",\n        \"SSH_CLIENT\": \"REDACTED 55672 22\",\n        \"SSH_CONNECTION\": \"REDACTED 55672 REDACTED 22\",\n        \"USER\": \"zuul\",\n        \"XDG_RUNTIME_DIR\": \"/run/user/1000\",\n        \"XDG_SESSION_ID\": \"1\",\n        \"_\": \"/usr/bin/python2\"\n    },\n    \"ansible_eth0\": {\n        \"active\": true,\n        \"device\": \"eth0\",\n        \"ipv4\": {\n            \"address\": \"REDACTED\",\n            \"broadcast\": \"REDACTED\",\n            \"netmask\": \"255.255.255.0\",\n            \"network\": \"REDACTED\"\n        },\n        \"ipv6\": [\n            {\n                \"address\": \"REDACTED\",\n                \"prefix\": \"64\",\n                \"scope\": \"link\"\n            }\n        ],\n        \"macaddress\": \"REDACTED\",\n        \"module\": \"xen_netfront\",\n        \"mtu\": 1500,\n        \"pciid\": \"vif-0\",\n        \"promisc\": false,\n        \"type\": \"ether\"\n    },\n    \"ansible_eth1\": {\n        \"active\": true,\n        \"device\": \"eth1\",\n        \"ipv4\": {\n            \"address\": \"REDACTED\",\n            \"broadcast\": \"REDACTED\",\n            \"netmask\": \"255.255.224.0\",\n            \"network\": \"REDACTED\"\n        },\n        \"ipv6\": [\n```\n\n----------------------------------------\n\nTITLE: Using Ansible Become with `new_credentials` to Access Network Share (YAML)\nDESCRIPTION: This Ansible task demonstrates copying a file from a network share (`\\\\server\\share\\data\\file.txt`) to a local path (`C:\\temp\\file.txt`) on a Windows host using `ansible.windows.win_copy`. It uses `become` with the `runas` method to impersonate `DOMAIN\\user`. The `become_flags` are set to `logon_type=new_credentials` and `logon_flags=netcredentials_only`, which allows the task to access the network resource using the specified `become_user` and `become_password` while running locally under the caller's security context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n- name: copy a file from a fileshare with custom credentials\n  ansible.windows.win_copy:\n    src: \\\\server\\share\\data\\file.txt\n    dest: C:\\temp\\file.txt\n    remote_src: true\n  vars:\n    ansible_become: true\n    ansible_become_method: runas\n    ansible_become_user: DOMAIN\\user\n    ansible_become_password: Password01\n    ansible_become_flags: logon_type=new_credentials logon_flags=netcredentials_only\n```\n\n----------------------------------------\n\nTITLE: Mixing Integer and Percentage Batch Sizes with Serial (YAML)\nDESCRIPTION: Demonstrates assigning a mix of integer and percentage values to the 'serial' keyword ([1,5,\"20%\"]). Ansible processes hosts in the order of these batch sizes: first 1, then 5, then groups gathering 20% of remaining hosts per pass. Designed for flexible staged or rolling updates; no dependencies required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: test play\\n  hosts: webservers\\n  serial:\\n    - 1\\n    - 5\\n    - \"20%\"\n```\n\n----------------------------------------\n\nTITLE: Handling Concurrency with run_once and Loop in Ansible Delegated Tasks (YAML)\nDESCRIPTION: Addresses Ansible concurrency issues when delegating a task involving a shared file. Uses run_once: true to ensure only one execution on the delegated host and loops over ansible_play_hosts_all, providing each iteration's context as the file is lineinfile-modified. Dependencies: lineinfile module, host inventory. Inputs: loop variable and options to lineinfile. Output: Changes applied collectively, avoiding race conditions among parallel task forks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"handle concurrency with a loop on the hosts with `run_once: true`\"\n  lineinfile: \"<options here>\"\n  run_once: true\n  loop: '{{ ansible_play_hosts_all }}'\n```\n\n----------------------------------------\n\nTITLE: Non-Optimal Package Installation using `loop` with `yum` in Ansible\nDESCRIPTION: This YAML+Jinja task shows a less efficient way to install multiple packages using `ansible.builtin.yum`. It iterates over the `list_of_packages` variable using `loop`, executing the `yum` module once for each package. This is slower and can cause issues compared to passing the list directly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_8\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n   - name: Non-optimal yum, slower and may cause issues with interdependencies\n     ansible.builtin.yum:\n       name: \"{{ item }}\"\n       state: present\n     loop: \"{{ list_of_packages }}\"\n```\n\n----------------------------------------\n\nTITLE: Applying a Condition to an Entire Role in Ansible (`roles` keyword)\nDESCRIPTION: This playbook snippet demonstrates applying a `when` condition directly to a role listed under the `roles:` keyword. The condition `when: ansible_facts['os_family'] == 'Debian'` ensures that all tasks within the `debian_stock_config` role will only execute on hosts where the OS family fact is 'Debian'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_28\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: webservers\n  roles:\n     - role: debian_stock_config\n       when: ansible_facts['os_family'] == 'Debian'\n```\n\n----------------------------------------\n\nTITLE: Enabling Servers in HAProxy and Re-enabling Nagios Alerts using Ansible YAML Playbook\nDESCRIPTION: This post_tasks snippet demonstrates reversing prior changes after a rolling update. The first task re-enables the server in HAProxy using a shell command with socat, looping and delegating to all load balancer servers. The second task re-enables monitoring alerts in Nagios by calling the nagios Ansible module with defined parameters, delegating to all entries in the monitoring group. Required dependencies include the Nagios Ansible module, proper inventory grouping, access to the HAProxy stats socket, and valid Nagios configuration. Inputs are handled via variable interpolation for inventory_hostname and group variables, and outputs depend on the successful change of server and alert states.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\npost_tasks:\n- name: Enable the server in haproxy\n  shell: echo \"enable server myapplb/{{ inventory_hostname }}\" | socat stdio /var/lib/haproxy/stats\n  delegate_to: \"{{ item }}\"\n  loop: \"{{ groups.lbservers }}\"\n\n- name: re-enable nagios alerts\n  nagios:\n    action: enable_alerts\n    host: \"{{ inventory_hostname }}\"\n    services: webserver\n  delegate_to: \"{{ item }}\"\n  loop: \"{{ groups.monitoring }}\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Mathematical Comparison of Facts (YAML)\nDESCRIPTION: This Ansible task runs a shell command using `ansible.builtin.shell`. The `when` condition checks if the OS family is \"RedHat\" and if the LSB major release number is 6 or greater. It uses the `int` filter to convert the `ansible_facts['lsb']['major_release']` fact (which might be a string) to an integer for the mathematical comparison.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - ansible.builtin.shell: echo \"only on Red Hat 6, derivatives, and later\"\n    when: ansible_facts['os_family'] == \"RedHat\" and ansible_facts['lsb']['major_release'] | int >= 6\n```\n\n----------------------------------------\n\nTITLE: Configuring Common Ansible Connection Variables\nDESCRIPTION: These inventory variables control common connection parameters: `ansible_host` specifies the target hostname or IP if different from the inventory name, `ansible_port` sets the connection port (defaulting to 22 for SSH), and `ansible_user` defines the login username (defaulting to the current user).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nansible_host\n```\n\nLANGUAGE: yaml\nCODE:\n```\nansible_port\n```\n\nLANGUAGE: yaml\nCODE:\n```\nansible_user\n```\n\n----------------------------------------\n\nTITLE: Looping Through Host Groups in Ansible Jinja2 Templates (Jinja)\nDESCRIPTION: This snippet, also from `roles/common/templates/iptables.j2`, demonstrates looping in Jinja2. It iterates through all hosts defined in the `monitoring` group. For each host, it accesses its default IPv4 address using `hostvars[host].ansible_default_ipv4.address` and adds an iptables rule allowing TCP traffic from that monitoring host to port 5666 (commonly used for Nagios NRPE).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_6\n\nLANGUAGE: jinja\nCODE:\n```\n{% for host in groups['monitoring'] %}\n-A INPUT -p tcp -s {{ hostvars[host].ansible_default_ipv4.address }} --dport 5666 -j ACCEPT\n{% endfor %}\n\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible with Verbose Output and Keeping Remote Files\nDESCRIPTION: This command executes the Ansible 'ping' module against 'localhost'. The environment variable 'ANSIBLE_KEEP_REMOTE_FILES=1' prevents Ansible from deleting temporary files on the target host after execution. The '-vvv' option increases verbosity, displaying detailed execution steps, including the path to the temporary module file, which is essential for debugging.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/debugging.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ANSIBLE_KEEP_REMOTE_FILES=1 ansible localhost -m ping -a 'data=debugging_session' -vvv\n<127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: badger\n<127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p \"` echo $HOME/.ansible/tmp/ansible-tmp-1461434734.35-235318071810595 `\" && echo \"` echo $HOME/.ansible/tmp/ansible-tmp-1461434734.35-235318071810595 `\" )'\n<127.0.0.1> PUT /var/tmp/tmpjdbJ1w TO /home/badger/.ansible/tmp/ansible-tmp-1461434734.35-235318071810595/AnsiballZ_ping.py\n<127.0.0.1> EXEC /bin/sh -c 'LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461434734.35-235318071810595/AnsiballZ_ping.py && sleep 0'\nlocalhost | SUCCESS => {\n    \"changed\": false,\n    \"invocation\": {\n        \"module_args\": {\n            \"data\": \"debugging_session\"\n        },\n        \"module_name\": \"ping\"\n    },\n    \"ping\": \"debugging_session\"\n}\n```\n\n----------------------------------------\n\nTITLE: Role-Based NTP Task Configuration - Ansible Tasks YAML\nDESCRIPTION: A sample role tasks file for ensuring NTP is installed, configured, and running. Uses 'yum' and 'ansible.builtin.service' modules, and Ansible's notify/handlers mechanism. Expects appropriate templates (ntp.conf.j2), tags for selective execution ('ntp'), and a handler named 'restart ntpd' (see next snippet). Typical inputs are hosts with correct group_vars, outputs are idempotent NTP configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: roles/common/tasks/main.yml\\n\\n- name: be sure ntp is installed\\n  yum:\\n    name: ntp\\n    state: present\\n  tags: ntp\\n\\n- name: be sure ntp is configured\\n  template:\\n    src: ntp.conf.j2\\n    dest: /etc/ntp.conf\\n  notify:\\n    - restart ntpd\\n  tags: ntp\\n\\n- name: be sure ntpd is running and enabled\\n  ansible.builtin.service:\\n    name: ntpd\\n    state: started\\n    enabled: true\\n  tags: ntp\n```\n\n----------------------------------------\n\nTITLE: Accessing Current Item Result Within a Loop in Ansible\nDESCRIPTION: This YAML+Jinja task demonstrates that when using `register` within a `loop`, the registered variable (`echo` in this case) holds the result of the *current* item's execution during that specific iteration. The `changed_when` condition checks the `stdout` of the current iteration's shell command.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_14\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - name: Place the result of the current item in the variable\n      ansible.builtin.shell: echo \"{{ item }}\"\n      loop:\n        - one\n        - two\n      register: echo\n      changed_when: echo.stdout != \"one\"\n```\n\n----------------------------------------\n\nTITLE: Passing Variables and Tags to Ansible Roles at Play Level (YAML)\nDESCRIPTION: Illustrates passing specific variables (`vars`) and applying tags (`tags`) to roles when defined using the `roles` keyword in a playbook. Tags applied here cascade to all tasks within that role instance.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - common\n    - role: foo_app_instance\n      vars:\n        dir: '/opt/a'\n        app_port: 5000\n      tags: typeA\n    - role: foo_app_instance\n      vars:\n        dir: '/opt/b'\n        app_port: 5001\n      tags: typeB\n```\n\n----------------------------------------\n\nTITLE: Defining the Standard Ansible Role Directory Structure\nDESCRIPTION: Illustrates the standard directory layout for an Ansible role. It shows common directories like `tasks` (containing `main.yml`), `handlers` (`main.yml`), `templates` (using `.j2` extension), `files`, `vars` (`main.yml`), `defaults` (`main.yml`), and `meta` (`main.yml`). It also includes optional directories for custom `library` modules, `module_utils`, and `lookup_plugins`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/role_directory.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nroles/\n    common/               # this hierarchy represents a \"role\"\n        tasks/            #\n            main.yml      #  <-- tasks file can include smaller files if warranted\n        handlers/         #\n            main.yml      #  <-- handlers file\n        templates/        #  <-- files for use with the template resource\n            ntp.conf.j2   #  <------- templates end in .j2\n        files/            #\n            bar.txt       #  <-- files for use with the copy resource\n            foo.sh        #  <-- script files for use with the script resource\n        vars/             #\n            main.yml      #  <-- variables associated with this role\n        defaults/         #\n            main.yml      #  <-- default lower priority variables for this role\n        meta/             #\n            main.yml      #  <-- role dependencies\n        library/          # roles can also include custom modules\n        module_utils/     # roles can also include custom module_utils\n        lookup_plugins/   # or other types of plugins, like lookup in this case\n\n    webtier/              # same kind of structure as \"common\" was above, done for the webtier role\n    monitoring/           # \"\"\n    fooapp/               # \"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Role Dependencies in meta/main.yml (YAML)\nDESCRIPTION: This YAML snippet shows an example `meta/main.yml` file for a role. It defines a dependency on another role (`geerlingguy.java`) using the simple `namespace.role_name` format under the `dependencies` key. The `galaxy_info` section provides metadata for Ansible Galaxy.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n---\ndependencies:\n  - geerlingguy.java\n\ngalaxy_info:\n  author: geerlingguy\n  description: Elasticsearch for Linux.\n  company: \"Midwestern Mac, LLC\"\n  license: \"license (BSD, MIT)\"\n  min_ansible_version: 2.4\n  galaxy_tags:\n    - web\n    - system\n    - monitoring\n    - logging\n    - lucene\n    - elk\n    - elasticsearch\n```\n\n----------------------------------------\n\nTITLE: Assigning Hosts to Multiple Groups (YAML)\nDESCRIPTION: Demonstrates a YAML inventory structure where hosts belong to multiple groups. This allows categorization based on different criteria like function (`webservers`, `dbservers`), location (`east`, `west`), and environment (`prod`, `test`). For example, `one.example.com` is part of `dbservers`, `east`, and `prod`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nungrouped:\n  hosts:\n    mail.example.com:\nwebservers:\n  hosts:\n    foo.example.com:\n    bar.example.com:\ndbservers:\n  hosts:\n    one.example.com:\n    two.example.com:\n    three.example.com:\neast:\n  hosts:\n    foo.example.com:\n    one.example.com:\n    two.example.com:\nwest:\n  hosts:\n    bar.example.com:\n    three.example.com:\nprod:\n  hosts:\n    foo.example.com:\n    one.example.com:\n    two.example.com:\ntest:\n  hosts:\n    bar.example.com:\n    three.example.com:\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: changed\nDESCRIPTION: Illustrates the `changed` boolean return value. It indicates whether the Ansible task made any modifications to the target or delegated host (`true` if changes were made, `false` otherwise).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n\"changed\": true\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Collections from Git via Command Line (Bash)\nDESCRIPTION: Demonstrates using `ansible-galaxy collection install` to install collections from different types of Git repositories. Includes examples for public HTTPS URLs with a specific branch (`devel`), private repositories using SSH authentication (`git@github.com`), and local file system repositories (`git+file://`). Requires `ansible-galaxy` and a Git repository containing a `galaxy.yml` or `MANIFEST.json` file. The commit-ish syntax (e.g., `,devel`) allows specifying branches, tags, or commits.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_git_repo.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install a collection in a repository using the latest commit on the branch 'devel'\nansible-galaxy collection install git+https://github.com/organization/repo_name.git,devel\n\n# Install a collection from a private GitHub repository\nansible-galaxy collection install git@github.com:organization/repo_name.git\n\n# Install a collection from a local git repository\nansible-galaxy collection install git+file:///home/user/path/to/repo_name.git\n```\n\n----------------------------------------\n\nTITLE: Testing Task Results Using Ansible Result Tests - YAML\nDESCRIPTION: This set of examples demonstrates how to use Ansible's result test expressions—such as failed, changed, succeeded, success, and skipped—to conditionally act on registered task results. Dependencies are a registered variable from a previous task and standard Ansible modules. Expected inputs are result objects, and outputs are debug messages depending on the result state. These snippets highlight robust error handling and conditional logic in playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n  - shell: /usr/bin/foo\n    register: result\n    ignore_errors: True\n\n  - debug:\n      msg: \"it failed\"\n    when: result is failed\n\n  # in most cases you'll want a handler, but if you want to do something right now, this is nice\n  - debug:\n      msg: \"it changed\"\n    when: result is changed\n\n  - debug:\n      msg: \"it succeeded in Ansible >= 2.1\"\n    when: result is succeeded\n\n  - debug:\n      msg: \"it succeeded\"\n    when: result is success\n\n  - debug:\n      msg: \"it was skipped\"\n    when: result is skipped\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Collections Manually using Bash\nDESCRIPTION: This command uses the `ansible-galaxy` utility to install an Ansible collection specified by `<name-of-collection>`. This is useful for installing collections that have been removed from the main Ansible distribution package or are not included by default. Replace `<name-of-collection>` with the actual name of the desired collection (e.g., `frr.frr`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_11.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install <name-of-collection>\n```\n\n----------------------------------------\n\nTITLE: Defining Ansible Group Variables in YAML\nDESCRIPTION: Example of a group variable file (`/etc/ansible/group_vars/raleigh`) in YAML format. It defines `ntp_server` and `database_server` variables specific to the 'raleigh' group, which will be available to all hosts within that group. This demonstrates a common way to assign configuration parameters to multiple hosts based on group membership.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_24\n\nLANGUAGE: yaml\nCODE:\n```\n---\nntp_server: acme.example.org\ndatabase_server: storage.example.org\n```\n\n----------------------------------------\n\nTITLE: Illustrating Implicit Localhost Inventory Definition in Ansible (YAML)\nDESCRIPTION: This snippet shows the equivalent inventory structure that Ansible uses internally when creating an implicit 'localhost'. It defines 'localhost' with specific variables: `ansible_connection: local` ensures tasks run locally, and `ansible_python_interpreter: \"{{ansible_playbook_python}}\"` ensures the same Python interpreter running the playbook is used for the local tasks. This configuration is automatically applied when `delegate_to: localhost` or `local_action` is used without an explicit 'localhost' in inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory/implicit_localhost.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# ...\n\nhosts:\n  localhost:\n   vars:\n     ansible_connection: local\n     ansible_python_interpreter: \"{{ansible_playbook_python}}\"\n```\n\n----------------------------------------\n\nTITLE: Checking Current User Username on Windows with Ansible - YAML\nDESCRIPTION: This Ansible playbook task checks the current user's username and related authentication details on a Windows host. It uses the 'ansible.windows.win_whoami' module with privilege escalation (become: true). No input parameters are required, but Ansible connectivity to Windows and elevation capability is assumed. The result provides detailed user information for auditing or debugging privilege context. Ensure the target host is configured for WinRM access.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Check my username\\n  ansible.windows.win_whoami:\\n  become: true\n```\n\n----------------------------------------\n\nTITLE: Defining Playbook Variables in a Play - Ansible - YAML\nDESCRIPTION: Demonstrates setting play-scope variables via the vars block in a play. In this example, http_port is defined and only visible to tasks executed within this play. Inputs are host groups and variable dictionaries; outputs are variable availability for the play's tasks. No special dependencies or constraints, but variable scope is limited to the current play.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: webservers\n  vars:\n    http_port: 80\n```\n\n----------------------------------------\n\nTITLE: Ansible Output When File Not Found (Warning Level)\nDESCRIPTION: This snippet delivers the Ansible output for a missing file where 'errors=warn' is configured. Two warnings are issued: one for the missing file location, another for the unhandled exception in the lookup plugin. The playbook keeps running, demonstrating how warning mode works when the file is not found, with the message output left empty.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_6\n\nLANGUAGE: ansible-output\nCODE:\n```\n    [WARNING]: Unable to find '/nosuchfile' in expected paths (use -vvvvv to see paths)\n\n    [WARNING]: An unhandled exception occurred while running the lookup plugin 'file'. Error was a <class 'ansible.errors.AnsibleError'>, original message: could not locate file in lookup: /nosuchfile\n\n    ok: [localhost] => {\n        \"msg\": \"\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Forcing Task 'Changed' Status to False (YAML)\nDESCRIPTION: This Ansible task demonstrates setting `changed_when: False`. Regardless of the command's output or return code, this task will never be reported as having made a change ('changed' status) in Ansible's output or statistics, and it will not trigger any notified handlers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n  - name: This will never report 'changed' status\n    ansible.builtin.shell: wall 'beep'\n    changed_when: False\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of Variables in Handler Names in Ansible (YAML+Jinja)\nDESCRIPTION: Provides an example of a potentially problematic pattern: templating variables directly in handler names. Using variables in handler names can fail if variable values are unavailable at handler parsing time, causing playbook failures or unexpected handler behavior. Advises against this approach in Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nhandlers:\\n# This handler name may cause your play to fail!\\n- name: Restart \"{{ web_service_name }}\"\\n\n```\n\n----------------------------------------\n\nTITLE: Listing Ansible Plugins and Their Source Files with ansible-doc (Bash)\nDESCRIPTION: Uses the `ansible-doc -F` command to list all available Ansible plugins (modules, lookups, filters, etc.) along with the path to their source file. This is useful for discovering available functionality and its location.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nansible-doc -F\n#...\n```\n\n----------------------------------------\n\nTITLE: Skipping an Entire Loop Task if Loop Variable (Dict) is Undefined in Ansible\nDESCRIPTION: Similar to the list example, this task demonstrates skipping a loop over a dictionary (`mydict`) if it's undefined. It uses the `|default({})` filter to provide an empty dictionary and the `query('dict', ...)` lookup to iterate over the dictionary's keys and values safely. The task only runs for items where the value is greater than 5.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n    - name: The same as above using a dict\n      ansible.builtin.command: echo {{ item.key }}\n      loop: \"{{ query('dict', mydict|default({})) }}\"\n      when: item.value > 5\n```\n\n----------------------------------------\n\nTITLE: Listing Tags and Tasks in Ansible Playbooks - Bash\nDESCRIPTION: These Bash commands demonstrate how to preview tags and task lists in an Ansible playbook using '--list-tags' to show all available tags, and '--list-tasks' along with '--tags' to show which tasks will run without executing them. Useful for debugging, auditing playbooks, or verifying playbook structure. Requires Ansible installed and a valid 'example.yml'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml --list-tags\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml --tags \\\"configuration,packages\\\" --list-tasks\n```\n\n----------------------------------------\n\nTITLE: Organizing Ansible Group Variables in Directories (Bash)\nDESCRIPTION: Shows how group variables can be split into multiple files within a directory named after the group (`/etc/ansible/group_vars/raleigh/`). Ansible loads all files (`db_settings`, `cluster_settings`) within such directories lexicographically, merging the variables. This is useful for organizing large numbers of variables or using Ansible Vault on specific files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\n/etc/ansible/group_vars/raleigh/db_settings\n/etc/ansible/group_vars/raleigh/cluster_settings\n```\n\n----------------------------------------\n\nTITLE: Waiting for Arista EOS Interface Status using eos_command (YAML)\nDESCRIPTION: This Ansible task uses the `arista.eos.eos_command` module to execute `show interface Ethernet4 | json` on an Arista EOS device. It employs the `wait_for` conditional to repeatedly check the command output until the interface status (`result[0].interfaces.Ethernet4.interfaceStatus`) equals `connected`. The task retries every second for up to 10 times by default if the condition is not met.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_working_with_command_output.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: wait for interface to be admin enabled\n  arista.eos.eos_command:\n      commands:\n          - show interface Ethernet4 | json\n      wait_for:\n          - \"result[0].interfaces.Ethernet4.interfaceStatus eq connected\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible EXOS-API Connection Variables (YAML)\nDESCRIPTION: Defines Ansible group variables in `group_vars/exos.yml` for connecting to EXOS devices using the httpapi (HTTP/S) connection. It specifies the connection type (`ansible.netcommon.httpapi`), network OS (`community.network.exos`), user credentials (`ansible_user`, `ansible_password` using vault), and optional `proxy_env` settings for routing API calls through a web proxy. Remove `proxy_env` if not using a proxy.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_exos.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.httpapi\nansible_network_os: community.network.exos\nansible_user: myuser\nansible_password: !vault...\nproxy_env:\n  http_proxy: http://proxy.example.com:8080\n```\n\n----------------------------------------\n\nTITLE: Ensuring Handler Execution on Error with Ansible Blocks and flush_handlers in YAML\nDESCRIPTION: This Ansible snippet shows how to ensure handlers are run even when errors occur within a block. By placing 'meta: flush_handlers' inside the 'rescue' section, any handlers notified by tasks in the main 'block' (before the failure) will be executed during the error handling phase.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_blocks.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Attempt and graceful roll back demo\n    block:\n      - name: Print a message\n        ansible.builtin.debug:\n          msg: 'I execute normally'\n        changed_when: true\n        notify: Run me even after an error\n\n      - name: Force a failure\n        ansible.builtin.command: /bin/false\n    rescue:\n      - name: Make sure all handlers run\n        meta: flush_handlers\nhandlers:\n   - name: Run me even after an error\n     ansible.builtin.debug:\n       msg: 'This handler runs even on error'\n```\n\n----------------------------------------\n\nTITLE: Using Long-Form Commands with cisco.ios.ios_config in YAML\nDESCRIPTION: This Ansible playbook snippet demonstrates the recommended practice of using full, non-abbreviated commands (e.g., `shutdown` instead of `shut`) within the `lines` parameter of `*_config` modules like `cisco.ios.ios_config`. Using the long-form command prevents the module from incorrectly reporting `changed=true` when comparing the provided command with the device's configuration, which typically stores the expanded form. The task ensures the `shutdown` command is present under the `interface GigabitEthernet1/0/11` configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/faq.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: all\n  gather_facts: no\n  tasks:\n    - cisco.ios.ios_config:\n        lines:\n          - shutdown\n        parents: interface GigabitEthernet1/0/11\n```\n\n----------------------------------------\n\nTITLE: Using the Loop Keyword in Ansible Tasks (YAML)\nDESCRIPTION: Highlights the `loop` keyword in Ansible. This construct allows a task to be repeated for each item in a provided list, enabling iteration over data sets.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\nloop\n```\n\n----------------------------------------\n\nTITLE: Executing 'show version' Command via CLI on EXOS (YAML)\nDESCRIPTION: An Ansible task example demonstrating the use of the `community.network.exos_command` module to execute the `show version` command on an EXOS device configured for CLI (SSH) connection. The task runs conditionally based on the `ansible_network_os` variable being set to `community.network.exos`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_exos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve EXOS OS version\n  community.network.exos_command:\n    commands: show version\n  when: ansible_network_os == 'community.network.exos'\n```\n\n----------------------------------------\n\nTITLE: Defining Unsafe Strings in Ansible Variables (YAML)\nDESCRIPTION: Demonstrates how to mark a simple string variable as `!unsafe` in Ansible YAML to prevent it from being templated by the Jinja2 engine. This is particularly useful for values like passwords or JSON arguments that contain special characters (`%`, `{`, `}`) which might otherwise be misinterpreted as template syntax.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_advanced_syntax.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nmypassword: !unsafe 234%234{435lkj{{lkjsdf\n```\n\n----------------------------------------\n\nTITLE: Example Debugger Session Resolving Variable Error (Ansible Output)\nDESCRIPTION: This output shows an interactive Ansible debugger session. The user identifies an undefined variable error (`p result._result`), inspects the task arguments (`p task.args`), corrects the argument to use the correct variable (`task.args['data'] = '{{ var1 }}'`), verifies the change (`p task.args`), and retries the task successfully (`redo`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_8\n\nLANGUAGE: ansible-output\nCODE:\n```\nPLAY ***************************************************************************\n\nTASK [wrong variable] **********************************************************\nfatal: [192.0.2.10]: FAILED! => {\"failed\": true, \"msg\": \"ERROR! 'wrong_var' is undefined\"}\nDebugger invoked\n[192.0.2.10] TASK: wrong variable (debug)> p result._result\n{'failed': True,\n 'msg': 'The task includes an option with an undefined variable. The error '\n        \"was: 'wrong_var' is undefined\\n\"\n        '\\n'\n        'The error appears to have been in '\n        \"'playbooks/debugger.yml': line 7, \"\n        'column 7, but may\\n'\n        'be elsewhere in the file depending on the exact syntax problem.\\n'\n        '\\n'\n        'The offending line appears to be:\\n'\n        '\\n'\n        '  tasks:\\n'\n        '    - name: wrong variable\\n'\n        '      ^ here\\n'}\n[192.0.2.10] TASK: wrong variable (debug)> p task.args\n{u'data': u'{{ wrong_var }}'}\n[192.0.2.10] TASK: wrong variable (debug)> task.args['data'] = '{{ var1 }}'\n[192.0.2.10] TASK: wrong variable (debug)> p task.args\n{u'data': '{{ var1 }}'}\n[192.0.2.10] TASK: wrong variable (debug)> redo\nok: [192.0.2.10]\n\nPLAY RECAP *********************************************************************\n192.0.2.10               : ok=1    changed=0    unreachable=0    failed=0\n```\n\n----------------------------------------\n\nTITLE: Quoting Version Numbers Resembling Floats in YAML\nDESCRIPTION: Shows the necessity of quoting strings that look like floating-point numbers, such as '1.0', when you want them to be treated as literal strings (e.g., for version numbers in requirements files). Without quotes, YAML will convert them to numeric types.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"1.0\"\n```\n\n----------------------------------------\n\nTITLE: Configuring VyOS CLI Connection with Ansible - YAML\nDESCRIPTION: This YAML snippet demonstrates how to configure Ansible group variables to connect to VyOS devices using the ansible.netcommon.network_cli connection. It specifies the network OS, user credentials, and SSH proxy command for access via a bastion host. Dependencies include the vyos.vyos Ansible collection and enabled network_cli connection plugin. Required fields are ansible_user and either ansible_password or an SSH key, and ansible_network_os must match the VyOS plugin. Adjustments can be made to ansible_ssh_common_args based on whether a jump/bastion host is used.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_vyos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: vyos.vyos.vyos\\nansible_user: myuser\\nansible_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Dynamically Including Specific Task File from Ansible Role (YAML)\nDESCRIPTION: Illustrates using `include_role` with the `tasks_from` parameter to execute a specific task file (`apt.yml`) from a role, bypassing the default `tasks/main.yml`. The `when` condition ensures this only runs on Debian-based systems.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: include apt tasks\n  include_role:\n      name: package_manager_bootstrap\n      tasks_from: apt.yml\n  when: ansible_facts['os_family'] == 'Debian'\n```\n\n----------------------------------------\n\nTITLE: Targeting Specific Integration Tests in Ubuntu Container via ansible-test in Shell\nDESCRIPTION: This shell command targets the 'ping' integration test to be run within a Ubuntu 18.04 Docker container using ansible-test. It is a variant of other targeting commands but ensures containerization for consistent results across environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration ping --docker ubuntu1804\n```\n\n----------------------------------------\n\nTITLE: Merging Variables with merge_variables Lookup - Ansible - YAML\nDESCRIPTION: Shows use of the community.general.merge_variables lookup plugin to dynamically merge variables matching a pattern or suffix. This requires the community.general collection. The lookup function accepts a pattern string and pattern_type argument, returning a merged variable depending on matches. Inputs are prefix/suffix or regex; output is a merged variable. Proper patterns and plugin installation are expected.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nmerged_variable: \"{{ lookup('community.general.merge_variables', '__my_pattern', pattern_type='suffix') }}\"\n```\n\n----------------------------------------\n\nTITLE: Delegating Tasks to the Control Node (YAML)\nDESCRIPTION: Illustrates the `delegate_to: localhost` directive within an Ansible task. This causes the specific task to be executed on the Ansible control node itself, rather than on the remote target host specified in the play's `hosts` line.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\ndelegate_to: localhost\n```\n\n----------------------------------------\n\nTITLE: Configuring Hostname and DNS on Cisco IOS using Ansible Playbook (YAML)\nDESCRIPTION: An Ansible playbook designed to configure Cisco routers defined in the 'routers' host group. It uses the `ansible.netcommon.network_cli` connection plugin and disables fact gathering. The playbook contains two tasks using the `cisco.ios.ios_config` module: one sets the device hostname based on `inventory_hostname`, and the other configures DNS servers using the `dns` variable defined within the playbook's `vars` section.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: configure cisco routers\n  hosts: routers\n  connection: ansible.netcommon.network_cli\n  gather_facts: no\n  vars:\n    dns: \"8.8.8.8 8.8.4.4\"\n\n  tasks:\n   - name: configure hostname\n     cisco.ios.ios_config:\n       lines: hostname {{ inventory_hostname }}\n\n   - name: configure DNS\n     cisco.ios.ios_config:\n       lines: ip name-server {{dns}}\n```\n\n----------------------------------------\n\nTITLE: Using `with_fileglob` for Cleaner File Iteration in Ansible\nDESCRIPTION: This YAML snippet demonstrates the preferred way to iterate over files matching a pattern using `with_fileglob`. It is considered cleaner and more readable than using `loop` with the `fileglob` lookup plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n.. code-block:: yaml\n\n  with_fileglob: '*.txt'\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Imports - Ansible import_role and import_tasks (YAML)\nDESCRIPTION: Demonstrates how to apply tags to statically imported roles and tasks using 'import_role' and 'import_tasks'. All tasks brought in by these import statements will inherit the specified tags. Suitable for broad application of tags to pre-defined task groups. Involves 'import_role', 'import_tasks', and 'tags' in task definitions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  tasks:\n    - name: Import the foo role\n      import_role:\n        name: foo\n      tags:\n        - bar\n        - baz\n\n    - name: Import tasks from foo.yml\n      import_tasks: foo.yml\n      tags: [ web, foo ]\n\n```\n\n----------------------------------------\n\nTITLE: Gathering Device Facts and Displaying Information Using Ansible Playbook (YAML format)\nDESCRIPTION: This YAML playbook demonstrates connecting to a group of network switches to gather system facts using vendor-specific facts modules and conditionals based on the ansible_network_os variable. It then displays and writes out selected device facts. Dependencies: ansible >= 2.10, modules (arista.eos.eos_facts, cisco.ios.ios_facts, vyos.vyos.vyos_facts), inventory with correct groups, and access credentials. Inputs are hosts defined in the 'switches' group; key parameters are names, conditionals, group membership, and use of hostvars. Outputs include fact data, debug messages, and templated files per host/group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"Demonstrate connecting to switches\"\n  hosts: switches\n  gather_facts: no\n\n  tasks:\n    ###\n    # Collect data\n    #\n    - name: Gather facts (eos)\n      arista.eos.eos_facts:\n      when: ansible_network_os == 'arista.eos.eos'\n\n    - name: Gather facts (ios)\n      cisco.ios.ios_facts:\n      when: ansible_network_os == 'cisco.ios.ios'\n\n    - name: Gather facts (vyos)\n      vyos.vyos.vyos_facts:\n      when: ansible_network_os == 'vyos.vyos.vyos'\n\n    ###\n    # Demonstrate variables\n    #\n    - name: Display some facts\n      debug:\n        msg: \"The hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}\"\n\n    - name: Facts from a specific host\n      debug:\n        var: hostvars['vyos01.example.net']\n\n    - name: Write facts to disk using a template\n      copy:\n        content: |\n          #jinja2: lstrip_blocks: True\n          EOS device info:\n            {% for host in groups['eos'] %}\n            Hostname: {{ hostvars[host].ansible_net_hostname }}\n            Version: {{ hostvars[host].ansible_net_version }}\n            Model: {{ hostvars[host].ansible_net_model }}\n\n```\n\n----------------------------------------\n\nTITLE: Defining an Ansible Playbook for Remote Execution and Privilege Escalation (YAML)\nDESCRIPTION: This YAML snippet defines an Ansible playbook named 'test_remote.yml'. It targets hosts in the 'ee_testing' group (defined in a separate inventory file). The playbook gathers facts and executes the 'whoami' command using privilege escalation ('become: true'), demonstrating interaction with remote hosts from within an EE.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_execution_environment.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: Test remote host\n  hosts: ee_testing\n  gather_facts: true\n  become: true\n\n  tasks:\n    - name: Run whoami command\n      ansible.builtin.command:\n        cmd: whoami\n      register: result\n\n    - name: Print whoami result\n      ansible.builtin.debug:\n        msg: \"{{ result.stdout }}\"\n\n```\n\n----------------------------------------\n\nTITLE: Hashing Prompted Variable Values (Password Hashing) in Ansible Playbook - YAML\nDESCRIPTION: This snippet illustrates securing prompted input in Ansible by hashing the response before storage, ideal for password input. It leverages 'encrypt' and related parameters in 'vars_prompt' (e.g., 'sha512_crypt' with salt options). Dependencies: Ansible installed, optionally Passlib for more hash schemes. Parameters: 'name' (variable identifier), 'prompt' (user message), 'private' (hides input), 'encrypt' (hash method), 'confirm' (double entry verification), 'salt_size'. Input: user input via prompt, Output: hashed value stored in variable. Ensures credentials are not stored in plain text.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_prompts.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvars_prompt:\\n\\n  - name: my_password2\\n    prompt: Enter password2\\n    private: true\\n    encrypt: sha512_crypt\\n    confirm: true\\n    salt_size: 7\n```\n\n----------------------------------------\n\nTITLE: Handling Unsafe Variables in Ansible Vars Plugins using `wrap_var` (Python)\nDESCRIPTION: This Python code shows an implementation of the `get_vars` method within an Ansible vars plugin (`VarsPlugin`). It demonstrates the use of `wrap_var` from `ansible.utils.unsafe_proxy` to mark a variable value containing a Jinja2 template string as potentially unsafe, ensuring Ansible processes it correctly and avoids unintended templating or execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n    from ansible.plugins.vars import BaseVarsPlugin\n    from ansible.utils.unsafe_proxy import wrap_var\n\n    class VarsPlugin(BaseVarsPlugin):\n        def get_vars(self, loader, path, entities):\n            return dict(\n                something_unsafe=wrap_var(\"{{ SOMETHING_UNSAFE }}\")\n            )\n```\n\n----------------------------------------\n\nTITLE: Setting Host-specific Variables to Override Group or Global Values - Ansible YAML\nDESCRIPTION: This example places a host-specific ntp_server variable in /etc/ansible/host_vars/xyz.boston.example.com, overriding both group and global values for the matching host. Intended for cases where a single host requires special configuration. Relies on the host being explicitly listed in inventory and structured according to Ansible host_vars conventions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: /etc/ansible/host_vars/xyz.boston.example.com\\nntp_server: override.example.com\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Ansible Role Directory Structure\nDESCRIPTION: This snippet displays the canonical directory layout for an Ansible role. It shows standard directories like `tasks` (for main task lists), `handlers` (for handler tasks), `templates` (for Jinja2 templates, ending in `.j2`), `files` (for static files to be copied or used by scripts), `vars` (for role-specific variables), `defaults` (for default variables with lower precedence), `meta` (for role dependencies and Galaxy metadata), and optional plugin directories like `library` (custom modules), `module_utils` (shared module code), and `lookup_plugins` (custom lookup plugins). Each directory holds specific types of Ansible content for modularity and reusability.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/shared_snippets/role_directory.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nroles/\n    common/               # this hierarchy represents a \"role\"\n        tasks/            #\n            main.yml      #  <-- tasks file can include smaller files if warranted\n        handlers/         #\n            main.yml      #  <-- handlers file\n        templates/        #  <-- files for use with the template resource\n            ntp.conf.j2   #  <------- templates end in .j2\n        files/            #\n            bar.txt       #  <-- files for use with the copy resource\n            foo.sh        #  <-- script files for use with the script resource\n        vars/             #\n            main.yml      #  <-- variables associated with this role\n        defaults/         #\n            main.yml      #  <-- default lower priority variables for this role\n        meta/             #\n            main.yml      #  <-- role dependencies and optional Galaxy info\n        library/          # roles can also include custom modules\n        module_utils/     # roles can also include custom module_utils\n        lookup_plugins/   # or other types of plugins, like lookup in this case\n\n    webtier/              # same kind of structure as \"common\" was above, done for the webtier role\n    monitoring/           # \"\"\n    fooapp/               # \"\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Ansible Content with FQCN\nDESCRIPTION: Illustrates the use of a Fully Qualified Collection Name (FQCN) to unambiguously reference a specific module (`grafana_dashboard`) within a collection (`community.grafana`). FQCNs are necessary when multiple collections might provide content with the same name.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_0\n\nLANGUAGE: Ansible\nCODE:\n```\ncommunity.grafana.grafana_dashboard\n```\n\n----------------------------------------\n\nTITLE: Controlling Rolling Updates in Ansible Plays\nDESCRIPTION: The `serial:` keyword is used within an Ansible play definition in a playbook (YAML format). It controls the execution flow by specifying how many hosts (either an absolute number or a percentage) from the target group should be processed in each batch. This enables rolling updates, preventing simultaneous changes across all targeted infrastructure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_27\n\nLANGUAGE: yaml\nCODE:\n```\nserial:\n```\n\n----------------------------------------\n\nTITLE: Passing Extra Variables at Runtime - JSON String Format - Ansible - Shell\nDESCRIPTION: Shows passing extra variables as a JSON object string to ansible-playbook using --extra-vars, supporting non-string and composite types such as lists or booleans. Two variations demonstrate use with different playbooks. Inputs are JSON-encoded strings; outputs make these variables available during playbook execution. JSON syntax and shell quoting must be correct to avoid errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook release.yml --extra-vars '{\"version\":\"1.23.45\",\"other_variable\":\"foo\"}'\nansible-playbook arcade.yml --extra-vars '{\"pacman\":\"mrs\",\"ghosts\":[\"inky\",\"pinky\",\"clyde\",\"sue\"]}'\n```\n\n----------------------------------------\n\nTITLE: Setting Group Variables for Atlanta Group - Ansible YAML\nDESCRIPTION: Defines static variables for all hosts within the 'atlanta' group, such as NTP and backup server values. Place this YAML file in group_vars/atlanta to apply these settings automatically to associated hosts. No external dependencies; variables are referenced in playbooks and templates using standard variable notation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: group_vars/atlanta\\nntp: ntp-atlanta.example.com\\nbackup: backup-atlanta.example.com\n```\n\n----------------------------------------\n\nTITLE: Setting Default Value in vars_prompt - Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet demonstrates how to define a prompt with a default value using 'vars_prompt' in an Ansible playbook. When the user is prompted for input (here, a 'release_version'), they can accept the default or override it. Dependencies: Ansible installed. Key parameters: 'name' (variable name), 'prompt' (display message), 'default' (used if the user provides no input). Input: user input or fallback to '1.0'. Output: variable set for later tasks. Useful for infrequently changed variables.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_prompts.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvars_prompt:\\n\\n  - name: release_version\\n    prompt: Product release version\\n    default: \\\"1.0\\\"\n```\n\n----------------------------------------\n\nTITLE: Running an Ad-Hoc Ansible Command to Install a Package (Bash)\nDESCRIPTION: Demonstrates using the `ansible` command for an ad-hoc task on `localhost`. It utilizes the `ansible.builtin.apt` module (`-m`) with arguments (`-a`) to ensure the `apache2` package is present on a Debian-based system. Privilege escalation is enabled (`-b`), and the command prompts for the necessary password (`-K`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nansible localhost -m ansible.builtin.apt -a \"name=apache2 state=present\" -b -K\n```\n\n----------------------------------------\n\nTITLE: Using Group Variables in Ansible Database Tasks (YAML)\nDESCRIPTION: This snippet from `roles/db/tasks/main.yml` demonstrates how group variables are used within Ansible tasks. It uses the `mysql_db` and `mysql_user` modules to create a database and a user, referencing variables like `dbname`, `dbuser`, and `upassword` (defined in `group_vars/dbservers`) using Jinja2 syntax.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Create Application Database\n  mysql_db:\n    name: \"{{ dbname }}\"\n    state: present\n\n- name: Create Application DB User\n  mysql_user:\n    name: \"{{ dbuser }}\"\n    password: \"{{ upassword }}\"\n    priv: \"*.*:ALL\"\n    host: '%'\n    state: present\n\n```\n\n----------------------------------------\n\nTITLE: Debugging Ansible Conditionals with Variable Type Checks (YAML)\nDESCRIPTION: This sequence of Ansible tasks demonstrates using the `ansible.builtin.debug` module to help troubleshoot conditional (`when`) statements. The first task displays the raw value of a variable (`bar_status.rc`). The subsequent tasks check the boolean result of comparing this variable to both a string (`\"127\"`) and an integer (`127`). This helps identify potential type mismatches (string vs. integer) that often cause unexpected behavior in conditionals. It assumes the `bar_status` variable, typically containing a return code, was set by a preceding task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_32\n\nLANGUAGE: yaml\nCODE:\n```\n- name: check value of return code\n  ansible.builtin.debug:\n    var: bar_status.rc\n   \n- name: check test for rc value as string\n  ansible.builtin.debug:\n    var: bar_status.rc == \"127\"\n\n- name: check test for rc value as integer\n  ansible.builtin.debug:\n    var: bar_status.rc == 127\n```\n\n----------------------------------------\n\nTITLE: Replacing with_subelements with Loop and subelements Filter in Ansible YAML+Jinja\nDESCRIPTION: Migrates with_subelements to loop with subelements filter, which enables iteration over paired values from a list of dictionaries and a sublist referenced by a key path. Expects a 'users' variable and a subkey ('mysql.hosts'). Produces combined user and host messages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_8\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_subelements\n  ansible.builtin.debug:\n    msg: \"{{ item.0.name }} - {{ item.1 }}\"\n  with_subelements:\n    - \"{{ users }}\"\n    - mysql.hosts\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_subelements -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item.0.name }} - {{ item.1 }}\"\n  loop: \"{{ users|subelements('mysql.hosts') }}\"\n```\n\n----------------------------------------\n\nTITLE: Forcing or Preventing Check Mode at the Task Level in Ansible (YAML)\nDESCRIPTION: These YAML snippets show how to control whether an Ansible task obeys check mode: setting 'check_mode: false' forces a task to always change the system, while 'check_mode: true' prevents it from making changes even in normal mode. Useful for fine-grained testing and validation of role or module logic, with 'register' capturing would-be changes for review.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_checkmode.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: This task will always make changes to the system\n    ansible.builtin.command: /something/to/run --even-in-check-mode\n    check_mode: false\n\n  - name: This task will never make changes to the system\n    ansible.builtin.lineinfile:\n      line: \"important config\"\n      dest: /path/to/myconfig.conf\n      state: present\n    check_mode: true\n    register: changes_to_important_config\n```\n\n----------------------------------------\n\nTITLE: Dynamically Including an Ansible Role Using include_role (YAML)\nDESCRIPTION: Demonstrates using `include_role` within the `tasks` section of a play to execute the `example` role dynamically. This allows tasks defined before and after the `include_role` statement to run in sequence.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  tasks:\n    - name: Print a message\n      ansible.builtin.debug:\n        msg: \"this task runs before the example role\"\n\n    - name: Include the example role\n      include_role:\n        name: example\n\n    - name: Print a message\n      ansible.builtin.debug:\n        msg: \"this task runs after the example role\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Native String Literal in Python\nDESCRIPTION: Shows how a simple string literal is defined in Python. In the context of Ansible modules following the \"Native String\" strategy, this represents a byte string in Python 2 and a text string (Unicode) in Python 3.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"This is a native string\"\n```\n\n----------------------------------------\n\nTITLE: Using Strict Version Comparison in Ansible Jinja\nDESCRIPTION: Demonstrates how to enable strict version parsing (using `ansible.module_utils.compat.version.StrictVersion`) for the `version` test by setting the third parameter, `strict`, to `True`. This enforces a more rigid version format (two or three dot-separated numbers, optional 'a'/'b' prerelease tag).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_8\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n{{ sample_version_var is version('1.0', operator='lt', strict=True) }}\n```\n\n----------------------------------------\n\nTITLE: Overriding Group Variables for Location-specific Hosts - Ansible YAML\nDESCRIPTION: This snippet shows how to override global defaults by placing variables in a location-specific group_vars file, in this case, /etc/ansible/group_vars/boston. The ntp_server value here takes precedence for all hosts in the 'boston' group, shadowing the value set for 'all'. Requires a structured inventory where 'boston' is a defined host group; applies only to those grouped hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: /etc/ansible/group_vars/boston\\nntp_server: boston-time.example.com\n```\n\n----------------------------------------\n\nTITLE: Defining Simple and Complex Arrays for win_dsc - Ansible YAML+Jinja\nDESCRIPTION: Demonstrates how to declare both simple type arrays and arrays of CIM instances in Ansible playbooks for Windows DSC resources. Requires Ansible's win_dsc module and provides options for declaring array data as either comma-separated strings or lists. For complex arrays, dictionary structures represent CIM instances with specific keys. Important for ensuring proper transmission to the Windows DSC engine without manual parsing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# [string[]]\nValueData: entry1, entry2, entry3\nValueData:\n- entry1\n- entry2\n- entry3\n\n# [UInt32[]]\nReturnCode: 0,3010\nReturnCode:\n- 0\n- 3010\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# [CimInstance[]]BindingInfo == DSC_WebBindingInformation\nBindingInfo:\n- Protocol: https\n  Port: 443\n  CertificateStoreName: My\n  CertificateThumbprint: C676A89018C4D5902353545343634F35E6B3A659\n  HostName: DSCTest\n  IPAddress: '*'\n  SSLFlags: 1\n- Protocol: http\n  Port: 80\n  IPAddress: '*'\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: stderr\nDESCRIPTION: Illustrates the `stderr` key, common for modules running external commands. It contains a string with the standard error output generated by the executed command or utility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n\"stderr\": \"ls: foo: No such file or directory\"\n```\n\n----------------------------------------\n\nTITLE: Listing Inventory as JSON via Ansible-Inventory Command - Console/JSON\nDESCRIPTION: This console example demonstrates the use of 'ansible-inventory' to display the processed inventory in JSON format, showing how Ansible interprets inventory files. The command showcases host variables, group relationships, and hierarchy. Requires a valid test.yml inventory file and Ansible installed with JSON support. Command output is syntactically valid JSON for use in further automation or debugging.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ ansible-inventory -i test.yml --list\n  {\n    \"_meta\": {\n        \"hostvars\": {\n            \"leaf01\": {\n                \"ansible_connection\": \"ansible.netcommon.network_cli\",\n                \"ansible_host\": \"10.16.10.11\",\n                \"ansible_network_os\": \"vyos.vyos.vyos\",\n                \"ansible_user\": \"my_vyos_user\"\n            },\n            \"leaf02\": {\n                \"ansible_connection\": \"ansible.netcommon.network_cli\",\n                \"ansible_host\": \"10.16.10.12\",\n                \"ansible_network_os\": \"vyos.vyos.vyos\",\n                \"ansible_user\": \"my_vyos_user\"\n            },\n            \"spine01\": {\n                \"ansible_connection\": \"ansible.netcommon.network_cli\",\n                \"ansible_host\": \"10.16.10.13\",\n                \"ansible_network_os\": \"vyos.vyos.vyos\",\n                \"ansible_user\": \"my_vyos_user\"\n            },\n            \"spine02\": {\n                \"ansible_connection\": \"ansible.netcommon.network_cli\",\n                \"ansible_host\": \"10.16.10.14\",\n                \"ansible_network_os\": \"vyos.vyos.vyos\",\n                \"ansible_user\": \"my_vyos_user\"\n            },\n            \"webserver01\": {\n                \"ansible_host\": \"10.16.10.15\",\n                \"ansible_user\": \"my_server_user\"\n            },\n            \"webserver02\": {\n                \"ansible_host\": \"10.16.10.16\",\n                \"ansible_user\": \"my_server_user\"\n            }\n        }\n    },\n    \"all\": {\n        \"children\": [\n            \"datacenter\",\n            \"ungrouped\"\n        ]\n    },\n    \"datacenter\": {\n        \"children\": [\n            \"network\",\n            \"webservers\"\n        ]\n    },\n    \"leafs\": {\n        \"hosts\": [\n            \"leaf01\",\n            \"leaf02\"\n        ]\n    },\n    \"network\": {\n        \"children\": [\n            \"leafs\",\n            \"spines\"\n        ]\n    },\n    \"spines\": {\n        \"hosts\": [\n            \"spine01\",\n            \"spine02\"\n        ]\n    },\n    \"webservers\": {\n        \"hosts\": [\n            \"webserver01\",\n            \"webserver02\"\n        ]\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Interpreter Path in Ansible Inventory - INI\nDESCRIPTION: Configures the Python interpreter path using the ansible_python_interpreter variable in the Ansible inventory. This ensures Ansible uses the specified Python executable on the target z/OS node. The inventory line syntax follows INI format, and should be tailored to your specific Python path. Requires Ansible and access to the managed host's inventory file. Input: hostname and interpreter path. Output: sets interpreter path for the node during playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\nzos1 ansible_python_interpreter:/usr/lpp/cyp/v3r12/pyz\n```\n\n----------------------------------------\n\nTITLE: Importing AnsibleModule in Python\nDESCRIPTION: This Python snippet shows the standard and required way to import the `AnsibleModule` class from `module_utils.basic`. This specific import format is mandated, and wildcard imports are disallowed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n.. code-block:: python\n\n   from module_utils.basic import AnsibleModule\n```\n\n----------------------------------------\n\nTITLE: Type Testing and Value Casting Using Ansible Tests - YAML\nDESCRIPTION: This snippet illustrates how to use Ansible's built-in type tests and casting filters to assert variable types and behaviors—including string, dictionary, list, number, float, integer, and boolean types—while highlighting type inheritance and strictness. It uses the 'assert' module with 'that' conditions, demonstrating the evaluation of types and their conversion using Jinja filters. Inputs are play variables of various types, and outputs are assertion results for each condition. Primary dependencies are Ansible 2.5+ and Jinja2 filters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: \"String interpretation\"\n    vars:\n      a_string: \"A string\"\n      a_dictionary: {\"a\": \"dictionary\"}\n      a_list: [\"a\", \"list\"]\n    assert:\n      that:\n      # Note that a string is classed as also being \"iterable\" and \"sequence\", but not \"mapping\"\n      - a_string is string and a_string is iterable and a_string is sequence and a_string is not mapping\n\n      # Note that a dictionary is classed as not being a \"string\", but is \"iterable\", \"sequence\" and \"mapping\"\n      - a_dictionary is not string and a_dictionary is iterable and a_dictionary is mapping\n\n      # Note that a list is classed as not being a \"string\" or \"mapping\" but is \"iterable\" and \"sequence\"\n      - a_list is not string and a_list is not mapping and a_list is iterable\n\n  - name: \"Number interpretation\"\n    vars:\n      a_float: 1.01\n      a_float_as_string: \"1.01\"\n      an_integer: 1\n      an_integer_as_string: \"1\"\n    assert:\n      that:\n      # Both a_float and an_integer are \"number\", but each has their own type as well\n      - a_float is number and a_float is float\n      - an_integer is number and an_integer is integer\n\n      # Both a_float_as_string and an_integer_as_string are not numbers\n      - a_float_as_string is not number and a_float_as_string is string\n      - an_integer_as_string is not number and a_float_as_string is string\n\n      # a_float or a_float_as_string when cast to a float and then to a string should match the same value cast only to a string\n      - a_float | float | string == a_float | string\n      - a_float_as_string | float | string == a_float_as_string | string\n\n      # Likewise an_integer and an_integer_as_string when cast to an integer and then to a string should match the same value cast only to an integer\n      - an_integer | int | string == an_integer | string\n      - an_integer_as_string | int | string == an_integer_as_string | string\n\n      # However, a_float or a_float_as_string cast as an integer and then a string does not match the same value cast to a string\n      - a_float | int | string != a_float | string\n      - a_float_as_string | int | string != a_float_as_string | string\n\n      # Again, Likewise an_integer and an_integer_as_string cast as a float and then a string does not match the same value cast to a string\n      - an_integer | float | string != an_integer | string\n      - an_integer_as_string | float | string != an_integer_as_string | string\n\n  - name: \"Native Boolean interpretation\"\n    loop:\n    - yes\n    - true\n    - True\n    - TRUE\n    - no\n    - No\n    - NO\n    - false\n    - False\n    - FALSE\n    assert:\n      that:\n      # Note that while other values may be cast to boolean values, these are the only ones that are natively considered boolean\n      # Note also that `yes` is the only case-sensitive variant of these values.\n      - item is boolean\n```\n\n----------------------------------------\n\nTITLE: Updating an Installed Ansible Role via ansible-galaxy (Bash)\nDESCRIPTION: Forces the reinstallation or update of an Ansible role (`mynamespace.my_role`) to version 2.7.1 using the `ansible-galaxy install` command with the `--force` option. Requires Ansible and internet connectivity to the Galaxy repository. Key parameters: role name with version, `--force` to overwrite existing installations. Input: role name and target version. Output: Updated role in the local Ansible roles directory. Users may need to manage dependencies manually for compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible]$ ansible-galaxy install mynamespace.my_role,v2.7.1 --force\n```\n\n----------------------------------------\n\nTITLE: Setting Basic Module Defaults at Play Level in Ansible YAML\nDESCRIPTION: This Ansible playbook demonstrates setting default arguments (`owner`, `group`, `mode`) for the `ansible.builtin.file` module at the play level using `module_defaults`. These defaults are automatically applied to all subsequent tasks invoking `ansible.builtin.file` within the play, simplifying task definitions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n- hosts: localhost\n  module_defaults:\n    ansible.builtin.file:\n      owner: root\n      group: root\n      mode: 0755\n  tasks:\n    - name: Create file1\n      ansible.builtin.file:\n        state: touch\n        path: /tmp/file1\n\n    - name: Create file2\n      ansible.builtin.file:\n        state: touch\n        path: /tmp/file2\n\n    - name: Create file3\n      ansible.builtin.file:\n        state: touch\n        path: /tmp/file3\n```\n\n----------------------------------------\n\nTITLE: Configuring PPA and Installing Ansible on Ubuntu (Bash)\nDESCRIPTION: Configures the official Ansible PPA (Personal Package Archive) and installs the 'ansible' package on Ubuntu systems. It first updates the package list, installs 'software-properties-common' (needed to manage repositories), adds the Ansible PPA, and finally installs Ansible using the APT package manager. Requires root privileges (sudo). Note variations for older Ubuntu versions regarding 'software-properties-common' naming and the '--update' flag for 'add-apt-repository'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt update\n$ sudo apt install software-properties-common\n$ sudo add-apt-repository --yes --update ppa:ansible/ansible\n$ sudo apt install ansible\n```\n\n----------------------------------------\n\nTITLE: Applying Conditionals to Items within an Ansible Loop\nDESCRIPTION: This task demonstrates combining a `when` statement with a `loop`. The `ansible.builtin.command` module executes `echo` for each item in the provided list, but the `when: item > 5` condition ensures it only runs for items whose value is greater than 5.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n    - name: Run with items greater than 5\n      ansible.builtin.command: echo {{ item }}\n      loop: [ 0, 2, 4, 6, 8, 10 ]\n      when: item > 5\n```\n\n----------------------------------------\n\nTITLE: Configuring Junos via NETCONF with Overridden Key File (YAML)\nDESCRIPTION: This Ansible task shows how to use the 'junipernetworks.junos.netconf_config' module while overriding a connection variable for this specific task. The 'vars' section sets 'ansible_private_key_file' to a custom path, instructing Ansible to use a different SSH private key ('/home/admin/.ssh/newprivatekeyfile') for authentication during this task execution, instead of the default or inventory-defined key. It also performs a configuration backup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netconf_enabled.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: configure interface while providing different private key file path\n  junipernetworks.junos.netconf_config:\n    backup: yes\n  register: backup_junos_location\n  vars:\n    ansible_private_key_file: /home/admin/.ssh/newprivatekeyfile\n```\n\n----------------------------------------\n\nTITLE: Ensuring Latest Package Version with Ansible Ad Hoc Command (yum) in Bash\nDESCRIPTION: Uses the `ansible.builtin.yum` module to ensure the 'acme' package is installed and at the latest available version on all 'webservers'. The `state=latest` argument triggers an update if a newer version exists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.yum -a \"name=acme state=latest\"\n```\n\n----------------------------------------\n\nTITLE: Setting File Permissions with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Utilizes the `ansible.builtin.file` module (`-m ansible.builtin.file`) to change the permissions of a remote file. This command sets the mode of `/srv/foo/a.txt` to `600` on all hosts in the 'webservers' group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.file -a \"dest=/srv/foo/a.txt mode=600\"\n```\n\n----------------------------------------\n\nTITLE: Replacing WeOS 4 Device Configuration using Ansible (YAML)\nDESCRIPTION: This Ansible task shows how to replace the entire running configuration on a WeOS 4 device with the content of a local file (`westermo.conf`). It utilizes the `ansible.netcommon.cli_config` module, using the `lookup` plugin to read the file content into the `config` parameter. The `replace: \"yes\"` option ensures the existing configuration is replaced, and `diff_match` and `diff_replace` control how differences are handled. A `when` condition targets the task specifically to WeOS 4 devices.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_weos4.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Replace configuration with file on ansible host (WeOS 4)\n  ansible.netcommon.cli_config:\n    config: \"{{ lookup('file', 'westermo.conf') }}\"\n    replace: \"yes\"\n    diff_match: exact\n    diff_replace: config\n  when: ansible_network_os == 'community.network.weos4'\n```\n\n----------------------------------------\n\nTITLE: Validating Web Service Response with Ansible URI and Fail Modules in YAML\nDESCRIPTION: Shows how to test a web service endpoint using Ansible's 'uri' module to fetch content and register the result, followed by a 'fail' action if certain keywords (e.g., 'AWESOME') are missing in the response. This approach enables custom content validation as part of deployments. Requires Ansible and network access to the specified URL. 'webpage' is a registered variable; input: URL, output: test failure or success.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n  - action: uri url=https://www.example.com return_content=yes\n    register: webpage\n\n  - fail:\n      msg: 'service is not happy'\n    when: \"'AWESOME' not in webpage.content\"\n```\n\n----------------------------------------\n\nTITLE: Executing Commands Securely within Ansible Modules\nDESCRIPTION: Mandates the use of `module.run_command` for executing external commands within an Ansible module. This function integrates properly with Ansible's logging, error handling, and security mechanisms. Direct use of Python's `subprocess`, `Popen`, or `os.system` is strongly discouraged.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmodule.run_command\n```\n\n----------------------------------------\n\nTITLE: Securing Playbook Conditionals in Ansible Playbooks (YAML)\nDESCRIPTION: Demonstrates correct and incorrect approaches to referencing module output in playbook task conditionals due to CVE-2023-5764 mitigation in ansible-core 2.15. The first snippet (commented code) shows the unsafe use of embedded Jinja templates consulting untrusted data, which is no longer allowed; the second snippet provides the recommended method by directly referencing the result as a variable in the assertion condition. There are no external dependencies beyond standard Ansible variables and modules; 'untrusted_result' is a registered variable from a shell command. Inputs are playbook tasks, and outputs are assertion results.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.15.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: task with a module result (always untrusted by Ansible)\\n  shell: echo \\\"hi mom\\\"\\n  register: untrusted_result\\n\\n# don't do it this way...\\n# - name: insecure conditional with embedded template consulting untrusted data\\n#   assert:\\n#     that: '\\\"hi mom\\\" is in {{ untrusted_result.stdout }}'\\n\\n- name: securely access untrusted values directly as Jinja variables instead\\n  assert:\\n    that: '\\\"hi mom\\\" is in untrusted_result.stdout'\n```\n\n----------------------------------------\n\nTITLE: Chained and Nested Lookups with Filters in Ansible (YAML+Jinja)\nDESCRIPTION: This advanced example illustrates combining multiple lookups, nested data sources, and Jinja2 filters within a single Ansible task. It uses 'lookup', 'with_nested', and filters like 'urlencode', 'join', and 'shuffle', integrating lookups from external plugins such as 'url', 'consul_kv', and 'sequence'. The snippet demonstrates parameters and usage patterns for complex data retrieval and manipulation, which is useful for dynamically constructing messages or performing calculations. Dependencies include Ansible, defined plugins, accessible endpoints, and appropriate file paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_2\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n  tasks:\n    - name: Complicated chained lookups and filters\n      debug: msg=\"find the answer here:\\n{{ lookup('url', 'https://google.com/search/?q=' + item|urlencode)|join(' ') }}\"\n      with_nested:\n        - \"{{ lookup('consul_kv', 'bcs/' + lookup('file', '/the/question') + ', host=localhost, port=2000')|shuffle }}\"\n        - \"{{ lookup('sequence', 'end=42 start=2 step=2')|map('log', 4)|list) }}\"\n        - ['a', 'c', 'd', 'c']\n```\n\n----------------------------------------\n\nTITLE: Defining Variables for Conditional Use in Ansible (YAML)\nDESCRIPTION: This YAML snippet shows the definition of variables within an Ansible playbook's `vars` section. It defines a boolean variable `epic` set to `true` and a string variable `monumental` set to \"yes\". These variables can be subsequently used in `when` conditions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  epic: true\n  monumental: \"yes\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Ansible Ping Module Success Output (JSON)\nDESCRIPTION: This JSON object represents the successful output returned by the Ansible 'ping' module when run against a managed host. It confirms the host is reachable and responsive ('ping': 'pong'), indicates that no changes were made to the host ('changed': false), and includes gathered Ansible facts, such as the path to the discovered Python interpreter ('discovered_interpreter_python'). This structure is standard for successful ping module executions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/ansible_output/ping_inventory_output.txt#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Unreachable Host Errors for a Specific Task (YAML)\nDESCRIPTION: This Ansible task uses `ignore_unreachable: true` to prevent the play from stopping on a host if this specific task fails due to the host being unreachable. Subsequent tasks in the play will still attempt to execute on the host. The second task lacks this directive, so an unreachable error there would halt execution for that host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: This executes, fails, and the failure is ignored\n  ansible.builtin.command: /bin/true\n  ignore_unreachable: true\n\n- name: This executes, fails, and ends the play for this host\n  ansible.builtin.command: /bin/true\n```\n\n----------------------------------------\n\nTITLE: Passing Extra Variables at Runtime - Escaping Quotes - Ansible - Shell\nDESCRIPTION: Provides multiple examples of passing complex strings as extra-vars to ansible-playbook, requiring careful escaping for both shell and JSON, especially with single/double quotes and backslashes. Inputs are strings with special characters or JSON; outputs are variables with possibly intricate values. Failure to escape properly will cause playbook or shell parsing errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook arcade.yml --extra-vars \"{\\\"name\\\":\\\"Conan O\\'Brien\\\"}\"\nansible-playbook arcade.yml --extra-vars '{\"name\":\"Conan O'\\''Brien\"}'\nansible-playbook script.yml --extra-vars \"{\\\"dialog\\\":\\\"He said \\\\\\\"I just can't get enough of those single and double-quotes\\\"!\\\\\\\"\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Setup Tasks (YAML)\nDESCRIPTION: Ansible tasks in `tests/integration/targets/setup_postgresql_db/tasks/main.yml` to prepare the environment for PostgreSQL tests. It installs necessary packages (`apt-utils`, `postgresql`, `python3-psycopg2`), initializes the PostgreSQL cluster using a shell command (conditionally, if not already created), and starts the PostgreSQL service.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Install required packages\n  package:\n    name:\n      - apt-utils\n      - postgresql\n      - postgresql-common\n      - python3-psycopg2\n\n- name: Initialize PostgreSQL\n  shell: . /usr/share/postgresql-common/maintscripts-functions && set_system_locale && /usr/bin/pg_createcluster -u postgres 12 main\n  args:\n    creates: /etc/postgresql/12/\n\n- name: Start PostgreSQL service\n  ansible.builtin.service:\n    name: postgresql\n    state: started\n```\n\n----------------------------------------\n\nTITLE: Sample Values for ansible_facts['distribution'] (Text)\nDESCRIPTION: This snippet provides a non-exhaustive list of example string values for the `ansible_facts['distribution']` fact. This fact identifies the specific Linux distribution or operating system variant (e.g., 'CentOS', 'Ubuntu', 'Debian') running on the target host. It's commonly used in Ansible playbooks within conditional statements (`when`) to execute tasks or apply configurations specific to a particular distribution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_34\n\nLANGUAGE: text\nCODE:\n```\nAlpine\nAltlinux\nAmazon\nArchlinux\nClearLinux\nCoreos\nCentOS\nDebian\nFedora\nGentoo\nMandriva\nNA\nOpenWrt\nOracleLinux\nRedHat\nSlackware\nSLES\nSMGL\nSUSE\nUbuntu\nVMwareESX\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Ad Hoc Tasks with Polling Enabled (bash)\nDESCRIPTION: Runs a job asynchronously from the command line, specifying both a timeout and a polling interval in seconds. Ansible will keep the remote connection open and periodically poll the job's state. Intended for long-running commands where periodic status updates are desirable. Requires proper fork/parallelism configuration for high concurrency.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -B 1800 -P 60 -a \"/usr/bin/long_running_operation --do-stuff\"\n```\n\n----------------------------------------\n\nTITLE: Storing Encrypted Network Credentials Using Ansible Vault (YAML format)\nDESCRIPTION: This YAML snippet demonstrates how to store sensitive connection variables, specifically ansible_ssh_pass, in encrypted form using Ansible Vault syntax. Dependencies include having ansible-vault configured and the vault password available for decryption. Parameters include ansible_connection, ansible_network_os, ansible_user, and ansible_ssh_pass. Expected input is a YAML structure with the credential fields; output is secure variable values ready for use in playbooks. Only the encrypted string is visible, protecting secrets in source control.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: vyos.vyos.vyos\nansible_user: my_vyos_user\nansible_ssh_pass: !vault |\n                  $ANSIBLE_VAULT;1.1;AES256\n                  39336231636137663964343966653162353431333566633762393034646462353062633264303765\n                  6331643066663534383564343537343334633031656538370a333737656236393835383863306466\n                  62633364653238323333633337313163616566383836643030336631333431623631396364663533\n                  3665626431626532630a353564323566316162613432373738333064366130303637616239396438\n                  9853\n\n```\n\n----------------------------------------\n\nTITLE: Ignoring Unreachable Host Errors at Playbook Level (YAML)\nDESCRIPTION: This Ansible playbook demonstrates setting `ignore_unreachable: true` at the play level. This makes Ansible ignore unreachable errors for all tasks within the play by default. The first task inherits this setting. The second task explicitly sets `ignore_unreachable: false`, overriding the play-level setting and causing an unreachable error on this task to halt execution for the host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  ignore_unreachable: true\n  tasks:\n  - name: This executes, fails, and the failure is ignored\n    ansible.builtin.command: /bin/true\n\n  - name: This executes, fails, and ends the play for this host\n    ansible.builtin.command: /bin/true\n    ignore_unreachable: false\n```\n\n----------------------------------------\n\nTITLE: Using Collections Keyword in Playbook for Role Import (YAML)\nDESCRIPTION: Example playbook showing the use of the 'collections' keyword to globally enable reference to roles by short name, simplifying FQCN usage in tasks. Takes a list of collections as input and allows 'import_role' to refer to roles within the specified collections by name only. Outputs improved playbook readability.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: example role by FQCN\\n  hosts: some_host_pattern\\n  collections:\\n    - mynamespace.mycollection\\n  tasks:\\n    - name: import role from a collection\\n      import_role:\\n        name: my_role\\n\n```\n\n----------------------------------------\n\nTITLE: Using local_action to Run Rsync Commands Locally in Ansible (YAML)\nDESCRIPTION: Provides an example of using local_action to run the 'rsync' command from the management server to recursively copy files onto managed nodes. Requires passwordless SSH key setup between the control node and targets, as rsync invokes a new ssh session. Inputs: local file source, inventory_hostname for destination. Outputs: files copied to target directories. Limitation: Fails if SSH key authentication is not properly configured.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# ...\n\n  tasks:\n    - name: Recursively copy files from management server to target\n      local_action: ansible.builtin.command rsync -a /path/to/files {{ inventory_hostname }}:/path/to/target/\n```\n\n----------------------------------------\n\nTITLE: Comparing Control Node and Target Timestamps in Action Plugin (Python)\nDESCRIPTION: Implements a full action plugin that compares the Ansible control node's UTC time to the remote machine's time as returned by the setup module, calculating the delta in days, seconds, and microseconds. Dependencies include ActionBase, datetime, and __future__ imports for Python 3 compliance. Inputs are taken from setup, and the output is a dict of ansible_facts with time differences; works for tasks where clock drift needs to be measured.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/python\n# Make coding more python3-ish, this is required for contributions to Ansible\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom ansible.plugins.action import ActionBase\nfrom datetime import datetime\n\n\nclass ActionModule(ActionBase):\n    def run(self, tmp=None, task_vars=None):\n        super(ActionModule, self).run(tmp, task_vars)\n        module_args = self._task.args.copy()\n        module_return = self._execute_module(module_name='setup',\n                                             module_args=module_args,\n                                             task_vars=task_vars, tmp=tmp)\n        ret = dict()\n        remote_date = None\n        if not module_return.get('failed'):\n            for key, value in module_return['ansible_facts'].items():\n                if key == 'ansible_date_time':\n                    remote_date = value['iso8601']\n\n        if remote_date:\n            remote_date_obj = datetime.strptime(remote_date, '%Y-%m-%dT%H:%M:%SZ')\n            time_delta = datetime.utcnow() - remote_date_obj\n            ret['delta_seconds'] = time_delta.seconds\n            ret['delta_days'] = time_delta.days\n            ret['delta_microseconds'] = time_delta.microseconds\n\n        return dict(ansible_facts=dict(ret))\n```\n\n----------------------------------------\n\nTITLE: Ensuring Package Installation with Ansible Ad Hoc Command (yum) in Bash\nDESCRIPTION: Guarantees that a package ('acme') is installed on hosts in the 'webservers' group using the `ansible.builtin.yum` package manager module. The `state=present` argument ensures the package exists but doesn't necessarily update it to the latest version if it's already installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.yum -a \"name=acme state=present\"\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin Configuration Options in Embedded Documentation (YAML)\nDESCRIPTION: Provides a YAML schema for defining plugin configuration options in a plugin's DOCUMENTATION section. This configuration includes option descriptions, defaults, environment variables, ini sections, variables, requirements, types, and version metadata. Inputs are option fields and their metadata; output is a block describing the options for documentation purposes. Applies to any Ansible plugin supporting embedded documentation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\noptions:\n  option_name:\n    description: describe this config option\n    default: default value for this config option\n    env:\n      - name: NAME_OF_ENV_VAR\n    ini:\n      - section: section_of_ansible.cfg_where_this_config_option_is_defined\n        key: key_used_in_ansible.cfg\n    vars:\n      - name: name_of_ansible_var\n      - name: name_of_second_var\n        version_added: X.x\n    required: True/False\n    type: boolean/float/integer/list/none/path/pathlist/pathspec/string/tmppath\n    version_added: X.x\n```\n\n----------------------------------------\n\nTITLE: Updating Module Arguments via the Ansible Debugger - Ansible Output\nDESCRIPTION: This Ansible debugger output illustrates the process of inspecting and updating a module argument ('name') within the task arguments dictionary during a debug session. It shows how to print current argument values, update them interactively, and redo the failed task. Dependencies include an active playbook run with a failed task and usage of the Ansible debugger in a terminal. Inputs are the commands typed at the prompt; output is the representation of arguments and task retry.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_11\n\nLANGUAGE: ansible-output\nCODE:\n```\n[192.0.2.10] TASK: install package (debug)> p task.args\n{u'name': u'{{ pkg_name }}'}\n[192.0.2.10] TASK: install package (debug)> task.args['name'] = 'bash'\n[192.0.2.10] TASK: install package (debug)> p task.args\n{u'name': 'bash'}\n[192.0.2.10] TASK: install package (debug)> redo\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Host Variables for WinRM/PSRP Certificate Authentication (YAML)\nDESCRIPTION: Defines Ansible host variables required for establishing WinRM or PSRP connections using certificate authentication. It specifies the connection type, authentication method (`certificate`), and paths to the public certificate PEM file and the private key PEM file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# psrp\nansible_connection: psrp\nansible_psrp_auth: certificate\nansible_psrp_certificate_pem: /path/to/certificate/public_key.pem\nansible_psrp_certificate_key_pem: /path/to/certificate/private_key.pem\n\n# winrm\nansible_connection: winrm\nansible_winrm_transport: certificate\nansible_winrm_cert_pem: /path/to/certificate/public_key.pem\nansible_winrm_cert_key_pem: /path/to/certificate/private_key.pem\n```\n\n----------------------------------------\n\nTITLE: Grouping Handlers with Listen Keyword in Ansible (YAML)\nDESCRIPTION: Demonstrates using the listen keyword to group multiple handlers under a shared topic (\"restart web services\"). Tasks notify the group topic, resulting in all listening handlers being executed. Useful for decoupling handler names and enabling reuse, especially across roles and shared playbooks. Shows shell command task and service module handler examples.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n  - name: Restart everything\\n    command: echo \"this task will restart the web services\"\\n    notify: \"restart web services\"\\n\\nhandlers:\\n  - name: Restart memcached\\n    service:\\n      name: memcached\\n      state: restarted\\n    listen: \"restart web services\"\\n\\n  - name: Restart apache\\n    service:\\n      name: apache\\n      state: restarted\\n    listen: \"restart web services\"\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Rolling Update Play Parameters in Ansible (YAML)\nDESCRIPTION: This snippet marks the beginning of the main update play in the `rolling_update.yml` playbook. It targets the `webservers` host group and specifies that tasks should run as the `root` user. Crucially, the `serial: 1` parameter instructs Ansible to process only one web server at a time, enabling a controlled, zero-downtime rolling upgrade.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: webservers\n  user: root\n  serial: 1\n\n```\n\n----------------------------------------\n\nTITLE: Installing and Configuring OpenSSH Server via PowerShell - Windows - PowerShell\nDESCRIPTION: This PowerShell script installs the OpenSSH Server feature on Windows, configures the sshd service to start automatically, creates a firewall rule for SSH, and sets the default login shell to PowerShell by editing the registry. It uses `Get-WindowsCapability`, `Add-WindowsCapability`, `Set-Service`, `New-NetFirewallRule`, and `New-ItemProperty` cmdlets. The script should be run with administrative privileges; prerequisites include Windows Server 2022 or later. The inputs are cmdlet parameters and registry values; output is a configured and running OpenSSH server ready for Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nGet-WindowsCapability -Name OpenSSH.Server* -Online |\n    Add-WindowsCapability -Online\nSet-Service -Name sshd -StartupType Automatic -Status Running\n\n$firewallParams = @{\n    Name        = 'sshd-Server-In-TCP'\n    DisplayName = 'Inbound rule for OpenSSH Server (sshd) on TCP port 22'\n    Action      = 'Allow'\n    Direction   = 'Inbound'\n    Enabled     = 'True'  # This is not a boolean but an enum\n    Profile     = 'Any'\n    Protocol    = 'TCP'\n    LocalPort   = 22\n}\nNew-NetFirewallRule @firewallParams\n\n$shellParams = @{\n    Path         = 'HKLM:\\SOFTWARE\\OpenSSH'\n    Name         = 'DefaultShell'\n    Value        = 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe'\n    PropertyType = 'String'\n    Force        = $true\n}\nNew-ItemProperty @shellParams\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Roles in Ansible YAML Playbook\nDESCRIPTION: This code example demonstrates how to assign multiple Ansible roles to hosts in a play. By listing roles under the 'roles' keyword, tasks defined in each referenced role (e.g., common, base-apache, web) will be run in the order listed. This structure requires that the roles are defined and available in the project's roles directory or via requirements, and facilitates reusable configuration patterns and modular orchestration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nroles:\n- common\n- base-apache\n- web\n```\n\n----------------------------------------\n\nTITLE: Setting Global Defaults with Group Vars in Ansible - YAML\nDESCRIPTION: This snippet demonstrates creating a site-wide default variable for NTP server configuration in Ansible by defining it in the \\/etc\\/ansible\\/group_vars\\/all file. All hosts and groups inherit this ntp_server value unless specifically overridden elsewhere. No dependencies are required beyond Ansible and a properly structured inventory; ntp_server is the main parameter, providing a default time source for all managed hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: /etc/ansible/group_vars/all\\n# this is the site wide default\\nntp_server: default-time.example.com\n```\n\n----------------------------------------\n\nTITLE: Using Single Quotes to Preserve Colons in YAML\nDESCRIPTION: Demonstrates the correct way to include a colon followed by a space within a scalar value by enclosing the entire string in single quotes. This prevents YAML from interpreting the colon as a mapping indicator.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nfoo: 'somebody said I should put a colon here: so I did'\n\nwindows_drive: 'c:'\n```\n\n----------------------------------------\n\nTITLE: Replacing with_items Loops using Loop and Flatten Filter in Ansible YAML+Jinja\nDESCRIPTION: Illustrates conversion of with_items to loop with flatten, enabling iteration over a possibly nested list of items. Assumes the 'items' variable is defined elsewhere. This approach flattens one level, providing each atomic value to the task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_items\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_items: \"{{ items }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_items -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ items|flatten(levels=1) }}\"\n```\n\n----------------------------------------\n\nTITLE: Using Secure Conditionals in Ansible Playbooks - YAML\nDESCRIPTION: This snippet demonstrates proper handling of module results in Ansible playbooks, focusing on securely referencing untrusted values within conditional statements. It illustrates the transition from unsafe embedded templates to directly accessing Jinja variables, mitigating security risks associated with template injection. This technique requires no external dependencies and expects registered module results (like 'untrusted_result') as input; output is the result of the 'assert' task. Limitation: unsafe embedded templates in conditionals should be avoided, and all module results are treated as untrusted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_8.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: task with a module result (always untrusted by Ansible)\\n  shell: echo \\\"hi mom\\\"\\n  register: untrusted_result\\n\\n# don't do it this way...\\n# - name: insecure conditional with embedded template consulting untrusted data\\n#   assert:\\n#     that: '\\\"hi mom\\\" is in {{ untrusted_result.stdout }}'\\n\\n- name: securely access untrusted values directly as Jinja variables instead\\n  assert:\\n    that: '\\\"hi mom\\\" is in untrusted_result.stdout'\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Individual Tasks - Ansible Playbook (YAML)\nDESCRIPTION: Demonstrates how to assign different tags to individual tasks within an Ansible playbook. This allows selective execution of tasks based on tags provided at runtime. No extra dependencies are required other than Ansible itself, and important parameters include 'tags', 'name', and the respective module parameters. Tasks are executed or skipped according to specified tags when running the playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n- name: Install the servers\n  ansible.builtin.yum:\n    name:\n    - httpd\n    - memcached\n    state: present\n  tags:\n  - packages\n  - webservers\n\n- name: Configure the service\n  ansible.builtin.template:\n    src: templates/src.j2\n    dest: /etc/foo.conf\n  tags:\n  - configuration\n\n```\n\n----------------------------------------\n\nTITLE: Registering Task Output as Variables - Ansible - YAML\nDESCRIPTION: Provides an example for using the register keyword in an Ansible playbook to capture the output of tasks as variables, which can be referenced in subsequent tasks. Runs shell commands with ansible.builtin.shell, sets ignore_errors for resilience, and uses registered results to control task execution via conditional when clauses. Inputs are the task commands; outputs are registered variables with module return data. Shell module must exist on target and the command must be valid.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: web_servers\n\n  tasks:\n\n     - name: Run a shell command and register its output as a variable\n       ansible.builtin.shell: /usr/bin/foo\n       register: foo_result\n       ignore_errors: true\n\n     - name: Run a shell command using output of the previous task\n       ansible.builtin.shell: /usr/bin/bar\n       when: foo_result.rc == 5\n```\n\n----------------------------------------\n\nTITLE: Setting Host-Specific Variables in Inventory - yaml\nDESCRIPTION: This YAML example configures variables for an individual host directly in the inventory. It sets properties such as IP address, FQDN, or user name, simplifying command-line usage. Dependencies include YAML inventory support and proper key-value structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nhost1:\\n  ansible_host: 10.0.0.1\\n  ansible_user: admin\n```\n\n----------------------------------------\n\nTITLE: Aborting Play on First Error using any_errors_fatal (Play Level) (YAML)\nDESCRIPTION: This Ansible play snippet demonstrates setting `any_errors_fatal: true` at the play level. If any task within this play fails on any host, Ansible will finish executing the failing task on all hosts currently in the batch, but it will then immediately stop the entire playbook execution for all hosts. No further tasks or plays will run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n - hosts: somehosts\n   any_errors_fatal: true\n   roles:\n     - myrole\n```\n\n----------------------------------------\n\nTITLE: Defining Role Dependencies with Variables in Ansible (YAML)\nDESCRIPTION: Example `meta/main.yml` for an Ansible role ('myapp') defining dependencies on 'common', 'apache', and 'postgres' roles. It demonstrates passing variables (`vars`) to the dependent roles, which Ansible executes before the 'myapp' role.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\n# roles/myapp/meta/main.yml\n---\ndependencies:\n  - role: common\n    vars:\n      some_parameter: 3\n  - role: apache\n    vars:\n      apache_port: 80\n  - role: postgres\n    vars:\n      dbname: blarg\n      other_parameter: 12\n```\n\n----------------------------------------\n\nTITLE: Defining Task Failure Based on Return Code (YAML)\nDESCRIPTION: This Ansible task utilizes the `failed_when` conditional with the `ansible.builtin.raw` module to define failure based on the command's return code (`rc`). The `diff` command's result is registered in `diff_cmd`. The task fails if the return code is exactly 0 (indicating files are identical) or greater than or equal to 2 (indicating an error during diff). A return code of 1 (files differ) is considered success in this context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Fail task when both files are identical\n  ansible.builtin.raw: diff foo/file1 bar/file2\n  register: diff_cmd\n  failed_when: diff_cmd.rc == 0 or diff_cmd.rc >= 2\n```\n\n----------------------------------------\n\nTITLE: Assigning Group Variables in YAML Inventory - Ansible Inventory - YAML\nDESCRIPTION: Shows the YAML syntax for assigning variables to a host group, leveraging a 'vars' dictionary under the named group. Enables clean assignment of group-wide configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\natlanta:\\n  hosts:\\n    host1:\\n    host2:\\n  vars:\\n    ntp_server: ntp.atlanta.example.com\\n    proxy: proxy.atlanta.example.com\n```\n\n----------------------------------------\n\nTITLE: Conditionally Shutting Down Systems Based on OS Family (YAML)\nDESCRIPTION: This Ansible task runs the `/sbin/shutdown -t now` command using the `ansible.builtin.command` module. It executes only on hosts where the `ansible_facts['os_family']` fact is equal to \"Debian\", showcasing conditional execution based on operating system facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Shut down Debian flavored systems\n    ansible.builtin.command: /sbin/shutdown -t now\n    when: ansible_facts['os_family'] == \"Debian\"\n```\n\n----------------------------------------\n\nTITLE: Installing Minimal ansible-core with pip\nDESCRIPTION: Installs the minimal 'ansible-core' package using pip for the current user (--user flag). This provides the core Ansible functionality.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --user ansible-core\n```\n\n----------------------------------------\n\nTITLE: Restarting Webserver Using Service Module - Ansible - YAML\nDESCRIPTION: Illustrates passing structured (complex) arguments to the 'service' module via YAML in a playbook. The module manages the 'httpd' service, ensuring it is restarted. Required parameters include 'name' (service identifier) and 'state' (desired status). Inputs are specified as YAML mapping. Applicable in playbooks needing clear, structured module arguments. Output is Ansible module response in JSON. Requires control host connectivity and modern playbook support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/module_plugin_guide/modules_intro.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: restart webserver\n  service:\n    name: httpd\n    state: restarted\n```\n\n----------------------------------------\n\nTITLE: Defining Host Inventory with Become - Ansible Inventory Text\nDESCRIPTION: This example demonstrates defining a managed host in an Ansible inventory file with user-specific privilege escalation parameters. The configuration assigns 'manager' as the SSH user and enables privilege escalation via 'ansible_become=true'. Inputs: the host (webserver), user credential, and escalation directive. Output: tasks run on 'webserver' as 'manager' will escalate to root by default. Limitation: requires valid credentials and configuration in inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nwebserver ansible_user=manager ansible_become=true\n```\n\n----------------------------------------\n\nTITLE: Example OS-Specific Variables File (`vars/RedHat.yml`)\nDESCRIPTION: This snippet shows an example Ansible variables file intended for Red Hat family systems (e.g., CentOS). It defines variables like `apache` (set to `httpd`) and `somethingelse`. Such files are typically loaded conditionally based on host facts (e.g., `ansible_facts['os_family']`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_29\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# for vars/RedHat.yml\napache: httpd\nsomethingelse: 42\n```\n\n----------------------------------------\n\nTITLE: Defining Tasks in Ansible Role's tasks/main.yml (YAML)\nDESCRIPTION: Displays the content of the `tasks/main.yml` file within the 'system_demo' role using the `cat` command. This YAML file contains the list of tasks that the role will execute, specifically configuring the hostname and DNS servers using the `cisco.ios.ios_config` module. These tasks were moved from the original standalone playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n[user@ansible system_demo]$ cat tasks/main.yml\n---\n- name: configure hostname\n  cisco.ios.ios_config:\n    lines: hostname {{ inventory_hostname }}\n\n- name: configure DNS\n  cisco.ios.ios_config:\n    lines: ip name-server {{dns}}\n```\n\n----------------------------------------\n\nTITLE: Using win_dsc Module for DSC Registry Resource in YAML\nDESCRIPTION: This Ansible task demonstrates how to use the `win_dsc` module to interact with the DSC 'Registry' resource. It specifies `resource_name: Registry` and maps other task parameters (Ensure, Key, ValueName, ValueData) directly to the corresponding DSC resource properties defined in the PowerShell syntax. This task ensures a specific registry key and value exist on the target Windows host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Use win_dsc module with the Registry DSC resource\n  win_dsc:\n    resource_name: Registry\n    Ensure: Present\n    Key: HKEY_LOCAL_MACHINE\\SOFTWARE\\ExampleKey\n    ValueName: TestValue\n    ValueData: TestData\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Python Installation on OpenBSD via Raw Module\nDESCRIPTION: This command utilizes the Ansible 'raw' module to install a specific Python version (3.11) on an OpenBSD managed node ('myopenbsdhost') using the 'pkg_add' package manager. Bootstrapping Python is required before using most Ansible modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible -m raw -a \"pkg_add -I python%3.11\" myopenbsdhost\n```\n\n----------------------------------------\n\nTITLE: Enable Device Interaction Logging for a Task - YAML\nDESCRIPTION: Demonstrates enabling persistent log messages for a specific Ansible task involving the cisco.ios.ios_command module. The 'ansible_persistent_log_messages' variable is set to True in the task's vars section. Requires installing Cisco IOS Ansible Collection. Useful for gathering detailed command/response traces for targeted troubleshooting of individual automation actions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: get version information\\n  cisco.ios.ios_command:\\n    commands:\\n      - show version\\n  vars:\\n    ansible_persistent_log_messages: True\n```\n\n----------------------------------------\n\nTITLE: Assigning Variables with a Lookup Plugin in Ansible Playbook (YAML+Jinja)\nDESCRIPTION: This snippet demonstrates assigning file contents to a variable within an Ansible playbook using the 'lookup' Jinja2 function and the 'file' plugin. It requires Ansible with Jinja2 enabled and a valid file path ('path/to/file.txt'). The 'file_contents' variable will store the returned file content as a string, to be used elsewhere in the playbook. The lookup executes on the control host, ensuring data fetched is available in other playbook constructs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_0\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n  vars:\n    file_contents: \"{{ lookup('file', 'path/to/file.txt') }}\"\n```\n\n----------------------------------------\n\nTITLE: Stopping Service with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Ensures that the 'httpd' service is stopped on all hosts within the 'webservers' group. It employs the `ansible.builtin.service` module with the argument `name=httpd state=stopped`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.service -a \"name=httpd state=stopped\"\n```\n\n----------------------------------------\n\nTITLE: Mocking External Command Execution in Ansible Modules - Python\nDESCRIPTION: Details how to mock 'AnsibleModule.run_command' within a test, controlling its return value and asserting call behavior, including that the command was called as expected. Includes assertions for exit handling via exception and call count validation. Designed for modules that invoke external processes and require their effects to be simulated in tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nwith patch.object(basic.AnsibleModule, 'run_command') as run_command:\\n    run_command.return_value = 0, '', ''  # successful execution, no output\\n    with self.assertRaises(AnsibleExitJson) as result:\\n        my_module.main()\\n        self.assertFalse(result.exception.args[0]['changed'])\\n# Check that run_command has been called\\nrun_command.assert_called_once_with('/usr/bin/command args')\\nself.assertEqual(run_command.call_count, 1)\\nself.assertFalse(run_command.called)\n```\n\n----------------------------------------\n\nTITLE: Installing a Specific Version of an Ansible Role from Galaxy\nDESCRIPTION: Illustrates how to install a specific version of a role from Ansible Galaxy by appending a comma and the version tag (e.g., `,3.2.0`) to the role name in the `ansible-galaxy role install` command. This requires the specified version tag (matching Semantic Versioning format) to exist on Galaxy for the role.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role install geerlingguy.apache,3.2.0\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to Ansible Test Plugins - YAML+Jinja\nDESCRIPTION: Shows various ways to pass positional and named parameters to test plugins within Ansible task conditionals. Requires Ansible execution environment and proper variable definitions (e.g., myurl, myvariable, sample_semver_var). Demonstrates passing a pattern as a positional argument to the 'match' test, using a named parameter for the 'truthy' test, and combining both positional and named parameters with 'version'. Outputs are booleans governing whether the given task is executed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/test.rst#_snippet_1\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n  tasks:\n  - name: pass a positional parameter to match test\n    action: dostuff\n    when: myurl is match(\"https://example.com/users/.*/resources\")\n\n  - name: pass named parameter to truthy test\n    action: dostuff\n    when: myvariable is truthy(convert_bool=True)\n\n  - name: pass both types to 'version' test\n    action: dostuff\n    when: sample_semver_var is version('2.0.0-rc.1+build.123', 'lt', version_type='semver')\n```\n\n----------------------------------------\n\nTITLE: Illustrating Basic Ansible Playbook File Layout (Text)\nDESCRIPTION: Shows a basic layout example with multiple playbook files (`site.yml`, `webservers.yml`, `fooservers.yml`) at the root level, setting the context for where roles typically reside relative to playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# playbooks\nsite.yml\nwebservers.yml\nfooservers.yml\n```\n\n----------------------------------------\n\nTITLE: Retrying a Task with `until`, `retries`, and `delay` in Ansible\nDESCRIPTION: This YAML task demonstrates using the `until` keyword to retry a `shell` command (`/usr/bin/foo`) until its standard output contains the string \"all systems go\". The task will retry up to 5 times (`retries: 5`), waiting 10 seconds (`delay: 10`) between attempts. The result of the command is registered in the `result` variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n.. code-block:: yaml\n\n    - name: Retry a task until a certain condition is met\n      ansible.builtin.shell: /usr/bin/foo\n      register: result\n      until: result.stdout.find(\"all systems go\") != -1\n      retries: 5\n      delay: 10\n```\n\n----------------------------------------\n\nTITLE: Configuring Asynchronous Tasks in Ansible Playbooks - YAML\nDESCRIPTION: This YAML snippet demonstrates the updated method for configuring asynchronous task execution in Ansible by setting the ansible_async_dir variable within a playbook task, replacing the deprecated ANSIBLE_ASYNC_DIR environment option. The code requires Ansible 2.12 or newer and applies a dnf task asynchronously (for 300 seconds, polling every 5). The ansible_async_dir variable points to a custom directory for async results. Inputs are standard Ansible task parameters; output is managed by Ansible's async task system.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.12.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - dnf:\n      name: '*'\n      state: latest\n    async: 300\n    poll: 5\n    vars:\n      ansible_async_dir: /path/to/my/custom/dir\n```\n\n----------------------------------------\n\nTITLE: Locating Ansible Host and Group Variable Files (Bash)\nDESCRIPTION: Illustrates the directory structure and file paths Ansible searches for loading variables using the `host_group_vars` plugin. It shows paths relative to `/etc/ansible/` for group variables (`group_vars/raleigh`, `group_vars/webservers`) and host variables (`host_vars/foosball`), noting that file extensions like `.yml`, `.yaml`, or `.json` are optional. This structure allows defining variables specific to groups or individual hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n/etc/ansible/group_vars/raleigh # can optionally end in '.yml', '.yaml', or '.json'\n/etc/ansible/group_vars/webservers\n/etc/ansible/host_vars/foosball\n```\n\n----------------------------------------\n\nTITLE: Using undef() for Template Variables in Ansible - YAML\nDESCRIPTION: This YAML code demonstrates the usage of the undef() function within variable declarations in Ansible. The snippet creates undefined variables (old, new, new_with_hint), where new_with_hint provides a message for users who must override the value. Ansible 2.12 or newer is required. Inputs are variable assignments, and output reflects undefined placeholders within playbook templates or roles, aiding in enforcing override requirements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.12.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  old: \"{{ undef }}\"\n  new: \"{{ undef() }}\"\n  new_with_hint: \"{{ undef(hint='You must override this variable') }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Database Server Group Variables in Ansible (YAML)\nDESCRIPTION: This snippet displays the content of the `group_vars/dbservers` file. It defines variables specific to hosts belonging to the `dbservers` group, such as MySQL service name (`mysqlservice`), port (`mysql_port`), database name (`dbname`), username (`dbuser`), and password (`upassword`). These variables configure the database servers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\nmysqlservice: mysqld\nmysql_port: 3306\ndbuser: root\ndbname: foodb\nupassword: usersecret\n\n```\n\n----------------------------------------\n\nTITLE: Setting Default AWS Region for Multiple Modules in Ansible YAML\nDESCRIPTION: This Ansible playbook demonstrates setting a default AWS region using a variable (`my_region`) for multiple related EC2 modules (`amazon.aws.ec2`, `community.aws.ec2_instance_info`, `amazon.aws.ec2_vpc_net_info`) via `module_defaults` at the play level. This ensures consistency across tasks interacting with AWS resources in that region.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\n- hosts: localhost\n  vars:\n    my_region: us-west-2\n  module_defaults:\n    amazon.aws.ec2:\n      region: '{{ my_region }}'\n    community.aws.ec2_instance_info:\n      region: '{{ my_region }}'\n    amazon.aws.ec2_vpc_net_info:\n      region: '{{ my_region }}'\n```\n\n----------------------------------------\n\nTITLE: Tagging Files as UTF-8 Using ansible.builtin.command (YAML)\nDESCRIPTION: This YAML snippet illustrates how to tag a text file on a z/OS UNIX node as UTF-8 using the ansible.builtin.command module. The code uses the chtag command to set the file's character set tag, which helps z/OS and related tools recognize its encoding and avoid misinterpretation. Requires the chtag utility on the remote system, and the file parameter (my_file.txt) should match the actual target file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Tag my_file.txt as UTF-8.\\n  ansible.builtin.command: chtag -tc iso8859-1 my_file.txt\n```\n\n----------------------------------------\n\nTITLE: Creating Dictionary from Flat List using Jinja2 `zip_longest`\nDESCRIPTION: This Jinja2 expression, used within Ansible `vars`, defines a dictionary `mydict` from a flat list `single_list` assuming alternating key-value pairs. It uses list slicing (`[::2]` for keys, `[1::2]` for values) and the `zip_longest` filter to pair up keys and values, which are then passed to the `dict` constructor to create the dictionary (`{\"a\": \"b\", \"c\": \"d\"}`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_10\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\nvars:\n    single_list: [ 'a', 'b', 'c', 'd' ]\n    mydict: \"{{ dict(single_list[::2] | zip_longest(single_list[1::2])) }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Task 'Changed' Status Based on Return Code (YAML)\nDESCRIPTION: This Ansible task uses the `changed_when` conditional to control whether the task is reported as having made a change. The `ansible.builtin.shell` module executes a command, and its result is registered in `bass_result`. The task will report 'changed' status only if the return code (`bass_result.rc`) is not equal to 2. This allows overriding the default change detection behavior based on specific criteria.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n  - name: Report 'changed' when the return code is not equal to 2\n    ansible.builtin.shell: /usr/bin/billybass --mode=\"take me to the river\"\n    register: bass_result\n    changed_when: \"bass_result.rc != 2\"\n```\n\n----------------------------------------\n\nTITLE: Applying Conditional Required Arguments - Ansible Python\nDESCRIPTION: This snippet details how to declare conditionally-required options with required_if in Ansible argument specs. The inner tuples denote the condition (option name and value) followed by a list of required arguments if the condition is true; a trailing True enforces that at least one in the list is set, trailing False or absent requires all. Used for complex parameter dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n('option_name', option_value, ('option_a', 'option_b', ...)),\n('option_name', option_value, ('option_a', 'option_b', ...), False),\n('option_name', option_value, ('option_a', 'option_b', ...), True),\n```\n\n----------------------------------------\n\nTITLE: Finding Specific Mount Point using Ansible Facts and Jinja2 Filters\nDESCRIPTION: This Ansible task uses the `debug` module to display the mount point containing the specified `path`. It filters the `ansible_facts.mounts` list using `selectattr` to find mounts where the `path` string starts with the mount point, sorts the results by 'mount' path length (implicitly by string sort), and selects the last (most specific) entry's 'mount' value. Requires `gather_facts: True` or equivalent fact gathering.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_5\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- hosts: all\n  gather_facts: True\n  vars:\n     path: /var/lib/cache\n  tasks:\n  - name: The mount point for {{path}}, found using the Ansible mount facts, [-1] is the same as the 'last' filter\n    ansible.builtin.debug:\n     msg: \"{{(ansible_facts.mounts | selectattr('mount', 'in', path) | list | sort(attribute='mount'))[-1]['mount']}}\"\n```\n\n----------------------------------------\n\nTITLE: Overriding Variables with undef() in Ansible Playbook - YAML\nDESCRIPTION: This snippet demonstrates the usage of the Jinja2 undef() function in an Ansible playbook written in YAML. The playbook shows how to temporarily override the 'vaulted_credentials' variable to an undefined state within a task block, allowing downstream modules and tasks to pick up variable precedence rules. The snippet depends on Ansible 2.12 or later, with Jinja2 templating enabled, and requires the presence of ns.col.module1 and ns.col.module2 modules. Inputs are inventory hosts, while output affects variable evaluation and module behavior; limitations include the scope of variable override and the need for jinja2.StrictUndefined to be respected.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_templating_undef.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- hosts: localhost\\n  gather_facts: no\\n  module_defaults:\\n    group/ns.col.auth: \"{{ vaulted_credentials | default({}) }}\"\\n  tasks:\\n    - ns.col.module1:\\n    - ns.col.module2:\\n\\n    - name: override host variable\\n      vars:\\n        vaulted_credentials: \"{{ undef() }}\"\\n      block:\\n        - ns.col.module1:\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Role Dependencies with Parameters in Ansible (YAML)\nDESCRIPTION: The `meta/main.yml` for a role ('car') that depends on the 'wheel' role multiple times, passing a different parameter 'n' for each instance. This forces the 'wheel' dependency to run multiple times as long as its own dependencies allow duplication or also receive differing parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\n---\ndependencies:\n  - role: wheel\n    n: 1\n  - role: wheel\n    n: 2\n  - role: wheel\n    n: 3\n  - role: wheel\n    n: 4\n```\n\n----------------------------------------\n\nTITLE: Using Escape Sequences in Double-Quoted YAML Strings\nDESCRIPTION: Illustrates the use of escape sequences (like '\\t' for tab and '\\n' for newline) within double-quoted strings in YAML. Single-quoted strings do not process escape sequences.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nfoo: \"a \\t TAB and a \\n NEWLINE\"\n```\n\n----------------------------------------\n\nTITLE: Creating Dictionary from List of Pairs using Jinja2 `dict`\nDESCRIPTION: This Jinja2 expression, used within Ansible `vars`, demonstrates the creation of a dictionary `mydict` directly from a `list_of_pairs` using the `dict` constructor. Each inner list `['key', 'value']` in `list_of_pairs` becomes a key-value pair in the resulting dictionary (`{\"a\": \"b\", \"c\": \"d\"}`). This is simpler if the input data is already paired.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_11\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\nvars:\n    list_of_pairs: [ ['a', 'b'], ['c', 'd'] ]\n    mydict: \"{{ dict(list_of_pairs) }}\"\n```\n\n----------------------------------------\n\nTITLE: Installing Services Asynchronously with Ansible Playbooks (YAML)\nDESCRIPTION: Demonstrates how to run service management tasks asynchronously using the 'async' keyword in an Ansible playbook, which is newly supported with action plugins in Ansible 2.3. No additional dependencies are required beyond standard Ansible installation. Key parameters include 'name' and 'state' for the service, with 'async' specifying the duration (in seconds) for asynchronous execution. The task will install and restart nginx, running up to 45 seconds in the background before being waited on or polled.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.3.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Install nginx asynchronously\\n  service:\\n    name: nginx\\n    state: restarted\\n  async: 45\n```\n\n----------------------------------------\n\nTITLE: Skipping an Entire Loop Task if Loop Variable (List) is Undefined in Ansible\nDESCRIPTION: This task shows how to prevent errors and skip the entire task if the list variable used in a loop (`mylist`) is undefined. The `|default([])` Jinja2 filter provides an empty list as the loop input if `mylist` doesn't exist, effectively skipping the loop iterations and the `when` condition check for items.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n    - name: Skip the whole task when a loop variable is undefined\n      ansible.builtin.command: echo {{ item }}\n      loop: \"{{ mylist|default([]) }}\"\n      when: item > 5\n```\n\n----------------------------------------\n\nTITLE: Ansible Role Directory Structure - Text\nDESCRIPTION: Shows the default directory and file hierarchy generated by 'ansible-galaxy role init'. This structure includes folders for defaults, handlers, meta, tasks, templates, tests, and vars. Key files like main.yml exist for role logic, while README.md and test files facilitate documentation and testing. Required as a starting template for most Ansible roles.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nrole_name/\n    README.md\n    defaults/\n        main.yml\n    files/\n    handlers/\n        main.yml\n    meta/\n        main.yml\n    tasks/\n        main.yml\n    templates/\n    tests/\n        inventory\n        test.yml\n    vars/\n        main.yml\n```\n\n----------------------------------------\n\nTITLE: Instantiating the Display Logger in Ansible 2.8+ - Python\nDESCRIPTION: This updated snippet illustrates the recommended approach for creating a Display object in Ansible 2.8 and later. Each file should directly import and instantiate ansible.utils.display.Display as a singleton, rather than relying on shared global state. The dependency is the ansible.utils.display module, and the output is an instance of Display for use in logging and output. The pattern is minimal and meant for script modernization.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.utils.display import Display\ndisplay = Display()\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: backup_file\nDESCRIPTION: Shows an example of the `backup_file` return key, indicating the path to the backup file created by a module when `backup=yes` is used and the original file was changed. This key is present for modules that manipulate files and support the `backup` parameter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n\"backup_file\": \"./foo.txt.32729.2020-07-30@06:24:19~\"\n```\n\n----------------------------------------\n\nTITLE: Defining an Ansible Lookup Plugin in Python\nDESCRIPTION: This Python code defines a custom Ansible Lookup plugin class `LookupModule` that inherits from `LookupBase`. The `run` method processes input terms (file paths), uses `find_file_in_search_path` to locate files, reads their contents using the loader's `_get_file_contents`, handles potential errors using Ansible's exception classes, and returns a list of file contents. It also demonstrates basic option handling with `set_options` and `get_option`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n    from ansible.errors import AnsibleError, AnsibleParserError\n    from ansible.plugins.lookup import LookupBase\n    from ansible.utils.display import Display\n\n    display = Display()\n\n    class LookupModule(LookupBase):\n\n        def run(self, terms, variables=None, **kwargs):\n\n          # First of all populate options,\n          # this will already take into account env vars and ini config\n          self.set_options(var_options=variables, direct=kwargs)\n\n          # lookups in general are expected to both take a list as input and output a list\n          # this is done so they work with the looping construct 'with_'.\n          ret = []\n          for term in terms:\n              display.debug(\"File lookup term: %s\" % term)\n\n              # Find the file in the expected search path, using a class method\n              # that implements the 'expected' search path for Ansible plugins.\n              lookupfile = self.find_file_in_search_path(variables, 'files', term)\n\n              # Don't use print or your own logging, the display class\n              # takes care of it in a unified way.\n              display.vvvv(u\"File lookup using %s as file\" % lookupfile)\n              try:\n                  if lookupfile:\n                      contents, show_data = self._loader._get_file_contents(lookupfile)\n                      ret.append(contents.rstrip())\n                  else:\n                      # Always use ansible error classes to throw 'final' exceptions,\n                      # so the Ansible engine will know how to deal with them.\n                      # The Parser error indicates invalid options passed\n                      raise AnsibleParserError()\n              except AnsibleParserError:\n                  raise AnsibleError(\"could not locate file in lookup: %s\" % term)\n\n              # consume an option: if this did something useful, you can retrieve the option value here\n              if self.get_option('option1') == 'do something':\n                pass\n\n          return ret\n```\n\n----------------------------------------\n\nTITLE: Configuring Cobbler Inventory Source - Text - Ansible\nDESCRIPTION: This snippet demonstrates how to configure Ansible to communicate with a Cobbler server for dynamic inventory. It shows the structure and key options for a cobbler.ini file, specifying the server address, cache path, and cache duration settings. Inputs are plain text configuration pairs; outputs are settings recognized by the cobbler.py script. The file must be saved into /etc/ansible as 'cobbler.ini', and may require permissions adjustments on the cobbler.py script.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[cobbler]\n\n# Set Cobbler's hostname or IP address\nhost = http://127.0.0.1/cobbler_api\n\n# API calls to Cobbler can be slow. For this reason, we cache the results of an API\n# call. Set this to the path you want cache files to be written to. Two files\n# will be written to this directory:\n#   - ansible-cobbler.cache\n#   - ansible-cobbler.index\n\ncache_path = /tmp\n\n# The number of seconds a cache file is considered valid. After this many\n# seconds, a new API call will be made, and the cache file will be updated.\n\ncache_max_age = 900\n```\n\n----------------------------------------\n\nTITLE: Ensuring List Input for Loops using 'query'\nDESCRIPTION: This example shows how to use the `query` Jinja2 function with the `inventory_hostnames` lookup plugin. `query` guarantees that the output is a list, which is the required input format for the `loop` keyword.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_21\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nloop: \"{{ query('inventory_hostnames', 'all') }}\"\n```\n\n----------------------------------------\n\nTITLE: Recommended Use of 'dummy' Variable in Python Loop\nDESCRIPTION: This Python code snippet illustrates the Ansible-recommended practice for handling unused loop variables. It replaces the discouraged underscore `_` with the identifier `dummy` in a `for` loop designed for retrying an operation (`retry_thing`). This adheres to Ansible's coding standards, ensuring compatibility with potential future internationalization efforts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-underscore-variable.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. code-block:: python\n\n    for dummy in range(0, retries):\n        success = retry_thing()\n        if success:\n            break\n```\n\n----------------------------------------\n\nTITLE: Controlling Fact Delegation with `delegate_facts` in Ansible\nDESCRIPTION: The `delegate_facts: True` parameter, when applied to an Ansible task or block (often used with `delegate_to`), modifies the default fact handling behavior. It prevents facts gathered or set by the delegated task from being associated with the original host (`inventory_hostname`), ensuring they are only set on the host the task was delegated *to*.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\ndelegate_facts: True\n```\n\n----------------------------------------\n\nTITLE: Updating Task Variables in the Ansible Debugger - Ansible Output\nDESCRIPTION: This snippet demonstrates how to inspect and update a task variable ('pkg_name') within the Ansible debugger. It walks through printing the variable, setting it to a new value, loading the updated variable set with 'update_task', and re-executing the task. The context assumes a failed task in a running playbook, with a dependency on the Ansible debugger. Input is the debugger commands; output reflects the variable's value at each step and task retry.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_12\n\nLANGUAGE: ansible-output\nCODE:\n```\n[192.0.2.10] TASK: install package (debug)> p task_vars['pkg_name']\nu'not_exist'\n[192.0.2.10] TASK: install package (debug)> task_vars['pkg_name'] = 'bash'\n[192.0.2.10] TASK: install package (debug)> p task_vars['pkg_name']\n'bash'\n[192.0.2.10] TASK: install package (debug)> update_task\n[192.0.2.10] TASK: install package (debug)> redo\n\n```\n\n----------------------------------------\n\nTITLE: Using Abbreviated Flow Collections in YAML\nDESCRIPTION: Illustrates the abbreviated 'flow collection' syntax for dictionaries (using '{}') and lists (using '[]'). While valid YAML, Ansible doesn't frequently use this style.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\nmartin: {name: Martin D'vloper, job: Developer, skill: Elite}\nfruits: ['Apple', 'Orange', 'Strawberry', 'Mango']\n```\n\n----------------------------------------\n\nTITLE: Replacing with_flattened with Loop and Flatten Filter in Ansible YAML+Jinja\nDESCRIPTION: Replaces with_flattened by utilizing the loop and the flatten filter to handle multi-level lists. It outputs debug messages for each atomic list value. Expects an 'items' variable that may contain nested lists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_flattened\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_flattened: \"{{ items }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_flattened -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ items|flatten }}\"\n```\n\n----------------------------------------\n\nTITLE: Structuring Documentation for Ansible Vars Plugins in Python\nDESCRIPTION: This Python snippet demonstrates the standard `DOCUMENTATION` block format for defining metadata and documentation within an Ansible vars plugin file. It includes essential fields like `name`, `version_added`, `short_description`, `description`, and `options`. It also shows how to extend documentation using fragments like `vars_plugin_staging` for common option patterns (e.g., controlling execution stage).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n    DOCUMENTATION = '''\n        name: custom_hostvars\n        version_added: \"2.10\"  # for collections, use the collection version, not the Ansible version\n        short_description: Load custom host vars\n        description: Load custom host vars\n        options:\n          stage:\n            ini:\n              - key: stage\n                section: vars_custom_hostvars\n            env:\n              - name: ANSIBLE_VARS_PLUGIN_STAGE\n        extends_documentation_fragment:\n          - vars_plugin_staging\n    '''\n```\n\n----------------------------------------\n\nTITLE: Referencing an Element from a List Variable using Jinja2 Indexing\nDESCRIPTION: This snippet shows how to access a specific element from a list variable (`region`) using Jinja2 bracket notation. `region[0]` retrieves the first element ('northeast') from the previously defined `region` list.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n  region: \"{{ region[0] }}\"\n```\n\n----------------------------------------\n\nTITLE: Using Percentage Value with Serial in Ansible Playbook (YAML)\nDESCRIPTION: Demonstrates how to specify a batch size as a percentage using the 'serial' keyword (e.g., \"30%\") in a playbook, meaning Ansible divides the host group into batches based on the given percent. Applies to inventories with arbitrary numbers of hosts; actual batch size is the numeric result of percentage calculation. No extra dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: test play\\n  hosts: webservers\\n  serial: \"30%\"\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Ansible Inventory Structure - YAML\nDESCRIPTION: This YAML snippet sets up a basic Ansible inventory with logical groupings for leaf, spine, network, webservers, and datacenter devices. Each group contains hosts referenced by their hostnames and IP addresses. The structure follows Ansible best practices for group naming and demonstrates group-of-groups (children) relationships. No special dependencies except Ansible itself and use of inventory plugins supporting YAML are required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\nleafs:\n  hosts:\n    leaf01:\n      ansible_host: 10.16.10.11\n    leaf02:\n      ansible_host: 10.16.10.12\n\nspines:\n  hosts:\n    spine01:\n      ansible_host: 10.16.10.13\n    spine02:\n      ansible_host: 10.16.10.14\n\nnetwork:\n  children:\n    leafs:\n    spines:\n\nwebservers:\n  hosts:\n    webserver01:\n      ansible_host: 10.16.10.15\n    webserver02:\n      ansible_host: 10.16.10.16\n\ndatacenter:\n  children:\n    network:\n    webservers:\n\n```\n\n----------------------------------------\n\nTITLE: Validating Conversion to Bytes Using human_to_bytes - Ansible YAML/Jinja\nDESCRIPTION: This snippet validates string representations of data sizes as they are converted to bytes using the 'human_to_bytes' filter in Ansible. It asserts equivalence between expected byte values and filter output for different input formats including KB, MB, GB, and bit forms. Dependencies are Ansible with the human_to_bytes filter available. Inputs are formatted strings or numbers, with outputs being assertion pass/fail results. It is constrained by the correctness of input formats and filter behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_18\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: \"Human to Bytes\"\n  assert:\n    that:\n      - \"{{'0'|human_to_bytes}}        == 0\"\n      - \"{{'0.1'|human_to_bytes}}      == 0\"\n      - \"{{'0.9'|human_to_bytes}}      == 1\"\n      - \"{{'1'|human_to_bytes}}        == 1\"\n      - \"{{'10.00 KB'|human_to_bytes}} == 10240\"\n      - \"{{   '11 MB'|human_to_bytes}} == 11534336\"\n      - \"{{  '1.1 GB'|human_to_bytes}} == 1181116006\"\n      - \"{{'10.00 Kb'|human_to_bytes(isbits=True)}} == 10240\"\n```\n\n----------------------------------------\n\nTITLE: Advanced Inventory Graph Output Including Custom Groups (text)\nDESCRIPTION: Presents the hierarchical output after applying constructed options in aws_ec2 YAML inventory source, demonstrating automatically generated groups such as development, role_Webserver, and tag-based groupings. Useful for validating grouping logic and plugin dynamic group features. Intended for inspection, not direct execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n@all:\\n  |--@aws_ec2:\\n  |  |--ec2-12-345-678-901.compute-1.amazonaws.com\\n  |  |--ec2-98-765-432-10.compute-1.amazonaws.com\\n  |  |--...\\n  |--@development:\\n  |  |--ec2-12-345-678-901.compute-1.amazonaws.com\\n  |  |--ec2-98-765-432-10.compute-1.amazonaws.com\\n  |--@role_Webserver\\n  |  |--ec2-12-345-678-901.compute-1.amazonaws.com\\n  |--@tag_Name_ECS_Instance:\\n  |  |--ec2-98-765-432-10.compute-1.amazonaws.com\\n  |--@tag_Name_Test_Server:\\n  |  |--ec2-12-345-678-901.compute-1.amazonaws.com\\n  |--@ungrouped\n```\n\n----------------------------------------\n\nTITLE: Extending Documentation Fragments in Ansible Collections (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to extend Ansible module documentation by referencing shared documentation fragments from both the same and external collections using FQCNs. No special dependencies are required beyond having the referenced fragments available in the target collection's doc_fragments directory. The parameter extends_documentation_fragment takes a list of FQCNs that point to reusable documentation fragments. This technique enables reusability and consistency in module documentation across collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_shared.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nextends_documentation_fragment:\n  - kubernetes.core.k8s_name_options\n  - kubernetes.core.k8s_auth_options\n  - kubernetes.core.k8s_resource_options\n  - kubernetes.core.k8s_scale_options\n```\n\n----------------------------------------\n\nTITLE: Asserting No Module Failure with Mock Objects in Python Unit Tests\nDESCRIPTION: This snippet shows how to use a mock module object (`MagicMock`) in a Python unit test for an Ansible module function. After calling the function under test (`function_to_test`), it asserts that the mock module's `fail_json` method was not called, ensuring the function executed without triggering a failure exit.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmodule = MagicMock()\nfunction_to_test(module, argument)\nmodule.fail_json.assert_not_called()\n```\n\n----------------------------------------\n\nTITLE: Replacing with_list Loops using Loop Keyword in Ansible YAML+Jinja\nDESCRIPTION: Demonstrates how to migrate legacy with_list constructs to use the modern loop keyword in Ansible task definitions. Both variants render a debug message for each list element. No additional dependencies required. Inputs are provided as literal lists; outputs are the evaluated messages per item.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_list\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_list:\n    - one\n    - two\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_list -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop:\n    - one\n    - two\n```\n\n----------------------------------------\n\nTITLE: Defining Role Dependencies (Namespace Format) in meta/main.yml (YAML)\nDESCRIPTION: This YAML snippet demonstrates defining multiple role dependencies within `meta/main.yml` using the standard `namespace.role_name` format, suitable for roles sourced from Ansible Galaxy. Both `geerlingguy.apache` and `geerlingguy.ansible` are listed as dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  - geerlingguy.apache\n  - geerlingguy.ansible\n```\n\n----------------------------------------\n\nTITLE: Replacing with_dict with Loop and dict2items/dictsort Filters in Ansible YAML+Jinja\nDESCRIPTION: Shows two approaches to replace with_dict using loop with either dict2items or dictsort filters, enabling key-value iteration over a dictionary variable. Inputs are dictionary structures; outputs use either named (item.key/item.value) or tuple (item.0/item.1) referencing, depending on the filter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_dict\n  ansible.builtin.debug:\n    msg: \"{{ item.key }} - {{ item.value }}\"\n  with_dict: \"{{ dictionary }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_dict -> loop (option 1)\n  ansible.builtin.debug:\n    msg: \"{{ item.key }} - {{ item.value }}\"\n  loop: \"{{ dictionary|dict2items }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_dict -> loop (option 2)\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }}\"\n  loop: \"{{ dictionary|dictsort }}\"\n```\n\n----------------------------------------\n\nTITLE: Parsing Network Command Output with ntc_templates in Ansible\nDESCRIPTION: This Ansible task uses `ansible.utils.cli_parse` to execute the `show interface` command on a network device. It leverages the `ansible.netcommon.ntc_templates` parser, which uses the `ntc_templates` Python library and associated TextFSM templates to parse the output based on the device's `ansible_network_os`. The structured data is stored in the `interfaces` fact.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"Run command and parse with ntc_templates\"\n  ansible.utils.cli_parse:\n    command: show interface\n    parser:\n      name: ansible.netcommon.ntc_templates\n    set_fact: interfaces\n```\n\n----------------------------------------\n\nTITLE: Delegating Tasks and Managing Serial Execution in Ansible Playbooks (YAML)\nDESCRIPTION: Illustrates delegating tasks to the control node (127.0.0.1) from hosts in the 'webservers' group using the delegate_to keyword. Shows usage of serial execution, Ansible command module, and yum module to manage load balancer pool operations before and after updating package stacks. Dependencies: Ansible core modules (command, yum), inventory with 'webservers.' Inputs are host inventory and task definitions, outputs are the result of delegated tasks. Limitation: Delegate target must be SSH-accessible and may require relevant permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  serial: 5\n\n  tasks:\n    - name: Take out of load balancer pool\n      ansible.builtin.command: /usr/bin/take_out_of_pool {{ inventory_hostname }}\n      delegate_to: 127.0.0.1\n\n    - name: Actual steps would go here\n      ansible.builtin.yum:\n        name: acme-web-stack\n        state: latest\n\n    - name: Add back to load balancer pool\n      ansible.builtin.command: /usr/bin/add_back_to_pool {{ inventory_hostname }}\n      delegate_to: 127.0.0.1\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible CLI Connection for Cisco NXOS (YAML)\nDESCRIPTION: Example `group_vars/nxos.yml` configuration for connecting to Cisco NXOS devices using the CLI method over SSH. It specifies the connection type (`ansible.netcommon.network_cli`), network OS, user credentials (using Ansible Vault for passwords), privilege escalation settings (`become` for enable mode), and optionally configures SSH arguments for using a bastion/jump host via `ProxyCommand`. Remove `ansible_password` if using SSH keys and `ansible_ssh_common_args` if not using a bastion host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nxos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: cisco.nxos.nxos\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nansible_become_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Network Inventory Groups and Variables (INI format)\nDESCRIPTION: This snippet shows a sample Ansible inventory file written in INI format for organizing network switches (Arista EOS, Cisco IOS, Vyos), defining host groups and associating connection, authentication, and privilege escalation variables per group. Key parameters include ansible_connection, ansible_network_os, ansible_user, ansible_password, ansible_become, and ansible_become_method. It demonstrates grouping, nested groups, and variable precedence at the group level. Inputs are hostnames and connection info; outputs are inventory mappings that Ansible uses for subsequent automation tasks. Sensitive fields should be encrypted or securely managed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[all:vars]\n# these defaults can be overridden for any group in the [group:vars] section\nansible_connection=ansible.netcommon.network_cli\nansible_user=ansible\n\n[switches:children]\neos\nios\nvyos\n\n[eos]\nveos01 ansible_host=veos-01.example.net\nveos02 ansible_host=veos-02.example.net\nveos03 ansible_host=veos-03.example.net\nveos04 ansible_host=veos-04.example.net\n\n[eos:vars]\nansible_become=yes\nansible_become_method=enable\nansible_network_os=arista.eos.eos\nansible_user=my_eos_user\nansible_password=my_eos_password\n\n[ios]\nios01 ansible_host=ios-01.example.net\nios02 ansible_host=ios-02.example.net\nios03 ansible_host=ios-03.example.net\n\n[ios:vars]\nansible_become=yes\nansible_become_method=enable\nansible_network_os=cisco.ios.ios\nansible_user=my_ios_user\nansible_password=my_ios_password\n\n[vyos]\nvyos01 ansible_host=vyos-01.example.net\nvyos02 ansible_host=vyos-02.example.net\nvyos03 ansible_host=vyos-03.example.net\n\n[vyos:vars]\nansible_network_os=vyos.vyos.vyos\nansible_user=my_vyos_user\nansible_password=my_vyos_password\n\n```\n\n----------------------------------------\n\nTITLE: Using String Matching Tests in Ansible YAML\nDESCRIPTION: Illustrates how to use the `match`, `search`, and `regex` Jinja tests within Ansible tasks' `when` conditions to perform string comparisons using regular expressions against a URL variable. `match` checks the start of the string, `search` checks anywhere, and `regex` offers more control via `match_type`. Optional `ignorecase` and `multiline` arguments corresponding to Python's re.I and re.M flags are available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  url: \"https://example.com/users/foo/resources/bar\"\n\ntasks:\n    - debug:\n        msg: \"matched pattern 1\"\n      when: url is match(\"https://example.com/users/.*/resources\")\n\n    - debug:\n        msg: \"matched pattern 2\"\n      when: url is search(\"users/.*/resources/.*\")\n\n    - debug:\n        msg: \"matched pattern 3\"\n      when: url is search(\"users\")\n\n    - debug:\n        msg: \"matched pattern 4\"\n      when: url is regex(\"example\\.com/\\w+/foo\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Task File with Tagged and Untagged Tasks in Ansible - YAML\nDESCRIPTION: This YAML snippet ('mixed.yml') demonstrates a tasks file with a mix of tagged and untagged tasks, including a block containing subtasks. It shows how to define tasks with/without tags and block-level tagging, which allows for applying tags to multiple child tasks. Blocks encapsulate related tasks and can inherit tags for grouped execution. Requires Ansible core and assumes this file will be included or imported elsewhere in a playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n# mixed.yml\\ntasks:\\n- name: Run the task with no tags\\n  ansible.builtin.debug:\\n    msg: this task has no tags\\n\\n- name: Run the tagged task\\n  ansible.builtin.debug:\\n    msg: this task is tagged with mytag\\n  tags: mytag\\n\\n- block:\\n  - name: Run the first block task with mytag\\n    # ...\\n  - name: Run the second block task with mytag\\n    # ...\\n  tags:\\n  - mytag\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: failed\nDESCRIPTION: Shows the `failed` boolean return value. This key indicates whether the task encountered an error and failed (`true` if failed, `false` otherwise).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n\"failed\": false\n```\n\n----------------------------------------\n\nTITLE: Tags in Block Error Handling - Block, Rescue, and Always (YAML)\nDESCRIPTION: This snippet shows how block-level tagging interacts with Ansible's 'block', 'rescue', and 'always' sections. Tags set on block tasks might prevent 'rescue' or 'always' tasks from running if they're not appropriately tagged. Requires understanding of Ansible error handling. Important fields are 'block', 'rescue', 'always', 'tags', and task modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- block:\n  - debug: msg=run with tag, but always fail\n    failed_when: true\n    tags: example\n\n  rescue:\n  - debug: msg=I always run because the block always fails, except if you select to only run 'example' tag\n\n  always:\n  - debug: msg=I always run, except if you select to only run 'example' tag\n\n```\n\n----------------------------------------\n\nTITLE: Subscript Access of Group Members - Host Selection (Python-like Syntax)\nDESCRIPTION: This Python-style code shows subscripting to reference specific hosts within a group: 0-based indexing, negative indices from end. Used for slice operations in host patterns. Requires a group defined in the inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nwebservers[0]       # == cobweb\\nwebservers[-1]      # == weber\n```\n\n----------------------------------------\n\nTITLE: Running All Unit Tests for Ansible Collections using ansible-test\nDESCRIPTION: Executes all unit tests for an Ansible collection across all supported Python versions using the `ansible-test units` command within a default Docker container. The `--docker default` flag indicates the testing environment, and `-v` provides verbose output. Unit tests should reside in the `tests/unit/plugins/` directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_testing.rst#_snippet_1\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-test units --docker default -v\n```\n\n----------------------------------------\n\nTITLE: Assigning Host Variables in YAML Inventory - Ansible Inventory - YAML\nDESCRIPTION: Shows how to set host variables for specific hosts in a YAML-formatted Ansible inventory. This approach ensures correct type parsing and is less error-prone compared to INI. The example assigns HTTP port and maxRequestsPerChild parameters per host under the 'atlanta' group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\natlanta:\\n  hosts:\\n    host1:\\n      http_port: 80\\n      maxRequestsPerChild: 808\\n    host2:\\n      http_port: 303\\n      maxRequestsPerChild: 909\n```\n\n----------------------------------------\n\nTITLE: Combining Roles and Collections in requirements.yml (YAML)\nDESCRIPTION: This example demonstrates a `requirements.yml` file that defines both Ansible roles and collections. Roles are listed under the `roles` key (specifying name and exact version), while collections are listed under the `collections` key (allowing version ranges and source specification). This allows managing both types of dependencies in a single file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_multiple_collections.txt#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\nroles:\n  # Install a role from Ansible Galaxy.\n  - name: geerlingguy.java\n    version: \"1.9.6\" # note that ranges are not supported for roles\n\n\ncollections:\n  # Install a collection from Ansible Galaxy.\n  - name: geerlingguy.php_roles\n    version: \">=0.9.3\"\n    source: https://galaxy.ansible.com\n```\n\n----------------------------------------\n\nTITLE: Illustrating Forbidden Multi-Pass Templating Error in Ansible Expressions\nDESCRIPTION: This Ansible playbook snippet demonstrates an insecure pattern disallowed in Ansible 12: embedding a template (`{{ value }}`) directly within a conditional expression. Ansible 12's overhauled templating engine prevents this multi-pass templating, raising a syntax error ('Template delimiters are not supported in expressions'). Variables should be referenced directly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_9\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: 1 + {{ value }} == 2\n  vars:\n    value: 1\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions Compatibly in Python 2/3 using 'as'\nDESCRIPTION: Shows the recommended exception handling syntax using `except ExceptionType as e:` which is compatible with Python 2.6+ and Python 3. The example catches a `ValueError` during division by zero and uses `module.fail_json` for reporting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    a = 2/0\nexcept ValueError as e:\n    module.fail_json(msg=\"Tried to divide by zero: %s\" % e)\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Embedding Custom Modules in an Ansible Role (Text)\nDESCRIPTION: Shows the directory structure for embedding custom Ansible modules within a role. Custom modules are placed inside a 'library' subdirectory within the role's main directory (`roles/my_custom_modules/library/`) and become available to this role and subsequent roles in the play.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_26\n\nLANGUAGE: text\nCODE:\n```\nroles/\n    my_custom_modules/\n        library/\n            module1\n            module2\n```\n\n----------------------------------------\n\nTITLE: Running CLI Module Command for IOS-XR with Ansible (YAML)\nDESCRIPTION: An Ansible playbook task for retrieving system version details from a Cisco IOS-XR device using the iosxr_command module. This snippet requires the Cisco IOS-XR Ansible collection and is conditioned on matching the network_os variable. The 'commands' parameter specifies the device command to execute, with output returned in module results. Requires remote access credentials set in inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_iosxr.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve IOS-XR version\\n  cisco.iosxr.iosxr_command:\\n    commands: show version\\n  when: ansible_network_os == 'cisco.iosxr.iosxr'\\n\n```\n\n----------------------------------------\n\nTITLE: Replacing with_indexed_items Using Loop, Flatten, and loop_control.index_var in Ansible YAML+Jinja\nDESCRIPTION: Shows how to replace with_indexed_items with a combination of loop, flatten, and loop_control.index_var to provide item indices. The refactored code exposes the item and its corresponding index variable for use in debug messages. Input is a list variable 'items'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_2\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_indexed_items\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }}\"\n  with_indexed_items: \"{{ items }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_indexed_items -> loop\n  ansible.builtin.debug:\n    msg: \"{{ index }} - {{ item }}\"\n  loop: \"{{ items|flatten(levels=1) }}\"\n  loop_control:\n    index_var: index\n```\n\n----------------------------------------\n\nTITLE: Jinja Test for Successful Result - Ansible Playbook YAML\nDESCRIPTION: This snippet shows the new 'successful' test introduced in Ansible 2.5 as a grammatically clear alias for 'success', used in a 'when' clause: 'result is successful'. It is used for Boolean expressions in playbook task conditionals. Input is a task result variable. This pattern is the recommended replacement for older filter-based test usage.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nwhen: result is successful\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbook with Encrypted Vars and Password File (Bash)\nDESCRIPTION: Demonstrates running an `ansible-playbook` command that utilizes variables from an encrypted file (`secrets.enc`). The command specifies the location of the vault password file (`secrets.pass`) using the `--vault-password-file` flag, allowing Ansible to decrypt the necessary content.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_managing_passwords.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --extra-vars @secrets.enc --vault-password-file secrets.pass\n```\n\n----------------------------------------\n\nTITLE: Configuring Localhost in Inventory File - Ansible Inventory - Bash\nDESCRIPTION: This snippet configures 'localhost' in the Ansible inventory to use the 'local' connection and a specific Python interpreter path. It is useful when you want to execute playbooks against the control node itself, ensuring that Ansible leverages the correct Python environment. This line should be added to the inventory file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlocalhost ansible_connection=local ansible_python_interpreter=\"/usr/bin/env python\"\\n\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbooks with Tag Options - Bash\nDESCRIPTION: This group contains several Bash commands for executing an Ansible playbook ('example.yml') with different tag and skip-tag options. These commands illustrate: running all tasks, running only tasks with specific tags, skipping tasks, including those with 'never', or combining tag filters. Requires Ansible installed and a valid 'example.yml'. Command-line syntax: '--tags', '--skip-tags', with comma-separated tag lists in quotes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml --tags \\\"configuration,packages\\\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml --skip-tags \\\"packages\\\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml --tags \\\"all,never\\\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml --tags \\\"tag1,tag3\\\" --skip-tags \\\"tag4\\\"\n```\n\n----------------------------------------\n\nTITLE: Setting SSH Password Mechanism via Ansible Variable (YAML)\nDESCRIPTION: Provides an example of setting the SSH password handling mechanism within Ansible's variable system (e.g., in playbooks or inventory). Assigning the value `sshpass` to the `ansible_ssh_password_mechanism` variable configures the SSH connection plugin to utilize the `sshpass` program.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\nansible_ssh_password_mechanism: sshpass\n```\n\n----------------------------------------\n\nTITLE: Defining Variables Using Supported Dictionary Syntax - Ansible YAML\nDESCRIPTION: This snippet highlights the recommended way to define variables in Ansible playbooks using a dictionary under 'vars', replacing the deprecated list-of-dictionaries syntax. This change improves clarity and future compatibility, as providing a list of dictionaries to 'vars' is deprecated. No external packages are required; inputs are key-value pairs, and the playbook expects explicit mappings under 'vars'. Limitation: list syntax for 'vars' may be removed in future Ansible versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_8.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\\n  - var1: foo\\n  - var2: bar\n```\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\\n  var1: foo\\n  var2: bar\n```\n\n----------------------------------------\n\nTITLE: Triggering an Included Task File as a Handler in Ansible (YAML)\nDESCRIPTION: This Ansible playbook snippet demonstrates defining a handler named 'Restart services' which uses `include_tasks` to dynamically run tasks from an external file (`restarts.yml`). This handler is triggered by the `notify` directive in the main task, causing the entire included file to execute as the handler action.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n       - name: Restart services\n         include_tasks: restarts.yml\n     tasks:\n       - command: \"true\"\n         notify: Restart services\n```\n\n----------------------------------------\n\nTITLE: Delegating QA Scripts from Testing Server in Ansible Rolling Update Playbook in YAML\nDESCRIPTION: Extends the rolling update playbook example to delegate a QA script execution from a dedicated testing server to target nodes, before reintroducing them into the load balancer. Highlights use of 'delegate_to' for remote execution and running infrastructure script-based tests. Prerequisites: accessible 'app_testing_script.sh', proper inventory/host configuration, and secure SSH connectivity.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\n- hosts: webservers\n  serial: 5\n\n  pre_tasks:\n\n    - name: take out of load balancer pool\n      ansible.builtin.command: /usr/bin/take_out_of_pool {{ inventory_hostname }}\n      delegate_to: 127.0.0.1\n\n  roles:\n\n     - common\n     - webserver\n\n  tasks:\n     - ansible.builtin.script: /srv/qa_team/app_testing_script.sh --server {{ inventory_hostname }}\n       delegate_to: testing_server\n\n  post_tasks:\n\n    - name: add back to load balancer pool\n      ansible.builtin.command: /usr/bin/add_back_to_pool {{ inventory_hostname }}\n      delegate_to: 127.0.0.1\n```\n\n----------------------------------------\n\nTITLE: Implementing the verify_file Method for File Pattern Matching in Python\nDESCRIPTION: This Python snippet shows an implementation of the `verify_file` method within an Ansible inventory plugin (`InventoryModule`). Its purpose is to quickly determine if a given inventory source path is potentially valid for this plugin. It first calls the base class's `verify_file` to check existence and readability, then checks if the path ends with specific YAML file extensions related to VirtualBox. This pre-filtering helps optimize the inventory process by avoiding attempts to parse unsuitable files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef verify_file(self, path):\n    ''' return true/false if this is possibly a valid file for this plugin to consume '''\n    valid = False\n    if super(InventoryModule, self).verify_file(path):\n        # base class verifies that file exists and is readable by current user\n        if path.endswith(('virtualbox.yaml', 'virtualbox.yml', 'vbox.yaml', 'vbox.yml')):\n            valid = True\n    return valid\n```\n\n----------------------------------------\n\nTITLE: Overriding Settings with Extra Variables in Ansible Shell\nDESCRIPTION: Demonstrates the highest precedence level using extra variables (`-e` or `--extra-vars`) on the command line. Despite specifying `-u carol` via a standard command-line option, the `-e 'ansible_user=brian'` extra variable overrides it, causing the `whoami` command to execute as the user `brian`, highlighting the power of extra vars to supersede other configuration methods.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nansible -u carol -e 'ansible_user=brian' -a whoami all\n```\n\n----------------------------------------\n\nTITLE: Configuring Delegation for Ansible Plugins (YAML+Jinja)\nDESCRIPTION: This snippet provides YAML inventory variables for enabling Kerberos delegation in Ansible’s psrp, winrm, and ssh connection plugins. Each setting activates credential delegation for its respective plugin. Ansible inventory should include these host variables or group variables as required for your environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# psrp\nansible_psrp_negotiate_delegate: true\n\n# winrm\nansible_winrm_kerberos_delegation: true\n\n# ssh\nansible_ssh_common_args: -o GSSAPIDelegateCredentials=yes\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with ansible-test - Shell\nDESCRIPTION: These shell commands provide different ways to run Ansible unit tests across the codebase, on individual files or modules, targetting specific Python versions, and obtaining help for more advanced usage. Dependencies include sourcing the appropriate environment and having ansible-test installed. Parameters include the target scope (directory, module, or file) and options like --docker, --python, and verbosity. The outputs differ based on the command used, ranging from test results to help summaries.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd /path/to/ansible/source\\nsource hacking/env-setup\\nansible-test units --docker -v\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units --docker -v apt\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units --docker -v --python 2.7 apt\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units --docker -v test/units/module_utils/basic/test_imports.py\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units --help\n```\n\n----------------------------------------\n\nTITLE: Setting Python Interpreter Path in Ansible Inventory for BSD\nDESCRIPTION: This INI snippet shows how to define the Python interpreter path for groups of BSD hosts in the Ansible inventory. It sets 'ansible_python_interpreter' to '/usr/local/bin/python' for the 'freebsd' group and '/usr/local/bin/python3' for the 'openbsd' group, ensuring Ansible uses the correct Python binary.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[freebsd:vars]\nansible_python_interpreter=/usr/local/bin/python\n[openbsd:vars]\nansible_python_interpreter=/usr/local/bin/python3\n```\n\n----------------------------------------\n\nTITLE: Referencing Roles and Plugins from Collections Using FQCNs (YAML+Jinja)\nDESCRIPTION: Shows multiple examples of tasks referencing roles, modules, and plugins from collections using their FQCNs, including the use of a role import, custom modules, and inline Jinja filters/lookups. Dependencies include installed collections and Ansible core; plugins used in Jinja must exist in the specified collection. Inputs include inventory hosts and module parameters; outputs vary depending on the tasks invoked.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n     - name: Reference collections contents using their FQCNs\\n       hosts: all\\n       tasks:\\n\\n         - name: Import a role\\n           ansible.builtin.import_role:\\n             name: my_namespace.my_collection.role1\\n\\n         - name: Call a module\\n           my_namespace.mycollection.my_module:\\n             option1: value\\n\\n         - name: Call a debug task\\n           ansible.builtin.debug:\\n             msg: '{{ lookup(\"my_namespace.my_collection.lookup1\", \"param1\") | my_namespace.my_collection.filter1 }}'\n```\n\n----------------------------------------\n\nTITLE: Registering Output from a Loop in Ansible\nDESCRIPTION: This YAML+Jinja task demonstrates registering the output of a task that uses a `loop`. The `ansible.builtin.shell` module executes `echo` for each item in the list. The `register: echo` statement captures the results of all iterations into the `echo` variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_11\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n   - name: Register loop output as a variable\n     ansible.builtin.shell: \"echo {{ item }}\"\n     loop:\n       - \"one\"\n       - \"two\"\n     register: echo\n```\n\n----------------------------------------\n\nTITLE: Using Variables for Environment Settings in Ansible Tasks (YAML)\nDESCRIPTION: This example shows how to define environment settings as a dictionary variable (`proxy_env`) in the `vars` section of a play and then apply it to a task using the `environment` keyword with variable interpolation (`\"{{ proxy_env }}\"`). This promotes reusability of environment configurations across multiple tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_environment.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  remote_user: root\n\n  # create a variable named \"proxy_env\" that is a dictionary\n  vars:\n    proxy_env:\n      http_proxy: http://proxy.example.com:8080\n\n  tasks:\n\n    - name: Install cobbler\n      ansible.builtin.package:\n        name: cobbler\n        state: present\n      environment: \"{{ proxy_env }}\"\n```\n\n----------------------------------------\n\nTITLE: Generating a Comprehensive Ansible Configuration File (ansible.cfg) with Plugins using Console\nDESCRIPTION: This command utilizes `ansible-config init --disabled -t all` to generate a more complete `ansible.cfg` file. In addition to the core Ansible settings, it includes configuration sections for all available plugins (connection, lookup, callback, etc.) detected in the environment. The `--disabled` flag comments out all settings, and the output is redirected to the `ansible.cfg` file. Requires Ansible to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_configuration.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ ansible-config init --disabled -t all > ansible.cfg\n```\n\n----------------------------------------\n\nTITLE: Testing Delegatability of an AD User (PowerShell)\nDESCRIPTION: This PowerShell function determines whether a specified Active Directory user account is allowed to be delegated for Kerberos authentication. It leverages the .NET ADSISearcher class to locate the user object by sAMAccountName and checks for flags that control delegation status. Requires the script to run with privileges to read AD properties within the domain. Parameters include UserName (mandatory). Output is error on user-not-found or status bitfield for delegation eligibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_11\n\nLANGUAGE: powershell\nCODE:\n```\nFunction Test-IsDelegatable {\n    [CmdletBinding()]\n    param (\n        [Parameter(Mandatory)]\n        [string]\n        $UserName\n    )\n\n    $NOT_DELEGATED = 0x00100000\n\n    $searcher = [ADSISearcher]\"(&(objectClass=user)(objectCategory=person)(sAMAccountName=$UserName))\"\n    $res = $searcher.FindOne()\n    if (-not $res) {\n        Write-Error -Message \"Failed to find user '$UserName'\"\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Hosts in an Inventory Group Using Jinja2 (Jinja)\nDESCRIPTION: This Jinja2 for loop shows how to iterate over all hosts in the 'app_servers' group in an Ansible inventory. Intended for template expansion or dynamic file generation, it allows lines or blocks to be rendered for every host in the group. Assumes 'groups' variable is available in template context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_14\n\nLANGUAGE: jinja\nCODE:\n```\n{% for host in groups['app_servers'] %}\\n   # something that applies to all app servers.\\n{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Correctly Creating Directories with the `file` Module (Ansible Shell)\nDESCRIPTION: This example shows the recommended way to create a directory using the Ansible `file` module in version 2.6 and later. The full desired path (`/tmp/lib`) should be specified directly in the `path` parameter when `state=directory`, avoiding the problematic interaction with the `src` parameter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.6.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible localhost -m file -a 'path=/tmp/lib state=directory'\n```\n\n----------------------------------------\n\nTITLE: Exporting Functions from PowerShell Module Utility\nDESCRIPTION: This PowerShell snippet uses 'Export-ModuleMember' to expose specific functions from a module util. Any PowerShell module_util must export at least one function so that its features can be consumed by importing modules. List function names in the -Function parameter; these then become available for use by modules importing the util.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_10\n\nLANGUAGE: powershell\nCODE:\n```\nExport-ModuleMember -Function Invoke-CustomUtil, Get-CustomInfo\n```\n\n----------------------------------------\n\nTITLE: Tracking Loop Index with 'loop_control' and 'index_var'\nDESCRIPTION: This task demonstrates how to track the current iteration index within a loop. By setting `index_var: my_idx` under `loop_control`, the 0-based index of the current loop iteration becomes available in the `my_idx` variable. The `ansible.builtin.debug` module then prints both the item and its corresponding index.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_26\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Count our fruit\n  ansible.builtin.debug:\n    msg: \"{{ item }} with index {{ my_idx }}\"\n  loop:\n    - apple\n    - banana\n    - pear\n  loop_control:\n    index_var: my_idx\n```\n\n----------------------------------------\n\nTITLE: Initializing Base Properties within the parse Method in Python\nDESCRIPTION: This snippet shows the initial part of the `parse` method in an Ansible inventory plugin. It assigns the passed `loader` (Ansible's DataLoader), `inventory` (the inventory object to be populated), and initializes a `Templar` instance (for Jinja2 templating) to instance variables (`self.loader`, `self.inventory`, `self.templar`). This setup makes these core Ansible objects readily available for use throughout the parsing logic. Assumes `Templar` is imported (likely from `ansible.template`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n   def parse(self, inventory, loader, path, cache=True):\n\n        self.loader = loader\n        self.inventory = inventory\n        self.templar = Templar(loader=loader)\n```\n\n----------------------------------------\n\nTITLE: FQCN Role Reference in Ansible Collection (Python)\nDESCRIPTION: Demonstrates how to reference a role within a collection using its Fully Qualified Collection Name in Python syntax. No imports required for the reference itself; used in documentation and playbooks to ensure clarity in role calling convention. Input is the namespace, collection, and role name, and the output is the correct FQCN identifier.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmynamespace.mycollection.role1\\n\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Setup and Template Modules - Bash - Ansible Commands\nDESCRIPTION: This snippet shows how to use Ansible ad-hoc commands to gather host facts and deploy a template file using inventory-sourced variables. It demonstrates the 'setup' module for gathering system facts and the 'template' module for rendering a Jinja2 MOTD. The input includes the inventory group and template/source/destination paths; outputs are on-host configuration changes or fact collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible webserver -m setup\nansible webserver -m template -a \"src=/tmp/motd.j2 dest=/etc/motd\"\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Ansible Inventory (INI)\nDESCRIPTION: Illustrates a simple Ansible inventory file using the INI format. It shows hosts listed directly (implicitly in the 'ungrouped' group) and hosts organized under specific group names indicated by brackets (e.g., `[webservers]`, `[dbservers]`). This format is often found in `/etc/ansible/hosts`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nmail.example.com\n\n[webservers]\nfoo.example.com\nbar.example.com\n\n[dbservers]\none.example.com\ntwo.example.com\nthree.example.com\n```\n\n----------------------------------------\n\nTITLE: Simplifying Network Command Execution with cli_command - YAML\nDESCRIPTION: This snippet features use of the Ansible ansible.netcommon.cli_command module in blocks tailored for each network OS (Arista EOS, Cisco IOS, VyOS), with each block running a command and displaying the result. This pattern reduces the number of conditionals and tasks compared to platform-specific modules. Prerequisites include ansible.netcommon collection, network_cli connection configuration, and relevant group variables or hostvars. Inputs are the command strings and device facts; outputs are command results displayed by the debug task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- hosts: network\\n  gather_facts: false\\n  connection: ansible.netcommon.network_cli\\n\\n  tasks:\\n    - name: Run cli_command on Arista and display results\\n      block:\\n      - name: Run cli_command on Arista\\n        ansible.netcommon.cli_command:\\n          command: show ip int br\\n        register: result\\n\\n      - name: Display result to terminal window\\n        debug:\\n          var: result.stdout_lines\\n      when: ansible_network_os == 'arista.eos.eos'\\n\\n    - name: Run cli_command on Cisco IOS and display results\\n      block:\\n      - name: Run cli_command on Cisco IOS\\n        ansible.netcommon.cli_command:\\n          command: show ip int br\\n        register: result\\n\\n      - name: Display result to terminal window\\n        debug:\\n          var: result.stdout_lines\\n      when: ansible_network_os == 'cisco.ios.ios'\\n\\n    - name: Run cli_command on Vyos and display results\\n      block:\\n      - name: Run cli_command on Vyos\\n        ansible.netcommon.cli_command:\\n          command: show interfaces\\n        register: result\\n\\n      - name: Display result to terminal window\\n        debug:\\n          var: result.stdout_lines\\n      when: ansible_network_os == 'vyos.vyos.vyos'\n```\n\n----------------------------------------\n\nTITLE: Using Group Variables in Ansible Inventory - YAML\nDESCRIPTION: This YAML inventory illustrates moving repeated variable assignments (like ansible_network_os and ansible_user) under group-level 'vars' for leafs, spines, and webservers. This practice improves scalability and maintainability by centralizing shared configuration. It requires only standard Ansible support for group variables in YAML format and is ideal for large or consistent device groups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\nleafs:\n  hosts:\n    leaf01:\n      ansible_host: 10.16.10.11\n    leaf02:\n      ansible_host: 10.16.10.12\n  vars:\n    ansible_network_os: vyos.vyos.vyos\n    ansible_user: my_vyos_user\n\nspines:\n  hosts:\n    spine01:\n      ansible_host: 10.16.10.13\n    spine02:\n      ansible_host: 10.16.10.14\n  vars:\n    ansible_network_os: vyos.vyos.vyos\n    ansible_user: my_vyos_user\n\nnetwork:\n  children:\n    leafs:\n    spines:\n\nwebservers:\n  hosts:\n    webserver01:\n      ansible_host: 10.16.10.15\n    webserver02:\n      ansible_host: 10.16.10.16\n  vars:\n    ansible_user: my_server_user\n\ndatacenter:\n  children:\n    network:\n    webservers:\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Debugger on Task Failure (YAML)\nDESCRIPTION: This Ansible task uses the `debugger` keyword set to `on_failed`. This means the Ansible debugger will be invoked specifically for this task if, and only if, the task fails during playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Execute a command\n  ansible.builtin.command: \"false\"\n  debugger: on_failed\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a List of Hashes with `loop` in Ansible\nDESCRIPTION: This YAML+Jinja task demonstrates how to iterate over a list of dictionaries (hashes) using the `loop` keyword. Inside the loop, `item.name` and `item.groups` are used to access the subkeys of the current dictionary item (`item`) being processed by the `ansible.builtin.user` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_9\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - name: Add several users\n      ansible.builtin.user:\n        name: \"{{ item.name }}\"\n        state: present\n        groups: \"{{ item.groups }}\"\n      loop:\n        - { name: 'testuser1', groups: 'wheel' }\n        - { name: 'testuser2', groups: 'root' }\n```\n\n----------------------------------------\n\nTITLE: Executing a Playbook Task Asynchronously with Polling (YAML/Ansible)\nDESCRIPTION: Defines an Ansible playbook task using the 'command' module to run '/bin/sleep 15' asynchronously. The 'async' parameter sets the maximum runtime allowed (in seconds), and 'poll' sets the polling interval. The task is non-blocking only during polling but will not allow the playbook to progress until completion or timeout. Requires Ansible and Python on targets. Outputs result or timeout. Suitable for handling slow operations without SSH timeout.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\n- hosts: all\n  remote_user: root\n\n  tasks:\n\n  - name: Simulate long running op (15 sec), wait for up to 45 sec, poll every 5 sec\n    ansible.builtin.command: /bin/sleep 15\n    async: 45\n    poll: 5\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a Dictionary using `dict2items` Filter in Ansible\nDESCRIPTION: This YAML+Jinja task shows how to iterate over the key-value pairs of a dictionary (`tag_data`) using the `loop` keyword combined with the `dict2items` Jinja2 filter. For each item, `item.key` provides the dictionary key and `item.value` provides the corresponding value, which are then printed using `ansible.builtin.debug`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - name: Using dict2items\n      ansible.builtin.debug:\n        msg: \"{{ item.key }} - {{ item.value }}\"\n      loop: \"{{ tag_data | dict2items }}\"\n      vars:\n        tag_data:\n          Environment: dev\n          Application: payment\n```\n\n----------------------------------------\n\nTITLE: Including External Variable Files - Ansible - YAML\nDESCRIPTION: Shows how to include variables from an external YAML file using vars_files in a playbook. Variables defined in external files are made available for use elsewhere in the playbook, promoting variable reuse and separation. Inputs are the file paths; outputs are the loaded variables. The referenced files must exist and be valid YAML dictionaries.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\n- hosts: all\n  remote_user: root\n  vars:\n    favcolor: blue\n  vars_files:\n    - /vars/external_vars.yml\n\n  tasks:\n\n  - name: This is just a placeholder\n    ansible.builtin.command: /bin/echo foo\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic List in YAML\nDESCRIPTION: Illustrates a simple YAML list containing strings (fruit names). Each list item starts with a dash and a space ('- '). The optional '---' and '...' indicate the start and end of a YAML document.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# A list of tasty fruits\n- Apple\n- Orange\n- Strawberry\n- Mango\n...\n```\n\n----------------------------------------\n\nTITLE: Looping Over Dictionary Keys Portably in Ansible (YAML/Jinja2)\nDESCRIPTION: Demonstrates how to iterate over the keys of a dictionary variable in an Ansible playbook, ensuring compatibility between Python2 and Python3 by using the 'list' filter with hosts.keys() in the loop directive. The snippet includes commented code showing the Python2-only approach (using hosts.keys()) and the portable approach (using hosts.keys() | list). Dependencies include Ansible, Jinja2 templating, and variable definitions. Inputs are an Ansible variable 'hosts' as a dictionary; the output is a loop iterating over its keys, printing each with debug. Note that using the list filter is required for cross-version compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_python_version.rst#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    vars:\n      hosts:\n        testhost1: 127.0.0.2\n        testhost2: 127.0.0.3\n    tasks:\n      - debug:\n          msg: '{{ item }}'\n        # Only works with Python 2\n        #loop: \"{{ hosts.keys() }}\"\n        # Works with both Python 2 and Python 3\n        loop: \"{{ hosts.keys() | list }}\"\n```\n\n----------------------------------------\n\nTITLE: Iterating with with_items Lookup in Ansible Tasks (YAML+Jinja)\nDESCRIPTION: This snippet shows how to perform a debug operation for each item in a sequence by using the 'with_items' lookup in an Ansible task. The loop iterates over a static list [1, 2, 3], outputting each value. Ansible and Jinja2 are required, with the debug module available; the output for each task item will be the current list element. This approach is commonly used for repetitive operations across item lists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_1\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n  tasks:\n    - name: count to 3\n      debug: msg={{ item }}\n      with_items: [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Running the Same Role Multiple Times with Different Variables - Ansible YAML\nDESCRIPTION: This example demonstrates running the app_user role multiple times in a playbook, each with a distinct value for the myname variable. This pattern enables flexible, repeated configuration tasks using the same role with different user-specific data. The 'vars' under each role controls the effective variables during each invocation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_26\n\nLANGUAGE: yaml\nCODE:\n```\nroles:\\n   - role: app_user\\n     vars:\\n        myname: Ian\\n   - role: app_user\\n     vars:\\n       myname: Terry\\n   - role: app_user\\n     vars:\\n       myname: Graham\\n   - role: app_user\\n     vars:\\n       myname: John\n```\n\n----------------------------------------\n\nTITLE: Setting Play-Level Environment Variables in Ansible (YAML)\nDESCRIPTION: This example demonstrates setting an environment variable (`http_proxy`) at the play level using the `environment` keyword. This setting applies to all tasks executed within this play for the specified hosts (`testing`), ensuring consistent environment settings for the entire play execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_environment.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: testing\n\n  roles:\n     - php\n     - nginx\n\n  environment:\n    http_proxy: http://proxy.example.com:8080\n```\n\n----------------------------------------\n\nTITLE: Comparing `with_items` Flattening Behavior in Ansible\nDESCRIPTION: This YAML snippet demonstrates the implicit single-level flattening behavior of `with_items` when iterating over a list containing nested lists. This behavior needs to be replicated explicitly using `flatten(1)` when converting to the `loop` keyword.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n.. code-block:: yaml\n\n  with_items:\n    - 1\n    - [2,3]\n    - 4\n```\n\n----------------------------------------\n\nTITLE: Defining an Extended Ansible Playbook for Network Configuration Management using YAML\nDESCRIPTION: This YAML file presents an extended version of the first playbook, named \"Network Getting Started First Playbook Extended\". It includes tasks to: get initial facts, display them, update the device's hostname using the `vyos.vyos.vyos_config` module, get the facts again to reflect the change, and display the updated configuration. This demonstrates a more complete configuration management cycle within a single playbook, including making changes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Network Getting Started First Playbook Extended\n  hosts: all\n  gather_facts: false\n  connection: ansible.netcommon.network_cli\n\n  tasks:\n\n    - name: Get config for VyOS devices\n      vyos.vyos.vyos_facts:\n        gather_subset: '!all'\n        gather_network_resources:\n          - config\n\n    - name: Display the config\n      debug:\n        msg: \"The hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}\"\n\n    - name: Update the hostname\n      vyos.vyos.vyos_config:\n        lines:\n          - set system host-name vyos-changed\n        save: true\n\n    - name: Get changed config for VyOS devices\n      vyos.vyos.vyos_facts:\n        gather_subset: '!all'\n        gather_network_resources:\n          - config\n\n    - name: Display the changed config\n      debug:\n        msg: \"The new hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}\"\n```\n\n----------------------------------------\n\nTITLE: Advanced aws_ec2 Inventory Plugin Configuration with Constructed Features (yaml)\nDESCRIPTION: Describes a detailed YAML inventory source for the aws_ec2 plugin, featuring constructed dynamic groups, custom host variable composition, and automatic group assignments based on tag analysis. Key options demonstrated include keyed_groups, groups, and compose for variable transformation and grouping logic. File must be .yml or .yaml for automatic plugin loading. Intended for complex, tag-driven infrastructure organization.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n# demo.aws_ec2.yml\\nplugin: amazon.aws.aws_ec2\\nregions:\\n  - us-east-1\\n  - us-east-2\\nkeyed_groups:\\n  # add hosts to tag_Name_value groups for each aws_ec2 host's tags.Name variable\\n  - key: tags.Name\\n    prefix: tag_Name_\\n    separator: \"\"\\n  # If you have a tag called \"Role\" which has the value \"Webserver\", this will add the group\\n  # role_Webserver and add any hosts that have that tag assigned to it.\\n  - key: tags.Role\\n    prefix: role\\ngroups:\\n  # add hosts to the group development if any of the dictionary's keys or values is the word 'devel'\\n  development: \"'devel' in (tags|list)\"\\n  # add hosts to the \"private_only\" group if the host doesn't have a public IP associated to it\\n  private_only: \"public_ip_address is not defined\"\\ncompose:\\n  # use a private address where a public one isn't assigned\\n  ansible_host: public_ip_address|default(private_ip_address)\\n  # alternatively, set the ansible_host variable to connect with the private IP address without changing the hostname\\n  # ansible_host: private_ip_address\\n  # if you *must* set a string here (perhaps to identify the inventory source if you have multiple\\n  # accounts you want to use as sources), you need to wrap this in two sets of quotes, either ' then \"\\n  # or \" then '\\n  some_inventory_wide_string: '\"Yes, you need both types of quotes here\"'\n```\n\n----------------------------------------\n\nTITLE: Parsing Command Output with TTP using Ansible `cli_parse` (YAML)\nDESCRIPTION: This Ansible task demonstrates using the `ansible.utils.cli_parse` module to execute the `show interface` command and parse its output using the TTP parser (`ansible.utils.ttp`). It assumes a TTP template exists at the default path (e.g., `templates/nxos_show_interface.ttp`) and stores the parsed data in the `interfaces` fact.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: \"Run command and parse with ttp\"\n     ansible.utils.cli_parse:\n       command: show interface\n       parser:\n         name: ansible.utils.ttp\n       set_fact: interfaces\n```\n\n----------------------------------------\n\nTITLE: Grouping Tasks with Ansible Blocks in YAML\nDESCRIPTION: This Ansible playbook snippet demonstrates grouping related tasks using a 'block'. A 'when' condition and privilege escalation directives ('become', 'become_user') applied to the block are inherited by all nested tasks (installing packages, applying a template, starting a service). 'ignore_errors: true' ensures the playbook continues even if tasks within the block fail.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_blocks.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Install, configure, and start Apache\n    when: ansible_facts['distribution'] == 'CentOS'\n    block:\n      - name: Install httpd and memcached\n        ansible.builtin.yum:\n          name:\n          - httpd\n          - memcached\n          state: present\n\n      - name: Apply the foo config template\n        ansible.builtin.template:\n          src: templates/src.j2\n          dest: /etc/foo.conf\n\n      - name: Start service bar and enable it\n        ansible.builtin.service:\n          name: bar\n          state: started\n          enabled: True\n    become: true\n    become_user: root\n    ignore_errors: true\n```\n\n----------------------------------------\n\nTITLE: Executing Playbook and Checking Outputs - Console\nDESCRIPTION: These snippets show how to execute an Ansible playbook from the shell, review its summary output, and verify the backup and facts files using standard Linux commands. The main dependencies are the presence of Ansible, a proper inventory, and configuration files; commands included focus on running ansible-playbook, checking playbook recap, reading result files, and locating backup directories. Inputs are CLI commands, outputs are console results indicating task status and file locations; these are not programmatic but are essential operational steps for users.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\nansible-playbook -i inventory facts-demo.yml\n```\n\nLANGUAGE: console\nCODE:\n```\nPLAY RECAP\\neos01.example.net          : ok=7    changed=2    unreachable=0    failed=0\\nios01.example.net          : ok=7    changed=2    unreachable=0    failed=0\\nvyos01.example.net         : ok=6    changed=2    unreachable=0    failed=0\n```\n\nLANGUAGE: console\nCODE:\n```\ncat /tmp/switch-facts\n```\n\nLANGUAGE: console\nCODE:\n```\nfind /tmp/backups\n```\n\n----------------------------------------\n\nTITLE: Safely Using Variables in Handler Parameters in Ansible (YAML+Jinja)\nDESCRIPTION: Demonstrates the recommended approach for variable handling in handlers: keeping handler names static and templating variables within task/module parameters. Uses include_vars to load per-distribution configuration and defaults service name via Jinja filters. Facilitates dynamic service control without risk of handler naming conflicts or runtime errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_7\n\nLANGUAGE: yaml+jinja\nCODE:\n```\ntasks:\\n  - name: Set host variables based on distribution\\n    include_vars: \"{{ ansible_facts.distribution }}.yml\"\\n\\nhandlers:\\n  - name: Restart web service\\n    ansible.builtin.service:\\n      name: \"{{ web_service_name | default('httpd') }}\"\\n      state: restarted\\n\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Prompts with cli_command - YAML\nDESCRIPTION: This task illustrates the use of cli_command with interactive CLI operations requiring multiple prompts and responses, such as changing passwords. The module accepts 'prompt' and 'answer' lists, and processes them in order, with check_all ensuring all prompts must be matched. Inputs include a list of configuration commands; outputs are applied configuration changes on the device. This pattern is crucial for automating complex CLI flows. Ansible.netcommon collection is required, and all prompt/answer pairs must be correct for success.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: Change password to default\\n  ansible.netcommon.cli_command:\\n    command: \"{{ item }}\"\\n    prompt:\\n      - \"New password\"\\n      - \"Retype new password\"\\n    answer:\\n      - \"mypassword123\"\\n      - \"mypassword123\"\\n    check_all: True\\n  loop:\\n    - \"configure\"\\n    - \"rollback\"\\n    - \"set system root-authentication plain-text-password\"\\n    - \"commit\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Module Requirements with #AnsibleRequires and #Requires in PowerShell\nDESCRIPTION: This snippet features various examples of how to use PowerShell and Ansible-specific '#Requires' and '#AnsibleRequires' statements at the top of a module script to declare dependencies. It covers importing module utilities, specifying minimum PowerShell or OS versions, and making certain utilities optionally imported. These statements help Ansible and PowerShell enforce that required modules, versions, utilities, or privileges are available before the script runs. They do not require explicit dependency checking code in the script but affect execution by failing early if requirements are unmet.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Imports the PowerShell Ansible.ModuleUtils.Legacy provided by Ansible itself\n#AnsibleRequires -PowerShell Ansible.ModuleUtils.Legacy\n\n# Imports the PowerShell my_util in the my_namesapce.my_name collection\n#AnsibleRequires -PowerShell ansible_collections.my_namespace.my_name.plugins.module_utils.my_util\n\n# Imports the PowerShell my_util that exists in the same collection as the current module\n#AnsibleRequires -PowerShell ..module_utils.my_util\n\n# Imports the PowerShell Ansible.ModuleUtils.Optional provided by Ansible if it exists.\n# If it does not exist then it will do nothing.\n#AnsibleRequires -PowerShell Ansible.ModuleUtils.Optional -Optional\n\n# Imports the C# Ansible.Process provided by Ansible itself\n#AnsibleRequires -CSharpUtil Ansible.Process\n\n# Imports the C# my_util in the my_namespace.my_name collection\n#AnsibleRequires -CSharpUtil ansible_collections.my_namespace.my_name.plugins.module_utils.my_util\n\n# Imports the C# my_util that exists in the same collection as the current module\n#AnsibleRequires -CSharpUtil ..module_utils.my_util\n\n# Imports the C# Ansible.Optional provided by Ansible if it exists.\n# If it does not exist then it will do nothing.\n#AnsibleRequires -CSharpUtil Ansible.Optional -Optional\n```\n\n----------------------------------------\n\nTITLE: Assigning Host Variables in INI Inventory - Ansible Inventory - Text\nDESCRIPTION: Demonstrates how to define host-level variables directly in an INI-formatted Ansible inventory file, using key=value syntax inline after each hostname. Each host in the [atlanta] group is assigned unique variables. No dependencies are required; input is the inventory file, and output is availability of host variables in playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n[atlanta]\\nhost1 http_port=80 maxRequestsPerChild=808\\nhost2 http_port=303 maxRequestsPerChild=909\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Role Multiple Times with Different Parameters (List Item Syntax) (YAML)\nDESCRIPTION: Illustrates another syntax for running an Ansible role ('foo') multiple times in a play by assigning different parameters directly as keys under each role entry in the `roles` list.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - role: foo\n      message: \"first\"\n    - role: foo\n      message: \"second\"\n```\n\n----------------------------------------\n\nTITLE: Expanded Logic of Conditional Import in Ansible\nDESCRIPTION: This snippet illustrates the effective behavior of the conditional import example. It shows how Ansible conceptually applies the `when: x is not defined` condition to *both* the `set_fact` task and the `debug` task from the imported `other_tasks.yml` file. Consequently, if 'x' is initially undefined, the first task runs and defines 'x', causing the second task's condition to become false, thus skipping it.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Set a variable if not defined\n  ansible.builtin.set_fact:\n    x: foo\n  when: x is not defined\n  # this task sets a value for x\n\n- name: Do the task if \"x\" is not defined\n  ansible.builtin.debug:\n    var: x\n  when: x is not defined\n  # Ansible skips this task, because x is now defined\n```\n\n----------------------------------------\n\nTITLE: Backing Up Dell OS10 Configuration using Ansible Task (YAML)\nDESCRIPTION: An example Ansible task that utilizes the `dellemc.os10.os10_config` module to perform a backup of the current configuration on a Dell OS10 switch. The task sets the `backup` parameter to `yes`, registers the output (containing the backup location) into the `backup_dellos10_location` variable, and includes a `when` condition to ensure it only runs on hosts identified as `dellemc.os10.os10`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_dellos10.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (dellos10)\n  dellemc.os10.os10_config:\n    backup: yes\n  register: backup_dellos10_location\n  when: ansible_network_os == 'dellemc.os10.os10'\n```\n\n----------------------------------------\n\nTITLE: Correct YAML Syntax for Variable Assignment (Using Quotes)\nDESCRIPTION: This YAML snippet shows the correct way to define a variable `app_path` whose value starts with a Jinja2 expression `{{ base_path }}`. The entire string value must be enclosed in quotes to ensure valid YAML syntax and proper parsing by Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - hosts: app_servers\n      vars:\n        app_path: \"{{ base_path }}/22\"\n```\n\n----------------------------------------\n\nTITLE: Nesting Groups and Assigning Group Variables in YAML - Ansible Inventory - YAML\nDESCRIPTION: Provides the YAML approach for creating hierarchically nested host groups with variables assigned at different levels. Parent-child relationships are represented by 'children', and group-scoped variables reside under 'vars'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\nusa:\\n  children:\\n    southeast:\\n      children:\\n        atlanta:\\n          hosts:\\n            host1:\\n            host2:\\n        raleigh:\\n          hosts:\\n            host2:\\n            host3:\\n      vars:\\n        some_server: foo.southeast.example.com\\n        halon_system_timeout: 30\\n        self_destruct_countdown: 60\\n        escape_pods: 2\\n    northeast:\\n    northwest:\\n    southwest:\n```\n\n----------------------------------------\n\nTITLE: Setting Ansible Strategy via Environment Variable (Ansible, Shell)\nDESCRIPTION: This shell snippet demonstrates setting the ANSIBLE_STRATEGY environment variable to select the 'free' strategy for play execution in Ansible. Requires a working Ansible installation and a shell environment. The export statement should be executed in the shell prior to running Ansible commands. The variable influences only the execution context in which it is set and does not persist across sessions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/strategy.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_STRATEGY=free\n```\n\n----------------------------------------\n\nTITLE: Logging Out and Releasing Tokens - Ansible HTTPAPI Python\nDESCRIPTION: Implements a logout method for an httpapi plugin to invalidate and clear authentication tokens by making an explicit API request. Relies on send_request for HTTP calls. No input parameters. After successfully hitting the logout endpoint, cleans up the plugin's connection._auth attribute to ensure tokens are not retained between sessions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef logout(self):\\n    logout_path = '/my/logout/path'\\n    self.send_request(None, path=logout_path)\\n\\n    # Clean up tokens\\n    self.connection._auth = None\\n\n```\n\n----------------------------------------\n\nTITLE: Advanced with_together Example: Zipping Multiple Lists with Loop in Ansible YAML+Jinja\nDESCRIPTION: An advanced example where the loop with zip filter aggregates more than two lists using unpacking syntax and Jinja2's list/zip abilities. It requires a variable 'data', which is a list of equal-length lists. The result is a combination of the ith element from each sublist.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_together -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }} - {{ item.2 }}\"\n  loop: \"{{ data[0]|zip(*data[1:])|list }}\"\n  vars:\n    data:\n      - ['a', 'b', 'c']\n      - ['d', 'e', 'f']\n      - ['g', 'h', 'i']\n```\n\n----------------------------------------\n\nTITLE: Searching Ansible Galaxy Roles via CLI\nDESCRIPTION: Demonstrates using the `ansible-galaxy role search` command to find roles on Ansible Galaxy. This example searches for roles containing 'elasticsearch' and filters by the author 'geerlingguy'. Requires the `ansible-galaxy` command-line tool to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role search elasticsearch --author geerlingguy\n```\n\n----------------------------------------\n\nTITLE: Configuring L3 Interface using Ansible ios_l3_interfaces Module - YAML\nDESCRIPTION: This snippet shows an Ansible playbook task that configures a Layer 3 interface on a Cisco IOS device using the cisco.ios.ios_l3_interfaces resource module. Dependencies include the Ansible collection cisco.ios, and the 'config' variable must be defined. The 'state' parameter determines how provided configuration merges with the device. Outputs depend on the chosen state (e.g., merged, replaced, deleted).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: configure l3 interface\\n  cisco.ios.ios_l3_interfaces:\\n    config: \\\"{{ config }}\\\"\\n    state: <state>\n```\n\n----------------------------------------\n\nTITLE: Specifying Absolute Path for Ansible Role Usage (YAML)\nDESCRIPTION: Demonstrates defining a role in a playbook by specifying its absolute filesystem path. This method bypasses the standard Ansible role search paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - role: '/path/to/my/roles/common'\n```\n\n----------------------------------------\n\nTITLE: Enabling NX-API on Cisco NXOS using Ansible CLI Connection (YAML)\nDESCRIPTION: Example Ansible task demonstrating how to enable the NX-API feature on a Cisco NXOS device using the `cisco.nxos.nxos_nxapi` module. This task requires an initial CLI connection (SSH) to be established. It enables both HTTP and HTTPS access for NX-API. The task runs conditionally based on the `ansible_network_os` variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nxos.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Enable NX-API\n  cisco.nxos.nxos_nxapi:\n    enable_http: yes\n    enable_https: yes\n  when: ansible_network_os == 'cisco.nxos.nxos'\n```\n\n----------------------------------------\n\nTITLE: Configuring Extended Loop Variables\nDESCRIPTION: This configuration snippet shows how to enable extended loop variables within `loop_control` by setting `extended: true`. When enabled, variables like `ansible_loop.index`, `ansible_loop.first`, `ansible_loop.last`, `ansible_loop.previtem`, etc., become available within the loop, providing more context about the loop's state. This is not a runnable task, but part of the `loop_control` configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_27\n\nLANGUAGE: none\nCODE:\n```\nloop_control:\n  extended: true\n```\n\n----------------------------------------\n\nTITLE: Orchestrating Roles and Serial Execution - Ansible Playbook - YAML\nDESCRIPTION: This YAML code demonstrates a simple Ansible playbook orchestrating common and web application roles for 'webservers', and common plus content roles for 'content_servers'. The serial field ensures only five webservers are updated at a time for controlled rolling deployments. Prerequisites are a working Ansible installation and defined role directories. Inputs include group names and roles as defined in the user's Ansible environment, and outputs are applied role tasks on specified hosts. The playbook must be placed in a readable location and run with ansible-playbook; all tasks execute as per the task order in the playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/overview_architecture.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- hosts: webservers\\n  serial: 5 # update 5 machines at a time\\n  roles:\\n  - common\\n  - webapp\\n\\n- hosts: content_servers\\n  roles:\\n  - common\\n  - content\n```\n\n----------------------------------------\n\nTITLE: Outputting Host Variables for a Specific Host in JSON for Ansible Inventory Script - JSON\nDESCRIPTION: This JSON snippet shows the structure for host-specific variables returned when the inventory script is called with --host <hostname>. The snippet should be dynamically generated by the script for each host. Dependencies include a callable inventory script and Ansible expecting a valid JSON response. Key parameters include host variable keys and values, determined by the inventory designer. An empty object or key-value pairs may be returned; output must be valid JSON.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"VAR001\": \"VALUE\",\n    \"VAR002\": \"VALUE\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing an Ansible Inventory Plugin with Constructable and Cacheable Features in Python\nDESCRIPTION: This Python code snippet illustrates how to add advanced features to an Ansible inventory plugin by inheriting from multiple base classes. Besides `BaseInventoryPlugin`, it includes `Constructable` (likely for dynamic group/variable creation) and `Cacheable` (for utilizing Ansible's caching mechanism). This allows the plugin (`InventoryModule` named 'myplugin') to leverage built-in Ansible functionalities for improved performance and flexibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.inventory import BaseInventoryPlugin, Constructable, Cacheable\n\nclass InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):\n\n    NAME = 'myplugin'\n```\n\n----------------------------------------\n\nTITLE: Filtering Lists with Select Filters and Ansible Tests - YAML+Jinja\nDESCRIPTION: Illustrates the application of test plugins with Jinja2 'select' and related filters to process lists in Ansible, such as extracting defined variables and filtering by attribute values. Assumes availability of relevant lists (all_vars, all_addresses) and the standard Jinja2/Ansible execution context. Key filters demonstrated include 'select', 'selectattr', and 'rejectattr' in combination with 'defined' and 'equalto' tests. Inputs are lists of objects or variables; outputs are filtered sublists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/test.rst#_snippet_2\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n   # give me only defined variables from a list of variables, using 'defined' test\n   good_vars: \"{{ all_vars|select('defined') }}\"\n\n   # this uses the 'equalto' test to filter out non 'fixed' type of addresses from a list\n   only_fixed_addresses:  \"{{ all_addresses|selectattr('type', 'equalto', 'fixed') }}\"\n\n   # this does the opposite of the previous one\n   only_fixed_addresses:  \"{{ all_addresses|rejectattr('type', 'equalto', 'fixed') }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Aliases for the Same Host in YAML - Ansible Inventory - YAML\nDESCRIPTION: YAML example showing two inventory aliases (jumper1 and jumper2) both mapping to the same host/port, enabling multiple-target scenarios for one endpoint. Type handling is reliable in YAML files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n# ...\\n  hosts:\\n    jumper1:\\n      ansible_port: 5555\\n      ansible_host: 192.0.2.50\\n    jumper2:\\n      ansible_port: 5555\\n      ansible_host: 192.0.2.50\n```\n\n----------------------------------------\n\nTITLE: Setting and Resetting OpenSSH Default Shell - Windows - PowerShell\nDESCRIPTION: This PowerShell script changes the OpenSSH default shell between PowerShell and cmd.exe by manipulating the Windows registry. The script demonstrates both setting the default shell to powershell.exe using `New-ItemProperty` and reverting back to cmd.exe with `Remove-ItemProperty`. Administrative rights and proper use of registry paths are required. Inputs include registry path and value parameters, with outputs being persistent configuration changes that affect future SSH sessions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Set default to powershell.exe\n$shellParams = @{\n    Path         = 'HKLM:\\SOFTWARE\\OpenSSH'\n    Name         = 'DefaultShell'\n    Value        = 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe'\n    PropertyType = 'String'\n    Force        = $true\n}\nNew-ItemProperty @shellParams\n\n# Set default back to cmd.exe\nRemove-ItemProperty -Path HKLM:\\SOFTWARE\\OpenSSH -Name DefaultShell\n```\n\n----------------------------------------\n\nTITLE: Enabling Privilege Mode for a Single Network Task in Ansible YAML\nDESCRIPTION: This YAML snippet demonstrates how to apply privilege escalation (`become: true` with `become_method: enable`) to a specific task within an Ansible playbook. The example uses the `arista.eos.eos_facts` module to gather facts from an EOS device, ensuring the task runs in enable mode.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Gather facts (eos)\n  arista.eos.eos_facts:\n    gather_subset:\n      - \"!hardware\"\n  become: true\n  become_method: enable\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbooks from the Command Line (Bash)\nDESCRIPTION: This code snippet shows how to execute an Ansible playbook from the command line using the ansible-playbook tool. The '-f 10' flag sets the number of parallel processes (forks) for task execution. Requires Ansible to be installed and properly configured (hosts, playbook.yml). Input is a playbook YAML file, output is the result of applied playbook tasks across targeted hosts. Must have proper SSH access and permissions to affected hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_intro.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook playbook.yml -f 10\n\n```\n\n----------------------------------------\n\nTITLE: Applying VLAN Configuration Changes from Local File - YAML\nDESCRIPTION: This snippet applies changes to VLAN configuration by merging an updated local configuration with the device's existing configuration using cisco.ios.ios_vlans. The configuration must be stored in the 'vlans' variable, and 'state: merged' instructs Ansible to combine the settings. Used as part of a configuration management and update workflow.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Make VLAN config changes by updating stored facts on the control node.\\n  cisco.ios.ios_vlans:\\n    config: \\\"{{ vlans }}\\\"\\n    state: merged\\n  tags: update_config\n```\n\n----------------------------------------\n\nTITLE: Creating Unique List of Host Variable Values in Ansible Jinja2\nDESCRIPTION: This Jinja2 expression, typically used within an Ansible variable definition, extracts the value of 'varname' from the `hostvars` of all hosts in the inventory (`groups['all']`). It uses `map` with `extract`, converts the result to a list, and then applies the `unique` filter to get a deduplicated list. Requires `hostvars` to be populated, usually by gathering facts or defining variables.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_4\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\nvars:\n    unique_value_list: \"{{ groups['all'] | map ('extract', hostvars, 'varname') | list | unique}}\"\n```\n\n----------------------------------------\n\nTITLE: Valid YAML Syntax for Windows Path\nDESCRIPTION: Shows a valid unquoted scalar representing a Windows path. Although it contains a colon, it is not followed by a space, so it is parsed correctly as a string.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nwindows_path: c:\\windows\n```\n\n----------------------------------------\n\nTITLE: Setting Remote User in Ansible Playbook - Ansible - YAML\nDESCRIPTION: This YAML snippet demonstrates how to specify a remote user for all tasks in an Ansible playbook using the 'remote_user' keyword. It requires Ansible installed on the control machine and assumes the inventory includes the listed hosts. The 'remote_user' parameter sets 'admin' as the user for connecting to target hosts ('webservers'). Adjust 'remote_user' as necessary for each playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: update webservers\\n  hosts: webservers\\n  remote_user: admin\\n\\n  tasks:\\n  - name: thing to do first in this playbook\\n\\n  # ...\\n\n```\n\n----------------------------------------\n\nTITLE: Serial as a List of Percentages in Ansible Playbook (YAML)\nDESCRIPTION: This playbook uses the 'serial' keyword as a list of percentages ([\"10%\", \"20%\", \"100%\"]), making Ansible process hosts in growing batches based on inventory size per pass. Users can specify any valid percentages as batch sizes, applied in order. No dependencies or special prerequisites.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: test play\\n  hosts: webservers\\n  serial:\\n    - \"10%\"\\n    - \"20%\"\\n    - \"100%\"\n```\n\n----------------------------------------\n\nTITLE: Generating Client Certificate using PowerShell (PowerShell)\nDESCRIPTION: A PowerShell script that uses the `New-SelfSignedCertificate` cmdlet to generate a certificate suitable for WinRM client authentication within the current user's certificate store. It specifies necessary extensions (`clientAuth`, `userPrincipalName`), exports the public certificate to `cert.pem` and the certificate with its private key to `cert.pfx`, and then removes the certificate and key from the store. The private key is exported in PFX format, requiring conversion for Ansible use.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\n# Set the username to the name of the user the certificate will be mapped to\n$username = 'local-user'\n\n$clientParams = @{\n    CertStoreLocation = 'Cert:\\CurrentUser\\My'\n    NotAfter          = (Get-Date).AddYears(1)\n    Provider          = 'Microsoft Software Key Storage Provider'\n    Subject           = \"CN=$username\"\n    TextExtension     = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2\",\"2.5.29.17={text}upn=$username@localhost\")\n    Type              = 'Custom'\n}\n$cert = New-SelfSignedCertificate @clientParams\n$certKeyName = [System.Security.Cryptography.X509Certificates.RSACertificateExtensions]::GetRSAPrivateKey(\n    $cert).Key.UniqueName\n\n# Exports the public cert.pem and key cert.pfx\nSet-Content -Path \"cert.pem\" -Value @(\n    \"-----BEGIN CERTIFICATE-----\"\n    [Convert]::ToBase64String($cert.RawData) -replace \".{64}\", \"$&`n\"\n    \"-----END CERTIFICATE-----\"\n)\n$certPfxBytes = $cert.Export('Pfx', '')\n[System.IO.File]::WriteAllBytes(\"$pwd\\cert.pfx\", $certPfxBytes)\n\n# Removes the private key and cert from the store after exporting\n$keyPath = [System.IO.Path]::Combine($env:AppData, 'Microsoft', 'Crypto', 'Keys', $certKeyName)\nRemove-Item -LiteralPath \"Cert:\\CurrentUser\\My\\$($cert.Thumbprint)\" -Force\nRemove-Item -LiteralPath $keyPath -Force\n```\n\n----------------------------------------\n\nTITLE: Jinja2 Template for Rendering Hostname - Jinja2\nDESCRIPTION: This snippet illustrates a simple Jinja2 template that outputs the current host's detected hostname using Ansible facts. This template is referenced in the playbook and is rendered on the control node before being deployed to the managed host. The template uses the ansible_facts dictionary to inject the hostname value, producing a text file stating the server's name. Prerequisites include the variable ansible_facts['hostname'] being available at rendering time.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_templating.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nMy name is {{ ansible_facts['hostname'] }}\\n\n```\n\n----------------------------------------\n\nTITLE: Installing Multiple Ansible Roles from a Requirements File\nDESCRIPTION: Shows the command `ansible-galaxy install -r requirements.yml` used to install multiple roles defined in a YAML file (typically named `requirements.yml` or `requirements.yaml`). This allows batch installation of roles from various sources as specified within the file. Requires the `ansible-galaxy` command-line tool and a valid requirements file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy install -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Showing Host Uptime as Human-Readable String - Ansible Debug Module - YAML+Jinja\nDESCRIPTION: Provides a playbook task that formats the host's uptime in days/hours/minutes/seconds using Jinja2's 'now', 'replace', 'fromtimestamp', and arithmetic operations within an Ansible debug message. Dependencies include the Ansible 'debug' module and gathered 'ansible_uptime_seconds' fact. Input required: the current time and uptime fact; output: a human-readable uptime duration. Assumes the host fact is available and correct; formatting relies on Jinja2's datetime support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_15\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- name: Show the uptime in days/hours/minutes/seconds\n  ansible.builtin.debug:\n   msg: Uptime {{ now().replace(microsecond=0) - now().fromtimestamp(now(fmt='%s') | int - ansible_uptime_seconds) }}\n```\n\n----------------------------------------\n\nTITLE: Enabling Unsafe Shell Execution with module.run_command\nDESCRIPTION: Parameter `use_unsafe_shell=True` must be passed to `module.run_command` if shell execution (e.g., using pipes, redirection) is absolutely necessary. This signals that the command execution might be less secure and requires careful handling of inputs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nuse_unsafe_shell=True\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Values in YAML\nDESCRIPTION: Shows different ways to represent boolean true/false values in YAML. Ansible accepts various case formats, but lowercase 'true' or 'false' is recommended for compatibility with tools like yamllint.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ncreate_key: true\nneeds_agent: false\nknows_oop: True\nlikes_emacs: TRUE\nuses_cvs: false\n```\n\n----------------------------------------\n\nTITLE: Ensuring Single Task Execution with `when` Condition in Ansible\nDESCRIPTION: This Ansible `when` condition ensures a task runs strictly once on the very first host defined in the play's host list (`ansible_play_hosts_all[0]`), even when using `serial` execution mode. This provides an alternative to `run_once` when absolute single execution across all potential serial batches is required. The condition compares the current host's name (`inventory_hostname`) against the first host in the list for the entire play.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nwhen: inventory_hostname == ansible_play_hosts_all[0]\n```\n\n----------------------------------------\n\nTITLE: Including Tasks with Tags in Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet demonstrates how to include an external tasks file ('db.yml') into a playbook using the 'include_tasks' directive and assigning the tag 'db'. The 'include_tasks' statement dynamically pulls tasks from another file at runtime, which can then be targeted or skipped by tag at execution. The prerequisite is that the specified file ('db.yml') exists and contains valid Ansible tasks. No direct parameters are passed beyond the file name, and this pattern is often used for modular task organization.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Include tasks from db.yml\\n  include_tasks: db.yml\\ntags: db\n```\n\n----------------------------------------\n\nTITLE: Executing Arista Commands via Httpapi in Ansible Playbook (YAML)\nDESCRIPTION: This snippet demonstrates an Ansible playbook that connects to an Arista device using the 'httpapi' connection type and runs a command with the 'eos_command' module. The example requires Ansible to be installed and assumes the host 'leaf01' is defined in the inventory with 'ansible_network_os=eos'. The playbook disables fact gathering, runs a CLI command ('show version | json'), registers the output, and then uses the 'debug' module to print the version from the command results. The required dependencies are the appropriate Ansible collections (such as 'arista.eos') and network access to the configured device. Inputs include host information and inventory variables; outputs display the version information from the device. This implementation is constrained to Arista EOS devices with HTTP API interfaces.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/httpapi.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: leaf01\n  connection: httpapi\n  gather_facts: false\n  tasks:\n\n    - name: type a simple arista command\n      eos_command:\n        commands:\n          - show version | json\n      register: command_output\n\n    - name: print command output to terminal window\n      debug:\n        var: command_output.stdout[0][\"version\"]\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Variable in Ansible (YAML Syntax)\nDESCRIPTION: This snippet shows how to define a simple variable named `remote_install_path` with a string value `/opt/my_app_config` using standard YAML syntax. This variable can later be referenced in Ansible playbooks or templates.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nremote_install_path: /opt/my_app_config\n```\n\n----------------------------------------\n\nTITLE: Ignoring Errors in Ansible Lookup Plugins (YAML+Jinja)\nDESCRIPTION: This snippet demonstrates setting the 'errors' argument to 'ignore' in a lookup operation using Ansible's 'file' plugin. When the specified file path does not exist, Ansible will display a warning but continue execution, setting the message to an empty string. This behavior requires Ansible 2.6 or newer and is intended for non-fatal handling of external file lookups, especially in playbooks where missing files are acceptable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_3\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n    - name: if this file does not exist, I do not care .. file plugin itself warns anyway ...\n      debug: msg=\"{{ lookup('file', '/nosuchfile', errors='ignore') }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Connection via Inventory Variables in Ansible INI (2.5+)\nDESCRIPTION: Demonstrates the recommended Ansible 2.5 method for configuring network device connections using standard Ansible variables within an INI inventory file. It specifies the 'network_cli' connection type, the target network OS ('nxos'), and user credentials ('ansible_user', 'ansible_password').\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_10\n\nLANGUAGE: ini\nCODE:\n```\n[nxos:vars]\nansible_connection=network_cli\nansible_network_os=nxos\nansible_user=operator\nansible_password=secret\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Cliconf Plugins (Shell)\nDESCRIPTION: This shell command uses 'ansible-doc' to display a list of all Cliconf plugins currently available in the Ansible environment. It's useful for discovering which network operating systems have corresponding cliconf plugins installed. Requires Ansible installation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cliconf.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t cliconf -l\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Package with pip\nDESCRIPTION: Installs the full 'ansible' package using pip for the current user (--user flag). This places the package in the user's site-packages directory, avoiding the need for system-wide installation privileges.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --user ansible\n```\n\n----------------------------------------\n\nTITLE: Using FQCN for dellemc.openmanage Module (Ansible)\nDESCRIPTION: Specifies the Fully Qualified Collection Name (FQCN) `dellemc.openmanage.idrac_firmware` that must be used in playbooks and roles when using Ansible 2.9, as redirections are not supported. Requires the `dellemc.openmanage` collection to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_15\n\nLANGUAGE: ansible\nCODE:\n```\ndellemc.openmanage.idrac_firmware\n```\n\n----------------------------------------\n\nTITLE: Using Variables in Ansible Jinja2 Templates (Text/Jinja2)\nDESCRIPTION: This snippet shows part of an NTP configuration template file (`roles/common/templates/ntp.conf.j2`). It demonstrates how Ansible variables, specifically `ntpserver` (defined in `group_vars/all`), can be embedded into template files using Jinja2 syntax (`{{ ntpserver }}`) to generate configuration files dynamically.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ndriftfile /var/lib/ntp/drift\n\nrestrict 127.0.0.1\nrestrict -6 ::1\n\nserver {{ ntpserver }}\n\nincludefile /etc/ntp/crypto/pw\n\nkeys /etc/ntp/keys\n\n```\n\n----------------------------------------\n\nTITLE: Executing 'show version' Command via EXOS-API (YAML)\nDESCRIPTION: An Ansible task example demonstrating the use of the `community.network.exos_command` module to execute the `show version` command on an EXOS device configured for EXOS-API (HTTP/S) connection. The task runs conditionally based on the `ansible_network_os` variable. Proxy settings defined in `proxy_env` group variables are implicitly passed to the module's `environment` option.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_exos.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve EXOS OS version\n  community.network.exos_command:\n    commands: show version\n  when: ansible_network_os == 'community.network.exos'\n```\n\n----------------------------------------\n\nTITLE: Using the 'contains' Test with Filters in Ansible YAML\nDESCRIPTION: Illustrates the use of the `contains` test (introduced in Ansible 2.8), typically used with filters like `selectattr`, `rejectattr`, `select`, or `reject`. This example filters a list of dictionaries (`lacp_groups`) to find the first item where the `interfaces` list attribute contains the value 'em1', and then extracts the `master` attribute from that item.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  lacp_groups:\n    - master: lacp0\n      network: 10.65.100.0/24\n      gateway: 10.65.100.1\n      dns4:\n        - 10.65.100.10\n        - 10.65.100.11\n      interfaces:\n        - em1\n        - em2\n\n    - master: lacp1\n      network: 10.65.120.0/24\n      gateway: 10.65.120.1\n      dns4:\n        - 10.65.100.10\n        - 10.65.100.11\n      interfaces:\n          - em3\n          - em4\n\ntasks:\n  - debug:\n      msg: \"{{ (lacp_groups|selectattr('interfaces', 'contains', 'em1')|first).master }}\"\n```\n\n----------------------------------------\n\nTITLE: Delegating Gathering of Facts to Different Hosts in Ansible (YAML)\nDESCRIPTION: Demonstrates how to gather facts from a group (dbservers) and assign those facts to the correct hosts by using delegate_to and delegate_facts: true while looping through a group. This enables referencing facts from non-play hosts elsewhere. Requires: Ansible, group definitions (eg. app_servers, dbservers). Inputs: groups['dbservers'], Output: facts stored in hostvars for dbservers. Limitation: Only works with compatible modules and playbook structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: app_servers\n\n  tasks:\n    - name: Gather facts from db servers\n      ansible.builtin.setup:\n      delegate_to: \"{{ item }}\"\n      delegate_facts: true\n      loop: \"{{ groups['dbservers'] }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Vars Plugin Execution Stage in Ansible (INI)\nDESCRIPTION: This INI configuration snippet demonstrates how to control when a specific vars plugin executes by setting its `stage` option in `ansible.cfg`. In this example, the `host_group_vars` plugin is configured to run immediately after inventory sources are imported (`stage = inventory`) by defining its behavior under the `[vars_host_group_vars]` section. This overrides the global `RUN_VARS_PLUGINS` setting for this specific plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/vars.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[vars_host_group_vars]\nstage = inventory\n```\n\n----------------------------------------\n\nTITLE: Collecting and Reporting Test Coverage with ansible-test - Shell\nDESCRIPTION: This shell code snippet demonstrates a common sequence of ansible-test commands for erasing old coverage data, running unit and integration tests with coverage collection enabled, and generating an HTML coverage report. Dependencies include the ansible-test CLI tool and the 'coverage' Python module, which may need to be installed with the --requirements option if not using isolated environments. The commands accept various test targets (e.g., apt, aws_lambda) and can produce output in multiple formats (console, HTML, XML). The main limitation is that coverage reporting may require additional setup unless tests are run in a managed environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nansible-test coverage erase\nansible-test units --coverage apt\nansible-test integration --coverage aws_lambda\nansible-test coverage html\n```\n\n----------------------------------------\n\nTITLE: Retrieving VyOS Version Information Using vyos_command - YAML\nDESCRIPTION: This YAML playbook snippet shows how to execute a command on a VyOS device using the vyos.vyos.vyos_command Ansible module. It retrieves version information by running the 'show version' command, and only executes when ansible_network_os is set to vyos.vyos.vyos. Dependencies are the vyos.vyos collection, proper network_cli connection, and relevant group/host vars. Input includes the target command as a list, and the module's output will have command output in Ansible task results.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_vyos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve VyOS version info\\n  vyos.vyos.vyos_command:\\n    commands: show version\\n  when: ansible_network_os == 'vyos.vyos.vyos'\n```\n\n----------------------------------------\n\nTITLE: Specifying Native SSH Connection in Ansible\nDESCRIPTION: This snippet shows the command-line argument `-c ssh` used with Ansible commands. It tells Ansible to utilize the 'ssh' connection plugin, which leverages the native OpenSSH client installed on the control node. This is often the default and supports advanced SSH features like Kerberos authentication, jump hosts, and connection multiplexing via ControlMaster/ControlPersist for better performance.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\n-c ssh\n```\n\n----------------------------------------\n\nTITLE: Installing a Specific Version of an Ansible Galaxy Collection - Bash\nDESCRIPTION: This command demonstrates how to install an exact version (1.0.0-beta.1) of an Ansible Galaxy collection using the ansible-galaxy CLI. It uses the 'collection install' operation combined with the '==<version>' operator to identify the target version. No additional dependencies are required beyond a functional Ansible installation, and 'ansible-galaxy' must be on the path. The input expects the collection name followed by the exact version, and installs only that version. Pre-release versions must be explicitly referenced in this way.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_older_collection.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install my_namespace.my_collection:==1.0.0-beta.1\n```\n\n----------------------------------------\n\nTITLE: Defining Roles and Collections in requirements.yml (YAML)\nDESCRIPTION: This YAML snippet demonstrates the structure of a `requirements.yml` file that specifies both roles and collections to be installed using `ansible-galaxy`. It shows how to define a role from Ansible Galaxy with a specific version and a collection from Ansible Galaxy with a version range and source URL.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n---\nroles:\n  # Install a role from Ansible Galaxy.\n  - name: geerlingguy.java\n    version: \"1.9.6\" # note that ranges are not supported for roles\n\ncollections:\n  # Install a collection from Ansible Galaxy.\n  - name: community.general\n    version: \">=7.0.0\"\n    source: https://galaxy.ansible.com\n```\n\n----------------------------------------\n\nTITLE: Importing Playbooks in Ansible Playbook (YAML)\nDESCRIPTION: This snippet statically imports other playbooks ('webservers.yml' and 'databases.yml') into the main Ansible playbook, allowing the plays and tasks from these files to be executed in sequence as part of the main workflow. Requires Ansible installed. Expected input is the YAML-formatted playbook file; outputs are the sequential task executions. The import is static, meaning all tasks are resolved and planned before execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- import_playbook: webservers.yml\n- import_playbook: databases.yml\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbook Against a Specific Inventory and Group\nDESCRIPTION: Command-line example showing how to execute an Ansible playbook (`site.yml`) using a specific inventory file (`inventory_test`) via the `-i` flag. It further limits the execution to only the hosts within the `appservers` group using the `-l` (limit) flag.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -i inventory_test -l appservers site.yml\n```\n\n----------------------------------------\n\nTITLE: Gathering Facts with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Collects system facts (discovered variables like OS, IP address, hardware details) from all managed nodes (`all`). This command uses the `ansible.builtin.setup` module (`-m ansible.builtin.setup`) to gather and display this information.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m ansible.builtin.setup\n```\n\n----------------------------------------\n\nTITLE: Running a Playbook Task Asynchronously without Waiting (Fire-and-Forget) (YAML/Ansible)\nDESCRIPTION: Shows a playbook task using the 'command' module to run '/bin/sleep 15' with 'async: 45' and 'poll: 0'. This launches the command asynchronously and immediately proceeds to the next task, not waiting for completion or output. Requires Ansible on the control node and targets. Ideal for concurrent, independent operations but does not perform status checks or cleanup by default.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\n- hosts: all\n  remote_user: root\n\n  tasks:\n\n  - name: Simulate long running op, allow to run for 45 sec, fire and forget\n    ansible.builtin.command: /bin/sleep 15\n    async: 45\n    poll: 0\n```\n\n----------------------------------------\n\nTITLE: Defining Task Failure Based on Command Output String (YAML)\nDESCRIPTION: This Ansible task uses the `failed_when` conditional to define failure based on the content of the command's standard error output. The `ansible.builtin.command` module executes `/usr/bin/example-command`, and its result is registered in the `command_result` variable. The task is marked as failed if the string 'FAILED' is found within the `stderr` attribute of `command_result`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Fail task when the command error output prints FAILED\n  ansible.builtin.command: /usr/bin/example-command -x -y -z\n  register: command_result\n  failed_when: \"'FAILED' in command_result.stderr\"\n```\n\n----------------------------------------\n\nTITLE: Overriding Role Default Variables in an Ansible Playbook (YAML)\nDESCRIPTION: An updated Ansible playbook demonstrating variable precedence. It includes a `vars` section where the `dns` variable is set to `1.1.1.1`. This value will override the default value (`8.8.8.8 8.8.4.4`) defined in the `defaults/main.yml` file of the 'system_demo' role when the playbook is executed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: configure cisco routers\n  hosts: routers\n  connection: ansible.netcommon.network_cli\n  gather_facts: no\n  vars:\n    dns: 1.1.1.1\n  roles:\n    - system_demo\n```\n\n----------------------------------------\n\nTITLE: Targeting Dynamically Created OS Groups (Reference)\nDESCRIPTION: This reStructuredText directive includes an external Ansible playbook snippet (`yaml/tip_group_hosts.yaml`). The referenced code shows how subsequent plays can use the dynamic groups created by a previous `group_by` task (like the one in `tip_group_by.yaml`) in their `hosts` line. This enables OS-specific task execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/ansible_tips_tricks.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. literalinclude:: yaml/tip_group_hosts.yaml\n      :language: yaml\n```\n\n----------------------------------------\n\nTITLE: Configuring CLI Connection Group Variables for Arista EOS in YAML\nDESCRIPTION: This YAML snippet defines Ansible group variables (`group_vars/eos.yml`) for managing Arista EOS devices using the SSH-based CLI connection (`ansible.netcommon.network_cli`). It specifies the target network OS, user credentials (using Ansible Vault for passwords), enables privilege escalation (`become: true`, `become_method: enable`), and optionally configures SSH connection arguments for using a bastion host (`ansible_ssh_common_args`). Remove `ansible_password` if using SSH keys and `ansible_ssh_common_args` if not using a bastion host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: arista.eos.eos\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nansible_become_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Installing Windows Updates with win_updates and win_hotfix - Ansible Playbook YAML\nDESCRIPTION: This snippet shows updating Windows systems either by categories (win_updates) or by a specific hotfix file (win_hotfix) in Ansible. It registers task results to trigger conditional reboots as necessary. Dependencies may include access to Windows update repositories and the DISM PowerShell cmdlets for hotfixes on older systems. Inputs are update categories or KB/hotfix file and outputs are update installation and host reboot status.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Install all critical and security updates\\n  win_updates:\\n    category_names:\\n    - CriticalUpdates\\n    - SecurityUpdates\\n    state: installed\\n  register: update_result\\n\\n- name: Reboot host if required\\n  win_reboot:\\n  when: update_result.reboot_required\\n\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Download KB3172729 for Server 2012 R2\\n  win_get_url:\\n    url: http://download.windowsupdate.com/d/msdownload/update/software/secu/2016/07/windows8.1-kb3172729-x64_e8003822a7ef4705cbb65623b72fd3cec73fe222.msu\\n    dest: C:\\\\temp\\\\KB3172729.msu\\n\\n- name: Install hotfix\\n  win_hotfix:\\n    hotfix_kb: KB3172729\\n    source: C:\\\\temp\\\\KB3172729.msu\\n    state: present\\n  register: hotfix_result\\n\\n- name: Reboot host if required\\n  win_reboot:\\n  when: hotfix_result.reboot_required\n```\n\n----------------------------------------\n\nTITLE: Writing Text to File as UTF-8 Bytes with Ansible Converter - Python\nDESCRIPTION: Shows conversion of a Unicode string to bytes using Ansible's to_bytes utility before writing to a binary file. Requires ansible.module_utils.common.text.converters.to_bytes. Input is a Unicode string (some_text_string), which is encoded as UTF-8 bytes before writing. All Python text strings can be transformed to UTF-8, so no UnicodeError handling is necessary. Output is a file named filename.txt containing encoded UTF-8 bytes of the text.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.common.text.converters import to_bytes\n\nwith open('filename.txt', 'wb') as my_file:\n    my_file.write(to_bytes(some_text_string))\n```\n\n----------------------------------------\n\nTITLE: Testing Open Ports with Ansible Wait_for Module in YAML\nDESCRIPTION: This YAML demonstrates using Ansible's 'wait_for' module to check if a specific port (e.g., 22) is open on a target host. The module is delegated to 'localhost' for local validation. This pattern is useful for basic connectivity and readiness checks, especially pre-deployment. Dependencies: Ansible environment, use of variables like 'inventory_hostname', and network access from execution host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n  - ansible.builtin.wait_for:\n      host: \"{{ inventory_hostname }}\"\n      port: 22\n    delegate_to: localhost\n```\n\n----------------------------------------\n\nTITLE: Running Windows Shell Commands with win_shell (Ansible/YAML)\nDESCRIPTION: This snippet demonstrates the use of the 'ansible.windows.win_shell' module within an Ansible playbook to run a shell command on a Windows target host. It ensures the command is executed using the host's shell and that output is encoded in UTF-8 when appropriate. Dependency: Requires the 'ansible.windows.win_shell' module and a properly configured inventory for Windows hosts. Key parameter: the shell command to execute. Input: a string containing the command. Output: task execution results including stdout and stderr. Limitation: For PowerShell-specific execution, use the win_powershell module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.18.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run with win_shell\\n  ansible.windows.win_shell: Write-Host \\\"Hello, Caf\\u00e9\\\"\n```\n\n----------------------------------------\n\nTITLE: Backing Up Dell OS6 Configuration with Ansible Task (YAML)\nDESCRIPTION: An example Ansible task that utilizes the `dellemc.os6.os6_config` module to perform a configuration backup on a Dell OS6 device. The `backup: yes` parameter triggers the backup operation, and the result (likely the backup file path or status) is registered in the `backup_dellso6_location` variable. The `when` condition ensures this task only runs on hosts identified as Dell OS6.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_dellos6.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (dellos6)\n  dellemc.os6.os6_config:\n    backup: yes\n  register: backup_dellso6_location\n  when: ansible_network_os == 'dellemc.os6.os6'\n```\n\n----------------------------------------\n\nTITLE: Configuring NOS CLI Connection Settings in Ansible Playbook - YAML\nDESCRIPTION: This snippet demonstrates how to configure group variables for connecting to NOS devices using the network_cli connection in Ansible. Required settings include ansible_connection (set to ansible.netcommon.network_cli), ansible_network_os, ansible_user, and ansible_password (which may reference an Ansible Vault secret). The optional ansible_ssh_common_args parameter shows usage of a bastion/jump host using SSH ProxyCommand. Credentials should be managed securely and unnecessary fields (like ansible_password with SSH keys or ansible_ssh_common_args without a bastion) can be omitted as appropriate.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: community.network.nos\nansible_user: myuser\nansible_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n\n```\n\n----------------------------------------\n\nTITLE: Backing Up Arista EOS Configuration via CLI using Ansible YAML Task\nDESCRIPTION: This Ansible task, written in YAML, utilizes the `arista.eos.eos_config` module to perform a configuration backup on an Arista EOS device. It requires the CLI connection (`ansible.netcommon.network_cli`) to be configured. The `backup: yes` parameter triggers the backup operation, and the task only runs if the `ansible_network_os` variable matches `arista.eos.eos`. The path to the backup file is stored in the `backup_eos_location` variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (eos)\n  arista.eos.eos_config:\n    backup: yes\n  register: backup_eos_location\n  when: ansible_network_os == 'arista.eos.eos'\n```\n\n----------------------------------------\n\nTITLE: Checking for Ansible Vault Encryption in YAML\nDESCRIPTION: Demonstrates the use of the `vault_encrypted` test (introduced in Ansible 2.10) to determine if a variable contains an inline Ansible Vault encrypted value. The example uses a ternary filter within a debug task to display a message based on the test result.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  variable: !vault |\n    $ANSIBLE_VAULT;1.2;AES256;dev\n    61323931353866666336306139373937316366366138656131323863373866376666353364373761\n    3539633234313836346435323766306164626134376564330a373530313635343535343133316133\n    36643666306434616266376434363239346433643238336464643566386135356334303736353136\n    6565633133366366360a326566323363363936613664616364623437336130623133343530333739\n    3039\n\ntasks:\n  - debug:\n      msg: '{{ (variable is vault_encrypted) | ternary(\"Vault encrypted\", \"Not vault encrypted\") }}'\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Connection Variables for Dell OS6 (YAML)\nDESCRIPTION: Example `group_vars/dellos6.yml` file defining connection parameters for Dell OS6 devices. It specifies the connection type (`ansible.netcommon.network_cli`), the network OS (`dellemc.os6.os6`), user credentials (using Ansible Vault for passwords), enables privilege escalation (`ansible_become`), and includes optional SSH arguments for connecting via a bastion host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_dellos6.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: dellemc.os6.os6\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nansible_become_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Converting Boolean Indicators for Truthiness Checks in YAML\nDESCRIPTION: Illustrates using the optional `convert_bool=True` parameter with the `truthy` and `falsy` tests (Ansible >= 2.10) to convert common boolean string indicators (like 'yes', 'off') to actual boolean values before performing the truthiness check.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- debug:\n    msg: \"Truthy\"\n  when: value is truthy(convert_bool=True)\n  vars:\n    value: \"yes\"\n\n- debug:\n    msg: \"Falsy\"\n  when: value is falsy(convert_bool=True)\n  vars:\n    value: \"off\"\n```\n\n----------------------------------------\n\nTITLE: Including a Tagged Task File in an Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet ('myplaybook.yml') shows how to include a task file ('mixed.yml') using the 'include_tasks' directive with an associated tag 'mytag'. Running this playbook with '--tags \\\"mytag\\\"' will selectively execute only those tasks in 'mixed.yml' also tagged 'mytag', skipping untagged tasks. The include_tasks method is dynamic, meaning tag inheritance from the include does not propagate to the interior tasks; only those with explicit matching tags are executed. Assumes presence of 'mixed.yml' and at least one host defined.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n# myplaybook.yml\\n- hosts: all\\n  tasks:\\n  - name: Run tasks from mixed.yml\\n    include_tasks:\\n      name: mixed.yml\\n    tags: mytag\n```\n\n----------------------------------------\n\nTITLE: Retrieving Device Configuration with Connection Plugin - Ansible Python\nDESCRIPTION: Demonstrates how to use the Ansible connection plugin API within a shared module_utils file to retrieve the configuration from a network device. Requires importing from ansible.module_utils.connection and requires the module parameter to be a valid AnsibleModule instance. The only required input is the module whose _socket_path property connects to the device; output is the device's current configuration. The connection.get_config() method is called directly; private methods (starting with '_') are not accessible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.connection import Connection\\n\\ndef get_config(module):\\n    # module is your AnsibleModule instance.\\n    connection = Connection(module._socket_path)\\n\\n    # You can now call any method (that doesn't start with '_') of the connection\\n    # plugin or its platform-specific plugin\\n    return connection.get_config()\\n\n```\n\n----------------------------------------\n\nTITLE: Globally Enabling Task Debugger via Environment Variable (Shell)\nDESCRIPTION: This command demonstrates how to enable the Ansible task debugger globally for a single playbook run using the `ANSIBLE_ENABLE_TASK_DEBUGGER` environment variable. Setting it to `True` activates the debugger for failed tasks during the execution of `site.yml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nANSIBLE_ENABLE_TASK_DEBUGGER=True ansible-playbook -i hosts site.yml\n```\n\n----------------------------------------\n\nTITLE: Building and Installing an Ansible Collection from Source using Bash\nDESCRIPTION: This command instructs `ansible-galaxy` to build and install a collection located in the source directory `/path/to/collection`. It uses metadata from `MANIFEST.json` or `galaxy.yml` within that directory. The `-p ./collections` option directs the installation to the `./collections/ansible_collections/` path, unless `./collections` itself is named `ansible_collections`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install /path/to/collection -p ./collections\n```\n\n----------------------------------------\n\nTITLE: Fetching and Checking Out a Pull Request Branch (Shell)\nDESCRIPTION: This shell-session snippet fetches a specific GitHub pull request (PR) and creates a local branch for testing using the PR number. It ensures the contributor can evaluate code changes directly. Dependencies: cloned repository, correct PR number, and git access. Input is a PR number; output is a checked-out branch with proposed changes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit fetch origin refs/pull/XXXX/head:testing_PRXXXX\ngit checkout testing_PRXXXX\n```\n\n----------------------------------------\n\nTITLE: Using Executable Script with --vault-id (No Label) - CLI Usage (Bash)\nDESCRIPTION: Uses an executable script to supply the vault password via --vault-id without a label. The script must output the password to stdout and have executable permissions. Input: CLI command with script path; Output: Password for decryption sourced from script output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id my-vault-password-client.py\n```\n\n----------------------------------------\n\nTITLE: Viewing Specific Ansible Shell Plugin Documentation (Shell)\nDESCRIPTION: Uses the `ansible-doc` command to display detailed documentation and examples for a specific shell plugin. Replace `<plugin name>` with the actual name of the desired plugin (e.g., `sh`, `csh`, `powershell`). The `-t shell` flag specifies the plugin type. This command provides usage details, configuration options, and examples for the selected plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/shell.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t shell <plugin name>\n```\n\n----------------------------------------\n\nTITLE: Overriding Play-Level Debugger Setting at Task Level (YAML)\nDESCRIPTION: This example demonstrates debugger setting precedence. Although the debugger is set to `never` at the play level, the task explicitly sets `debugger: on_failed`. The task-level setting takes precedence, so the debugger will activate if this specific task fails.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Play\n  hosts: all\n  debugger: never\n  tasks:\n    - name: Execute a command\n      ansible.builtin.command: \"false\"\n      debugger: on_failed\n```\n\n----------------------------------------\n\nTITLE: Configuring ICX Group Variables for Ansible CLI Connection (YAML)\nDESCRIPTION: This YAML snippet shows an example `group_vars/icx.yml` file for configuring Ansible connections to ICX devices. It sets the connection type to `ansible.netcommon.network_cli`, specifies the network OS as `community.network.icx`, defines user credentials and enable mode parameters (using Ansible Vault for passwords), and includes SSH arguments for connecting through a bastion host named `bastion01`. This configuration applies to all hosts within the 'icx' group in the Ansible inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: community.network.icx\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nansible_become_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Ad hoc Local Execution of Custom Ansible Module (Shell)\nDESCRIPTION: Shell command example to run a custom module against localhost for module validation without remote hosts. Again uses ANSIBLE_LIBRARY to specify module location. Takes the same arguments as above. Main purpose is rapid local testing without full playbook overhead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nANSIBLE_LIBRARY=./library ansible -m my_test -a 'name=hello new=true' localhost\n```\n\n----------------------------------------\n\nTITLE: Enabling GSSAPI Authentication in OpenSSH - Windows - text\nDESCRIPTION: This sshd_config setting enables GSSAPI authentication (Kerberos) for the OpenSSH daemon on Windows by setting `GSSAPIAuthentication yes`. This allows remote users to authenticate using Kerberos tickets. Requires editing `C:\\ProgramData\\ssh\\sshd_config` and a restart of the sshd service for changes to take effect. The only input is the configuration line, and output is SSHD enabling GSSAPI authentication.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nGSSAPIAuthentication yes\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Role Dependencies in meta/main.yml (YAML)\nDESCRIPTION: This YAML snippet illustrates defining role dependencies in `meta/main.yml` using the more complex format, similar to `requirements.yml`. It allows specifying roles by `name`, `src` (including SCM URLs), and `version` (like a specific commit hash). Note that Galaxy import might fail if `src` is a URL.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  - name: geerlingguy.ansible\n  - name: composer\n    src: git+https://github.com/geerlingguy/ansible-role-composer.git\n    version: 775396299f2da1f519f0d8885022ca2d6ee80ee8\n```\n\n----------------------------------------\n\nTITLE: Fetching URLs Securely in Ansible Modules\nDESCRIPTION: Recommends using the `fetch_url` or `open_url` functions provided by `ansible.module_utils.urls` for handling URL operations, especially HTTPS. These utilities handle TLS certificate verification correctly, unlike standard Python libraries like `urllib2`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfetch_url\n```\n\nLANGUAGE: python\nCODE:\n```\nopen_url\n```\n\nLANGUAGE: python\nCODE:\n```\nansible.module_utils.urls\n```\n\n----------------------------------------\n\nTITLE: Structuring Inventory with Named Hosts and ansible_host Key - yaml\nDESCRIPTION: This YAML-formatted inventory snippet defines host entries with custom names and the explicit 'ansible_host' variable, which sets the actual IP or hostname used for connection. The YAML format supports additional host-level settings and is more scalable for large inventories. Dependencies include Ansible 2.4+ and YAML compatibility for inventory parsing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nexample_host_1:\\n  ansible_host: 192.0.2.50\\nexample_host_2:\\n  ansible_host: 192.0.2.51\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbook with Variable Override (Bash)\nDESCRIPTION: Shows the execution of the updated `playbook.yml` using `ansible-playbook`, specifically targeting the 'rtr2' host with `-l rtr2`. This execution uses the `dns` variable defined in the playbook's `vars` section (`1.1.1.1`), overriding the value present in the role's `defaults/main.yml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible ~]$ ansible-playbook playbook.yml -l rtr2\n```\n\n----------------------------------------\n\nTITLE: Configuring Inventory Cache Plugin in YAML Inventory Configuration\nDESCRIPTION: Demonstrates setting the specific cache plugin (`jsonfile`) directly within a YAML configuration file for an inventory plugin (e.g., `aws_ec2`). This configuration is specific to the inventory source defined in the file (e.g., `dev.aws_ec2.yaml`) and requires `cache: True` to also be set.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n# dev.aws_ec2.yaml\nplugin: aws_ec2\ncache_plugin: jsonfile\n```\n\n----------------------------------------\n\nTITLE: Specifying Alphabetic Host Ranges (INI)\nDESCRIPTION: Demonstrates defining hosts using alphabetic ranges (`[a:f]`) in an INI inventory file, useful for hosts following alphabetic naming conventions (e.g., `db-a`, `db-b`, ..., `db-f`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n[databases]\ndb-[a:f].example.com\n```\n\n----------------------------------------\n\nTITLE: Configuring Webservers Group via Roles - Ansible Playbook YAML\nDESCRIPTION: Defines a play targeting all hosts in the 'webservers' group, applying both 'common' and 'webtier' roles. This modular structure lets you separate generic configuration from web-tier-specific automation. The playbook expects group_vars and relevant roles to be present; inputs and outputs align with Ansible play standards.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: webservers.yml\\n- hosts: webservers\\n  roles:\\n    - common\\n    - webtier\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Multiple Collections within a Namespace\nDESCRIPTION: This text block illustrates a file system structure where a parent directory `ns/` contains subdirectories `collection1/` and `collection2/`, each representing an Ansible collection with its respective metadata (`MANIFEST.json` or `galaxy.yml`) and plugin directories. This structure allows installing all collections under `ns/` using a single `ansible-galaxy` command targeting the parent directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nns/\n├── collection1/\n│   ├── MANIFEST.json\n│   └── plugins/\n└── collection2/\n    ├── galaxy.yml\n    └── plugins/\n```\n\n----------------------------------------\n\nTITLE: Generating Client Certificate and Private Key using OpenSSL (Bash)\nDESCRIPTION: A sequence of Bash commands utilizing OpenSSL to generate a private key (`cert.key`) and a public certificate (`cert.pem`) suitable for WinRM client authentication. It includes creating a configuration file (`openssl.conf`) specifying required extensions like `clientAuth` and `subjectAltName` with a `userPrincipalName`, generating a certificate signing request (CSR), and finally signing the certificate.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Set the username to the name of the user the certificate will be mapped to\nUSERNAME=\"local-user\"\n\ncat > openssl.conf << EOL\ndistinguished_name = req_distinguished_name\n\n[req_distinguished_name]\n[v3_req_client]\nextendedKeyUsage = clientAuth\nsubjectAltName = otherName:1.3.6.1.4.1.311.20.2.3;UTF8:${USERNAME}@localhost\nEOL\n\nopenssl req \\\n    -new \\\n    -sha256 \\\n    -subj \"/CN=${USERNAME}\" \\\n    -newkey rsa:2048 \\\n    -nodes \\\n    -keyout cert.key \\\n    -out cert.csr \\\n    -config openssl.conf \\\n    -reqexts v3_req_client\n\nopenssl x509 \\\n    -req \\\n    -in cert.csr \\\n    -sha256 \\\n    -out cert.pem \\\n    -days 365 \\\n    -extfile openssl.conf \\\n    -extensions v3_req_client \\\n    -key cert.key\n\nrm openssl.conf cert.csr\n```\n\n----------------------------------------\n\nTITLE: Conditional Include Example for Reusability (`main.yml`)\nDESCRIPTION: This snippet presents the main playbook file (`main.yml`) focusing on using `include_tasks` conditionally to reuse a file (`other_tasks.yml`) specifically for defining a variable ('x') only when it's not already defined. The `when` condition applies only to the inclusion step.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_24\n\nLANGUAGE: yaml\nCODE:\n```\n# Includes let you reuse a file to define a variable when it is not already defined\n\n# main.yml\n- include_tasks: other_tasks.yml\n  when: x is not defined\n```\n\n----------------------------------------\n\nTITLE: Retrieving ENOS OS Version with enos_command Plugin (YAML)\nDESCRIPTION: Executes a task in an Ansible play or role that invokes the community.network.enos_command module to run CLI commands on ENOS devices. This example uses a conditional to ensure the task only runs when the ansible_network_os is set to 'community.network.enos'. It requires the community.network collection and properly configured connection settings (as per inventory variables). The main input is the command 'show version', and the output will be the command results as returned by Ansible's module. Suitable for gathering OS version information programmatically during automation runs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_enos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve ENOS OS version\\n  community.network.enos_command:\\n    commands: show version\\n  when: ansible_network_os == 'community.network.enos'\\n\n```\n\n----------------------------------------\n\nTITLE: Nested Loops via 'include_tasks' (Inner Loop)\nDESCRIPTION: This is the included playbook (`inner.yml`) for the nested loop example. It defines an inner loop iterating over `['a', 'b', 'c']`, using the default loop variable `item`. Inside the loop, the `ansible.builtin.debug` task can access both the outer loop's variable (`outer_item`, passed from the including playbook) and the inner loop's variable (`item`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_32\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# inner.yml\n- name: Print outer and inner items\n  ansible.builtin.debug:\n    msg: \"outer item={{ outer_item }} inner item={{ item }}\"\n  loop:\n    - a\n    - b\n    - c\n```\n\n----------------------------------------\n\nTITLE: Replacing Deprecated `__file__` with `module.tmpdir` in Ansible Modules (Python Diff)\nDESCRIPTION: Provides a diff showing the recommended code change for Ansible module authors. It replaces the usage of `os.path.dirname(__file__)` to determine a temporary directory path with the `module.tmpdir` attribute, available since Ansible 2.5. This change is necessary because `__file__` will no longer reliably point to a filesystem path starting in Ansible 2.8.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.7.rst#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-    tempdir = os.path.dirname(__file__)\n-    package = os.path.join(tempdir, to_native(deb.rsplit('/', 1)[1]))\n+    package = os.path.join(module.tmpdir, to_native(deb.rsplit('/', 1)[1]))\n```\n\n----------------------------------------\n\nTITLE: Enabling WinRM Certificate Authentication on Windows Host (PowerShell)\nDESCRIPTION: A PowerShell command to enable certificate-based authentication within the WinRM service configuration on a target Windows host. This setting is disabled by default and must be enabled for certificate authentication to function.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nSet-Item -Path WSMan:\\localhost\\Service\\Auth\\Certificate -Value $true\n```\n\n----------------------------------------\n\nTITLE: Disabling Ansible Fact Gathering in a Playbook using YAML\nDESCRIPTION: This YAML snippet, part of an Ansible playbook, demonstrates how to disable the default fact-gathering process for a specific play by setting the `gather_facts` parameter to `false`. This can improve performance, especially in large environments or when facts are not needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: whatever\n  gather_facts: false\n```\n\n----------------------------------------\n\nTITLE: Executing Generic Ansible Ad Hoc Command in Bash\nDESCRIPTION: Provides the basic syntax for running an Ansible ad hoc command. It uses the `/usr/bin/ansible` command-line tool, specifying a target host pattern, the module to execute (`-m`), and module-specific arguments (`-a`). Module options can be key=value pairs or a JSON string.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible [pattern] -m [module] -a \"[module options]\"\n```\n\n----------------------------------------\n\nTITLE: Building an Ansible Collection Docsite using antsibull-docs in Shell\nDESCRIPTION: This sequence of shell commands uses 'antsibull-docs' to initialize a Sphinx documentation structure for an Ansible collection, installs necessary Python dependencies using pip (optionally within a virtual environment), and then builds the HTML documentation site using a generated build script. The resulting documentation can be viewed by opening the 'build/html/index.html' file. It requires 'antsibull-docs' and 'pip' to be installed, and the target collection should be accessible via COLLECTIONS_PATHS.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_documenting.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n#. Create your collection and make sure you can use it with ansible-core by adding it to your :ref:`COLLECTIONS_PATHS`.\n#. Create a directory ``dest`` and run ``antsibull-docs sphinx-init --use-current --dest-dir dest namespace.name``, where ``namespace.name`` is the name of your collection.\n#. Go into ``dest`` and run ``pip install -r requirements.txt``. You might want to create a venv and activate it first to avoid installing this globally.\n#. Then run ``./build.sh``.\n#. Open ``build/html/index.html`` in a browser of your choice.\n```\n\n----------------------------------------\n\nTITLE: Installing Kerberos Authentication Requirements via pip (Shell)\nDESCRIPTION: This snippet demonstrates installing Kerberos-related Python packages directly with pip3, specifically required by Ansible’s psrp and winrm connection plugins for Kerberos authentication. Run these commands in your Python environment if using pip rather than pipx with Ansible. The code ensures the correct extras and versions are installed for proper plugin support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npip3 install \"pypsrp[kerberos]<=1.0.0\"  # for psrp\npip3 install \"pywinrm[kerberos]>=0.4.0\"  # for winrm\n```\n\n----------------------------------------\n\nTITLE: Checking Playbook Changes Safely using Ansible Check Mode (Bash)\nDESCRIPTION: This Bash snippet demonstrates how to run an Ansible playbook in check mode using the '--check' or '-C' flag. Check mode allows users to preview what changes would be made by the playbook without actually modifying any systems. Requires a valid playbook YAML, Ansible installed, and proper inventories. Useful for safely validating intended changes prior to applying them in production environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_intro.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --check playbook.yaml\n\n```\n\n----------------------------------------\n\nTITLE: Formatting Ansible Changelog Known Issues in YAML\nDESCRIPTION: Shows the YAML format for documenting known issues under the 'known_issues' key in Ansible changelog fragments. The example details a present-tense description of an issue with 'ansible-test' tab completion and includes a link to the corresponding GitHub issue for tracking.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nknown_issues:\n  - ansible-test - tab completion anywhere other than the end of the command with the new composite options provides incorrect results (https://github.com/kislyuk/argcomplete/issues/351).\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Handler Tasks in Ansible (YAML)\nDESCRIPTION: This handler definition file ('restarts.yml') provides reusable tasks to restart the Apache and MySQL services. Requires the 'ansible.builtin.service' module (part of standard Ansible). Each task specifies the 'name' and 'state' to control service restarts. This file is meant to be included or imported in the handlers section of other playbooks to centralize common restart actions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# restarts.yml\n- name: Restart apache\n  ansible.builtin.service:\n    name: apache\n    state: restarted\n\n- name: Restart mysql\n  ansible.builtin.service:\n    name: mysql\n    state: restarted\n```\n\n----------------------------------------\n\nTITLE: Parsing XML Output with Ansible `cli_parse` (YAML)\nDESCRIPTION: This Ansible task uses `ansible.utils.cli_parse` to run a command that produces XML output (`show interface | xml`) on a network device. It utilizes the built-in XML parser (`ansible.utils.xml`) to convert the XML output into an Ansible native data structure, which is then registered in the `interfaces` variable. Requires the `xmltodict` Python library.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: \"Run command and parse as xml\"\n     ansible.utils.cli_parse:\n       command: show interface | xml\n       parser:\n         name: ansible.utils.xml\n     register: interfaces\n```\n\n----------------------------------------\n\nTITLE: Conditional Task Execution Based on Hostname (YAML)\nDESCRIPTION: Displays a playbook task that conditionally runs a command only if the executing host is the first in the 'webservers' inventory group, simulating behavior similar to 'run_once'. Uses a 'when' clause for conditional logic. Output applies only to matching host; no dependencies outside standard Ansible constructs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n    - command: /opt/application/upgrade_db.py\\n      when: inventory_hostname == webservers[0]\n```\n\n----------------------------------------\n\nTITLE: Sample Ansible Task Output for Resource Changes - Console\nDESCRIPTION: This console output demonstrates the result dictionary from running a resource module playbook. It includes structured details for the 'before' and 'after' states of key configuration elements, a changed flag, commands applied, and error states. This helps users understand the feedback returned by Ansible network resource modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\nok: [nxos101] =>\\n  result:\\n    after:\\n      contact: IT Support\\n      location: Room E, Building 6, Seattle, WA 98134\\n      users:\\n      - algorithm: md5\\n        group: network-admin\\n        localized_key: true\\n        password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'\\n        privacy_password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'\\n        username: admin\\n    before:\\n      contact: IT Support\\n      location: Room E, Building 5, Seattle HQ\\n      users:\\n      - algorithm: md5\\n        group: network-admin\\n        localized_key: true\\n        password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'\\n        privacy_password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'\\n        username: admin\\n    changed: true\\n    commands:\\n    - snmp-server location Room E, Building 6, Seattle, WA 98134\\n    failed: false\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with ansible-test and Docker\nDESCRIPTION: Illustrates how to execute a specific unit test file within an Ansible collection using the ansible-test command and Docker for environment isolation. Dependencies are ansible-test and Docker installed on the local machine. This allows for automated validation of code changes within a predictable environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_unit_tests.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-test units tests/unit/plugins/modules/test_my_module.py --docker\n\n```\n\n----------------------------------------\n\nTITLE: Running All Sanity Tests for Ansible Collections using ansible-test\nDESCRIPTION: Executes all sanity tests for an Ansible collection using the `ansible-test sanity` command within a default Docker container. The `--docker default` flag specifies the use of the default Docker environment, and `-v` enables verbose output. This command must be run from the root directory of the collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_testing.rst#_snippet_0\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-test sanity --docker default -v\n```\n\n----------------------------------------\n\nTITLE: JSON Arguments File for Direct Module Testing\nDESCRIPTION: Presents a sample JSON file for passing arguments to an Ansible module outside of the Ansible runtime, enabling easy Python-based debugging. The expected file (typically /tmp/args.json) provides the ANSIBLE_MODULE_ARGS dict, used by modules to parse the input parameters. Used during direct testing with Python to quickly supply arguments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ANSIBLE_MODULE_ARGS\": {\n        \"name\": \"hello\",\n        \"new\": true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Host Variables to Ansible Inventory - YAML\nDESCRIPTION: This YAML snippet demonstrates how to enrich each host in an Ansible inventory file with additional variables such as IP address, network OS, and SSH user. It ensures all necessary connection data is included for both network and server hosts, reducing the need for repeated command-line arguments. Dependencies include the 'vyos.vyos.vyos' collection for network OS and Ansible network plugins.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\nleafs:\n  hosts:\n    leaf01:\n      ansible_host: 10.16.10.11\n      ansible_network_os: vyos.vyos.vyos\n      ansible_user: my_vyos_user\n    leaf02:\n      ansible_host: 10.16.10.12\n      ansible_network_os: vyos.vyos.vyos\n      ansible_user: my_vyos_user\n\nspines:\n  hosts:\n    spine01:\n      ansible_host: 10.16.10.13\n      ansible_network_os: vyos.vyos.vyos\n      ansible_user: my_vyos_user\n    spine02:\n      ansible_host: 10.16.10.14\n      ansible_network_os: vyos.vyos.vyos\n      ansible_user: my_vyos_user\n\nnetwork:\n  children:\n    leafs:\n    spines:\n\nwebservers:\n  hosts:\n    webserver01:\n      ansible_host: 10.16.10.15\n      ansible_user: my_server_user\n    webserver02:\n      ansible_host: 10.16.10.16\n      ansible_user: my_server_user\n\ndatacenter:\n  children:\n    network:\n    webservers:\n\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Dictionary Values with Built-in Python 3 Syntax - Python\nDESCRIPTION: This snippet demonstrates how to iterate over the values of a dictionary in Python 3 using the built-in DICT.values() method, replacing the removed DICT.itervalues method. No external dependencies are required. The snippet assigns each value in DICT to the VALUE variable in a standard for loop. Input is any dictionary object (DICT), output is sequential access to its values; no modifications are made.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-dict-itervalues.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfor VALUE in DICT.values():\n   pass\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Sequential Prompts using cli_command (YAML)\nDESCRIPTION: This Ansible task uses the `ansible.netcommon.cli_command` module to execute a command (`copy sftp...`) that triggers multiple prompts. It defines a list of expected prompts (as Python regex) and corresponding answers. The `check_all: True` parameter ensures that each prompt is matched with its corresponding answer in the order they appear. This is typically used for operations requiring multiple confirmations or inputs like passwords.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_working_with_command_output.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: multiple prompt, multiple answer (mandatory check for all prompts)\n  ansible.netcommon.cli_command:\n    command: \"copy sftp sftp://user@host//user/test.img\"\n    check_all: True\n    prompt:\n      - \"Confirm download operation\"\n      - \"Password\"\n      - \"Do you want to change that to the standby image\"\n    answer:\n      - 'y'\n      - <password>\n      - 'y'\n```\n\n----------------------------------------\n\nTITLE: Move Modules to Collection Plugins Directory (Bash CLI)\nDESCRIPTION: Command to move custom modules from the role's local 'library' to the collection's global plugins/modules directory. File system structure prerequisites: populated source and destination paths. Ensures modules are properly discoverable by Ansible in the new collection layout.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mv -r mynamespace/mycollection/roles/my_role/library/* mynamespace/mycollection/plugins/modules/\\n\n```\n\n----------------------------------------\n\nTITLE: Using default(omit) to Handle Missing Values in Loop (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: An updated loop task, this snippet shows the correct way to propagate omitted values using 'default(omit)', complying with the new Ansible-core mechanism. Needs Ansible, 'omit' variable, and looping support. Output: msg is omitted when not present, preventing errors from undefined values. Limitation: depends on Ansible handling of 'omit' in latest versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_13\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - debug:\n        msg: \"{{ item.msg | default(omit) }}\"  # 'msg' is undefined, use 'default(omit)' to turn it into an omit\n      loop:\n       - msg: \"{{ omit }}\"  # passed through in earlier versions, this value is now omitted from the loop item\n```\n\n----------------------------------------\n\nTITLE: Launching SSH Agent and Adding Private Key - Secure Shell - Bash\nDESCRIPTION: This Bash snippet demonstrates launching an SSH agent and adding a private SSH key (id_rsa) to the agent for passwordless authentication in Ansible. It requires OpenSSH installed and a valid private key at '~/.ssh/id_rsa'. Used to streamline SSH connections for Ansible automation, especially when multiple SSH keys are in use.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ssh-agent bash\\n$ ssh-add ~/.ssh/id_rsa\\n\n```\n\n----------------------------------------\n\nTITLE: Writing Function-Based Unit Tests with Pytest - Python\nDESCRIPTION: This Python snippet demonstrates a simple, function-based pytest unit test, where test discovery is triggered by function names beginning with test_. It requires pytest to be installed and supports basic assertion checks. The test checks that the sum of two numbers matches the expected result. No external dependencies beyond the pytest runner are needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#this function will be called simply because it is called test_*()\\ndef test_add():\\n    a = 10\\n    b = 23\\n    c = 33\\n    assert a + b == c\n```\n\n----------------------------------------\n\nTITLE: Conditionally Shutting Down Systems with Combined Fact Conditions (YAML)\nDESCRIPTION: This Ansible task executes `/sbin/shutdown -t now` using `ansible.builtin.command`. The `when` condition uses parentheses and the logical `or` operator to target hosts where the distribution is either CentOS version 6 OR Debian version 7, based on `ansible_facts`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Shut down CentOS 6 and Debian 7 systems\n    ansible.builtin.command: /sbin/shutdown -t now\n    when: (ansible_facts['distribution'] == \"CentOS\" and ansible_facts['distribution_major_version'] == \"6\") or\n          (ansible_facts['distribution'] == \"Debian\" and ansible_facts['distribution_major_version'] == \"7\")\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: stdout\nDESCRIPTION: Provides an example of the `stdout` key, used by modules that execute external commands. It contains a string holding the standard output produced by the executed command or utility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n\"stdout\": \"foo!\"\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Integration Tests with Docker in Bash\nDESCRIPTION: Executes Ansible integration tests for a specific target subdirectory (`name_of_test_subdirectory`) using the `ansible-test integration` command. The `--docker` flag ensures tests run in an isolated, consistent container environment (default image), and `-v` provides verbose output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test integration name_of_test_subdirectory --docker -v\n```\n\n----------------------------------------\n\nTITLE: Passing Positional and Named Arguments to Filters in Ansible YAML+Jinja\nDESCRIPTION: Illustrates different ways to pass arguments to Ansible filters using YAML+Jinja syntax. It shows examples of using positional arguments (with `ternary`), named arguments (with `to_yaml`), and a combination of both positional and named arguments (with `ternary`). Positional arguments must precede named arguments when both are used. Requires standard Ansible filters `ternary` and `to_yaml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/filter.rst#_snippet_1\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\npassing_positional: \"{{ (x == 32) | ternary('x is 32', 'x is not 32') }}\"\npassing_extra_named_parameters: \"{{ some_variable | to_yaml(indent=8, width=1337) }}\"\npassing_both: \"{{ some_variable | ternary('true value', 'false value', none_val='NULL') }}\"\n```\n\n----------------------------------------\n\nTITLE: Restart Webservers Playbook Example - Ansible Playbooks (YAML)\nDESCRIPTION: This YAML playbook snippet targets all hosts in the 'webservers' inventory group and describes a play that restarts webservers. Requires a properly defined inventory with the 'webservers' group. The playbook actions should provide the actual tasks (not shown in snippet).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: restart webservers\\n  hosts: webservers\n```\n\n----------------------------------------\n\nTITLE: Handling Task Errors with Ansible Blocks and Rescue in YAML\nDESCRIPTION: This Ansible playbook snippet illustrates error handling using a 'rescue' block. Tasks within the main 'block' are executed sequentially. If any task fails (like the deliberate 'command: /bin/false'), execution jumps to the 'rescue' section, allowing for recovery actions or specific error logging, similar to a try-catch block.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_blocks.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Handle the error\n    block:\n      - name: Print a message\n        ansible.builtin.debug:\n          msg: 'I execute normally'\n\n      - name: Force a failure\n        ansible.builtin.command: /bin/false\n\n      - name: Never print this\n        ansible.builtin.debug:\n          msg: 'I never execute, due to the above task failing, :-('\n    rescue:\n      - name: Print when errors\n        ansible.builtin.debug:\n          msg: 'I caught an error, can do stuff here to fix it, :-)'\n```\n\n----------------------------------------\n\nTITLE: Combining Host IPs/Names using Jinja2 `selectattr` and `rejectattr`\nDESCRIPTION: This Ansible task uses the `wait_for` module to check SSH connectivity for hosts. The `loop` iterates over a combined list derived from `hostvars`. `has_ah` extracts `ansible_host` for hosts where it's defined using `selectattr`, while `no_ah` extracts `inventory_hostname` (the dictionary key, accessed as attribute \"0\" after `dictsort`) for hosts where `ansible_host` is not defined using `rejectattr`. This effectively prioritizes `ansible_host`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_8\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- hosts: localhost\n  tasks:\n    - name: Check hosts in inventory that respond to ssh port\n      wait_for:\n        host: \"{{ item }}\"\n        port: 22\n      loop: '{{ has_ah + no_ah }}'\n      vars:\n        has_ah: '{{ hostvars|dictsort|selectattr(\"1.ansible_host\", \"defined\")|map(attribute=\"1.ansible_host\")|list }}'\n        no_ah: '{{ hostvars|dictsort|rejectattr(\"1.ansible_host\", \"defined\")|map(attribute=\"0\")|list }}'\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Environment Variables in Ansible group_vars (YAML)\nDESCRIPTION: This snippet illustrates storing environment variables, specifically `proxy_env` containing proxy settings, within a `group_vars` file (e.g., `group_vars/boston`). These variables become available to plays targeting hosts in the 'boston' group and can be referenced in the `environment` keyword, facilitating centralized configuration management.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_environment.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# file: group_vars/boston\n\nntp_server: ntp.bos.example.com\nbackup: bak.bos.example.com\nproxy_env:\n  http_proxy: http://proxy.bos.example.com:8080\n  https_proxy: http://proxy.bos.example.com:8080\n```\n\n----------------------------------------\n\nTITLE: Including a Role Dynamically with Tags - Ansible - YAML\nDESCRIPTION: Dynamically includes the 'foo_app_instance' role in an Ansible playbook using the 'include_role' module, specifying custom variables and a tag. Requires Ansible Core and appropriate inventory setup for the 'webservers' group. Parameters such as 'dir' and 'app_port' are passed to the role; the task is tagged with 'typeA'. Only the included statement receives the tag unless role tasks have the same tag. Inputs: inventory hosts in 'webservers'. Outputs: tasks from 'foo_app_instance' executed with provided variables.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n    - hosts: webservers\n      tasks:\n        - name: Include the foo_app_instance role\n          include_role:\n            name: foo_app_instance\n          vars:\n            dir: '/opt/a'\n            app_port: 5000\n          tags: typeA\n      # ...\n```\n\n----------------------------------------\n\nTITLE: Manually Flushing Handlers at Runtime in Ansible (YAML)\nDESCRIPTION: Shows how to manually flush and run notified handlers earlier in a playbook using the meta: flush_handlers task. Useful when handlers should execute before the end of the play, for example after key tasks but before cleanup. Demonstrates combining shell module tasks with meta operations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n  - name: Some tasks go here\\n    ansible.builtin.shell: ...\\n\\n  - name: Flush handlers\\n    meta: flush_handlers\\n\\n  - name: Some other tasks\\n    ansible.builtin.shell: ...\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Tagged Tasks in Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet provides three example tasks in an Ansible playbook, showing the use of the reserved 'always', 'tag1', and multiple tags ('always', 'tag2'). Each task uses the 'ansible.builtin.debug' module with a message to print. The tags control task execution: 'always' runs unless explicitly skipped, 'tag1' requires the matching tag to be specified, and tasks with multiple tags are impacted by any matching command-line tags or skips. Requires the Ansible core library, and any variables like 'showmevar' used must be defined elsewhere.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n- name: Print a message\\n  ansible.builtin.debug:\\n    msg: \\\"Always runs\\\"\\n  tags:\\n  - always\\n\\n- name: Print a message\\n  ansible.builtin.debug:\\n    msg: \\\"runs when you use specify tag1, all(default) or tagged\\\"\\n  tags:\\n  - tag1\\n\\n- name: Print a message\\n  ansible.builtin.debug:\\n    msg: \\\"always runs unless you explicitly skip, like if you use ``--skip-tags tag2``\\\"\\n  tags:\\n     - always\\n     - tag2\n```\n\n----------------------------------------\n\nTITLE: Prompting for Ansible Vault Password - CLI Usage (Bash)\nDESCRIPTION: Prompts the user for the vault password at runtime when executing a playbook with encrypted content. Requires Ansible to be installed and assumes 'site.yml' contains encrypted variables or files. The '--ask-vault-pass' option ensures Ansible prompts interactively for the password needed to decrypt vault-protected data. Input: CLI command; Output: Playbook behavior is interactive password prompt.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --ask-vault-pass site.yml\n```\n\n----------------------------------------\n\nTITLE: Running a Playbook with Inventory via CLI - Console\nDESCRIPTION: This console command shows how to execute an Ansible playbook (first_playbook.yml) using a specified inventory file and prompting for SSH passwords with the '-k' flag. It assumes the inventory file provided is in YAML format and that the playbook exists. Requires Ansible installed on the system and appropriate privileges on target hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\nansible-playbook -i inventory.yml -k first_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Targeting Host Groups in Ansible Playbook Tasks (YAML)\nDESCRIPTION: An Ansible task snippet written in YAML demonstrating how to target a specific host group (`dbservers`) defined in the inventory using the `hosts` directive. This task utilizes the `ansible.builtin.iptables` module to configure firewall rules, specifically allowing incoming traffic from the source IP `10.0.0.1`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_32\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: dbservers\n  tasks:\n  - name: Allow access from 10.0.0.1\n    ansible.builtin.iptables:\n      chain: INPUT\n      jump: ACCEPT\n      source: 10.0.0.1\n```\n\n----------------------------------------\n\nTITLE: Checking List Element Truthiness with 'any'/'all' in Ansible YAML\nDESCRIPTION: Demonstrates using the `any` and `all` tests (introduced in Ansible 2.4) within `when` conditions. `all` checks if all elements in a list evaluate to True, while `any` checks if at least one element evaluates to True.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  mylist:\n    - 1\n    - \"{{ 3 == 3 }}\"\n    - True\n  myotherlist:\n    - False\n    - True\ntasks:\n\n  - debug:\n      msg: \"all are true!\"\n    when: mylist is all\n\n  - debug:\n      msg: \"at least one is true\"\n    when: myotherlist is any\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Lookup Results with lookup and q Functions - Ansible YAML/Jinja2\nDESCRIPTION: This snippet compares two approaches for looping over a lookup plugin's results: explicitly invoking lookup with wantlist=True and using the shorthand q function. The example shows two debug tasks, each iterating over items from the 'ns.col.lookup_items' plugin. Dependencies include the presence of the plugin 'ns.col.lookup_items' and a compatible Ansible version. Each task receives items as loop variables in turn. This demonstrates standard and shorthand list-producing lookup usage in Ansible, using YAML with Jinja2 templates.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_lookups.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nblock:\n  - debug:\n      msg: \"{{ item }}\"\n    loop: \"{{ lookup('ns.col.lookup_items', wantlist=True) }}\"\n\n  - debug:\n      msg: \"{{ item }}\"\n    loop: \"{{ q('ns.col.lookup_items') }}\"\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook Locally within an EE using ansible-navigator (Bash)\nDESCRIPTION: This Bash command uses `ansible-navigator` to run the 'test_localhost.yml' playbook. It specifies the 'postgresql_ee' container image as the Execution Environment, directs output to stdout, pulls the image only if missing, and runs the container as root (user 0). This demonstrates executing a playbook against the container's localhost.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_execution_environment.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator run test_localhost.yml --execution-environment-image postgresql_ee --mode stdout --pull-policy missing --container-options='--user=0'\n```\n\n----------------------------------------\n\nTITLE: Defining a YAML Inventory Source for aws_ec2 Plugin (yaml)\nDESCRIPTION: Provides the minimum YAML configuration to activate the amazon.aws.aws_ec2 inventory plugin. The file name should conform to the plugin's naming schema and use the .yml extension to be recognized automatically. This snippet is expected to be placed in a file (demo.aws_ec2.yml) for Ansible to consume as a dynamic inventory source.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# demo.aws_ec2.yml\\nplugin: amazon.aws.aws_ec2\n```\n\n----------------------------------------\n\nTITLE: Accessing Network Facts for All Hosts in a Group (Jinja)\nDESCRIPTION: This Jinja2 loop shows how to obtain the IPv4 address of the eth0 interface for each host in the 'app_servers' group, leveraging the hostvars and groups magic variables. Used in templates to collect information for all group members, such as for configuring a load balancer or firewall. Requires that facts have been gathered for all involved hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_15\n\nLANGUAGE: jinja\nCODE:\n```\n{% for host in groups['app_servers'] %}\\n   {{ hostvars[host]['ansible_facts']['eth0']['ipv4']['address'] }}\\n{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Blocks - Ansible Block Tasks (YAML)\nDESCRIPTION: Illustrates how to assign tags at the block level, affecting all tasks within the block rather than tagging each individually. This allows managing groups of related tasks as a unit. Requires Ansible 2.0 or later. Key parameters involve 'block', 'tags', and task/module fields. When the tag is selected, all tasks in the block are executed; otherwise, they can be skipped.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# myrole/tasks/main.yml\n- name: ntp tasks\n  tags: ntp\n  block:\n  - name: Install ntp\n    ansible.builtin.yum:\n      name: ntp\n      state: present\n\n  - name: Configure ntp\n    ansible.builtin.template:\n      src: ntp.conf.j2\n      dest: /etc/ntp.conf\n    notify:\n    - restart ntpd\n\n  - name: Enable and run ntpd\n    ansible.builtin.service:\n      name: ntpd\n      state: started\n      enabled: true\n\n- name: Install NFS utils\n  ansible.builtin.yum:\n    name:\n    - nfs-utils\n    - nfs-util-lib\n    state: present\n  tags: filesharing\n\n```\n\n----------------------------------------\n\nTITLE: Importing Tasks with Variables in Ansible Playbook (YAML)\nDESCRIPTION: This snippet imports the same task file ('wordpress.yml') multiple times with different variable values ('wp_user'), allowing for repeating automation logic with different parameters in a single playbook. Requires Ansible installed. Each import_tasks statement statically brings in the defined tasks for a specific user context. Tasks are run with their corresponding 'wp_user' variable applied.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n- import_tasks: wordpress.yml\n  vars:\n    wp_user: timmy\n\n- import_tasks: wordpress.yml\n  vars:\n    wp_user: alice\n\n- import_tasks: wordpress.yml\n  vars:\n    wp_user: bob\n```\n\n----------------------------------------\n\nTITLE: Nesting Groups and Assigning Group Variables in INI - Ansible Inventory - Text\nDESCRIPTION: Shows how to define multiple groups of hosts and organize them hierarchically (group nesting) in INI, including assigning group variables at the parent group level. Child groups inherit from parents unless overridden.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_21\n\nLANGUAGE: text\nCODE:\n```\n[atlanta]\\nhost1\\nhost2\\n\\n[raleigh]\\nhost2\\nhost3\\n\\n[southeast:children]\\natlanta\\nraleigh\\n\\n[southeast:vars]\\nsome_server=foo.southeast.example.com\\nhalon_system_timeout=30\\nself_destruct_countdown=60\\nescape_pods=2\\n\\n[usa:children]\\nsoutheast\\nnortheast\\nsouthwest\\nnorthwest\n```\n\n----------------------------------------\n\nTITLE: Conditional Include Statement in Ansible (`main.yml`)\nDESCRIPTION: This snippet shows the main playbook file (`main.yml`) demonstrating a conditional include. The `include_tasks: other_tasks.yml` statement dynamically includes tasks from another file, but only if the variable 'x' is not defined. Unlike imports, the `when` condition applies *only* to the include statement itself, not to the tasks within the included file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\n# using a conditional on include_* only applies to the include task itself\n# main.yml\n- hosts: all\n  tasks:\n  - include_tasks: other_tasks.yml # note \"include\"\n    when: x is not defined\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Task via CLI Connection on Cisco NXOS (YAML)\nDESCRIPTION: Example Ansible task using the `cisco.nxos.nxos_config` module to back up the current configuration of a Cisco NXOS device. This task assumes a CLI connection (`ansible.netcommon.network_cli`) is configured (e.g., via group variables). It sets `backup: yes`, registers the output (backup file location) to the `backup_nxos_location` variable, and includes a condition to only run when the target OS is `cisco.nxos.nxos`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nxos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (nxos)\n  cisco.nxos.nxos_config:\n    backup: yes\n  register: backup_nxos_location\n  when: ansible_network_os == 'cisco.nxos.nxos'\n```\n\n----------------------------------------\n\nTITLE: Using Loops with Handler Notification in Ansible (YAML)\nDESCRIPTION: Shows how Ansible tasks with loops can notify handlers dynamically. The template task runs for each item (e.g., memcached and apache), templating their respective service files, and notifies corresponding handler(s). If any loop iteration results in a change, all handlers are triggered. This demonstrates combining loop variables with notify, and group-based service restarts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n- name: Template services\\n  ansible.builtin.template:\\n    src: \"{{ item }}.j2\"\\n    dest: /etc/systemd/system/{{ item }}.service\\n  # Note: if *any* loop iteration triggers a change, *all* handlers are run\\n  notify: Restart {{ item }}\\n  loop:\\n    - memcached\\n    - apache\\n\\nhandlers:\\n  - name: Restart memcached\\n    ansible.builtin.service:\\n      name: memcached\\n      state: restarted\\n\\n  - name: Restart apache\\n    ansible.builtin.service:\\n      name: apache\\n      state: restarted\\n\n```\n\n----------------------------------------\n\nTITLE: Debugging and Decrypting Ansible Vault Variable\nDESCRIPTION: Executes the Ansible debug module (`-m debug`) against localhost to display the value of a specific variable (`ansible_password`). It loads extra variables from the specified file (`-e \"@vyos_no_connection.yml\"`) and prompts for the vault password (`--ask-vault-pass`) to decrypt the variable. The output shows the decrypted password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\nansible localhost -m debug -a var=\"ansible_password\" -e \"@vyos_no_connection.yml\" --ask-vault-pass\nVault password:\n\nlocalhost | SUCCESS => {\n    \"ansible_password\": \"VyOS_SSH_password\"\n}\n```\n\n----------------------------------------\n\nTITLE: Including OS-Specific Variable Files using include_vars (Reference)\nDESCRIPTION: This reStructuredText directive includes an external Ansible task snippet (`yaml/tip_include_vars.yaml`). The referenced task demonstrates using the `include_vars` module as an alternative method for loading OS-specific variables. Instead of relying on group variable precedence, this approach explicitly includes a variable file (e.g., `group_vars/os_CentOS.yml`) within a task, often based on a condition checking the OS type.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/ansible_tips_tricks.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. literalinclude:: yaml/tip_include_vars.yaml\n      :language: yaml\n```\n\n----------------------------------------\n\nTITLE: Gathering Specific Network Interface Facts in an Ansible Playbook using YAML\nDESCRIPTION: This YAML snippet shows how to configure an Ansible playbook to gather specific network facts, focusing on interfaces for Arista devices. It sets `gather_facts: True` and uses `gather_subset: interfaces` to limit the general fact gathering. Additionally, `module_defaults` is used to configure the `arista.eos.eos_facts` module specifically to gather only interface-related configuration data via `gather_network_resources: interfaces`. This provides a structured subset of device configuration as facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: arista\n  gather_facts: True\n  gather_subset: interfaces\n  module_defaults:\n    arista.eos.eos_facts:\n      gather_network_resources: interfaces\n```\n\n----------------------------------------\n\nTITLE: Running and Polling an Asynchronous Task in Playbook using Registered Job ID (YAML+Jinja/Ansible)\nDESCRIPTION: Implements a two-step pattern: first, runs an asynchronous 'yum' task to install 'docker-io' with 'poll: 0', registering its job ID. Second, uses the async_status module to poll for the job status in a loop until completion (using 'until', 'retries', and 'delay'). Requires Ansible version supporting async and polling with 'register' and looping features. Input includes the desired package, output is job completion or failure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - name: Run an async task\n      ansible.builtin.yum:\n        name: docker-io\n        state: present\n      async: 1000\n      poll: 0\n      register: yum_sleeper\n\n    - name: Check on an async task\n      async_status:\n        jid: \"{{ yum_sleeper.ansible_job_id }}\"\n      register: job_result\n      until: job_result.finished\n      retries: 100\n      delay: 10\n```\n\n----------------------------------------\n\nTITLE: Assigning Group Variables in INI Inventory - Ansible Inventory - Text\nDESCRIPTION: Demonstrates two INI groups (hosts and subsequent group vars), where variables for a group, such as network servers and proxy, are defined under a [group:vars] header. Only one variable per line is allowed in the :vars section.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_19\n\nLANGUAGE: text\nCODE:\n```\n[atlanta]\\nhost1\\nhost2\\n\\n[atlanta:vars]\\nntp_server=ntp.atlanta.example.com\\nproxy=proxy.atlanta.example.com\n```\n\n----------------------------------------\n\nTITLE: Enabling NETCONF on Junos OS via CLI Connection (YAML)\nDESCRIPTION: Highlights a playbook task that uses the junipernetworks.junos.junos_netconf module to enable NETCONF on Junos OS devices via an initial CLI connection. Prior installation of the 'ncclient' Python package is required. The module is executed conditionally, ensuring proper network OS context. This enables switching future operations to NETCONF-based workflows.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_junos.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Enable NETCONF\\n  connection: ansible.netcommon.network_cli\\n  junipernetworks.junos.junos_netconf:\\n  when: ansible_network_os == 'junipernetworks.junos.junos'\\n\n```\n\n----------------------------------------\n\nTITLE: Listing All Installed Ansible Collections (Shell)\nDESCRIPTION: This command lists all Ansible collections installed in the default configured search paths. The output displays the collection name, its version, and the path where it is located. A '*' indicates an unknown version, often for collections under development.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_listing.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# /home/astark/.ansible/collections/ansible_collections\nCollection                 Version\n-------------------------- -------\ncisco.aci                  0.0.5\ncisco.mso                  0.0.4\nsandwiches.ham             *\nsplunk.es                  0.0.5\n\n# /usr/share/ansible/collections/ansible_collections\nCollection        Version\n----------------- -------\nfortinet.fortios  1.0.6\npureport.pureport 0.0.8\nsensu.sensu_go    1.3.0\n```\n\n----------------------------------------\n\nTITLE: Pausing Between Loop Iterations with 'loop_control' and 'pause'\nDESCRIPTION: This Ansible task shows how to introduce a delay between loop iterations. Using `loop_control` with the `pause: 3` directive, Ansible will wait for 3 seconds after processing each item ('server1', 'server2') before starting the next iteration. This is useful for tasks that might require time between actions, like provisioning resources.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_24\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# main.yml\n- name: Create servers, pause 3s before creating next\n  community.digitalocean.digital_ocean:\n    name: \"{{ item }}\"\n    state: present\n  loop:\n    - server1\n    - server2\n  loop_control:\n    pause: 3\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Plays - Ansible Play Level Tagging (YAML)\nDESCRIPTION: Demonstrates tagging at the play level, where the 'tags' keyword is applied to the play rather than to individual tasks. This tags all tasks in the play, including those from roles or implicit tasks. Suitable for cases where an entire play is related to a specific function. No special dependencies are needed; parameters include 'hosts', 'tags', and standard task/module fields.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  tags: ntp\n  tasks:\n  - name: Install ntp\n    ansible.builtin.yum:\n      name: ntp\n      state: present\n\n  - name: Configure ntp\n    ansible.builtin.template:\n      src: ntp.conf.j2\n      dest: /etc/ntp.conf\n    notify:\n    - restart ntpd\n\n  - name: Enable and run ntpd\n    ansible.builtin.service:\n      name: ntpd\n      state: started\n      enabled: true\n\n- hosts: fileservers\n  tags: filesharing\n  tasks:\n  # ...\n\n```\n\n----------------------------------------\n\nTITLE: Example Structured Data from XML Parsing (YAML)\nDESCRIPTION: This YAML snippet shows the nested dictionary structure resulting from parsing the XML output of the `show interface | xml` command using the `ansible.utils.xml` parser within `cli_parse`. It reflects the hierarchy of the original XML data, converted into Ansible-usable format.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\n   nf:rpc-reply:\n     '@xmlns': http://www.cisco.com/nxos:1.0:if_manager\n     '@xmlns:nf': urn:ietf:params:xml:ns:netconf:base:1.0\n     nf:data:\n       show:\n         interface:\n           __XML__OPT_Cmd_show_interface_quick:\n             __XML__OPT_Cmd_show_interface___readonly__:\n               __readonly__:\n                 TABLE_interface:\n                   ROW_interface:\n                   - admin_state: up\n                     encapsulation: ARPA\n                     eth_autoneg: 'on'\n                     eth_bia_addr: x254.005a.f8b5\n                     eth_bw: '1000000'\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: stderr_lines\nDESCRIPTION: Shows the `stderr_lines` key, which always accompanies the `stderr` key. It provides the standard error output as a list of strings, with each string representing one line from the original `stderr`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n\"stderr_lines\": [\n        \"ls: doesntexist: No such file or directory\"\n        ]\n```\n\n----------------------------------------\n\nTITLE: Providing Skeleton All/Ungrouped Groups for Dynamic Inventory - JSON\nDESCRIPTION: This JSON snippet provides the skeleton for a dynamic inventory script that replicates a static inventory's required structure, with 'all' and 'ungrouped' groups and empty hostvars. Essential for compatibility when migrating from INI/static to dynamic inventories. No extra dependencies beyond working with Ansible inventory scripts. The 'all' group must list all children and hosts, and 'ungrouped' must list ungrouped hosts. Used for --list responses.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"_meta\": {\n     \"hostvars\": {}\n   },\n   \"all\": {\n     \"children\": [\n       \"ungrouped\"\n     ]\n   },\n   \"ungrouped\": {\n     \"children\": [\n     ]\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Commands with Python 3 Configured Hosts (Shell)\nDESCRIPTION: Provides examples of running the `ansible` command against a specific host alias (`localhost-py3`) previously configured in inventory to use Python 3, and running `ansible-playbook`, which will use the inventory settings for Python interpreter discovery on the targeted hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/python_3_support.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible localhost-py3 -m ping\n$ ansible-playbook sample-playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Setting Up Ansible Development Environment (Bash)\nDESCRIPTION: Sources the 'env-setup' script using Bash to configure the shell environment for running Ansible directly from the cloned source code directory. This modifies PATH and PYTHONPATH.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_16\n\nLANGUAGE: console\nCODE:\n```\n$ source ./hacking/env-setup\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Collections from Git in requirements.yml (YAML)\nDESCRIPTION: This snippet shows how to configure `requirements.yml` to install an Ansible collection directly from a Git repository. It uses `type: git` and specifies the repository URL in the `name` field. The `version` key indicates the specific branch (`devel` in this case), tag, or commit hash to check out and install.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_multiple_collections.txt#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ncollections:\n  - name: https://github.com/organization/repo_name.git\n    type: git\n    version: devel\n```\n\n----------------------------------------\n\nTITLE: Configuring Source-based Collection Installation - Ansible - YAML\nDESCRIPTION: This YAML snippet demonstrates how to declare Ansible collections for installation directly from local directories in a requirements file. It includes installing from a single collection directory (type: dir) or from a directory containing multiple collections under a namespace (type: subdirs). The 'name' parameter specifies the relative or absolute path, and 'type' determines whether the path is a single collection directory or a namespace containing collections. No external dependencies are needed other than Ansible itself; paths are resolved from the current working directory, not relative to the requirements file. Input must point to valid local directories, and these options are intended for advanced or offline workflows.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_file.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ncollections:\n  # directory containing the collection\n  - name: ./my_namespace/my_collection/\n    type: dir\n\n  # directory containing a namespace, with collections as subdirectories\n  - name: ./my_namespace/\n    type: subdirs\n\n```\n\n----------------------------------------\n\nTITLE: Obtaining a Ticket Granting Ticket with Kerberos (Bash)\nDESCRIPTION: This bash command invokes kinit to request a ticket for the specified user in a Kerberos realm. The user is prompted for their password. Successful completion provides a TGT in the user's ticket cache. Required: valid Kerberos configuration and user credentials.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ kinit username@MY.DOMAIN.COM\nPassword for username@REALM.COM\n```\n\n----------------------------------------\n\nTITLE: Initializing an Ansible Role with Ansible Galaxy - Bash\nDESCRIPTION: Initializes the folder and file structure for a new Ansible role using the 'ansible-galaxy role init' command. Requires the ansible-galaxy CLI tool as a dependency. Parameter 'role_name' specifies the desired name for the role directory. The command creates subdirectories and default files needed for a role. It may error if the directory exists unless the --force option is used.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role init role_name\n```\n\n----------------------------------------\n\nTITLE: Installing Specific ansible-core Version with pipx\nDESCRIPTION: Installs a specific version (e.g., 2.12.3) of the 'ansible-core' package using pipx. This is useful for pinning to a known compatible version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ pipx install ansible-core==2.12.3\n```\n\n----------------------------------------\n\nTITLE: Explicitly Loading Cache Plugin in parse Method - Ansible Inventory Python\nDESCRIPTION: This Python snippet shows how to override the 'parse' method in a custom InventoryModule to explicitly load the cache plugin. The method calls 'super' to retain parent logic and then invokes 'load_cache_plugin' to set up inventory caching if '_read_config_data' is not used. Required arguments include 'inventory', 'loader', 'path', and the optional boolean 'cache'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nNAME = 'myplugin'\n\ndef parse(self, inventory, loader, path, cache=True):\n    super(InventoryModule, self).parse(inventory, loader, path)\n\n    self.load_cache_plugin()\n\n```\n\n----------------------------------------\n\nTITLE: Optional Shared Utility Code Path in Ansible Collections\nDESCRIPTION: Depicts the standard directory for storing shared utility code within an Ansible collection. These optional Python files, located in `/plugins/module_utils/`, contain common functions, classes, or constants (e.g., argument specifications) used by multiple modules in the collection to promote code reuse.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_in_groups.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n/plugins/module_utils/$topic.py\n```\n\n----------------------------------------\n\nTITLE: Adding Host with Composed Groups and Variables Using Constructed Methods - Python\nDESCRIPTION: This Python snippet details adding a host to Ansible inventory and using constructed methods to assign composed variables and dynamically create groups via Jinja2 expressions. It loops through supplied host variables, sets them, and invokes '_set_composite_vars', '_add_host_to_composed_groups', and '_add_host_to_keyed_groups', optionally enforcing strict variable checking as specified. The dependencies are an InventoryModule and access to constructed plugin features.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef add_host(self, hostname, host_vars):\n    self.inventory.add_host(hostname, group='all')\n\n    for var_name, var_value in host_vars.items():\n        self.inventory.set_variable(hostname, var_name, var_value)\n\n    strict = self.get_option('strict')\n\n    # Add variables created by the user's Jinja2 expressions to the host\n    self._set_composite_vars(self.get_option('compose'), host_vars, hostname, strict=True)\n\n    # Create user-defined groups using variables and Jinja2 conditionals\n    self._add_host_to_composed_groups(self.get_option('groups'), host_vars, hostname, strict=strict)\n    self._add_host_to_keyed_groups(self.get_option('keyed_groups'), host_vars, hostname, strict=strict)\n\n```\n\n----------------------------------------\n\nTITLE: Cloning Forked Collection Repository using Git\nDESCRIPTION: This Git command clones the repository containing the pull request changes from the author's GitHub account (`AUTHOR_ACC`/`COLLECTION_REPO`) into the previously created local directory (`~/ansible_collections/NAMESPACE/COLLECTION_NAME`). This step downloads the code needed for testing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_test_pr_locally.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/AUTHOR_ACC/COLLECTION_REPO.git ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Enabling Privilege Escalation for Arista EOS Devices (INI format)\nDESCRIPTION: This snippet, in INI format, shows how to set group variables for Ansible to enable privilege escalation (become) for Arista EOS network devices. It uses the ansible_connection for network_cli, specifies the operating system, and sets become and become_method to 'enable'. Dependencies are that the inventory group is properly defined and Ansible is able to reach the devices. Inputs are the variable assignments. Outputs are host connections with privilege mode enabled for tasks requiring elevated access.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[eos:vars]\nansible_connection=ansible.netcommon.network_cli\nansible_network_os=arista.eos.eos\nansible_become=yes\nansible_become_method=enable\n\n```\n\n----------------------------------------\n\nTITLE: Defining Ansible Plugin Documentation in Python\nDESCRIPTION: This Python snippet demonstrates the traditional method of embedding Ansible plugin documentation within the Python source file. It uses multiline raw strings assigned to variables like `DOCUMENTATION` and `EXAMPLES` to define metadata such as description, options, their types, defaults, environment variables, INI configurations, and required status.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/sidecar.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nDOCUMENTATION = r'''\n  description: something\n  options:\n    option_name:\n      description: describe this config option\n      default: default value for this config option\n      env:\n        - name: NAME_OF_ENV_VAR\n      ini:\n        - section: section_of_ansible.cfg_where_this_config_option_is_defined\n          key: key_used_in_ansible.cfg\n      vars:\n        - name: name_of_ansible_var\n        - name: name_of_second_var\n          version_added: X.x\n      required: True/False\n      type: boolean/float/integer/list/none/path/pathlist/pathspec/string/tmppath\n      version_added: X.x\n'''\n\nEXAMPLES = r'''\n  # TODO: write examples\n'''\n```\n\n----------------------------------------\n\nTITLE: Globally Enabling Task Debugger in ansible.cfg (INI)\nDESCRIPTION: This configuration snippet shows how to enable the Ansible task debugger globally by setting `enable_task_debugger = True` within the `[defaults]` section of the `ansible.cfg` file. When enabled this way, the debugger will automatically activate for any failed task unless explicitly overridden.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nenable_task_debugger = True\n```\n\n----------------------------------------\n\nTITLE: Launching SSH Agent with PEM Key - Secure Shell - Bash\nDESCRIPTION: Similar to the previous example, this Bash snippet starts an SSH agent and adds an alternate private key file (keypair.pem) via 'ssh-add'. This is particularly helpful when using PEM-format keys (common with cloud providers) for authentication in Ansible playbooks. Requires the referenced PEM file to have appropriate permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ssh-agent bash\\n$ ssh-add ~/.ssh/keypair.pem\\n\n```\n\n----------------------------------------\n\nTITLE: Generating Changelog for Release - antsibull-changelog (Bash)\nDESCRIPTION: This Bash code runs the 'antsibull-changelog release' command to generate or update the changelogs for an Ansible collection based on individual changelog fragments. The tool aggregates fragment files to produce a unified CHANGELOG.rst and updates relevant YAML files. No parameters are required at invocation. Requires the antsibull-changelog Python package. Output is updated changelog files in the repository; limitations depend on proper fragment formatting and placement.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nantsibull-changelog release\\n\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbook with Role and Viewing Output (Bash)\nDESCRIPTION: Demonstrates running the refactored `playbook.yml` (which now uses the 'system_demo' role) via `ansible-playbook`, limited to the 'rtr1' host. The output shows that tasks executed from within the role are prefixed with the role name (e.g., `TASK [system_demo : configure hostname]`). In this run, the status is 'ok' instead of 'changed' because the configuration was already applied in the previous example.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible ~]$ ansible-playbook playbook.yml -l rtr1\n\nPLAY [configure cisco routers] *************************************************\n\nTASK [system_demo : configure hostname] ****************************************\nok: [rtr1]\n\nTASK [system_demo : configure DNS] *********************************************\nok: [rtr1]\n\nPLAY RECAP *********************************************************************\nrtr1             : ok=2    changed=0    unreachable=0    failed=0\n```\n\n----------------------------------------\n\nTITLE: Defining CLI Inventory for Junos OS Ansible Integration (INI)\nDESCRIPTION: Sets up Ansible inventory group variables to connect to Junos OS devices using the network_cli connection method. Required variables include credentials (user, password), network OS, and optional SSH arguments for bastion access. The configuration ensures Ansible tasks use the correct connection and authentication details for CLI-based operations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_junos.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[junos:vars]\\nansible_connection=ansible.netcommon.network_cli\\nansible_network_os=junipernetworks.junos.junos\\nansible_user=myuser\\nansible_password=!vault...\\nansible_ssh_common_args='-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Importing Playbooks with Variables in Ansible Playbook (YAML)\nDESCRIPTION: This snippet imports playbooks dynamically based on variable values, allowing the imported file paths to be set at runtime via --extra-vars or vars keyword. Requires Ansible installed. Uses variables ('import_from_extra_var', 'import_from_vars') to select different playbooks for import, providing flexibility in which automation is included. The imported playbooks are statically resolved at execution start.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- import_playbook: \"/path/to/{{ import_from_extra_var }}\"\n- import_playbook: \"{{ import_from_vars }}\"\n  vars:\n    import_from_vars: /path/to/one_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Dictionary Items Using Ansible Six Utility - Python\nDESCRIPTION: This snippet illustrates using the iteritems function from ansible.module_utils.six to iterate through a dictionary's items. This approach provides compatibility for both Python 2 and Python 3, which is helpful in Ansible plugins and modules that need to support multiple Python versions. The prerequisite is that ansible.module_utils.six must be importable in the execution environment. DICT is the input dictionary, and the loop yields each (KEY, VALUE) pair as in the native approach.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-dict-iteritems.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.six import iteritems\n\nfor KEY, VALUE in iteritems(DICT):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Enabling NETCONF on Junos via Ansible Task (YAML)\nDESCRIPTION: This Ansible task uses the 'ansible.netcommon.network_cli' connection to execute the 'junipernetworks.junos.junos_netconf' module, enabling the NETCONF service on a Juniper device. The task only runs when the 'ansible_network_os' variable is set to 'junipernetworks.junos.junos'. This step is typically performed before switching the connection type to NETCONF.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netconf_enabled.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Enable NETCONF\n  connection: ansible.netcommon.network_cli\n  junipernetworks.junos.junos_netconf:\n  when: ansible_network_os == 'junipernetworks.junos.junos'\n```\n\n----------------------------------------\n\nTITLE: Replacing with_nested and with_cartesian with Loop and product Filter in Ansible YAML+Jinja\nDESCRIPTION: Shows how to replace both with_nested and with_cartesian constructs using loop and the product filter, performing a Cartesian product across two input lists. Generates debug messages for every pairwise combination of list_one and list_two. Variables should be lists of suitable elements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_9\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_nested\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }}\"\n  with_nested:\n    - \"{{ list_one }}\"\n    - \"{{ list_two }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_nested -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }}\"\n  loop: \"{{ list_one|product(list_two)|list }}\"\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Sanity Tests on a File with Docker in Bash\nDESCRIPTION: Runs Ansible sanity tests using `ansible-test sanity` on a specific changed file (`path/to/changed_file.py`). The `--docker` flag runs tests in a container for consistency, and `-v` provides verbose output. Sanity tests check for formatting, syntax, and common code errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test sanity path/to/changed_file.py --docker -v\n```\n\n----------------------------------------\n\nTITLE: Updating Ansible FQCNs for Hetzner Firewall Modules - Markdown\nDESCRIPTION: This snippet shows the migration of the Hetzner firewall module FQCN to the new community.hrobot collection. Users must update playbook references and install the required collection for compatibility with Ansible 2.9.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.hetzner_firewall`` → ``community.hrobot.firewall``\n```\n\n----------------------------------------\n\nTITLE: Referencing ansible.module_utils Module\nDESCRIPTION: Stub documentation reference for the main `ansible.module_utils` package, which contains various utility modules for Ansible module development.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_22\n\nLANGUAGE: rst\nCODE:\n```\n.. py:module:: ansible.module_utils\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook with Extra Vars (Bash)\nDESCRIPTION: Runs an Ansible playbook (`playbook.yml`) targeting only the `rtr3` host and overrides the `dns` variable to `192.168.1.1` using the `-e` option. Requires Ansible to be installed and accessible in the environment. Key parameters: `-e` for setting extra vars, `-l` for limiting playbook execution to a specific host. Inputs: playbook file, variable name and value, host specification. Output: Playbook execution with given parameters. Altering variables via extra vars can override both defaults and playbook-vars.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible ~]$ ansible-playbook playbook.yml -e \"dns=192.168.1.1\" -l rtr3\n```\n\n----------------------------------------\n\nTITLE: NTP Restart Handler Implementation - Ansible Handlers YAML\nDESCRIPTION: Defines an Ansible handler for restarting the NTP daemon whenever notified by relevant tasks. The handler is implemented using the 'ansible.builtin.service' module. Place this YAML file under roles/common/handlers/main.yml; it expects to be triggered from tasks like those ensuring NTP configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: roles/common/handlers/main.yml\\n- name: restart ntpd\\n  ansible.builtin.service:\\n    name: ntpd\\n    state: restarted\n```\n\n----------------------------------------\n\nTITLE: Configuring Play-Level Environment for NVM in Ansible (YAML/Jinja)\nDESCRIPTION: This playbook snippet shows how to configure the environment at the play level for Node Version Manager (nvm). It sets `NVM_DIR` and modifies the `PATH` variable, prepending the nvm node binary path using Jinja templating and the `ansible_env.PATH` fact. This setup enables subsequent tasks (`npm prune`, `npm install`) to use the correct Node.js version managed by nvm. Note the warning about relying on `ansible_env` as its value depends on fact gathering context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_environment.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n---\n### A playbook demonstrating a common npm workflow:\n# - Check for package.json in the application directory\n# - If package.json exists:\n#   * Run npm prune\n#   * Run npm install\n\n- hosts: application\n  become: false\n\n  vars:\n    node_app_dir: /var/local/my_node_app\n\n  environment:\n    NVM_DIR: /var/local/nvm\n    PATH: /var/local/nvm/versions/node/v4.2.1/bin:{{ ansible_env.PATH }}\n\n  tasks:\n  - name: Check for package.json\n    ansible.builtin.stat:\n      path: '{{ node_app_dir }}/package.json'\n    register: packagejson\n\n  - name: Run npm prune\n    ansible.builtin.command: npm prune\n    args:\n      chdir: '{{ node_app_dir }}'\n    when: packagejson.stat.exists\n\n  - name: Run npm install\n    community.general.npm:\n      path: '{{ node_app_dir }}'\n    when: packagejson.stat.exists\n```\n\n----------------------------------------\n\nTITLE: Encrypting String Variable using Ansible Vault Password File\nDESCRIPTION: Shows how to use `ansible-vault encrypt_string` to encrypt a specific string ('VyOS_SSH_password') and assign it to a variable name ('ansible_password'). It uses a vault ID (`my_user`) and specifies the path to the vault password file (`~/my-ansible-vault-pw-file`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\nansible-vault encrypt_string --vault-id my_user@~/my-ansible-vault-pw-file 'VyOS_SSH_password' --name 'ansible_password'\n```\n\n----------------------------------------\n\nTITLE: Defining Pinned Python Dependencies for Ansible Documentation Testing\nDESCRIPTION: This `requirements.txt` file specifies the exact versions of Python packages needed to create a reproducible environment for testing the Ansible documentation build. It lists each package with its pinned version (e.g., `aiofiles==24.1.0`) and includes comments (`# via ...`) explaining why each package is required, often indicating the originating dependency or input file (`requirements.in`, `constraints.in`). Conditional dependencies are specified using environment markers (e.g., `; platform_python_implementation != 'PyPy'`). The file was autogenerated by the `uv` tool.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/requirements.txt#_snippet_0\n\nLANGUAGE: pip-requirements\nCODE:\n```\n# This file was autogenerated by uv via the following command:\n#    uv pip compile --universal --output-file tests/requirements.txt tests/requirements.in\naiofiles==24.1.0\n    # via\n    #   antsibull-core\n    #   antsibull-fileutils\naiohappyeyeballs==2.6.1\n    # via aiohttp\naiohttp==3.11.17\n    # via\n    #   antsibull-core\n    #   antsibull-docs\naiosignal==1.3.2\n    # via aiohttp\nalabaster==0.7.16\n    # via sphinx\nannotated-types==0.7.0\n    # via\n    #   antsibull-changelog\n    #   pydantic\nansible-pygments==0.1.1\n    # via\n    #   antsibull-docs\n    #   sphinx-ansible-theme\nantsibull-changelog==0.33.0\n    # via antsibull-docs\nantsibull-core==3.4.0\n    # via antsibull-docs\nantsibull-docs==2.16.3\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\nantsibull-docs-parser==1.2.0\n    # via antsibull-docs\nantsibull-docutils==1.1.0\n    # via antsibull-changelog\nantsibull-fileutils==1.2.0\n    # via\n    #   antsibull-changelog\n    #   antsibull-core\n    #   antsibull-docs\nasyncio-pool==0.6.0\n    # via antsibull-docs\nattrs==25.3.0\n    # via aiohttp\nbabel==2.17.0\n    # via\n    #   sphinx\n    #   sphinx-intl\nbuild==1.2.2.post1\n    # via antsibull-core\ncertifi==2025.1.31\n    # via requests\ncffi==1.17.1 ; platform_python_implementation != 'PyPy'\n    # via cryptography\ncharset-normalizer==3.4.1\n    # via requests\nclick==8.1.8\n    # via sphinx-intl\ncolorama==0.4.6 ; os_name == 'nt' or sys_platform == 'win32'\n    # via\n    #   build\n    #   click\n    #   sphinx\ncryptography==44.0.2\n    # via -r tests/requirements.in\ndocutils==0.18.1\n    # via\n    #   antsibull-changelog\n    #   antsibull-docs\n    #   antsibull-docutils\n    #   rstcheck\n    #   sphinx\n    #   sphinx-rtd-theme\nfrozenlist==1.6.0\n    # via\n    #   aiohttp\n    #   aiosignal\nidna==3.10\n    # via\n    #   requests\n    #   yarl\nimagesize==1.4.1\n    # via sphinx\njinja2==3.1.6\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\n    #   antsibull-docs\n    #   sphinx\nmarkupsafe==3.0.2\n    # via jinja2\nmultidict==6.4.3\n    # via\n    #   aiohttp\n    #   yarl\npackaging==25.0\n    # via\n    #   -r tests/requirements.in\n    #   antsibull-changelog\n    #   antsibull-core\n    #   antsibull-docs\n    #   build\n    #   sphinx\npathspec==0.12.1\n    # via yamllint\nperky==0.9.3\n    # via antsibull-core\npropcache==0.3.1\n    # via\n    #   aiohttp\n    #   yarl\npycparser==2.22 ; platform_python_implementation != 'PyPy'\n    # via cffi\npydantic==2.11.3\n    # via\n    #   antsibull-changelog\n    #   antsibull-core\n    #   antsibull-docs\npydantic-core==2.33.1\n    # via pydantic\npygments==2.19.1\n    # via\n    #   ansible-pygments\n    #   sphinx\npyproject-hooks==1.2.0\n    # via build\npyyaml==6.0.2\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\n    #   antsibull-docs\n    #   antsibull-fileutils\n    #   yamllint\nrequests==2.32.3\n    # via sphinx\nresolvelib==1.1.0\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\nrstcheck==5.0.0\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\n    #   antsibull-changelog\n    #   antsibull-docs\nsemantic-version==2.10.0\n    # via\n    #   antsibull-changelog\n    #   antsibull-core\n    #   antsibull-docs\nsetuptools==78.1.1\n    # via sphinx-intl\nsix==1.17.0\n    # via twiggy\nsnowballstemmer==2.2.0\n    # via sphinx\nsphinx==7.2.5\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\n    #   antsibull-docs\n    #   sphinx-ansible-theme\n    #   sphinx-copybutton\n    #   sphinx-intl\n    #   sphinx-notfound-page\n    #   sphinx-rtd-theme\n    #   sphinxcontrib-jquery\nsphinx-ansible-theme==0.10.3\n    # via -r tests/requirements.in\nsphinx-copybutton==0.5.2\n    # via -r tests/requirements.in\nsphinx-intl==2.3.1\n    # via -r tests/requirements.in\nsphinx-notfound-page==1.1.0\n    # via -r tests/requirements.in\nsphinx-rtd-theme==3.0.2\n    # via\n    #   -c tests/constraints.in\n    #   -r tests/requirements.in\n    #   sphinx-ansible-theme\nsphinxcontrib-applehelp==2.0.0\n    # via sphinx\nsphinxcontrib-devhelp==2.0.0\n    # via sphinx\nsphinxcontrib-htmlhelp==2.1.0\n    # via sphinx\nsphinxcontrib-jquery==4.1\n    # via sphinx-rtd-theme\nsphinxcontrib-jsmath==1.0.1\n    # via sphinx\nsphinxcontrib-qthelp==2.0.0\n    # via sphinx\nsphinxcontrib-serializinghtml==2.0.0\n    # via sphinx\ntwiggy==0.5.1\n    # via\n    #   antsibull-core\n    #   antsibull-docs\ntypes-docutils==0.18.3\n    # via rstcheck\ntyping-extensions==4.13.2\n    # via\n    #   pydantic\n    #   pydantic-core\n    #   rstcheck\n    #   typing-inspection\ntyping-inspection==0.4.0\n    # via pydantic\nurllib3==2.4.0\n    # via requests\nyamllint==1.37.0\n    # via -r tests/requirements.in\nyarl==1.20.0\n    # via aiohttp\n\n```\n\n----------------------------------------\n\nTITLE: Using Inline Vaulted Variable in YAML Inventory\nDESCRIPTION: Provides an example of integrating an encrypted variable (identified by the `!vault` tag) directly within a YAML inventory file. This snippet defines variables for a group named `vyos`, including connection details and the encrypted `ansible_password`. Note that inline vaults are not supported in INI format inventories.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n# ...\n\nvyos: # this is a group in yaml inventory, but you can also do under a host\n  vars:\n    ansible_connection: ansible.netcommon.network_cli\n    ansible_network_os: vyos.vyos.vyos\n    ansible_user: my_vyos_user\n    ansible_password:  !vault |\n         $ANSIBLE_VAULT;1.2;AES256;my_user\n         66386134653765386232383236303063623663343437643766386435663632343266393064373933\n         3661666132363339303639353538316662616638356631650a316338316663666439383138353032\n         63393934343937373637306162366265383461316334383132626462656463363630613832313562\n         3837646266663835640a313164343535316666653031353763613037656362613535633538386539\n         65656439626166666363323435613131643066353762333232326232323565376635\n\n # ...\n```\n\n----------------------------------------\n\nTITLE: Incorrect YAML Syntax for Variable Assignment (Missing Quotes)\nDESCRIPTION: This snippet illustrates incorrect YAML syntax where a variable value starting with a Jinja2 expression `{{ base_path }}` is not quoted. This will cause a YAML parsing error in Ansible because the parser cannot interpret if it's a variable or the start of a dictionary.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n    - hosts: app_servers\n      vars:\n        app_path: {{ base_path }}/22\n```\n\n----------------------------------------\n\nTITLE: Using a Basic Filter in Ansible YAML+Jinja\nDESCRIPTION: Demonstrates the basic usage of an Ansible filter (`to_yaml`) applied to a variable within a `vars` block. The filter takes the value of `some_variable` as input (left of the pipe `|`) and converts it to YAML format, assigning the result to `yaml_string`. This requires the standard `to_yaml` filter available in Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/filter.rst#_snippet_0\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\nvars:\n   yaml_string: \"{{ some_variable|to_yaml }}\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Watching a Scheduled Task with Ansible win_scheduled_task (YAML/Jinja)\nDESCRIPTION: This YAML playbook snippet creates and executes a Windows scheduled task using Ansible's win_scheduled_task and waits for its completion using win_scheduled_task_stat. It uses the SYSTEM account, schedules both PowerShell and command-line actions, and triggers on registration. The snippet demonstrates self-deleting scheduled tasks for automation and describes a retry loop to wait until the task is no longer running. Dependencies include Ansible 2.5+ and Windows with WinRM connectivity.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Create scheduled task to run a process\n  win_scheduled_task:\n    name: adhoc-task\n    username: SYSTEM\n    actions:\n    - path: PowerShell.exe\n      arguments: |\n        Start-Sleep -Seconds 30  # This isn't required, just here as a demonstration\n        New-Item -Path C:\\temp\\test -ItemType Directory\n    # Remove this action if the task shouldn't be deleted on completion\n    - path: cmd.exe\n      arguments: /c schtasks.exe /Delete /TN \"adhoc-task\" /F\n    triggers:\n    - type: registration\n\n- name: Wait for the scheduled task to complete\n  win_scheduled_task_stat:\n    name: adhoc-task\n  register: task_stat\n  until: (task_stat.state is defined and task_stat.state.status != \"TASK_STATE_RUNNING\") or (task_stat.task_exists == False)\n  retries: 12\n  delay: 10\n```\n\n----------------------------------------\n\nTITLE: Defining Windows Inventory for ansible-test in Shell\nDESCRIPTION: This sequence of commands prepares the inventory file needed for running Windows integration tests in Ansible. It copies the template and opens it for editing using the user's default or vi editor. Requires presence of 'inventory.winrm.template' file and an available editor.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ncp inventory.winrm.template inventory.winrm\n${EDITOR:-vi} inventory.winrm\n```\n\n----------------------------------------\n\nTITLE: Generating Role Directory Scaffold - Ansible - Bash\nDESCRIPTION: Runs ansible-playbook with resource module builder to generate an Ansible role directory structure for 'myos'/'interfaces'. Similar dependencies as collection example. Uses rm_dest for where the files are written, structure of 'role', and the relevant YAML model file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -e rm_dest=~/github/rm_example/roles/my_role \\\n                 -e structure=role \\\n                 -e model=models/myos/interfaces/myos_interfaces.yml \\\n                 site.yml\n```\n\n----------------------------------------\n\nTITLE: Querying ansible-test with Full Path in Shell\nDESCRIPTION: This snippet illustrates invoking ansible-test using its relative path in the bin directory. It is useful when bin/ is not in the user's PATH. The command 'bin/ansible-test --help' will output help and available options for the ansible-test CLI. No special dependencies are required beyond an Ansible checkout with the bin/ansible-test executable present.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbin/ansible-test --help\n```\n\n----------------------------------------\n\nTITLE: Extending Inventory Plugins with Collection or Local Plugin Names (ini)\nDESCRIPTION: Demonstrates enabling plugins within a collection using the plugin's fully qualified collection name or enabling local plugins by name. This method is applicable when plugins are not auto-detected or are placed in custom directories referenced by DEFAULT_INVENTORY_PLUGIN_PATH. Requires Ansible 2.8+ for collection plugin syntax.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[inventory]\\nenable_plugins = host_list, script, auto, yaml, ini, toml, namespace.collection_name.inventory_plugin_name\n```\n\nLANGUAGE: ini\nCODE:\n```\n[inventory]\\nenable_plugins = host_list, script, auto, yaml, ini, toml, my_plugin\n```\n\n----------------------------------------\n\nTITLE: Ansible Debug Output for Nested Data Extraction\nDESCRIPTION: This snippet shows the expected output from the preceding Ansible `debug` task. It displays the `msg` field containing a flattened list of 'type' values extracted from the `chains_config` variable using the Jinja2 filters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_3\n\nLANGUAGE: ansible-output\nCODE:\n```\nok: [localhost] => {\n    \"msg\": [\n        \"routed\",\n        \"bridged\",\n        \"routed\",\n        \"bridged\"\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Dictionary Values with ansible.module_utils.six.itervalues - Python\nDESCRIPTION: This snippet illustrates the use of the itervalues function from the ansible.module_utils.six compatibility module to iterate over values in a dictionary, ensuring consistent behavior between Python 2 and 3. The approach requires importing itervalues and passing the dictionary (DICT) as an argument. It's used in Ansible plugins or modules that need Python 2 and 3 compatibility. Inputs are a dictionary (DICT); output is sequential access to its values, mirroring Python 2 semantics.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-dict-itervalues.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.six import itervalues\n\nfor VALUE in itervalues(DICT):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Accessing Facts from Other Hosts with hostvars in Jinja2 (Jinja)\nDESCRIPTION: This Jinja2 template expression demonstrates how to access the 'distribution' fact from another host using the hostvars special variable. Used to fetch a fact (for example, Linux distribution) from 'test.example.com' within a template or playbook. Requires that facts for 'test.example.com' are already gathered and present in the hostvars dictionary.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_13\n\nLANGUAGE: jinja\nCODE:\n```\n{{ hostvars['test.example.com']['ansible_facts']['distribution'] }}\n```\n\n----------------------------------------\n\nTITLE: Rebooting Servers with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Demonstrates rebooting all servers matching the 'atlanta' pattern in the inventory using an Ansible ad hoc command. It relies on the default `ansible.builtin.command` module (implicitly used when `-m` is omitted) to execute the `/sbin/reboot` command on the remote hosts. Requires appropriate inventory setup and SSH credentials.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible atlanta -a \"/sbin/reboot\"\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Integration Tests with Specific Docker Image in Bash\nDESCRIPTION: Demonstrates running Ansible integration tests using `ansible-test` against a specific Docker container image (`fedora35` in this example) instead of the default. Specify the desired image name after the `--docker` flag.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test integration name_of_test_subdirectory --docker fedora35 -v\n```\n\n----------------------------------------\n\nTITLE: Gathering Device Information using Ansible Templating - YAML\nDESCRIPTION: This snippet demonstrates how to use Ansible Jinja2 templating to iterate over grouped hosts and display device-specific details like hostname, version, model, and serial number. It relies on host variables such as hostvars and groups defined in the Ansible inventory, targeting different device platforms (IOS, VyOS). Inputs are Ansible inventory and facts collected by setup or network modules; output is structured information for each platform, commonly written to a report file. Limitations are that it requires pre-populated variables and is meant to be embedded in a playbook or template.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n           IOS device info:\\n             {% for host in groups['ios'] %}\\n             Hostname: {{ hostvars[host].ansible_net_hostname }}\\n             Version: {{ hostvars[host].ansible_net_version }}\\n             Model: {{ hostvars[host].ansible_net_model }}\\n             Serial: {{ hostvars[host].ansible_net_serialnum }}\\n             {% endfor %}\\n\\n           VyOS device info:\\n             {% for host in groups['vyos'] %}\\n             Hostname: {{ hostvars[host].ansible_net_hostname }}\\n             Version: {{ hostvars[host].ansible_net_version }}\\n             Model: {{ hostvars[host].ansible_net_model }}\\n             Serial: {{ hostvars[host].ansible_net_serialnum }}\\n             {% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Roles via Playbook - Ansible Role Tagging (YAML)\nDESCRIPTION: Shows how to assign tags to all tasks in a role by specifying the 'tags' keyword within the role definition in your playbook. This causes all role tasks (and dependencies) to inherit the tags. Requires proper playbook and role structure. The main components include 'roles', 'role', 'tags', and optional 'vars'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nroles:\n  - role: webserver\n    vars:\n      port: 5000\n    tags: [ web, foo ]\n\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Against a Host Using an Inventory Plugin Source (bash)\nDESCRIPTION: Provides an example Bash command to run Ansible against a specific host using the -i flag to specify a custom inventory source, which may be a YAML or other compatible format file. Requires ansible to be installed and inventory_source to reference a valid and accessible inventory file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible hostname -i inventory_source -m ansible.builtin.ping\n```\n\n----------------------------------------\n\nTITLE: Behavior Change in gitlab_deploy_key Module (Ansible)\nDESCRIPTION: Highlights a behavior change in the `gitlab_deploy_key` module from the `community.general` collection. Previously, providing a different public key for an existing key title did nothing; now, it updates the public key to the new value.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_17\n\nLANGUAGE: ansible\nCODE:\n```\ngitlab_deploy_key\n```\n\n----------------------------------------\n\nTITLE: Defining Host-Specific Variables - Ansible YAML\nDESCRIPTION: This file provides hardware or application port overrides for an individual host. Place in host_vars/db-bos-1.example.com so that only this system receives the 'foo_agent_port' and 'bar_agent_port' values. Used for granular configuration control in heterogeneous clusters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: host_vars/db-bos-1.example.com\\nfoo_agent_port: 86\\nbar_agent_port: 99\n```\n\n----------------------------------------\n\nTITLE: Defining Task 'Changed' Status with Multiple AND Conditions (YAML)\nDESCRIPTION: This Ansible task shows using a list of conditions under `changed_when`, implying an AND relationship. The task executes `/bin/fake_command`, ignores potential errors, and registers the result. It will report 'changed' status only if *both* conditions are met: the string 'ERROR' is present in standard error (`result.stderr`) AND the return code (`result.rc`) is exactly 2.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Combine multiple conditions to override 'changed' result\n  ansible.builtin.command: /bin/fake_command\n  register: result\n  ignore_errors: True\n  changed_when:\n    - '\"ERROR\" in result.stderr'\n    - result.rc == 2\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible CLI Connection Variables for EXOS (YAML)\nDESCRIPTION: Defines Ansible group variables in `group_vars/exos.yml` for connecting to EXOS devices using the network_cli (SSH) connection. It specifies the connection type (`ansible.netcommon.network_cli`), the network OS (`community.network.exos`), user credentials (`ansible_user`, `ansible_password` using vault), and optional SSH arguments (`ansible_ssh_common_args`) for using a bastion host via `ProxyCommand`. Remove password if using SSH keys, remove `ansible_ssh_common_args` if not using a bastion host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_exos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: community.network.exos\nansible_user: myuser\nansible_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Example Fully Qualified Collection Names (FQCN) for Ansible Plugins\nDESCRIPTION: Provides examples of Fully Qualified Collection Names (FQCNs) used to uniquely identify Ansible plugins (like modules) within the ecosystem. An FQCN follows the format `namespace.collection_name.plugin_name`, clearly indicating its origin and specific function.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_in_groups.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ncommunity.mongodb.mongodb_linux\n```\n\nLANGUAGE: text\nCODE:\n```\ncisco.meraki.meraki_device\n```\n\n----------------------------------------\n\nTITLE: Structuring the RETURN Block for Complex/Nested Values (Text/YAML)\nDESCRIPTION: This snippet shows how to document complex, nested return values in the `RETURN` block. It defines a top-level dictionary `packages` which contains nested lists and dictionaries (`missing`, `badversion`), each with their own descriptions, types, elements, and samples, using the `contains` key to structure the hierarchy. The code represents the YAML structure expected within the raw string literal assigned to the RETURN variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n.. code-block:: text\n\n    RETURN = r'''\n    packages:\n        description: Information about package requirements.\n        returned: success\n        type: dict\n        contains:\n            missing:\n                description: Packages that are missing from the system.\n                returned: success\n                type: list\n                elements: str\n                sample:\n                    - libmysqlclient-dev\n                    - libxml2-dev\n            badversion:\n                description: Packages that are installed but at bad versions.\n                returned: success\n                type: list\n                elements: dict\n                sample:\n                    - package: libxml2-dev\n                      version: 2.9.4+dfsg1-2\n                      constraint: \">= 3.0\"\n    '''\n```\n\n----------------------------------------\n\nTITLE: Correct Variable Syntax for include_tasks using 'vars' in YAML\nDESCRIPTION: Illustrates the required syntax in Ansible 2.7 for passing variables to `include_tasks`. Variables must now be specified under the `vars` keyword, replacing the deprecated inline variable method.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.7.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- include_tasks: include_me.yml\n  vars:\n    variable: value\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbooks (Shell)\nDESCRIPTION: Refers to the `ansible-playbook` command-line tool. This command is used to execute Ansible playbooks, which contain ordered sets of tasks to be run against inventory hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Dependencies using pip in Shell\nDESCRIPTION: Installs Python packages listed in the 'requirements.txt' file using pip. These are prerequisites needed to run Ansible from the source checkout after setting up the environment with 'env-setup'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ pip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Using Explicit Imports in Ansible Python Code - Python\nDESCRIPTION: Shows the preferred approach of explicit imports for Ansible modules in Python. Specific classes or symbols such as 'six' and 'AnsibleModule' are referenced directly, improving readability and easing static analysis. Dependencies remain the same as in the wildcard variant; referenced modules must be available. The explicit form clarifies what is imported and reduces namespace conflicts, supporting robust code refactoring.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-wildcard-import.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils import six\nif isinstance(variable, six.string_types):\n    do_something(variable)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import AnsibleModule\nmodule = AnsibleModule()\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Role to a Specific Path via CLI\nDESCRIPTION: Shows how to use the `--roles-path` option with `ansible-galaxy role install` to specify a custom installation directory for a role downloaded from Ansible Galaxy. In this example, the role `geerlingguy.apache` is installed into the current working directory (`.`). Requires the `ansible-galaxy` command-line tool.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role install --roles-path . geerlingguy.apache\n```\n\n----------------------------------------\n\nTITLE: Configuring SSH ProxyCommand for Bastion Host (INI)\nDESCRIPTION: This snippet shows an example SSH configuration file (`~/.ssh/config` or a custom file specified via ANSIBLE_NETCONF_SSH_CONFIG). It configures a `ProxyCommand` for all hosts (`Host *`) to route SSH connections through a specified jump host (`jumphost.fqdn.com`) using a specific username (`jumphost-username`). This allows Ansible's NETCONF connection to reach devices behind the jump host. Strict host key checking is disabled for simplicity.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netconf_enabled.rst#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\nHost *\n  proxycommand ssh -o StrictHostKeyChecking=no -W %h:%p jumphost-username@jumphost.fqdn.com\n  StrictHostKeyChecking no\n```\n\n----------------------------------------\n\nTITLE: Including Multiple Documentation Fragments/Sections in YAML\nDESCRIPTION: This YAML snippet shows how to include multiple documentation fragments or sections from fragments by providing a list to the `extends_documentation_fragment` directive. It includes both the default `DOCUMENTATION` section and the `other` section from `example_fragment`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    extends_documentation_fragment:\n      - example_fragment\n      - example_fragment.other\n```\n\n----------------------------------------\n\nTITLE: Tasks File for Conditional Import Example (`other_tasks.yml`)\nDESCRIPTION: This is the content of `other_tasks.yml`, which is imported by the `main.yml` example. It contains two tasks: one to set the variable 'x' using `ansible.builtin.set_fact`, and another to print 'x' using `ansible.builtin.debug`. When imported conditionally, the `when` condition from the import statement applies to both these tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\n# other_tasks.yml\n- name: Set a variable\n  ansible.builtin.set_fact:\n    x: foo\n\n- name: Print a variable\n  ansible.builtin.debug:\n    var: x\n```\n\n----------------------------------------\n\nTITLE: Checking out Pull Request Branch using Git\nDESCRIPTION: This Git command switches the active branch within the cloned repository to the specific branch associated with the pull request (`pr_branch`). The exact branch name can usually be found on the pull request page on GitHub. This ensures the code being tested includes the proposed changes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_test_pr_locally.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout pr_branch\n```\n\n----------------------------------------\n\nTITLE: Configuring Python 3 Interpreter in Ansible Inventory (INI)\nDESCRIPTION: Illustrates how to configure managed hosts to use a specific Python 3 interpreter using Ansible inventory files (INI format). It shows setting the `ansible_python_interpreter` variable for a single host alias (`localhost-py3`) and defining it as a group variable for all hosts within the `py3_hosts` group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/python_3_support.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n# Example inventory that makes an alias for localhost that uses Python3\nlocalhost-py3 ansible_host=localhost ansible_connection=local ansible_python_interpreter=/usr/bin/python3\n\n# Example of setting a group of hosts to use Python3\n[py3_hosts]\nubuntu16\nfedora27\n\n[py3_hosts:vars]\nansible_python_interpreter=/usr/bin/python3\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule._diff Attribute\nDESCRIPTION: Stub documentation reference for the `_diff` attribute of the `AnsibleModule` class, likely related to the diff mode.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule._diff\n```\n\n----------------------------------------\n\nTITLE: Enabling Network Logging with Environment Variables - Shell\nDESCRIPTION: This snippet shows how to enable verbose Ansible network logging by exporting the ANSIBLE_LOG_PATH and ANSIBLE_DEBUG environment variables, and then running ansible-playbook with connection-level verbosity (-vvvv). Prerequisites include access to the Ansible control node shell and the appropriate environment. This allows problem diagnosis by storing detailed logs in the specified path, useful for troubleshooting network device interactions. Sensitive information may be logged, so caution is advised.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Specify the location for the log file\\nexport ANSIBLE_LOG_PATH=~/ansible.log\\n# Enable Debug\\nexport ANSIBLE_DEBUG=True\\n\\n# Run with 4*v for connection level verbosity\\nansible-playbook -vvvv ...\n```\n\n----------------------------------------\n\nTITLE: Example Output of 'until' with 'loop'\nDESCRIPTION: This snippet shows sample console output from running an Ansible task that combines `loop` with an `until` condition and retries. It demonstrates how the task retries for the first item (msg: 1) because the `until` condition is not met, indicating multiple attempts before potential failure for that specific item within the loop.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_34\n\nLANGUAGE: none\nCODE:\n```\n[started TASK: debug on localhost]\nFAILED - RETRYING: [localhost]: debug (2 retries left).Result was: {\n    \"attempts\": 1,\n    \"changed\": false,\n    \"msg\": 1,\n    \"retries\": 3\n}\nFAILED - RETRYING: [localhost]: debug (1 retries left).Result was: {\n    \"attempts\": 2,\n    \"changed\": false,\n    \"msg\": 1,\n```\n\n----------------------------------------\n\nTITLE: Using Ansible Vault ID with Source Specification (Bash)\nDESCRIPTION: Illustrates the command-line pattern for specifying a vault ID (`label`) along with its corresponding password source (`source`). The source can be a prompt (implicit if no '@' is used), a file path, or an executable client script path. This syntax is used with options like `--vault-id` in commands such as `ansible-vault` and `ansible-playbook`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_managing_passwords.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--vault-id label@source\n```\n\n----------------------------------------\n\nTITLE: Defining Windows Paths Using key=value Style in Ansible (INI)\nDESCRIPTION: This snippet presents examples of specifying Windows directory paths using the legacy key=value syntax used by Ansible ad hoc commands and older playbooks. It highlights the correct forms with properly escaped backslashes, forms that may work but are discouraged, and forms that can cause parsing failures due to mistaken escape sequences (e.g., '\\\\t' as a tab). Applies when using key=value on the command line; note escaping requirements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_10\n\nLANGUAGE: ini\nCODE:\n```\n# GOOD\ntempdir=C:\\\\Windows\\\\Temp\n\n# WORKS\ntempdir='C:\\\\Windows\\\\Temp'\ntempdir=\"C:\\\\Windows\\\\Temp\"\n\n# BAD, BUT SOMETIMES WORKS\ntempdir=C:\\Windows\\Temp\ntempdir='C:\\Windows\\Temp'\ntempdir=\"C:\\Windows\\Temp\"\ntempdir=C:/Windows/Temp\n\n# FAILS\ntempdir=C:\\Windows\\temp\ntempdir='C:\\Windows\\temp'\ntempdir=\"C:\\Windows\\temp\"\n```\n\n----------------------------------------\n\nTITLE: Mandatory Shebang for Ansible Modules (Python)\nDESCRIPTION: Specifies the required shebang line for Ansible modules. Ansible modules must use `#!/usr/bin/python` and should not have execute permissions set. This ensures consistency in how modules are invoked by the Ansible engine.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/shebang.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/python\n```\n\n----------------------------------------\n\nTITLE: Defining Ansible Inventory Groups for Fact Gathering Example (INI format)\nDESCRIPTION: This snippet illustrates a minimal example of grouping switches for use in a demo playbook. It creates the parent group 'switches' and child groups for eos, ios, and vyos, with a single host for each. Dependencies: file is read by Ansible before running the facts-gathering playbook. Key parameters are group and host names. Input is explicitly defined hosts; output is accessible groups and hosts in subsequent plays. There are no credential variables here.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[switches:children]\neos\nios\nvyos\n\n[eos]\neos01.example.net\n\n[ios]\nios01.example.net\n\n[vyos]\nvyos01.example.net\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Trimming Multiline Variables: Ansible Playbook YAML Syntax (2.0.x)\nDESCRIPTION: This YAML snippet demonstrates the approach in Ansible 2.0.x for explicitly trimming trailing newlines from a multiline variable using Python slicing within Jinja2 templates. The code creates 'old_message' with a trailing newline and assigns 'message' to the version without the last character. Dependencies include Jinja2 templating and understanding of string slicing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  old_message: >\n    Testing\n    some things\n  message: \"{{ old_message[:-1] }}\"\ntasks:\n- debug:\n    msg: \"{{ message }}\"\n```\n\n----------------------------------------\n\nTITLE: Conditionally Omitting Items from a List using Jinja2 `reject` and `omit`\nDESCRIPTION: This Ansible task uses `set_fact` to define `win_feature_list`. It starts with a list `namestuff` where the first element is conditionally set to the special `omit` variable or 'FS-SMB1' based on `fs_installed_smb_v1`. The `reject('equalto', omit)` filter removes any `omit` elements before creating the final list. The `omit` variable is specific to Ansible module options but can be used as a marker here.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_6\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- name: Enable a list of Windows features, by name\n  ansible.builtin.set_fact:\n    win_feature_list: \"{{ namestuff | reject('equalto', omit) | list }}\"\n  vars:\n    namestuff:\n      - \"{{ (fs_installed_smb_v1 | default(False)) | ternary(omit, 'FS-SMB1') }}\"\n      - \"foo\"\n      - \"bar\"\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: results\nDESCRIPTION: Demonstrates the `results` key, which appears when a task uses a loop. It contains a list, where each item represents the standard module result for one iteration of the loop.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n\"results\": [\n    {\n        \"ansible_loop_var\": \"item\",\n        \"backup\": \"foo.txt.83170.2020-07-30@07:03:05~\",\n        \"changed\": true,\n        \"diff\": [\n            {\n                \"after\": \"\",\n                \"after_header\": \"foo.txt (content)\",\n                \"before\": \"\",\n                \"before_header\": \"foo.txt (content)\"\n            },\n            {\n                \"after_header\": \"foo.txt (file attributes)\",\n                \"before_header\": \"foo.txt (file attributes)\"\n            }\n        ],\n        \"failed\": false,\n        \"invocation\": {\n            \"module_args\": {\n                \"attributes\": null,\n                \"backrefs\": false,\n                \"backup\": true\n            }\n        },\n        \"item\": \"foo\",\n        \"msg\": \"line added\"\n    },\n    {\n        \"ansible_loop_var\": \"item\", \n        \"backup\": \"foo.txt.83187.2020-07-30@07:03:05~\",\n        \"changed\": true,\n        \"diff\": [\n            {\n                \"after\": \"\",\n                \"after_header\": \"foo.txt (content)\",\n                \"before\": \"\",\n                \"before_header\": \"foo.txt (content)\"\n            },\n            {\n                \"after_header\": \"foo.txt (file attributes)\",\n                \"before_header\": \"foo.txt (file attributes)\"\n            }\n        ],\n        \"failed\": false,\n        \"invocation\": {\n            \"module_args\": {\n                \"attributes\": null,\n                \"backrefs\": false,\n                \"backup\": true\n            }\n        },\n        \"item\": \"bar\",\n        \"msg\": \"line added\"\n    }\n    ]\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Prompts with Single Answer Behavior using cli_command (YAML)\nDESCRIPTION: This Ansible task uses `ansible.netcommon.cli_command` to reload an IOS device. It demonstrates handling multiple prompts (`Save?` and `confirm`) using the `prompt` and `answer` parameters. Importantly, without `check_all: True` (or set to `False`), the first answer ('y' in this case) will be sent in response to *any* prompt that matches one of the regex patterns in the `prompt` list. This example also highlights the need to escape regex special characters (like `?`) within the `prompt` values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_working_with_command_output.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\n - name: reboot ios device\n   ansible.netcommon.cli_command:\n     command: reload\n     prompt:\n       - Save\\?\n       - confirm\n     answer:\n       - y\n       - y\n```\n\n----------------------------------------\n\nTITLE: Block Inclusion in Included File - Ansible Playbook YAML\nDESCRIPTION: This snippet illustrates an included YAML file defining a block of tasks—a debug message and an apt package installation. In Ansible 2.4, when this included file is brought in by a dynamic include, the tasks inside this block do not inherit any tags or attributes from the including task. This can cause expected task-level attributes to not propagate. Requires Ansible 2.4 or later; expects variables like 'ansible_distribution' to be used for file selection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- block:\n    - debug:\n        msg: \"In included file\"\n\n    - apt:\n        name: nginx\n        state: latest\n```\n\n----------------------------------------\n\nTITLE: Viewing Ansible Log Files - Console\nDESCRIPTION: Displays how to inspect Ansible log files with the 'less' command, followed by a sample excerpt from a typical Ansible networking log. This demonstrates key log format elements such as PID, user, connection plugin, socket path, and success indications. No dependencies except a generated Ansible log file. Outputs log details essential for tracing network module execution and connection problems.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nless $ANSIBLE_LOG_PATH\\n\\n2017-03-30 13:19:52,740 p=28990 u=fred |  creating new control socket for host veos01:22 as user admin\\n2017-03-30 13:19:52,741 p=28990 u=fred |  control socket path is /home/fred/.ansible/pc/ca5960d27a\\n2017-03-30 13:19:52,741 p=28990 u=fred |  current working directory is /home/fred/ansible/test/integration\\n2017-03-30 13:19:52,741 p=28990 u=fred |  using connection plugin network_cli\\n...\\n2017-03-30 13:20:14,771 paramiko.transport userauth is OK\\n2017-03-30 13:20:15,283 paramiko.transport Authentication (keyboard-interactive) successful!\\n2017-03-30 13:20:15,302 p=28990 u=fred |  ssh connection done, setting terminal\\n2017-03-30 13:20:15,321 p=28990 u=fred |  ssh connection has completed successfully\\n2017-03-30 13:20:15,322 p=28990 u=fred |  connection established to veos01 in 0:00:22.580626\n```\n\n----------------------------------------\n\nTITLE: Running Specific Ansible Unit Tests with Docker in Bash\nDESCRIPTION: Executes a specific set of unit tests located in the specified path (e.g., `tests/unit/plugins/test_myclass.py`) using the `ansible-test units` command. The `--docker` flag ensures the tests run within an isolated container environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test units tests/unit/plugins/test_myclass.py --docker\n```\n\n----------------------------------------\n\nTITLE: Variable Prefixing in theforeman.foreman Collection (Ansible)\nDESCRIPTION: Specifies that all role variables within the `theforeman.foreman` collection are now prefixed with `foreman_` to prevent naming conflicts with variables from other roles or collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_23\n\nLANGUAGE: ansible\nCODE:\n```\nforeman_\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Task with `batch` Logon Type using Become (YAML)\nDESCRIPTION: This Ansible task executes the `ansible.windows.win_whoami` module on a Windows host. It utilizes `become: true` to escalate privileges. The `become_flags` are set to `logon_type=batch`, causing the command to run under a batch logon context, similar to a scheduled task. This can bypass most WinRM restrictions and is useful if the `become_user` lacks interactive logon rights.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n- name: run a command under a batch logon\n  ansible.windows.win_whoami:\n  become: true\n  become_flags: logon_type=batch\n```\n\n----------------------------------------\n\nTITLE: Installing Collections from a Namespace Directory - Ansible Galaxy - Bash\nDESCRIPTION: Shows how to install all Ansible collections found within a specific namespace directory using ansible-galaxy. The command expects the path provided to represent a directory containing one or more valid collection subdirectories. It installs all collections under that namespace by referencing the target path.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install /path/to/ns\n```\n\n----------------------------------------\n\nTITLE: Correcting List Processing with 'map' Filter in Jinja (Ansible)\nDESCRIPTION: This revised Ansible task demonstrates the correct way to apply the `replace` filter to each element of a list. It uses the `map` filter to iterate over the list (`['test1', 'test2']`) and apply `replace('test', 'prod')` to each item individually. This approach preserves the list structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_16\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - debug:\n        msg: \"{{ ['test1', 'test2'] | map('replace', 'test', 'prod') }}\"\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests in Fedora Container via ansible-test in Shell\nDESCRIPTION: This command runs all POSIX integration tests under the 'shippable/' directory using ansible-test in a Fedora 34 Docker container. Requires Docker installed and access to the Ansible source repository. The '--docker' flag ensures environment isolation and consistency. Input is the shippable/ test target; output is the result of all relevant integration tests executed inside the container.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration shippable/ --docker fedora34\n```\n\n----------------------------------------\n\nTITLE: Testing Module Failure and Error Message with Ansible Assert (YAML)\nDESCRIPTION: This playbook snippet shows how to test expected module failure in Ansible. It runs 'abstract_module', registers the result, and uses an 'assert' task to confirm that the task fails with a specific error message. Useful for validating error handling. Requires target module behavior and accurate expected message specification; outputs are assertion checks of failure and error message.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_about.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Task to fail\\n  abstract_module:\\n      ...\\n  register: result\\n\\n- name: Check the task fails and its error message\\n  assert:\\n    that:\\n      - result is failed\\n      - result.msg == 'Message we expect'\n```\n\n----------------------------------------\n\nTITLE: Running PowerShell Scripts with win_powershell (Ansible/YAML)\nDESCRIPTION: This snippet shows how to use the 'ansible.windows.win_powershell' module in an Ansible playbook to execute a PowerShell script on a Windows host, maintaining compatibility with the new plugin execution framework. Dependency: Requires the 'ansible.windows.win_powershell' module and Windows hosts. Key parameter: 'script' contains the PowerShell command(s) to run. Input: a string representing the PowerShell script. Output: execution results with captured output and errors. Limitation: Only runs in environments where PowerShell is available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.18.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run with win_powershell\\n  ansible.windows.win_powershell:\\n    script: Write-Host \\\"Hello, Caf\\u00e9\\\"\n```\n\n----------------------------------------\n\nTITLE: Notifying Multiple Handlers from a Task in Ansible (YAML)\nDESCRIPTION: Illustrates how a single Ansible task can notify multiple handlers using a notify list. The example shows a template update task notifying both memcached and apache restart handlers, which are defined using the service module. Handlers execute only if the task registers as changed, and they run once per play per notification. This snippet demonstrates handler ordering and de-duplication.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n- name: Template configuration file\\n  ansible.builtin.template:\\n    src: template.j2\\n    dest: /etc/foo.conf\\n  notify:\\n    - Restart apache\\n    - Restart memcached\\n\\nhandlers:\\n  - name: Restart memcached\\n    ansible.builtin.service:\\n      name: memcached\\n      state: restarted\\n\\n  - name: Restart apache\\n    ansible.builtin.service:\\n      name: apache\\n      state: restarted\\n\n```\n\n----------------------------------------\n\nTITLE: Securing Conditionals in Ansible Playbooks using YAML\nDESCRIPTION: These YAML snippets demonstrate how conditional expressions in Ansible playbooks can lead to security vulnerabilities when referencing untrusted data through embedded templates, and provide a secure alternative. No external dependencies are required, but referencing module results directly in conditionals must be done as variables rather than templates. Inputs include registered module results (e.g., from the shell module); outputs are assertion pass/fail. When referencing untrusted data, use direct variable access to mitigate unsafe template evaluation in conditionals, as enforced in ansible-core 2.14.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.14.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: task with a module result (always untrusted by Ansible)\n  shell: echo \"hi mom\"\n  register: untrusted_result\n\n# don't do it this way...\n# - name: insecure conditional with embedded template consulting untrusted data\n#   assert:\n#     that: '\"hi mom\" is in {{ untrusted_result.stdout }}'\n\n- name: securely access untrusted values directly as Jinja variables instead\n  assert:\n    that: '\"hi mom\" is in untrusted_result.stdout'\n```\n\n----------------------------------------\n\nTITLE: Starting Service with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Ensures that the 'httpd' service is running on all hosts within the 'webservers' group. It uses the `ansible.builtin.service` module with the argument `name=httpd state=started`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.service -a \"name=httpd state=started\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Dictionary Variable in Ansible using YAML\nDESCRIPTION: This YAML snippet defines a variable named `foo` as a dictionary (or hash/map) containing key-value pairs. `field1` maps to 'one' and `field2` maps to 'two'. This demonstrates standard YAML syntax for defining dictionaries.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n  foo:\n    field1: one\n    field2: two\n```\n\n----------------------------------------\n\nTITLE: Skipping Tasks or Ignoring Errors in Ansible Check Mode (YAML)\nDESCRIPTION: These YAML task examples demonstrate using the 'ansible_check_mode' magic variable to conditionally skip or ignore errors during dry runs. The 'when: not ansible_check_mode' statement skips a task in check mode, while 'ignore_errors: \"{{ ansible_check_mode }}\"' prevents errors from failing the playbook during simulation runs. These constructs enhance robustness when using Ansible for pre-deployment validation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_checkmode.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n  - name: This task will be skipped in check mode\n    ansible.builtin.git:\n      repo: ssh://git@github.com/mylogin/hello.git\n      dest: /home/mylogin/hello\n    when: not ansible_check_mode\n\n  - name: This task will ignore errors in check mode\n    ansible.builtin.git:\n      repo: ssh://git@github.com/mylogin/hello.git\n      dest: /home/mylogin/hello\n    ignore_errors: \"{{ ansible_check_mode }}\"\n```\n\n----------------------------------------\n\nTITLE: Encrypting String Variable using Ansible Vault Password Prompt\nDESCRIPTION: Demonstrates encrypting a string ('VyOS_SSH_password') with `ansible-vault encrypt_string` by prompting the user for the vault password associated with the vault ID (`my_user@prompt`) instead of reading it from a file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nansible-vault encrypt_string --vault-id my_user@prompt 'VyOS_SSH_password' --name 'ansible_password'\n```\n\n----------------------------------------\n\nTITLE: Organizing Multi-Environment Ansible Directory Structure - Console Example\nDESCRIPTION: This console block illustrates organizing Ansible inventories and variable directories for multiple environments. Each environment (production, staging) has its own isolated group_vars and host_vars subdirectories to support separation of configuration and variables. It also shows where to place custom modules, filters, core playbooks, and roles for scalable automation across different setups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\ninventories/\\n   production/\\n      hosts               # inventory file for production servers\\n      group_vars/\\n         group1.yml       # here we assign variables to particular groups\\n         group2.yml\\n      host_vars/\\n         hostname1.yml    # here we assign variables to particular systems\\n         hostname2.yml\\n\\n   staging/\\n      hosts               # inventory file for staging environment\\n      group_vars/\\n         group1.yml       # here we assign variables to particular groups\\n         group2.yml\\n      host_vars/\\n         stagehost1.yml   # here we assign variables to particular systems\\n         stagehost2.yml\\n\\nlibrary/\\nmodule_utils/\\nfilter_plugins/\\n\\nsite.yml\\nwebservers.yml\\ndbservers.yml\\n\\nroles/\\n    common/\\n    webtier/\\n    monitoring/\\n    fooapp/\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Directory Definitions Using with_items: Ansible Playbook YAML Syntax\nDESCRIPTION: This YAML playbook demonstrates iterating over a list of dictionaries defining directories using the 'file' module with 'with_items' and 'args' in Ansible 2.0.x. It highlights the required use of full Jinja2 variable syntax (i.e., '{{item}}') and marks the deprecation of bare variable names for module arguments. Dependencies include the core 'file' module and correct structuring of variables for iterative module calls.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: localhost\n  connection: local\n  gather_facts: false\n  vars:\n    my_dirs:\n      - { path: /tmp/3a, state: directory, mode: 0755 }\n      - { path: /tmp/3b, state: directory, mode: 0700 }\n  tasks:\n    - file:\n      args: \"{{item}}\"\n      with_items: \"{{my_dirs}}\"\n```\n\n----------------------------------------\n\nTITLE: Using ansible_failed_task and ansible_failed_result in Ansible Rescue Blocks (YAML)\nDESCRIPTION: This Ansible example illustrates how to access information about the failing task within a 'rescue' block. The special variables 'ansible_failed_task' (containing metadata like the task name) and 'ansible_failed_result' (containing the task's registered result) can be used in conditional logic ('when' statements) to tailor the rescue operation based on which task failed and its output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_blocks.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Attempt and graceful roll back demo\n    block:\n      - name: Do Something\n        ansible.builtin.shell: grep $(whoami) /etc/hosts\n\n      - name: Force a failure, if previous one succeeds\n        ansible.builtin.command: /bin/false\n    rescue:\n      - name: All is good if the first task failed\n        when: ansible_failed_task.name == 'Do Something'\n        ansible.builtin.debug:\n          msg: All is good, ignore error as grep could not find 'me' in hosts\n\n      - name: All is good if the second task failed\n        when: \"'/bin/false' in ansible_failed_result.cmd | d([])\"\n        ansible.builtin.fail:\n          msg: It is still false!!!\n```\n\n----------------------------------------\n\nTITLE: Overriding Play-Level Keywords in Ansible Playbook (YAML)\nDESCRIPTION: Shows keyword precedence within an Ansible playbook. A play-level `connection: ssh` is defined. The first task inherits this setting, while the second task explicitly overrides it with `connection: paramiko`, demonstrating that task-level settings take precedence over more general play-level settings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  connection: ssh\n  tasks:\n    - name: This task uses ssh.\n      ping:\n\n    - name: This task uses paramiko.\n      connection: paramiko\n      ping:\n```\n\n----------------------------------------\n\nTITLE: Notifying Includes and Imports as Handlers - Ansible Documentation - Markdown\nDESCRIPTION: This snippet explains how dynamic and static includes (using include_task and import_task) behave when referenced as handlers in Ansible. It emphasizes that dynamic includes result in all tasks being run when notified and that static includes are rewritten before execution. Key considerations include that dynamic includes cannot define notifiable handlers and that handlers defined within static imports can be notified individually.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\nNotifying a dynamic include such as ``include_task`` as a handler results in executing all tasks from within the include. It is not possible to notify a handler defined inside a dynamic include.\n\nHaving a static include such as ``import_task`` as a handler results in that handler being effectively rewritten by handlers from within that import before the play execution. A static include itself cannot be notified; the tasks from within that include, on the other hand, can be notified individually.\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Network Privilege Mode via Ansible Group Vars YAML\nDESCRIPTION: This YAML snippet, intended for a group variables file (e.g., `group_vars/eos.yml`), demonstrates how to configure Ansible to always use privilege escalation (`ansible_become: true`, `ansible_become_method: enable`) for hosts in that group. It also sets the necessary connection type (`ansible.netcommon.network_cli`) and network OS (`arista.eos.eos`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: arista.eos.eos\nansible_user: myuser\nansible_become: true\nansible_become_method: enable\n```\n\n----------------------------------------\n\nTITLE: Simulating Nested Loops using Jinja2 'product' Filter\nDESCRIPTION: This task demonstrates simulating a nested loop by formatting data appropriately. It uses the Jinja2 `product` filter to create a Cartesian product of two lists (`['alice', 'bob']` and `['clientdb', 'employeedb', 'providerdb']`). The resulting list contains pairs like `['alice', 'clientdb']`, `['alice', 'employeedb']`, etc. The `community.mysql.mysql_user` module then iterates over this combined list, effectively granting each user access to each database.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_30\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Give users access to multiple databases\n  community.mysql.mysql_user:\n    name: \"{{ item[0] }}\"\n    priv: \"{{ item[1] }}.*:ALL\"\n    append_privs: true\n    password: \"foo\"\n  loop: \"{{ ['alice', 'bob'] | product(['clientdb', 'employeedb', 'providerdb']) | list }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Ansible Collections in requirements.yml (YAML+Jinja)\nDESCRIPTION: This snippet shows the basic YAML structure for listing collections within a `requirements.yml` file. It demonstrates defining a collection by just its name (`my_namespace.my_collection`) and a more detailed definition including name, version range (`>=1.2.0`), and source URL. The `version` defaults to `*` (any) and `source` defaults to the `--api-server` command-line setting if omitted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_multiple_collections.txt#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n---\ncollections:\n# With just the collection name\n- my_namespace.my_collection\n\n# With the collection name, version, and source options\n- name: my_namespace.my_other_collection\n  version: \">=1.2.0\" # Version range identifiers (default: ``*``)\n  source: ... # The Galaxy URL to pull the collection from (default: ``--api-server`` from cmdline)\n```\n\n----------------------------------------\n\nTITLE: Chaining Role Variable Inheritance and Overriding in Ansible Playbooks - YAML\nDESCRIPTION: This snippet sets up a playbook including multiple roles, showing how variables defined by one role (common_settings) are available to subsequent roles. If a variable (foo) is set in the 'something' role, it overrides the value in 'common_settings' only for that role's scope. Demonstrates variable sharing and scoping across role invocations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_27\n\nLANGUAGE: yaml\nCODE:\n```\n roles:\\n    - role: common_settings\\n    - role: something\\n      vars:\\n        foo: 12\\n    - role: something_else\n```\n\n----------------------------------------\n\nTITLE: Executing Platform-Agnostic Commands using Group Vars - YAML\nDESCRIPTION: This streamlined playbook runs a group-variable-defined command (show_interfaces) across all hosts in the 'routers' group using the ansible.netcommon.cli_command module. It showcases how group_vars combined with platform-independent modules reduce code duplication even further. Input is a host group and a templated variable representing the desired command; the output is a result registered per host. This pattern requires consistent naming of group_vars and the ansible.netcommon collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: Run command and print to terminal window\\n  hosts: routers\\n  gather_facts: false\\n\\n  tasks:\\n    - name: Run show command\\n      ansible.netcommon.cli_command:\\n        command: \"{{show_interfaces}}\"\\n      register: command_output\n```\n\n----------------------------------------\n\nTITLE: Validating Command Output Using Ansible Shell and Assert Modules in YAML\nDESCRIPTION: Combines Ansible's 'shell' module to execute a command, registering its result, with the 'assert' module to enforce multiple conditions on stdout and stderr. This enables tests for expected strings (e.g., verifying 'gizmo enabled' and absence of 'not ready'). Useful for embedding domain-specific health checks in deployments. Requires shell access to the command and Ansible's register/assert syntax familiarity.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n   - ansible.builtin.shell: /usr/bin/some-command --parameter value\n     register: cmd_result\n\n   - ansible.builtin.assert:\n       that:\n         - \"'not ready' not in cmd_result.stderr\"\n         - \"'gizmo enabled' in cmd_result.stdout\"\n```\n\n----------------------------------------\n\nTITLE: Combining Lists with set_fact - Ansible - YAML\nDESCRIPTION: Demonstrates using the set_fact module to combine two list variables (list1 and list2) into a single merged_list within an Ansible playbook task. Requires the ansible.builtin.set_fact module. Takes list variables as input and outputs a new list variable; lists must be present in vars. No special limitations except both lists should be defined beforehand.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  list1:\n  - apple\n  - banana\n  - fig\n\n  list2:\n  - peach\n  - plum\n  - pear\n\ntasks:\n- name: Combine list1 and list2 into a merged_list var\n  ansible.builtin.set_fact:\n    merged_list: \"{{ list1 + list2 }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Archive-based Collection Installation - Ansible - YAML\nDESCRIPTION: This YAML code illustrates how to install an Ansible collection directly from a package archive (typically created with 'ansible-galaxy collection build' or downloaded from Galaxy) using a requirements file. The 'name' parameter should point to the .tar.gz archive and 'type' must be set to 'file'. This mechanism facilitates offline or reproducible installations. The input file path must be accessible, and no external dependencies are required beyond Ansible itself. Ensure that the specified archive is a valid collection package for successful installation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_file.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ncollections:\n  - name: /tmp/my_namespace-my_collection-1.0.0.tar.gz\n    type: file\n\n```\n\n----------------------------------------\n\nTITLE: Executing an Ad-Hoc Ansible Command to Retrieve Network Facts using Bash\nDESCRIPTION: This single Ansible command retrieves configuration facts from a network device specified directly in the inventory string (`-i vyos.example.net,`). It targets all hosts (`all`), uses the `ansible.netcommon.network_cli` connection method (`-c`), specifies the SSH user (`-u my_vyos_user`), prompts for the SSH password (`-k`), runs the `vyos.vyos.vyos_facts` module (`-m`), and provides the network OS type as an extra variable (`-e ansible_network_os=vyos.vyos.vyos`). The trailing comma after the hostname in the inventory flag (`-i`) signifies a host list rather than an inventory file path. If using SSH keys with ssh-agent, the `-k` flag can be omitted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible all -i vyos.example.net, -c ansible.netcommon.network_cli -u my_vyos_user -k -m vyos.vyos.vyos_facts -e ansible_network_os=vyos.vyos.vyos\n```\n\n----------------------------------------\n\nTITLE: Importing a Role with Variables - Ansible - YAML\nDESCRIPTION: Illustrates importing the 'foo_app_instance' role and passing parameters with 'import_role' in a playbook. The given variables ('dir' and 'app_port') are set for the duration of the imported tasks. Requires existing Ansible inventory and the specified role. Accepts arbitrary task keywords, such as variables and tags. Outputs: tasks are run with provided parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  tasks:\n    - name: Import the foo_app_instance role\n      import_role:\n        name: foo_app_instance\n      vars:\n        dir: '/opt/a'\n        app_port: 5000\n  # ...\n```\n\n----------------------------------------\n\nTITLE: Interpreting Ansible Task Result Output - Plaintext\nDESCRIPTION: This snippet shows sample output from running an Ansible playbook that processes multiple items with retry logic and error reporting. Each result entry reflects the task's execution for a specific item, including failed attempts, retries remaining, and eventual success or fatal failure. This is useful for users learning how Ansible logs looped task progress, and does not require any external dependencies or actual code execution; inputs are items in a loop, and outputs are log records mapping task status (ok, failed, fatal) to input values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_35\n\nLANGUAGE: plaintext\nCODE:\n```\n\"        \\\"retries\\\": 3\\n    }\\n    failed: [localhost] (item=1) => {\\n        \\\"msg\\\": 1\\n    }\\n    FAILED - RETRYING: [localhost]: debug (2 retries left).Result was: {\\n        \\\"attempts\\\": 1,\\n        \\\"changed\\\": false,\\n        \\\"msg\\\": 2,\\n        \\\"retries\\\": 3\\n    }\\n    FAILED - RETRYING: [localhost]: debug (1 retries left).Result was: {\\n        \\\"attempts\\\": 2,\\n        \\\"changed\\\": false,\\n        \\\"msg\\\": 2,\\n        \\\"retries\\\": 3\\n    }\\n    failed: [localhost] (item=2) => {\\n        \\\"msg\\\": 2\\n    }\\n    ok: [localhost] => (item=3) => {\\n        \\\"msg\\\": 3\\n    }\\n    fatal: [localhost]: FAILED! => {\\\"msg\\\": \\\"One or more items failed\\\"}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Managing Local Windows Users, Groups, and ACLs - Ansible Playbook YAML\nDESCRIPTION: This snippet provides an end-to-end example for managing local users, groups, directories, and access control lists (ACLs) using Ansible on Windows. Tasks cover creating groups and users, setting folders, assigning permissions, and adjusting ACL inheritance. The modules win_user, win_group, win_group_membership, win_file, win_acl, and win_acl_inheritance are utilized. Inputs are user/group specs and paths; outputs are user/group creation and updated folder permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_2\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Create local group to contain new users\\n  win_group:\\n    name: LocalGroup\\n    description: Allow access to C:\\\\Development folder\\n\\n- name: Create local user\\n  win_user:\\n    name: '{{ item.name }}'\\n    password: '{{ item.password }}'\\n    groups: LocalGroup\\n    update_password: false\\n    password_never_expires: true\\n  loop:\\n  - name: User1\\n    password: Password1\\n  - name: User2\\n    password: Password2\\n\\n- name: Create Development folder\\n  win_file:\\n    path: C:\\\\Development\\n    state: directory\\n\\n- name: Set ACL of Development folder\\n  win_acl:\\n    path: C:\\\\Development\\n    rights: FullControl\\n    state: present\\n    type: allow\\n    user: LocalGroup\\n\\n- name: Remove parent inheritance of Development folder\\n  win_acl_inheritance:\\n    path: C:\\\\Development\\n    reorganize: true\\n    state: absent\n```\n\n----------------------------------------\n\nTITLE: Support for ansible_network_import_modules (Ansible)\nDESCRIPTION: Indicates that support for the `ansible_network_import_modules` feature in various network collections (arista.eos, cisco.asa, cisco.ios, cisco.iosxr, cisco.nxos, junipernetworks.junos, vyos.vyos) requires `ansible.netcommon` v2.0.0+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_35\n\nLANGUAGE: ansible\nCODE:\n```\nansible_network_import_modules\n```\n\n----------------------------------------\n\nTITLE: Defining Site-Wide Deployment Plays in Ansible (YAML)\nDESCRIPTION: This is the main site deployment playbook (`site.yml`) which orchestrates the setup of the entire application stack. It consists of multiple plays, each targeting specific host groups (`all`, `dbservers`, `webservers`, `lbservers`, `monitoring`) and applying corresponding roles (`common`, `db`, `base-apache`, `web`, `haproxy`, `nagios`) to configure different tiers of the infrastructure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# This playbook deploys the whole application stack in this site.\n\n# Apply common configuration to all hosts\n- hosts: all\n\n  roles:\n  - common\n\n# Configure and deploy database servers.\n- hosts: dbservers\n\n  roles:\n  - db\n\n# Configure and deploy the web servers. Note that we include two roles\n# here, the 'base-apache' role which simply sets up Apache, and 'web'\n# which includes our example web application.\n\n- hosts: webservers\n\n  roles:\n  - base-apache\n  - web\n\n# Configure and deploy the load balancer(s).\n- hosts: lbservers\n\n  roles:\n  - haproxy\n\n# Configure and deploy the Nagios monitoring node(s).\n- hosts: monitoring\n\n  roles:\n  - base-apache\n  - nagios\n\n```\n\n----------------------------------------\n\nTITLE: Defining Module-Specific Environment Variable Names (Example)\nDESCRIPTION: Recommends using module-specific environment variable names to avoid conflicts when modules fall back on environment variables for default values, particularly for credentials used with helpers like `module_utils.api` or `module_utils.urls.fetch_url()`. The example format uses the API name, module name, and the credential type.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nAPI_<MODULENAME>_USERNAME\n```\n\n----------------------------------------\n\nTITLE: Defining Python Test Dependencies for Ansible Tagging\nDESCRIPTION: Specifies the exact versions of Python packages required for Ansible's tagging tests, generated by `uv pip compile`. It includes dependencies like `click`, `gitpython`, `rich`, and `typer`, with comments detailing their provenance (via which other package they were included) and platform constraints (e.g., `colorama` for Windows). This ensures a consistent environment for testing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/tag.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# This file was autogenerated by uv via the following command:\n#    uv pip compile --universal --output-file tests/tag.txt tests/tag.in\nclick==8.1.8\n    # via typer\ncolorama==0.4.6 ; sys_platform == 'win32'\n    # via click\ngitdb==4.0.12\n    # via gitpython\ngitpython==3.1.44\n    # via -r tests/tag.in\nmarkdown-it-py==3.0.0\n    # via rich\nmdurl==0.1.2\n    # via markdown-it-py\npackaging==25.0\n    # via -r tests/tag.in\npygments==2.19.1\n    # via rich\nrich==14.0.0\n    # via typer\nshellingham==1.5.4\n    # via typer\nsmmap==5.0.2\n    # via gitdb\ntyper==0.15.2\n    # via -r tests/tag.in\ntyping-extensions==4.13.2\n    # via typer\n```\n\n----------------------------------------\n\nTITLE: Replacing 'slave' with 'replica' in mysql_replication Messages (Ansible)\nDESCRIPTION: Notes that the word `slave` in messages returned by the `mysql_replication` module (`community.mysql`) has been replaced with `replica`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_45\n\nLANGUAGE: ansible\nCODE:\n```\nslave\n```\n\nLANGUAGE: ansible\nCODE:\n```\nreplica\n```\n\n----------------------------------------\n\nTITLE: Checking List/Dictionary Emptiness in Conditionals using Jinja\nDESCRIPTION: Illustrates the recommended way to check if a list or dictionary is non-empty within an Ansible `when` condition using the `length` filter combined with a comparison (`> 0`). Using the `bool` filter directly on lists or dictionaries is discouraged as it always evaluates to `False`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- debug:\n  when: my_list | length > 0\n\n- debug:\n  when: my_dictionary | length > 0\n```\n\n----------------------------------------\n\nTITLE: Displaying Ansible Facts using Debug Module (YAML)\nDESCRIPTION: This Ansible task utilizes the `ansible.builtin.debug` module to display the value of the `ansible_facts` variable. This is useful for inspecting the available facts on a target system, which can then be used in conditional statements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Show facts available on the system\n  ansible.builtin.debug:\n    var: ansible_facts\n```\n\n----------------------------------------\n\nTITLE: Prompting for Password for Specific Vault ID - CLI Usage (Bash)\nDESCRIPTION: Prompts the user for the password belonging to a specific vault ID (e.g., 'dev') at runtime. Requires Ansible and a playbook with encrypted content labeled by vault IDs. The format 'dev@prompt' tells Ansible to prompt for the 'dev' vault ID. Input: CLI command; Output: Interactive password prompt for specified vault ID.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id dev@prompt site.yml\n```\n\n----------------------------------------\n\nTITLE: Configuring Fallback with env_fallback - Ansible Python\nDESCRIPTION: This example demonstrates how to use the fallback argument in an Ansible module option specification, assigning env_fallback with a list of environment variable names. It requires the env_fallback utility function of Ansible and expects a tuple where the first element is the callable function to use for lookup and the second is the list of fallback values. The username parameter will utilize the ANSIBLE_NET_USERNAME environment variable if not otherwise provided.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nusername=dict(fallback=(env_fallback, ['ANSIBLE_NET_USERNAME']))\n```\n\n----------------------------------------\n\nTITLE: Checking ansible-test Location on PATH - Shell\nDESCRIPTION: Uses which to display the directory path to the ansible-test executable currently resolved in the user\\'s shell environment. Ensures the correct (source code) version is used, not an installed one.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nwhich ansible-test\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: diff\nDESCRIPTION: Demonstrates the `diff` return key structure, providing information on differences between the previous and current state of a resource. It often contains `before` and `after` entries, formatted by callback plugins.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n\"diff\": [\n        {\n            \"after\": \"\",\n            \"after_header\": \"foo.txt (content)\",\n            \"before\": \"\",\n            \"before_header\": \"foo.txt (content)\"\n        },\n        {\n            \"after_header\": \"foo.txt (file attributes)\",\n            \"before_header\": \"foo.txt (file attributes)\"\n        }\n\n```\n\n----------------------------------------\n\nTITLE: Using --upgrade Flag for Transitive Dependency Updates (Ansible CLI)\nDESCRIPTION: Describes the use of the `--upgrade` flag with `ansible-galaxy collection install`. This flag forces updates for transitive dependencies when reinstalling or upgrading collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_25\n\nLANGUAGE: plaintext\nCODE:\n```\n--upgrade\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Roles via Role List - Ansible Role List Tagging (YAML)\nDESCRIPTION: Demonstrates an alternative way of tagging roles using YAML shorthand when listing roles in a playbook. Tagging at this level ensures that all contained tasks are executed or skipped according to the tags. Works in standard Ansible playbook structures. Key elements are 'hosts', 'roles', 'role', and 'tags'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - role: foo\n      tags:\n        - bar\n        - baz\n    # using YAML shorthand, this is equivalent to:\n    # - { role: foo, tags: [\"bar\", \"baz\"] }\n\n```\n\n----------------------------------------\n\nTITLE: Removing an Installed Role using ansible-galaxy Command (Bash)\nDESCRIPTION: This Bash command demonstrates how to use `ansible-galaxy role remove` followed by the role's fully qualified name (`namespace.role_name`) to uninstall a specific role from the configured `roles_path`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role remove namespace.role_name\n```\n\n----------------------------------------\n\nTITLE: Executing Ad-Hoc Ansible Commands (Shell)\nDESCRIPTION: Refers to the primary Ansible command-line tool `/usr/bin/ansible`. This command is used for executing single modules or ad-hoc tasks directly against specified hosts without needing a full playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n/usr/bin/ansible\n```\n\n----------------------------------------\n\nTITLE: Limiting Playbook Runs with --limit Option - Ansible Playbooks (Bash)\nDESCRIPTION: These bash snippets demonstrate how to limit target hosts in Ansible playbooks using the '--limit' flag and the inventory option '-i'. Examples include matching specific hosts, groups, and reading host lists from files. Some methods require comma syntax and manual variable specification if inventory is bypassed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook site.yml --limit datacenter2\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook site.yml --limit @retry_hosts.txt\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook site.yml --limit @site.retry\n```\n\n----------------------------------------\n\nTITLE: Migrating Gluster Modules from community.general\nDESCRIPTION: The `gluster_heal_info`, `gluster_peer`, and `gluster_volume` modules have been migrated to the `gluster.gluster` collection. These modules will be removed from community.general in version 3.0.0. Users should update playbooks to use the modules from the `gluster.gluster` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_11\n\nLANGUAGE: Ansible\nCODE:\n```\ngluster_heal_info\n```\n\nLANGUAGE: Ansible\nCODE:\n```\ngluster_peer\n```\n\nLANGUAGE: Ansible\nCODE:\n```\ngluster_volume\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Changelog Bugfix Entry (copy module) in YAML\nDESCRIPTION: Shows another YAML example of a 'bugfixes' entry, this time for the 'copy' module in an Ansible changelog fragment. It describes fixing an issue where file mode was incorrectly attempted to be changed for remote sources ('remote_src=True') on certain filesystems, along with the associated issue link.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nbugfixes:\n  - copy - the module was attempting to change the mode of files for\n    remote_src=True even if mode was not set as a parameter.  This failed on\n    filesystems which do not have permission bits (https://github.com/ansible/ansible/issues/29444).\n```\n\n----------------------------------------\n\nTITLE: Importing Network Module Utilities in Python (Ansible 2.4)\nDESCRIPTION: Shows the Python import statement used in Ansible 2.4 to access shared module utilities for a specific network platform (VyOS). This path structure is deprecated in Ansible 2.5.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.vyos import get_config, load_config\n```\n\n----------------------------------------\n\nTITLE: Requiring Explicit Enablement for Ansible Vars Plugins (Python)\nDESCRIPTION: This Python code defines a vars plugin class `VarsModule` inheriting from `BaseVarsPlugin` and sets the class attribute `REQUIRES_ENABLED = True`. This configuration prevents the vars plugin from running automatically and requires users to explicitly enable it in their Ansible configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n    class VarsModule(BaseVarsPlugin):\n        REQUIRES_ENABLED = True\n```\n\n----------------------------------------\n\nTITLE: Running a CNOS CLI Command Task in Ansible Playbook (YAML)\nDESCRIPTION: This YAML snippet shows a task within an Ansible playbook that retrieves the Lenovo CNOS device OS version using the community.network.cnos_command module. It runs the command 'show version' when the target device is identified as community.network.cnos. Dependencies include the community.network Ansible collection and a configured Ansible network connection context. Input parameters include the command to execute and the condition to match CNOS devices; output is command result data returned in the default format (stdout[0]).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_cnos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve CNOS OS version\\n  community.network.cnos_command:\\n    commands: show version\\n  when: ansible_network_os == 'community.network.cnos'\n```\n\n----------------------------------------\n\nTITLE: Backing Up Arista EOS Configuration via eAPI using Ansible YAML Task\nDESCRIPTION: This Ansible task, written in YAML, uses the `arista.eos.eos_config` module over an eAPI connection (`ansible.netcommon.httpapi`) to back up an Arista EOS device's configuration. It demonstrates passing proxy settings defined in the `proxy_env` group variable to the task's `environment` parameter, enabling connection through a web proxy. The `backup: yes` parameter initiates the backup, the task runs conditionally, and the result is stored in `backup_eos_location`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eos.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (eos)\n  arista.eos.eos_config:\n    backup: yes\n  register: backup_eos_location\n  environment: \"{{ proxy_env }}\"\n  when: ansible_network_os == 'arista.eos.eos'\n```\n\n----------------------------------------\n\nTITLE: Defining Navigation Trees with Sphinx reStructuredText - reStructuredText\nDESCRIPTION: Demonstrates the use of the .. toctree:: directive in reStructuredText to create structured navigation hierarchies within Sphinx-based documentation. Each block specifies a section of the documentation (caption), the level of hierarchy to display (maxdepth), and child documentation files to include. No external dependencies are required outside of Sphinx, and the snippets expect documentation files to reside in specified relative paths. Outputs a structured navigable index for documentation rendering; usage is limited to Sphinx-compatible reStructuredText environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/ansible_index.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Ansible getting started\\n\\n   getting_started/index\\n   getting_started_ee/index\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Installation, Upgrade & Configuration\\n\\n   installation_guide/index\\n   porting_guides/porting_guides\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Using Ansible\\n\\n   inventory_guide/index\\n   command_guide/index\\n   playbook_guide/index\\n   vault_guide/index\\n   module_plugin_guide/index\\n   collections_guide/index\\n   os_guide/index\\n   tips_tricks/index\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Contributing to Ansible\\n\\n   community/index\\n   community/contributions_collections\\n   community/contributions\\n   community/advanced_index\\n   dev_guide/style_guide/index\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Extending Ansible\\n\\n   dev_guide/index\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :glob:\\n   :maxdepth: 1\\n   :caption: Common Ansible Scenarios\\n\\n   scenario_guides/cloud_guides\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Network Automation\\n\\n   network/getting_started/index\\n   network/user_guide/index\\n   network/dev_guide/index\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Ansible Galaxy\\n\\n   galaxy/user_guide.rst\\n   galaxy/dev_guide.rst\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 1\\n   :caption: Reference & Appendices\\n\\n   collections/index\\n   collections/all_plugins\\n   reference_appendices/playbooks_keywords\\n   reference_appendices/common_return_values\\n   reference_appendices/config\\n   reference_appendices/general_precedence\\n   reference_appendices/YAMLSyntax\\n   reference_appendices/python_3_support\\n   reference_appendices/interpreter_discovery\\n   reference_appendices/release_and_maintenance\\n   reference_appendices/test_strategies\\n   dev_guide/testing/sanity/index\\n   reference_appendices/faq\\n   reference_appendices/glossary\\n   reference_appendices/module_utils\\n   reference_appendices/special_variables\\n   reference_appendices/tower\\n   reference_appendices/automationhub\\n   reference_appendices/logging\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 2\\n   :caption: Roadmaps\\n\\n   roadmap/ansible_roadmap_index.rst\\n   roadmap/ansible_core_roadmap_index.rst\n```\n\n----------------------------------------\n\nTITLE: Running a Playbook with an Inventory Directory - Ansible CLI - Bash\nDESCRIPTION: Shows how to specify an inventory directory when running an Ansible playbook from the command line. The '-i' option points to the inventory directory, allowing Ansible to automatically aggregate all inventory sources found within it. Inputs include the path to the playbook and the inventory directory; outputs are playbook execution results.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook example.yml -i inventory\n```\n\n----------------------------------------\n\nTITLE: Extracting Uptime of Host with Most Recent Reboot Using Facts - Ansible - YAML+Jinja\nDESCRIPTION: Shows how to use Jinja2 filters to extract and sort the 'ansible_uptime_seconds' fact for all hosts, finding the minimum, i.e., the host that was most recently rebooted. This uses the 'map' filter with 'extract', and the 'sort' and 'first' filters. Prerequisites: Host facts ('ansible_uptime_seconds') must be gathered. Input is the hostvars and list of hosts; output is the uptime value with the smallest value. Limitations: Expects all hosts to have 'ansible_uptime_seconds' fact set.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_14\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\nvars:\n  uptime_of_host_most_recently_rebooted: \"{{ansible_play_hosts_all | map('extract', hostvars, 'ansible_uptime_seconds') | sort | first}}\"\n```\n\n----------------------------------------\n\nTITLE: Triggering Fact Gathering in Ansible Playbook (YAML)\nDESCRIPTION: This is the first play within the `rolling_update.yml` playbook. Although it targets the `monitoring` hosts, it contains no explicit tasks (`tasks: []`). Its purpose is to force Ansible to gather facts from all monitoring servers before proceeding with the update, ensuring their information (like IP addresses) is available for subsequent tasks in the rolling update process.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: monitoring\n  tasks: []\n\n```\n\n----------------------------------------\n\nTITLE: Authentication Failure Log Output - Plain Text\nDESCRIPTION: Demonstrates output from an Ansible run where user authentication (typically via SSH) has failed, such as incorrect username/password or invalid ssh key configuration. This output is critical for diagnosing login failures due to credential or SSH key issues; it's automatically emitted by Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\n<ios01> ESTABLISH CONNECTION FOR USER: cisco on PORT 22 TO ios01\n<ios01> Authentication failed.\n```\n\n----------------------------------------\n\nTITLE: Managing Ansible Collections with ansible-galaxy\nDESCRIPTION: The `ansible-galaxy collection` command is used to interact with Ansible Galaxy or compatible repositories (like a self-hosted Pulp 3 instance) to manage Collections. Common subcommands include `install`, `list`, `remove`, and `init`, allowing users to download, view, delete, or create collection structures. It's essential for working with reusable Ansible content packaged as collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection\n```\n\n----------------------------------------\n\nTITLE: Main Infrastructure Playbook Importing Role-Specific Playbooks - Ansible YAML\nDESCRIPTION: Demonstrates how to aggregate multiple playbook files using 'import_playbook'. The site.yml acts as the entry point for automating both webserver and dbserver groups. This structure enables reusable, modular playbooks, improving scalability and maintainability. No parameters are required; invoked with 'ansible-playbook site.yml'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: site.yml\\n- import_playbook: webservers.yml\\n- import_playbook: dbservers.yml\n```\n\n----------------------------------------\n\nTITLE: Populating Variables Dynamically with the lookup Function - Ansible YAML/Jinja2\nDESCRIPTION: This snippet demonstrates how to set a variable in an Ansible playbook using the lookup function to retrieve data from an external source (in this case, a file at /etc/motd) and how to use that variable in a task. Dependencies include a working Ansible environment with access to the target plugin (here, 'file') and read permissions for the file. The 'motd_value' variable is evaluated fresh each execution and can be used throughout the playbook. The code is written in YAML with embedded Jinja2 templating.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_lookups.rst#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nvars:\n  motd_value: \"{{ lookup('file', '/etc/motd') }}\"\ntasks:\n  - debug:\n      msg: \"motd value is {{ motd_value }}\"\n```\n\n----------------------------------------\n\nTITLE: Executing Pre-Update Tasks in Ansible Rolling Update (YAML)\nDESCRIPTION: This snippet shows the `pre_tasks` section within the rolling update play in `rolling_update.yml`. These tasks run on each web server *before* the main roles/tasks update it. The example includes disabling Nagios alerts for the specific host being updated (using `delegate_to` to run the `nagios` module on the monitoring servers) and a comment indicating where a task to disable the server in the HAProxy load balancer would go.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\npre_tasks:\n- name: disable nagios alerts for this host webserver service\n  nagios:\n    action: disable_alerts\n    host: \"{{ inventory_hostname }}\"\n    services: webserver\n  delegate_to: \"{{ item }}\"\n  loop: \"{{ groups.monitoring }}\"\n\n- name: disable the server in haproxy\n\n```\n\n----------------------------------------\n\nTITLE: Running an Entire Playbook Locally Using ansible-playbook (Shell)\nDESCRIPTION: Shows how to execute an entire Ansible playbook locally on 127.0.0.1 by passing the --connection=local flag to ansible-playbook. Useful for system configuration, CI, or installer scenarios (e.g., in kickstart). Dependencies: Ansible installed on target. Inputs: playbook.yml file location. Output: Local host configuration is applied. Limitation: Only affects local system.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook playbook.yml --connection=local\n```\n\n----------------------------------------\n\nTITLE: Verifying Collection Signature with Keyring - ansible-galaxy CLI - Bash\nDESCRIPTION: Uses the --keyring option to verify the signature of a locally installed and signed collection. The keyring (e.g., ~/.ansible/pubring.kbx) must contain the public key used to sign the collection. This validates both content and authenticity for collections with provided signatures.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection  --keyring ~/.ansible/pubring.kbx\n```\n\n----------------------------------------\n\nTITLE: Loop Item with Omitted Value in Ansible Playbook (Omit Placeholder, YAML+Jinja)\nDESCRIPTION: This snippet passes an omitted value ('omit') through a loop, resulting in 'msg' being undefined in the loop item. Recent Ansible-core requires explicit use of 'default(omit)' to propagate omitted items correctly. Needs a playbook context with looping. Output: shows potential undefined variable handling in updated loop semantics.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_12\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - debug:\n        msg: \"{{ item.msg }}\"  # 'msg' is undefined\n      loop:\n       - msg: \"{{ omit }}\"  # 'msg' will be omitted from the loop item\n```\n\n----------------------------------------\n\nTITLE: Example: Creating Directory for community.general Collection using Bash\nDESCRIPTION: This Bash command provides a specific example of creating the directory structure for the `community.general` Ansible collection within the user's home directory. It uses `mkdir -p` for idempotent directory creation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_test_pr_locally.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/ansible_collections/community/general\n```\n\n----------------------------------------\n\nTITLE: Defining OS-Specific Variables using Group Vars\nDESCRIPTION: This snippet demonstrates how to set different variable values based on dynamically created OS groups. A default value for `asdf` is set in `group_vars/all`, while a specific override (`asdf: 42`) is defined in `group_vars/os_CentOS.yml`. Ansible automatically loads these variables when hosts belonging to the `os_CentOS` group (created dynamically via `group_by`) are targeted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/ansible_tips_tricks.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# file: group_vars/all\nasdf: 10\n\n---\n# file: group_vars/os_CentOS.yml\nasdf: 42\n```\n\n----------------------------------------\n\nTITLE: Enabling Inventory Cache in YAML Inventory Configuration\nDESCRIPTION: Shows how to enable caching directly within a YAML configuration file for a specific inventory plugin, such as `aws_ec2`. The `cache: True` key-value pair enables caching specifically for the inventory source defined in this file (e.g., `dev.aws_ec2.yaml`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n# dev.aws_ec2.yaml\nplugin: aws_ec2\ncache: True\n```\n\n----------------------------------------\n\nTITLE: Manually Connecting to a Network Device via SSH using Bash\nDESCRIPTION: This sequence of commands demonstrates manually connecting to a network device (specifically a VyOS router in the example) using SSH, retrieving its configuration with the 'show config' command, and then closing the session. This step helps verify connectivity, user credentials, and establishes the device's authenticity by adding its RSA key to the known hosts file. Users should replace 'my_vyos_user' and 'vyos.example.net' with their actual credentials and device address.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nssh my_vyos_user@vyos.example.net\nshow config\nexit\n```\n\n----------------------------------------\n\nTITLE: Installing a Range of Ansible Galaxy Collection Versions - Bash\nDESCRIPTION: This command shows how to install the most recent version of a collection that satisfies multiple version constraints (greater than or equal to 1.0.0 and less than 2.0.0). Single quotes are required to ensure special characters (like '>', '<', ',') are not interpreted by the shell. The dependency is the 'ansible-galaxy' CLI (included with Ansible), and the operator format enables flexible version selection. Inputs include the collection name and a comma-separated string with version constraints. An appropriate version is resolved and downloaded if available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_older_collection.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install 'my_namespace.my_collection:>=1.0.0,<2.0.0'\n```\n\n----------------------------------------\n\nTITLE: Rewriting Insecure Conditionals in Ansible Playbooks (YAML)\nDESCRIPTION: Illustrates the recommended secure method for evaluating conditions involving untrusted data (like module results) in Ansible playbooks, specifically within an `assert` task. Due to CVE-2023-5764 mitigation, embedded templates (`{{ }}`) referencing untrusted variables in conditionals like `when` or `assert` are discouraged and may fail. This snippet shows accessing the untrusted variable `untrusted_result.stdout` directly within the `that` expression instead of embedding it in a template.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.17.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: task with a module result (always untrusted by Ansible)\n  shell: echo \"hi mom\"\n  register: untrusted_result\n\n# don't do it this way...\n# - name: insecure conditional with embedded template consulting untrusted data\n#   assert:\n#     that: '\"hi mom\" is in {{ untrusted_result.stdout }}'\n\n- name: securely access untrusted values directly as Jinja variables instead\n  assert:\n    that: '\"hi mom\" is in untrusted_result.stdout'\n```\n\n----------------------------------------\n\nTITLE: Specifying Connection Plugin in Ansible Playbook\nDESCRIPTION: The `connection` keyword within an Ansible play allows you to define which connection plugin (e.g., `ssh`, `local`, `winrm`) should be used for tasks executed against the hosts targeted by that play. This provides granular control over connection methods within a playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nconnection\n```\n\n----------------------------------------\n\nTITLE: Enforcing Fatal Errors and Sequential Task Execution in Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet shows an Ansible playbook which enforces that disabling load balancers must succeed on all targeted hosts before proceeding to stop and upgrade frontend services. The 'any_errors_fatal: true' directive ensures that failure on any host stops execution across all hosts in that play. The playbook contains sequential plays that first disable load balancers, then stop and upgrade services, and finally re-enable load balancers. Dependencies include Ansible core, with required access to hosts defined in the inventory. Parameters like 'hosts', 'tasks', and module usage (ansible.builtin.command) should be tailored to environment needs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- hosts: load_balancers_dc_a\\n  any_errors_fatal: true\\n\\n  tasks:\\n    - name: Shut down datacenter 'A'\\n      ansible.builtin.command: /usr/bin/disable-dc\\n\\n- hosts: frontends_dc_a\\n\\n  tasks:\\n    - name: Stop service\\n      ansible.builtin.command: /usr/bin/stop-software\\n\\n    - name: Update software\\n      ansible.builtin.command: /usr/bin/upgrade-software\\n\\n- hosts: load_balancers_dc_a\\n\\n  tasks:\\n    - name: Start datacenter 'A'\\n      ansible.builtin.command: /usr/bin/enable-dc\n```\n\n----------------------------------------\n\nTITLE: Looping Over Registered Loop Results in Ansible\nDESCRIPTION: This YAML+Jinja task demonstrates how to iterate over the results captured in a variable registered from a previous loop (`echo.results`). It uses `ansible.builtin.fail` to check the return code (`item.rc`) of each command executed in the previous loop and fails if any return code is non-zero.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_13\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - name: Fail if return code is not 0\n      ansible.builtin.fail:\n        msg: \"The command ({{ item.cmd }}) did not have a 0 return code\"\n      when: item.rc != 0\n      loop: \"{{ echo.results }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Native Parser Template for 'show interface' (YAML)\nDESCRIPTION: Defines a native parser template (`templates/nxos_show_interface.yaml`) for the `ansible.netcommon.native` parser. It uses regular expressions (`getval`) with named capture groups (`?P<name>`) to extract data from lines matching the `example` text in the `show interface` output. The `result` key defines how the captured data is structured into a YAML dictionary. The `shared: true` key makes the captured `name` variable available to subsequent rules within the template until overwritten.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- example: Ethernet1/1 is up\n  getval: '(?P<name>\\S+) is (?P<oper_state>\\S+)'\n  result:\n    \"{{ name }}\":\n      name: \"{{ name }}\"\n      state:\n        operating: \"{{ oper_state }}\"\n  shared: true\n\n- example: admin state is up, Dedicated Interface\n  getval: 'admin state is (?P<admin_state>\\S+),'\n  result:\n    \"{{ name }}\":\n      name: \"{{ name }}\"\n      state:\n        admin: \"{{ admin_state }}\"\n\n- example: \"  Hardware: Ethernet, address: 5254.005a.f8b5 (bia 5254.005a.f8b5)\"\n  getval: '\\s+Hardware: (?P<hardware>.*), address: (?P<mac>\\S+)'\n  result:\n    \"{{ name }}\":\n      hardware: \"{{ hardware }}\"\n      mac_address: \"{{ mac }}\"\n```\n\n----------------------------------------\n\nTITLE: Ansible Plugin Naming Convention Elements\nDESCRIPTION: Highlights specific rules for naming Ansible plugins within collections. Names must be entirely in lowercase. Words within a name should be separated by an underscore (`_`) character. Plugin names should use singular nouns (e.g., `command`) rather than plural forms (e.g., `commands`) for consistency.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_in_groups.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n_\n```\n\nLANGUAGE: text\nCODE:\n```\ncommand\n```\n\nLANGUAGE: text\nCODE:\n```\ncommands\n```\n\n----------------------------------------\n\nTITLE: Configuring ProxyCommand via Inventory Variables (INI)\nDESCRIPTION: Demonstrates setting `ansible_ssh_common_args` within the Ansible inventory file's `[nxos:vars]` section. This configures the `ProxyCommand` SSH option to tunnel connections through a specified bastion host (`bastion01`) when connecting to devices in the `nxos` group using the `cli` transport.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_37\n\nLANGUAGE: ini\nCODE:\n```\n[nxos]\nnxos01\nnxos02\n\n[nxos:vars]\nansible_ssh_common_args='-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Configuring Persistent Connection Retry Timeout in ansible.cfg (INI)\nDESCRIPTION: Shows how to permanently configure the persistent connection retry timeout. Add the `connect_retry_timeout = 30` setting under the `[persistent_connection]` section in the `ansible.cfg` configuration file to set the timeout to 30 seconds globally.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_33\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\nconnect_retry_timeout = 30\n```\n\n----------------------------------------\n\nTITLE: Navigating into Cloned Repository (Bash)\nDESCRIPTION: Changes the current working directory to the newly cloned `community.postgresql` collection repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/ansible_collections/community/postgresql\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbook with Vault Password Prompt\nDESCRIPTION: Demonstrates running an Ansible playbook (`first_playbook.yml`) while prompting the user for the vault password associated with the specified vault ID (`my_user@prompt`). This avoids storing the vault password in a file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_13\n\nLANGUAGE: console\nCODE:\n```\nansible-playbook -i inventory --vault-id my_user@prompt first_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Extending Inventory Plugin Documentation with Caching Fragment - Ansible YAML\nDESCRIPTION: This YAML snippet extends an Ansible inventory plugin's documentation with the 'inventory_cache' documentation fragment, indicating that the plugin supports caching. This is a required step for integrating cache support with inventory plugins. The 'extends_documentation_fragment' property signals to Ansible that the plugin provides cache functionality via the standard inventory cache interface. No parameters are required besides listing 'inventory_cache' as a fragment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nextends_documentation_fragment:\n  - inventory_cache\n\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Role from Galaxy via CLI\nDESCRIPTION: Demonstrates the basic command `ansible-galaxy role install` to download and install a role directly from Ansible Galaxy using its qualified name (`namespace.role_name`). The role is installed into the first writable directory specified in the Ansible configuration (defaulting to `~/.ansible/roles`). Requires the `ansible-galaxy` command-line tool.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role install namespace.role_name\n```\n\n----------------------------------------\n\nTITLE: Extending Inventory Plugin Documentation with Constructed Fragment - Ansible YAML\nDESCRIPTION: This YAML snippet instructs an Ansible inventory plugin to extend its documentation with the 'constructed' documentation fragment. This signifies use of Jinja2-based constructed inventory features such as custom variable and group creation. Only the 'constructed' fragment needs to be listed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nextends_documentation_fragment:\n  - constructed\n\n```\n\n----------------------------------------\n\nTITLE: Example Output of Ansible Galaxy Role Info\nDESCRIPTION: Provides an example of the detailed information returned by the `ansible-galaxy role info` command. This includes metadata such as description, commit details, license, minimum Ansible version, and repository information. This is sample output, not executable code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nRole: username.role_name\n    description: Installs and configures a thing, a distributed, highly available NoSQL thing.\n    active: True\n    commit: c01947b7bc89ebc0b8a2e298b87ab416aed9dd57\n    commit_message: Adding travis\n    commit_url: https://github.com/username/repo_name/commit/c01947b7bc89ebc0b8a2e298b87ab\n    company: My Company, Inc.\n    created: 2015-12-08T14:17:52.773Z\n    download_count: 1\n    forks_count: 0\n    github_branch: main\n    github_repo: repo_name\n    github_user: username\n    id: 6381\n    is_valid: True\n    issue_tracker_url:\n    license: Apache\n    min_ansible_version: 2.15\n    modified: YYYY-MM-DDTHH:MM:SS.000Z\n    namespace: username\n    open_issues_count: 0\n    path: /Users/username/projects/roles\n    role_type: ANS\n    stargazers_count: 0\n    travis_status_url: https://travis-ci.org/username/repo_name.svg?branch=main\n```\n\n----------------------------------------\n\nTITLE: Deprecating hashi_vault VAULT_ROLE_ID Variable in community.hashi_vault\nDESCRIPTION: The `VAULT_ROLE_ID` environment variable used to set the `role_id` option for the `hashi_vault` lookup plugin is deprecated. It will be removed in community.hashi_vault version 2.0.0. Use `ANSIBLE_HASHI_VAULT_ROLE_ID` instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_21\n\nLANGUAGE: Environment Variable\nCODE:\n```\nVAULT_ROLE_ID\n```\n\n----------------------------------------\n\nTITLE: Activating Ansible Source Environment for Development (Shell)\nDESCRIPTION: This shell-session snippet reiterates how to activate the Ansible source code environment (after setting up git branches), using the env-setup script for immediate access to source-based testing and development. This shell-level configuration persists for the session and sets up paths for correct Python imports. Prerequisite: cloned Ansible source code; input is the path to env-setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsource ./hacking/env-setup\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Logic in Ansible Jinja2 Templates (Jinja)\nDESCRIPTION: This snippet from `roles/common/templates/iptables.j2` illustrates the use of Jinja2 conditional logic within an Ansible template. It checks if the current host (`inventory_hostname`) is part of the `dbservers` group. If the condition is true, it adds an iptables rule to accept TCP traffic on port 3306 (MySQL).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_5\n\nLANGUAGE: jinja\nCODE:\n```\n{% if inventory_hostname in groups['dbservers'] %}\n-A INPUT -p tcp  --dport 3306 -j  ACCEPT\n{% endif %}\n\n```\n\n----------------------------------------\n\nTITLE: Direct Parameter Assignment to Ansible Plugins (Text/Jinja2)\nDESCRIPTION: Illustrates direct assignment of parameters to Ansible lookup, filter, and test plugins using Jinja2 syntax, typically within playbook expressions. Examples show passing key-value pairs to a lookup plugin (`lookup('plugin', direct1='value', direct2='value2')`), a value to a filter plugin (`'value_directly_assigned'|filter('another directly assigned')`), and a value to a test plugin (`'direct value' is testplugin`) directly within the expression.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nlookup('plugin', direct1='value', direct2='value2')\n\n'value_directly_assigned'|filter('another directly assigned')\n\n'direct value' is testplugin\n```\n\n----------------------------------------\n\nTITLE: Installing a Single Ansible Collection via ansible-galaxy (Bash)\nDESCRIPTION: Uses the `ansible-galaxy collection install` command to download and install a single collection named `mynamespace.mycollection`. The collection is typically fetched from the default Ansible Galaxy server (`galaxy.ansible.com`) unless configured otherwise.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install mynamespace.mycollection\n```\n\n----------------------------------------\n\nTITLE: Allowing Special Characters in Prompted Variables - Ansible Playbook - YAML\nDESCRIPTION: This YAML example enables support for special characters in a variable prompted with 'vars_prompt' by setting 'unsafe: true'. Parameters include 'name' (variable), 'prompt' (displayed message), 'unsafe' (permits special characters), and 'private' (hides input). Dependencies: Ansible. Input: user-provided value, possibly containing reserved YAML or Jinja characters. Output: assigned variable allowing special characters. Useful where character restrictions would otherwise cause errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_prompts.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nvars_prompt:\\n  - name: my_password_with_weird_chars\\n    prompt: Enter password\\n    unsafe: true\\n    private: true\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies Within a Dependent Ansible Role (YAML)\nDESCRIPTION: The `meta/main.yml` for the 'wheel' role, which itself depends on the 'tire' and 'brake' roles. This demonstrates nested dependencies in Ansible roles, where 'tire' and 'brake' will run before 'wheel'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\n---\ndependencies:\n  - role: tire\n  - role: brake\n```\n\n----------------------------------------\n\nTITLE: Specifying Collection Dependencies Using Git in galaxy.yml (YAML)\nDESCRIPTION: This YAML snippet shows how to declare external dependencies for an Ansible collection by specifying a Git repository and branch in the dependencies mapping of galaxy.yml. During local development and testing, you may use direct Git URLs to point to required collections. The mapping key is the repository clone URL and the value is the target branch or ref. This method is not supported for published collections in the Ansible Galaxy ecosystem.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_shared.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies: {'git@github.com:organization/repo_name.git': 'devel'}\n```\n\n----------------------------------------\n\nTITLE: Configuring CLI Inventory for IOS-XR in Ansible (INI)\nDESCRIPTION: Defines host or group variables for connecting to Cisco IOS-XR devices using Ansible's network_cli connection. The configuration includes essential variables such as ansible_connection, ansible_network_os, credentials, and optional SSH proxy command for bastion access. This must be placed in your Ansible inventory file and may require values to be substituted for your environment. No additional dependencies are required for standard SSH access; for password authentication, ensure relevant ssh-agent or keys are set.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_iosxr.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[iosxr:vars]\\nansible_connection=ansible.netcommon.network_cli\\nansible_network_os=cisco.iosxr.iosxr\\nansible_user=myuser\\nansible_password=!vault...\\nansible_ssh_common_args='-o ProxyCommand=\\\"ssh -W %h:%p -q bastion01\\\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook Remotely within an EE using ansible-navigator (Bash)\nDESCRIPTION: This Bash command uses `ansible-navigator` to execute the 'test_remote.yml' playbook against remote hosts defined in the './inventory' directory. It utilizes the 'postgresql_ee:latest' Execution Environment image, directs output to stdout, pulls the image if missing, enables prompts for credentials, specifies the remote user 'student', and prompts for both SSH (-k) and become (-K) passwords.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_execution_environment.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator run test_remote.yml -i inventory --execution-environment-image postgresql_ee:latest --mode stdout --pull-policy missing --enable-prompts -u student -k -K\n```\n\n----------------------------------------\n\nTITLE: Example Error Due to Mismatched Error Regex (Console)\nDESCRIPTION: Illustrates the fatal error output that can occur when command output (like from `show logging`) contains patterns (e.g., log messages with severity levels) that are mistakenly matched by the default error detection regex in the `network_cli` connection plugin, causing the task to fail.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_44\n\nLANGUAGE: console\nCODE:\n```\nTASK [first fetch logs] ********************************************************\nfatal: [ios01]: FAILED! => {\n    \"changed\": false,\n    \"msg\": \"RF Name:\\r\\n\\r\\n <--nsip-->\n           \\\"IPSEC-3-REPLAY_ERROR: Test log\\\"\\r\\n*Aug  1 08:36:18.483: %SYS-7-USERLOG_DEBUG:\n            Message from tty578(user id: ansible): test\\r\\nan-ios-02#\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Inventory Plugins via Ansible Configuration (ini)\nDESCRIPTION: Shows how to enable specific inventory plugins in Ansible by modifying the enable_plugins setting in the [inventory] section of the ansible.cfg file. Supports selection of built-in, auto-detected, and fully qualified plugin names. Users can list plugins (with optional FQCN) separated by commas. Requires access to Ansible's configuration directory and writable configuration files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[inventory]\\nenable_plugins = host_list, script, auto, yaml, ini, toml\n```\n\n----------------------------------------\n\nTITLE: Dynamic Expression Construction with Embedded Template (Unsupported, Ansible, YAML+Jinja)\nDESCRIPTION: A dynamic constructed expression using template delimiters is shown, which is now flagged as insecure and unsupported in playbooks. Suitable for illustrating the new constraints in templating logic. Needs 'inventory_hostname' and 'comparison' set in 'vars'. Output: error and warning about use of template delimiters in expression.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_11\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname {{ comparison }} 'localhost'\n      vars:\n        comparison: ==\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Network CLI Connection Retries (INI)\nDESCRIPTION: Shows how to configure the number of connection retry attempts globally for the `network_cli` connection plugin in `ansible.cfg`. Adding `network_cli_retries = 5` under the `[persistent_connection]` section increases the attempts from the default of 3, useful for less reliable networks or slower hosts. Available in Ansible 2.9+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_46\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\nnetwork_cli_retries = 5\n```\n\n----------------------------------------\n\nTITLE: Preparing Release Summary Changelog Fragment - YAML\nDESCRIPTION: This YAML code defines a changelog fragment with a required 'release_summary' field for an Ansible collection version. The summary utilizes reStructuredText and is intended to appear as the human-readable summary for the version being released. The fragment is later used by automated tools to assemble the full changelog. Inputs include the summary text; output is a valid YAML changelog fragment. There are no external dependencies, other than proper file placement in the changelogs/fragments directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nrelease_summary: |-\\n  Write some text here that should appear as the release summary for this version.\\n  The format is reStructuredText but not a list as for regular changelog fragments.\\n  This text will be inserted into the changelog.\\n\n```\n\n----------------------------------------\n\nTITLE: Example Structured Data from TextFSM Parsing (YAML)\nDESCRIPTION: This YAML snippet shows the expected structured data format (a list of dictionaries) after parsing the output of the `show interface` command on a Cisco NX-OS device using the TextFSM parser via `cli_parse`. Each dictionary represents an interface with its parsed attributes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n   - ADDRESS: X254.005a.f8b5\n     ADMIN_STATE: up\n     BANDWIDTH: 1000000 Kbit\n     BIA: X254.005a.f8b5\n     DELAY: 10 usec\n     DESCRIPTION: ''\n     DUPLEX: full-duplex\n     ENCAPSULATION: ARPA\n     HARDWARE_TYPE: Ethernet\n     INPUT_ERRORS: ''\n     INPUT_PACKETS: ''\n     INTERFACE: mgmt0\n     IP_ADDRESS: 192.168.101.14/24\n     LAST_LINK_FLAPPED: ''\n     LINK_STATUS: up\n     MODE: ''\n     MTU: '1500'\n     OUTPUT_ERRORS: ''\n     OUTPUT_PACKETS: ''\n     SPEED: 1000 Mb/s\n   - ADDRESS: X254.005a.f8bd\n     ADMIN_STATE: up\n     BANDWIDTH: 1000000 Kbit\n     BIA: X254.005a.f8bd\n```\n\n----------------------------------------\n\nTITLE: Initializing ansible-test Environment in Shell\nDESCRIPTION: This snippet demonstrates how to initialize the Ansible test environment by sourcing the env-setup script and invoking ansible-test with the help flag. Prerequisites include Ansible source checkout, a Unix-like shell, and ensuring the env-setup script exists in the hacking directory. The 'source hacking/env-setup' command sets up the PATH and environment variables, followed by 'ansible-test --help' which displays usage instructions for ansible-test.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsource hacking/env-setup\nansible-test --help\n```\n\n----------------------------------------\n\nTITLE: Checking Out Default Branch on Local Fork - Git Bash Script\nDESCRIPTION: This Bash script ensures the user is on the default branch (typically main) of their local fork before starting the release process. It uses the 'git status' command to show the current branch and 'git checkout main' to switch if needed. No external dependencies are required beyond Git, and it prepares the repository for subsequent release steps.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit status\\ngit checkout main     # if needed\n```\n\n----------------------------------------\n\nTITLE: Invalid YAML Syntax due to Unquoted Colon\nDESCRIPTION: Illustrates a common YAML syntax error. An unquoted scalar value containing a colon followed by a space (': ') or end-of-line is interpreted as a mapping indicator, causing an error. The 'windows_drive' example is also problematic in many parsers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nfoo: somebody said I should put a colon here: so I did\n\nwindows_drive: c:\n```\n\n----------------------------------------\n\nTITLE: Initial Resource Configuration Example - Text\nDESCRIPTION: This snippet provides an example of the starting configuration of a network interface on a device. It is used to illustrate how the interface will change after applying Ansible tasks with different states. No dependencies are required for this data representation, and it serves as context for subsequent YAML playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ninterface loopback100\\n ip address 10.10.1.100 255.255.255.0\\n ipv6 address FC00:100/64\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Redirection in Collection meta/runtime.yml (YAML)\nDESCRIPTION: This YAML snippet shows how to redirect an old module name ('old_cloud') to a new module ('foo.bar.new_cloud') within an Ansible collection using the 'meta/runtime.yml' file. A 'redirect' entry is added under 'plugin_routing' -> 'modules', specifying the Fully Qualified Collection Name (FQCN) of the target module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/module_lifecycle.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nplugin_routing:\n    modules:\n        old_cloud:\n            redirect: foo.bar.new_cloud\n```\n\n----------------------------------------\n\nTITLE: Structuring Ansible Inventory per Environment (Test)\nDESCRIPTION: Example INI inventory file (`inventory_test`) organizing hosts into functional groups (`dbservers`, `appservers`) specifically for a 'test' environment. This separation helps prevent accidental changes in other environments by isolating hosts belonging to a particular stage.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_29\n\nLANGUAGE: ini\nCODE:\n```\n[dbservers]\ndb01.test.example.com\ndb02.test.example.com\n\n[appservers]\napp01.test.example.com\napp02.test.example.com\napp03.test.example.com\n```\n\n----------------------------------------\n\nTITLE: Setting the Standard Output Callback Plugin in ansible.cfg\nDESCRIPTION: This configuration snippet shows how to specify the plugin responsible for handling standard output (stdout) for `ansible-playbook`. The `stdout_callback` setting is assigned the value `dense`, replacing the default stdout plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/callback.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\nstdout_callback = dense\n```\n\n----------------------------------------\n\nTITLE: Building List Conditionally Omitting Items using Ansible Loop and `omit`\nDESCRIPTION: This Ansible task iterates through a list containing potentially `omit` values. Inside the loop, `set_fact` conditionally adds the current `item` to the `namestuff` list (using `union`) only if the `item` is not equal to `omit`. This builds the desired list incrementally, excluding omitted items. The `omit` variable serves as a conditional marker.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_7\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- name: Build unique list with some items conditionally omitted\n  ansible.builtin.set_fact:\n     namestuff: ' {{ (namestuff | default([])) | union([item]) }}'\n  when: item != omit\n  loop:\n      - \"{{ (fs_installed_smb_v1 | default(False)) | ternary(omit, 'FS-SMB1') }}\"\n      - \"foo\"\n      - \"bar\"\n```\n\n----------------------------------------\n\nTITLE: Using Percent Formatting with Byte Strings in Python\nDESCRIPTION: Illustrates the use of percent-style formatting (`%`) with byte string literals (`b''`). This method is recommended for formatting byte strings, as the `bytes.format()` method has limited availability across Python versions (available >= 3.5).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nb_command_line = b'ansible-playbook --become-user %s -K %s' % (user, playbook_file)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Module Default Groups in Ansible Playbook YAML\nDESCRIPTION: This Ansible playbook demonstrates how to apply module defaults to a custom action group defined in a collection's `meta/runtime.yml`. It uses `group/ns.coll.my_group` within `module_defaults` to set `option_name: option_value` for all modules belonging to that group (`ns.coll.sample_module` and `another.collection.another_module` as defined previously).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\n- hosts: localhost\n  module_defaults:\n    group/ns.coll.my_group:\n      option_name: option_value\n  tasks:\n    - ns.coll.sample_module:\n    - another.collection.another_module:\n```\n\n----------------------------------------\n\nTITLE: Shortform 'q' for Querying Lookup Plugins (jinja)\nDESCRIPTION: This snippet uses the short form 'q' as an alias for 'query' to retrieve a dictionary variable via a lookup plugin in Jinja2 templates (Ansible 2.5+). It simplifies the syntax for situations where concise expressions are beneficial, with behavior identical to 'query', returning a list of results for consumption in loops or other expressions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_10\n\nLANGUAGE: jinja\nCODE:\n```\n    q('dict', dict_variable)\n```\n\n----------------------------------------\n\nTITLE: Console Output Showing Corrected List Result (Ansible)\nDESCRIPTION: This console output shows the result of the corrected Ansible task using the `map` filter. The `msg` field now correctly contains a list `[\"prod1\", \"prod2\"]`, indicating that the data type was preserved and the replacement occurred on each element.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_17\n\nLANGUAGE: console\nCODE:\n```\n.. code-block:: console\n\n    ok: [localhost] => {\n        \"msg\": [\n            \"prod1\",\n            \"prod2\"\n        ]\n    }\n```\n\n----------------------------------------\n\nTITLE: Setting Up Ansible Development Environment using Shell\nDESCRIPTION: Sources the 'env-setup' script located in the 'hacking' directory to modify the current shell environment, enabling the execution of Ansible directly from a Git checkout. Requires Python >= 3.8 and prerequisites installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ source ./hacking/env-setup\n```\n\n----------------------------------------\n\nTITLE: Executing Network Task with Inventory-Defined Connection in Ansible YAML (2.5+)\nDESCRIPTION: Shows the simplified Ansible 2.5 task syntax for interacting with a network device when connection parameters are defined in the inventory (as shown in the previous INI example). The task no longer requires explicit 'provider', 'host', 'username', or 'password' arguments, relying on the inventory configuration and the 'network_cli' connection type.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n- nxos_config:\n   src: config.j2\n```\n\n----------------------------------------\n\nTITLE: Boolean Conditionals in Ansible Tasks Using |bool Filter - YAML\nDESCRIPTION: This YAML example shows the recommended way to handle boolean values in when conditionals using the |bool Jinja2 filter. The vars section defines a variable teardown as the string 'false', and tasks use include_tasks with a when condition that explicitly converts the string to a boolean. This approach is needed due to deprecation of automatic boolean parsing. Required dependency is Ansible 2.12+. Inputs are string variables; expected output is conditional task execution based on the boolean result.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.12.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  teardown: 'false'\n\ntasks:\n  - include_tasks: teardown.yml\n    when: teardown | bool\n\n  - include_tasks: provision.yml\n    when: not teardown | bool\n```\n\n----------------------------------------\n\nTITLE: Implementing an Ansible Timer Callback Plugin in Python\nDESCRIPTION: Demonstrates a functional Ansible callback plugin that calculates and displays the total runtime of a playbook. It includes defining metadata and options in the `DOCUMENTATION` block, initializing a start timer in `__init__`, implementing a helper function (`_days_hours_minutes_seconds`) for time formatting, and overriding the `v2_playbook_on_stats` method to output the duration using the configured format string via the `_display` object. Requires `datetime` and `ansible.plugins.callback.CallbackBase`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Make coding more python3-ish, this is required for contributions to Ansible\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\n# not only visible to ansible-doc, it also 'declares' the options the plugin requires and how to configure them.\nDOCUMENTATION = '''\nname: timer\ncallback_type: aggregate\nrequirements:\n    - enable in configuration\nshort_description: Adds time to play stats\nversion_added: \"2.0\"  # for collections, use the collection version, not the Ansible version\ndescription:\n    - This callback just adds total play duration to the play stats.\noptions:\n  format_string:\n    description: format of the string shown to user at play end\n    ini:\n      - section: callback_timer\n        key: format_string\n    env:\n      - name: ANSIBLE_CALLBACK_TIMER_FORMAT\n    default: \"Playbook run took %s days, %s hours, %s minutes, %s seconds\"\n'''\nfrom datetime import datetime\n\nfrom ansible.plugins.callback import CallbackBase\n\n\nclass CallbackModule(CallbackBase):\n    \"\"\"\n    This callback module tells you how long your plays ran for.\n    \"\"\"\n    CALLBACK_VERSION = 2.0\n    CALLBACK_TYPE = 'aggregate'\n    CALLBACK_NAME = 'namespace.collection_name.timer'\n\n    # only needed if you ship it and don't want to enable by default\n    CALLBACK_NEEDS_ENABLED = True\n\n    def __init__(self):\n\n      # make sure the expected objects are present, calling the base's __init__\n      super(CallbackModule, self).__init__()\n\n      # start the timer when the plugin is loaded, the first play should start a few milliseconds after.\n      self.start_time = datetime.now()\n\n    def _days_hours_minutes_seconds(self, runtime):\n      ''' internal helper method for this callback '''\n      minutes = (runtime.seconds // 60) % 60\n      r_seconds = runtime.seconds - (minutes * 60)\n      return runtime.days, runtime.seconds // 3600, minutes, r_seconds\n\n    # this is only event we care about for display, when the play shows its summary stats; the rest are ignored by the base class\n    def v2_playbook_on_stats(self, stats):\n      end_time = datetime.now()\n      runtime = end_time - self.start_time\n\n      # Shows the usage of a config option declared in the DOCUMENTATION variable. Ansible will have set it when it loads the plugin.\n      # Also note the use of the display object to print to screen. This is available to all callbacks, and you should use this over printing yourself\n      self._display.display(self._plugin_options['format_string'] % (self._days_hours_minutes_seconds(runtime)))\n```\n\n----------------------------------------\n\nTITLE: Isolating Errors with Debug Logging and Ad Hoc Command - Shell\nDESCRIPTION: Combines enabling detailed debug logging (ANIBLE_LOG_PATH, ANSIBLE_DEBUG, -vvvv) with execution of an ad hoc Ansible command against a remote network device, using the arista.eos.eos_command module. Demonstrates best practices for capturing comprehensive diagnostic information in troubleshooting scenarios involving device connectivity and module execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n# Specify the location for the log file\\nexport ANSIBLE_LOG_PATH=~/ansible.log\\n# Enable Debug\\nexport ANSIBLE_DEBUG=True\\n# Run with ``-vvvv`` for connection level verbosity\\nansible -m arista.eos.eos_command -a 'commands=?' -i inventory switch1.example.net -e 'ansible_connection=ansible.netcommon.network_cli' -u admin -k\n```\n\n----------------------------------------\n\nTITLE: Using Vault Password File with Ansible Playbook - CLI Usage (Bash)\nDESCRIPTION: Retrieves the vault password from a specified file to decrypt variables or files in the playbook. Requires a readable file at the given path that contains the vault password in plain text. The supplied file replaces the interactive prompt, enabling automated or batch executions. Input: CLI command with file path; Output: Playbook execution uses password from file for vault decryption.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-password-file /path/to/my/vault-password-file site.yml\n```\n\n----------------------------------------\n\nTITLE: Conditionally Including a Role Based on Facts - Ansible - YAML\nDESCRIPTION: Shows how to conditionally include a role ('some_role') using 'include_role' depending on the Ansible fact 'os_family'. Requires a populated 'ansible_facts' dictionary (typically gathered during play). The role will only be included if the target machine's OS family is 'RedHat'. Inputs: managed hosts in 'webservers', correct fact population. Outputs: 'some_role' is included only for matching hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  tasks:\n    - name: Include the some_role role\n      include_role:\n        name: some_role\n      when: \"ansible_facts['os_family'] == 'RedHat'\"\n```\n\n----------------------------------------\n\nTITLE: Setting Task-Level Environment Variables in Ansible (YAML)\nDESCRIPTION: This snippet demonstrates setting an environment variable (`http_proxy`) directly within an Ansible task using the `environment` keyword. The `ansible.builtin.package` task will execute on the remote host with the specified `http_proxy` environment variable set, enabling tasks like package installation via a proxy.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_environment.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  remote_user: root\n\n  tasks:\n\n    - name: Install cobbler\n      ansible.builtin.package:\n        name: cobbler\n        state: present\n      environment:\n        http_proxy: http://proxy.example.com:8080\n```\n\n----------------------------------------\n\nTITLE: Gathering Windows facts using ansible setup module - Bash\nDESCRIPTION: This bash command demonstrates how to gather detailed facts from Windows hosts using Ansible's setup module. The \"ansible windows -m setup\" command connects to the inventory group named 'windows' and executes the setup module, returning all available facts about the hosts in JSON format. Requires Ansible installed and an inventory group named 'windows' with working host connections. The output provides all collected facts and is useful for debugging or auditing remote host state.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_windows.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible windows -m setup\n```\n\n----------------------------------------\n\nTITLE: Using Named Blocks in Ansible Playbooks (YAML)\nDESCRIPTION: Demonstrates assigning a name to a block in an Ansible playbook and the use of 'block', 'rescue', and 'always' constructs for structured error handling. This snippet is for Ansible 2.3+, requiring standard Ansible on the controller and target. Inputs include a play targeting 'localhost' with multiple 'debug' and 'command' tasks within the block structures; output is typical Ansible task execution and error-handling behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.3.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Block test case\\n  hosts: localhost\\n  tasks:\\n   - name: Attempt to setup foo\\n     block:\\n       - debug: msg='I execute normally'\\n       - command: /bin/false\\n       - debug: msg='I never execute, cause ERROR!'\\n     rescue:\\n       - debug: msg='I caught an error'\\n       - command: /bin/false\\n       - debug: msg='I also never execute :-('\\n     always:\\n       - debug: msg=\\\"this always executes\\\"\n```\n\n----------------------------------------\n\nTITLE: Combining 'until' and 'loop'\nDESCRIPTION: This task illustrates the behavior of using the `until` keyword within a `loop`. The `until: item > 2` condition is evaluated independently for each item in the loop (`[1, 2, 3]`). The task will retry (up to `retries: 2` times) for items 1 and 2 because they don't satisfy the condition. Item 3 satisfies the condition on the first attempt. Since items 1 and 2 ultimately fail after retries, the overall task will fail.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_33\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- debug: msg={{item}}\n  loop:\n    - 1\n    - 2\n    - 3\n  retries: 2\n  until: item > 2\n```\n\n----------------------------------------\n\nTITLE: Defining Task Failure with Multiple OR Conditions (YAML String)\nDESCRIPTION: This snippet shows how to define `failed_when` using a single string containing multiple conditions joined by the explicit `or` operator. The task will be marked as failed if *either* the return code (`result.rc`) is 0 *or* the string 'No such' is *not* present in the standard error output (`result.stderr`). This contrasts with using a list, which implies AND.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n  failed_when: result.rc == 0 or \"No such\" not in result.stderr\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to Roles Inline in Ansible Playbooks - YAML\nDESCRIPTION: This code snippet illustrates how to pass variables directly to a role invocation in a playbook, explicitly setting http_port: 8080 for the 'apache' role. This approach overrides defaults and other settings, clarifies intent, and provides flexibility for reusing or customizing role behavior in different plays.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_25\n\nLANGUAGE: yaml\nCODE:\n```\nroles:\\n   - role: apache\\n     vars:\\n        http_port: 8080\n```\n\n----------------------------------------\n\nTITLE: Running 'cli_parse' with Native Parser for Network Command (YAML)\nDESCRIPTION: Demonstrates an Ansible task using the `ansible.utils.cli_parse` module to execute the `show interface` command on a target device. It specifies the `ansible.netcommon.native` parser engine via the `parser.name` option. By default, `cli_parse` looks for a template named based on the OS and command (`nxos_show_interface.yaml` in this context). The parsed, structured data is then stored in the `interfaces` fact using the `set_fact` parameter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"Run command and parse with native\"\n  ansible.utils.cli_parse:\n    command: show interface\n    parser:\n      name: ansible.netcommon.native\n    set_fact: interfaces\n```\n\n----------------------------------------\n\nTITLE: Verifying Network Device Configuration Consistency - YAML\nDESCRIPTION: This playbook illustrates a verification pipeline using Arista EOS modules: it gathers L3 interface facts from a device, uses the gathered facts as configuration input back to the same module, and asserts that the device configuration did not change. Requires arista.eos collection, and is typically used for configuration drift and consistency checks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Example of facts being pushed right back to device.\\n  hosts: arista\\n  gather_facts: false\\n  tasks:\\n    - name: grab arista eos facts\\n      arista.eos.eos_facts:\\n        gather_subset: min\\n        gather_network_resources: l3_interfaces\\n\\n- name: Ensure that the IP address information is accurate.\\n  arista.eos.eos_l3_interfaces:\\n    config: \\\"{{ ansible_network_resources['l3_interfaces'] }}\\\"\\n    register: result\\n\\n- name: Ensure config did not change.\\n  assert:\\n    that: not result.changed\n```\n\n----------------------------------------\n\nTITLE: Passing Extra Variables at Runtime - key=value Format - Ansible - CLI\nDESCRIPTION: An example of defining variables via the --extra-vars argument to ansible-playbook using a simple key=value CLI format. Inputs are pairs of variable assignments as a single quoted string; outputs are extra variables available for the playbook execution. Limitations: All values are interpreted as strings. For complex types, use JSON format.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nansible-playbook release.yml --extra-vars \"version=1.23.45 other_variable=foo\"\n```\n\n----------------------------------------\n\nTITLE: Downloading a Specific Version of a Collection with Ansible Galaxy - Bash\nDESCRIPTION: Shows how to specify an exact version when downloading an Ansible collection with ansible-galaxy. This command ensures that version 1.0.0 of the given collection is downloaded, including all dependencies. Requires Ansible installed and the targeted collection version to be available on the Galaxy server. The output includes the precise version and related metadata in the default folder.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection download my_namespace.my_collection:1.0.0\n```\n\n----------------------------------------\n\nTITLE: Verifying Collections with requirements.yml - ansible-galaxy CLI - Bash\nDESCRIPTION: Invokes verification for multiple collections listed in a requirements.yml file using the -r flag. Only collections specified in the namespace.name format are processed; dependencies in the file are ignored. Essential for scenarios where collections are managed in bulk.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Defining Global Group Variables in Ansible (YAML)\nDESCRIPTION: This snippet shows the content of the `group_vars/all` file. It defines variables (`httpd_port`, `ntpserver`) that are applied globally to all hosts in the inventory. These variables are used for site-wide configurations, such as setting the default web server port and specifying the NTP server.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\nhttpd_port: 80\nntpserver: 192.0.2.23\n\n```\n\n----------------------------------------\n\nTITLE: Waiting for Multiple Arista EOS Interface Statuses using eos_command (YAML)\nDESCRIPTION: This Ansible task demonstrates using `arista.eos.eos_command` to run multiple commands (`show interface Ethernet4 | json` and `show interface Ethernet5 | json`). It utilizes the `wait_for` argument with multiple conditions, referencing the output of each command by its index (`result[0]` and `result[1]`), to ensure both Ethernet4 and Ethernet5 interfaces have a status of `connected` before proceeding.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_working_with_command_output.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: wait for interfaces to be admin enabled\n  arista.eos.eos_command:\n      commands:\n          - show interface Ethernet4 | json\n          - show interface Ethernet5 | json\n      wait_for:\n          - \"result[0].interfaces.Ethernet4.interfaceStatus eq connected\"\n          - \"result[1].interfaces.Ethernet5.interfaceStatus eq connected\"\n```\n\n----------------------------------------\n\nTITLE: Writing Test Task for postgresql_info Module (YAML)\nDESCRIPTION: An Ansible playbook task within `tests/integration/targets/postgresql_info/tasks/main.yml`. The first task runs the `community.postgresql.postgresql_info` module as the `postgres` user to gather database information, registering the output. The second task uses `assert` to verify the module reported no changes (`is not changed`) and that the major and minor version numbers match expected values (12 and 8).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Test postgresql_info module\n  become: true\n  become_user: postgres\n  community.postgresql.postgresql_info:\n    login_user: postgres\n    login_db: postgres\n  register: result\n\n- name: Check the module returns what we expect\n  assert:\n    that:\n      - result is not changed\n      - result.version.major == 12\n      - result.version.minor == 8\n```\n\n----------------------------------------\n\nTITLE: Limiting Ad Hoc Commands - Ansible (Bash)\nDESCRIPTION: These bash snippets show usage of the '--limit' option to constrain pattern-matched hosts during ad hoc Ansible command runs. Limits can be single hosts, multiple hosts, exclusions, or groups. Quoting is required in some cases to prevent shell interpretation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m <module> -a \"<module options>\" --limit \"host1\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m <module> -a \"<module options>\" --limit \"host1,host2\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m <module> -a \"<module options>\" --limit 'all:!host1'\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m <module> -a \"<module options>\" --limit 'group1'\n```\n\n----------------------------------------\n\nTITLE: Using Folded Block Scalars for Multiline Strings in YAML\nDESCRIPTION: Demonstrates the folded block scalar ('>') for multiline strings. This folds newlines within the block into spaces, creating a single logical line of text, which improves readability for long lines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nfold_newlines: >\n            this is really a\n            single line of text\n            despite appearances\n```\n\n----------------------------------------\n\nTITLE: Using File for Password with Specific Vault ID - CLI Usage (Bash)\nDESCRIPTION: Retrieves the password for a particular vault ID ('dev') from a specified file during playbook execution. Requires a file ('dev-password') containing the vault password and a playbook with data encrypted under the given vault ID. Input: CLI command with vault ID and file; Output: Decryption utilizes password from file for the selected vault ID.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id dev@dev-password site.yml\n```\n\n----------------------------------------\n\nTITLE: Example Multi-line Bugfix Entry for copy in Ansible Changelog (YAML)\nDESCRIPTION: Demonstrates a multi-line `bugfixes` entry for the `copy` module in an Ansible changelog fragment. It follows the scoped entry format, explaining the bug related to `remote_src=True` and file modes on certain filesystems, and providing the GitHub issue link. The description spans multiple lines with appropriate indentation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nbugfixes:\n  - copy - the module was attempting to change the mode of files for\n    remote_src=True even if mode was not set as a parameter.  This failed on\n    filesystems which do not have permission bits (https://github.com/ansible/ansible/issues/29444).\n```\n\n----------------------------------------\n\nTITLE: Specifying a Different Parser Command in `cli_parse` (YAML)\nDESCRIPTION: This Ansible task shows how to run a shorter command (`sho int`) via `cli_parse` while instructing the parser to use the template associated with the full command (`show interface`). This is achieved using the `parser/command` suboption, ensuring the correct parsing logic is applied even with command aliases or abbreviations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_24\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: \"Run command and parse with native\"\n     ansible.utils.cli_parse:\n       command: sho int\n       parser:\n         name: ansible.netcommon.native\n         command: show interface\n```\n\n----------------------------------------\n\nTITLE: Output Showing Preserved List Structure After Correction (Console)\nDESCRIPTION: Displays the console output from the corrected Ansible task using the `map` filter. The `msg` field shows a proper list (`[\"prod1\", \"prod2\"]`), demonstrating that using `map` correctly applied the filter and maintained the original data type.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\nok: [localhost] => {\n    \"msg\": [\n        \"prod1\",\n        \"prod2\"\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Number of Forks for Ansible Parallelism (INI)\nDESCRIPTION: This configuration snippet increases the default number of process forks (parallel tasks) that Ansible spawns to 30, by specifying it under '[defaults]' in ansible.cfg. This setting is significant for environments with strong processing resources. Dependencies: a writable ansible.cfg. The 'forks' parameter must be less than or equal to the system's file descriptor/process limits; more forks allow higher parallelism.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\\nforks = 30\n```\n\n----------------------------------------\n\nTITLE: Running Resource Module Builder Playbook - Ansible - Bash\nDESCRIPTION: Invokes the resource module builder playbook to generate a role directory layout by specifying various parameters via extra vars. Requires Ansible installed and files like site.yml and the model at the provided path. The command accepts destination (rm_dest), structure (role), and model file location, producing scaffolding at the target location.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -e rm_dest=<destination for modules and module utils> \\\n                 -e structure=role \\\n                 -e model=<model> \\\n                 site.yml\n```\n\n----------------------------------------\n\nTITLE: Converting Command Output Encoding with ansible.builtin.shell and iconv (YAML)\nDESCRIPTION: This snippet uses ansible.builtin.shell to execute a command-line program on z/OS and pipes its output through iconv, converting it from EBCDIC (ibm-1047) to ISO8859-1 encoding. This ensures that the output is readable by downstream tasks expecting UTF-8/ISO8859-1 text. Requires iconv to be installed on the remote host, and users should adjust 'some_pgm' and encodings as appropriate for their data.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nansible.builtin.shell: \"some_pgm | iconv -f ibm-1047 -t iso8859-1\"\n```\n\n----------------------------------------\n\nTITLE: Outputting Standard Inventory Structure in JSON for Ansible Inventory Script - JSON\nDESCRIPTION: This JSON snippet demonstrates the required structure for the output of an inventory script when called with --list. It includes multiple groups, each with hosts, group variables, and potential child groups. Dependencies include a working Ansible environment and a script that outputs valid JSON when called with --list. Expected input is the --list argument; output is a JSON object mapping group names to group metadata as required by Ansible. All groups can omit empty fields, and host/group membership must be accurate.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"group001\": {\n        \"hosts\": [\"host001\", \"host002\"],\n        \"vars\": {\n            \"var1\": true\n        },\n        \"children\": [\"group002\"]\n    },\n    \"group002\": {\n        \"hosts\": [\"host003\",\"host004\"],\n        \"vars\": {\n            \"var2\": 500\n        },\n        \"children\":[]\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Running Sanity Tests on Changelog Fragments Directory in Bash\nDESCRIPTION: Executes Ansible sanity tests specifically on the `changelogs/fragments/` directory using `ansible-test sanity`. This command validates the format and content of newly added changelog fragment YAML files before committing. Uses Docker (`--docker`) and verbose output (`-v`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test sanity changelogs/fragments/ --docker -v\n```\n\n----------------------------------------\n\nTITLE: Creating an Ansible Inventory File for Windows VMs (INI format)\nDESCRIPTION: This INI file defines a static inventory for Ansible to connect to a Windows VM provisioned via Vagrant. It sets the host group, target address, and connection details such as username, password, WinRM port, and authentication transport. Dependencies include a running Windows VM and knowledge of the actual WinRM port, which Vagrant may reassign. Expected input is for Ansible inventory processing; output is the ability to target the provided Windows host in subsequent playbooks. The configuration ignores self-signed cert validation, and port conflicts may require user adjustment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[windows]\\nWindowsServer  ansible_host=127.0.0.1\\n\\n[windows:vars]\\nansible_user=vagrant\\nansible_password=vagrant\\nansible_port=55986\\nansible_connection=winrm\\nansible_winrm_transport=ntlm\\nansible_winrm_server_cert_validation=ignore\n```\n\n----------------------------------------\n\nTITLE: PowerShell Module Example Importing Collection Module Utils (PowerShell)\nDESCRIPTION: Snippet demonstrating use of #AnsibleRequires comment headers in a PowerShell module to import basic and collection-specific module_utils dependencies. Requires the Ansible PowerShell execution engine and collection module_utils packaged in the specified path. Parameters are set in the $spec hash table, and the module utilizes collection helpers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_11\n\nLANGUAGE: powershell\nCODE:\n```\n#!powershell\\n#AnsibleRequires -CSharpUtil Ansible.Basic\\n#AnsibleRequires -PowerShell ansible_collections.ansible_example.community.plugins.module_utils.hyperv\\n\\n$spec = @{\\n\\tname = @{ required = $true; type = \"str\" }\\n\n```\n\n----------------------------------------\n\nTITLE: Dependency on ansible.netcommon v2.0.0+ (Ansible)\nDESCRIPTION: Specifies that several network collections (arista.eos, cisco.asa, cisco.ios, cisco.iosxr, cisco.nxos, junipernetworks.junos, vyos.vyos) now require `ansible.netcommon` version 2.0.0 or newer.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_33\n\nLANGUAGE: ansible\nCODE:\n```\nansible.netcommon v2.0.0+\n```\n\n----------------------------------------\n\nTITLE: Referencing the Ansible Apt Module (Text)\nDESCRIPTION: Reference to the Ansible `apt` module (`apt_module`). It's mentioned as an example of a module that can accept a list of packages directly, potentially avoiding the need for an explicit `loop` construct for package installation on Debian/Ubuntu-based systems.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_20\n\nLANGUAGE: text\nCODE:\n```\napt_module\n```\n\n----------------------------------------\n\nTITLE: Specifying Collection for Version Added in YAML Metadata\nDESCRIPTION: This YAML snippet is used within Ansible module or plugin metadata (DOCUMENTATION block) when the `version_added` field refers to a version of a different collection (like Ansible core or another dependency). The `version_added_collection` field explicitly names the collection whose version is being referenced. Usage of this field is discouraged.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_requirements.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nversion_added_collection: collection_name\n```\n\n----------------------------------------\n\nTITLE: Converting PFX to PEM Private Key using OpenSSL (Bash)\nDESCRIPTION: A Bash command using OpenSSL to extract the unencrypted private key from a PFX file (`cert.pfx`) and save it in PEM format (`cert.key`). This is necessary when the certificate is generated using PowerShell, as Ansible requires the private key in PEM format without encryption.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nopenssl pkcs12 \\\n    -in cert.pfx \\\n    -nocerts \\\n    -nodes \\\n    -passin pass: |\n    sed -ne '/-BEGIN PRIVATE KEY-/,/-END PRIVATE KEY-/p' > cert.key\n```\n\n----------------------------------------\n\nTITLE: Including External Role Definitions in requirements.yml (YAML)\nDESCRIPTION: This YAML snippet illustrates how to use the `include` directive within a main `requirements.yml` file. It allows referencing another file (e.g., `webserver.yml`) containing role definitions, enabling the splitting of requirements across multiple files for better organization.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n# from galaxy\n- name: yatesr.timezone\n- include: <path_to_requirements>/webserver.yml\n```\n\n----------------------------------------\n\nTITLE: Git Repository Structure: Multiple Collections (Text)\nDESCRIPTION: Illustrates a Git repository structure containing multiple collections (`collection1`, `collection2`), each within its own subdirectory and having its own `galaxy.yml` file. By default, `ansible-galaxy` searches one level deep and would install both collections found in this structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_git_repo.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n├── collection1\n│   ├── docs/\n│   ├── galaxy.yml\n│   └── plugins/\n│       ├── inventory/\n│       └── modules/\n└── collection2\n    ├── docs/\n    ├── galaxy.yml\n    ├── plugins/\n    |   ├── filter/\n    |   └── modules/\n    └── roles/\n```\n\n----------------------------------------\n\nTITLE: Slice Access of Group Members - Range Selection (Python-like Syntax)\nDESCRIPTION: This Python-like snippet demonstrates selecting ranges or slices from an inventory group for use in patterns. Handles omitted indices and edge conditions. Produces a list of hostnames as per start:end indices.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nwebservers[0:2]     # == webservers[0],webservers[1],webservers[2]\\n                    # == cobweb,webbing,weber\\nwebservers[1:2]     # == webservers[1],webservers[2]\\n                    # == webbing,weber\\nwebservers[1:]      # == webbing,weber\\nwebservers[:3]      # == cobweb,webbing,weber\n```\n\n----------------------------------------\n\nTITLE: Console Output Showing String Conversion Result (Ansible)\nDESCRIPTION: This console output shows the result of the previous Ansible task. The `msg` field contains the string \"['prod1', 'prod2']\", demonstrating that the original list was converted to a string by the `replace` filter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\n.. code-block:: console\n\n    ok: [localhost] => {\n        \"msg\": \"['prod1', 'prod2']\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Manually Mounting systemd Cgroup Hierarchy - Shell\nDESCRIPTION: Shows how to create the /sys/fs/cgroup/systemd directory if missing, and mount the cgroup hierarchy for systemd support. Essential for Docker containers or WSL environments where systemd is not automatically available. Must be run as root. No output unless errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nmkdir /sys/fs/cgroup/systemd\nmount cgroup -t cgroup /sys/fs/cgroup/systemd -o none,name=systemd,xattr\n```\n\n----------------------------------------\n\nTITLE: Ansible Playbook Invoking a Role Multiple Times (YAML)\nDESCRIPTION: An Ansible playbook that lists the role 'foo' twice. This configuration relies on the 'foo' role having `allow_duplicates: true` set in its `meta/main.yml` to execute twice.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\n# playbook.yml\n---\n- hosts: webservers\n  roles:\n    - foo\n    - foo\n```\n\n----------------------------------------\n\nTITLE: Listing Ansible Collections from Custom Paths (Shell)\nDESCRIPTION: This command lists Ansible collections using additional specified search paths along with the default ones. The `-p` option takes a colon-separated list of paths to prepend to the search list. The output shows collections found in the specified paths (`/opt/ansible/collections`, `/etc/ansible/collections`) as well as the default paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_listing.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n> ansible-galaxy collection list -p '/opt/ansible/collections:/etc/ansible/collections'\n\n# /opt/ansible/collections/ansible_collections\nCollection      Version\n--------------- -------\nsandwiches.club 1.7.2\n\n# /etc/ansible/collections/ansible_collections\nCollection     Version\n-------------- -------\nsandwiches.pbj 1.2.0\n\n# /home/astark/.ansible/collections/ansible_collections\nCollection                 Version\n-------------------------- -------\ncisco.aci                  0.0.5\ncisco.mso                  0.0.4\nfortinet.fortios           1.0.1\nsandwiches.ham             *\nsplunk.es                  0.0.5\n\n# /usr/share/ansible/collections/ansible_collections\nCollection        Version\n----------------- -------\nfortinet.fortios  1.0.6\npureport.pureport 0.0.8\nsensu.sensu_go    1.3.0\n```\n\n----------------------------------------\n\nTITLE: Defining Host Groups in Ansible Inventory File (INI format) - ini\nDESCRIPTION: This snippet demonstrates how to define a group named 'myhosts' in an Ansible inventory file, listing individual hosts by IP address or FQDN. Required dependency is an INI-format inventory file (commonly named inventory.ini); no external libraries needed. Input is a list of hosts under a group header, output is interpreted by Ansible commands for host management. Ensure group names are unique, and host entries do not include extra parameters in simple inventories.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[myhosts]\\n192.0.2.50\\n192.0.2.51\\n192.0.2.52\n```\n\n----------------------------------------\n\nTITLE: Silencing Python Discovery Warning in Ansible Inventory\nDESCRIPTION: This INI snippet shows an updated example Ansible inventory file ('hosts'). It adds the 'ansible_python_interpreter=auto_silent' variable to the 'test:vars' section. This setting suppresses the warning about potential Python path changes when using the fallback discovery mechanism.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_13\n\nLANGUAGE: ini\nCODE:\n```\nshell> cat hosts\n[test]\ntest_11\ntest_12\ntest_13\n\n[test:vars]\nansible_connection=ssh\nansible_user=admin\nansible_become=true\nansible_become_user=root\nansible_become_method=sudo\nansible_interpreter_python_fallback=['/usr/local/bin/python', '/usr/local/bin/python3', '/usr/local/bin/python3.11']\nansible_python_interpreter=auto_silent\nansible_perl_interpreter=/usr/local/bin/perl\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Devel Branch from GitHub with pip\nDESCRIPTION: Installs the latest development version ('devel' branch) of 'ansible-core' directly from its GitHub repository using pip for the current user. Useful for testing bleeding-edge features.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --user https://github.com/ansible/ansible/archive/devel.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Incorrect Conditional Referencing Undefined Attribute (Ansible)\nDESCRIPTION: This Ansible task uses the `stat` module and registers the result. The `failed_when` conditional incorrectly tries to access `result.exists`. The correct path is `result.stat.exists`. In previous versions, passing this undefined value to the `is false` test might silently fail; in current versions, it raises an error due to improved undefined value handling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_18\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - stat:\n        path: /does-not-exist\n      register: result\n      failed_when: result.exists is false\n      #                   ^ missing reference to stat\n```\n\n----------------------------------------\n\nTITLE: Renaming OpenStack Dynamic Inventory Script (Shell/Filename)\nDESCRIPTION: This indicates the required filename change for the OpenStack dynamic inventory script from `openstack.py` to `openstack_inventory.py` in Ansible 2.6's contrib section. Users referencing the old name (`openstack.py`) must update to the new name (`openstack_inventory.py`) to avoid potential Python import conflicts with the `openstacksdk` library.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.6.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncontrib/inventory/openstack.py\n```\n\nLANGUAGE: shell\nCODE:\n```\ncontrib/inventory/openstack_inventory.py\n```\n\nLANGUAGE: python\nCODE:\n```\nopenstack.py\n```\n\nLANGUAGE: python\nCODE:\n```\nopenstack_inventory.py\n```\n\nLANGUAGE: python\nCODE:\n```\nopenstacksdk\n```\n\n----------------------------------------\n\nTITLE: Chown systemd Cgroup for Rootless Podman - Shell\nDESCRIPTION: Changes ownership of the systemd cgroup hierarchy directory for the specified user/group, a necessary step when using rootless Podman containers for ansible-test. Replace {user} and {group} with actual usernames. Must be run as root.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nchown -R {user}:{group} /sys/fs/cgroup/systemd\n```\n\n----------------------------------------\n\nTITLE: Linking to Ansible Modules/Plugins with :ansplugin: in reStructuredText (rst)\nDESCRIPTION: Demonstrates the `:ansplugin:` role in reStructuredText for linking to Ansible modules or plugins specified by their FQCN (e.g., `ansible.builtin.copy#module`). It also shows how to provide custom link text.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n  The ansible.builtin.copy module can be linked with\n  :ansplugin:`ansible.builtin.copy#module`\n\n  If you want to specify an explicit type, use:\n  :ansplugin:`the copy module <ansible.builtin.copy#module>`\n```\n\n----------------------------------------\n\nTITLE: Referencing module.exit_json() Method\nDESCRIPTION: Stub documentation reference for the `exit_json()` method, typically called on an `AnsibleModule` instance (`module`) to exit the module execution successfully and return structured JSON data.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_21\n\nLANGUAGE: rst\nCODE:\n```\n.. py:method:: module.exit_json()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating systemd Session Issue with Ansible Become on Linux\nDESCRIPTION: Shows the console output when the `XDG_RUNTIME_DIR` environment variable is missing due to `become` not creating a full systemd session via `pam_systemd`. This results in a \"Permission denied\" error when trying to run `systemctl --user status`, as it cannot connect to the user's D-Bus session. The suggested solution is to use `become_method: machinectl`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ echo $XDG_RUNTIME_DIR\n\n$ systemctl --user status\nFailed to connect to bus: Permission denied\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom UInt64 Parameter Type with AnsibleModule in PowerShell\nDESCRIPTION: This snippet demonstrates how to define a custom module argument type for Ansible PowerShell modules using the argument spec system. The 'uint64_type' parameter uses a delegate function to parse and convert the input value to a System.UInt64 type, enabling strict type enforcement for 64-bit integers. It requires that the Ansible module is being developed using the AnsibleModule wrapper for PowerShell. Inputs must provide a value convertible to UInt64; outputs are accessible under module.Params. Conversion errors will cause the module to fail during argument processing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\n$spec = @{\n    uint64_type = @{ type = [Func[[Object], [UInt64]]]{ [System.UInt64]::Parse($args[0]) } }\n}\n$uint64_type = $module.Params.uint64_type\n```\n\n----------------------------------------\n\nTITLE: Downloading a Single Collection with Ansible Galaxy - Bash\nDESCRIPTION: Demonstrates how to use the ansible-galaxy CLI command to download a single Ansible collection and its dependencies from the configured Galaxy server for offline installation. No other dependencies are required beyond Ansible itself. The key parameter is the collection name (in the format namespace.collection), and the output goes into the default './collections' directory. The expected output is the downloaded collection tarball, its dependencies, and a requirements.yml file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection download my_namespace.my_collection\n```\n\n----------------------------------------\n\nTITLE: Running Platform-Specific Commands on Multiple Devices - YAML\nDESCRIPTION: This playbook demonstrates the use of discrete, platform-specific Ansible modules for Arista EOS, Cisco NXOS, and VyOS devices, each running their relevant command based on device type. It uses a conditional 'when' clause per device OS, and requires the proper Ansible collections (cisco.nxos, arista.eos, vyos.vyos) installed. This example inputs YAML-based playbook tasks and outputs per-device CLI command results, but does not consolidate platform logic; it is best for environments where tasks are deeply customized per device.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: Run Arista command\\n  arista.eos.eos_command:\\n    commands: show ip int br\\n  when: ansible_network_os == 'arista.eos.eos'\\n\\n- name: Run Cisco NXOS command\\n  cisco.nxos.nxos_command:\\n    commands: show ip int br\\n  when: ansible_network_os == 'cisco.nxos.nxos'\\n\\n- name: Run Vyos command\\n  vyos.vyos.vyos_command:\\n    commands: show interface\\n  when: ansible_network_os == 'vyos.vyos.vyos'\n```\n\n----------------------------------------\n\nTITLE: Example Linux 'ip addr show' Command Output (Bash)\nDESCRIPTION: Shows sample output from the `ip addr show` command on a Linux host (Fedora implied by later template name). This semi-structured text serves as input for parsing with the `cli_parse` module and a corresponding native template in the Linux example.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s31f6: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000\n    link/ether x2:6a:64:9d:84:19 brd ff:ff:ff:ff:ff:ff\n3: wlp2s0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether x6:c2:44:f7:41:e0 brd ff:ff:ff:ff:ff:ff permaddr d8:f2:ca:99:5c:82\n```\n\n----------------------------------------\n\nTITLE: Running Windows Integration Tests via ansible-test in Shell\nDESCRIPTION: Runs Windows integration tests using ansible-test with verbose output ('-v') on the shippable/ directory. Requires a defined remote Windows inventory and PowerShell Remoting enabled. Output includes detailed results of Windows-based integration scenarios.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nansible-test windows-integration -v shippable/\n```\n\n----------------------------------------\n\nTITLE: Filtering YAML File for Debugging Vaulted Variable\nDESCRIPTION: Uses shell commands (`cat`, `grep -v`, `>>`) to create a new YAML file (`vyos_no_connection.yml`) by copying an existing file (`vyos.yml`) and excluding lines containing `ansible_connection`. This is done to prevent connection attempts when debugging a variable value.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ cat vyos.yml | grep -v ansible_connection >> vyos_no_connection.yml\n```\n\n----------------------------------------\n\nTITLE: Description of FreeBSD Python Meta Port\nDESCRIPTION: This text snippet contains the description for the FreeBSD 'lang/python' meta port. It clarifies that this port creates symbolic links (like bin/python) to ensure compatibility with Python scripts that are version agnostic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nThis is a meta port to the Python interpreter and provides symbolic links\nto bin/python, bin/pydoc, bin/idle and so on to allow compatibility with\nversion agnostic python scripts.\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespaced Inventory Cache Plugin in ansible.cfg using INI\nDESCRIPTION: Illustrates how to configure an inventory cache plugin that resides within an Ansible collection using its Fully Qualified Collection Name (FQCN). This is set using the `cache_plugin` parameter under the `[inventory]` section in `ansible.cfg`. Inventory caching must also be enabled (`cache=True`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_9\n\nLANGUAGE: ini\nCODE:\n```\n[inventory]\ncache_plugin=collection_namespace.collection_name.cache_plugin\n```\n\n----------------------------------------\n\nTITLE: Example Parsed Interface State Output (Text/JSON)\nDESCRIPTION: Illustrates the structured JSON data format produced by the `ansible.utils.cli_parse` module with the `pyats` parser after processing the 'show interface' command output from a Cisco NXOS device. This nested dictionary represents the state of interfaces like 'Ethernet2/1' and 'Ethernet2/10', including properties like 'admin_state' and 'bandwidth'. This data serves as the input for the subsequent validation task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/validate.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nok: [nxos] => {\n\"changed\": false,\n\"parsed\": {\n    \"Ethernet2/1\": {\n        \"admin_state\": \"down\",\n        \"auto_mdix\": \"off\",\n        \"auto_negotiate\": false,\n        \"bandwidth\": 1000000,\n        \"beacon\": \"off\"\n        <--output omitted-->\n    },\n    \"Ethernet2/10\": {\n        \"admin_state\": \"down\",\n        \"auto_mdix\": \"off\",\n        \"auto_negotiate\": false,\n        \"bandwidth\": 1000000,\n        \"beacon\": \"off\",\n        <--output omitted-->\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Class-Based Unit Tests with unittest - Python\nDESCRIPTION: This Python snippet provides an example of using the unittest module to organize unit tests within a test class. The class structure allows sharing setup code and writing multiple test methods. Dependencies include unittest (standard in Python) and, for integration in the Ansible environment, pytest may be used to discover tests even in unittest-based style. Each method verifies simple arithmetic with assertions on class instance variables.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport unittest\\n\\nclass AddTester(unittest.TestCase):\\n\\n    def SetUp():\\n        self.a = 10\\n        self.b = 23\\n\\n    # this function will\\n    def test_add():\\n      c = 33\\n      assert self.a + self.b == c\\n\\n   # this function will\\n    def test_subtract():\\n      c = -13\\n      assert self.a - self.b == c\n```\n\n----------------------------------------\n\nTITLE: Expanded Logic - Conditional Include Step (`main.yml` part)\nDESCRIPTION: This snippet shows the first part of the expanded logic for the conditional include example. It highlights the `include_tasks` statement in `main.yml` with its `when: x is not defined` condition. Ansible evaluates this condition; if true, it proceeds to include `other_tasks.yml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_26\n\nLANGUAGE: yaml\nCODE:\n```\n# main.yml\n- include_tasks: other_tasks.yml\n  when: x is not defined\n  # if condition is met, Ansible includes other_tasks.yml\n```\n\n----------------------------------------\n\nTITLE: Custom Module Example with Collection Module Utils Usage (Python)\nDESCRIPTION: Python snippet showing a module invoking both built-in and collection-supplied module_utils helpers. Dependencies: Ansible module_utils base libraries and custom helpers inside the target collection. Key parameters include 'argspec' (argument spec), and the module uses a 'HelperRequest' from the collection util. Input is user parameters via Ansible, output is managed by HelperRequest.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nfrom ansible.module_utils.basic import AnsibleModule\\nfrom ansible.module_utils.common.text.converters import to_text\\nfrom ansible.module_utils.six.moves.urllib.parse import urlencode\\nfrom ansible.module_utils.six.moves.urllib.error import HTTPError\\nfrom ansible_collections.ansible_example.community.plugins.module_utils.helper import HelperRequest\\n\\nargspec = dict(\\n\\tname=dict(required=True, type='str'),\\n\\tstate=dict(choices=['present', 'absent'], required=True),\\n)\\n\\nmodule = AnsibleModule(\\n\\targument_spec=argspec,\\n\\tsupports_check_mode=True\\n)\\n\\n_request = HelperRequest(\\n\\tmodule,\\n\\theaders={\"Content-Type\": \"application/json\"},\\n       data=data\\n )\\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Collection Integrity - ansible-galaxy CLI - Bash\nDESCRIPTION: Demonstrates the basic command to verify that a locally installed Ansible collection matches the version on the remote Galaxy server. Requires ansible-galaxy to be installed and configured with proper collection paths and Galaxy server URLs. The primary parameter is the namespace.collection_name identifier; a successful run is silent, with output only if files have been modified.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection\n```\n\n----------------------------------------\n\nTITLE: Ansible Output When File Not Found (Strict Failure)\nDESCRIPTION: This output demonstrates Ansible's error reporting when 'errors=strict' is used in the 'file' lookup and the file is missing. Ansible prints a warning for the missing file and then fails the task with a fatal error, including details about the exception type and file path. This is the default error handling mode, suitable for mandatory file dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_8\n\nLANGUAGE: ansible-output\nCODE:\n```\n    [WARNING]: Unable to find '/nosuchfile' in expected paths (use -vvvvv to see paths)\n\n    fatal: [localhost]: FAILED! => {\"msg\": \"An unhandled exception occurred while running the lookup plugin 'file'. Error was a <class 'ansible.errors.AnsibleError'>, original message: could not locate file in lookup: /nosuchfile\"}\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbook Using Vault ID and Client Script (Bash)\nDESCRIPTION: Shows how to execute an `ansible-playbook` using a specific vault ID (`dev`). The password for this vault ID is retrieved dynamically by executing the provided vault password client script (`@contrib-scripts/vault/vault-keyring-client.py`), which interfaces with a third-party password storage mechanism.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_managing_passwords.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id dev@contrib-scripts/vault/vault-keyring-client.py\n```\n\n----------------------------------------\n\nTITLE: Warning on Missing File Using Lookup Plugin in Ansible (YAML+Jinja)\nDESCRIPTION: Here, the 'errors' argument for the lookup function is set to 'warn,' causing Ansible to continue execution but emit a warning instead of stopping on a missing file. When the 'file' plugin fails, both a file-not-found warning and a traceback warning are shown, and the message is set to empty. This configuration is suitable when user notification is desired but interruption is not.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_5\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n    - name: if this file does not exist, let me know, but continue\n      debug: msg=\"{{ lookup('file', '/nosuchfile', errors='warn') }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Galaxy Servers in ansible.cfg (INI)\nDESCRIPTION: This INI configuration snippet demonstrates how to define distribution servers and their associated API tokens within the `ansible.cfg` file. It sets up an alias (`release_galaxy`) under the `[galaxy]` section and specifies the server URL and authentication token in a corresponding `[galaxy_server.release_galaxy]` section. This method is recommended for securely managing API tokens.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[galaxy]\nserver_list = release_galaxy\n\n[galaxy_server.release_galaxy]\nurl=https://galaxy.ansible.com/\ntoken=abcdefghijklmnopqrtuvwxyz\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies from File with pipx runpip\nDESCRIPTION: Uses 'pipx runpip' to execute a pip command within the Ansible environment managed by pipx. This example installs dependencies listed in a requirements file, commonly needed for specific Ansible collections like the Azure collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ pipx runpip ansible install -r ~/.ansible/collections/ansible_collections/azure/azcollection/requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Adding Common File Option Support in Ansible Modules (Python)\nDESCRIPTION: This snippet configures an Ansible module to automatically support standard file option arguments by setting `add_file_common_args=True` during initialization, and demonstrates using helper methods to apply and validate file-specific options (e.g., permissions, ownership). Key dependencies are the `AnsibleModule` and relevant file helper utilities. The main parameters are custom plus auto-added file options; operations ensure `module.params['path']` is compliant and attributes are updated as required. Input is an argument_spec including 'path'; output signals if changes occurred via `changed`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nargument_spec = {\n  'path': {\n    'type': 'str',\n    'required': True,\n  },\n}\n\nmodule = AnsibleModule(argument_spec, add_file_common_args=True)\nchanged = False\n\n# TODO do something with module.params['path'], like update its contents\n\n# Ensure that module.params['path'] satisfies the file options supplied by the user\nfile_args = module.load_file_common_arguments(module.params)\nchanged = module.set_fs_attributes_if_different(file_args, changed)\n\nmodule.exit_json(changed=changed)\n```\n\n----------------------------------------\n\nTITLE: Strict Error on Missing File Using Lookup Plugin (YAML+Jinja)\nDESCRIPTION: The snippet sets the 'errors' parameter to 'strict' (the default) in a lookup operation. If the specified file does not exist, Ansible will fail the task, emitting detailed error output. This is intended for situations where missing files are unacceptable and should cause immediate playbook failure. This default behavior ensures that required external data must be available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_7\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n    - name: if this file does not exist, FAIL (this is the default)\n      debug: msg=\"{{ lookup('file', '/nosuchfile', errors='strict') }}\"\n```\n\n----------------------------------------\n\nTITLE: Building Core Documentation Pages with Make in Bash\nDESCRIPTION: Uses the `make` utility with the `coredocs` target to build all core documentation pages written in reStructuredText, excluding most module documentation. This provides a more comprehensive build than `htmlsingle`. Should be run from the `docs/docsite` directory. Requires `make` and the documentation build tools.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmake coredocs\n```\n\n----------------------------------------\n\nTITLE: Creating and Pushing Release Branches - Bash\nDESCRIPTION: Creates a new release branch (named 'stable-X') from the main branch and pushes it to the upstream repository. Replace 'X' with the appropriate major version number. Requires Git, correct permissions, and a configured upstream. Input: target branch name and main as base; Output: remote branch created upstream.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit branch stable-X main\\ngit push upstream stable-X\n```\n\n----------------------------------------\n\nTITLE: Building SELinux Module with Bash Script - Bash\nDESCRIPTION: This snippet demonstrates how to invoke a shell script (build.sh) to build the Ansible-Podman SELinux module. The script is assumed to automate the steps necessary for module compilation. Required dependency: The script file build.sh must exist and have executable permissions. The main parameter is the script path, and no arguments are required. Output is the compiled SELinux policy module file (ansible-podman.pp), and the process must be run from the directory containing build.sh.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/tests/selinux/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Enabling Persistent Device Logging Globally - INI\nDESCRIPTION: This snippet configures persistent device interaction logging globally via the Ansible configuration file in INI format. Add the 'log_messages = True' option under the 'persistent_connection' section. Prerequisite: write access to ansible.cfg. Forces logging of all persistent network connections, which may expose sensitive information; best used in secured environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\\nlog_messages = True\n```\n\n----------------------------------------\n\nTITLE: Verifying Collection with Detached Signature(s) - ansible-galaxy CLI - Bash\nDESCRIPTION: Demonstrates how to provide one or more detached signatures using --signature options when verifying a collection. The command also uses --keyring for signature validation and accepts remote or local signature files. This pattern is used when signatures are provided out-of-band or with added verification strictness.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection --signature https://examplehost.com/detached_signature.asc --signature file:///path/to/local/detached_signature.asc --keyring ~/.ansible/pubring.kbx\n```\n\n----------------------------------------\n\nTITLE: Styling Custom Table for Ansible Collection Details - HTML/CSS\nDESCRIPTION: Defines custom table styling and the structure of a detailed information table on Ansible-maintained collections using HTML and CSS. This snippet is used to format and visually enhance the presentation of collection metadata in Sphinx/reStructuredText documentation via a raw HTML block, and depends on Sphinx's ability to render raw directives. Inputs are fixed collection and requirement data; outputs are a visually formatted table in the generated documentation. No client-side scripting or advanced CSS features are used, and all data is statically embedded in the table.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/contributing_maintained_collections.rst#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<style>\\n  /* Style for this single table.  Add delimiters between header columns */\\n  table#ansible-collection-table  th {\\n    border-width: 1px;\\n    border-color: #dddddd /*rgb(225, 228, 229)*/;\\n    border-style: solid;\\n    text-align: center;\\n    padding: 5px;\\n    background-color: #eeeeee;\\n  }\\n  tr, td {\\n   border-width: 1px;\\n   border-color: rgb(225, 228, 229);\\n   border-style: solid;\\n   text-align: center;\\n   padding: 5px;\\n }\\n  </style>\\n\\n  <table id=\\\"ansible-collection-table\\\">\\n    <tr>\\n      <th colspan=\\\"3\\\">Collection details</th>\\n      <th colspan=\\\"4\\\">Test requirements: Ansible collections</th>\\n      <th colspan=\\\"2\\\">Developer details</th>\\n    </tr>\\n    <tr>\\n      <th>Ansible collection</th>\\n      <th>Related community collection</th>\\n      <th>Sponsor</th>\\n      <th>Sanity</th>\\n      <th>Unit</th>\\n      <th>Integration</th>\\n      <th>CI Platform</th>\\n      <th>Open to PRs*</th>\\n      <th>Guidelines</th>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/amazon/aws\\\">amazon.aws</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/aws\\\">community.aws</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/AWS\\\">AWS</a></td>\\n      <td>\\u2713**</td>\\n      <td>**</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/collections/amazon/aws/docsite/dev_guidelines.html\\\">AWS guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/ansible/netcommon\\\">ansible.netcommon***</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/ansible/posix\\\">ansible.posix</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/general\\\">community.general</a></td>\\n      <td>Linux</a></td>\\n      <td>\\u2713</td>\\n      <td></td>\\n      <td></td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/latest/dev_guide/index.html\\\">Developer guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/ansible/windows\\\">ansible.windows</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/windows\\\">community.windows</a></td>\\n      <td><a href=\\\"https://matrix.to:/#/#windows:ansible.com\\\">Windows</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713****</td>\\n      <td>\\u2713</td>\\n      <td>Azure Pipelines and Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/dev_guide/developing_modules_general_windows.html#developing-modules-general-windows\\\">Windows guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/arista/eos\\\">arista.eos</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/cisco/asa\\\">cisco.asa</a></td>\\n      <td><a href=\\\"https://github.com/ansible-collections/community.asa\\\">community.asa</a></td>\\n      <td><a href=\\\"https://matrix.to/#/#security-automation:ansible.com\\\">Security</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/latest/dev_guide/index.html\\\">Developer guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/cisco/ios\\\">cisco.ios</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/cisco/iosxr\\\">cisco.iosxr</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/cisco/nxos\\\">cisco.nxos</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/ibm/qradar\\\">ibm.qradar</a></td>\\n      <td><a href=\\\"https://github.com/ansible-collections/community.qradar\\\">community.qradar</a></td>\\n      <td><a href=\\\"https://matrix.to/#/#security-automation:ansible.com\\\">Security</a></td>\\n      <td>\\u2713</td>\\n      <td></td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/latest/dev_guide/index.html\\\">Developer guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/junipernetworks/junos\\\">junipernetworks.junos</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/kubernetes/core\\\">kubernetes.core</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/kubernetes/core\\\">kubernetes.core</a></td>\\n      <td><a href=\\\"https://matrix.to:/#/#kubernetes:ansible.com\\\">Kubernetes</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>GitHub Actions</td>\\n      <td>\\u2713</td>\\n      <td></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://cloud.redhat.com/ansible/automation-hub/redhat/openshift\\\">redhat.openshift</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/okd\\\">community.okd</a></td>\\n      <td><a href=\\\"https://matrix.to:/#/#kubernetes:ansible.com\\\">Kubernetes</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>GitHub Actions</td>\\n      <td>\\u2713</td>\\n      <td></td>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/openvswitch/openvswitch\\\">openvswitch.openvswitch</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://github.com/ansible-collections/splunk.es\\\">splunk.es</a></td>\\n      <td><a href=\\\"https://github.com/ansible-collections/community.es\\\">community.es</a></td>\\n      <td><a href=\\\"https://matrix.to/#/#security-automation:ansible.com\\\">Security</a></td>\\n      <td>\\u2713</td>\\n      <td></td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/latest/dev_guide/index.html\\\">Developer guide</a></td>\\n    </tr>\\n    <tr>\\n      <td><a href=\\\"https://galaxy.ansible.com/vyos/vyos\\\">vyos.vyos</a></td>\\n      <td><a href=\\\"https://galaxy.ansible.com/community/network\\\">community.network</a></td>\\n      <td><a href=\\\"https://forum.ansible.com/g/network-wg\\\">Network</a></td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>\\u2713</td>\\n      <td>Zuul</td>\\n      <td>\\u2713</td>\\n      <td><a href=\\\"https://docs.ansible.com/ansible/devel/network/dev_guide/index.html\\\">Network guide</a></td>\\n    </tr>\\n\n```\n\n----------------------------------------\n\nTITLE: Installing pip using easy_install in Shell\nDESCRIPTION: Installs the 'pip' package manager using 'easy_install'. This step is only necessary if pip is not already available on the system. Pip is required to install Ansible's dependencies listed in 'requirements.txt'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ easy_install pip               # if pip is not already available\n```\n\n----------------------------------------\n\nTITLE: Overriding Python Interpreter via Command Line (Shell)\nDESCRIPTION: Demonstrates how to manually specify the Python interpreter to be used on managed hosts for a single command execution using the `-e` (extra-vars) command-line option. This overrides any inventory settings and is useful for testing Python 3 compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/python_3_support.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible localhost -m ping -e 'ansible_python_interpreter=/usr/bin/python3'\n$ ansible-playbook sample-playbook.yml -e 'ansible_python_interpreter=/usr/bin/python3'\n```\n\n----------------------------------------\n\nTITLE: Defining Playbook Host Pattern - Ansible Playbooks (YAML)\nDESCRIPTION: This YAML playbook outline shows the 'hosts:' field using a pattern, which may represent a host, group, or expression. The content under 'name' describes the play. An inventory and playbook structure are required. Input patterns determine which managed nodes are targeted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: <play_name>\\n  hosts: <pattern>\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Ansible Module Setup Function (Python)\nDESCRIPTION: This Python unit test specifically targets the argument validation within an Ansible module's setup function (like the previously shown `setup_module_object`). It utilizes a helper function `set_module_args` (common in Ansible testing frameworks) to simulate providing incomplete arguments (missing the required `db_instance_identifier`). It then asserts that calling the module's setup logic raises an `AnsibleFailJson` exception, confirming that the validation correctly identifies and handles missing required parameters. This approach isolates the testing of initialization logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef test_rds_module_setup_fails_if_db_instance_identifier_parameter_missing():\n    # db_instance_identifier parameter is missing\n    set_module_args({\n        'state': 'absent',\n        'apply_immediately': 'True',\n     })\n\n    with self.assertRaises(AnsibleFailJson) as result:\n        my_module.setup_json\n```\n\n----------------------------------------\n\nTITLE: Declaring Module Dependencies with AnsibleModule - Ansible Python\nDESCRIPTION: This snippet illustrates how to apply dependency constraints among module arguments when instantiating an AnsibleModule. It sets mutually_exclusive and required_one_of dependencies, passing option names as sequences of tuples to enforce exclusivity or requirement. Requires the AnsibleModule class and a defined argument_spec dictionary.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nmodule = AnsibleModule(\n  argument_spec,\n  mutually_exclusive=[\n    ('path', 'content'),\n  ],\n  required_one_of=[\n    ('path', 'content'),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Delegating a Task to a Specific Host with Run_once in Ansible (YAML)\nDESCRIPTION: Illustrates applying both 'run_once: true' and 'delegate_to' to a task, forcing execution of a command on a nominated host (e.g., web01.example.org) regardless of batch scope. Task runs once and result is applied to all hosts, but runs only on the delegated node. No dependencies outside standard Ansible delegation functionality.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n    - command: /opt/application/upgrade_db.py\\n      run_once: true\\n      delegate_to: web01.example.org\n```\n\n----------------------------------------\n\nTITLE: Importing Integration Test Tasks Conditionally with Ansible YAML\nDESCRIPTION: This YAML snippet demonstrates how to import an external set of test tasks into a main integration test file, using a conditional statement to ensure tests only run if the PostgreSQL server version meets the required minimum version. The primary dependency is the output variable 'postgres_version_resp' which must be defined and deliver a 'stdout' property interpretable by the 'version' test. This allows the test suite to be modular and adaptable for different environments. The imported file must exist within the tasks directory structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_updating.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# General tests:\n- import_tasks: postgresql_user_general.yml\n  when: postgres_version_resp.stdout is version('9.4', '>=')\n```\n\n----------------------------------------\n\nTITLE: Description of FreeBSD Python 3 Meta Port\nDESCRIPTION: This text snippet provides the description for the FreeBSD 'lang/python3' meta port. It explains that this port provides symbolic links (like bin/python3) for compatibility with scripts that don't specify a minor Python 3 version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nThis is a meta port to the Python 3.x interpreter and provides symbolic links\nto bin/python3, bin/pydoc3, bin/idle3 and so on to allow compatibility with\nminor version agnostic Python scripts.\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Callback Plugins in ansible.cfg\nDESCRIPTION: This configuration snippet demonstrates how to enable specific callback plugins within the `ansible.cfg` file. Multiple plugins like `timer`, `mail`, `profile_roles`, and a custom namespaced callback are listed under the `callbacks_enabled` option, although the line is commented out by default.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/callback.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n#callbacks_enabled = timer, mail, profile_roles, collection_namespace.collection_name.custom_callback\n```\n\n----------------------------------------\n\nTITLE: Defining Inventory Groups - Ansible - text\nDESCRIPTION: This snippet demonstrates how to create groups of hosts within a static Ansible inventory file using plain text format. It lists hostnames under group headers, such as [webservers] and [dbservers], designating each member server. The file can be placed anywhere Ansible is configured to search for inventory, and it allows for simple host grouping without requiring dynamic inventory scripts. No specific dependencies are required beyond standard Ansible; expected input is a list of hostnames and group sections and output is interpreted by Ansible during runtime as host groups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/overview_architecture.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[webservers]\\nwww1.example.com\\nwww2.example.com\\n\\n[dbservers]\\ndb0.example.com\\ndb1.example.com\n```\n\n----------------------------------------\n\nTITLE: Setting a Custom Standard Output Callback Plugin in ansible.cfg\nDESCRIPTION: This configuration snippet illustrates how to set a custom plugin named `mycallback` as the handler for standard output (stdout) in `ansible-playbook` via the `ansible.cfg` file. This requires the custom callback to have `CALLBACK_TYPE = stdout` defined.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/callback.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\nstdout_callback = mycallback\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Unable to Connect to Socket Error - Ansible Output\nDESCRIPTION: Illustrates Ansible failure output when a connection cannot be established to the socket used by a network module. Contains traceback with ConnectionError, points to line 123 within ansible.module_utils.connection, and provides guidance for further troubleshooting. Useful for recognizing and addressing connection layer issues and interpreting structured output from failed playbook or ad hoc runs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_10\n\nLANGUAGE: ansible-output\nCODE:\n```\nfatal: [spine02]: FAILED! => {\\n    \"changed\": false,\\n    \"failed\": true,\\n    \"module_stderr\": \"Traceback (most recent call last):\\n  File \\\"/tmp/ansible_TSqk5J/ansible_modlib.zip/ansible/module_utils/connection.py\\\", line 123, in _exec_jsonrpc\\nansible.module_utils.connection.ConnectionError: Unable to connect to socket XX. See Troubleshooting socket path issues in Network Debug and Troubleshooting Guide\\n\",\\n    \"module_stdout\": \"\",\\n    \"msg\": \"MODULE FAILURE\",\\n    \"rc\": 1\\n}\n```\n\n----------------------------------------\n\nTITLE: Role Directory Structure Including Custom Module Utils\nDESCRIPTION: This console snippet outlines the standard directory structure of an Ansible role that integrates both PowerShell and C# custom module utilities. The folder 'module_utils' contains utility files for both languages, named according to Ansible conventions. This structure enables roles to maintain or share reusable module logic outside the Ansible core distribution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nmeta/\n  main.yml\ndefaults/\n  main.yml\nmodule_utils/\n  Ansible.ModuleUtils.ModuleUtil1.psm1\n  Ansible.ModuleUtils.ModuleUtil2.psm1\n  Ansible.CustomUtil.cs\ntasks/\n  main.yml\n```\n\n----------------------------------------\n\nTITLE: Detecting Modified Collection Files - ansible-galaxy CLI - Bash\nDESCRIPTION: Illustrates output from ansible-galaxy collection verify when a collection has been altered. It lists the namespace.collection name and the paths to the files that differ from the remote, allowing users to identify local changes. Usage patterns and dependencies are identical to the basic verification command.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection\nCollection my_namespace.my_collection contains modified content in the following files:\nmy_namespace.my_collection\n    plugins/inventory/my_inventory.py\n    plugins/modules/my_module.py\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Ad Hoc Operations via Ansible CLI (bash)\nDESCRIPTION: Demonstrates how to run a long-running command on remote systems asynchronously from the command line using Ansible ad hoc commands. Requires Ansible installed and accessible hosts. The '-B' flag specifies the timeout for the task in seconds, and the '-P' flag controls polling behavior (0 disables polling for 'fire and forget'). No command output is collected unless later checked via job ID. Outputs depend on job execution and can be checked with async_status.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -B 3600 -P 0 -a \"/usr/bin/long_running_operation --do-stuff\"\n```\n\n----------------------------------------\n\nTITLE: Testing Attribute Options in PostgreSQL User Module with Ansible YAML\nDESCRIPTION: This YAML snippet demonstrates comprehensive integration testing for adding a new boolean option ('add_attribute') to the 'community.postgresql.postgresql_user' module. The sequence tests both attribute-absent and attribute-present cases, ensures proper creation with assertions, performs SQL queries to validate user attributes, and verifies expected row counts in query results. Needed dependencies are the 'community.postgresql' modules and access to an initialized database. Tasks are parameterized by user name and conditional attribute state. Results are checked with assert tasks and registered variables. Limitations may include reliance on the schema having an 'attribute' field and proper database setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_updating.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# https://github.com/ansible-collections/community.postgresql/issues/NUM\n# We should also run the same tasks with check_mode: true. We omit it here for simplicity.\n- name: Test for new_option, create new user WITHOUT the attribute\n  community.postgresql.postgresql_user:\n    name: test_user      \n  register: result\n\n- name: Check the module returns what we expect\n  assert:\n    that:\n      - result is changed\n\n- name: Query the database if the user exists but does not have the attribute (it is NULL)\n  community.postgresql.postgresql_query:\n    query: SELECT * FROM pg_authid WHERE rolename = 'test_user' AND attribute = NULL\n  register: result\n\n- name: Check the database returns one row\n  assert:\n    that:\n      - result.query_result.rowcount == 1\n\n- name: Test for new_option, create new user WITH the attribute\n  community.postgresql.postgresql_user:\n    name: test_user\n  register: result\n\n- name: Check the module returns what we expect\n  assert:\n    that:\n      - result is changed\n\n- name: Query the database if the user has the attribute (it is TRUE)\n  community.postgresql.postgresql_query:\n    query: SELECT * FROM pg_authid WHERE rolename = 'test_user' AND attribute = 't'\n  register: result\n\n- name: Check the database returns one row\n  assert:\n    that:\n      - result.query_result.rowcount == 1\n```\n\n----------------------------------------\n\nTITLE: Defining Subsection Headings in reStructuredText (rst)\nDESCRIPTION: Shows the reStructuredText syntax using '-' underlines to define a 'subsection' level heading, like 'Internal navigation', nested under a section.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n      Internal navigation\n      -------------------\n```\n\n----------------------------------------\n\nTITLE: Running All Ansible Unit Tests in Collection with Docker in Bash\nDESCRIPTION: Executes all available unit tests within the Ansible collection using the `ansible-test units` command without specifying a path. The `--docker` flag runs all unit tests within a consistent container environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test units --docker\n```\n\n----------------------------------------\n\nTITLE: Tag Inheritance for Includes via apply Keyword - Ansible (YAML)\nDESCRIPTION: Shows how to apply tags to all dynamically included tasks using the 'apply' keyword with 'include_tasks'. This approach allows tags to propagate to all tasks within the included file, overcoming the default lack of tag inheritance for dynamic includes. Requires Ansible version supporting the 'apply' keyword. Involves 'include_tasks', 'apply', and 'tags'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Apply the db tag to the include and to all tasks in db.yml\n  include_tasks:\n    file: db.yml\n    # adds 'db' tag to tasks within db.yml\n    apply:\n      tags: db\n  # adds 'db' tag to this 'include_tasks' itself\n  tags: db\n\n```\n\n----------------------------------------\n\nTITLE: Privatized Functions in `ansible.module_utils.common.parameters` in Python\nDESCRIPTION: The functions `list_no_log_values`, `list_deprecations`, and `handle_aliases` within `ansible.module_utils.common.parameters` are now considered private implementation details. Direct usage is discouraged; developers should use `ArgumentSpecValidator.validate()` which incorporates this logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Discouraged direct use:\n# from ansible.module_utils.common.parameters import list_no_log_values, list_deprecations, handle_aliases\n\n# Recommended approach:\nfrom ansible.module_utils.common.arg_spec import ArgumentSpecValidator\n\n# validator = ArgumentSpecValidator(...)\n# validated_params = validator.validate(module.params)\n# (These functions are called internally by validate)\n```\n\n----------------------------------------\n\nTITLE: Deprecating ldap_attr Module in community.general\nDESCRIPTION: The `ldap_attr` module is deprecated and scheduled for removal in a future release. Users should use the `ldap_attrs` module instead for managing LDAP attributes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_13\n\nLANGUAGE: Ansible\nCODE:\n```\nldap_attr\n```\n\n----------------------------------------\n\nTITLE: Tagging Multiple Tasks with the Same Tag - Ansible Role Tasks (YAML)\nDESCRIPTION: Shows how to apply the same tag to several tasks within a role's task file, such as tagging NTP-related tasks with 'ntp'. This enables running or skipping grouped tasks together. Prerequisites include Ansible and a role structure. Key parameters include 'tags' and module-specific arguments. Tasks sharing the same tag respond together to tag selection during playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# file: roles/common/tasks/main.yml\n\n- name: Install ntp\n  ansible.builtin.yum:\n    name: ntp\n    state: present\n  tags: ntp\n\n- name: Configure ntp\n  ansible.builtin.template:\n    src: ntp.conf.j2\n    dest: /etc/ntp.conf\n  notify:\n  - restart ntpd\n  tags: ntp\n\n- name: Enable and run ntpd\n  ansible.builtin.service:\n    name: ntpd\n    state: started\n    enabled: true\n  tags: ntp\n\n- name: Install NFS utils\n  ansible.builtin.yum:\n    name:\n    - nfs-utils\n    - nfs-util-lib\n    state: present\n  tags: filesharing\n\n```\n\n----------------------------------------\n\nTITLE: Using failed_when for Conditional Failure Handling in community.routeros Modules - YAML\nDESCRIPTION: Demonstrates how to use the 'failed_when' directive in an Ansible playbook to conditionally mark a task as failed based on a specific error message from a 'community.routeros' module. This pattern helps users handle idempotent failure scenarios gracefully (e.g., 'failure: already have such address') by customizing the error-handling logic for module responses. Requires Ansible, community.routeros collection, and familiarity with task result objects. The variable 'result.msg[0]' is checked for a substring; input is the result of a previous task, and output is a boolean for task failure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_5.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nfailed_when: \"'failure: already have ' in result.msg[0]\"\n```\n\n----------------------------------------\n\nTITLE: Querying Included Collections with Ansible Navigator and Community EE Base - Bash\nDESCRIPTION: Lists all Ansible collections available in the 'community-ee-base' execution environment image using ansible-navigator. Requires ansible-navigator to be installed and Docker access. The '--execution-environment-image' parameter specifies which container image to inspect and outputs the list of preinstalled collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_community_ee_image.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator collections --execution-environment-image ghcr.io/ansible-community/community-ee-base:latest\n```\n\n----------------------------------------\n\nTITLE: Specifying Paramiko SSH Connection in Ansible\nDESCRIPTION: This snippet represents the command-line argument `-c paramiko` used with Ansible commands (like `ansible` or `ansible-playbook`). It forces Ansible to use the 'paramiko' connection plugin, which is a Python-based SSH implementation, instead of the native OpenSSH or other connection types. This setting can also be specified within playbooks or the Ansible configuration file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n-c paramiko\n```\n\n----------------------------------------\n\nTITLE: Incorrect String Formatting (Python 2.6 Incompatible)\nDESCRIPTION: Shows an example of `str.format()` using implicit positional arguments (`\"{}\".format(val)`). This syntax was introduced in Python 2.7 and is incompatible with Python 2.6, thus should be avoided in Ansible control node code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Does not work in Python 2.6!\nnew_string = \"Dear {}, Welcome to {}\".format(username, location)\n```\n\n----------------------------------------\n\nTITLE: Formatting Ansible Changelog Security Fixes in YAML\nDESCRIPTION: Demonstrates the YAML structure for documenting security fixes within an Ansible changelog fragment under the 'security_fixes' key. It includes a sample entry for 'set_options' addressing CVE-2021-3620, highlighting the required format (present tense, CVE link) and the importance of not logging sensitive parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nsecurity_fixes:\n  - set_options -do not include params in exception when a call to ``set_options`` fails. Additionally, block the exception that is returned from being displayed to stdout. (CVE-2021-3620).\n```\n\n----------------------------------------\n\nTITLE: Installing Collection Locally from Tarball (Bash)\nDESCRIPTION: Demonstrates using ansible-galaxy collection install to install a collection tarball locally into a specified directory with the -p flag. Collection must be built already. By default, installs to first COLLECTIONS_PATHS unless specified. Input is the tarball path; output is the unpacked collection in the local Ansible collections directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncollection_dir#> ansible-galaxy collection install my_namespace-my_collection-1.0.0.tar.gz -p ./collections\n```\n\n----------------------------------------\n\nTITLE: Installing and Uninstalling Software with win_chocolatey, win_package, and win_command - Ansible Playbook YAML\nDESCRIPTION: This set of snippets demonstrates three methods for installing and uninstalling software (7-Zip) on Windows hosts using Ansible: the win_chocolatey module for Chocolatey package management, win_package for direct installer execution, and win_command for explicit command-based installs/uninstalls. Required dependencies include Chocolatey for the first method and proper installer files for the others. Inputs include package name/installer path and state, while outputs are the installation state of software; tasks can be conditionally executed and support become for privilege elevation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# Install/uninstall with chocolatey\\n- name: Ensure 7-Zip is installed through Chocolatey\\n  win_chocolatey:\\n    name: 7zip\\n    state: present\\n\\n- name: Ensure 7-Zip is not installed through Chocolatey\\n  win_chocolatey:\\n    name: 7zip\\n    state: absent\\n\\n# Install/uninstall with win_package\\n- name: Download the 7-Zip package\\n  win_get_url:\\n    url: https://www.7-zip.org/a/7z1701-x64.msi\\n    dest: C:\\\\temp\\\\7z.msi\\n\\n- name: Ensure 7-Zip is installed through win_package\\n  win_package:\\n    path: C:\\\\temp\\\\7z.msi\\n    state: present\\n\\n- name: Ensure 7-Zip is not installed through win_package\\n  win_package:\\n    path: C:\\\\temp\\\\7z.msi\\n    state: absent\\n\\n# Install/uninstall with win_command\\n- name: Download the 7-Zip package\\n  win_get_url:\\n    url: https://www.7-zip.org/a/7z1701-x64.msi\\n    dest: C:\\\\temp\\\\7z.msi\\n\\n- name: Check if 7-Zip is already installed\\n  win_reg_stat:\\n    name: HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\{23170F69-40C1-2702-1701-000001000000}\\n  register: 7zip_installed\\n\\n- name: Ensure 7-Zip is installed through win_command\\n  win_command: C:\\\\Windows\\\\System32\\\\msiexec.exe /i C:\\\\temp\\\\7z.msi /qn /norestart\\n  when: 7zip_installed.exists == false\\n\\n- name: Ensure 7-Zip is uninstalled through win_command\\n  win_command: C:\\\\Windows\\\\System32\\\\msiexec.exe /x {23170F69-40C1-2702-1701-000001000000} /qn /norestart\\n  when: 7zip_installed.exists == true\n```\n\n----------------------------------------\n\nTITLE: Marking Deprecated Features in Changelog Fragments - YAML\nDESCRIPTION: This YAML snippet exemplifies documenting deprecations, explaining which features or behavior have been deprecated, alternatives when available, and when removal is expected. The 'deprecated_features' key is followed by entries that clarify deprecation and give specific guidance to users, often referencing upcoming releases and related pull requests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndeprecated_features:\n  - mail callback plugin - not specifying ``sender`` is deprecated and will be disallowed in ``community.general`` 6.0.0 (https://github.com/ansible-collections/community.general/pull/4140).\n\n```\n\n----------------------------------------\n\nTITLE: Isolating Errors with Ad Hoc Ansible Command - Shell\nDESCRIPTION: Presents an ad hoc shell command that uses Ansible's CLI to run the arista.eos.eos_command module against a specified network device. Arguments include inventory location, host, connection plugin, username, and SSH password prompt (-k). Used to quickly test connectivity, authentication, and basic communication with a single device outside of playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nansible -m arista.eos.eos_command -a 'commands=?' -i inventory switch1.example.net -e 'ansible_connection=ansible.netcommon.network_cli' -u admin -k\n```\n\n----------------------------------------\n\nTITLE: Configuring Inventory Cache Plugin in ansible.cfg using INI\nDESCRIPTION: Specifies the inventory cache plugin within the `[inventory]` section of the `ansible.cfg` file using the `cache_plugin` parameter. This example sets the plugin to `jsonfile`. This requires inventory caching to be enabled (`cache=True`) in the same section or via an environment variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_7\n\nLANGUAGE: ini\nCODE:\n```\n[inventory]\ncache_plugin=jsonfile\n```\n\n----------------------------------------\n\nTITLE: Defining Collections Search Order in Role Metadata (YAML)\nDESCRIPTION: Demonstrates specifying an explicit list of collections to search for tasks in a role via the 'meta/main.yml' file. No external dependencies except for the relevant collections being available and properly installed. Ansible uses this search order for resolving unqualified module and plugin names within the role, affecting which modules are found if multiple collections supply similarly-named plugins.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n   # myrole/meta/main.yml\\n   collections:\\n     - my_namespace.first_collection\\n     - my_namespace.second_collection\\n     - other_namespace.other_collection\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Integration Tests in Shell\nDESCRIPTION: This snippet shows how to exclude a specific integration test, in this case targeting the git module, when running ansible-test integration. The '--exclude' flag omits the named test, useful for debugging or temporary exclusion. Dependencies are the same as standard ansible-test runs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration --exclude git\n```\n\n----------------------------------------\n\nTITLE: Periodically Updating Cloned Ansible Core Parts in Bash\nDESCRIPTION: Re-runs the Python script to ensure the locally cloned Ansible Core components are up-to-date. This is recommended to be run periodically before building documentation to incorporate the latest changes from the core repository. Requires Python 3 and the 'ansible-documentation' repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython3 docs/bin/clone-core.py\n```\n\n----------------------------------------\n\nTITLE: Removing Deprecated Arguments in ansible.netcommon (Ansible)\nDESCRIPTION: Notes the removal of deprecated connection arguments from the `netconf_config` module within the `ansible.netcommon` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_32\n\nLANGUAGE: ansible\nCODE:\n```\nansible.netcommon\n```\n\n----------------------------------------\n\nTITLE: Building Dictionary from Key/Value Lists using Ansible Loop and `combine`\nDESCRIPTION: This Ansible task constructs `mydict` by iterating over pairs created by `zip(keys, values)`. In each loop iteration, `set_fact` uses the `combine` filter to merge a new dictionary `{item[0]: item[1]}` (where `item[0]` is the key from the `keys` list and `item[1]` is the corresponding value from the `values` list) into the existing `mydict`. This incrementally builds the final dictionary `{\"foo\": \"a\", \"var\": \"b\", \"bar\": \"c\"}`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_12\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- name: Uses 'combine' to update the dictionary and 'zip' to make pairs of both lists\n  ansible.builtin.set_fact:\n    mydict: \"{{ mydict | default({}) | combine({item[0]: item[1]}) }}\"\n  loop: \"{{ (keys | zip(values)) | list }}\"\n  vars:\n    keys:\n      - foo\n      - var\n      - bar\n    values:\n      - a\n      - b\n      - c\n```\n\n----------------------------------------\n\nTITLE: Correcting Jinja Filter Usage on Lists with 'map' in Ansible (YAML+Jinja)\nDESCRIPTION: Presents the corrected Ansible debug task. It uses the `map` filter to apply the `replace` filter individually to each element of the list (`['test1', 'test2']`), ensuring the operation is performed correctly on strings and preserving the list structure in the result.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_14\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- debug:\n    msg: \"{{ ['test1', 'test2'] | map('replace', 'test', 'prod') }}\"\n```\n\n----------------------------------------\n\nTITLE: Checking Ansible Playbook Syntax\nDESCRIPTION: This shell command demonstrates how to use the `ansible-playbook` command with the `--syntax-check` flag to validate the syntax of an Ansible playbook without executing it. This is useful for catching errors early, especially before deploying changes to a staging or production environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/ansible_tips_tricks.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook --syntax-check\n```\n\n----------------------------------------\n\nTITLE: Enabling Device Interaction Logging Globally - Shell\nDESCRIPTION: Illustrates how to set the ANSIBLE_LOG_PATH environment variable to enable logging of device interactions for all Ansible network tasks. Requires shell access to the Ansible control node. Subsequent Ansible playbook runs will append detailed device command interaction data to the specified log file, which may contain sensitive information.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# Specify the location for the log file\\nexport ANSIBLE_LOG_PATH=~/ansible.log\n```\n\n----------------------------------------\n\nTITLE: Suppressing Task Logging for Sensitive Data in Ansible\nDESCRIPTION: An Ansible task attribute set to `True` within a playbook task definition. It prevents the task's input, output, and potentially sensitive variable values from being logged or displayed in standard output, thus protecting secrets. Note that this does not affect debugging output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/logging.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n`no_log: True`\n```\n\n----------------------------------------\n\nTITLE: Disabling Diff Output for Sensitive Tasks in Ansible (YAML)\nDESCRIPTION: This YAML snippet shows how to prevent Ansible from displaying file diffs for a sensitive template task by setting 'diff: false'. This is useful when file contents are confidential or diffs could expose secrets. Only the specified task's diff output is suppressed, while other tasks and modes function as normal.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_checkmode.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: This task will not report a diff when the file changes\n    ansible.builtin.template:\n      src: secret.conf.j2\n      dest: /etc/secret.conf\n      owner: root\n      group: root\n      mode: '0600'\n    diff: false\n```\n\n----------------------------------------\n\nTITLE: Organizing Ansible Directory Structure - Console Representation\nDESCRIPTION: This directory listing provides an example layout for an Ansible project, demonstrating how to organize inventory files, variable directories, role directories, and main playbooks. It helps users visualize the recommended folder and file structure for managing environments, variables, and custom modules/plugins. No dependencies are required—this is a logical structure guide, not executable code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nproduction                # inventory file for production servers\\nstaging                   # inventory file for staging environment\\n\\ngroup_vars/\\n   group1.yml             # here we assign variables to particular groups\\n   group2.yml\\nhost_vars/\\n   hostname1.yml          # here we assign variables to particular systems\\n   hostname2.yml\\n\\nlibrary/                  # if any custom modules, put them here (optional)\\nmodule_utils/             # if any custom module_utils to support modules, put them here (optional)\\nfilter_plugins/           # if any custom filter plugins, put them here (optional)\\n\\nsite.yml                  # main playbook\\nwebservers.yml            # playbook for webserver tier\\ndbservers.yml             # playbook for dbserver tier\\ntasks/                    # task files included from playbooks\\n    webservers-extra.yml  # <-- avoids confusing playbook with task files\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Facts Structure in JSON\nDESCRIPTION: Provides a sample JSON output representing the `ansible_facts` variable gathered by Ansible from a target host (CentOS 7 in this case). It includes extensive details about hardware, operating system, network configuration, memory, storage, and more, which can be utilized in Ansible playbooks and templates. Note that sensitive data like MAC addresses, serial numbers, and SSH keys are often redacted (`REDACTED`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"address\": \"REDACTED\",\n    \"prefix\": \"64\",\n    \"scope\": \"link\"\n}\n            ],\n            \"macaddress\": \"REDACTED\",\n            \"module\": \"xen_netfront\",\n            \"mtu\": 1500,\n            \"pciid\": \"vif-1\",\n            \"promisc\": false,\n            \"type\": \"ether\"\n        },\n        \"ansible_fips\": false,\n        \"ansible_form_factor\": \"Other\",\n        \"ansible_fqdn\": \"centos-7-rax-dfw-0003427354\",\n        \"ansible_hostname\": \"centos-7-rax-dfw-0003427354\",\n        \"ansible_interfaces\": [\n            \"lo\",\n            \"eth1\",\n            \"eth0\"\n        ],\n        \"ansible_is_chroot\": false,\n        \"ansible_kernel\": \"3.10.0-862.14.4.el7.x86_64\",\n        \"ansible_lo\": {\n            \"active\": true,\n            \"device\": \"lo\",\n            \"ipv4\": {\n                \"address\": \"127.0.0.1\",\n                \"broadcast\": \"host\",\n                \"netmask\": \"255.0.0.0\",\n                \"network\": \"127.0.0.0\"\n            },\n            \"ipv6\": [\n                {\n                    \"address\": \"::1\",\n                    \"prefix\": \"128\",\n                    \"scope\": \"host\"\n                }\n            ],\n            \"mtu\": 65536,\n            \"promisc\": false,\n            \"type\": \"loopback\"\n        },\n        \"ansible_local\": {},\n        \"ansible_lsb\": {\n            \"codename\": \"Core\",\n            \"description\": \"CentOS Linux release 7.5.1804 (Core)\",\n            \"id\": \"CentOS\",\n            \"major_release\": \"7\",\n            \"release\": \"7.5.1804\"\n        },\n        \"ansible_machine\": \"x86_64\",\n        \"ansible_machine_id\": \"2db133253c984c82aef2fafcce6f2bed\",\n        \"ansible_memfree_mb\": 7709,\n        \"ansible_memory_mb\": {\n            \"nocache\": {\n                \"free\": 7804,\n                \"used\": 173\n            },\n            \"real\": {\n                \"free\": 7709,\n                \"total\": 7977,\n                \"used\": 268\n            },\n            \"swap\": {\n                \"cached\": 0,\n                \"free\": 0,\n                \"total\": 0,\n                \"used\": 0\n            }\n        },\n        \"ansible_memtotal_mb\": 7977,\n        \"ansible_mounts\": [\n            {\n                \"block_available\": 7220998,\n                \"block_size\": 4096,\n                \"block_total\": 9817227,\n                \"block_used\": 2596229,\n                \"device\": \"/dev/xvda1\",\n                \"fstype\": \"ext4\",\n                \"inode_available\": 10052341,\n                \"inode_total\": 10419200,\n                \"inode_used\": 366859,\n                \"mount\": \"/\",\n                \"options\": \"rw,seclabel,relatime,data=ordered\",\n                \"size_available\": 29577207808,\n                \"size_total\": 40211361792,\n                \"uuid\": \"cac81d61-d0f8-4b47-84aa-b48798239164\"\n            },\n            {\n                \"block_available\": 0,\n                \"block_size\": 2048,\n                \"block_total\": 252,\n                \"block_used\": 252,\n                \"device\": \"/dev/xvdd\",\n                \"fstype\": \"iso9660\",\n                \"inode_available\": 0,\n                \"inode_total\": 0,\n                \"inode_used\": 0,\n                \"mount\": \"/mnt/config\",\n                \"options\": \"ro,relatime,mode=0700\",\n                \"size_available\": 0,\n                \"size_total\": 516096,\n                \"uuid\": \"2018-10-25-12-05-57-00\"\n            }\n        ],\n        \"ansible_nodename\": \"centos-7-rax-dfw-0003427354\",\n        \"ansible_os_family\": \"RedHat\",\n        \"ansible_pkg_mgr\": \"yum\",\n        \"ansible_processor\": [\n            \"0\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"1\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"2\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"3\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"4\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"5\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"6\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\",\n            \"7\",\n            \"GenuineIntel\",\n            \"Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\"\n        ],\n        \"ansible_processor_cores\": 8,\n        \"ansible_processor_count\": 8,\n        \"ansible_processor_nproc\": 8,\n        \"ansible_processor_threads_per_core\": 1,\n        \"ansible_processor_vcpus\": 8,\n        \"ansible_product_name\": \"HVM domU\",\n        \"ansible_product_serial\": \"REDACTED\",\n        \"ansible_product_uuid\": \"REDACTED\",\n        \"ansible_product_version\": \"4.1.5\",\n        \"ansible_python\": {\n            \"executable\": \"/usr/bin/python2\",\n            \"has_sslcontext\": true,\n            \"type\": \"CPython\",\n            \"version\": {\n                \"major\": 2,\n                \"micro\": 5,\n                \"minor\": 7,\n                \"releaselevel\": \"final\",\n                \"serial\": 0\n            },\n            \"version_info\": [\n                2,\n                7,\n                5,\n                \"final\",\n                0\n            ]\n        },\n        \"ansible_python_version\": \"2.7.5\",\n        \"ansible_real_group_id\": 1000,\n        \"ansible_real_user_id\": 1000,\n        \"ansible_selinux\": {\n            \"config_mode\": \"enforcing\",\n            \"mode\": \"enforcing\",\n            \"policyvers\": 31,\n            \"status\": \"enabled\",\n            \"type\": \"targeted\"\n        },\n        \"ansible_selinux_python_present\": true,\n        \"ansible_service_mgr\": \"systemd\",\n        \"ansible_ssh_host_key_ecdsa_public\": \"REDACTED KEY VALUE\",\n        \"ansible_ssh_host_key_ed25519_public\": \"REDACTED KEY VALUE\",\n        \"ansible_ssh_host_key_rsa_public\": \"REDACTED KEY VALUE\",\n        \"ansible_swapfree_mb\": 0,\n        \"ansible_swaptotal_mb\": 0,\n        \"ansible_system\": \"Linux\",\n        \"ansible_system_capabilities\": [\n            \"\"\n        ],\n        \"ansible_system_capabilities_enforced\": \"True\",\n        \"ansible_system_vendor\": \"Xen\",\n        \"ansible_uptime_seconds\": 151,\n        \"ansible_user_dir\": \"/home/zuul\",\n        \"ansible_user_gecos\": \"\",\n        \"ansible_user_gid\": 1000,\n        \"ansible_user_id\": \"zuul\",\n        \"ansible_user_shell\": \"/bin/bash\",\n        \"ansible_user_uid\": 1000,\n        \"ansible_userspace_architecture\": \"x86_64\",\n        \"ansible_userspace_bits\": \"64\",\n        \"ansible_virtualization_role\": \"guest\",\n        \"ansible_virtualization_type\": \"xen\",\n        \"gather_subset\": [\n            \"all\"\n        ],\n        \"module_setup\": true\n    }\n```\n\n----------------------------------------\n\nTITLE: Executing an Ansible Playbook for Network Configuration (Bash)\nDESCRIPTION: Demonstrates running the `playbook.yml` using the `ansible-playbook` command. The `-l rtr1` option limits the execution to only the host named 'rtr1'. The output shows the successful execution of the two tasks ('configure hostname' and 'configure DNS'), indicating changes were made on the target device.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible ~]$ ansible-playbook playbook.yml -l rtr1\n\nPLAY [configure cisco routers] *************************************************\n\nTASK [configure hostname] ******************************************************\nchanged: [rtr1]\n\nTASK [configure DNS] ***********************************************************\nchanged: [rtr1]\n\nPLAY RECAP *********************************************************************\nrtr1                       : ok=2    changed=2    unreachable=0    failed=0\n```\n\n----------------------------------------\n\nTITLE: Mixed Wildcard and Group Pattern - Ansible Playbooks (YAML)\nDESCRIPTION: This snippet combines a wildcard DNS name pattern ('one*.com') and an inventory group ('dbservers') to target hosts matching either in Ansible playbooks. Requires inventory group and hosts with appropriate names. Demonstrates pattern composition flexibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\none*.com:dbservers\n```\n\n----------------------------------------\n\nTITLE: Accessing Top-Level Ansible Fact using Jinja\nDESCRIPTION: This Jinja2 template snippet demonstrates accessing a top-level key ('nodename', representing the system hostname) directly within the `ansible_facts` variable. It's a common way to retrieve basic system identifiers in Ansible templates or playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_5\n\nLANGUAGE: jinja\nCODE:\n```\n{{ ansible_facts['nodename'] }}\n```\n\n----------------------------------------\n\nTITLE: Adding Directory and Custom Facts, Then Re-Gathering Facts in Ansible Playbook (YAML)\nDESCRIPTION: This YAML snippet provides an example Ansible playbook for preparing a host to use custom facts. It performs three tasks: creates the facts.d directory, copies a custom fact file to that directory, and re-runs fact gathering to make the new custom facts available in the current play. Relies on ansible.builtin.file, ansible.builtin.copy, and ansible.builtin.setup modules. The playbook requires that the source custom fact file (ipmi.fact) is present on the controller machine. Outputs the updated custom facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: webservers\\n  tasks:\\n\\n    - name: Create directory for ansible custom facts\\n      ansible.builtin.file:\\n        state: directory\\n        recurse: true\\n        path: /etc/ansible/facts.d\\n\\n    - name: Install custom ipmi fact\\n      ansible.builtin.copy:\\n        src: ipmi.fact\\n        dest: /etc/ansible/facts.d\\n\\n    - name: Re-read facts after adding custom fact\\n      ansible.builtin.setup:\\n        filter: ansible_local\n```\n\n----------------------------------------\n\nTITLE: Specifying the Host Variables Directory (Text/Path)\nDESCRIPTION: Indicates the directory name `host_vars/` relative to an Ansible inventory file. This directory contains YAML files named after specific hostnames in the inventory, allowing variables (including complex data structures) to be assigned directly to individual hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nhost_vars/\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Variables in Ansible Inventory - Ansible Inventory - Text\nDESCRIPTION: This inventory snippet shows how to set per-host SSH connection methods and users directly in the Ansible inventory. 'ansible_connection=ssh' selects the SSH method; 'ansible_user' sets the login username for each host. This method requires a properly formatted Ansible inventory file and is useful for managing heterogeneous remote user requirements for different machines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nother1.example.com     ansible_connection=ssh        ansible_user=myuser\\nother2.example.com     ansible_connection=ssh        ansible_user=myotheruser\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Minimum Ansible Core Version in YAML\nDESCRIPTION: This YAML snippet, intended for the `meta/runtime.yml` file within an Ansible collection, defines the minimum required version of ansible-core using the `requires_ansible` field. In this example, it specifies that the collection requires ansible-core version 2.16 or later.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_requirements.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrequires_ansible: '>=2.16'\n```\n\n----------------------------------------\n\nTITLE: Invoking a Collection Playbook from Command Line (Shell)\nDESCRIPTION: Shows how to execute a playbook packaged inside a collection by supplying its fully qualified name to 'ansible-playbook' from the shell. Requires the collection and playbook to be present in the Ansible environment. Takes inventory as input; outputs depend on tasks defined in the collection playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n    ansible-playbook my_namespace.my_collection.playbook1 -i ./myinventory\n```\n\n----------------------------------------\n\nTITLE: Replicating `with_items` Flattening with `loop` and `flatten` in Ansible\nDESCRIPTION: This YAML+Jinja snippet shows how to achieve the same flattened list iteration as `with_items` using the `loop` keyword combined with the `flatten(1)` Jinja2 filter. The list `[1, [2, 3], 4]` is flattened to `[1, 2, 3, 4]` before iteration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n  loop: \"{{ [1, [2, 3], 4] | flatten(1) }}\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Host Aliases and Connection Parameters in YAML - Ansible Inventory - YAML\nDESCRIPTION: Provides a YAML representation for defining a host alias with custom port and destination host address. This enables connecting to the host via the alias while specifying actual connection parameters, with type safety ensured by YAML.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n# ...\\n  hosts:\\n    jumper:\\n      ansible_port: 5555\\n      ansible_host: 192.0.2.50\n```\n\n----------------------------------------\n\nTITLE: Enabling Vars Plugins in Ansible Configuration (INI)\nDESCRIPTION: This INI snippet shows how to enable specific vars plugins within the `ansible.cfg` file. It lists the default `host_group_vars` plugin and a custom plugin from a collection (`namespace.collection_name.vars_plugin_name`) under the `[defaults]` section using the `vars_plugins_enabled` setting. This configuration determines which vars plugins Ansible will load and potentially execute.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/vars.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nvars_plugins_enabled = host_group_vars,namespace.collection_name.vars_plugin_name\n```\n\n----------------------------------------\n\nTITLE: Conditional Skipping in Ansible Playbooks using YAML\nDESCRIPTION: This YAML snippet demonstrates how to use a conditional statement (`when`) within an Ansible integration test playbook for fine-grained test skipping. It serves as an alternative to `skip/*` aliases in the `aliases` file, allowing tests or specific tasks to run only when certain conditions are met, such as the target system's distribution being 'Ubuntu'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/integration-aliases.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n.. code-block:: yaml\n\n   when: ansible_distribution in ('Ubuntu')\n```\n\n----------------------------------------\n\nTITLE: Configuring Junos Inventory for NETCONF (INI)\nDESCRIPTION: This snippet shows an example Ansible inventory group variables section ([junos:vars]) in INI format. It configures hosts in the 'junos' group to use the NETCONF connection plugin ('ansible.netcommon.netconf'), specifies the network OS ('junipernetworks.junos.junos'), sets the username ('myuser'), and uses Ansible Vault for the password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netconf_enabled.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[junos:vars]\nansible_connection=ansible.netcommon.netconf\nansible_network_os=junipernetworks.junos.junos\nansible_user=myuser\nansible_password=!vault |\n```\n\n----------------------------------------\n\nTITLE: Setting Buffer Read Timeout per Task (YAML)\nDESCRIPTION: Example Ansible task demonstrating how to increase the buffer read timeout for a specific task using `vars`. Setting `ansible_buffer_read_timeout: 2` gives the `ansible.netcommon.network_cli` connection plugin 2 seconds to read the command output buffer, which can resolve intermittent failures caused by slow devices or complex prompts. Available since Ansible 2.7.1.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_41\n\nLANGUAGE: yaml\nCODE:\n```\n- name: gather ios facts\n  cisco.ios.ios_facts:\n    gather_subset: all\n  register: result\n  vars:\n    ansible_buffer_read_timeout: 2\n```\n\n----------------------------------------\n\nTITLE: Linting Ansible Playbooks for Best Practices (Bash)\nDESCRIPTION: This Bash snippet illustrates the use of 'ansible-lint' to analyze a playbook (here, verify-apache.yml) for adherence to Ansible style and best practices. The tool provides feedback and warnings, such as the recommendation to replace 'state: latest' with 'state: present' for package installation tasks. Dependencies include installation of ansible-lint and access to the playbook file. Input is the path to a playbook; output is linter diagnostics.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_intro.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-lint verify-apache.yml\n[403] Package installs should not use latest\nverify-apache.yml:8\nTask/Handler: ensure apache is at the latest version\n\n```\n\n----------------------------------------\n\nTITLE: Restarting Service with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Restarts the 'httpd' service on all hosts in the 'webservers' group. This command utilizes the `ansible.builtin.service` module, specifying `name=httpd state=restarted` as the argument.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.service -a \"name=httpd state=restarted\"\n```\n\n----------------------------------------\n\nTITLE: Overriding OS Detection for Parser in `cli_parse` (YAML)\nDESCRIPTION: These two Ansible tasks illustrate overriding the operating system used by the parser in `cli_parse`. The first task forces the `pyats` parser to use `ios` templates instead of the detected `iosxe`. The second task forces the `native` parser to use `linux` templates instead of the detected `fedora` distribution. This is done using the `parser/os` suboption.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_25\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: Use ios instead of iosxe for pyats\n     ansible.utils.cli_parse:\n       command: show something\n       parser:\n         name: ansible.netcommon.pyats\n         os: ios\n\n   - name: Use linux instead of fedora from ansible_distribution\n     ansible.utils.cli_parse:\n       command: ps -ef\n       parser:\n         name: ansible.netcommon.native\n         os: linux\n```\n\n----------------------------------------\n\nTITLE: Looping Over All Inventory Hosts using 'groups'\nDESCRIPTION: This Ansible task uses the `ansible.builtin.debug` module to print the name of each host in the entire inventory. It iterates through the list of all hosts provided by the special Jinja2 variable `groups['all']`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_17\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Show all the hosts in the inventory\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ groups['all'] }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Directory Structure for Ansible Role Variables (Text)\nDESCRIPTION: Shows an example of organizing role variables within nested directories under `vars/main/`. Ansible processes these directories and files alphabetically, handling nested directories before files at the same level.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nroles/\n    common/          # this hierarchy represents a \"role\"\n        vars/\n            main/    #  <-- variables associated with this role\n                first_nested_directory/\n                    first_variables_file.yml\n                second_nested_directory/\n                    second_variables_file.yml\n                third_variables_file.yml\n```\n\n----------------------------------------\n\nTITLE: Example Output of Python Discovery Debug Playbook\nDESCRIPTION: This console output shows the result of running the debug playbook using the YAML callback for readability. It displays the discovered Python interpreter path ('/usr/local/bin/python'), the fallback list used, the discovered interpreter variable, and the Python path on the control node. A warning about potential path changes due to future installations is also shown.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\nshell> ANSIBLE_STDOUT_CALLBACK=yaml ansible-playbook -i hosts playbook.yml\n\nPLAY [test_11] *******************************************************************************\n\nTASK [command] *******************************************************************************\n[WARNING]: Platform freebsd on host test_11 is using the discovered Python interpreter at\n/usr/local/bin/python, but future installation of another Python interpreter could change the\nmeaning of that path. See https://docs.ansible.com/ansible-\ncore/2.18/reference_appendices/interpreter_discovery.html for more information.\nchanged: [test_11]\n\nTASK [debug] *********************************************************************************\nok: [test_11] =>\n  result.stdout: /usr/local/bin/python\n\nTASK [debug] *********************************************************************************\nok: [test_11] =>\n  msg: |-\n    ansible_interpreter_python_fallback:\n      - /usr/local/bin/python\n      - /usr/local/bin/python3\n      - /usr/local/bin/python3.11\n\n    discovered_interpreter_python:\n      /usr/local/bin/python\n\n    ansible_playbook_python:\n      /usr/bin/python3\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_delete_lc_job* Modules in dellemc.openmanage\nDESCRIPTION: The `dellemc_delete_lc_job` and `dellemc_delete_lc_job_queue` modules are deprecated. Use the `idrac_lifecycle_controller_jobs` module to manage jobs in the Dell EMC Lifecycle Controller.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_34\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_delete_lc_job\n```\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_delete_lc_job_queue\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Command with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Uses the `ansible.builtin.shell` module (`-m ansible.builtin.shell`) to execute a command (`echo $TERM`) that requires shell processing (like variable expansion) on hosts in the 'raleigh' group. Single quotes around the command argument (`-a`) ensure the `$TERM` variable is evaluated on the remote host, not locally.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible raleigh -m ansible.builtin.shell -a 'echo $TERM'\n```\n\n----------------------------------------\n\nTITLE: Illustrating Jinja2 Test Syntax in Ansible\nDESCRIPTION: This snippet shows the correct Jinja2 syntax for applying a test to a variable within Ansible. Tests are designed for making comparisons or checks (e.g., checking if a variable is defined, is a string, etc.) and return a boolean result.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-tests-as-filters.rst#_snippet_1\n\nLANGUAGE: jinja2\nCODE:\n```\nvariable is test_name\n```\n\n----------------------------------------\n\nTITLE: Analyzing Verbose Output from win_dsc Task (Ansible Output)\nDESCRIPTION: This snippet displays example output generated when running an Ansible playbook containing the `win_dsc` task with verbosity level 3 (`-vvv`). It shows the 'invocation.module_args' containing the parameters passed to the DSC resource, detailed logs from the DSC Local Configuration Manager (LCM) performing 'Test' and 'Set' operations, the module version used, and whether a reboot is required. This output is useful for debugging and understanding the interaction between Ansible and DSC.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_2\n\nLANGUAGE: ansible-output\nCODE:\n```\nchanged: [2016] => {\n    \"changed\": true,\n    \"invocation\": {\n        \"module_args\": {\n            \"DependsOn\": null,\n            \"Ensure\": \"Present\",\n            \"Force\": null,\n            \"Hex\": null,\n            \"Key\": \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\ExampleKey\",\n            \"PsDscRunAsCredential_password\": null,\n            \"PsDscRunAsCredential_username\": null,\n            \"ValueData\": [\n                \"TestData\"\n            ],\n            \"ValueName\": \"TestValue\",\n            \"ValueType\": null,\n            \"module_version\": \"latest\",\n            \"resource_name\": \"Registry\"\n        }\n    },\n    \"module_version\": \"1.1\",\n    \"reboot_required\": false,\n    \"verbose_set\": [\n        \"Perform operation 'Invoke CimMethod' with following parameters, ''methodName' = ResourceSet,'className' = MSFT_DSCLocalConfigurationManager,'namespaceName' = root/Microsoft/Windows/DesiredStateConfiguration'.\",\n        \"An LCM method call arrived from computer SERVER2016 with user sid S-1-5-21-3088887838-4058132883-1884671576-1105.\",\n        \"[SERVER2016]: LCM:  [ Start  Set      ]  [[Registry]DirectResourceAccess]\",\n        \"[SERVER2016]:                            [[Registry]DirectResourceAccess] (SET) Create registry key 'HKLM:\\\\SOFTWARE\\\\ExampleKey'\",\n        \"[SERVER2016]:                            [[Registry]DirectResourceAccess] (SET) Set registry key value 'HKLM:\\\\SOFTWARE\\\\ExampleKey\\\\TestValue' to 'TestData' of type 'String'\",\n        \"[SERVER2016]: LCM:  [ End    Set      ]  [[Registry]DirectResourceAccess]  in 0.1930 seconds.\",\n        \"[SERVER2016]: LCM:  [ End    Set      ]    in  0.2720 seconds.\",\n        \"Operation 'Invoke CimMethod' complete.\",\n        \"Time taken for configuration job to complete is 0.402 seconds\"\n    ],\n    \"verbose_test\": [\n        \"Perform operation 'Invoke CimMethod' with following parameters, ''methodName' = ResourceTest,'className' = MSFT_DSCLocalConfigurationManager,'namespaceName' = root/Microsoft/Windows/DesiredStateConfiguration'.\",\n        \"An LCM method call arrived from computer SERVER2016 with user sid S-1-5-21-3088887838-4058132883-1884671576-1105.\",\n        \"[SERVER2016]: LCM:  [ Start  Test     ]  [[Registry]DirectResourceAccess]\",\n        \"[SERVER2016]:                            [[Registry]DirectResourceAccess] Registry key 'HKLM:\\\\SOFTWARE\\\\ExampleKey' does not exist\",\n        \"[SERVER2016]: LCM:  [ End    Test     ]  [[Registry]DirectResourceAccess] False in 0.2510 seconds.\",\n        \"[SERVER2016]: LCM:  [ End    Set      ]    in  0.3310 seconds.\",\n        \"Operation 'Invoke CimMethod' complete.\",\n        \"Time taken for configuration job to complete is 0.475 seconds\"\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Example Validation Error Output (Text)\nDESCRIPTION: Shows the console output when the `ansible.utils.validate` task identifies validation failures against the specified criteria. The `fatal: [nxos02]: FAILED!` indicates failure, but the playbook continues due to `ignore_errors: true`. The `errors` list details each failure: `data_path` shows the location in the input data (e.g., 'Ethernet2/1.admin_state'), `expected` shows the criteria pattern ('up'), `found` shows the actual value ('down'), and `message` provides a human-readable error. This output is captured in the 'result' variable for further processing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/validate.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nTASK [Validate interface for admin state] ***********************************************************************************************************\nfatal: [nxos02]: FAILED! => {\"changed\": false, \"errors\": [{\"data_path\": \"Ethernet2/1.admin_state\", \"expected\": \"up\", \"found\": \"down\", \"json_path\": \"$.Ethernet2/1.admin_state\", \"message\": \"'down' does not match 'up'\", \"relative_schema\": {\"pattern\": \"up\", \"type\": \"string\"}, \"schema_path\": \"patternProperties.^.*.properties.admin_state.pattern\", \"validator\": \"pattern\"}, {\"data_path\": \"Ethernet2/10.admin_state\", \"expected\": \"up\", \"found\": \"down\", \"json_path\": \"$.Ethernet2/10.admin_state\", \"message\": \"'down' does not match 'up'\", \"relative_schema\": {\"pattern\": \"up\", \"type\": \"string\"}, \"schema_path\": \"patternProperties.^.*.properties.admin_state.pattern\", \"validator\": \"pattern\"}], \"msg\": \"Validation errors were found.\\nAt 'patternProperties.^.*.properties.admin_state.pattern' 'down' does not match 'up'. \\nAt 'patternProperties.^.*.properties.admin_state.pattern' 'down' does not match 'up'. \\nAt 'patternProperties.^.*.properties.admin_state.pattern' 'down' does not match 'up'. \"}\n...ignoring\n```\n\n----------------------------------------\n\nTITLE: Verifying pip Installation\nDESCRIPTION: Checks if the 'pip' package manager is installed and available for the specified Python interpreter (python3). This command executes pip as a module to display its version and location.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip -V\n```\n\n----------------------------------------\n\nTITLE: Defining Task Failure with Multiple AND Conditions (YAML)\nDESCRIPTION: This Ansible task demonstrates using a list of conditions under `failed_when`. Ansible implicitly joins these conditions with an AND operator. The task executes `ls /tmp/this_should_not_be_here` and registers the result. It will only be marked as failed if *both* conditions are true: the return code (`result.rc`) is 0 (meaning the `ls` command succeeded, implying the file exists) AND the string 'No such' is *not* present in the standard error output (`result.stderr`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Check if a file exists in temp and fail task if it does\n  ansible.builtin.command: ls /tmp/this_should_not_be_here\n  register: result\n  failed_when:\n    - result.rc == 0\n    - '\"No such\" not in result.stderr'\n```\n\n----------------------------------------\n\nTITLE: Installing argcomplete with pip - Shell\nDESCRIPTION: Installs the 'argcomplete' Python package for the current user to support shell command completion. Use this if Ansible was installed with pip (not pipx). Inputs: none. Outputs: argcomplete available for configuration. Requires pip, Python 3, and user permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_24\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --user argcomplete\n```\n\n----------------------------------------\n\nTITLE: Defining Section Headings in reStructuredText (rst)\nDESCRIPTION: Provides the reStructuredText syntax using '=' underlines to create a 'section' level heading within Ansible documentation, for example, 'Mechanical guidelines'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n      Mechanical guidelines\n      =====================\n```\n\n----------------------------------------\n\nTITLE: Structuring Inventory Directory for Controlled Load Order (Text)\nDESCRIPTION: Illustrates using numerical prefixes (e.g., `01-`, `02-`, `03-`) for inventory source files within a directory (`inventory/`) to control the alphabetical loading order. This ensures predictable variable merging when multiple sources (like cloud inventory, dynamic scripts, static files) define the same variables, with later files overriding earlier ones. The example includes inventory sources and a `group_vars/all.yml` file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_27\n\nLANGUAGE: text\nCODE:\n```\ninventory/\n  01-openstack.yml          # configure inventory plugin to get hosts from Openstack cloud\n  02-dynamic-inventory.py   # add additional hosts with dynamic inventory script\n  03-static-inventory       # add static hosts\n  group_vars/\n    all.yml                 # assign variables to all hosts\n```\n\n----------------------------------------\n\nTITLE: Example JSON Structure of a Registered Loop Variable in Ansible\nDESCRIPTION: This JSON object shows the typical data structure stored in a variable when using `register` with a loop in Ansible. It contains an overall status (`changed`, `msg`) and a `results` attribute, which is a list containing the detailed output from each individual loop iteration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n.. code-block:: json\n\n    {\n        \"changed\": true,\n        \"msg\": \"All items completed\",\n        \"results\": [\n            {\n                \"changed\": true,\n                \"cmd\": \"echo \\\"one\\\" \",\n                \"delta\": \"0:00:00.003110\",\n                \"end\": \"2013-12-19 12:00:05.187153\",\n                \"invocation\": {\n                    \"module_args\": \"echo \\\"one\\\"\",\n                    \"module_name\": \"shell\"\n                },\n                \"item\": \"one\",\n                \"rc\": 0,\n                \"start\": \"2013-12-19 12:00:05.184043\",\n                \"stderr\": \"\",\n                \"stdout\": \"one\"\n            },\n            {\n                \"changed\": true,\n                \"cmd\": \"echo \\\"two\\\" \",\n                \"delta\": \"0:00:00.002920\",\n                \"end\": \"2013-12-19 12:00:05.245502\",\n                \"invocation\": {\n                    \"module_args\": \"echo \\\"two\\\"\",\n                    \"module_name\": \"shell\"\n                },\n                \"item\": \"two\",\n                \"rc\": 0,\n                \"start\": \"2013-12-19 12:00:05.242582\",\n                \"stderr\": \"\",\n                \"stdout\": \"two\"\n            }\n        ]\n    }\n```\n\n----------------------------------------\n\nTITLE: Listing Installed Ansible Roles using ansible-galaxy (Bash)\nDESCRIPTION: Executes the `ansible-galaxy role list` command to display all Ansible roles that are currently installed on the system within the configured roles paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy role list\n```\n\n----------------------------------------\n\nTITLE: Using Plugin-Specific Ansible Connection Variables\nDESCRIPTION: Ansible allows plugin-specific connection variables, like `ansible_ssh_host` for the `ssh` plugin, which take precedence over general variables (e.g., `ansible_host`) for finer control over connection parameters for that specific plugin. This example shows the SSH-specific variable for the host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nansible_ssh_host\n```\n\n----------------------------------------\n\nTITLE: Validating Data and Handling Errors with Ansible Playbook (YAML)\nDESCRIPTION: These Ansible tasks demonstrate using the `ansible.utils.validate` module to check the previously parsed interface data against the defined JSON schema criteria. The first task inputs the parsed data (`nxos_pyats_show_interface['parsed']`) and loads the criteria from a file using the `lookup` plugin. It specifies `ansible.utils.jsonschema` as the validation engine. `ignore_errors: true` prevents the playbook from stopping if validation fails, and the result (including potential errors) is registered in the `result` variable. The second task uses `ansible.builtin.debug` to loop (`loop`) through the `result['errors']` list (if it exists, checked by `when: \"'errors' in result\"`) and prints the interface name (extracted from `item['data_path']`) for each validation error.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/validate.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Validate interface admin state\n  ansible.utils.validate:\n    data: \"{{ nxos_pyats_show_interface['parsed'] }}\"\n    criteria:\n      - \"{{ lookup('file',  './criteria/nxos_show_interface_admin_criteria.json') | from_json }}\"\n    engine: ansible.utils.jsonschema\n  ignore_errors: true\n  register: result\n\n- name: Print the interface names that do not satisfy the desired state\n  ansible.builtin.debug:\n    msg: \"{{ item['data_path'].split('.')[0] }}\"\n  loop: \"{{ result['errors'] }}\"\n  when: \"'errors' in result\"\n```\n\n----------------------------------------\n\nTITLE: Listing Installed Ansible Collections using ansible-galaxy (Bash)\nDESCRIPTION: Executes the `ansible-galaxy collection list` command to display all Ansible collections that are currently installed on the system within the configured collection paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection list\n```\n\n----------------------------------------\n\nTITLE: Sourcing ansible-core Environment Setup Script - Shell\nDESCRIPTION: Executes the shell script to update environment variables (especially PATH) so that ansible-core tools are available from the command line. Requires a valid cloned ansible-core repository and a POSIX shell. Output: Updates current shell environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nsource hacking/env-setup\n```\n\n----------------------------------------\n\nTITLE: Using Boolean Filters in Conditionals - Ansible Playbook - YAML\nDESCRIPTION: Illustrates the correct use of boolean filters in 'when' conditionals in Ansible 5, as bare variables containing string values like 'false' are always considered true without '|bool'. This example prevents accidental execution of tasks by ensuring string variables are conversions using the bool filter. Prerequisite: Ansible 5 or later. Inputs: string variable 'teardown'; Outputs: conditional task inclusion based on boolean interpretation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_5.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  teardown: 'false'\n\ntasks:\n  - include_tasks: teardown.yml\n    when: teardown | bool\n\n  - include_tasks: provision.yml\n    when: not teardown | bool\n```\n\n----------------------------------------\n\nTITLE: Defining Variables with the 'vars' Keyword (YAML)\nDESCRIPTION: Shows the `vars:` keyword used in Ansible playbooks. This keyword allows defining variables directly within the scope of the object it's applied to (Play, Block, Role, or Task).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n```\n\n----------------------------------------\n\nTITLE: Cloning Collection Repository via SSH (Bash)\nDESCRIPTION: Clones a forked `community.postgresql` collection repository from GitHub using the SSH protocol into the local collections directory. This is an alternative to HTTPS cloning. Replace `YOURACC` with the actual GitHub username.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:YOURACC/community.postgresql.git ~/ansible_collections/community/postgresql\n```\n\n----------------------------------------\n\nTITLE: Displaying Name Lookup Failure Log Output - Console\nDESCRIPTION: Provides log lines recorded by Ansible when it fails to resolve the remote host or service, as indicated by the '[Errno -2] Name or service not known' message. Utilized for diagnosing inventory file or provider misconfigurations. No setup is required—results shown are direct console outputs from Ansible runs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\n2017-04-04 11:39:48,147 p=15299 u=fred |  control socket path is /home/fred/.ansible/pc/ca5960d27a\n2017-04-04 11:39:48,147 p=15299 u=fred |  current working directory is /home/fred/git/ansible-inc/stable-2.3/test/integration\n2017-04-04 11:39:48,147 p=15299 u=fred |  using connection plugin network_cli\n2017-04-04 11:39:48,340 p=15299 u=fred |  connecting to host veos01 returned an error\n2017-04-04 11:39:48,340 p=15299 u=fred |  [Errno -2] Name or service not known\n```\n\n----------------------------------------\n\nTITLE: Automatically Accept SSH Host Keys via ansible.cfg - INI\nDESCRIPTION: Configures the ansible.cfg file to instruct Paramiko to auto-accept unknown SSH host keys (host_key_auto_add = True). Place this in the '[paramiko_connection]' section to persist this behavior globally for all Ansible runs using Paramiko. It is a security-sensitive setting to use with care.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_21\n\nLANGUAGE: ini\nCODE:\n```\n[paramiko_connection]\nhost_key_auto_add = True\n```\n\n----------------------------------------\n\nTITLE: Using Double Quotes to Preserve Colons in YAML\nDESCRIPTION: Demonstrates using double quotes to enclose a string containing a colon followed by a space. Similar to single quotes, this preserves the literal value but additionally allows for escape sequences within the string.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nfoo: \"somebody said I should put a colon here: so I did\"\n\nwindows_drive: \"c:\"\n```\n\n----------------------------------------\n\nTITLE: Rebooting Servers as Specific User with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Illustrates executing the `/sbin/reboot` command on 'atlanta' hosts as a specific remote user ('username') by using the `-u` flag. It also specifies 10 parallel forks (`-f 10`) for potentially faster execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible atlanta -a \"/sbin/reboot\" -f 10 -u username\n```\n\n----------------------------------------\n\nTITLE: Re-running Ansible Integration Tests After Fix in Bash\nDESCRIPTION: Re-runs the Ansible integration tests for the relevant subdirectory (`name_of_test_subdirectory`) using `ansible-test integration` with Docker and verbose output. This step verifies that the applied code changes have fixed the bug and the tests now pass successfully.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test integration name_of_test_subdirectory --docker -v\n```\n\n----------------------------------------\n\nTITLE: Creating Setup Target Directory Structure (Bash)\nDESCRIPTION: Creates the necessary directory structure for a setup target named `setup_abstract_service` within the integration tests directory. This structure follows Ansible's convention for organizing tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p tests/integration/targets/setup_abstract_service/tasks\n```\n\n----------------------------------------\n\nTITLE: Assigning Global Metaclass for New-Style Classes in Python\nDESCRIPTION: This snippet demonstrates assigning `type` to the special `__metaclass__` variable at the module level. This ensures that all classes defined in the file will inherit from `object` implicitly, making them new-style classes, which is the standard behavior in Python 3. This is typically placed after `from __future__ import` statements for Python 2 compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/metaclass-boilerplate.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n__metaclass__ = type\n```\n\n----------------------------------------\n\nTITLE: Specifying Formatter and Utility Python Package Dependencies - INI\nDESCRIPTION: This snippet lists Python package requirements for formatter-related testing. Each line pins the exact version for a package such as black, click, isort, and their dependencies. Comments indicate the origin of each dependency (direct, transitive, or via specific platforms like Windows). This file is intended for consumption by pip, ensuring reproducible installations in CI or developer environments. No input parameters are accepted, and all output is through installed Python modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/formatters.txt#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\nblack==25.1.0\n    # via -r tests/formatters.in\nclick==8.1.8\n    # via black\ncolorama==0.4.6 ; sys_platform == 'win32'\n    # via click\nisort==6.0.1\n    # via -r tests/formatters.in\nmypy-extensions==1.0.0\n    # via black\npackaging==25.0\n    # via black\npathspec==0.12.1\n    # via black\nplatformdirs==4.3.7\n    # via black\n```\n\n----------------------------------------\n\nTITLE: Setting Ancestor Version in Changelog (Stable Branch) - YAML\nDESCRIPTION: YAML for 'changelogs/changelog.yml' in the stable branch, reflecting the previous major release as the ancestor (e.g., 'X-1.0.0'). Ensures changelog history chains correctly. Inputs: ancestor version; Outputs: changelog with updated ancestry.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nancestor: X-1.0.0\\nreleases: {}\n```\n\n----------------------------------------\n\nTITLE: Updating Conditionals by Defining Boolean Variables in YAML\nDESCRIPTION: Shows an alternative method for updating playbooks by defining variables directly as boolean types (e.g., `teardown: false`) instead of strings. This avoids ambiguity in conditional statements (`when: teardown`) without needing the `bool` filter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  teardown: false\n\ntasks:\n  - include_tasks: teardown.yml\n    when: teardown\n\n  - include_tasks: provision.yml\n    when: not teardown\n```\n\n----------------------------------------\n\nTITLE: Removing a Travis Integration from Ansible Galaxy - Bash\nDESCRIPTION: Removes a specified Travis CI integration from Galaxy using the 'ansible-galaxy role setup --remove ID' command. The integration ID, obtainable from a previous listing, is required. This disables automatic notifications and Galaxy imports tied to that CI integration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role setup --remove ID\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to the Collection Root - Shell\nDESCRIPTION: Explains how to navigate to the root directory of the cloned Ansible collection in preparation for running tests. Assumes the directory exists as created by previous git clone command.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd ~/dev/ansible_collections/community/windows\n```\n\n----------------------------------------\n\nTITLE: Specifying Execution Environment Dependencies - YAML\nDESCRIPTION: This snippet references the required 'execution-environment.yml' YAML file, which must be created to define the dependencies and configuration for the Ansible Execution Environment. Dependencies typically include Python packages, Ansible collections, and system requirements. Users should ensure that required collections and Python dependencies (e.g., 'community.postgresql', 'psycopg2-binary') are specified either directly or via a 'requirements.txt' file within the collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/build_execution_environment.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# Refer to yaml/execution-environment.yml in documentation context\n```\n\n----------------------------------------\n\nTITLE: Importing and Instantiating Ansible Display Singleton in Python\nDESCRIPTION: This Python snippet demonstrates the correct way to import the `Display` class from `ansible.utils.display` and instantiate it, as recommended starting from Ansible 2.8. `Display` is now treated as a singleton, making direct import from `__main__` obsolete.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-main-display.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.utils.display import Display\ndisplay = Display()\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Typing Lockfile using Nox (Bash)\nDESCRIPTION: Executes the `nox` command to run the `pip-compile` session without upgrading packages. This is used to regenerate the typing lockfile after removing the tagger dependency from the input file (`tests/typing.in`), ensuring the lockfile is consistent.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnox -s pip-compile -- --no-upgrade\n```\n\n----------------------------------------\n\nTITLE: Setting Hostname and Domain with IOS-XR System Module (YAML)\nDESCRIPTION: Task for configuring the hostname and domain-related parameters on a Cisco IOS-XR device using the iosxr_system Ansible module. The parameters include hostname, domain_name, and an array domain_search. Executed over a NETCONF connection, this task assumes all device and control node prerequisites are met, delivering changes directly to the remote system.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_iosxr.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Configure hostname and domain-name\\n  cisco.iosxr.iosxr_system:\\n    hostname: iosxr01\\n    domain_name: test.example.com\\n    domain_search:\\n      - ansible.com\\n      - redhat.com\\n      - cisco.com\\n\n```\n\n----------------------------------------\n\nTITLE: Setting SSH Password Mechanism via Environment Variable (Shell)\nDESCRIPTION: Illustrates how to set the SSH password mechanism for Ansible connections using a shell environment variable. Exporting `ANSIBLE_SSH_PASSWORD_MECHANISM` with the value `sshpass` forces the SSH connection plugin to use the `sshpass` program for password authentication.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_SSH_PASSWORD_MECHANISM=sshpass\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in Ansible Test Plugins using Python\nDESCRIPTION: This Python code snippet shows the recommended way to handle exceptions, specifically `jinja2.exceptions.UndefinedError`, within Ansible test plugins. It demonstrates catching the Jinja2 exception and re-raising it as an `AnsibleUndefinedVariable` to ensure proper handling of undefined variables by the Ansible engine. Other exceptions are caught and re-raised as `AnsibleFilterError`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n   try:\n       cause_an_exception(with_undefined_variable)\n   except jinja2.exceptions.UndefinedError as e:\n       raise AnsibleUndefinedVariable(\"Something happened, this was the original exception: %s\" % to_native(e))\n   except Exception as e:\n       raise AnsibleFilterError(\"Something happened, this was the original exception: %s\" % to_native(e))\n```\n\n----------------------------------------\n\nTITLE: Setting Fact Cache Plugin via Environment Variable in Shell\nDESCRIPTION: Configures the fact cache plugin for Ansible by setting the `ANSIBLE_CACHE_PLUGIN` environment variable in a shell environment. This example specifically sets the cache plugin to `jsonfile`. Using an environment variable overrides settings defined in the `ansible.cfg` file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_CACHE_PLUGIN=jsonfile\n```\n\n----------------------------------------\n\nTITLE: Resetting Changelog For New Release - YAML\nDESCRIPTION: Sample YAML content for 'changelogs/changelog.yml' to mark the start of a new release cycle. Sets the ancestor version to 'X.0.0' and initializes the releases mapping. Inputs: ancestor version; Outputs: changelog reflecting new baseline. No special dependencies beyond YAML support in the changelog tool.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nancestor: X.0.0\\nreleases: {}\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Collection Requiring All Signatures but Ignoring NO_PUBKEY Error\nDESCRIPTION: These bash commands configure GPG verification for `ansible-galaxy`. They set the keyring path via `ANSIBLE_GALAXY_GPG_KEYRING` and require all provided signatures (from server and `--signature` options) to be valid using `ANSIBLE_GALAXY_REQUIRED_VALID_SIGNATURE_COUNT=all`. The command then installs `my_namespace.my_collection`, instructing `ansible-galaxy` to ignore signature verification failures caused specifically by a missing public key (`NO_PUBKEY` GPG status code) using the `--ignore-signature-status-code` option.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nexport ANSIBLE_GALAXY_GPG_KEYRING=~/.ansible/pubring.kbx\nexport ANSIBLE_GALAXY_REQUIRED_VALID_SIGNATURE_COUNT=all\nansible-galaxy collection install my_namespace.my_collection --ignore-signature-status-code NO_PUBKEY\n```\n\n----------------------------------------\n\nTITLE: Formatting Ansible Changelog Bugfixes in YAML\nDESCRIPTION: Illustrates the YAML structure for documenting bugfixes under the 'bugfixes' key in Ansible changelog fragments. It provides an example fixing an issue with 'ansible_play_batch' related to unreachable hosts, showing the convention of describing the past problem and the present fix, along with a link to the relevant GitHub issue.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nbugfixes:\n  - ansible_play_batch - variable included unreachable hosts. Fix now saves unreachable hosts between plays by adding them to the PlayIterator's ``_play._removed_hosts`` (https://github.com/ansible/ansible/issues/66945).\n```\n\n----------------------------------------\n\nTITLE: Setting Remote Environment and Running Raw Commands with ansible.builtin.raw (YAML)\nDESCRIPTION: This YAML block leverages ansible.builtin.raw to export multiple environment variables that enable automatic encoding conversion and tagging on the remote z/OS UNIX host. It subsequently runs a simple echo command. All exports and commands run in one raw statement. This method bypasses Ansible's environmental setup, so it's crucial to manually set environment variables. Suitable for scenarios where modules cannot be used, but requires familiarity with variable semantics on z/OS UNIX.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nansible.builtin.raw: |\\n    export _BPXK_AUTOCVT: \"ON\" ;\\n    export _CEE_RUNOPTS: \"FILETAG(AUTOCVT,AUTOTAG) POSIX(ON)\" ;\\n    export _TAG_REDIR_ERR: \"txt\" ;\\n    export _TAG_REDIR_IN: \"txt\" ;\\n    export _TAG_REDIR_OUT: \"txt\" ;\\n    echo \"hello world!\"\n```\n\n----------------------------------------\n\nTITLE: Host Template File for Ansible MOTD - Text - Jinja2 Template\nDESCRIPTION: This snippet illustrates a Jinja2 template file for generating a dynamic message of the day (MOTD) in Ansible, showing how inventory-collected variables are rendered. The file is meant for use with the Ansible 'template' module, taking in variables 'a', 'b', and 'c' from dynamic inventory sources (like Cobbler) and outputting a personalized MOTD. The template should be placed at the specified inventory path and referenced in a playbook or ad-hoc 'template' task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n# file: /srv/motd.j2\nWelcome, I am templated with a value of a={{ a }}, b={{ b }}, and c={{ c }}\n```\n\n----------------------------------------\n\nTITLE: Using Executable Script for Password with Specific Vault ID - CLI Usage (Bash)\nDESCRIPTION: Uses an executable script to supply the password for a specific vault ID ('dev') when running a playbook with encrypted content. Requires the script ('my-vault-password-client.py') to be present and executable. Input: CLI command; Output: Playbook uses password output by the script for the specified vault ID.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id dev@my-vault-password-client.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Group Variables for ERIC_ECCLI CLI Connection (YAML)\nDESCRIPTION: This YAML snippet shows an example configuration within `group_vars/eric_eccli.yml` for connecting to Extreme ERIC_ECCLI devices using Ansible. It sets the connection type to `network_cli`, specifies the network OS, defines user credentials (using Ansible Vault for the password), and includes optional SSH arguments for connecting through a bastion host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eric_eccli.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n   ansible_connection: ansible.netcommon.network_cli\n   ansible_network_os: community.network.eric_eccli\n   ansible_user: myuser\n   ansible_password: !vault...\n   ansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n\n```\n\n----------------------------------------\n\nTITLE: Running pip-compile to Generate Dependency Lock File - Bash\nDESCRIPTION: This snippet demonstrates the uv pip compile command used to generate a requirements lock file ('tests/formatters.txt') from an input file ('tests/formatters.in'). It ensures a universal output suitable for multiple Python environments. Requires uv and pip tools to be installed, and the input file must already list the base requirements. Outputs a reproducible requirements file used in further testing or deployment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/formatters.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n#    uv pip compile --universal --output-file tests/formatters.txt tests/formatters.in\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbooks with Limit and Tag Options - Shell Commands\nDESCRIPTION: Shows how to invoke various Ansible playbooks using the 'ansible-playbook' CLI, utilizing features like inventory selection, tags, and limits for granular deployment control. These examples are intended for system administrators to apply changes to selective environments or roles interactively. Shell commands expect a properly configured Ansible project as described in the directory layout above.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook site.yml --limit webservers\\nansible-playbook webservers.yml\n```\n\n----------------------------------------\n\nTITLE: Defining Ansible Core Support Matrix Table in reStructuredText\nDESCRIPTION: This reStructuredText snippet uses the `list-table` directive to create a structured table outlining the support lifecycle, end-of-life dates, and Python/PowerShell compatibility for various `ansible-core` versions. It includes header rows and lists data for each version, linking version numbers to their respective changelogs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/release_and_maintenance.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. list-table::\n   :header-rows: 1\n\n   * - Version\n     - Support\n     - End Of Life\n     - Control Node Python\n     - Target Python / PowerShell\n   * - `2.19`_\n     - | GA: 16 June 2025\n       | Critical: 03 Nov 2025\n       | Security: 18 May 2026\n     - Nov 2027\n     - | Python 3.11 - 3.13\n     - | Python 3.8 - 3.13\n       | PowerShell 5.1\n   * - `2.18`_\n     - | GA: 04 Nov 2024\n       | Critical: 19 May 2025\n       | Security: 03 Nov 2025\n     - May 2026\n     - | Python 3.11 - 3.13\n     - | Python 3.8 - 3.13\n       | PowerShell 5.1\n   * - `2.17`_\n     - | GA: 20 May 2024\n       | Critical: 04 Nov 2024\n       | Security: 19 May 2025\n     - Nov 2025\n     - | Python 3.10 - 3.12\n     - | Python 3.7 - 3.12\n       | PowerShell 5.1\n   * - `2.16`_\n     - | GA: 06 Nov 2023\n       | Critical: 20 May 2024\n       | Security: Nov 2024\n     - May 2025\n     - | Python 3.10 - 3.12\n     - | Python 2.7\n       | Python 3.6 - 3.12\n       | Powershell 5.1\n   * - `2.15`_\n     - | GA: 22 May 2023\n       | Critical: 06 Nov 2023\n       | Security: 20 May 2024\n     - | **EOL**\n       | Nov 2024\n     - | Python 3.9 - 3.11\n     - | Python 2.7\n       | Python 3.5 - 3.11\n       | PowerShell 3 - 5.1\n   * - `2.14`_\n     - | GA: 07 Nov 2022\n       | Critical: 22 May 2023\n       | Security: 06 Nov 2023\n     - | **EOL**\n       | 20 May 2024\n     - | Python 3.9 - 3.11\n     - | Python 2.7\n       | Python 3.5 - 3.11\n       | PowerShell 3 - 5.1\n   * - `2.13`_\n     - | GA: 23 May 2022\n       | Critical: 07 Nov 2022\n       | Security: 22 May 2023\n     - | **EOL**\n       | 06 Nov 2023\n     - | Python 3.8 - 3.10\n     - | Python 2.7\n       | Python 3.5 - 3.10\n       | PowerShell 3 - 5.1\n   * - `2.12`_\n     - | GA: 08 Nov 2021\n       | Critical: 23 May 2022\n       | Security: 07 Nov 2022\n     - | **EOL**\n       | 22 May 2023\n     - | Python 3.8 - 3.10\n     - | Python 2.6 - 2.7\n       | Python 3.5 - 3.10\n       | PowerShell 3 - 5.1\n   * - `2.11`_\n     - | GA: 26 Apr 2021\n       | Critical: 08 Nov 2021\n       | Security: 23 May 2022\n     - | **EOL**\n       | 07 Nov 2022\n     - | Python 2.7\n       | Python 3.5 - 3.9\n     - | Python 2.6 - 2.7\n       | Python 3.5 - 3.9\n       | PowerShell 3 - 5.1\n   * - `2.10`_\n     - | GA: 13 Aug 2020\n       | Critical: 26 Apr 2021\n       | Security: 08 Nov 2021\n     - | **EOL**\n       | 23 May 2022\n     - | Python 2.7\n       | Python 3.5 - 3.9\n     - | Python 2.6 - 2.7\n       | Python 3.5 - 3.9\n       | PowerShell 3 - 5.1\n   * - `2.9`_\n     - | GA: 31 Oct 2019\n       | Critical: 13 Aug 2020\n       | Security: 26 Apr 2021\n     - | **EOL**\n       | 23 May 2022\n     - | Python 2.7\n       | Python 3.5 - 3.8\n     - | Python 2.6 - 2.7\n       | Python 3.5 - 3.8\n       | PowerShell 3 - 5.1\n```\n\n----------------------------------------\n\nTITLE: Building All Module Docs and RST Files with Make (Bash)\nDESCRIPTION: This command uses `make` to build all module documentation for the Ansible community package along with all the reStructuredText (rST) files. It's the primary command for a full documentation build.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmake webdocs\n```\n\n----------------------------------------\n\nTITLE: Running Arbitrary Shell with Inventory Variables - Bash - Ansible Shell Module\nDESCRIPTION: This snippet shows an Ansible ad-hoc command invoking the shell module with inventory-derived variables, demonstrating that template variables can be inserted into shell commands at execution time. The example uses the '{{ a }}' variable value for the webserver group, relying on correct dynamic inventory integration. Inputs are the inventory group and a shell command; output is command execution per host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nansible webserver -m ansible.builtin.shell -a \"echo {{ a }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Unscoped Ansible Changelog Entry Format in YAML\nDESCRIPTION: Outlines the YAML format for unscoped changelog entries in Ansible fragments, typically used for collection-wide changes or items not tied to a specific module/plugin. The description should start with an uppercase letter, end with a period, and include a parenthesized link to the issue or PR.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- Description starting with an uppercase letter and ending with a dot at the very end. Multiple sentences are allowed (https://github.com/reference/to/an/issue or, if there is no issue, reference to a pull request itself).\n```\n\n----------------------------------------\n\nTITLE: Verifying Configuration on Cisco IOS XE Router (Bash)\nDESCRIPTION: Shows the command executed on the Cisco IOS XE router 'rtr1' to verify the configuration applied by the Ansible playbook. The `show run | include name` command filters the running configuration to display lines containing 'name', confirming that the hostname is set to 'rtr1' and the IP name servers are configured as '8.8.8.8 8.8.4.4'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrtr1#sh run | i name\nhostname rtr1\nip name-server 8.8.8.8 8.8.4.4\n```\n\n----------------------------------------\n\nTITLE: Specifying File-Based Inventory Source in Ansible (Bash)\nDESCRIPTION: This snippet illustrates how to specify a file containing inventory information as the source using the `-i` command-line option in Ansible. Like inline sources passed with `-i`, this is treated as 'direct assignment' and shares the same precedence.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n-i /path/to/inventory_source\n```\n\n----------------------------------------\n\nTITLE: Example Output for Ansible Conditional Debugging (Ansible Output)\nDESCRIPTION: This block shows sample output from executing the Ansible debug tasks designed to check variable types in conditionals. It illustrates how the `debug` module displays the variable's value (`\"127\"`, indicating a string) and the results of the conditional tests. Comparing the string value `\"127\"` to the string `\"127\"` evaluates to `false` (likely due to subtle differences or how Ansible handles the debug output rendering itself in this specific example, though typically string-to-string comparison would be true if identical), while comparing it to the integer `127` evaluates to `true` because Ansible often performs implicit type coercion during conditional evaluation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_33\n\nLANGUAGE: ansible-output\nCODE:\n```\nTASK [check value of return code] *********************************************************************************\nok: [foo-1] => {\n    \"bar_status.rc\": \"127\"\n}\n\nTASK [check test for rc value as string] **************************************************************************\nok: [foo-1] => {\n    \"bar_status.rc == \\\"127\\\"\": false\n}\n\nTASK [check test for rc value as integer] *************************************************************************\nok: [foo-1] => {\n    \"bar_status.rc == 127\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Example ansible-test Success Output (Shell)\nDESCRIPTION: Shows sample output from `ansible-test` indicating that the assertion task ('Check the module returns what we expect') completed successfully (`ok`) on the test host, confirming that all specified conditions passed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nTASK [postgresql_info : Check the module returns what we expect] ***************\nok: [testhost] => {\n  \"changed\": false,\n  \"msg\": \"All assertions passed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Standalone Role Contents into Collection Structure in Bash\nDESCRIPTION: This snippet copies all contents from the standalone 'my-standalone-role.webapp' role into a new 'webapp' role inside the 'acme.webserver' collection. Uses bash commands 'mkdir' and 'cp' to create the destination directory and recursively copy files. Prerequisites include existing source and destination directories. Used to migrate role contents as part of collection conversion.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir acme/webserver/roles/webapp\n$ cp my-standalone-role.webapp/* acme/webserver/roles/webapp/\n```\n\n----------------------------------------\n\nTITLE: Setting up Ansible Development Environment using env-setup (Shell)\nDESCRIPTION: This shell-session snippet demonstrates how to initialize the Ansible development environment by sourcing the env-setup script found in the hacking directory. The script sets environment variables such as PYTHONPATH to utilize Ansible directly from source without full installation. Required: A cloned Ansible repository and a POSIX-like shell. Input is the script path; output configures the current shell for development use.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsource hacking/env-setup\n```\n\n----------------------------------------\n\nTITLE: Replacing 'master' with 'primary' in mysql_replication Messages (Future) (Ansible)\nDESCRIPTION: States that the word `master` in messages returned by the `mysql_replication` module (`community.mysql`) will be replaced with `primary` in `community.mysql` 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_44\n\nLANGUAGE: ansible\nCODE:\n```\nmaster\n```\n\nLANGUAGE: ansible\nCODE:\n```\nprimary\n```\n\n----------------------------------------\n\nTITLE: Cherry-Picking Commits for Ansible Backporting using Shell\nDESCRIPTION: Demonstrates the `git cherry-pick` command used in the Ansible backporting process. This command applies a specific commit (identified by its SHA from the 'devel' branch) onto the current local backport branch. The `-x` option is used to append a line to the commit message indicating the original commit it was cherry-picked from.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n   git cherry-pick -x [SHA_FROM_DEVEL]\n```\n\n----------------------------------------\n\nTITLE: Running the Backport Reference Adder Script using Shell\nDESCRIPTION: These shell commands demonstrate how to run backport_of_line_adder.py to add a reference from a backport PR to its original pull request. The script can deduce the original PR automatically if 'auto' is passed as the second argument. It is invoked with two arguments: the backport PR number and either the original PR number or 'auto'. Users are prompted to confirm changes before they are made. Requires Python, PyGithub, and a GITHUB_TOKEN environment variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/backport/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./backport_of_line_adder.py <backport> <original PR>\n```\n\nLANGUAGE: shell\nCODE:\n```\n./backport_of_line_adder.py 12345 auto\n```\n\n----------------------------------------\n\nTITLE: Formatting Ansible Arguments for Module Debugging - JSON\nDESCRIPTION: This JSON snippet illustrates the format of arguments expected by a Windows module during debugging, typically saved as 'args.json.' It features an 'ANSIBLE_MODULE_ARGS' object containing parameters such as check mode, diff, file path, and state. The JSON must be correctly structured and placed where the debugging PowerShell script can read it. Inputs are the parameter key-value pairs used by the module; expected outputs are module behaviors corresponding to these values during test runs. Strict JSON formatting is required for import.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\\n    \"ANSIBLE_MODULE_ARGS\": {\\n        \"_ansible_check_mode\": false,\\n        \"_ansible_diff\": false,\\n        \"path\": \"C:\\\\temp\",\\n        \"state\": \"present\"\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Variables to Groups in Inventory - yaml\nDESCRIPTION: This snippet shows how to assign variables to all hosts within a group in YAML inventory format, centralizing settings (e.g., SSH user) for the entire group. Recommended when multiple hosts share common settings, which ensures consistency. Requires the correct placement and indentation in the YAML inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nwebservers:\\n  vars:\\n    ansible_user: deploy\n```\n\n----------------------------------------\n\nTITLE: Formatting Unscoped Ansible Changelog Fragment Entries (YAML)\nDESCRIPTION: Defines the standard YAML structure for an unscoped changelog entry, used for changes affecting a whole collection or not easily tied to a specific scope. The entry starts directly with the description (beginning with an uppercase letter and ending with a period) followed by the reference link.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- Description starting with an uppercase letter and ending with a dot at the very end. Multiple sentences are allowed (https://github.com/reference/to/an/issue or, if there is no issue, reference to a pull request itself).\n```\n\n----------------------------------------\n\nTITLE: Listing Specific Ansible Collection Instances (Shell)\nDESCRIPTION: This command lists all installed instances of a specific Ansible collection, identified by its fully qualified collection name (FQCN). In this example, it lists all found versions and locations for the `fortinet.fortios` collection across the configured search paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_listing.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n> ansible-galaxy collection list fortinet.fortios\n\n# /home/astark/.ansible/collections/ansible_collections\nCollection       Version\n---------------- -------\nfortinet.fortios 1.0.1\n\n# /usr/share/ansible/collections/ansible_collections\nCollection       Version\n---------------- -------\nfortinet.fortios 1.0.6\n```\n\n----------------------------------------\n\nTITLE: Generated Import for Common Module Boilerplate (Ansiballz)\nDESCRIPTION: This Python import statement is generated by the Ansiballz framework when it encounters the `#<<INCLUDE_ANSIBLE_MODULE_COMMON>>` placeholder. It ensures the necessary basic module utilities are included in the module package and imported.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import *\n```\n\n----------------------------------------\n\nTITLE: Deprecated Constant `_CHECK_ARGUMENT_TYPES_DISPATCHER` in Python\nDESCRIPTION: The internal constant `ansible.module_utils.basic._CHECK_ARGUMENT_TYPES_DISPATCHER` is deprecated. Custom modules or plugins using this should switch to using `ansible.module_utils.common.parameters.DEFAULT_TYPE_VALIDATORS` instead for type validation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# Deprecated:\nfrom ansible.module_utils.basic import _CHECK_ARGUMENT_TYPES_DISPATCHER\n\n# Recommended replacement:\nfrom ansible.module_utils.common.parameters import DEFAULT_TYPE_VALIDATORS\n```\n\n----------------------------------------\n\nTITLE: Documenting and Indexing Ansible Core Porting Guides - reStructuredText\nDESCRIPTION: This snippet builds the table of contents for the Ansible Core porting guides using the Sphinx '.. toctree::' directive and the 'maxdepth' parameter to control navigation hierarchy. Dependencies include Sphinx or compatible documentation toolchains capable of parsing reStructuredText. The guide filenames listed under the directive correspond to separate documentation sub-pages that provide upgrade information for each Ansible Core version. Inputs are static documentation files, with the output being an organized site navigation structure; there are no code-based constraints, but all files must exist for correct rendering.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/core_porting_guides.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 1\\n   :glob:\\n\\n   porting_guide_core_2.19\\n   porting_guide_core_2.18\\n   porting_guide_core_2.17\\n   porting_guide_core_2.16\\n   porting_guide_core_2.15\\n   porting_guide_core_2.14\\n   porting_guide_core_2.13\\n   porting_guide_core_2.12\\n   porting_guide_core_2.11\\n   porting_guide_base_2.10\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Travis CI Integration with Ansible Galaxy - Bash\nDESCRIPTION: Creates a Travis CI integration for a specified GitHub/Ansible role using 'ansible-galaxy role setup'. Requires Galaxy API token, Travis account, and the Travis token. Parameters include Travis, GitHub user, repository, and Travis token. This enables automatic imports and notifications between Travis and Galaxy.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role setup travis github_user github_repo xxx-travis-token-xxx\n```\n\n----------------------------------------\n\nTITLE: Generating Changelogs with antsibull-changelog - Bash\nDESCRIPTION: Runs the antsibull-changelog command-line tool with the '--cummulative-release' flag to generate the changelog for a cumulative release in the stable branch. Inputs: changelog metadata and fragments; Outputs: updated CHANGELOG.rst. Requires Python and the antsibull-changelog package.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nantsibull-changelog release --cummulative-release\n```\n\n----------------------------------------\n\nTITLE: Removed Private Methods from AnsibleModule in Python\nDESCRIPTION: Several private methods previously used for argument specification validation within `ansible.module_utils.basic.AnsibleModule` have been removed due to the shift to `ArgumentSpecValidator`. Custom modules relying on these internal methods must be updated to use public functions from `ansible.module_utils.common.validation` or `ArgumentSpecValidator.validate()`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Example of removed methods (not exhaustive):\n# module._check_argument_types()\n# module._check_mutually_exclusive()\n# module._check_required_if()\n# module._check_type_int()\n\n# Replace with (examples):\nfrom ansible.module_utils.common.validation import check_mutually_exclusive, check_required_if\nfrom ansible.module_utils.common.arg_spec import ArgumentSpecValidator\n\n# validator = ArgumentSpecValidator(...)\n# validated_params = validator.validate(module.params)\n# check_mutually_exclusive(spec['mutually_exclusive'], validated_params)\n```\n\n----------------------------------------\n\nTITLE: Displaying Simplified Role Directory Structure (Bash)\nDESCRIPTION: Uses the `tree` command to show a simplified directory structure for the 'system_demo' role, intended for this specific demonstration. It only includes the essential `tasks` and `vars` directories, each containing a `main.yml` file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible system_demo]$ tree\n.\n├── tasks\n│   └── main.yml\n└── vars\n    └── main.yml\n```\n\n----------------------------------------\n\nTITLE: Deprecating Return Values in mysql_replication (Ansible)\nDESCRIPTION: Issues a deprecation warning for the `mysql_replication` module (`community.mysql`). The return values `Is_Slave` and `Is_Master` will be replaced with `Is_Replica` and `Is_Primary` respectively in `community.mysql` 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_38\n\nLANGUAGE: ansible\nCODE:\n```\nmysql_replication\n```\n\nLANGUAGE: ansible\nCODE:\n```\nIs_Slave\n```\n\nLANGUAGE: ansible\nCODE:\n```\nIs_Master\n```\n\n----------------------------------------\n\nTITLE: Configuring Persistent Connection Idle Timeout in ansible.cfg - INI\nDESCRIPTION: Adds or modifies the '[persistent_connection]' section in ansible.cfg, explicitly setting 'connect_timeout = 60' to persistently increase the idle timeout value in future Ansible runs. To be included in the configuration file for site-wide default behavior; no additional dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_25\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\nconnect_timeout = 60\n```\n\n----------------------------------------\n\nTITLE: Composing Variable Values Using YAML Anchors and Aliases in Ansible (YAML)\nDESCRIPTION: Shows how to use a YAML anchor (`&my_version`) to define a value (version number) and then reuse it with an alias (`*my_version`) within another variable definition (a list forming a custom application name) in Ansible `vars`. This technique promotes maintainability by defining the version in a single place and reusing it.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_advanced_syntax.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n  vars:\n    webapp:\n        version: &my_version 1.0\n        custom_name:\n            - \"ToDo_App\"\n            - *my_version\n```\n\n----------------------------------------\n\nTITLE: Discouraged Use of ConfigureRemotingForAnsible.ps1 for Ansible WinRM Setup (PowerShell)\nDESCRIPTION: A PowerShell script historically used to configure WinRM for Ansible connections. It checks and modifies WinRM settings, enables Basic authentication (insecure over HTTP), creates self-signed certificates, and opens firewall rules broadly. Its use is strongly discouraged due to security risks and the availability of better, more secure defaults supported by modern Ansible and Python WinRM libraries. Users needing specific configurations (like self-signed certs) should extract only necessary parts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/examples/scripts/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nConfigureRemotingForAnsible.ps1\n```\n\n----------------------------------------\n\nTITLE: Installing Multiple Ansible Collections from a Requirements File (Bash)\nDESCRIPTION: Uses the `ansible-galaxy collection install` command with the `-r` flag to install multiple collections listed in a specified `requirements.yml` file. This file must exist and contain a list of collections to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Conditionally Shutting Down Systems Using List for AND Logic (YAML)\nDESCRIPTION: This Ansible task runs `/sbin/shutdown -t now` via `ansible.builtin.command`. The `when` clause uses a list of conditions. All conditions in the list must be true (logical AND) for the task to run. It targets hosts where `ansible_facts['distribution']` is \"CentOS\" AND `ansible_facts['distribution_major_version']` is \"6\".\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Shut down CentOS 6 systems\n    ansible.builtin.command: /sbin/shutdown -t now\n    when:\n      - ansible_facts['distribution'] == \"CentOS\"\n      - ansible_facts['distribution_major_version'] == \"6\"\n```\n\n----------------------------------------\n\nTITLE: Verifying Specific Collection Version - ansible-galaxy CLI - Bash\nDESCRIPTION: Specifies how to verify a particular version of a collection using the namespace.collection_name:version format. Ensures the integrity of the installed version against the corresponding version from the Galaxy server. This is necessary when non-latest or pre-release versions are in use.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection:1.0.0\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in Ansible Filter Plugins using Python\nDESCRIPTION: Shows the standard pattern for handling exceptions within Ansible filter plugins. It specifically demonstrates catching `jinja2.exceptions.UndefinedError` and re-raising it as `AnsibleUndefinedVariable`, and catching general `Exception`s to re-raise as `AnsibleFilterError`. This ensures proper error reporting and respects Ansible's lazy evaluation of variables. Requires `jinja2.exceptions`, `ansible.errors.AnsibleUndefinedVariable`, `ansible.errors.AnsibleFilterError`, and `ansible.module_utils.common.text.converters.to_native` (implied for `to_native` usage).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ntry:\n   cause_an_exception(with_undefined_variable)\nexcept jinja2.exceptions.UndefinedError as e:\n   raise AnsibleUndefinedVariable(\"Something happened, this was the original exception: %s\" % to_native(e))\nexcept Exception as e:\n   raise AnsibleFilterError(\"Something happened, this was the original exception: %s\" % to_native(e))\n```\n\n----------------------------------------\n\nTITLE: Batching Hosts with Serial Keyword in Ansible Playbook (YAML)\nDESCRIPTION: This playbook snippet demonstrates using the 'serial' keyword with an integer value (3) to limit the number of hosts that Ansible manages concurrently in each batch. The play contains two tasks, both running the 'hostname' command. Dependencies: standard Ansible install, 'webservers' inventory group. Serial insures only a subset of hosts receives all tasks before moving on.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: test play\\n  hosts: webservers\\n  serial: 3\\n  gather_facts: False\\n\\n  tasks:\\n    - name: first task\\n      command: hostname\\n    - name: second task\\n      command: hostname\n```\n\n----------------------------------------\n\nTITLE: Ensuring Specific Package Version with Ansible Ad Hoc Command (yum) in Bash\nDESCRIPTION: Ensures that a specific version ('acme-1.5') of a package is installed on 'webservers' using the `ansible.builtin.yum` module. The `state=present` combined with the versioned name targets a particular release.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.yum -a \"name=acme-1.5 state=present\"\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Ansible Temporary Directory\nDESCRIPTION: These commands demonstrate how to access the temporary directory created by Ansible on the target host. If debugging on a remote host, first use 'ssh' to connect. Then, use 'cd' to change to the specific temporary directory path identified in the verbose output from the previous Ansible execution step.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/debugging.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ ssh remotehost  # only if not debugging against localhost\n$ cd /home/badger/.ansible/tmp/ansible-tmp-1461434734.35-235318071810595\n```\n\n----------------------------------------\n\nTITLE: Backing Up Device Configurations with Platform Modules - YAML\nDESCRIPTION: This set of tasks performs device configuration backups via Ansible modules for Arista EOS and VyOS by conditionally invoking their respective modules with the backup parameter. The backup files are registered, a backup directory is created, and the resulting backup is copied to a centralized directory. Prerequisites include device connectivity, proper Ansible collections (arista.eos, vyos.vyos), and correct connection setup. Materially, these tasks prevent accidental overwrites, ensure folders exist, and can be extended for other platforms; inputs are device inventory and credentials, outputs are backup files under /tmp/backups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_best_practices_2.5.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup switch (eos)\\n  arista.eos.eos_config:\\n    backup: yes\\n  register: backup_eos_location\\n  when: ansible_network_os == 'arista.eos.eos'\\n\\n- name: backup switch (vyos)\\n  vyos.vyos.vyos_config:\\n    backup: yes\\n  register: backup_vyos_location\\n  when: ansible_network_os == 'vyos.vyos.vyos'\\n\\n- name: Create backup dir\\n  file:\\n    path: \"/tmp/backups/{{ inventory_hostname }}\"\\n    state: directory\\n    recurse: yes\\n\\n- name: Copy backup files into /tmp/backups/ (eos)\\n  copy:\\n    src: \"{{ backup_eos_location.backup_path }}\"\\n    dest: \"/tmp/backups/{{ inventory_hostname }}/{{ inventory_hostname }}.bck\"\\n  when: ansible_network_os == 'arista.eos.eos'\\n\\n- name: Copy backup files into /tmp/backups/ (vyos)\\n  copy:\\n    src: \"{{ backup_vyos_location.backup_path }}\"\\n    dest: \"/tmp/backups/{{ inventory_hostname }}/{{ inventory_hostname }}.bck\"\\n  when: ansible_network_os == 'vyos.vyos.vyos'\n```\n\n----------------------------------------\n\nTITLE: Replacing with_random_choice with Jinja2 Random Filter in Ansible YAML+Jinja\nDESCRIPTION: Updates with_random_choice usage to employ the Jinja2 random filter directly, avoiding the need for a loop altogether. The task selects one random item from 'my_list' and displays it. Requires 'my_list' to be a defined list variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_random_choice\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_random_choice: \"{{ my_list }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_random_choice -> loop (No loop is needed here)\n  ansible.builtin.debug:\n    msg: \"{{ my_list|random }}\"\n  tags: random\n```\n\n----------------------------------------\n\nTITLE: Configuring Task-Level Environment for RBEnv in Ansible (YAML/Jinja)\nDESCRIPTION: This task snippet demonstrates setting specific environment variables (`CONFIGURE_OPTS`, `RBENV_ROOT`, `PATH`) required for installing a Ruby version using `rbenv install`. The `environment` keyword is used at the task level, defining the necessary paths and options by combining defined variables (`rbenv_root`) and facts (`ansible_env.PATH`) via Jinja templating. This ensures the `rbenv` command runs with the correct environment context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_environment.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n---\n- name: Install ruby 2.3.1\n  ansible.builtin.command: rbenv install {{ rbenv_ruby_version }}\n  args:\n    creates: '{{ rbenv_root }}/versions/{{ rbenv_ruby_version }}/bin/ruby'\n  vars:\n    rbenv_root: /usr/local/rbenv\n    rbenv_ruby_version: 2.3.1\n  environment:\n    CONFIGURE_OPTS: '--disable-install-doc'\n    RBENV_ROOT: '{{ rbenv_root }}'\n    PATH: '{{ rbenv_root }}/bin:{{ rbenv_root }}/shims:{{ rbenv_plugins }}/ruby-build/bin:{{ ansible_env.PATH }}'\n```\n\n----------------------------------------\n\nTITLE: Executing an Ansible Playbook with Multiple Options (Bash)\nDESCRIPTION: This command runs the `ansible-playbook` utility to execute `my_playbook.yml`. It specifies an inventory file (`-i`), connection user (`-u`), prompts for the SSH password (`-k`), sets the number of parallel processes (`-f`), defines a task timeout (`-T`), runs only tasks with a specific tag (`-t`), specifies a path for local modules (`-M`), enables privilege escalation (`-b`), and prompts for the become password (`-K`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -i /path/to/my_inventory_file -u my_connection_user -k -f 3 -T 30 -t my_tag -M /path/to/my_modules -b -K my_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Reconfiguring Infrastructure and Ad Hoc Commands - Ansible Shell Usage\nDESCRIPTION: Provides concrete shell command examples for reconfiguring entire environments, limiting runs by tags, groups, or host slices, and running ad hoc commands via the 'ansible' CLI. Useful for administrators to manage or diagnose infrastructure quickly. Prerequisites include proper inventory files and directory structure as described previously.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook -i production site.yml\\nansible-playbook -i production site.yml --tags ntp\\nansible-playbook -i production webservers.yml\\nansible-playbook -i production webservers.yml --limit boston\\nansible-playbook -i production webservers.yml --limit boston[0:9]\\nansible-playbook -i production webservers.yml --limit boston[10:19]\\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nansible boston -i production -m ping\\nansible boston -i production -m command -a '/sbin/reboot'\\n\n```\n\nLANGUAGE: shell\nCODE:\n```\n# confirm what task names would be run if I ran this command and said \\\"just ntp tasks\\\"\\nansible-playbook -i production webservers.yml --tags ntp --list-tasks\\n\\n# confirm what hostnames might be communicated with if I said \\\"limit to boston\\\"\\nansible-playbook -i production webservers.yml --limit boston --list-hosts\n```\n\n----------------------------------------\n\nTITLE: Conditional Shell Command Execution Based on Variable Falsiness\nDESCRIPTION: This Ansible task uses the `ansible.builtin.shell` module to execute a command. The `when: not epic` condition ensures the task only runs if the variable 'epic' is defined and evaluates to false.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run the command if \"epic\" is false\n  ansible.builtin.shell: echo \"This certainly isn't epic!\"\n  when: not epic\n```\n\n----------------------------------------\n\nTITLE: Displaying Debug Messages Based on Task Result - Ansible Playbook YAML\nDESCRIPTION: This snippet demonstrates how to display debug output in an Ansible playbook depending on the status of a previous task. The first condition checks if the 'result' variable indicates success using the 'succeeded' test, while the second prints a debug message only if the return code is not zero (indicating failure). Dependencies include Ansible version 2.3 or newer and access to a properly defined 'result' variable from a prior task. Inputs are task execution results, and outputs are console debug prints governed by conditional logic executed during playbook runs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.4.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n  when: result|succeeded\n\n- debug:\n    msg: 'This is always printed'\n  when: result.rc != 0\n```\n\n----------------------------------------\n\nTITLE: Defining Group Variables in YAML Inventory - Ansible - YAML\nDESCRIPTION: This YAML-formatted inventory snippet defines a group ('cloud') with hosts and a group-wide variable ('ansible_user'). All hosts under 'cloud' inherit 'admin' as the SSH user. This setup is applicable to Ansible's YAML inventory format and requires Ansible 2.4+ for full functionality. It simplifies variable management for groups of nodes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ncloud:\\n  hosts:\\n    cloud1: my_backup.cloud.com\\n    cloud2: my_backup2.cloud.com\\n  vars:\\n    ansible_user: admin\\n\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Includes - Ansible Dynamic Include Tagging (YAML)\nDESCRIPTION: Provides an example for applying tags to dynamic task includes using 'include_tasks'. Tagging the include itself controls the execution of the include and nested tasks that share the tag. Best for task file reuse with selective execution. The snippet uses 'include_tasks', 'tags', and standard task structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# file: roles/common/tasks/main.yml\n\n- name: Dynamic reuse of database tasks\n  include_tasks: db.yml\n  tags: db\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Ansible Fact Value using Jinja\nDESCRIPTION: This Jinja2 template snippet shows how to access a specific piece of information (the model of the 'xvda' device) stored within the nested structure of the `ansible_facts` variable. This syntax is used within Ansible playbooks or templates to dynamically use gathered system information.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_4\n\nLANGUAGE: jinja\nCODE:\n```\n{{ ansible_facts['devices']['xvda']['model'] }}\n```\n\n----------------------------------------\n\nTITLE: Defining Host Variables in Ansible INI Inventory\nDESCRIPTION: Example Ansible inventory file in INI format demonstrating how to define hosts and assign host-specific variables. Variables shown include `ansible_port`, `ansible_user`, `ansible_ssh_private_key_file`, `ansible_python_interpreter`, and `ansible_ruby_interpreter` to customize connection parameters and interpreter paths for individual hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_28\n\nLANGUAGE: text\nCODE:\n```\nsome_host         ansible_port=2222     ansible_user=manager\naws_host          ansible_ssh_private_key_file=/home/example/.ssh/aws.pem\nfreebsd_host      ansible_python_interpreter=/usr/local/bin/python\nruby_module_host  ansible_ruby_interpreter=/usr/bin/ruby.1.9.3\n```\n\n----------------------------------------\n\nTITLE: Configuring Secure Playbook Conditionals - Ansible YAML\nDESCRIPTION: This YAML snippet demonstrates safe and unsafe ways to use module results in conditional assertions within Ansible playbooks. It highlights that referencing module output as an embedded Jinja template in a conditional expression poses security risks, especially when data is untrusted, and illustrates the preferred way to use the variable directly in the expression. No dependencies are required beyond ansible-core, though 2.16.1 or later is assumed. The 'untrusted_result' variable is registered by a shell module, and used both in an insecure (commented out) and secure (active) assertion task; the secure version should be adopted to prevent 'Conditional is marked as unsafe' errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.16.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: task with a module result (always untrusted by Ansible)\\n  shell: echo \"hi mom\"\\n  register: untrusted_result\\n\\n# don't do it this way...\\n# - name: insecure conditional with embedded template consulting untrusted data\\n#   assert:\\n#     that: '\\\"hi mom\\\" is in {{ untrusted_result.stdout }}'\\n\\n- name: securely access untrusted values directly as Jinja variables instead\\n  assert:\\n    that: '\\\"hi mom\\\" is in untrusted_result.stdout'\n```\n\n----------------------------------------\n\nTITLE: Implementing Exponential Backoff Loop in Ansible YAML\nDESCRIPTION: This Ansible task attempts `wait_for_connection` up to 10 times with an exponentially increasing delay (1, 4, 9, ..., 100 seconds). It uses a loop over a list generated by the Jinja2 expression `range(1, 11) | map(\"pow\", 2)`. The `ignore_errors` and `register` combination ensures the loop continues until successful or the last attempt fails.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: try wait_for_connection up to 10 times with exponential delay\n  ansible.builtin.wait_for_connection:\n    delay: '{{ item | int }}'\n    timeout: 1\n  loop: '{{ range(1, 11) | map(\"pow\", 2) }}'\n  loop_control:\n    extended: true\n  ignore_errors: \"{{ not ansible_loop.last }}\"\n  register: result\n  when: result is not defined or result is failed\n```\n\n----------------------------------------\n\nTITLE: Enabling eAPI on Arista EOS via CLI using Ansible YAML Task\nDESCRIPTION: This YAML task demonstrates how to enable the eAPI management interface on an Arista EOS device using the `arista.eos.eos_eapi` Ansible module. It enables both HTTP and HTTPS access. This task typically runs over an initial CLI connection and requires privilege escalation (`become: true` with `become_method: enable`) to modify the switch configuration. It's conditionally executed for devices identified as `arista.eos.eos`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eos.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Enable eAPI\n  arista.eos.eos_eapi:\n    enable_http: yes\n    enable_https: yes\n  become: true\n  become_method: enable\n  when: ansible_network_os == 'arista.eos.eos'\n```\n\n----------------------------------------\n\nTITLE: Specifying Numeric Host Ranges (YAML)\nDESCRIPTION: Demonstrates the YAML syntax for defining numeric host ranges within the `hosts:` section of a group. The ellipsis `...` indicates this is part of a larger file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n# ...\n  webservers:\n    hosts:\n      www[01:50].example.com:\n```\n\n----------------------------------------\n\nTITLE: Importing AnsibleModule for Module Creation - Ansible (Python)\nDESCRIPTION: Shows how to import the AnsibleModule class from the ansible.module_utils.basic package. This class is central for handling module arguments, result serialization, and error management when writing Ansible modules in Python. Dependency: Ansible must be installed, and the importing module should target execution as an Ansible module. No arguments are necessary for the import itself.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/module_utils.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import AnsibleModule\n```\n\n----------------------------------------\n\nTITLE: Backing Up Cisco IOS Configuration using Ansible Task (YAML)\nDESCRIPTION: This YAML snippet demonstrates an Ansible task that uses the `cisco.ios.ios_config` module to back up the current configuration of a Cisco IOS device. The `backup: yes` parameter instructs the module to perform the backup. The result, including the backup location, is registered into the `backup_ios_location` variable. A `when` condition ensures this task only runs on hosts where `ansible_network_os` is set to `cisco.ios.ios`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ios.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (ios)\n  cisco.ios.ios_config:\n    backup: yes\n  register: backup_ios_location\n  when: ansible_network_os == 'cisco.ios.ios'\n```\n\n----------------------------------------\n\nTITLE: Storing VLAN Configuration to Host Vars File - YAML\nDESCRIPTION: This playbook snippet uses the Ansible copy module to save the VLAN configuration as YAML into a 'host_vars' directory on the control node. It expects the ansible_network_resources variable to be available and formatted. This step is part of a workflow for offline modification and change control of device configurations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Store VLAN facts to host_vars\\n  copy:\\n    content: \\\"{{ ansible_network_resources | to_nice_yaml }}\\\"\\n    dest: \\\"{{ playbook_dir }}/host_vars/{{ inventory_hostname }}\\\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Dell OS10 Group Variables for Ansible CLI (YAML)\nDESCRIPTION: Example YAML configuration for `group_vars/dellos10.yml` defining connection parameters for Dell OS10 devices using Ansible's `network_cli`. It specifies the connection type, network OS, user credentials (potentially using Ansible Vault), settings for enabling privilege escalation (`become`), and an optional SSH proxy command for connecting through a bastion host. The `ansible_password` can be omitted if using SSH keys.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_dellos10.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: dellemc.os10.os10\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nansible_become_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Configuring ENOS Network CLI Access in Ansible (YAML)\nDESCRIPTION: Defines group or host variables in YAML for Ansible to connect to ENOS network devices via the ansible.netcommon.network_cli connection and the community.network.enos plugin. This configuration enables privilege escalation (Enable Mode) and supports both password and SSH key authentication. Key variables include the connection type, network OS identifier, credentials, become settings, and, optionally, the SSH bastion host proxy configuration. Inputs are inventory variable values, and this setup is required in your group_vars or host_vars for ENOS device automation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_enos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: community.network.enos\\nansible_user: myuser\\nansible_password: !vault...\\nansible_become: true\\nansible_become_method: enable\\nansible_become_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Contents of an External Variables File - Ansible - YAML\nDESCRIPTION: Gives an example of a variables file referenced from a playbook's vars_files. The file is a simple YAML mapping (dictionary) of keys to values. There are no dependencies beyond being valid YAML syntax. Inputs are key-value pairs; outputs are Ansible variables. Should avoid duplicate keys to prevent ambiguities.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# in the above example, this would be vars/external_vars.yml\nsomevar: somevalue\npassword: magic\n```\n\n----------------------------------------\n\nTITLE: Referencing Collection Content Using FQCN in Ansible Playbooks (YAML)\nDESCRIPTION: Demonstrates how to directly invoke a module from a specific collection using its fully qualified collection name (FQCN) in an Ansible playbook. No additional dependencies are required except the relevant collection installed in the Ansible environment. The snippet showcases how 'hosts' and basic task definitions work with FQCNs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n     - name: Reference a collection content using its FQCN\\n       hosts: all\\n       tasks:\\n\\n         - name: Call a module using FQCN\\n           my_namespace.my_collection.my_module:\\n             option1: value\n```\n\n----------------------------------------\n\nTITLE: Using Generated Collection in a Playbook - Ansible - YAML\nDESCRIPTION: YAML playbook demonstrates the use of a generated Ansible collection to invoke both an interface and a facts module, registering results and debugging outputs. Assumes the collection (cidrblock.my_collection) is installed/available and the inventory contains the host(s). Key parameters: targeted module namespaced with collection name, registered result variable, and output debug.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: myos101\n  gather_facts: False\n  tasks:\n  - cidrblock.my_collection.myos_interfaces:\n    register: result\n  - debug:\n      var: result\n  - cidrblock.my_collection.myos_facts:\n  - debug:\n      var: ansible_network_resources\n```\n\n----------------------------------------\n\nTITLE: Installing Specific ansible-core Version with pip\nDESCRIPTION: Installs a specific version (e.g., 2.12.3) of 'ansible-core' using pip for the current user (--user flag). Ensures a particular version is used.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --user ansible-core==2.12.3\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Collection from Galaxy using Bash\nDESCRIPTION: This command uses `ansible-galaxy` to install the collection named `my_collection` from the namespace `my_namespace` available on the configured Ansible Galaxy server (defaults to `galaxy.ansible.com`). The collection is installed to the default path, typically `~/.ansible/collections` within the `ansible_collections` directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install my_namespace.my_collection\n```\n\n----------------------------------------\n\nTITLE: Testing Path Attributes Using Ansible Tests - YAML\nDESCRIPTION: These snippets demonstrate how to use Ansible's test expressions to check attributes of filesystem paths, such as directory, file, symlink, existence, absoluteness, comparison to another path, and mount status. Dependencies include an Ansible control node and plays referencing proper variables like 'mypath' or 'path2'. Expected input is a variable containing a filesystem path, and the outputs are debug messages about the attribute status. The approach leverages conditional 'when' clauses for flexible flow based on path characteristics.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n- debug:\n    msg: \"path is a directory\"\n  when: mypath is directory\n\n- debug:\n    msg: \"path is a file\"\n  when: mypath is file\n\n- debug:\n    msg: \"path is a symlink\"\n  when: mypath is link\n\n- debug:\n    msg: \"path already exists\"\n  when: mypath is exists\n\n- debug:\n    msg: \"path is {{ (mypath is abs)|ternary('absolute','relative')}}\"\n\n- debug:\n    msg: \"path is the same file as path2\"\n  when: mypath is same_file(path2)\n\n- debug:\n    msg: \"path is a mount\"\n  when: mypath is mount\n\n- debug:\n    msg: \"path is a directory\"\n  when: mypath is directory\n  vars:\n     mypath: /my/path\n\n- debug:\n    msg: \"path is a file\"\n  when: \"'/my/path' is file\"\n```\n\n----------------------------------------\n\nTITLE: Creating Collection Directory - Shell\nDESCRIPTION: Demonstrates how to create the required directory structure for developing or contributing to an Ansible collection. The command ensures that the necessary parent directories exist for ansible_collections/community, which prepares the environment to clone or work with a collection repository. Typically a prerequisite step before cloning any collection source code repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_contributing.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmkdir -p ~/dev/ansible/collections/ansible_collections/community\n```\n\n----------------------------------------\n\nTITLE: Mapping Certificate to Local User Account (PowerShell)\nDESCRIPTION: A PowerShell script that creates a WinRM client certificate mapping using `New-Item` on the `WSMan:` drive. It associates the certificate (identified by its User Principal Name subject and issuer CA thumbprint) with a specified local Windows user account, prompting for the user's password. This allows authentication via the certificate instead of the password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_7\n\nLANGUAGE: powershell\nCODE:\n```\n# Will prompt for the password of the user.\n$credential = Get-Credential local-user\n\n$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(\"cert.pem\")\n$certChain = [System.Security.Cryptography.X509Certificates.X509Chain]::new()\n[void]$certChain.Build($cert)\n$caThumbprint = $certChain.ChainElements.Certificate[-1].Thumbprint\n\n$certMapping = @{\n    Path       = 'WSMan:\\localhost\\ClientCertificate'\n    Subject    = $cert.GetNameInfo('UpnName', $false)\n    Issuer     = $caThumbprint\n    Credential = $credential\n    Force      = $true\n}\nNew-Item @certMapping\n```\n\n----------------------------------------\n\nTITLE: Defining Validation Criteria with JSON Schema (Text/JSON)\nDESCRIPTION: This code shows the content of a JSON file (`criteria/nxos_show_interface_admin_criteria.json`) defining the validation criteria using JSON Schema. It specifies that the input data should be an object (`\"type\": \"object\"`). It uses `patternProperties` to apply rules to all keys matching `^.*` (effectively all interface names). For each interface, it expects the `admin_state` property to be a string (`\"type\": \"string\"`) that matches the regular expression `up` (`\"pattern\": \"up\"`). This schema enforces that all interfaces must have an administrative state of 'up'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/validate.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n$ cat criteria/nxos_show_interface_admin_criteria.json\n{\n      \"type\" : \"object\",\n      \"patternProperties\": {\n              \"^.*\": {\n                      \"type\": \"object\",\n                      \"properties\": {\n                              \"admin_state\": {\n                                      \"type\": \"string\",\n                                      \"pattern\": \"up\"\n                              }\n                      }\n              }\n      }\n }\n```\n\n----------------------------------------\n\nTITLE: Recommended Package Installation using Direct List Parameter in YAML\nDESCRIPTION: Illustrates the recommended approach in Ansible 2.7 and later for installing multiple packages. Instead of looping, the entire list of packages (e.g., `{{ packages }}`) should be passed directly to the module's `name` (or `pkg`/`package`) parameter. This leverages native module support for lists, available since Ansible 2.3.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.7.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Install packages\n  yum:\n    name: \"{{ packages }}\"\n    state: present\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Navigator with Pip - Bash\nDESCRIPTION: Installs the ansible-navigator tool (which also includes ansible-builder) via pip3. This is suitable for environments where ansible-navigator is not already present. Requires Python 3 and pip3 to be installed. The command can be run in user or system contexts depending on permissions and target location.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/setup_environment.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip3 install ansible-navigator\n```\n\n----------------------------------------\n\nTITLE: Dependency Change for one_image Module (Ansible)\nDESCRIPTION: Indicates a dependency change for the `one_image` module in `community.general`. It now uses `pyone` instead of the previous `python-oca` library.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_20\n\nLANGUAGE: ansible\nCODE:\n```\none_image\n```\n\n----------------------------------------\n\nTITLE: Viewing Ansible Vault Encrypted Variable Structure (YAML)\nDESCRIPTION: Shows an example of a YAML variable encrypted with Ansible Vault. The header (`!vault | $ANSIBLE_VAULT;1.2;AES256;dev`) includes metadata like the vault version, encryption algorithm (AES256), and the vault ID (`dev`) used for encryption. The subsequent lines contain the hex-encoded encrypted data.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_managing_passwords.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nmy_encrypted_var: !vault |\n          $ANSIBLE_VAULT;1.2;AES256;dev\n          30613233633461343837653833666333643061636561303338373661313838333565653635353162\n          3263363434623733343538653462613064333634333464660a663633623939393439316636633863\n          61636237636537333938306331383339353265363239643939666639386530626330633337633833\n          6664656334373166630a363736393262666465663432613932613036303963343263623137386239\n          6330\n```\n\n----------------------------------------\n\nTITLE: Verifying Documentation Build using Nox (Bash)\nDESCRIPTION: This command runs the `docs-build` check within the `checkers` nox session. It performs a test build of the documentation to verify that it can be generated without errors. Note that this session cleans up the generated documentation afterwards.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnox -s \"checkers(docs-build)\"\n```\n\n----------------------------------------\n\nTITLE: Custom Skeleton Configuration in ansible.cfg - Text\nDESCRIPTION: Specifies how to configure the default role skeleton and exclusion patterns in the ansible.cfg configuration file under the [galaxy] section. 'role_skeleton' determines the directory path for custom templates, while 'role_skeleton_ignore' uses regex patterns to filter out files such as .git and .git_keep during skeleton processing. This configuration affects the behavior of ansible-galaxy init.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n[galaxy]\nrole_skeleton = /path/to/skeleton\nrole_skeleton_ignore = ^.git$,^.*/.git_keep$\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Role Execution with allow_duplicates in Ansible (YAML)\nDESCRIPTION: The `meta/main.yml` file for an Ansible role ('foo') setting `allow_duplicates: true`. This allows the role to be executed multiple times within the same play, even with identical parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n# roles/foo/meta/main.yml\n---\nallow_duplicates: true\n```\n\n----------------------------------------\n\nTITLE: Obtaining and Inspecting Kerberos Tickets for SSH Authentication - bash\nDESCRIPTION: These bash commands demonstrate using `kinit` to obtain a Kerberos ticket for a specified principal and `klist` to verify ticket presence, cache, and flags. Used during GSSAPI authentication setup for Ansible, these commands require Kerberos client libraries installed and a correctly configured /etc/krb5.conf. Parameters include principal username and realm; output is the Kerberos ticket and its status, shown in the terminal.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n> kinit username@REALM.COM\nPassword for username@REALM.COM\n\n> klist\nTicket cache: KCM:1000\nDefault principal: username@REALM.COM\n\nValid starting     Expires            Service principal\n29/08/24 13:54:51  29/08/24 23:54:51  krbtgt/REALM.COM@REALM.COM\n        renew until 05/09/24 13:54:48\n```\n\n----------------------------------------\n\nTITLE: Deprecating 'master' State Choice in mysql_replication (Ansible)\nDESCRIPTION: Issues a deprecation warning for the `mysql_replication` module (`community.mysql`). Choices for the `state` option containing `master` will be replaced by alternatives using `primary` in `community.mysql` 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_40\n\nLANGUAGE: ansible\nCODE:\n```\nmysql_replication\n```\n\nLANGUAGE: ansible\nCODE:\n```\nstate\n```\n\nLANGUAGE: ansible\nCODE:\n```\nmaster\n```\n\n----------------------------------------\n\nTITLE: Importing Self-Signed Certificate to Root Store (PowerShell)\nDESCRIPTION: A PowerShell script to import a self-signed public certificate (`cert.pem`) into the `LocalMachine\\Root` (Trusted Root Certification Authorities) certificate store. This is necessary for self-signed certificates, as the host needs to trust the certificate itself as a CA.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\n$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(\"cert.pem\")\n\n$store = Get-Item -LiteralPath Cert:\\LocalMachine\\Root\n$store.Open('ReadWrite')\n$store.Add($cert)\n$store.Dispose()\n```\n\n----------------------------------------\n\nTITLE: Linking to Internal Anchors using :ref: in reStructuredText (rst)\nDESCRIPTION: Shows the reStructuredText `:ref:` role for creating internal links. The first example uses the anchor name as the link text, while the second provides custom link text ('this page') pointing to the same anchor (`unique_page`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_8\n\nLANGUAGE: rst\nCODE:\n```\n   :ref:`unique_page`\n   :ref:`this page <unique_page>`\n```\n\n----------------------------------------\n\nTITLE: Initializing an Ansible Role with a Custom Skeleton - Bash\nDESCRIPTION: Creates a new Ansible role using a custom skeleton by providing a path with the --role-skeleton flag. Requires a valid skeleton directory and the ansible-galaxy CLI as dependencies. Copies skeleton contents, renders .j2 templates (with 'role_name'), and ignores .git/.git_keep files. Usage of this command allows customization over role structure and default file content.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy init --role-skeleton=/path/to/skeleton role_name\n```\n\n----------------------------------------\n\nTITLE: Listing Travis Integrations with Ansible Galaxy - Bash\nDESCRIPTION: Displays existing Travis CI integrations for a given role using the 'ansible-galaxy setup --list' command. Requires authentication and accepts Travis, GitHub user, repo, and Travis token as arguments. Shows integration IDs for later removal.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy setup --list travis github_user github_repo xxx-travis-token-xxx\n```\n\n----------------------------------------\n\nTITLE: Downloading Coverage Results from Azure Pipelines (Shell)\nDESCRIPTION: This shell snippet downloads code coverage results and associated metadata from Azure Pipelines using the download.py script. Arguments include the desired run number, artifacts and run-metadata flags, and the verbose option. The command must be run with the target directory structure in place and requires the hacking/azp/download.py script and its dependencies. Output includes the artifacts and run metadata for the specified pipeline run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/azp/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# download results to ansible/ansible directory under cwd\n# substitute the correct run number for the Azure Pipelines coverage run you want to download\nhacking/azp/download.py 14075 --artifacts --run-metadata -v\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Collection Sanity Test Ignore Entries (Text)\nDESCRIPTION: Demonstrates the format for ignoring specific sanity test errors in an Ansible collection's `tests/sanity/ignore-X.Y.txt` file. Each line specifies a relative file path, a sanity test name (potentially with a specific error code separated by a colon), and an optional comment. This allows developers to selectively suppress reported errors for specific files, often used while updating code to meet newer test requirements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/ignores.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nroles/my_role/files/my_script.sh shellcheck:SC2154 # ignore undefined variable\nplugins/modules/my_module.py validate-modules:missing-gplv3-license # ignore license check\nplugins/modules/my_module.py import-3.8 # needs update to support collections.abc on Python 3.8+\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_get_firmware_inventory Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_get_firmware_inventory` module is deprecated. Users should migrate to the `idrac_firmware_info` module to retrieve firmware inventory information from Dell EMC iDRAC.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_27\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_get_firmware_inventory\n```\n\n----------------------------------------\n\nTITLE: Listing Current Ansible Steering Committee Members in RST\nDESCRIPTION: This reStructuredText snippet defines a table listing the current members of the Ansible Steering Committee, including their Name, GitHub handle, Forum handle, and the year they started.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/steering/community_steering_committee.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. table:: Current Steering committee members\n\n  +------------------+---------------+--------------+-------------+\n  | Name             | GitHub        | Forum        | Start year  |\n  +==================+===============+==============+=============+\n  | Alexei Znamensky | russoz        | russoz       | 2022        |\n  +------------------+---------------+--------------+-------------+\n  | Alicia Cozine    | acozine       | acozine      | 2021        |\n  +------------------+---------------+--------------+-------------+\n  | Andrew Klychkov  | Andersson007  | Andersson007 | 2021        |\n  +------------------+---------------+--------------+-------------+\n  | Brian Scholer    | briantist     | briantist    | 2022        |\n  +------------------+---------------+--------------+-------------+\n  | Core Team repr.  | See Forum     |              | 2024        |\n  +------------------+---------------+--------------+-------------+\n  | Felix Fontein    | felixfontein  | felixfontein | 2021        |\n  +------------------+---------------+--------------+-------------+\n  | James Cassell    | jamescassell  | cassel       | 2021        |\n  +------------------+---------------+--------------+-------------+\n  | John Barker      | gundalow      | gundalow     | 2021        |\n  +------------------+---------------+--------------+-------------+\n  | Mario Lenz       | mariolenz     | mariolenz    | 2022        |\n  +------------------+---------------+--------------+-------------+\n  | Markus Bergholz  | markuman      | markuman     | 2022        |\n  +------------------+---------------+--------------+-------------+\n  | Maxwell G        | gotmax23      | gotmax23     | 2022        |\n  +------------------+---------------+--------------+-------------+\n  | Sorin Sbarnea    | ssbarnea      | ssbarnea     | 2021        |\n  +------------------+---------------+--------------+-------------+\n```\n\n----------------------------------------\n\nTITLE: Deprecated List-of-Dictionaries Syntax for vars in Ansible Playbooks (YAML)\nDESCRIPTION: Displays the deprecated and recommended syntax for setting 'vars' in Ansible playbooks. The first snippet shows the old, now discouraged way of passing a list of dictionaries as variable definitions. The second snippet demonstrates the new, preferred method using a single dictionary to define variables directly. No external dependencies other than Ansible's core playbook processing are required. Both variants expect variable assignments, but as of ansible-core 2.15 only the dictionary-based syntax is recommended; using lists may result in deprecation warnings or future errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.15.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\\n  - var1: foo\\n  - var2: bar\n```\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\\n  var1: foo\\n  var2: bar\n```\n\n----------------------------------------\n\nTITLE: Running validate-modules Sanity Test Using Ansible-Test - Shell\nDESCRIPTION: This shell snippet demonstrates initializing your environment and running the validate-modules sanity test using ansible-test. It requires that you are inside the Ansible source directory and have sourced the hacking/env-setup script to set your environment before running ansible-test. Parameters such as --test specify the particular sanity test to execute. The main inputs are directory paths and environment variables; the output is CLI validation feedback about module code and documentation issues.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/validate-modules.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd /path/to/ansible/source\\nsource hacking/env-setup\\nansible-test sanity --test validate-modules\n```\n\n----------------------------------------\n\nTITLE: Referencing dellemc.openmanage Collection Name (Ansible)\nDESCRIPTION: Refers to the Ansible collection `dellemc.openmanage`. It must be installed manually when using ansible-base 2.10+ without Ansible 4.0.0 if community.general was installed separately, or if using Ansible 2.9 due to the lack of redirection support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_16\n\nLANGUAGE: ansible\nCODE:\n```\ndellemc.openmanage\n```\n\n----------------------------------------\n\nTITLE: Copying Azure Requirements for Integration Tests using Bash\nDESCRIPTION: This Bash command copies the Azure packaging requirements file (`packaging/requirements/requirements-azure.txt`) to the location used by Azure integration tests (`test/lib/ansible_test/_data/requirements/integration.cloud.azure.txt`). This ensures that the integration tests use the same dependencies defined for Azure packaging. Run this command whenever changes are made to `packaging/requirements/requirements-azure.txt`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/azure-requirements.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncp packaging/requirements/requirements-azure.txt test/lib/ansible_test/_data/requirements/integration.cloud.azure.txt\n```\n\n----------------------------------------\n\nTITLE: Cloning Forked Ansible Collection Repository via SSH in Bash\nDESCRIPTION: Clones the user's forked collection repository from GitHub using the SSH protocol into the previously created local directory structure (`~/ansible_collections/NAMESPACE/COLLECTION_NAME`). This requires SSH key setup with GitHub. Replace `YOURACC`, `COLLECTION_REPO`, `NAMESPACE`, and `COLLECTION_NAME` with actual values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone git@github.com:YOURACC/COLLECTION_REPO.git ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Listing Integration Test Targets in Shell\nDESCRIPTION: This shell command lists all available integration test targets using ansible-test. The '--list-targets' flag outputs the collection of testable modules or scenarios. Useful for discoverability and interactive shell workflows. No additional dependencies beyond ansible-test.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration --list-targets\n```\n\n----------------------------------------\n\nTITLE: Example Structured Output from Native Parser (Linux Interfaces)\nDESCRIPTION: Shows an example of the structured data stored in the `interfaces` fact after parsing the `ip addr show` command output using the native parser. Each top-level key is an interface name (e.g., `lo`, `enp64s0u1`), containing key-value pairs representing the parsed properties like IP address, MTU, state, and operational flags.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nlo:\n  broadcast: false\n  carrier: true\n  ip_address: 127.0.0.1\n  mask_bits: 8\n  mtu: 65536\n  multicast: false\n  name: lo\n  state: unknown\n  up: true\nenp64s0u1:\n  broadcast: true\n  carrier: true\n  ip_address: 192.168.86.83\n  mask_bits: 24\n  mtu: 1500\n  multicast: true\n  name: enp64s0u1\n  state: up\n  up: true\n# ...\n```\n\n----------------------------------------\n\nTITLE: Variable Precedence within Ansible Playbook Scopes (YAML)\nDESCRIPTION: Illustrates variable precedence across different scopes within an Ansible playbook. A variable `ansible_become_user` is set to `admin` at the play level. A task block overrides this variable to `service-admin` for tasks within the block. Tasks outside the block revert to using the play-level variable value (`admin`), demonstrating scope-based precedence where more specific definitions override broader ones.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: cloud\n  gather_facts: false\n  become: true\n  vars:\n    ansible_become_user: admin\n  tasks:\n    - name: This task uses admin as the become user.\n      dnf:\n        name: some-service\n        state: latest\n    - block:\n        - name: This task uses service-admin as the become user.\n          # a task to configure the new service\n        - name: This task also uses service-admin as the become user, defined in the block.\n          # second task to configure the service\n      vars:\n        ansible_become_user: service-admin\n    - name: This task (outside of the block) uses admin as the become user again.\n      service:\n        name: some-service\n        state: restarted\n```\n\n----------------------------------------\n\nTITLE: Describing Major Changes in Changelog Fragments - YAML\nDESCRIPTION: This YAML snippet shows how to document major changes that significantly impact an Ansible collection. The 'major_changes' key is used, followed by a list of important updates, such as modified default behaviors or parameter handling. Each entry includes details about the change and references relevant pull requests, helping maintainers and users quickly identify collection-wide updates.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nmajor_changes:\n  - bitbucket_* modules - client_id is no longer marked as ``no_log=true``. If you relied on its value not showing up in logs and output, mark the whole task with ``no_log: true`` (https://github.com/ansible-collections/community.general/pull/2045).\n\n```\n\n----------------------------------------\n\nTITLE: Analyzing Ansible Playbook Output in Text\nDESCRIPTION: This text snippet shows the standard output from a successful run of an Ansible playbook. It demonstrates named plays and tasks, implicit 'Gathering Facts', per-task statuses, and a summary recap. No dependencies aside from having executed the playbook. Input: terminal command; Output: human-readable playbook run result, including task states (ok, changed, failed, etc) for each host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_playbook.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nPLAY [Example Play] ******************************************************************\n\nTASK [Gathering Facts] *********************************************************\nok: [host1]\nok: [host2]\n\nTASK [Ping hosts] **************************************************************\nok: [host1]\nok: [host2]\n\nTASK [Print Hello World] *******************************************************\nok: [host1] => {\n    \"msg\": \"Hello world\"\n}\nok: [host2] => {\n    \"msg\": \"Hello world\"\n}\n\nPLAY RECAP *********************************************************************\nhost1        : ok=3    changed=0    unreachable=0    failed=0    \nhost2        : ok=3    changed=0    unreachable=0    failed=0\n```\n\n----------------------------------------\n\nTITLE: Listing Integration Test Targets with Ansible-Test (Bash)\nDESCRIPTION: This bash command uses the ansible-test utility to enumerate all integration test targets in an Ansible collection. Requires ansible-core or ansible packages installed. Outputs a list of available targets for integration testing, aiding discovery and verification of existing tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_about.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-test integration --list-targets\n```\n\n----------------------------------------\n\nTITLE: Incorrect Python 2 Exception Handling Syntax (Avoid)\nDESCRIPTION: Demonstrates the outdated Python 2 exception handling syntax using a comma (`except ExceptionType, e:`). This syntax is incompatible with Python 3 and should not be used in Ansible code aiming for cross-version compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_9\n\nLANGUAGE: none\nCODE:\n```\ntry:\n    a = 2/0\nexcept ValueError, e:\n    module.fail_json(msg=\"Tried to divide by zero: %s\" % e)\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Git Remote for Ansible Collection in Bash\nDESCRIPTION: Adds a new Git remote named `upstream` pointing to the original `ansible-collections` repository (e.g., `https://github.com/ansible-collections/COLLECTION_REPO.git`) from which the fork was created. Replace `COLLECTION_REPO` with the actual repository name.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ git remote add upstream https://github.com/ansible-collections/COLLECTION_REPO.git\n```\n\n----------------------------------------\n\nTITLE: Defining Multiline Variables and Trimming Newlines: Ansible Playbook YAML Syntax (1.9.x)\nDESCRIPTION: This YAML example illustrates how multiline variables defined in the playbook using the YAML dict format would previously have trailing newlines stripped in Ansible 1.9.x. It demonstrates variable definition and message output using the debug module, where the variable 'message' contains a multiline string. This sample helps users understand past behavior regarding preservation of newlines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  message: >\n    Testing\n    some things\ntasks:\n- debug:\n    msg: \"{{ message }}\"\n```\n\n----------------------------------------\n\nTITLE: Behavior Change in java_keystore Module (Passphrase Change) (Ansible)\nDESCRIPTION: Details a behavior change in the `java_keystore` module (`community.general`). If the passphrase is changed for an existing keystore, the module now overwrites the keystore instead of failing. Users should ensure playbooks do not rely on the old failure behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_19\n\nLANGUAGE: ansible\nCODE:\n```\njava_keystore\n```\n\n----------------------------------------\n\nTITLE: Listing Container Images with Podman - Bash\nDESCRIPTION: This snippet lists all available container images using 'podman image list', displaying image repositories, tags, IDs, creation times, and sizes. It allows verification that the new image 'postgresql_ee' has been built successfully. This command requires Podman to be installed. The listed example output demonstrates the expected result on success.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/build_execution_environment.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npodman image list\n\nlocalhost/postgresql_ee          latest      2e866777269b  6 minutes ago  1.11 GB\n```\n\n----------------------------------------\n\nTITLE: Example SSH Config for Netconf Jump Host (SSH Config)\nDESCRIPTION: Provides an example SSH configuration file (`~/.ssh/config`) setup for connecting to a network device (`junos01`) via a jump host (`jumphost`) using the NETCONF protocol. It highlights the use of `ProxyCommand` and the necessity of specifying the correct NETCONF port (e.g., 22 or 830) as Paramiko doesn't automatically use `ansible_port` from inventory here. This configuration is used when `ansible_netconf_ssh_config` is enabled in Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_39\n\nLANGUAGE: text\nCODE:\n```\nHost jumphost\n  HostName jumphost.domain.name.com\n  User jumphost-user\n  IdentityFile \"/path/to/ssh-key.pem\"\n  Port 22\n\n# Note: Due to the way that Paramiko reads the SSH Config file,\n# you need to specify the NETCONF port that the host uses.\n# In other words, it does not automatically use ansible_port\n# As a result you need either:\n\nHost junos01\n  HostName junos01\n  ProxyCommand ssh -W %h:22 jumphost\n\n# OR\n\nHost junos01\n  HostName junos01\n  ProxyCommand ssh -W %h:830 jumphost\n\n# Depending on the netconf port used.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Hyphen Usage for Ambiguity Avoidance\nDESCRIPTION: These examples demonstrate the use of hyphens in compound adjectives and terms to prevent misreading or clarify meaning. Pairs of phrases show how the presence or absence of a hyphen changes the interpretation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/grammar_punctuation.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\na little-used car\na little used-car\n\ncross complaint\ncross-complaint\n\nhigh-school girl\nhigh schoolgirl\n\nfine-tooth comb (most people do not comb their teeth)\n\nthird-world war\nthird world war\n```\n\n----------------------------------------\n\nTITLE: Generating Collection Directory Scaffold - Ansible - Bash\nDESCRIPTION: Runs ansible-playbook with extra vars to generate a collection-style directory structure for network_os 'myos' and resource 'interfaces'. Assumes the existence of the builder, the YAML model, site.yml, and necessary Ansible setup. Outputs files into the specified rm_dest directory. Key parameters: rm_dest (output), structure ('collection'), collection_org, collection_name, and model file path.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -e rm_dest=~/github/rm_example \\\n                 -e structure=collection \\\n                 -e collection_org=cidrblock \\\n                 -e collection_name=my_collection \\\n                 -e model=models/myos/interfaces/myos_interfaces.yml \\\n                 site.yml\n```\n\n----------------------------------------\n\nTITLE: Running Final Documentation Tests Locally (Bash)\nDESCRIPTION: These commands replicate the automated tests run during a documentation pull request. First, `make clean` ensures a clean state in the documentation site directory. Then, `python tests/checkers.py docs-build` runs the documentation build checks, and `python tests/checkers.py rstcheck` performs syntax checks on the rST files. Running these locally helps catch errors before submission.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nmake clean -C docs/docsite\npython tests/checkers.py docs-build\npython tests/checkers.py rstcheck\n```\n\n----------------------------------------\n\nTITLE: Example Minor Change Entry for lineinfile in Ansible Changelog (YAML)\nDESCRIPTION: Presents a specific example of a `minor_changes` entry in an Ansible changelog fragment for the `lineinfile` module. It follows the scoped entry format, documenting the addition of a warning for empty regexps and including the relevant GitHub issue link.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nminor_changes:\n  - lineinfile - add warning when using an empty regexp (https://github.com/ansible/ansible/issues/29443).\n```\n\n----------------------------------------\n\nTITLE: Simulating API Responses Via Mock Side Effects - Python\nDESCRIPTION: Demonstrates how to create a MagicMock of an AWS RDS client and specify a sequence of return values for the 'describe_db_instances' method, effectively simulating a series of RDS instance states. Each element in the side_effect list is generated by the helper 'simple_instance_list' function. This approach is vital for testing logic dependent on changing remote state, ensuring the test can reproduce scenarios that would be difficult or random in integration tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nrds_client_double = MagicMock()\\nrds_client_double.describe_db_instances.side_effect = [\\n    simple_instance_list('rebooting', {\"a\": \"b\", \"c\": \"d\"}),\\n    simple_instance_list('available', {\"c\": \"d\", \"e\": \"f\"}),\\n    simple_instance_list('rebooting', {\"a\": \"b\"}),\\n    simple_instance_list('rebooting', {\"e\": \"f\", \"g\": \"h\"}),\\n    simple_instance_list('rebooting', {}),\\n    simple_instance_list('available', {\"g\": \"h\", \"i\": \"j\"}),\\n    simple_instance_list('rebooting', {\"i\": \"j\", \"k\": \"l\"}),\\n    simple_instance_list('available', {}),\\n    simple_instance_list('available', {}),\\n]\n```\n\n----------------------------------------\n\nTITLE: Changelog Fragment for Release Summary - YAML\nDESCRIPTION: Template YAML fragment for a single release version (e.g., 'changelogs/fragments/X.0.0.yml' or 'X.Y.0.yml'). The 'release_summary' field supports reStructuredText for detailed summary. Input: release text; Output: fragment to be included in changelog generation by Ansible's changelog tools.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nrelease_summary: |-\\n  Write some text here that should appear as the release summary for this version.\\n  The format is reStructuredText, but not a list as for regular changelog fragments.\\n  This text will be inserted into the changelog.\n```\n\n----------------------------------------\n\nTITLE: Documenting Deprecated Aliases for Arguments - Ansible Python\nDESCRIPTION: This snippet shows the structure for marking specific argument aliases as deprecated in an Ansible module argument spec. The deprecated_aliases field holds a list of dicts with alias name, deprecation version/date, and collection name. This guides developers to warn users about renamed or to-be-removed aliases for module arguments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\noption = {\n  'type': 'str',\n  'aliases': ['foo', 'bar'],\n  'deprecated_aliases': [\n    {\n      'name': 'foo',\n      'version': '2.0.0',\n      'collection_name': 'testns.testcol',\n    },\n    {\n      'name': 'foo',\n      'date': '2020-12-31',\n      'collection_name': 'testns.testcol',\n    },\n  ],\n},\n```\n\n----------------------------------------\n\nTITLE: Enabling Duplicates for Dependent Ansible Roles (YAML)\nDESCRIPTION: The `meta/main.yml` file for dependent roles ('tire' and 'brake') setting `allow_duplicates: true`. This is necessary for them to run multiple times when called by a parent role ('wheel') that itself is invoked multiple times with different parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_24\n\nLANGUAGE: yaml\nCODE:\n```\n---\nallow_duplicates: true\n```\n\n----------------------------------------\n\nTITLE: Creating Syntax-Highlighted Python Code Blocks in reStructuredText (rst)\nDESCRIPTION: Demonstrates the reStructuredText directive `.. code-block:: python` used to embed Python code with syntax highlighting provided by Pygments. Requires correct indentation and surrounding blank lines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n      .. code-block:: python\n\n         def my_beautiful_python_code():\n            pass\n```\n\n----------------------------------------\n\nTITLE: Running the include_role Module via Ansible CLI - Bash\nDESCRIPTION: This snippet demonstrates invoking the 'include_role' Ansible module directly using the command-line interface for ad-hoc execution. No specific dependencies are required beyond a working ansible CLI installation. The module is specified with '-m', its argument with '-a', and the target hosts with 'all'. Inputs include the role name, and the expected outcome is the inclusion of the specified role's tasks in the execution. The snippet serves as an example for those transitioning to direct role/task inclusion in ad-hoc or console modes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.7.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n#> ansible -m include_role -a 'name=myrole' all\n```\n\n----------------------------------------\n\nTITLE: Recommended Standard Enable-PSRemoting Command for Ansible (PowerShell)\nDESCRIPTION: The standard PowerShell command recommended for enabling PowerShell Remoting (WinRM) on a Windows host. Running this command sets up WinRM with default, more secure settings (compared to ConfigureRemotingForAnsible.ps1) that are compatible with modern Ansible connections using NTLM or Kerberos authentication and message encryption over HTTP. This is generally sufficient for Ansible connectivity without needing the problematic ConfigureRemotingForAnsible.ps1 script.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/examples/scripts/README.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nEnable-PSRemoting\n```\n\n----------------------------------------\n\nTITLE: Specifying codespell Version (requirements)\nDESCRIPTION: This line defines the specific version (2.4.1) of the `codespell` package that should be installed. The comment indicates this dependency was derived from the input file `tests/spelling.in` during the `uv pip compile` process. This ensures consistent spelling checks across different environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/spelling.txt#_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\n# This file was autogenerated by uv via the following command:\n#    uv pip compile --universal --output-file tests/spelling.txt tests/spelling.in\ncodespell==2.4.1\n    # via -r tests/spelling.in\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule.no_log Attribute\nDESCRIPTION: Stub documentation reference for the `no_log` attribute of the `AnsibleModule` class, controlling logging suppression.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule.no_log\n```\n\n----------------------------------------\n\nTITLE: Fixing Dictionary Interpretation Error by Quoting the Expression in Ansible\nDESCRIPTION: This Ansible playbook snippet presents the fix for a conditional where a string was misinterpreted as a dictionary. By enclosing the entire expression `'result.msg == \"some_key: some_value\"'` in single quotes, it forces YAML to treat it as a single string, allowing Ansible to correctly parse and evaluate the intended comparison.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_8\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that:\n     - 'result.msg == \"some_key: some_value\"'\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Defaults with Jinja in Ansible 2.7 (Method 1)\nDESCRIPTION: Shows the verbose method required in Ansible 2.7 and older to safely access nested attributes that might be undefined. Each level of the nested structure needs a `default({})` filter to prevent errors if an intermediate key is missing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_1\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ ((foo | default({})).bar | default({})).baz | default('DEFAULT') }}\n```\n\n----------------------------------------\n\nTITLE: Specifying Required Ansible Version in `meta/runtime.yml` (YAML)\nDESCRIPTION: This snippet shows how to use the `requires_ansible` key within the `meta/runtime.yml` file to define the compatible versions of Ansible Core (`ansible-core`) needed for the collection. It uses PEP 440 version specifiers, although Ansible interprets them slightly differently for prereleases (e.g., `2.11.0b1` matches `>=2.11`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nrequires_ansible: \">=2.10,<2.11\"\n```\n\n----------------------------------------\n\nTITLE: Installing Full Ansible Package on Arch Linux (Bash)\nDESCRIPTION: Installs the complete 'ansible' package, which includes ansible-core and relevant collections available in the Arch repositories, using the Pacman package manager. Requires root privileges (sudo).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo pacman -S ansible\n```\n\n----------------------------------------\n\nTITLE: Required Module File Path Structure in Ansible Collections\nDESCRIPTION: Illustrates the standard path for placing Ansible module files within a collection. Modules must reside inside the `/plugins/modules/` directory. The `$your_first_module.py` serves as a placeholder for the actual module's Python file name. A collection requires at least one module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_in_groups.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n/plugins/modules/$your_first_module.py\n```\n\n----------------------------------------\n\nTITLE: Correctly Using the 'version' Test in Ansible Playbook 'when' Clause\nDESCRIPTION: Demonstrates the recommended syntax for using the `version` test directly within an Ansible task's `when` condition. Note the absence of Jinja2 template delimiters (`{{ }}`) when used in a `when` clause for boolean evaluation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n    my_version: 1.2.3\n\ntasks:\n    - debug:\n        msg: \"my_version is higher than 1.0.0\"\n      when: my_version is version('1.0.0', '>')\n\n```\n\n----------------------------------------\n\nTITLE: Using the Local Connection in Playbooks (YAML)\nDESCRIPTION: Shows the `connection: local` directive used within an Ansible playbook. This setting forces Ansible to execute tasks using a local fork on the control node, bypassing remote connections (like SSH) for the associated play or task. Often, `delegate_to: localhost` is preferred for task-level redirection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nconnection: local\n```\n\n----------------------------------------\n\nTITLE: Referencing Dictionary Values using Bracket and Dot Notation in Jinja2\nDESCRIPTION: This snippet illustrates two ways to access values within a dictionary variable (`foo`) using Jinja2 syntax within Ansible: bracket notation (`foo['field1']`) and dot notation (`foo.field1`). Both reference the value associated with `field1` ('one'). Bracket notation is generally safer, especially if keys clash with Python dictionary methods.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n  foo['field1']\n  foo.field1\n```\n\n----------------------------------------\n\nTITLE: Defining Variables in Ansible Role's vars/main.yml (YAML)\nDESCRIPTION: Displays the content of the `vars/main.yml` file within the 'system_demo' role using the `cat` command. This YAML file defines variables specific to the role. In this case, it defines the `dns` variable with the value \"8.8.8.8 8.8.4.4\". This variable was moved from the `vars` section of the original playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n[user@ansible system_demo]$ cat vars/main.yml\n---\ndns: \"8.8.8.8 8.8.4.4\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Import Statement in Ansible (`main.yml`)\nDESCRIPTION: This snippet shows the main playbook file (`main.yml`) demonstrating a conditional import. The `import_tasks: other_tasks.yml` statement includes tasks from another file, but only if the variable 'x' is not defined. The `when` condition applied to `import_tasks` is inherited by all tasks within `other_tasks.yml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n# all tasks within an imported file inherit the condition from the import statement\n# main.yml\n- hosts: all\n  tasks:\n  - import_tasks: other_tasks.yml # note \"import\"\n    when: x is not defined\n```\n\n----------------------------------------\n\nTITLE: Triggering Specific Handlers from a Statically Imported Task File in Ansible (YAML)\nDESCRIPTION: This Ansible playbook demonstrates how to trigger individual handlers defined within a task file (`restarts.yml`) that is statically imported using `import_tasks`. Because the import happens before the play begins, individual tasks within the imported file (e.g., 'Restart apache', 'Restart mysql') can be notified directly using their names.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Trigger an imported (static) handler\n  hosts: localhost\n  handlers:\n    - name: Restart services\n      import_tasks: restarts.yml\n  tasks:\n    - command: \"true\"\n      notify: Restart apache\n    - command: \"true\"\n      notify: Restart mysql\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbook with Multiple Inventory Sources (Bash)\nDESCRIPTION: Provides an example Bash command showing how to run `ansible-playbook` while specifying multiple inventory sources (files, directories, or dynamic scripts) using the `-i` flag multiple times. This allows targeting hosts from different inventories (e.g., `staging` and `production`) in a single run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook get_logs.yml -i staging -i production\n```\n\n----------------------------------------\n\nTITLE: Initializing Ansible Collection using ansible-galaxy (Bash)\nDESCRIPTION: This command initializes a new Ansible collection skeleton within the standard collections directory structure using the ansible-galaxy CLI. It creates all required subdirectories and meta files needed for custom module or plugin development. The command requires Ansible to be installed, and collection namespace/name must follow the described naming rules; inputs are the namespace and collection name, output is a directory tree scaffold for development.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_creating.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible_collections#> ansible-galaxy collection init my_namespace.my_collection\n```\n\n----------------------------------------\n\nTITLE: Defining Windows Paths Using YAML in Ansible Playbooks (INI)\nDESCRIPTION: These configuration snippets illustrate how to properly specify Windows file system paths in YAML-based Ansible roles and playbooks, clarifying which quoting schemes produce valid, working variables and which introduce errors. The examples demonstrate using unquoted, single-quoted, and double-quoted strings, caution against double backslashes unless needed for escaping, and point out scenarios where unescaped or POSIX-style paths are invalid in a Windows context. No dependencies beyond Ansible and YAML, but awareness of YAML syntax is critical.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_7\n\nLANGUAGE: ini\nCODE:\n```\n# GOOD\ntempdir: C:\\Windows\\Temp\n\n# WORKS\ntempdir: 'C:\\Windows\\Temp'\ntempdir: \"C:\\\\Windows\\\\Temp\"\n\n# BAD, BUT SOMETIMES WORKS\ntempdir: C:\\\\Windows\\\\Temp\ntempdir: 'C:\\\\Windows\\\\Temp'\ntempdir: C:/Windows/Temp\n```\n\n----------------------------------------\n\nTITLE: Expanded Logic - Included Tasks (`other_tasks.yml` part)\nDESCRIPTION: This snippet shows the second part of the expanded logic for the conditional include example, representing the tasks within `other_tasks.yml`. Crucially, these tasks (`set_fact` and `debug`) do *not* inherit the `when` condition from the `include_tasks` statement and will execute unconditionally once the file is included.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_27\n\nLANGUAGE: yaml\nCODE:\n```\n# other_tasks.yml\n- name: Set a variable\n  ansible.builtin.set_fact:\n    x: foo\n  # no condition applied to this task, Ansible sets the value of x to foo\n\n- name: Print a variable\n  ansible.builtin.debug:\n    var: x\n  # no condition applied to this task, Ansible prints the debug statement\n```\n\n----------------------------------------\n\nTITLE: Using Variables in 'changed_when' Conditions (YAML)\nDESCRIPTION: This Ansible task demonstrates using predefined variables (`log_path`, `log_file`) within a `changed_when` conditional. It attempts to create a directory or touch a file using `ansible.builtin.shell`. The task reports 'changed' status only if the shell command returns 0 AND the standard error does not contain the specific 'File exists' message from `mkdir`, using string concatenation (`~`) to build the expected error message dynamically from variables. Note the absence of `{{ }}` delimiters around variables within the `changed_when` expression itself.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Example playbook\n  hosts: myHosts\n  vars:\n    log_path: /home/ansible/logfolder/\n    log_file: log.log\n\n  tasks:\n    - name: Create empty log file\n      ansible.builtin.shell: mkdir {{ log_path }} || touch {{log_path }}{{ log_file }}\n      register: tmp\n      changed_when:\n        - tmp.rc == 0\n        - 'tmp.stderr != \"mkdir: cannot create directory ‘\" ~ log_path ~ \"’: File exists\"'\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Project Directory Structure (Console)\nDESCRIPTION: Displays a recommended directory structure for organizing an Ansible project. It includes top-level playbooks (`.yml`), an inventory file, directories for group variables (`group_vars`), roles, and a backup directory which can be automatically generated by certain Ansible modules (like `vyos_config`) when the `backup: true` parameter is used. This structure helps maintain clarity as projects grow.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/intermediate_concepts.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n.\\n├── backup\\n│   ├── vyos.example.net_config.2018-02-08@11:10:15\\n│   └── vyos.example.net_config.2018-02-12@08:22:41\\n├── first_playbook.yml\\n├── inventory\\n├── group_vars\\n│   ├── vyos.yml\\n│   └── eos.yml\\n├── roles\\n│   ├── static_route\\n│   └── system\\n├── second_playbook.yml\\n└── third_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Importing a Playbook from a Collection within Another Playbook (YAML)\nDESCRIPTION: Demonstrates importing another playbook by its FQCN directly within a play using 'ansible.builtin.import_playbook'. Requires both the main playbook and the imported playbook to be accessible through Ansible collections. Input: FQCN of the playbook to import. Output: tasks defined in the referenced playbook are executed in sequence.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n    - name: Import a playbook\\n      ansible.builtin.import_playbook: my_namespace.my_collection.playbookX\n```\n\n----------------------------------------\n\nTITLE: Structuring an Inventory Directory - Ansible Inventory - Text\nDESCRIPTION: This snippet outlines a typical structure of an inventory directory for Ansible, containing a mix of plugin configuration files, dynamic scripts, and static sources. No dependencies are needed; the inventory directory can be targeted directly for playbook execution. Each file is loaded and aggregated into a unified inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\ninventory/\\n  openstack.yml          # configure inventory plugin to get hosts from OpenStack cloud\\n  dynamic-inventory.py   # add additional hosts with dynamic inventory script\\n  on-prem                # add static hosts and groups\\n  parent-groups          # add static hosts and groups\n```\n\n----------------------------------------\n\nTITLE: Structure of the ansible_version Fact Output (JSON)\nDESCRIPTION: This JSON snippet displays the structure and fields provided by the ansible_version magic variable in Ansible. It allows users to adapt playbook behavior based on version numbers, with fields for full, major, minor, revision, and string representations of the version. Read-only variable provided by Ansible when facts are gathered.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\\n    \"ansible_version\": {\\n        \"full\": \"2.10.1\",\\n        \"major\": 2,\\n        \"minor\": 10,\\n        \"revision\": 1,\\n        \"string\": \"2.10.1\"\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting async task directory - Ansible Playbook - YAML\nDESCRIPTION: Demonstrates how to execute a dnf task asynchronously in an Ansible playbook with a custom directory for async status. The variable ansible_async_dir replaces the prior method of setting ANSIBLE_ASYNC_DIR under environment:, reflecting changes in Ansible 5. Key parameters include 'async' for the task timeout, 'poll' for checking frequency, and 'vars' for directory override. Inputs: task configuration; Outputs: async task tracked in specified directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_5.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - dnf:\n      name: '*'\n      state: latest\n    async: 300\n    poll: 5\n    vars:\n      ansible_async_dir: /path/to/my/custom/dir\n```\n\n----------------------------------------\n\nTITLE: Comparing Version Strings using Jinja in Ansible\nDESCRIPTION: Provides an example of using the `version` test (available since Ansible 1.6, renamed from `version_compare` in 2.5) within a Jinja expression to compare a version string (e.g., `ansible_facts['distribution_version']`) against a specific version ('12.04') using a comparison operator ('>='). The test returns True or False.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n\"{{ ansible_facts['distribution_version'] is version('12.04', '>=') }}\"\n```\n\n----------------------------------------\n\nTITLE: Testing Module Return Values By Catching Exit Exceptions - Python\nDESCRIPTION: Shows how to insert arguments and call a module's main function within a context that asserts a specific exception ('AnsibleExitJson') is raised, thereby verifying the module's return handling. Assumes the module's exit_json method is patched to raise the exception. Provides a robust pattern for testing both return values and error paths in Ansible modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef test_returned_value(self):\\n    set_module_args({\\n        'activationkey': 'key',\\n        'username': 'user',\\n        'password': 'pass',\\n    })\\n\\n    with self.assertRaises(AnsibleExitJson) as result:\\n        my_module.main()\n```\n\n----------------------------------------\n\nTITLE: Parsing Command Output with JC Filter Plugin in Ansible (YAML)\nDESCRIPTION: This Ansible playbook demonstrates parsing the output of the `dig` command using the JC filter plugin. It runs `dig example.com` on a host using the `shell` module, registers the result, and then uses the `community.general.jc('dig')` filter within `set_fact` to parse the stdout. Finally, it extracts and displays the IP address using the `debug` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: \"Run dig command and parse with jc\"\n     hosts: ubuntu\n     tasks:\n     - shell: dig example.com\n       register: result\n     - set_fact:\n         myvar: \"{{ result.stdout | community.general.jc('dig') }}\"\n     - debug:\n         msg: \"The IP is: {{ myvar[0].answer[0].data }}\"\n```\n\n----------------------------------------\n\nTITLE: Initializing an Ansible Role Structure using ansible-galaxy (Bash)\nDESCRIPTION: Illustrates the use of `ansible-galaxy init system_demo` to create a standard directory skeleton for an Ansible role named 'system_demo'. Subsequently, it changes into the new directory and uses the `tree` command to display the generated default role structure, including directories like `defaults`, `files`, `handlers`, `meta`, `tasks`, `templates`, `tests`, and `vars`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible ~]$ ansible-galaxy init system_demo\n[user@ansible ~]$ cd system_demo/\n[user@ansible system_demo]$ tree\n.\n├── defaults\n│   └── main.yml\n├── files\n├── handlers\n│   └── main.yml\n├── meta\n│   └── main.yml\n├── README.md\n├── tasks\n│   └── main.yml\n├── templates\n├── tests\n│   ├── inventory\n│   └── test.yml\n└── vars\n  └── main.yml\n```\n\n----------------------------------------\n\nTITLE: Running Ansible from Source with Python 3 (Shell)\nDESCRIPTION: Shows how to execute Ansible commands (`ansible`, `ansible-playbook`) directly using the `python3` interpreter when working with an Ansible source checkout. It requires sourcing the development environment setup script (`./hacking/env-setup`) first.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/python_3_support.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ source ./hacking/env-setup\n$ python3 $(which ansible) localhost -m ping\n$ python3 $(which ansible-playbook) sample-playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests with ansible-test (Bash)\nDESCRIPTION: Executes the `postgresql_info` integration tests using the `ansible-test` command. It specifies the target (`postgresql_info`), runs the tests within a Docker container based on the `ubuntu2004` image, and uses `-vvv` for verbose output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nansible-test integration postgresql_info --docker ubuntu2004 -vvv\n```\n\n----------------------------------------\n\nTITLE: Comparing Semantic Versions using Jinja in Ansible\nDESCRIPTION: Shows an example of comparing version strings according to Semantic Versioning (SemVer) rules using the `version` test by setting `version_type='semver'` (available since Ansible 2.11). It compares a variable against a SemVer string including pre-release and build metadata.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n\"{{ sample_semver_var is version('2.0.0-rc.1+build.123', 'lt', version_type='semver') }}\"\n```\n\n----------------------------------------\n\nTITLE: Debugging Variable with regex_replace Output: Ansible YAML Output\nDESCRIPTION: This snippet shows the expected 'msg' output of running the debug task with regex_replace in Ansible, demonstrating how the input string is transformed. It is purely output representation and does not have dependencies; it is useful for validating changes or comparing expected outcomes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n\"msg\": \"test1 1\\\\3\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Dictionary in YAML\nDESCRIPTION: Demonstrates a YAML dictionary (hash or map) representing an employee record. It uses key-value pairs in the 'key: value' format, with indentation defining the structure. A colon must be followed by a space.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# An employee record\nmartin:\n  name: Martin D'vloper\n  job: Developer\n  skill: Elite\n```\n\n----------------------------------------\n\nTITLE: Executing Tasks Unconditionally with Ansible Blocks and Always in YAML\nDESCRIPTION: This Ansible snippet shows the use of an 'always' section within a block structure. Tasks defined in the 'always' section are guaranteed to run, irrespective of whether the tasks in the preceding 'block' succeeded or failed. This is useful for cleanup operations or ensuring final steps are always performed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_blocks.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Always do X\n    block:\n      - name: Print a message\n        ansible.builtin.debug:\n          msg: 'I execute normally'\n\n      - name: Force a failure\n        ansible.builtin.command: /bin/false\n\n      - name: Never print this\n        ansible.builtin.debug:\n          msg: 'I never execute :-('\n    always:\n      - name: Always do this\n        ansible.builtin.debug:\n          msg: \"This always executes, :-)\"\n```\n\n----------------------------------------\n\nTITLE: Appending Multiple Inventory Sources in Ansible Shell\nDESCRIPTION: Illustrates how Ansible handles command-line options that accept multiple values, like `-i` for inventory. When specified multiple times, Ansible appends the values, effectively combining hosts from all specified inventory sources (`/path/inventory1` and `/path/inventory2` in this example).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible -i /path/inventory1 -i /path/inventory2 -m ping all\n```\n\n----------------------------------------\n\nTITLE: Running Antsibull Changelog for Minor Releases - Bash\nDESCRIPTION: Runs the basic antsibull-changelog release command (without --cummulative-release) for generating changelogs for minor releases in the stable branch. Inputs: changelog metadata and fragments; Output: CHANGELOG.rst with latest minor changes. Requires Python and the antsibull-changelog tool.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nantsibull-changelog release\n```\n\n----------------------------------------\n\nTITLE: Referencing the 'file' Lookup Plugin (Text)\nDESCRIPTION: Identifies the `file` lookup plugin in Ansible. This plugin is used within templates or keywords like `loop` to read data directly from files on the control node.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_17\n\nLANGUAGE: text\nCODE:\n```\nfile\n```\n\n----------------------------------------\n\nTITLE: Referring to the ansible-test CLI Command\nDESCRIPTION: Mandates the use of `ansible-test` whenever referring to this specific command-line interface tool. It should be used on all occurrences.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nansible-test\n```\n\n----------------------------------------\n\nTITLE: Using Serial as a List of Batch Sizes in Ansible Playbook (YAML)\nDESCRIPTION: This snippet demonstrates specifying the 'serial' keyword as a list of fixed integers ([1,5,10]), causing Ansible to use 1 host for the first batch, 5 for the second, and 10 for subsequent batches until all hosts are processed. Works with any size inventory; useful for staged rollouts. No dependencies beyond basic Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: test play\\n  hosts: webservers\\n  serial:\\n    - 1\\n    - 5\\n    - 10\n```\n\n----------------------------------------\n\nTITLE: Building Ansible Execution Environment Container Image - Bash\nDESCRIPTION: This snippet builds a new container image for the Execution Environment using 'ansible-builder'. The '--tag' argument names the image 'postgresql_ee'. If Docker is preferred over Podman, add '--container-runtime docker'. This step requires 'ansible-builder' and either Podman or Docker installed. Inputs are assumed to be configuration files in the project directory; output is a container image available on the local system.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/build_execution_environment.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-builder build --tag postgresql_ee\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Action Plugins with ActionBase (Python)\nDESCRIPTION: Shows the minimal template for defining an Ansible action plugin by subclassing ActionBase. This pattern is the foundation for custom actions and requires importing ActionBase from ansible.plugins.action. Input is the parent ActionBase class, and output is a new ActionModule class that can be expanded with task logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.action import ActionBase\n\nclass ActionModule(ActionBase):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Debugging Variable with Newline Removal Output: Ansible YAML Output\nDESCRIPTION: This example displays the output after removing the trailing newline from a variable in an Ansible debug message. It confirms that the modified variable is rendered correctly, showing 'Testing some things' as a single line, and is useful for validating template processing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n\"msg\": \"Testing some things\"\n```\n\n----------------------------------------\n\nTITLE: Batch Reporting Incidental Plugin Coverage with Find and Python Script (Shell)\nDESCRIPTION: This shell snippet demonstrates how to use the Unix find command to locate all Python files in a directory tree (excluding __init__.py) and invoke the incidental.py coverage reporting script for each file with the --plugin-path option. The approach is suitable for bulk reporting of coverage for all filter plugins. Dependencies include a POSIX-compatible shell, find utility, and the incidental.py Python script. Outputs are separate reports for each discovered plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/azp/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nfind lib/ansible/plugins/filter -name '*.py' -not -name __init__.py -exec hacking/azp/incidental.py 14075/ --plugin-path '{}' ';'\n```\n\n----------------------------------------\n\nTITLE: Removing SharedPluginLoaderObj Class from Ansible Core (Python/Ansible)\nDESCRIPTION: Announces the removal of the `SharedPluginLoaderObj` class from `ansible.plugins.strategy`. This class was deprecated and users should utilize the standard plugin loader instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nSharedPluginLoaderObj\n```\n\n----------------------------------------\n\nTITLE: Defining Chapter Headings in reStructuredText (rst)\nDESCRIPTION: Illustrates the reStructuredText syntax using '*' with an overline to define a 'chapter' level heading, such as the main title of a guide like 'Ansible style guide'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n      *******************\n      Ansible style guide\n      *******************\n```\n\n----------------------------------------\n\nTITLE: Inspecting the Execution Environment Containerfile - Bash\nDESCRIPTION: This snippet uses the 'less' utility to open and inspect the generated 'Containerfile' (or 'Dockerfile') located in the 'context' directory. This allows users to review build steps, included dependencies, and configuration. 'less' must be installed, and the file must exist in the specified path. This step helps in verifying that the build process created the correct configuration for the Execution Environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/build_execution_environment.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nless context/Containerfile\n```\n\n----------------------------------------\n\nTITLE: Installing Kerberos Authentication Requirements via pipx (Shell)\nDESCRIPTION: This shell snippet uses pipx to inject Kerberos-related Python extras into Ansible connection plugin dependencies (pypsrp for psrp and pywinrm for winrm). These commands are necessary when using Ansible via pipx and ensure Kerberos libraries are available for the respective plugins. Each line specifies a package and version constraint and should be run in a shell where pipx is installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npipx inject \"pypsrp[kerberos]<=1.0.0\"  # for psrp\npipx inject \"pywinrm[kerberos]>=0.4.0\"  # for winrm\n```\n\n----------------------------------------\n\nTITLE: Defining Python Import Redirections in `meta/runtime.yml` (YAML)\nDESCRIPTION: Illustrates the `import_redirection` key within `meta/runtime.yml`. This section provides a mapping to redirect Python import statements encountered within the collection's code, typically used when module utilities or other Python components are relocated. The key is the original import path, and the value under `redirect` is the new, fully qualified collection path.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nimport_redirection:\n  ansible.module_utils.old_utility:\n    redirect: ansible_collections.namespace_name.collection_name.plugins.module_utils.new_location\n```\n\n----------------------------------------\n\nTITLE: Updating OpenShift Connection Plugin FQCN for Ansible - Markdown\nDESCRIPTION: This entry specifies the change in FQCN for the 'oc' connection plugin, from community.general to community.okd. Users of Ansible 2.9 must update references and install the target collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.oc`` → ``community.okd.oc``\n```\n\n----------------------------------------\n\nTITLE: Defining Task Failure with Multiline OR Conditions (YAML)\nDESCRIPTION: This Ansible task demonstrates defining complex failure conditions using `failed_when` with a multiline YAML string (`>`) and explicit `or` operators. The task executes `./myBinary` and registers the result in `ret`. The task is marked as failed if *any* of the following conditions are true: the string 'No such file or directory' is in standard output, standard error is not empty, or the return code is exactly 10.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- name: example of many failed_when conditions with OR\n  ansible.builtin.shell: \"./myBinary\"\n  register: ret\n  failed_when: >\n    (\"No such file or directory\" in ret.stdout) or\n    (ret.stderr != '') or\n    (ret.rc == 10)\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Sanity Tests with Docker (Shell)\nDESCRIPTION: This shell command executes all standard Ansible sanity tests using the `ansible-test` utility. The `--docker` flag ensures the tests run inside a container environment (using the default image), isolating dependencies. Optional flags like `--test <NAME>` can be added to run specific tests, and `--allow-disabled` can be used to include tests that are normally disabled.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_sanity.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-test sanity --docker\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbooks with Full Path (Shell)\nDESCRIPTION: Refers to the `ansible-playbook` command-line tool specified with its common absolute path `/usr/bin/ansible-playbook`. This command executes Ansible playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n/usr/bin/ansible-playbook\n```\n\n----------------------------------------\n\nTITLE: Updating Local Main Branch After Release - Git Bash Script\nDESCRIPTION: This script ensures the local repository's default branch (main) is synchronized with the upstream repository after the release branch is merged. It prevents divergence and prepares for further development. The script depends on a properly configured 'upstream' remote.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\\ngit pull --rebase upstream main\n```\n\n----------------------------------------\n\nTITLE: Initializing Ansible Module Headers in Python\nDESCRIPTION: This header snippet demonstrates the required shebang, UTF-8 encoding declaration, copyright notice, and GPL license line for a Python-based Ansible module. It establishes crucial metadata at the beginning of every module file, ensuring the correct interpreter is used and licensing is properly attributed. No external dependencies are required, but authors must not edit these lines unless the guidelines specifically permit; always place these at the very top of new module files as demonstrated.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\n# Copyright: Contributors to the Ansible project\\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\\n\n```\n\n----------------------------------------\n\nTITLE: Building Ansible Collection Tarball (Bash)\nDESCRIPTION: This Bash command demonstrates how to build an Ansible collection tarball from the collection's source directory. Running `ansible-galaxy collection build` within the top-level directory of the collection packages its contents (modules, roles, plugins, metadata) into a `.tar.gz` file, ready for publishing. The command requires the collection source code, including a valid `galaxy.yml` file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncollection_dir#> ansible-galaxy collection build\n```\n\n----------------------------------------\n\nTITLE: Failing Ansible Plugin Execution on Import Error - Python\nDESCRIPTION: This snippet shows how a plugin should raise a clear exception if a required optional dependency is not available. If ANOTHER_LIBRARY_IMPORT_ERROR is set, it raises AnsibleError with a message, preserving the original import exception as context. Dependencies: Ansible's error handling exception AnsibleError. Inputs: ANOTHER_LIBRARY_IMPORT_ERROR. Output: Raises a failure with specific message to the user.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nif ANOTHER_LIBRARY_IMPORT_ERROR:\n    raise AnsibleError('another_library must be installed to use this plugin') from ANOTHER_LIBRARY_IMPORT_ERROR\n```\n\n----------------------------------------\n\nTITLE: Managing Domain Users and Groups with win_domain_user - Ansible Playbook YAML\nDESCRIPTION: This snippet automates the creation and configuration of Active Directory users and group assignments in a Windows domain using the win_domain_user module. It processes user details through a loop, setting group memberships, company name, password options, and unique user principal names (UPN). Dependencies include the target domain and correct permissions. Inputs include user objects; outputs are valid domain user listings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Ensure each account is created\\n  win_domain_user:\\n    name: '{{ item.name }}'\\n    upn: '{{ item.name }}@MY.DOMAIN.COM'\\n    password: '{{ item.password }}'\\n    password_never_expires: false\\n    groups:\\n    - Test User\\n    - Application\\n    company: Ansible\\n    update_password: on_create\\n  loop:\\n  - name: Test User\\n    password: Password\\n  - name: Admin User\\n    password: SuperSecretPass01\\n  - name: Dev User\\n    password: '@fvr3IbFBujSRh!3hBg%wgFucD8^x8W5'\n```\n\n----------------------------------------\n\nTITLE: Accessing CLI Arguments via Ansible Context - Python\nDESCRIPTION: This snippet demonstrates how to access command line arguments from a read-only dictionary using the context object in custom Ansible callback plugins. The context.CLIARGS object replaces the now-removed _options attribute for reading CLI data. Key parameters are referenced by string name; for example, 'tags' retrieves relevant filter arguments. Dependencies include having the Ansible Python API available and importing from the 'ansible' package. No modification to CLI arguments is permitted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible import context\n[...]\ntags = context.CLIARGS['tags']\n```\n\n----------------------------------------\n\nTITLE: Changing vmware_host_firewall_manager allowed_hosts Requirement in community.vmware\nDESCRIPTION: In the `vmware_host_firewall_manager` module, creating a new firewall rule without specifying an `allowed_ip` entry within the `allowed_hosts` dictionary will no longer be permitted after the community.vmware 2.0.0 release. Ensure all new rules define allowed IPs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_26\n\nLANGUAGE: Ansible\nCODE:\n```\nvmware_host_firewall_manager: allowed_hosts\n```\n\n----------------------------------------\n\nTITLE: Navigating to Ansible Collection Directory (Shell)\nDESCRIPTION: This shell command changes the current working directory to the root directory of a specific Ansible collection, identified by its namespace and collection name. This step is necessary before running sanity tests against the files within that collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_sanity.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd ~/ansible_collections/<NAMESPACE>/<COLLECTION_NAME>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Faulty Ansible Conditional with Undefined Attribute (YAML+Jinja)\nDESCRIPTION: Shows an Ansible `stat` task with a `failed_when` condition that incorrectly references an undefined attribute (`result.exists`) instead of the correct nested attribute (`result.stat.exists`). In previous Ansible versions, this might not have raised an error due to silent failure in the `is false` Jinja test when encountering undefined values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_16\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- stat:\n    path: /does-not-exist\n  register: result\n  failed_when: result.exists is false\n  #                   ^ missing reference to stat\n```\n\n----------------------------------------\n\nTITLE: Verifying Failed Kerberos Delegation via Ansible (klist.exe)\nDESCRIPTION: This shell command uses Ansible's `ansible.windows.win_command` module to execute `klist.exe` on a remote Windows host (`WINHOST`). The provided output shows a scenario where Kerberos delegation has likely failed or is not configured correctly. Key indicators are the `Server` field showing the target server principal (`http/winhost.my.domain.com @ MY.DOMAIN.COM`) instead of `krbtgt`, and the absence of the `forwarded` flag in `Ticket Flags`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible WINHOST -m ansible.windows.win_command -a klist.exe\n\nWINHOST | CHANGED | rc=0 >>\n\nCurrent LogonId is 0:0x82c312c\n\nCached Tickets: (1)\n\n#0>     Client: username @ MY.DOMAIN.COM\n        Server: http/winhost.my.domain.com @ MY.DOMAIN.COM\n        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96\n        Ticket Flags 0x40a10000 -> forwardable renewable pre_authent name_canonicalize\n        Start Time: 8/30/2024 14:16:24 (local)\n        End Time:   8/31/2024 0:16:12 (local)\n        Renew Time: 0\n        Session Key Type: AES-256-CTS-HMAC-SHA1-96\n        Cache Flags: 0x8 -> ASC\n        Kdc Called:\n```\n\n----------------------------------------\n\nTITLE: Converting Strings to Unicode with to_text (Python)\nDESCRIPTION: Illustrates converting plugin result strings to Python's unicode type using Ansible's to_text utility. Ensures Jinja2 and other components receive properly encoded outputs. The key parameter is the result_string to be converted; returns the result_string in unicode. Requires importing to_text from Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.common.text.converters import to_text\nresult_string = to_text(result_string)\n```\n\n----------------------------------------\n\nTITLE: Query vs Lookup Functions for Enforcing List Returns (jinja)\nDESCRIPTION: This code demonstrates two equivalent ways to ensure the return of a list from a lookup: explicitly passing 'wantlist=True' to 'lookup', and using 'query', which implicitly returns lists. It highlights the distinction and compatibility for use in Jinja2 templates integrated with Ansible since version 2.5. These patterns help maintain consistent behavior when writing new or backward compatible tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_9\n\nLANGUAGE: jinja\nCODE:\n```\n    lookup('dict', dict_variable, wantlist=True)\n\n    query('dict', dict_variable)\n```\n\n----------------------------------------\n\nTITLE: Defining Network Provider Dictionary in Ansible YAML (2.4)\nDESCRIPTION: Illustrates the Ansible 2.4 method of defining connection parameters using a 'provider' dictionary within the playbook's variables section, typically used with 'connection: local'. This method is superseded by standard Ansible connection variables and the 'network_cli'/'netconf' connection types in Ansible 2.5.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\nvars:\n   cli:\n      host: \"{{ inventory_hostname }}\"\n      username: operator\n      password: secret\n      transport: cli\n\ntasks:\n- nxos_config:\n   src: config.j2\n   provider: \"{{ cli }}\"\n   username: admin\n   password: admin\n```\n\n----------------------------------------\n\nTITLE: Invoke Role by FQCN in Playbook (YAML)\nDESCRIPTION: YAML example showing how to specify a role from a collection in an Ansible playbook using its FQCN in the import_role task. No external dependencies; required input is the FQCN, and task executes the specified role. Useful for migration scenarios where fully qualified referencing is needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: example role by FQCN\\n  hosts: some_host_pattern\\n  tasks:\\n    - name: import FQCN role from a collection\\n      import_role:\\n        name: mynamespace.mycollection.my_role\\n\n```\n\n----------------------------------------\n\nTITLE: Printing Ansible Facts Using ansible.builtin.debug in YAML\nDESCRIPTION: This YAML task uses the `ansible.builtin.debug` module within an Ansible play to print the entire `ansible_facts` variable. This displays all facts gathered by Ansible from the target host during the implicit setup phase or an explicit fact-gathering task. It's useful for inspecting available system information within a playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Print all available facts\n  ansible.builtin.debug:\n    var: ansible_facts\n```\n\n----------------------------------------\n\nTITLE: Using Globbing for Host Selection (Shell Pattern)\nDESCRIPTION: Provides an example of a glob pattern (`ww*`) used for selecting multiple Ansible hosts based on wildcards. This allows targeting hosts whose names match the pattern (e.g., starting with 'www') instead of specifying exact names or groups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nww*\n```\n\n----------------------------------------\n\nTITLE: Failing on Missing Dependencies in Main Execution - Python\nDESCRIPTION: This snippet demonstrates how to abort the Ansible module's main execution with an explicit error message if a required import is not present. It uses the 'fail_json' method of the Ansible module object to emit a structured failure message and exception trace. The messaging calls 'missing_required_lib' to clarify which library is missing. This approach ensures predictable, user-friendly errors for unmet dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nif not HAS_LIB:\\n    module.fail_json(msg=missing_required_lib(\"foo\"),\\n                     exception=LIB_IMP_ERR)\n```\n\n----------------------------------------\n\nTITLE: Ensuring Required _meta Hostvars Structure in Ansible Inventory Script Output - Text\nDESCRIPTION: This code represents the minimal valid structure for the _meta field with hostvars in the inventory script's JSON output. Including this ensures Ansible will not invoke the inventory script with --host per host, even if hostvars is empty. The dependency is an external inventory script returning proper JSON, to prevent unnecessary calls. Inputs: --list argument; Outputs: JSON with at least empty hostvars.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_18\n\nLANGUAGE: text\nCODE:\n```\n{\n\n    # results of inventory script as above go here\n    # ...\n\n    \"_meta\": {\n        \"hostvars\": {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Git Repository Structure: Namespace-Based Collections (Text)\nDESCRIPTION: Illustrates a Git repository structure where multiple collections (`collectionA`, `collectionB`) are organized under a common namespace directory (`namespace/`). Each collection subdirectory contains its required `galaxy.yml` file and associated content like plugins and roles.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_git_repo.txt#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nnamespace/\n├── collectionA/\n|   ├── docs/\n|   ├── galaxy.yml\n|   ├── plugins/\n|   │   ├── README.md\n|   │   └── modules/\n|   ├── README.md\n|   └── roles/\n└── collectionB/\n    ├── docs/\n    ├── galaxy.yml\n    ├── plugins/\n    │   ├── connection/\n    │   └── modules/\n    ├── README.md\n    └── roles/\n```\n\n----------------------------------------\n\nTITLE: Validating Changelog Fragments with antsibull-changelog (Shell)\nDESCRIPTION: This command validates the syntax and structure of changelog fragments within an Ansible collection using antsibull-changelog. Running this check prior to generating release changelogs helps identify errors and enforce project standards. The tool must be installed and changelog fragments should exist to be linted; no additional parameters are required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_changelogs.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nantsibull-changelog lint\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Ansible Lookup Plugin in a YAML Playbook\nDESCRIPTION: This YAML snippet demonstrates how to utilize a custom lookup plugin (e.g., `namespace.collection_name.file`) within an Ansible playbook. It shows assigning the lookup's return value to a variable (`contents`) and using it directly within a task's `msg` parameter. It also illustrates passing options to the lookup plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: all\n  vars:\n     contents: \"{{ lookup('namespace.collection_name.file', '/etc/foo.txt') }}\"\n     contents_with_option: \"{{ lookup('namespace.collection_name.file', '/etc/foo.txt', option1='donothing') }}\"\n  tasks:\n\n     - debug:\n         msg: the value of foo.txt is {{ contents }} as seen today {{ lookup('pipe', 'date +\"%Y-%m-%d\"') }}\n```\n\n----------------------------------------\n\nTITLE: Replacing with_together Loops with Loop and Zip Filter in Ansible YAML+Jinja\nDESCRIPTION: Demonstrates how to migrate with_together to use loop and the zip filter, allowing parallel iteration over multiple lists. The updated code combines corresponding elements from list_one and list_two. Inputs are two lists, and output messages reference both values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_together\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }}\"\n  with_together:\n    - \"{{ list_one }}\"\n    - \"{{ list_two }}\"\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_together -> loop\n  ansible.builtin.debug:\n    msg: \"{{ item.0 }} - {{ item.1 }}\"\n  loop: \"{{ list_one|zip(list_two)|list }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Dell OS9 Connection Variables for Ansible - YAML\nDESCRIPTION: This YAML snippet demonstrates how to set up group variables for connecting to Dell OS9 devices with Ansible using the dellemc.os9.os9 collection and Enable Mode for privilege escalation. It configures required credentials, the network CLI connection method, the privilege escalation method, and SSH proxy arguments for bastion host setups. Key variables include 'ansible_connection', 'ansible_network_os', 'ansible_user', 'ansible_password', 'ansible_become', 'ansible_become_method', and optionally 'ansible_ssh_common_args'. The use of Ansible Vault for secure password storage is indicated, and configuration should be applied to the 'group_vars/dellos9.yml' file for target groups.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_dellos9.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: dellemc.os9.os9\\nansible_user: myuser\\nansible_password: !vault...\\nansible_become: true\\nansible_become_method: enable\\nansible_become_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Conditional Template Content Based on Group Membership (Jinja)\nDESCRIPTION: This Jinja2 if statement determines whether the current host belongs to the 'webserver' group by checking group_names. It enables or disables certain template sections depending on group membership, facilitating role-based configuration management. Input is the template context; output is rendered content for group members. Assumes group_names variable is available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_16\n\nLANGUAGE: jinja\nCODE:\n```\n{% if 'webserver' in group_names %}\\n   # some part of a configuration file that only applies to webservers\\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Enabling Inventory Cache in ansible.cfg using INI\nDESCRIPTION: Enables inventory caching within the `[inventory]` section of the `ansible.cfg` file by setting the `cache` parameter to `True`. This activates inventory caching globally if not overridden by environment variables or specific inventory source configurations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n[inventory]\ncache=True\n```\n\n----------------------------------------\n\nTITLE: Disabling a Server in HAProxy using Ansible YAML Playbook\nDESCRIPTION: This snippet uses an Ansible shell task to disable a web server in the HAProxy load balancing pool. It sends a disable command via socat to the HAProxy stats socket, looping over all load balancer hosts using the loop and delegate_to mechanisms. Dependencies include a properly configured Ansible inventory, available socat utility, access to the HAProxy socket, and proper group variable definitions. The key requirement is that HAProxy is set to control servers via the stats socket, and that the web server and HAProxy hosts are properly grouped in inventory for delegation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/guide_rolling_upgrade.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nshell: echo \"disable server myapplb/{{ inventory_hostname }}\" | socat stdio /var/lib/haproxy/stats\ndelegate_to: \"{{ item }}\"\nloop: \"{{ groups.lbservers }}\"\n```\n\n----------------------------------------\n\nTITLE: Using Executable Vault Password Script with Ansible Playbook - CLI Usage (Bash)\nDESCRIPTION: Uses an executable Python script to provide the vault password to Ansible at runtime. Requires the script ('my-vault-password-client.py') to exist and be executable, outputting the vault password to stdout. Useful for dynamic password retrieval or integration with secure storage. Input: CLI command with script path; Output: Playbook execution uses password from script for decryption.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-password-file my-vault-password-client.py\n```\n\n----------------------------------------\n\nTITLE: Setting File Ownership and Permissions with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Uses the `ansible.builtin.file` module to modify file attributes on remote hosts. This command sets the mode to `600`, the owner to `mdehaan`, and the group to `mdehaan` for the file `/srv/foo/b.txt` on all 'webservers'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.file -a \"dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan\"\n```\n\n----------------------------------------\n\nTITLE: Executing the Exploded Ansible Module Manually\nDESCRIPTION: This command uses the Python interpreter to run the Ansible wrapper script (e.g., 'AnsiballZ_ping.py') with the 'execute' argument. This executes the module code located within the 'debug_dir', using the parameters found in the 'args' file. This allows testing modifications made to the module code or arguments directly within the temporary debugging environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/debugging.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ python AnsiballZ_ping.py execute\n{\"invocation\": {\"module_args\": {\"data\": \"debugging_session\"}}, \"changed\": false, \"ping\": \"debugging_session\"}\n```\n\n----------------------------------------\n\nTITLE: Gathering FRR Facts with Ansible Task (YAML)\nDESCRIPTION: This YAML snippet illustrates an Ansible task that uses the `frr.frr.frr_facts` module from the FRR collection. It gathers specific subsets of facts (configuration and hardware) from the target FRR device, relying on the connection settings previously established (e.g., in group variables). The `gather_subset` parameter limits the information collected.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_frr.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: Gather FRR facts\n     frr.frr.frr_facts:\n       gather_subset:\n        - config\n        - hardware\n```\n\n----------------------------------------\n\nTITLE: Failed Ansible Task Output: Unable to Open Shell - ansible-output\nDESCRIPTION: This snippet illustrates an Ansible playbook task failure with the message 'unable to open shell'. It's commonly encountered when the ansible-connection daemon fails to authenticate or communicate with a remote device. The output provides diagnostic details for troubleshooting persistent connection or credential issues; requires only Ansible and the relevant playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_13\n\nLANGUAGE: ansible-output\nCODE:\n```\nTASK [prepare_eos_tests : enable cli on remote device] **************************************************\nfatal: [veos01]: FAILED! => {\"changed\": false, \"failed\": true, \"msg\": \"unable to open shell\"}\n```\n\n----------------------------------------\n\nTITLE: Group Definition Example - Ansible Inventory (INI)\nDESCRIPTION: This INI-formatted snippet defines an inventory group called 'webservers' with three hosts. Used to illustrate subscript and slice operations for targeting hosts by position or range. Requires INI inventory format support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_11\n\nLANGUAGE: ini\nCODE:\n```\n[webservers]\\ncobweb\\nwebbing\\nweber\n```\n\n----------------------------------------\n\nTITLE: Defining a List Variable in Ansible using YAML\nDESCRIPTION: This YAML snippet defines a variable named `region` as a list containing three string values: 'northeast', 'southeast', and 'midwest'. This demonstrates the standard YAML syntax for defining lists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n  region:\n    - northeast\n    - southeast\n    - midwest\n```\n\n----------------------------------------\n\nTITLE: Tasks File for Conditional Include Example (`other_tasks.yml`)\nDESCRIPTION: This is the content of `other_tasks.yml`, used in the conditional include examples. It contains tasks to set 'x' and print 'x'. When included conditionally via `include_tasks`, the `when` condition from the include statement does *not* apply to these tasks; they will run unconditionally if the include step itself is executed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_25\n\nLANGUAGE: yaml\nCODE:\n```\n# other_tasks.yml\n- name: Set a variable\n  ansible.builtin.set_fact:\n    x: foo\n\n- name: Print a variable\n  ansible.builtin.debug:\n    var: x\n```\n\n----------------------------------------\n\nTITLE: Backing Up ICX Device Configuration using Ansible Task (YAML)\nDESCRIPTION: This YAML snippet presents an Ansible task that utilizes the `community.network.icx_config` module to back up the configuration of an ICX network device. The `backup: yes` parameter triggers the backup operation, and the output, including the path to the backup file, is registered in the `backup_icx_location` variable. A `when` condition ensures this task only runs on hosts identified as `community.network.icx`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (icx)\n  community.network.icx_config:\n    backup: yes\n  register: backup_icx_location\n  when: ansible_network_os == 'community.network.icx'\n```\n\n----------------------------------------\n\nTITLE: Installing Multiple Ansible Collections from a Namespace Directory using Bash\nDESCRIPTION: This command uses `ansible-galaxy` to install all collections found within the specified namespace directory `/path/to/ns`. It assumes a structure like the one previously shown, where subdirectories contain individual collections. The `-p ./collections` option specifies the target installation directory, creating `./collections/ansible_collections/` unless `./collections` is already named `ansible_collections`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install /path/to/ns -p ./collections\n```\n\n----------------------------------------\n\nTITLE: Retrieving Junos OS Version via CLI Command Module (YAML)\nDESCRIPTION: Demonstrates a playbook task leveraging the junipernetworks.junos.junos_command Ansible module to fetch the Junos OS version over a CLI connection. Requires prior inventory configuration for network_cli and relevant user credentials. The 'commands' parameter specifies the shell command to execute. The task is conditional on detecting the correct network OS on the target device.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_junos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve Junos OS version\\n  junipernetworks.junos.junos_command:\\n    commands: show version\\n  when: ansible_network_os == 'junipernetworks.junos.junos'\\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with Boolean Filter in Ansible\nDESCRIPTION: This snippet shows a basic `when` condition using an 'or' logical operator and the `bool` filter to ensure the result is evaluated as a boolean. The task associated with this condition (not shown) would run if either the variable 'epic' or 'monumental' evaluates to true.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nwhen: epic or monumental | bool\n```\n\n----------------------------------------\n\nTITLE: Overriding Module Defaults at Task Level in Ansible YAML\nDESCRIPTION: This Ansible playbook snippet shows how `module_defaults` can be applied at the block level for the `ansible.builtin.debug` module, setting a default `msg`. However, the task explicitly defines a different `msg`, demonstrating that task-level arguments override block-level defaults.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n- block:\n    - name: Print a message\n      ansible.builtin.debug:\n        msg: \"Different message\"\n  module_defaults:\n    ansible.builtin.debug:\n      msg: \"Default message\"\n```\n\n----------------------------------------\n\nTITLE: Using YAML Anchors and Aliases in an Ansible Playbook Task (YAML)\nDESCRIPTION: Provides a complete Ansible playbook example demonstrating the definition of variables using YAML anchors (`&my_version`) and aliases (`*my_version`) in the `vars` section. The composed `webapp.custom_name` list is then used within an `ansible.builtin.debug` task, joined into a string using the Jinja2 `join` filter for output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_advanced_syntax.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: Using values nested inside dictionary\n  hosts: localhost\n  vars:\n    webapp:\n      version: &my_version 1.0\n      custom_name:\n        - \"ToDo_App\"\n        - *my_version\n  tasks:\n  - name: Using Anchor value\n    ansible.builtin.debug:\n      msg: My app is called \"{{ webapp.custom_name | join('-') }}\".\n```\n\n----------------------------------------\n\nTITLE: Rebooting Servers with Privilege Escalation using Ansible Ad Hoc Command in Bash\nDESCRIPTION: Demonstrates rebooting servers in the 'atlanta' group, connecting as 'username' (`-u`) but executing the `/sbin/reboot` command with root privileges using privilege escalation (`--become`). The optional `--ask-become-pass` or `-K` flag prompts for the necessary sudo/su password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible atlanta -a \"/sbin/reboot\" -f 10 -u username --become [--ask-become-pass]\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Vault Password Client Script (Bash)\nDESCRIPTION: Illustrates how Ansible internally executes a vault password client script when invoked via the `--vault-id label@script` syntax. Ansible passes the specified vault ID (`dev` in this case) to the script using the `--vault-id` option, enabling the script to fetch the appropriate password from its backend (e.g., system keyring, secret manager). The script must be executable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_managing_passwords.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncontrib-scripts/vault/vault-keyring-client.py --vault-id dev\n```\n\n----------------------------------------\n\nTITLE: Selecting the Free Strategy in Ansible Playbook (YAML)\nDESCRIPTION: This snippet shows how to configure an Ansible play to use the 'free' strategy, allowing each host to proceed through the play as rapidly as possible without waiting for others. There are no extra dependencies outside of standard Ansible. The 'strategy: free' parameter is set at the play level, and user must define 'tasks' accordingly. Inputs include any hosts and tasks; output depends on task results which may complete at different times.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\\n  strategy: free\\n  tasks:\\n  # ...\n```\n\n----------------------------------------\n\nTITLE: Backing up Junos Configuration via NETCONF Task (YAML)\nDESCRIPTION: This Ansible task demonstrates using the NETCONF connection (implicitly configured via inventory) to interact with a Junos device. It utilizes the 'junipernetworks.junos.netconf_config' module with the 'backup: yes' parameter to create a backup of the device's current configuration. The location of the backup file is registered in the 'backup_junos_location' variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netconf_enabled.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config\n  junipernetworks.junos.netconf_config:\n    backup: yes\n  register: backup_junos_location\n```\n\n----------------------------------------\n\nTITLE: Using --vault-id without Vault Label - CLI Usage (Bash)\nDESCRIPTION: Uses the --vault-id option with only a password file specified, omitting the vault ID label; equivalent to using --vault-password-file. Suitable for simple scenarios or compatibility. Input: CLI command with password file; Output: Playbook decryption uses specified password file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id dev-password site.yml\n```\n\n----------------------------------------\n\nTITLE: Ensuring Package Removal with Ansible Ad Hoc Command (yum) in Bash\nDESCRIPTION: Makes sure a package ('acme') is not installed on hosts in the 'webservers' group. This uses the `ansible.builtin.yum` module with `state=absent` to remove the specified package if it exists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.yum -a \"name=acme state=absent\"\n```\n\n----------------------------------------\n\nTITLE: Setting Persistent Connection Retry Timeout via Environment Variable (Shell)\nDESCRIPTION: Demonstrates how to set the `ANSIBLE_PERSISTENT_CONNECT_RETRY_TIMEOUT` environment variable to 30 seconds. This increases the time Ansible waits before retrying a persistent connection, overriding the default value. This change is temporary and applies only to the current shell session.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_32\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_PERSISTENT_CONNECT_RETRY_TIMEOUT=30\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Ad-Hoc Commands (Shell)\nDESCRIPTION: Refers to the primary Ansible command-line tool. This command is executed on the control node to run ad-hoc tasks directly on managed nodes specified in the inventory, without requiring a playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/index.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible\n```\n\n----------------------------------------\n\nTITLE: Configuring Meraki Organization via Ansible Meraki Collection (YAML)\nDESCRIPTION: This snippet demonstrates how to use the cisco.meraki.meraki_organization module within an Ansible task to manage Meraki organizations by specifying the API authentication key, organization name, and state. It utilizes delegating the task locally to comply with the collection's connection requirement. Dependencies include the cisco.meraki Ansible collection; the \"auth_key\" parameter requires a valid Meraki Dashboard API key, \"org_name\" defines the target organization, and \"state\" controls resource presence. Outputs are subject to permission and valid API details; task execution occurs on localhost, as required by the collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_meraki.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  cisco.meraki.meraki_organization:\n    auth_key: abc12345\n    org_name: YourOrg\n    state: present\n  delegate_to: localhost\n```\n\n----------------------------------------\n\nTITLE: Preserving Specific Newlines in Folded Blocks (YAML)\nDESCRIPTION: Illustrates two methods to retain specific newlines within a folded block scalar ('>'): using blank lines or increased indentation between lines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nfold_some_newlines: >\n    a\n    b\n\n    c\n    d\n      e\n    f\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Galaxy Servers in ansible.cfg (INI)\nDESCRIPTION: This INI configuration snippet demonstrates how to define multiple Ansible Galaxy servers within the `ansible.cfg` file. It specifies a prioritized list of server names (`my_org_hub`, `release_galaxy`, `test_galaxy`, `my_galaxy_ng`) under the `[galaxy]` section using `server_list`. For each server name, a corresponding `[galaxy_server.<server_name>]` section is created to define its `url` and authentication details. Different authentication methods are shown: basic authentication (`username`, `password`), API token (`token`), and Keycloak SSO (`auth_url`, `client_id`, `token`). The `url` must end with a forward slash.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/galaxy_server_list.txt#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[galaxy]\nserver_list = my_org_hub, release_galaxy, test_galaxy, my_galaxy_ng\n\n[galaxy_server.my_org_hub]\nurl=https://automation.my_org/\nusername=my_user\npassword=my_pass\n\n[galaxy_server.release_galaxy]\nurl=https://galaxy.ansible.com/\ntoken=my_token\n\n[galaxy_server.test_galaxy]\nurl=https://galaxy-dev.ansible.com/\ntoken=my_test_token\n\n[galaxy_server.my_galaxy_ng]\nurl=http://my_galaxy_ng:8000/api/automation-hub/\nauth_url=http://my_keycloak:8080/auth/realms/myco/protocol/openid-connect/token\nclient_id=galaxy-ng\ntoken=my_keycloak_access_token\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Vault Passwords - CLI Usage (Bash)\nDESCRIPTION: Specifies multiple vault IDs and password sources when decrypting variables or files in a playbook, supporting scenarios with data encrypted under different vault IDs. The command provides a file source for 'dev' and prompts for 'prod'. Input: CLI command with multiple --vault-id options; Output: Passwords are tried in specified order, matching vault IDs where possible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id dev@dev-password --vault-id prod@prompt site.yml\n```\n\n----------------------------------------\n\nTITLE: Setting Ansible Persistent Command Timeout via Environment Variable (Bash)\nDESCRIPTION: This Bash snippet shows how to set the persistent command timeout globally for Ansible runs by exporting the `ANSIBLE_PERSISTENT_COMMAND_TIMEOUT` environment variable. The timeout is set to 30 seconds.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_connection_options.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$export ANSIBLE_PERSISTENT_COMMAND_TIMEOUT=30\n```\n\n----------------------------------------\n\nTITLE: Forcing Task 'Changed' Status to True (YAML)\nDESCRIPTION: This Ansible task demonstrates setting `changed_when: True`. Regardless of the command's actual behavior, output, or return code, this task will always be reported as having made a change ('changed' status) in Ansible's output and statistics. This will trigger any notified handlers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n  - name: This task will always report 'changed' status\n    ansible.builtin.command: /path/to/command\n    changed_when: True\n```\n\n----------------------------------------\n\nTITLE: Deleted State Final Resource Configuration Example - Text\nDESCRIPTION: This final configuration shows the effect after applying the resource module with 'deleted' state. The interface has its IP address removed, demonstrating configuration rollback to default where applicable. This underscores the use of 'deleted' state for purging specific resource settings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\ninterface loopback100\\n no ip address\n```\n\n----------------------------------------\n\nTITLE: Optimizing PowerShell Startup using Ngen in PowerShell\nDESCRIPTION: This PowerShell script defines and executes the `Optimize-Assemblies` function to pre-compile core PowerShell .NET assemblies using the Native Image Generator (`ngen.exe`). This significantly reduces PowerShell startup time, thereby decreasing the overhead for each Ansible task executed on the Windows host. Requires Administrator privileges and the .NET Framework to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_performance.rst#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nfunction Optimize-Assemblies {\n    param (\n        [string]$assemblyFilter = \"Microsoft.PowerShell.\",\n        [string]$activity = \"Native Image Installation\"\n    )\n\n    try {\n        # Get the path to the ngen executable dynamically\n        $ngenPath = [System.IO.Path]::Combine([Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory(), \"ngen.exe\")\n\n        # Check if ngen.exe exists\n        if (-Not (Test-Path $ngenPath)) {\n            Write-Host \"Ngen.exe not found at $ngenPath. Make sure .NET Framework is installed.\"\n            return\n        }\n\n        # Get a list of loaded assemblies\n        $assemblies = [AppDomain]::CurrentDomain.GetAssemblies()\n\n        # Filter assemblies based on the provided filter\n        $filteredAssemblies = $assemblies | Where-Object { $_.FullName -ilike \"$assemblyFilter*\" }\n\n        if ($filteredAssemblies.Count -eq 0) {\n            Write-Host \"No matching assemblies found for optimization.\"\n            return\n        }\n\n        foreach ($assembly in $filteredAssemblies) {\n            # Get the name of the assembly\n            $name = [System.IO.Path]::GetFileName($assembly.Location)\n\n            # Display progress\n            Write-Progress -Activity $activity -Status \"Optimizing $name\"\n\n            # Use Ngen to install the assembly\n            Start-Process -FilePath $ngenPath -ArgumentList \"install \\\"$($assembly.Location)\\\"\" -Wait -WindowStyle Hidden\n        }\n\n        Write-Host \"Optimization complete.\"\n    } catch {\n        Write-Host \"An error occurred: $_\"\n    }\n}\n\n# Optimize PowerShell assemblies:\nOptimize-Assemblies -assemblyFilter \"Microsoft.PowerShell.\"\n```\n\n----------------------------------------\n\nTITLE: Updating FQCN for Migrated Gluster Modules in community.general\nDESCRIPTION: Due to the migration of Gluster modules to the `gluster.gluster` collection, users employing Fully Qualified Collection Names (FQCNs) like `community.general.gluster_*` must update them. Change references to use the new FQCNs from the `gluster.gluster` collection (e.g., `gluster.gluster.gluster_volume`) before community.general 3.0.0 is released.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_12\n\nLANGUAGE: Ansible\nCODE:\n```\ncommunity.general.gluster_*\n```\n\n----------------------------------------\n\nTITLE: Configuring Fact and Inventory Caching Defaults in ansible.cfg (ini)\nDESCRIPTION: Shows how to set up default caching behavior for facts and inventory within the ansible.cfg file. The configuration covers default caching backend, connection path, and timeout, and separately specifies inventory cache storage location for greater granularity. Must be placed inside ansible.cfg under proper sections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_8\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\\nfact_caching = ansible.builtin.jsonfile\\nfact_caching_connection = /tmp/ansible_facts\\ncache_timeout = 3600\\n\\n[inventory]\\ncache = yes\\ncache_connection = /tmp/ansible_inventory\n```\n\n----------------------------------------\n\nTITLE: Renaming Role 'vars' Directory to 'defaults' for Lower Precedence (Bash)\nDESCRIPTION: Demonstrates changing the variable precedence within the 'system_demo' role. The `mv vars defaults` command renames the `vars` directory to `defaults`. Variables defined in `defaults/main.yml` have the lowest precedence in Ansible. The `tree` command then shows the updated role structure with the `defaults` directory instead of `vars`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible system_demo]$ mv vars defaults\n[user@ansible system_demo]$ tree\n.\n├── defaults\n│   └── main.yml\n├── tasks\n│   └── main.yml\n```\n\n----------------------------------------\n\nTITLE: Integration Testing Ansible Windows Modules - YAML\nDESCRIPTION: This YAML sequence demonstrates how to structure integration tests for a Windows module ('win_file') in an Ansible playbook. The workflow removes a file in check mode, asserts the correct state, performs the real operation, checks idempotency, and uses registered variables/assertions for validation. Dependencies are the existence of 'win_file', 'win_command', and assert modules plus an appropriate test environment and inventory. Parameters include path and state, among others; outputs are the success/failure of file removal actions and change tracking. This approach promotes robust end-to-end module validation with an emphasis on idempotency and check mode safety.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n- name: remove a file (check mode)\\n  win_file:\\n    path: C:\\\\temp\\n    state: absent\\n  register: remove_file_check\\n  check_mode: true\\n\\n- name: get result of remove a file (check mode)\\n  win_command: powershell.exe \"if (Test-Path -Path 'C:\\\\temp') { 'true' } else { 'false' }\"\\n  register: remove_file_actual_check\\n\\n- name: assert remove a file (check mode)\\n  assert:\\n    that:\\n    - remove_file_check is changed\\n    - remove_file_actual_check.stdout == 'true\\r\\n'\\n\\n- name: remove a file\\n  win_file:\\n    path: C:\\\\temp\\n    state: absent\\n  register: remove_file\\n\\n- name: get result of remove a file\\n  win_command: powershell.exe \"if (Test-Path -Path 'C:\\\\temp') { 'true' } else { 'false' }\"\\n  register: remove_file_actual\\n\\n- name: assert remove a file\\n  assert:\\n    that:\\n    - remove_file is changed\\n    - remove_file_actual.stdout == 'false\\r\\n'\\n\\n- name: remove a file (idempotent)\\n  win_file:\\n    path: C:\\\\temp\\n    state: absent\\n  register: remove_file_again\\n\\n- name: assert remove a file (idempotent)\\n  assert:\\n    that:\\n    - not remove_file_again is changed\n```\n\n----------------------------------------\n\nTITLE: Deprecating docker_container published_ports Behavior in community.docker\nDESCRIPTION: The current behavior where `published_ports` in the `docker_container` module ignores specific port mappings when the special value `all` is also present is deprecated. In community.docker 2.0.0, this combination will either be forbidden or implemented to match Docker CLI behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_10\n\nLANGUAGE: Ansible\nCODE:\n```\ndocker_container: published_ports\n```\n\n----------------------------------------\n\nTITLE: Continuous Deployment Workflow Steps for Ansible in Text\nDESCRIPTION: This plaintext bullet list summarizes a typical continuous deployment workflow using Ansible, CI/CD tools (e.g., Jenkins), and automated QA/test scripts. It outlines core stages from development to production, emphasizing automation and repeatable deploys. This is intended for process documentation and not directly executable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n- Use the same playbook all the time with embedded tests in development\n- Use the playbook to deploy to a staging environment (with the same playbooks) that simulates production\n- Run an integration test battery written by your QA team against staging\n- Deploy to production, with the same integrated tests.\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Target Dependencies (YAML)\nDESCRIPTION: Specifies that the `postgresql_info` test target depends on the `setup_postgresql_db` target by adding it to the `dependencies` list in `tests/integration/targets/postgresql_info/meta/main.yml`. This ensures the database is set up before tests run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  - setup_postgresql_db\n```\n\n----------------------------------------\n\nTITLE: Defining Roles from SCM in webserver.yml (YAML)\nDESCRIPTION: This snippet shows the content of a separate YAML file (`webserver.yml`) defining roles sourced directly from SCM repositories like GitHub and Bitbucket. It specifies the source URL (`src`) and optionally a specific version or commit (`version`). This file is intended to be included in a main `requirements.yml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n# from github\n- src: https://github.com/bennojoy/nginx\n\n# from Bitbucket\n- src: git+https://bitbucket.org/willthames/git-ansible-galaxy\n  version: v1.4\n```\n\n----------------------------------------\n\nTITLE: Rebooting Servers with Parallel Forks using Ansible Ad Hoc Command in Bash\nDESCRIPTION: Shows how to reboot servers in the 'atlanta' group while increasing the number of simultaneous processes (forks) to 10 using the `-f` flag. This can speed up execution when targeting a large number of hosts. It uses the default `command` module to run `/sbin/reboot`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible atlanta -a \"/sbin/reboot\" -f 10\n```\n\n----------------------------------------\n\nTITLE: Example Task Prone to Mismatched Error Regex (YAML)\nDESCRIPTION: A basic Ansible task using the `cisco.ios.ios_command` module to execute `show logging` on a remote device. This task might fail if the output contains strings that are incorrectly interpreted as errors by the default `stderr` regular expressions within the `ansible.netcommon.network_cli` connection plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_43\n\nLANGUAGE: yaml\nCODE:\n```\n- name: fetch logs from remote host\n  cisco.ios.ios_command:\n    commands:\n      - show logging\n```\n\n----------------------------------------\n\nTITLE: Deprecated Package Installation Loop using `with_items` in YAML\nDESCRIPTION: Shows the deprecated method in Ansible 2.6 and earlier for installing multiple packages using a loop (`with_items`) with a package module like `yum`. This relied on implicit `squash_actions` and is deprecated in Ansible 2.7, scheduled for removal in 2.11.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.7.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Install packages\n  yum:\n    name: \"{{ item }}\"\n    state: present\n  with_items: \"{{ packages }}\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Options Required Together - Ansible Python\nDESCRIPTION: This snippet defines a required_together constraint, indicating that if one of the listed arguments is present, all others in the group must also be provided. Used to ensure the consistency of combined inputs in module argument handling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nrequired_together=[\n  ('file_path', 'file_hash'),\n],\n```\n\n----------------------------------------\n\nTITLE: Creating Local Ansible Collection Directory Structure in Bash\nDESCRIPTION: Creates the necessary nested directories within the user's home directory (`~/ansible_collections/NAMESPACE/COLLECTION_NAME`) to house a specific Ansible collection for local development. This structure is standard for Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir -p ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Defining an Alternate Role Entry Point in Ansible (YAML)\nDESCRIPTION: Defines an alternate entry point named 'alternate' for an Ansible role, including its short description, detailed description, version added, and an optional integer parameter `myapp_int` with a default value. This structure is typically part of the role's `argument_specs`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n    # roles/myapp/tasks/alternate.yml entry point\n    alternate:\n      short_description: Alternate entry point for the myapp role\n      description:\n        - This is the alternate entrypoint for the C(myapp) role.\n      version_added: 1.2.0\n      options:\n        myapp_int:\n          type: \"int\"\n          required: false\n          default: 1024\n          description: \"The integer value, defaulting to 1024.\"\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_get_lcstatus Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_get_lcstatus` module is deprecated. To get the status of the Dell EMC Lifecycle Controller, use the `idrac_lifecycle_controller_status_info` module instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_37\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_get_lcstatus\n```\n\n----------------------------------------\n\nTITLE: Illustrating Disallowed Dynamic Expression Construction in Ansible\nDESCRIPTION: This Ansible playbook snippet attempts to dynamically construct a conditional expression using a template (`{{ comparison }}`). This pattern, where task argument templating previously rendered the variable into the string before evaluation, is now considered insecure and unsupported in Ansible 12, resulting in a syntax error.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_11\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname {{ comparison }} 'localhost'\n  vars:\n    comparison: ==\n```\n\n----------------------------------------\n\nTITLE: Importing Optional Dependencies Safely in Ansible Modules - Python\nDESCRIPTION: This snippet shows a robust way to import an optional Python dependency (here named 'foo') using a try/except block, tracking both the presence and import error for detailed runtime handling. This technique is used in Ansible modules to conditionally activate features if a library is available, and to report comprehensible failures if not. Dependencies: Python standard library's 'traceback' module and 'ansible.module_utils.basic.missing_required_lib' for messaging. The flags 'HAS_LIB' and 'LIB_IMP_ERR' are used later to notify users about missing requirements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport traceback\\n\\nfrom ansible.module_utils.basic import missing_required_lib\\n\\nLIB_IMP_ERR = None\\ntry:\\n    import foo\\n    HAS_LIB = True\\nexcept:\\n    HAS_LIB = False\\n    LIB_IMP_ERR = traceback.format_exc()\n```\n\n----------------------------------------\n\nTITLE: Exiting a Loop Early with 'loop_control' and 'break_when'\nDESCRIPTION: This example demonstrates conditionally breaking out of a loop using `loop_control` and `break_when`. It attempts to generate a password meeting a specific policy up to 10 times. The loop (`range(0, 10)`) uses `set_fact` to generate a password in each iteration. `break_when` checks if the generated password matches the `password_policy` regex; if it matches, the loop terminates early. A subsequent `fail` task triggers if the loop completes without generating a valid password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_25\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# main.yml\n- name: Use set_fact in a loop until a condition is met\n  vars:\n    special_characters: \"!@#$%^&*(),.?:{}|<&gt;\"\n    character_set: \"digits,ascii_letters,{{ special_characters }}\"\n    password_policy: '^(?=.*\\d)(?=.*[A-Z])(?=.*[{{ special_characters | regex_escape }}]).{12,}$'\n  block:\n    - name: Generate a password until it contains a digit, uppercase letter, and special character (10 attempts)\n      set_fact:\n        password: \"{{ lookup('password', '/dev/null', chars=character_set, length=12) }}\"\n      loop: \"{{ range(0, 10) }}\"\n      loop_control:\n        break_when:\n          - password is match(password_policy)\n\n    - fail:\n        msg: \"Maximum attempts to generate a valid password exceeded\"\n      when: password is not match(password_policy)\n```\n\n----------------------------------------\n\nTITLE: Backing Up IronWare Configuration Using Ansible Task - YAML\nDESCRIPTION: This YAML snippet provides an example of an Ansible task that backs up an IronWare switch's current configuration using the community.network.ironware_config module. The task registers the backup file location in a variable and includes a condition to ensure execution only when targeting IronWare OS devices. Dependencies include the community.network Ansible collection installed in your environment. Key parameters: 'backup: yes' initiates the configuration backup, and 'when' ensures the task runs on appropriate devices. Output is stored in the backup_ironware_location variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ironware.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (ironware)\\n  community.network.ironware_config:\\n    backup: yes\\n  register: backup_ironware_location\\n  when: ansible_network_os == 'community.network.ironware'\\n\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbook with Vault Password File\nDESCRIPTION: Shows the command to run an Ansible playbook (`first_playbook.yml`) using a specific inventory (`-i inventory`). It specifies the vault ID (`my_user`) and the path to the vault password file (`~/my-ansible-vault-pw-file`) to automatically decrypt necessary secrets during playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_12\n\nLANGUAGE: console\nCODE:\n```\nansible-playbook -i inventory --vault-id my_user@~/my-ansible-vault-pw-file first_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Extending Search Paths for Custom Modules, Utilities, and Plugins - Ansible Configuration - Bash\nDESCRIPTION: These bash code snippets specify either directory layouts or configuration variables relevant to Ansible's search path logic. The directory paths (/path/to/modules, etc.) show where custom modules, utilities, or plugins can reside adjacent to playbooks or roles, and the variables (DEFAULT_MODULE_PATH, ANSIBLE_LIBRARY, etc.) illustrate how to influence Ansible's discovery of core components via ansible.cfg or environment. Requirements are basic understanding of Unix file paths and the shell environment. Inputs are file/directory locations and environment variable settings, and outputs are Ansible's runtime behavior for loading user- or system-provided components.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/overview_architecture.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/path/to/modules\\n/path/to/module_utils\\n/path/to/plugins\n```\n\nLANGUAGE: bash\nCODE:\n```\n/path/to/subdir/modules\\n/path/to/subdir/module_utils\\n/path/to/subdir/plugins\n```\n\nLANGUAGE: bash\nCODE:\n```\n/path/to/roles/myrole/modules\\n/path/to/roles/myrole/module_utils\\n/path/to/roles/myrole/plugins\n```\n\nLANGUAGE: bash\nCODE:\n```\nDEFAULT_MODULE_PATH\\nDEFAULT_MODULE_UTILS_PATH\\nDEFAULT_CACHE_PLUGIN_PATH\\nDEFAULT_FILTER_PLUGIN_PATH\n```\n\nLANGUAGE: bash\nCODE:\n```\nANSIBLE_LIBRARY\\nANSIBLE_MODULE_UTILS\\nANSIBLE_CACHE_PLUGINS\\nANSIBLE_FILTER_PLUGINS\n```\n\n----------------------------------------\n\nTITLE: Parsing Existing Text with `cli_parse` (YAML)\nDESCRIPTION: These Ansible tasks demonstrate using the `text` parameter in `ansible.utils.cli_parse` instead of `command` to parse previously collected text. Examples show parsing text stored in a variable (`output['stdout']`, `sho_version['stdout']`) or read from a file using the `lookup` plugin. Parser context can be provided via `template_path` or `os` and `command` suboptions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_26\n\nLANGUAGE: yaml\nCODE:\n```\n   # using /home/user/templates/filename.yaml\n   - name: \"Parse text from previous task\"\n     ansible.utils.cli_parse:\n       text: \"{{ output['stdout'] }}\"\n       parser:\n         name: ansible.netcommon.native\n         template_path: /home/user/templates/filename.yaml\n\n    # using /home/user/templates/filename.yaml\n   - name: \"Parse text from file\"\n     ansible.utils.cli_parse:\n       text: \"{{ lookup('file', 'path/to/file.txt') }}\"\n       parser:\n         name: ansible.netcommon.native\n         template_path: /home/user/templates/filename.yaml\n\n   # using templates/nxos_show_version.yaml\n   - name: \"Parse text from previous task\"\n     ansible.utils.cli_parse:\n       text: \"{{ sho_version['stdout'] }}\"\n       parser:\n         name: ansible.netcommon.native\n         os: nxos\n         command: show version\n```\n\n----------------------------------------\n\nTITLE: Performing Truthiness Checks in Ansible YAML\nDESCRIPTION: Shows how to use the `truthy` and `falsy` tests (introduced in Ansible 2.10) in Ansible `when` conditions to perform Python-style truthiness evaluations on variables. These tests evaluate whether a variable is considered true or false in a boolean context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- debug:\n    msg: \"Truthy\"\n  when: value is truthy\n  vars:\n    value: \"some string\"\n\n- debug:\n    msg: \"Falsy\"\n  when: value is falsy\n  vars:\n    value: \"\"\n```\n\n----------------------------------------\n\nTITLE: Delegating Tasks Using local_action Shorthand in Ansible (YAML)\nDESCRIPTION: Demonstrates the use of the local_action shorthand for delegating tasks to the local machine in Ansible playbooks. This approach is equivalent to using delegate_to: 127.0.0.1 but has a more concise syntax for modules like command. Required: Ansible, inventory setup, and proper playbook structure. Key parameters include local_action with module and arguments. Output is task execution on the local (control) node.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# ...\n\n  tasks:\n    - name: Take out of load balancer pool\n      local_action: ansible.builtin.command /usr/bin/take_out_of_pool {{ inventory_hostname }}\n\n# ...\n\n    - name: Add back to load balancer pool\n      local_action: ansible.builtin.command /usr/bin/add_back_to_pool {{ inventory_hostname }}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Ansible Inventory Plugin Class in Python\nDESCRIPTION: This snippet demonstrates the fundamental structure for creating a custom Ansible inventory plugin in Python. It involves importing the `BaseInventoryPlugin` class and defining a new class `InventoryModule` that inherits from it. The `NAME` attribute is crucial for Ansible to identify the plugin, typically matching the filename (e.g., `myplugin.py`). For plugins within collections, the NAME should follow the format 'namespace.collection_name.myplugin'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.inventory import BaseInventoryPlugin\n\nclass InventoryModule(BaseInventoryPlugin):\n\n    NAME = 'myplugin'  # used internally by Ansible, it should match the file name but not required\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Task via NX-API Connection on Cisco NXOS (YAML)\nDESCRIPTION: Example Ansible task using the `cisco.nxos.nxos_config` module to back up the current configuration of a Cisco NXOS device via an NX-API connection. This task assumes an NX-API connection (`ansible.netcommon.httpapi`) is configured. It passes the `proxy_env` variable (defined in group vars) to the task's `environment` parameter to handle connections through a web proxy. It sets `backup: yes`, registers the output, and runs conditionally.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nxos.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (nxos)\n  cisco.nxos.nxos_config:\n    backup: yes\n  register: backup_nxos_location\n  environment: \"{{ proxy_env }}\"\n  when: ansible_network_os == 'cisco.nxos.nxos'\n```\n\n----------------------------------------\n\nTITLE: Executing Modules in Action Plugins with _execute_module (Python)\nDESCRIPTION: Demonstrates how to invoke an Ansible module from within an action plugin using _execute_module, passing the module name, its arguments, task variables, and optional tmp directory. Returns results from the called module for further processing. Requires ActionBase context; module_name, module_args, and task_vars are the expected parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmodule_return = self._execute_module(module_name='<NAME_OF_MODULE>',\n                                         module_args=module_args,\n                                         task_vars=task_vars, tmp=tmp)\n```\n\n----------------------------------------\n\nTITLE: Configuring CNOS Network CLI Connection in Ansible (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to set up group variables for connecting to CNOS devices via Ansible CLI using the community.network.cnos integration. It sets required parameters such as the network OS, user credentials, privilege escalation (Enable Mode), and SSH proxying for bastion hosts. Dependencies include the community.network Ansible collection and configuration of vault or plaintext credentials as needed. Inputs include user, password, become method, and optional SSH proxy settings; outputs will be the ability to execute later tasks against CNOS devices securely.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_cnos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: community.network.cnos\\nansible_user: myuser\\nansible_password: !vault...\\nansible_become: true\\nansible_become_method: enable\\nansible_become_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Defining an Ansible Inventory File for Remote Hosts (YAML)\nDESCRIPTION: This YAML snippet defines an Ansible inventory file named 'hosts.yml'. It creates an inventory group called 'ee_testing' and adds a single host, 'node1.example.com', to this group. This file is used to specify the target hosts for remote playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_execution_environment.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\nall:\n  children:\n    ee_testing:\n      hosts:\n        node1.example.com:\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Inline Inventory Source in Ansible (Bash)\nDESCRIPTION: This snippet shows how to provide a comma-separated list of hosts directly as an inventory source using the `-i` command-line option in Ansible. This method is considered 'direct assignment' and has the same precedence as file-based sources specified with `-i`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n-i host1, host2, host3\n```\n\n----------------------------------------\n\nTITLE: Example Structured Fact Output from 'cli_parse' (YAML)\nDESCRIPTION: Illustrates the structured YAML data format (an Ansible fact named `interfaces`) produced by the `ansible.utils.cli_parse` module after applying the native parser template (`nxos_show_interface.yaml`) to the `show interface` command output. It represents the parsed information in a hierarchical key-value structure, making it easily usable in subsequent Ansible tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nEthernet1/1:\n    hardware: 100/1000/10000 Ethernet\n    mac_address: 5254.005a.f8bd\n    name: Ethernet1/1\n    state:\n    admin: up\n    operating: up\nEthernet1/10:\n    hardware: 100/1000/10000 Ethernet\n    mac_address: 5254.005a.f8c6\n# ...\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Vault Encrypted Variable Output\nDESCRIPTION: Displays the typical output format generated by `ansible-vault encrypt_string`. It shows the variable name (`ansible_password`), the `!vault` YAML tag, vault metadata (version 1.2, AES256 algorithm, user ID 'my_user'), and the encrypted ciphertext string. This format is intended for use in YAML files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nansible_password: !vault |\n       $ANSIBLE_VAULT;1.2;AES256;my_user\n       66386134653765386232383236303063623663343437643766386435663632343266393064373933\n       3661666132363339303639353538316662616638356631650a316338316663666439383138353032\n       63393934343937373637306162366265383461316334383132626462656463363630613832313562\n       3837646266663835640a313164343535316666653031353763613037656362613535633538386539\n       65656439626166666363323435613131643066353762333232326232323565376635\nEncryption successful\n```\n\n----------------------------------------\n\nTITLE: Listing Inventory Structure with Ansible CLI - bash\nDESCRIPTION: This command lists all inventory hosts and groups in JSON format. It uses the 'ansible-inventory' tool, specifying the inventory file with '-i'. Ensure 'ansible' is installed and configured. The command outputs a full parsed tree of the inventory file structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-inventory -i inventory.ini --list\n```\n\n----------------------------------------\n\nTITLE: Direct Invocation of Ansible Module for Local Testing (Shell)\nDESCRIPTION: Shows how to run a Python module directly with an arguments JSON file for debugging. Assumes module is located at library/my_test.py and will process parameters from /tmp/args.json. Useful when bypassing Ansible's core runtime and CLI for rapid, isolated testing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\npython library/my_test.py /tmp/args.json\n```\n\n----------------------------------------\n\nTITLE: Testing Module Output and System State with Ansible Playbook (YAML)\nDESCRIPTION: This playbook demonstrates how to test a PostgreSQL module with Ansible's community.postgresql.postgresql_user. It creates a user, checks the module's output for expected results, verifies the actual state via a query module, and asserts state consistency using the 'assert' task. Prerequisites include the community.postgresql Ansible collection and access to a PostgreSQL database. Inputs are playbook parameters; outputs are assertion results that confirm both module-reported and actual system changes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_about.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Create PostgreSQL user and store module's output to the result variable\\n  community.postgresql.postgresql_user:\\n    name: test_user\\n  register: result\\n\\n- name: Check the module returns what we expect\\n  assert:\\n    that:\\n      - result is changed\\n\\n- name: Check actual system state with another module, in other words, that the user exists\\n  community.postgresql.postgresql_query:\\n    query: SELECT * FROM pg_authid WHERE rolename = 'test_user'\\n  register: query_result\\n\\n- name: We expect it returns one row, check it\\n  assert:\\n    that:\\n      - query_result.rowcount == 1\n```\n\n----------------------------------------\n\nTITLE: Creating Documentation Navigation with Toctree - Sphinx/reStructuredText\nDESCRIPTION: This snippet uses the reStructuredText syntax with Sphinx-specific directives to build a Table of Contents (toctree) for roadmap documents in the Ansible documentation project. It defines a section header, applies the toctree directive with options for maximum depth and pattern matching, and specifies three sub-index files for inclusion. Dependencies include Sphinx for processing directives and a compatible documentation build environment. The snippet requires referenced files (e.g., ansible_roadmap_index) to exist and expects an English documentation context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/roadmap/index.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _roadmaps:\n\nRoadmaps\n===============\n\n.. toctree::\n   :maxdepth: 1\n   :glob:\n\n   ansible_roadmap_index\n   ansible_core_roadmap_index\n   old_roadmap_index\n```\n\n----------------------------------------\n\nTITLE: Defining CLI Inventory Variables for CloudEngine OS in Ansible (INI)\nDESCRIPTION: This snippet provides a sample Ansible inventory group variable configuration for connecting to CloudEngine OS devices via CLI using SSH. It sets connection type, network OS identifier, user credentials, and SSH tunneling through a bastion (jump host) if required. Key variables include 'ansible_connection', 'ansible_network_os', and authentication parameters. Remove 'ansible_password' if using SSH keys; adjust 'ansible_ssh_common_args' only when a jump host is required. The expected input is an inventory file section, and it does not perform runtime operations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[ce:vars]\nansible_connection=ansible.netcommon.network_cli\nansible_network_os=community.network.ce\nansible_user=myuser\nansible_password=!vault...\nansible_ssh_common_args='-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Deprecating nxos_smu Module in Ansible NX-OS\nDESCRIPTION: The `nxos_smu` module is deprecated. Users should migrate to using the `nxos_rpm` module for managing software maintenance upgrades (SMUs) on Cisco NX-OS devices.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_7\n\nLANGUAGE: Ansible\nCODE:\n```\nnxos_smu\n```\n\n----------------------------------------\n\nTITLE: Defining the Legacy `run` Method in Ansible Vars Plugins (Python)\nDESCRIPTION: This Python snippet shows the signature of the `run` method, which was the primary execution point for legacy Ansible vars plugins (prior to Ansible 2.4). This method was called during inventory construction and had limitations, such as not receiving vault passwords.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n    def run(self, name, vault_password=None):\n        pass # your code goes here\n```\n\n----------------------------------------\n\nTITLE: Running Destructive Integration Tests in Fedora Container via ansible-test in Shell\nDESCRIPTION: This command executes destructive integration tests using ansible-test in a containerized Fedora 34 environment. Destructive tests can install or remove trivial packages and are intended for test environments, not production. The 'destructive/' argument specifies which test set to run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration destructive/ --docker fedora34\n```\n\n----------------------------------------\n\nTITLE: Delegating Task Execution to Implicit Localhost in Ansible (YAML)\nDESCRIPTION: This Ansible playbook snippet demonstrates delegating a task (`stat` module) to run on the control node using `delegate_to: localhost`. If 'localhost' is not defined in the inventory, Ansible implicitly creates it to execute this task locally. The task checks for the existence of a log file specific to each host in the `all` group on the local machine.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory/implicit_localhost.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  tasks:\n    - name: check that i have log file for all hosts on my local machine\n      stat: path=/var/log/hosts/{{inventory_hostname}}.log\n      delegate_to: localhost\n```\n\n----------------------------------------\n\nTITLE: Setting Ansible Persistent Command Timeout in ansible.cfg (INI)\nDESCRIPTION: This INI snippet illustrates configuring the default command timeout globally within the Ansible configuration file (`ansible.cfg`). The `command_timeout` option under the `[persistent_connection]` section is set to 30 seconds.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_connection_options.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\ncommand_timeout = 30\n```\n\n----------------------------------------\n\nTITLE: Creating Nested (Parent/Child) Groups (YAML)\nDESCRIPTION: Illustrates how to create parent/child group relationships (nested groups) in a YAML inventory using the `children:` key. This simplifies management by grouping existing groups (e.g., `east` under `prod`, `west` under `test`). Hosts in child groups are automatically members of the parent group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nungrouped:\n  hosts:\n    mail.example.com:\nwebservers:\n  hosts:\n    foo.example.com:\n    bar.example.com:\ndbservers:\n  hosts:\n    one.example.com:\n    two.example.com:\n    three.example.com:\neast:\n  hosts:\n    foo.example.com:\n    one.example.com:\n    two.example.com:\nwest:\n  hosts:\n    bar.example.com:\n    three.example.com:\nprod:\n  children:\n    east:\ntest:\n  children:\n    west:\n```\n\n----------------------------------------\n\nTITLE: Rendered MOTD Output from Template - Text - Sample Output\nDESCRIPTION: This snippet shows the expected contents of /etc/motd after rendering the motd.j2 template with dynamic variables via Ansible. It confirms the variable substitution mechanism; inputs are rendered variables a, b, c from dynamic inventory, and output is the MOTD file’s visible content for each host. No execution is needed; this is output verification.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nWelcome, I am templated with a value of a=2, b=3, and c=4\n```\n\n----------------------------------------\n\nTITLE: Defining Native Parser Template Rules for Linux 'ip addr' Output\nDESCRIPTION: Defines rules within an Ansible native parser template to extract interface properties (properties string, MTU, state, IP address, mask bits) from the output of the Linux `ip addr show` command. It uses regular expressions (free-spacing mode enabled via `(?x)`) to capture values and maps them to a structured dictionary using Jinja2 templating. The `shared: True` key allows the interface name (`{{ name }}`) to be reused across subsequent parsing rules within the same template.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n       <(?P<properties>\\S+)>                               # the properties\n       \\smtu\\s(?P<mtu>\\d+)                                 # the mtu\n       .*                                                  # gunk\n       state\\s(?P<state>\\S+)                               # the state of the interface\n     result:\n       \"{{ name }}\":\n           name: \"{{ name }}\"\n           loopback: \"{{ 'LOOPBACK' in stats.split(',') }}\"\n           up: \"{{ 'UP' in properties.split(',')  }}\"\n           carrier: \"{{ not 'NO-CARRIER' in properties.split(',') }}\"\n           broadcast: \"{{ 'BROADCAST' in properties.split(',') }}\"\n           multicast: \"{{ 'MULTICAST' in properties.split(',') }}\"\n           state: \"{{ state|lower() }}\"\n           mtu: \"{{ mtu }}\"\n     shared: True\n\n   - example: 'inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0'\n     getval: |\n      (?x)                                                 # free-spacing\n      \\s+inet\\s(?P<inet>([0-9]{1,3}\\.){3}[0-9]{1,3})       # the ip address\n      /(?P<bits>\\d{1,2})                                   # the mask bits\n     result:\n       \"{{ name }}\":\n           ip_address: \"{{ inet }}\"\n           mask_bits: \"{{ bits }}\"\n```\n\n----------------------------------------\n\nTITLE: Installing Minimal Ansible Core Package on Fedora Linux (Bash)\nDESCRIPTION: Installs only the minimal 'ansible-core' package, containing the essential Ansible command-line tools, modules, and engine, on Fedora Linux using the DNF package manager. Requires root privileges (sudo). Collections need to be installed separately.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo dnf install ansible-core\n```\n\n----------------------------------------\n\nTITLE: Registering argcomplete Per Command with eval - Shell\nDESCRIPTION: Enables shell completion for specific Ansible commands individually by evaluating 'register-python-argcomplete' for each. Intended when global bash completion (bash >= 4.2) is unavailable. Place these eval commands in your shell profile (like ~/.profile or ~/.bash_profile) for persistent effect. Each command enables shell completion for a single Ansible utility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_26\n\nLANGUAGE: console\nCODE:\n```\n$ eval $(register-python-argcomplete ansible)\n$ eval $(register-python-argcomplete ansible-config)\n$ eval $(register-python-argcomplete ansible-console)\n$ eval $(register-python-argcomplete ansible-doc)\n$ eval $(register-python-argcomplete ansible-galaxy)\n$ eval $(register-python-argcomplete ansible-inventory)\n$ eval $(register-python-argcomplete ansible-playbook)\n$ eval $(register-python-argcomplete ansible-pull)\n$ eval $(register-python-argcomplete ansible-vault)\n```\n\n----------------------------------------\n\nTITLE: Gathering EOS Device Facts Using Provider Dictionary (YAML)\nDESCRIPTION: Shows the updated approach for network modules in Ansible 2.3, using a provider dictionary to encapsulate transport and authentication details for devices. This method is required for latest network modules. Key parameters are 'provider' dictionary with connection details and 'gather_subset' controlling scope of fact collection. Output is structured EOS device facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.3.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Gather facts\\n  eos_facts:\\n    gather_subset: all\\n    provider:\\n      username: myuser\\n      password: \\\"{{ networkpassword }}\\\"\\n      transport: cli\\n      host: \\\"{{ ansible_host }}\\\"\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Collection Metadata Template (Jinja)\nDESCRIPTION: This Jinja template (galaxy.yml.j2) provides a flexible way to define a collection's metadata for initialization with ansible-galaxy. Template variables like namespace, collection_name, version, and dependencies are substituted at generation time, allowing customization via extra-vars or CLI input. The primary input is the skeleton initialization context; the output is a filled-in galaxy.yml file for the new collection. Requires Ansible 2.17+ for extended variable templating.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_creating.rst#_snippet_1\n\nLANGUAGE: jinja\nCODE:\n```\nnamespace: {{ namespace }}\nname: {{ collection_name }}\nversion: {{ (version|quote) is version('0.0.0', operator='gt', version_type='semver')|ternary(version, undef('version must be a valid semantic version greater than 0.0.0')) }}\ndependencies: {{ dependencies | default({}, true) }}\n```\n\n----------------------------------------\n\nTITLE: Setting Up an IIS Website Using win_dsc and win_psmodule - Ansible YAML+Jinja\nDESCRIPTION: Contains a comprehensive workflow for preparing an IIS site: installing required DSC modules, enabling features, pushing website contents, and configuring both HTTP and HTTPS bindings with authentication info. Tasks highlight use of yaml structures for bindings and attributes. Suitable for deploying a basic IIS web service with Windows DSC resources.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_14\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Install xWebAdministration module\n  win_psmodule:\n    name: xWebAdministration\n    state: present\n\n- name: Install IIS features that are required\n  win_dsc:\n    resource_name: WindowsFeature\n    Name: '{{ item }}'\n    Ensure: Present\n  loop:\n  - Web-Server\n  - Web-Asp-Net45\n\n- name: Setup web content\n  win_dsc:\n    resource_name: File\n    DestinationPath: C:\\inetpub\\IISSite\\index.html\n    Type: File\n    Contents: |\n      <html>\n      <head><title>IIS Site</title></head>\n      <body>This is the body</body>\n      </html>\n    Ensure: present\n\n- name: Create new website\n  win_dsc:\n    resource_name: xWebsite\n    Name: NewIISSite\n    State: Started\n    PhysicalPath: C:\\inetpub\\IISSite\\index.html\n    BindingInfo:\n    - Protocol: https\n      Port: 8443\n      CertificateStoreName: My\n      CertificateThumbprint: C676A89018C4D5902353545343634F35E6B3A659\n      HostName: DSCTest\n      IPAddress: '*'\n      SSLFlags: 1\n    - Protocol: http\n      Port: 8080\n      IPAddress: '*'\n    AuthenticationInfo:\n      Anonymous: false\n      Basic: true\n      Digest: false\n      Windows: true\n```\n\n----------------------------------------\n\nTITLE: Custom Webserver Group Variables - Ansible YAML\nDESCRIPTION: Defines Apache configuration variables for the 'webservers' group, such as maximum requests and client capacity. Save as group_vars/webservers to scope these values to group hosts. These variables are consumed in roles, playbooks, or templates for group-specific configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/tips_tricks/sample_setup.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: group_vars/webservers\\napacheMaxRequestsPerChild: 3000\\napacheMaxClients: 900\n```\n\n----------------------------------------\n\nTITLE: Specifying Local Connection via Command Line (Shell)\nDESCRIPTION: Shows the command-line option `-c local` passed to the `ansible` command. This flag instructs Ansible to use the 'local' connection plugin, meaning it will execute the requested module or task locally instead of connecting to remote hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n-c local\n```\n\n----------------------------------------\n\nTITLE: Defining Required-if Argument Relationships in Ansible Modules (Python)\nDESCRIPTION: This snippet configures the `required_if` parameter within an Ansible module's argument specification, establishing conditional requirements based on specific states or boolean flags. Dependencies such as the base `AnsibleModule` are assumed. When `state` is 'present', at least one of `path` or `content` is required, while if `force` is true, `force_reason` and `force_code` are mandated. Inputs are option values in the module's parameters; the assignment output serves validation enforcement. Mutually exclusive logic should be layered for exclusivity constraints.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nrequired_if=[\n  ('state', 'present', ('path', 'content'), True),\n  ('force', True, ('force_reason', 'force_code')),\n],\n```\n\n----------------------------------------\n\nTITLE: Listing Directory Structure for a Standalone Ansible Role in Bash\nDESCRIPTION: This bash snippet illustrates the typical directory layout for a standalone Ansible role named 'my-standalone-role.webapp'. It shows all standard role subdirectories, providing a template for creating or inspecting role structures before migration. No dependencies; used as reference for copying or comparing role contents prior to migration to collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nmy-standalone-role.webapp\n├── defaults\n├── files\n├── handlers\n├── library\n├── meta\n├── tasks\n├── templates\n├── tests\n└── vars\n```\n\n----------------------------------------\n\nTITLE: Invalid YAML: Unquoted Special Characters in Flow Mapping\nDESCRIPTION: Illustrates invalid YAML within a flow collection (using {}). Special characters like '{', '[', ',', '}' require quoting when used as literal values within flow style mappings or sequences.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_19\n\nLANGUAGE: text\nCODE:\n```\na scalar in block mapping: this } is [ all , valid\n\nflow mapping: { key: \"you { should [ use , quotes here\" }\n```\n\n----------------------------------------\n\nTITLE: Running Ad Hoc Command in Check Mode with Ansible in Bash\nDESCRIPTION: Executes an Ansible ad hoc command using the `copy` module, but includes the `-C` (or `--check`) flag for check mode. In this mode, Ansible reports the changes it *would* make (like creating `/root/bar.txt` with content 'foo') without actually modifying the remote systems.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$  ansible all -m copy -a \"content=foo dest=/root/bar.txt\" -C\n```\n\n----------------------------------------\n\nTITLE: Manipulating Unicode Filenames as Strings Without Filesystem Access - Python\nDESCRIPTION: Demonstrates manipulation of Unicode filenames purely as strings (text), avoiding OS/file IO, for safe composition and splitting. Relies on os.path.join and os.path.split with only Unicode string arguments. All manipulations stay in memory as Python str objects and do not require explicit conversion as long as no filesystem operations are involved. No dependencies on Ansible utilities are required for this snippet.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport os.path\n\nos.path.join(u'/var/tmp/caf\\u00e9', u'くらとみ')\nos.path.split(u'/var/tmp/caf\\u00e9/くらとみ')\n```\n\n----------------------------------------\n\nTITLE: Performing Set Theory Tests (Subset/Superset) in Ansible YAML\nDESCRIPTION: Shows how to use the `subset` and `superset` tests (introduced in Ansible 2.1, renamed from `issubset`/`issuperset` in 2.5) to perform set comparisons between lists within Ansible `when` conditions. `superset(b)` checks if list `a` contains all elements of list `b`, while `subset(a)` checks if list `b` is contained within list `a`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n    a: [1,2,3,4,5]\n    b: [2,3]\ntasks:\n    - debug:\n        msg: \"A includes B\"\n      when: a is superset(b)\n\n    - debug:\n        msg: \"B is included in A\"\n      when: b is subset(a)\n```\n\n----------------------------------------\n\nTITLE: Using local_action with Arguments in Ansible (YAML)\nDESCRIPTION: Shows how to provide detailed arguments to local_action for sending a summary email using the community.general.mail module. Demonstrates structured local_action with module argument, and parameters such as subject, to, and body; run_once ensures task runs only once. Dependencies: community.general.mail collection and Ansible email configuration. Inputs: mail_recipient, mail_body variables. Output: Email sent upon play execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# ...\n\n  tasks:\n    - name: Send summary mail\n      local_action:\n        module: community.general.mail\n        subject: \"Summary Mail\"\n        to: \"{{ mail_recipient }}\"\n        body: \"{{ mail_body }}\"\n      run_once: True\n```\n\n----------------------------------------\n\nTITLE: Running Scripts in Ansible While Disabling Check Mode in YAML\nDESCRIPTION: This snippet shows how to run a script in Ansible with check mode disabled for that specific task, even if the playbook is executed with the --check flag. It demonstrates the 'script' module usage and setting 'check_mode: false' to ensure certain tasks (like verification scripts) always execute during both normal and check runs. Dependencies include the Ansible environment with a defined 'roles' structure and accessible script files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nroles:\n  - webserver\n\ntasks:\n  - ansible.builtin.script: verify.sh\n    check_mode: false\n```\n\n----------------------------------------\n\nTITLE: Parsing Linux 'ip addr show' Output with Native Parser in Ansible\nDESCRIPTION: This Ansible task uses the `ansible.utils.cli_parse` module to execute the `ip addr show` command on a target host. It then parses the output using the `ansible.netcommon.native` parser, which relies on a pre-defined template (like the one shown previously) determined by the host's `ansible_distribution` fact or specified via `parser/template_path`. The parsed, structured data is registered as an Ansible fact named `interfaces` using `set_fact`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run command and parse\n  ansible.utils.cli_parse:\n    command: ip addr show\n    parser:\n      name: ansible.netcommon.native\n  set_fact: interfaces\n```\n\n----------------------------------------\n\nTITLE: Gathering VLAN Facts from Cisco IOS Device - YAML\nDESCRIPTION: This snippet shows an Ansible playbook step that retrieves VLAN information from a Cisco IOS device as structured data using cisco.ios.ios_facts. Required dependencies include the proper Ansible collection, and it uses the 'gather_network_resources' option to filter for VLAN-related data. Outputs are typically used for backup or further configuration steps.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Gather VLAN information as structured data\\n  cisco.ios.ios_facts:\\n     gather_subset:\\n      - '!all'\\n      - '!min'\\n     gather_network_resources:\\n     - 'vlans'\n```\n\n----------------------------------------\n\nTITLE: Running a Task Once per Batch using Run_once in Ansible Playbook (YAML)\nDESCRIPTION: Uses the 'run_once: true' directive in a playbook task to execute a command solely on the first host of the current batch, with results and facts broadcast to all hosts in that batch. This is particularly useful for upgrade tasks or shared initialization. Requires no extra dependencies, but the operation is performed only once per serial batch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# ...\\n\\n  tasks:\\n\\n    # ...\\n\\n    - command: /opt/application/upgrade_db.py\\n      run_once: true\\n\\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Verifying Configuration After Overriding Role Defaults (Bash)\nDESCRIPTION: Shows the verification command `show run | include name-server` executed on the 'rtr2' Cisco router. The output confirms that the IP name server is configured as `1.1.1.1`, reflecting the value provided in the playbook's `vars` section, successfully overriding the default value from the role.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nrtr2#sh run | i name-server\nip name-server 1.1.1.1\n```\n\n----------------------------------------\n\nTITLE: Defining FRR Connection Variables in Ansible Group Vars (YAML)\nDESCRIPTION: This YAML snippet shows example Ansible group variables (`group_vars/frr.yml`) for connecting to FRR devices using the `network_cli` connection. It sets the connection type (`ansible.netcommon.network_cli`), network OS (`frr.frr.frr`), user credentials (using Ansible Vault for the password), and optional SSH arguments for connecting via a bastion host (`ProxyCommand`). The `ansible_user` must belong to the `frrvty` group with `/bin/vtysh` as the default shell.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_frr.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n   ansible_connection: ansible.netcommon.network_cli\n   ansible_network_os: frr.frr.frr\n   ansible_user: frruser\n   ansible_password: !vault...\n   ansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Configuring NETCONF Inventory for IOS-XR in Ansible (INI)\nDESCRIPTION: Declares group or host variables for connecting to IOS-XR devices using NETCONF. The ansible_connection is set to netconf, with credentials and SSH proxy options for bastion support. To use this, ensure the ncclient Python package is installed and that NETCONF is enabled on the device. Store these variables in your inventory as required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_iosxr.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[iosxr:vars]\\nansible_connection=ansible.netcommon.netconf\\nansible_network_os=cisco.iosxr.iosxr\\nansible_user=myuser\\nansible_password=!vault |\\nansible_ssh_common_args='-o ProxyCommand=\\\"ssh -W %h:%p -q bastion01\\\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Ansible cli_parser Plugin in a Task (YAML)\nDESCRIPTION: This YAML snippet shows how to utilize a custom `cli_parser` plugin within an Ansible task. It uses the `ansible.netcommon.cli_parse` module to execute a command (`ls -l`) on the target host and process its output. The `parser` key specifies the custom plugin to use, identified by its fully qualified collection name (FQCN) `my_organiztion.my_collection.custom_parser` under the `name` sub-key. This directs the `cli_parse` module to invoke the `parse` method of the specified custom plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Use a custom cli_parser\n  ansible.netcommon.cli_parse:\n    command: ls -l\n    parser:\n      name: my_organiztion.my_collection.custom_parser\n```\n\n----------------------------------------\n\nTITLE: Illustrating Network Interface Facts Gathered by Ansible using YAML\nDESCRIPTION: This YAML block shows an example of the structured data returned when using `gather_network_resources: interfaces` with a fact-gathering module like `arista.eos.eos_facts`. The facts are nested under `network_resources.interfaces` and contain a list of dictionaries, each representing an interface with its configured properties (name, description, enabled status, MTU, etc.). This structured data can be easily consumed by subsequent Ansible tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n      \"network_resources\": {\n            \"interfaces\": [\n                {\n                    \"description\": \"test-interface\",\n                    \"enabled\": true,\n                    \"mtu\": \"512\",\n                    \"name\": \"Ethernet1\"\n                },\n                {\n                    \"enabled\": true,\n                    \"mtu\": \"3000\",\n                    \"name\": \"Ethernet2\"\n                },\n                {\n                    \"enabled\": true,\n                    \"name\": \"Ethernet3\"\n                },\n                {\n                    \"enabled\": true,\n                    \"name\": \"Ethernet4\"\n                },\n                {\n                    \"enabled\": true,\n                    \"name\": \"Ethernet5\"\n                },\n                {\n                    \"enabled\": true,\n                    \"name\": \"Ethernet6\"\n                },\n            ]\n        }\n```\n\n----------------------------------------\n\nTITLE: Using ansible-galaxy collection install Command (Ansible CLI)\nDESCRIPTION: Refers to the `ansible-galaxy collection install` command, specifically mentioning its capability to upgrade collections from Galaxy servers using the `--upgrade` option.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_29\n\nLANGUAGE: plaintext\nCODE:\n```\nansible-galaxy collection install\n```\n\n----------------------------------------\n\nTITLE: Configuring IronWare Ansible Connection Settings - YAML\nDESCRIPTION: This YAML snippet demonstrates how to configure group or host variables for connecting to IronWare devices in Ansible. It includes key parameters such as ansible_connection, ansible_network_os, authentication details, privilege escalation with Enable Mode, and optional SSH bastion settings. Required dependencies include the community.network collection and an Ansible environment with network_cli support. All parameters should be set based on your network topology and security requirements. Remove unnecessary parameters if you do not use bastion hosts or password-based authentication.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ironware.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: community.network.ironware\\nansible_user: myuser\\nansible_password: !vault...\\nansible_become: true\\nansible_become_method: enable\\nansible_become_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Fixing Multi-Pass Templating by Using Direct Variable Reference in Ansible\nDESCRIPTION: This Ansible playbook snippet shows the corrected way to use variables within expressions, avoiding the multi-pass templating error. Instead of embedding `{{ value }}`, the variable `value` is referenced directly within the expression `1 + value == 2`, which is the standard and secure way.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: 1 + value == 2\n  vars:\n    value: 1\n```\n\n----------------------------------------\n\nTITLE: Handler Limitations Regarding Imports, Roles, and Tags - Ansible Documentation - Markdown\nDESCRIPTION: This part lists handler limitations in Ansible, clarifying that handlers cannot execute import_role or include_role. It also references the behavior of handlers with tags, linking to further documentation about tag handling. This information is essential for users needing to design handler logic with the correct operational exceptions in mind.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\nA handler cannot run ``import_role`` nor ``include_role``.\nHandlers :ref:`ignore tags <tags_on_handlers>`.\n```\n\n----------------------------------------\n\nTITLE: Ansible Playbook Output with Serial Batching (Output)\nDESCRIPTION: This snippet shows Ansible output when running a playbook with a serial batch size of 3. It illustrates how tasks are executed in two distinct passes, and the PLAY RECAP displays results per host. There are no dependencies or parameters beyond those specified in the playbook; this output format is standard for successful, multi-batch runs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_4\n\nLANGUAGE: ansible-output\nCODE:\n```\nPLAY [webservers] ***********************************************************************\\n\\nTASK [first task] ***********************************************************************\\nchanged: [web1]\\nchanged: [web3]\\nchanged: [web2]\\n\\nTASK [second task] **********************************************************************\\nchanged: [web1]\\nchanged: [web2]\\nchanged: [web3]\\n\\nPLAY [webservers] ***********************************************************************\\n\\nTASK [first task] ***********************************************************************\\nchanged: [web4]\\nchanged: [web5]\\nchanged: [web6]\\n\\nTASK [second task] **********************************************************************\\nchanged: [web4]\\nchanged: [web5]\\nchanged: [web6]\\n\\nPLAY RECAP ******************************************************************************\\nweb1                       : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\\nweb2                       : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\\nweb3                       : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\\nweb4                       : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\\nweb5                       : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\\nweb6                       : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n```\n\n----------------------------------------\n\nTITLE: Rewriting Playbook Conditionals for Security in Ansible YAML\nDESCRIPTION: This YAML playbook snippet demonstrates how to avoid unsafe embedded template expressions in conditional checks, following security improvements in ansible-core 2.16.1. It highlights the transition from using Jinja2 templated expressions referencing untrusted module results to a more secure approach where results are accessed directly as variables. Dependencies include Ansible 9 or later, and the example shows registering a shell task result and then using it securely in an assert statement. Inputs are regular Ansible playbook tasks, and output is assert task validation; ensure variables are not referenced with Jinja curly braces inside 'that' conditions when referencing untrusted data.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_9.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  - name: task with a module result (always untrusted by Ansible)\\n    shell: echo \\\"hi mom\\\"\\n    register: untrusted_result\\n\\n  # don't do it this way...\\n  # - name: insecure conditional with embedded template consulting untrusted data\\n  #   assert:\\n  #     that: '\\\"hi mom\\\" is in {{ untrusted_result.stdout }}'\\n\\n  - name: securely access untrusted values directly as Jinja variables instead\\n    assert:\\n      that: '\\\"hi mom\\\" is in untrusted_result.stdout'\\n\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Unit Test File in Ansible Collections\nDESCRIPTION: Executes a single, specified unit test file (`tests/unit/plugins/module_utils/foo/test_bar.py`) for Python 3.6 using `ansible-test units`. The command runs within a default Docker container (`--docker default`) with verbose output (`-v`) and targets the specified test file and Python version (`--python 3.6`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_testing.rst#_snippet_3\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-test units --docker default -v --python 3.6 tests/unit/plugins/module_utils/foo/test_bar.py\n```\n\n----------------------------------------\n\nTITLE: Disabling User Account Control (UAC) on Windows and Rebooting with Ansible - YAML\nDESCRIPTION: This sequence disables UAC (User Account Control) by modifying the relevant registry setting using 'win_regedit', followed by an optional reboot if the setting was changed. It first alters 'EnableLUA' in the registry to '0', then triggers a system reboot only when the change is detected. Ansible connectivity with privilege to edit the registry and reboot is required. Disabling UAC can introduce security risks, and tasks must be executed with caution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n- name: turn UAC off\\n  win_regedit:\\n    path: HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\n    name: EnableLUA\\n    data: 0\\n    type: dword\\n    state: present\\n  register: uac_result\n```\n\nLANGUAGE: yaml\nCODE:\n```\n- name: reboot after disabling UAC\\n  win_reboot:\\n  when: uac_result is changed\n```\n\n----------------------------------------\n\nTITLE: Inventory Plugin-Specific Caching Configuration (yaml)\nDESCRIPTION: Illustrates how to enable inventory caching for a specific plugin using options such as cache_plugin, cache_timeout, cache_connection, and cache_prefix in a YAML inventory source file. This allows persistent local storage for discovered hosts and metadata. The cache_plugin (e.g., ansible.builtin.jsonfile) and cache_timeout are required parameters for persistent caching within the stated directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# demo.aws_ec2.yml\\nplugin: amazon.aws.aws_ec2\\ncache: true\\ncache_plugin: ansible.builtin.jsonfile\\ncache_timeout: 7200\\ncache_connection: /tmp/aws_inventory\\ncache_prefix: aws_ec2\n```\n\n----------------------------------------\n\nTITLE: Exception Handling Compatibility Refactor - Ansible Python\nDESCRIPTION: These snippets demonstrate the transition from using the deprecated get_exception() utility for capturing exceptions to standard direct exception assignment in Python. The first example shows legacy code using get_exception(), and the second shows the corrected modern pattern where the exception is directly assigned in the except block. Dependencies include the Ansible module_utils.pycompat24.get_exception (deprecated). Inputs are raised exceptions and outputs are function calls with the exception object; applicable when updating code to drop support for old Python versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-get-exception.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Unfixed code:\ntry:\n    raise IOError('test')\nexcept IOError:\n    e = get_exception()\n    do_something(e)\nexcept:\n    e = get_exception()\n    do_something_else(e)\n```\n\nLANGUAGE: python\nCODE:\n```\n# After fixing:\ntry:\n    raise IOError('test')\nexcept IOErrors as e:\n    do_something(e)\nexcept Exception as e:\n    do_something_else(e)\n```\n\n----------------------------------------\n\nTITLE: Command Timeout Triggered Log Output - Plain Text\nDESCRIPTION: Displays a log output example from Ansible when the command execution exceeds the persistent command timeout limit (default is 30 seconds), leading to a timeout error message. Used for troubleshooting long-running tasks and adjusting timing parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_26\n\nLANGUAGE: text\nCODE:\n```\n2017-04-04 12:19:05,670 p=18591 u=fred |  command timeout triggered, timeout value is 30 secs\n```\n\n----------------------------------------\n\nTITLE: Specifying Collection Signatures in requirements.yml for Ansible\nDESCRIPTION: This YAML snippet demonstrates the structure of a `requirements.yml` file used by `ansible-galaxy collection install -r`. It lists a collection (`ns.coll`) with a specific version (`1.0.0`) and includes a `signatures` key. This key contains a list of URIs (local file paths or URLs) pointing to detached GPG signature files (`.asc`) that will be used for verification during installation, in addition to any signatures provided by the distribution server.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n# requirements.yml\ncollections:\n  - name: ns.coll\n    version: 1.0.0\n    signatures:\n      - https://examplehost.com/detached_signature.asc\n      - file:///path/to/local/detached_signature.asc\n```\n\n----------------------------------------\n\nTITLE: Example Debug Output for Non-Compliant Interfaces (Text)\nDESCRIPTION: Illustrates the output generated by the second task in the validation playbook, which iterates through the errors captured by the `ansible.utils.validate` module. For each error found in the `result['errors']` list, it prints the name of the interface ('Ethernet2/1' and 'Ethernet2/10') that failed the validation check, extracted from the `data_path` field within each error item. This provides a clear list of non-compliant interfaces.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/validate.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nTASK [Print the interface names that do not satisfy the desired state] ****************************************************************************\nMonday 14 December 2020  11:05:38 +0530 (0:00:01.661)       0:00:28.676 *******\nok: [nxos] => {\n   \"msg\": \"Ethernet2/1\"\n}\nok: [nxos] => {\n   \"msg\": \"Ethernet2/10\"\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Fact Gathering in Ansible Plays (YAML)\nDESCRIPTION: Shows the Ansible playbook directive `gather_facts: False` used within a play. Setting this to `False` skips the implicit fact gathering phase for that play, which can speed up execution if the play's tasks do not require host facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ngather_facts: False\n```\n\n----------------------------------------\n\nTITLE: Example Inventory for Junos with Netconf Connection (INI)\nDESCRIPTION: Shows a sample Ansible inventory file configuring a Junos device (`junos01`). It specifies the connection type as `ansible.netcommon.netconf`, the network OS as `junipernetworks.junos.junos`, the username, and references a vaulted password. This inventory works in conjunction with SSH configuration (like ProxyCommand) for accessing devices.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_40\n\nLANGUAGE: ini\nCODE:\n```\n[junos]\njunos01\n\n[junos:vars]\nansible_connection=ansible.netcommon.netconf\nansible_network_os=junipernetworks.junos.junos\nansible_user=myuser\nansible_password=!vault...\n```\n\n----------------------------------------\n\nTITLE: Executing Arbitrary Scripts on Remote Hosts with Ansible Script Module in YAML\nDESCRIPTION: These tasks leverage the 'ansible.builtin.script' module to run arbitrary scripts (in any language) on remote hosts, with automatic failure handling on non-zero exit codes. The snippet illustrates passing parameters directly to the script. Scripts should reside in accessible locations or under the role's files/ directory. Inputs: script path and parameters; Outputs: success/failure according to script result.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n\n  - ansible.builtin.script: test_script1\n  - ansible.builtin.script: test_script2 --parameter value --parameter2 value\n```\n\n----------------------------------------\n\nTITLE: Initializing Ansible Module and Invoking Hyper-V in PowerShell\nDESCRIPTION: This snippet demonstrates initializing an Ansible-style module in PowerShell, setting required parameters with specific choices, creating the module object, invoking a Hyper-V function using module parameters, and then returning the module's result using ExitJson. Requires PowerShell, Ansible module emulation via Ansible.Basic, and Hyper-V functions to be defined in the context. The state parameter restricts acceptable values to 'present' or 'absent'. Intended for use in custom Ansible modules on Windows hosts with Hyper-V integration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_12\n\nLANGUAGE: powershell\nCODE:\n```\n  state = @{ required = $true; choices = @(\"present\", \"absent\") }\n}\n$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)\n\nInvoke-HyperVFunction -Name $module.Params.name\n\n$module.ExitJson()\n```\n\n----------------------------------------\n\nTITLE: Specifying the Group Variables Directory (Text/Path)\nDESCRIPTION: Indicates the directory name `group_vars/` relative to an Ansible inventory file. This directory contains YAML files named after inventory groups, providing a convenient way to define variables, especially complex ones, for all hosts within a specific group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ngroup_vars/\n```\n\n----------------------------------------\n\nTITLE: Example Network Device 'show interface' Output (Console)\nDESCRIPTION: Shows sample output from the `show interface` command on a network device (likely Cisco NXOS). This semi-structured text is the input that the `cli_parse` module with a native template will process.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nEthernet1/1 is up\nadmin state is up, Dedicated Interface\n  Hardware: 100/1000/10000 Ethernet, address: 5254.005a.f8bd (bia 5254.005a.f8bd)\n  MTU 1500 bytes, BW 1000000 Kbit, DLY 10 usec\n  reliability 255/255, txload 1/255, rxload 1/255\n  Encapsulation ARPA, medium is broadcast\n  Port mode is access\n  full-duplex, auto-speed\n  Beacon is turned off\n  Auto-Negotiation is turned on  FEC mode is Auto\n  Input flow-control is off, output flow-control is off\n  Auto-mdix is turned off\n  Switchport monitor is off\n  EtherType is 0x8100\n  EEE (efficient-ethernet) : n/a\n  Last link flapped 4week(s) 6day(s)\n  Last clearing of \"show interface\" counters never\n<...>\n```\n\n----------------------------------------\n\nTITLE: Replaced State Final Resource Configuration Example - Text\nDESCRIPTION: This snippet shows the configuration resulting from applying the Ansible resource module with 'replaced' state. It demonstrates the removal of the existing IP address while retaining and adding IPv6 addresses to the interface. This helps illustrate differences between 'merged' and 'replaced' behaviors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ninterface loopback100\\n no ip address\\n ipv6 address FC00:100/64\\n ipv6 address FC00:101/64\n```\n\n----------------------------------------\n\nTITLE: Return Value Change in utm_proxy_auth_profile Module (Ansible)\nDESCRIPTION: Notes a change in the `utm_proxy_auth_profile` module (`community.general`). The `frontend_cookie_secret` return value now contains a placeholder string instead of echoing the module's input parameter value.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_21\n\nLANGUAGE: ansible\nCODE:\n```\nutm_proxy_auth_profile\n```\n\n----------------------------------------\n\nTITLE: Handling Mocked Module Exits with Custom Exceptions in Python Unit Tests\nDESCRIPTION: This Python unit test snippet illustrates handling mocked Ansible module exits. It defines a custom exception `AnsibleExitJson`. A `MagicMock` represents the module, and its `exit_json` method is configured with `side_effect` to raise `AnsibleExitJson`. The test uses `assertRaises` to catch this exception when `my_module.test_this_function` is called, verifying the expected successful exit path. It also asserts `fail_json` was not called and checks the returned results.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n  class AnsibleExitJson(Exception):\n      \"\"\"Exception class to be raised by module.exit_json and caught by the test case\"\"\"\n      pass\n\n  # you may also do the same to fail json\n  module = MagicMock()\n  module.exit_json.side_effect = AnsibleExitJson(Exception)\n  with self.assertRaises(AnsibleExitJson) as result:\n      results = my_module.test_this_function(module, argument)\n  module.fail_json.assert_not_called()\n  assert results[\"changed\"] == True\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: msg\nDESCRIPTION: Shows an example of the `msg` return key, which provides a general-purpose string message relayed from the module to the user, often indicating the result or status of the operation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n\"msg\": \"line added\"\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Ansible Modules in Unit Tests - Python\nDESCRIPTION: Illustrates importing necessary utilities and calling 'set_module_args' to inject arguments into an Ansible module under test. This setup bypasses STDIN and injects parameters as a dictionary directly, facilitating argument handling in unit tests for modules that normally read from STDIN. Requires the 'set_module_args' helper and dependencies such as 'json' and 'to_bytes'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport json\\nfrom units.modules.utils import set_module_args\\nfrom ansible.module_utils.common.text.converters import to_bytes\\n\\ndef test_already_registered(self):\\n    set_module_args({\\n        'activationkey': 'key',\\n        'username': 'user',\\n        'password': 'pass',\\n    })\n```\n\n----------------------------------------\n\nTITLE: Sharing Variable Values with YAML Anchors and Aliases in Ansible (YAML)\nDESCRIPTION: Demonstrates using YAML anchors (`&jvm_opts`) to define a reusable block of variables and aliases (`*jvm_opts`) along with the merge operator (`<<`) to inherit these values in another variable structure within an Ansible playbook's `vars` section. This allows common configuration (`opts`, `port`) to be shared between `app1` and `app2`, while allowing specific overrides (`path`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_advanced_syntax.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\n# ...\nvars:\n  app1:\n    jvm: &jvm_opts\n      opts: '-Xms1G -Xmx2G'\n      port: 1000\n      path: /usr/lib/app1\n  app2:\n    jvm:\n      <<: *jvm_opts\n      path: /usr/lib/app2\n# ...\n```\n\n----------------------------------------\n\nTITLE: Formatting Command Names: cd Example\nDESCRIPTION: Provides 'cd' as an example of a command name that should be written in lowercase when referring specifically to the change directory command.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/spelling_word_choice.rst#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\ncd\n```\n\n----------------------------------------\n\nTITLE: Collecting and Reporting Code Coverage with ansible-test - Shell\nDESCRIPTION: These shell commands illustrate how to collect, generate, and manage code coverage information when running Ansible unit tests. They leverage the --coverage flag and various report format commands to produce coverage data in HTML, console, or XML format. The commands also include erasing coverage data between runs. Outputs may be files or console reports, and results are written to specific directories.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units --coverage apt\\nansible-test coverage html\n```\n\n----------------------------------------\n\nTITLE: Expected Output from Ansible Module Execution (JSON)\nDESCRIPTION: Provides the prototypical output JSON returned by an Ansible module after successful execution. Demonstrates the presence of changed, state (with result messages), and invocation/module_args fields. This schema helps users validate correct module behavior during manual or automated testing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\"changed\": true, \"state\": {\"original_message\": \"hello\", \"new_message\": \"goodbye\"}, \"invocation\": {\"module_args\": {\"name\": \"hello\", \"new\": true}}}\n```\n\n----------------------------------------\n\nTITLE: Corrected Conditional Referencing Defined Attribute (Ansible)\nDESCRIPTION: This Ansible task shows the corrected `failed_when` conditional for the `stat` module result. It correctly accesses the `exists` attribute via `result.stat.exists`. This resolves the undefined variable issue present in the previous example.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_19\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - stat:\n        path: /does-not-exist\n      register: result\n      failed_when: result.stat.exists is false\n```\n\n----------------------------------------\n\nTITLE: SSH Known Hosts Pre-population using ssh-keyscan - Shell\nDESCRIPTION: Runs 'ssh-keyscan' to fetch the public SSH host key from a network device and add it to the local known_hosts file, avoiding failed host key verification for automated Ansible connections. This command is used prior to playbook execution where host key acceptance is needed non-interactively. Only SSH client tools are required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\nssh-keyscan veos01\n```\n\n----------------------------------------\n\nTITLE: Running Collection-Based Ansible Module (Shell)\nDESCRIPTION: Demonstrates the invocation of an Ansible module bundled inside a collection using the ansible CLI. The -m argument specifies the FQCN (fully qualified collection name) for the module; --playbook-dir ensures playbook search path correctness. Used for validation of module integration inside a collection structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nansible localhost -m my_namespace.my_collection.my_test -a 'name=hello new=true' --playbook-dir=$PWD\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Playbook for Module Testing (YAML)\nDESCRIPTION: An annotated YAML playbook that demonstrates how to invoke and register the results of a custom module. Declares a play for localhost, uses the custom my_test module with arguments, registers output, and then dumps the result using debug. Requires Ansible playbook runtime and the custom module to be present in the library directory in the same folder as the playbook.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- name: test my new module\n  hosts: localhost\n  tasks:\n  - name: run the new module\n    my_test:\n      name: 'hello'\n      new: true\n    register: testout\n  - name: dump test output\n    debug:\n      msg: '{{ testout }}'\n```\n\n----------------------------------------\n\nTITLE: Using Local Action for Control Node Execution (YAML)\nDESCRIPTION: Refers to the `local_action` keyword in Ansible playbooks. This keyword is an alias for `delegate_to: localhost` and is used to redirect the execution of a specific task from the remote target host to the Ansible control node.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nlocal_action\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON Output with Ansible cli_parse\nDESCRIPTION: This Ansible task demonstrates using `ansible.utils.cli_parse` to parse command output that is already in JSON format. It executes `show interface | json` on the target device and uses the `ansible.utils.json` parser to convert the JSON string into Ansible native data structures. The result is registered into the `interfaces` variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- name: \"Run command and parse as json\"\n  ansible.utils.cli_parse:\n    command: show interface | json\n    parser:\n      name: ansible.utils.json\n    register: interfaces\n```\n\n----------------------------------------\n\nTITLE: Comparing PEP-440 Versions using Jinja in Ansible\nDESCRIPTION: Illustrates how to compare version strings using Python PEP-440 rules with the `version` test by setting `version_type='pep440'` (available since Ansible 2.14). This example demonstrates comparing a pre-release ('2.14.0rc1') with a final release ('2.14.0').\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_11\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n\"{{ '2.14.0rc1' is version('2.14.0', 'lt', version_type='pep440') }}\"\n```\n\n----------------------------------------\n\nTITLE: Limiting Loop Output Verbosity with 'loop_control' and 'label'\nDESCRIPTION: This task demonstrates using `loop_control` with the `label` directive to customize the output displayed for each loop iteration. Instead of showing the entire complex dictionary for each item, it only displays the value of the `item.name` field, making the console output more concise when looping over complex data structures like creating servers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_23\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Create servers\n  digital_ocean:\n    name: \"{{ item.name }}\"\n    state: present\n  loop:\n    - name: server1\n      disks: 3gb\n      ram: 15Gb\n      network:\n        nic01: 100Gb\n        nic02: 10Gb\n        # ...\n  loop_control:\n    label: \"{{ item.name }}\"\n```\n\n----------------------------------------\n\nTITLE: Restarting Webservers via Ad Hoc Command - Ansible (Bash)\nDESCRIPTION: This example uses an ad hoc Ansible command to restart the httpd service on all hosts in the 'webservers' group. The command leverages the 'service' module with options specifying the service name and desired state. Dependencies include an Ansible installation and an inventory group named 'webservers'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible webservers -m service -a \"name=httpd state=restarted\"\n```\n\n----------------------------------------\n\nTITLE: Configuring VOSS Group Variables for Ansible network_cli Connection in YAML\nDESCRIPTION: Provides an example YAML configuration for Ansible group variables (`group_vars/voss.yml`) specific to Extreme VOSS devices. It sets essential parameters like the connection type (`ansible.netcommon.network_cli`), network OS (`community.network.voss`), user, password (using Ansible Vault), enables privilege escalation (`ansible_become: true`, `ansible_become_method: enable`), and optionally configures an SSH proxy command for bastion host access. Note that `ansible_password` can be omitted if using SSH keys, and `ansible_ssh_common_args` is only needed for bastion/jump host access.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_voss.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: community.network.voss\nansible_user: myuser\nansible_become: true\nansible_become_method: enable\nansible_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Limiting Host Execution with Command-Line Option (Shell)\nDESCRIPTION: Shows the `--limit` command-line option used with `ansible` or `ansible-playbook`. This option restricts the execution of the command or playbook to a specific subset of hosts or groups defined in the inventory (e.g., `--limit somegroup`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n--limit somegroup\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Ansible cli_parser Plugin in Python\nDESCRIPTION: This Python code snippet demonstrates the basic structure for a custom `cli_parser` plugin within an Ansible collection. It defines a `CliParser` class inheriting from `CliParserBase`, sets template handling options (`DEFAULT_TEMPLATE_EXTENSION`, `PROVIDE_TEMPLATE_CONTENTS`), includes a placeholder `myparser` function for custom logic, and implements the standard `parse` entry point. The `parse` method handles text input (`text`) and template content (`template_contents`), calls the custom parser, and returns a dictionary containing either structured data under the 'parsed' key or errors under the 'errors' key. Required dependencies include `CliParserBase` from `ansible.netcommon`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible_collections.ansible.netcommon.plugins.module_utils.cli_parser.cli_parserbase import (\n    CliParserBase,\n)\n\nclass CliParser(CliParserBase):\n    \"\"\" Sample cli_parser plugin\n    \"\"\"\n\n    # Use the follow extension when loading a template\n    DEFAULT_TEMPLATE_EXTENSION = \"txt\"\n    # Provide the contents of the template to the parse function\n    PROVIDE_TEMPLATE_CONTENTS = True\n\n    def myparser(text, template_contents):\n      # parse the text using the template contents\n      return {...}\n\n    def parse(self, *_args, **kwargs):\n        \"\"\" Standard entry point for a cli_parse parse execution\n\n        :return: Errors or parsed text as structured data\n        :rtype: dict\n\n        :example:\n\n        The parse function of a parser should return a dict:\n        {\"errors\": [a list of errors]}\n        or\n        {\"parsed\": obj}\n        \"\"\"\n        template_contents = kwargs[\"template_contents\"]\n        text = self._task_args.get(\"text\")\n        try:\n            parsed = myparser(text, template_contents)\n        except Exception as exc:\n            msg = \"Custom parser returned an error while parsing. Error: {err}\"\n            return {\"errors\": [msg.format(err=to_native(exc))]}\n        return {\"parsed\": parsed}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fact Cache Plugin in ansible.cfg using INI\nDESCRIPTION: Specifies the fact cache plugin within the `[defaults]` section of the `ansible.cfg` file using the `fact_caching` parameter. This example configures Ansible to use the `redis` cache plugin. This setting is applied unless overridden by the `ANSIBLE_CACHE_PLUGIN` environment variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nfact_caching=redis\n```\n\n----------------------------------------\n\nTITLE: Setting Global ProxyCommand via Environment Variable (Shell)\nDESCRIPTION: Shows how to configure `ProxyCommand` globally for all Ansible SSH connections by setting the `ANSIBLE_SSH_ARGS` environment variable. This directs connections through the specified bastion host (`bastion01`), providing a system-wide proxy configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_38\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_SSH_ARGS='-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Initialize Ansible Collection Skeleton (Bash CLI)\nDESCRIPTION: Command to create a new collection skeleton via the Ansible Galaxy CLI. Requires `ansible-galaxy` tool and optionally a Galaxy namespace set up. Input is the namespace and collection name, output is a generated directory tree scaffold.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy collection init mynamespace.mycollection\\n\n```\n\n----------------------------------------\n\nTITLE: Listing Installed Roles using ansible-galaxy Command (Bash)\nDESCRIPTION: This Bash command shows how to use `ansible-galaxy role list` to display all Ansible roles currently installed in the configured `roles_path`. The output typically includes the role's namespace, name, and installed version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role list\n  - namespace-1.foo, v2.7.2\n  - namespace2.bar, v2.6.2\n```\n\n----------------------------------------\n\nTITLE: Ansible Playbook Utilizing a Role with Embedded Modules (YAML)\nDESCRIPTION: An Ansible playbook demonstrating how to use a role ('my_custom_modules') that contains embedded custom modules. Subsequent roles in the play ('some_other_role_using_my_custom_modules', etc.) can also use these embedded modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_27\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - my_custom_modules\n    - some_other_role_using_my_custom_modules\n    - yet_another_role_using_my_custom_modules\n```\n\n----------------------------------------\n\nTITLE: Creating a Facts Module in Ansible (Python)\nDESCRIPTION: Shows how to add custom facts to the result with the `ansible_facts` key using module.exit_json. This illustrates the required structure for a facts module, which must not alter the system and should set changed to False. This relies on Ansible's Python-based module API and requires importing the AnsibleModule helper from the appropriate utility location. Expects value_of_fact to have been calculated prior; output is a result JSON dict with ansible_facts populated.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmodule.exit_json(changed=False, ansible_facts=dict(my_new_fact=value_of_fact))\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests with ansible-test and Docker - Text Command\nDESCRIPTION: This code snippet demonstrates the general command-line syntax for executing integration tests using the 'ansible-test integration' command with Docker support. The '<target_name>' parameter should be replaced with the directory of the test target role, and '<distro>' should specify the container image (distribution) to use for testing. The output is shown in generic text format and requires Docker and ansible-test to be properly set up.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_running.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nansible-test integration <target_name> --docker <distro>\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Role Multiple Times (Implicitly Once) (YAML)\nDESCRIPTION: An Ansible playbook defining hosts and listing the role 'foo' twice. By default, Ansible only runs a role once per play, even if listed multiple times, unless parameters differ or `allow_duplicates` is true.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - foo\n    - bar\n    - foo\n```\n\n----------------------------------------\n\nTITLE: Using the 'print' Command in Ansible Debugger (Ansible Output)\nDESCRIPTION: This output demonstrates the use of the `print` (or `p`) command within the Ansible debugger. It shows how to inspect the current task definition (`p task`), task arguments (`p task.args`), available variables (`p task_vars`, `p task_vars['pkg_name']`), the target host (`p host`), and the result of the last task execution (`p result._result`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_9\n\nLANGUAGE: ansible-output\nCODE:\n```\n[192.0.2.10] TASK: install package (debug)> p task\nTASK: install package\n[192.0.2.10] TASK: install package (debug)> p task.args\n{u'name': u'{{ pkg_name }}'}\n[192.0.2.10] TASK: install package (debug)> p task_vars\n{u'ansible_all_ipv4_addresses': [u'192.0.2.10'],\n u'ansible_architecture': u'x86_64',\n ...\n}\n[192.0.2.10] TASK: install package (debug)> p task_vars['pkg_name']\nu'bash'\n[192.0.2.10] TASK: install package (debug)> p host\n192.0.2.10\n[192.0.2.10] TASK: install package (debug)> p result._result\n{'_ansible_no_log': False,\n 'changed': False,\n u'failed': True,\n ...\n u'msg': u\"No package matching 'not_exist' is available\"}\n```\n\n----------------------------------------\n\nTITLE: Defining NETCONF Inventory for Junos OS Ansible Integration (INI)\nDESCRIPTION: Specifies Ansible inventory group variables for connecting to Junos OS devices via the netconf connection. Essential variables include connection type, network OS, credentials, and optional SSH arguments for bastion host use. Prepares Ansible to leverage NETCONF modules for configuration management tasks after the feature is enabled on the device.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_junos.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[junos:vars]\\nansible_connection=ansible.netcommon.netconf\\nansible_network_os=junipernetworks.junos.junos\\nansible_user=myuser\\nansible_password=!vault |\\nansible_ssh_common_args='-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Identifying Ansible Collection Content with FQCN\nDESCRIPTION: This snippet shows an example of a Fully Qualified Collection Name (FQCN) used in Ansible, specifically `cisco.ios.ios_config`. The first part (`cisco`) is the namespace, identifying the source or category (often a vendor), and the rest specifies the collection and the specific content (like a module). FQCNs are used in playbooks to unambiguously reference modules, roles, or plugins from installed collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_23\n\nLANGUAGE: ansible-identifier\nCODE:\n```\ncisco.ios.ios_config\n```\n\n----------------------------------------\n\nTITLE: Enabling NETCONF on CloudEngine OS with Ansible CLI Connection (YAML)\nDESCRIPTION: This playbook task enables the NETCONF server on a CloudEngine OS device via a CLI connection, using the community.network.ce_config module to send the configuration command. It is intended to be run before switching the device to NETCONF-based management. Prerequisites include having 'ncclient' installed on the control node(s) and a CLI connection properly configured. The 'lines' parameter contains the configuration commands to enable NETCONF functionality.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Enable NETCONF\n  connection: ansible.netcommon.network_cli\n  community.network.ce_config:\n    lines:\n      - snetconf server enable\n  when: ansible_network_os == 'community.network.ce'\n```\n\n----------------------------------------\n\nTITLE: Using ArgumentSpecValidator Class in Ansible Modules (Python/Ansible)\nDESCRIPTION: Introduces the `ArgumentSpecValidator` class in Ansible Core for validating argument specifications. Modules previously using private methods for argument spec validation should now use this class or appropriate validation functions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nArgumentSpecValidator\n```\n\n----------------------------------------\n\nTITLE: Rebooting Servers in Playbook - Ansible - YAML\nDESCRIPTION: Shows how to issue a command module in an Ansible playbook to reboot servers. The '- name' field serves as task documentation, and the 'command' field holds the shell command. Requires playbook execution context and proper inventory setup. No extra arguments are given beyond the reboot command. No input parameters, output is standard Ansible task result in JSON. This pattern applies to playbook tasks invoking system commands.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/module_plugin_guide/modules_intro.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: reboot the servers\n  command: /sbin/reboot -t now\n```\n\n----------------------------------------\n\nTITLE: Referencing module.fail_json() Method\nDESCRIPTION: Stub documentation reference for the `fail_json()` method, typically called on an `AnsibleModule` instance (`module`) to exit the module execution with a failure status and return structured JSON data.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_20\n\nLANGUAGE: rst\nCODE:\n```\n.. py:method:: module.fail_json()\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Defaults with Jinja in Ansible 2.8\nDESCRIPTION: Demonstrates the simplified syntax in Ansible 2.8 for accessing potentially undefined nested attributes using the `default` filter. Due to changes in how Jinja handles undefined values, accessing an attribute of an Undefined value now returns another Undefined value, allowing direct use of `default` on the final attribute.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ foo.bar.baz | default('DEFAULT') }}\n```\n\n----------------------------------------\n\nTITLE: Removing Existing Integration Test Targets (Bash)\nDESCRIPTION: Removes all existing integration test targets within the `tests/integration/targets/` directory. This command simulates a scenario where no integration tests exist, allowing the user to follow the guide for creating tests from scratch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf tests/integration/targets/*\n```\n\n----------------------------------------\n\nTITLE: Invalid YAML: Escape Sequence in Single-Quoted String\nDESCRIPTION: Shows invalid YAML syntax attempting to use an escape sequence (\\' for a single quote) within a single-quoted string. Escape sequences are only processed in double-quoted strings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nfoo: \"an escaped \\' single quote\"\n```\n\n----------------------------------------\n\nTITLE: Jinja Test as Condition (Preferred) - Ansible Playbook YAML\nDESCRIPTION: This snippet demonstrates the preferred syntax in Ansible 2.5+, using Jinja tests as conditions directly: 'result is failed', 'results is not successful'. This eliminates ambiguity between filters and tests, ensuring consistent condition evaluation. Expects result variables as input; produces a Boolean for conditionals. No extra dependencies, but requires Ansible 2.5+ for correct deprecation handling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nwhen:\n    - result is failed\n    - results is not successful\n```\n\n----------------------------------------\n\nTITLE: Re-tagging and Publishing a Release if Publication Fails - Bash\nDESCRIPTION: Sequence of commands to re-tag and attempt republishing a release in case the initial publishing does not appear in Ansible Galaxy. It deletes the problematic tag locally and remotely, then re-creates and pushes it. Inputs: tag version and message; Outputs: retried publication. Requires push permissions and integration with Zuul or similar CI.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit tag --delete NEW_VERSION\\ngit push upstream :NEW_VERSION\\ngit tag -a NEW_VERSION -m \"comment here\"    # the comment can be, for example, \"community.foo: 2.0.0\"\\ngit push upstream NEW_VERSION\n```\n\n----------------------------------------\n\nTITLE: Importing from Ansible Collections Init File in Python\nDESCRIPTION: This Python snippet shows how to import a custom base class from a __init__.py file inside an Ansible collection's callback plugin. It demonstrates the use of absolute import paths when working with collection plugins and indicates the organization required for Python packaging within Ansible collections. Requires the ansible_collections Python path context and a CustomBaseClass defined in the referenced __init__.py file. Used for extending callback plugins with shared logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible_collections.ansible_example.community.plugins.callback.__init__ import CustomBaseClass\n```\n\n----------------------------------------\n\nTITLE: Gathering and Filtering Custom Facts with Ansible Setup Module (Shell)\nDESCRIPTION: This shell command runs the ansible.builtin.setup module via the Ansible command line interface to gather facts from the specified host and filter the results to only include the ansible_local namespace (custom facts from facts.d). Requires ansible CLI to be installed and available, as well as inventory access to <hostname>. Outputs gathered facts as JSON. Replace <hostname> with the actual host name.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nansible <hostname> -m ansible.builtin.setup -a \"filter=ansible_local\"\n```\n\n----------------------------------------\n\nTITLE: Writing Changelog Fragment Template - YAML Format\nDESCRIPTION: This YAML fragment provides the required structure for a changelog entry in 'changelogs/fragments/X.Y.Z.yml'. The 'release_summary' is a multiline string written in reStructuredText format, intended for integration into the collection's changelog. No dependencies beyond following the format are necessary, and the fragment should be customized for each release.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrelease_summary: |-\\n  Write some text here that should appear as the release summary for this version.\\n  The format is reStructuredText, but not a list as for regular changelog fragments.\\n  This text will be inserted into the changelog.\n```\n\n----------------------------------------\n\nTITLE: Ansible Playbook for Debugging Python Interpreter Discovery\nDESCRIPTION: This YAML+Jinja snippet presents an Ansible playbook designed to help debug Python interpreter discovery on a target host ('test_11'). It runs the 'which python' command to find the Python path used by the system and then uses the debug module to display this path and all Ansible variables containing 'python' in their names.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# playbook.yml\n- hosts: test_11\n  gather_facts: false\n  tasks:\n    - command: which python\n      register: result\n    - debug:\n        var: result.stdout\n    - debug:\n        msg: |-\n          {% for i in _vars %}\n          {{ i }}:\n            {{ lookup('vars', i)|to_nice_yaml|indent(2) }}\n          {% endfor %}\n      vars:\n        _vars: \"{{ query('varnames', '.*python.*') }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible NETVISOR CLI Connection - YAML\nDESCRIPTION: This snippet demonstrates how to configure Ansible host group variables to connect to a Pluribus NETVISOR device using SSH via the 'ansible.netcommon.network_cli' connection plugin. It specifies the network OS, user credentials, and optionally sets SSH proxy parameters for bastion hosts. Dependencies include the Ansible 'community.network' and 'ansible.netcommon' collections. Replace 'ansible_password' and 'ansible_ssh_common_args' as needed depending on authentication and network access requirements. Input: YAML variables; Output: configuration used by Ansible to establish CLI sessions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netvisor.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: community.netcommon.netvisor\\nansible_user: myuser\\nansible_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Network Device Privilege Error in Ansible\nDESCRIPTION: Displays a typical error message from a network device indicating that the attempted command requires privileged execution mode (often called 'enable' mode). This signifies that the Ansible task needs `become: true` and `become_method: enable` to succeed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\nInvalid input (privileged mode required)\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Changelog Minor Change Entry (lineinfile) in YAML\nDESCRIPTION: Provides a sample YAML 'minor_changes' entry for the 'lineinfile' module within an Ansible changelog fragment. It illustrates adding a warning for empty regexp usage, adhering to the scoped entry format including the relevant issue link.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nminor_changes:\n  - lineinfile - add warning when using an empty regexp (https://github.com/ansible/ansible/issues/29443).\n```\n\n----------------------------------------\n\nTITLE: New Module fortios_monitor_fact in fortinet.fortios (Ansible)\nDESCRIPTION: Announces the addition of the new module `fortios_monitor_fact` to the `fortinet.fortios` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_50\n\nLANGUAGE: ansible\nCODE:\n```\nfortios_monitor_fact\n```\n\n----------------------------------------\n\nTITLE: Declaring JSON Arguments Placeholder in Python\nDESCRIPTION: This Python snippet demonstrates how a JSONARGS module defines a variable to capture module arguments. The special string `<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>` acts as a placeholder that Ansible replaces with a JSON string containing the actual arguments before executing the module on the target node. The use of triple quotes (`\"\"\"`) is recommended to handle potential quote characters within the injected JSON string.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\njson_arguments = \"\"\"<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Git Repository Structure: Single Collection (Text)\nDESCRIPTION: Illustrates a typical Git repository structure where the `galaxy.yml` metadata file resides at the top level, alongside plugin directories (`plugins/`) and other files. This structure indicates a single collection within the repository, which `ansible-galaxy` searches for by default.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_git_repo.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n├── galaxy.yml\n├── plugins/\n│   ├── lookup/\n│   ├── modules/\n│   └── module_utils/\n└─── README.md\n```\n\n----------------------------------------\n\nTITLE: Defining Breaking Changes in Ansible Changelog Fragments (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to structure the `breaking_changes` section within an Ansible changelog fragment file (`changelogs/fragments/*.yaml`). This section is mandatory for changes that alter existing behavior and require users to update their playbooks or roles. The example shows a change related to `ansible-test` where automatic requirement installation for cloud plugins is removed, guiding users towards using integration test requirements files instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nbreaking_changes:\n  - ansible-test - automatic installation of requirements for cloud test plugins no longer occurs. The affected test plugins are ``aws``, ``azure``, ``cs``, ``hcloud``, ``nios``, ``opennebula``, ``openshift`` and ``vcenter``. Collections should instead use one of the supported integration test requirements files, such as the ``tests/integration/requirements.txt`` file (https://github.com/ansible/ansible/pull/75605).\n```\n\n----------------------------------------\n\nTITLE: Example Success Output from Ansible Ad-Hoc Command (Bash/JSON)\nDESCRIPTION: Shows sample output from a successful Ansible ad-hoc command execution against `localhost`. The output is in JSON format and indicates success (`SUCCESS =>`), providing details like cache status and whether any changes were made (`\"changed\": false`). This type of output would follow a command like the package installation example.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nlocalhost | SUCCESS => {\n\"cache_update_time\": 1709959287,\n\"cache_updated\": false,\n\"changed\": false\n#...\n```\n\n----------------------------------------\n\nTITLE: Mocking get_resource_connection_facts in Python Unit Tests\nDESCRIPTION: This snippet demonstrates using `unittest.mock.patch` to mock the `get_resource_connection` method from the `ansible.netcommon` collection's module utils. It replaces the original method with a mock object (`self.mock_get_resource_connection_facts`) and starts the patch, assigning the mock to `self.get_resource_connection_facts` for use within a test case.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n\"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.facts.facts.get_resource_connection\"\n)\nself.get_resource_connection_facts = (self.mock_get_resource_connection_facts.start())\n```\n\n----------------------------------------\n\nTITLE: Specifying Host Aliases and Connection Parameters in INI - Ansible Inventory - Text\nDESCRIPTION: Shows the use of host aliases and custom connection parameters in INI inventory, mapping a short alias to an IP with a custom port. This enhances inventory readability and flexibility. No external dependencies; inputs are alias, ansible_port, and ansible_host per host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\njumper ansible_port=5555 ansible_host=192.0.2.50\n```\n\n----------------------------------------\n\nTITLE: Updating Playbook Templating for Arithmetic/Concatenation in Ansible 2.13 (YAML)\nDESCRIPTION: Illustrates the required syntax change for performing arithmetic or concatenation operations within Ansible playbook templating starting from version 2.13. Operations previously allowed partially outside Jinja expressions must now be fully enclosed within `{{ }}`. The example shows list concatenation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.13.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Prior to 2.13\n  debug:\n    msg: '[1] + {{ [2] }}'\n\n- name: 2.13 and forward\n  debug:\n    msg: '{{ [1] + [2] }}'\n```\n\n----------------------------------------\n\nTITLE: Conditional Task Execution Based on Defined Variables (YAML)\nDESCRIPTION: This Ansible task uses `ansible.builtin.shell` to echo a message. Its execution depends on a `when` condition (which is incomplete in the provided source text but intended to use the variables defined previously). To evaluate string variables like 'yes' or 'on' as booleans in conditionals, the `| bool` filter is required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n    - name: Run the command if \"epic\" or \"monumental\" is true\n      ansible.builtin.shell: echo \"This certainly is epic!\"\n```\n\n----------------------------------------\n\nTITLE: Task-Provided L3 Interface Configuration - YAML\nDESCRIPTION: This YAML snippet presents the configuration section used in an Ansible task to update an interface resource. The configuration includes IPv6 addresses and logical interface names. The snippet demonstrates how configuration data should be structured as input to the Ansible module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nconfig:\\n- ipv6:\\n    - address: fc00::100/64\\n    - address: fc00::101/64\\n  name: loopback100\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Tasks via Command Line\nDESCRIPTION: The `/usr/bin/ansible` command-line tool allows users to run ad-hoc tasks on remote machines using specified connection plugins. It works in conjunction with playbooks to manage target hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n/usr/bin/ansible\n```\n\n----------------------------------------\n\nTITLE: Specifying Required One Of Options - Ansible Python\nDESCRIPTION: This code sets up a required_one_of dependency for Ansible module argument spec. At least one of the options in each tuple must be set by the user, ensuring modules get minimum required data, and if none are set, execution will fail.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nrequired_one_of=[\n  ('path', 'content'),\n],\n```\n\n----------------------------------------\n\nTITLE: Grouping Ansible Inventory Hosts by Location\nDESCRIPTION: Example INI inventory file showing how to group hosts based on their physical or logical location (e.g., data centers `dc1`, `dc2`). This allows targeting tasks or applying configurations based on geographic or network location, complementing functional grouping.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_33\n\nLANGUAGE: ini\nCODE:\n```\n[dc1]\ndb01.test.example.com\napp01.test.example.com\n\n[dc2]\ndb02.test.example.com\n```\n\n----------------------------------------\n\nTITLE: Improving Inventory Script Performance Using _meta Hostvars in Ansible - Text\nDESCRIPTION: This text-based JSON illustration shows how the special top-level _meta element with hostvars can be included to provide all host variables in a single --list call, thereby preventing per-host script invocation. The structure should be added to the output when optimizing large inventories. Required dependencies: none beyond Ansible and a compatible script. The key 'hostvars' maps hostnames to their variable dictionaries; empty dictionaries are allowed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_17\n\nLANGUAGE: text\nCODE:\n```\n{\n\n    # results of inventory script as above go here\n    # ...\n\n    \"_meta\": {\n        \"hostvars\": {\n            \"host001\": {\n                \"var001\" : \"value\"\n            },\n            \"host002\": {\n                \"var002\": \"value\"\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Resetting Default Shell via Ansible Playbook - Windows - yaml\nDESCRIPTION: This YAML Ansible playbook demonstrates how to set and clear the OpenSSH `DefaultShell` registry entry using `ansible.windows.win_regedit`, and resets connections using `ansible.builtin.meta: reset_connection`. It ensures Ansible tasks in subsequent steps use the new shell configuration. Dependencies include Ansible's Windows modules and appropriate remote permissions. Inputs are the target registry values and state; outputs are registry and Ansible connection changes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- name: set the default shell to PowerShell\n  ansible.windows.win_regedit:\n    path: HKLM:\\SOFTWARE\\OpenSSH\n    name: DefaultShell\n    data: C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\n    type: string\n    state: present\n\n- name: reset SSH connection after shell change\n  ansible.builtin.meta: reset_connection\n\n- name: set the default shell to cmd\n  ansible.windows.win_regedit:\n    path: HKLM:\\SOFTWARE\\OpenSSH\n    name: DefaultShell\n    state: absent\n\n- name: reset SSH connection after shell change\n  ansible.builtin.meta: reset_connection\n```\n\n----------------------------------------\n\nTITLE: Structuring Ansible Inventory per Environment (Staging)\nDESCRIPTION: Example INI inventory file (`inventory_staging`) organizing hosts into functional groups (`dbservers`, `appservers`) specifically for a 'staging' environment. This mirrors the structure of the test environment inventory, providing a consistent way to manage hosts across different deployment stages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_30\n\nLANGUAGE: ini\nCODE:\n```\n[dbservers]\ndb01.staging.example.com\ndb02.staging.example.com\n\n[appservers]\napp01.staging.example.com\napp02.staging.example.com\napp03.staging.example.com\n```\n\n----------------------------------------\n\nTITLE: Including Common Module Boilerplate via Ansiballz (Python)\nDESCRIPTION: In the Ansiballz framework, this placeholder comment within a Python module is recognized and converted into an import statement `from ansible.module_utils.basic import *`. This triggers the inclusion of 'basic.py' into the generated zipfile.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n#<<INCLUDE_ANSIBLE_MODULE_COMMON>>\n```\n\n----------------------------------------\n\nTITLE: Changing proxmox proxmox_default_behavior Default in community.general\nDESCRIPTION: The default value for the `proxmox_default_behavior` option in the `proxmox` module will change from `compatibility` to `no_defaults` in community.general version 4.0.0. Explicitly set this option to avoid deprecation warnings and ensure predictable behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_15\n\nLANGUAGE: Ansible\nCODE:\n```\nproxmox: proxmox_default_behavior\n```\n\n----------------------------------------\n\nTITLE: Running Windows Commands with win_shell and win_powershell in Ansible (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to execute Windows shell commands using Ansible's win_shell and win_powershell modules. Both tasks are designed for running commands on Windows target hosts, with win_shell executing plain shell commands and win_powershell running PowerShell scripts. The first task uses win_shell to display a message with Write-Host, while the second uses win_powershell and passes a script argument. Intended for playbooks targeting Windows hosts, both require the ansible.windows collection and a compatible Ansible control node and target Windows host configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_11.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run with win_shell\\n  ansible.windows.win_shell: Write-Host \\\"Hello, Café\\\"\\n\\n- name: Run with win_powershell\\n  ansible.windows.win_powershell:\\n    script: Write-Host \\\"Hello, Café\\\"\n```\n\n----------------------------------------\n\nTITLE: Correct String Formatting for Python 2.6+ Compatibility\nDESCRIPTION: Demonstrates the correct usage of `str.format()` for compatibility with Python 2.6 and later, using explicit numbered positional arguments (`\"{0}\".format(val)`). This ensures the code works across supported Python versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Use this instead\nnew_string = \"Dear {0}, Welcome to {1}\".format(username, location)\n```\n\n----------------------------------------\n\nTITLE: Running DSC Resources as Another User with Credentials - Ansible YAML+Jinja\nDESCRIPTION: Illustrates how to run DSC resources using specific user credentials by leveraging the PsDscRunAsCredential_username and _password parameters in win_dsc. This enables playbooks to interact with user-profile-specific components such as the HKEY_CURRENT_USER registry hive, while keeping credential values secure using Ansible variable substitution. Requires Ansible variables for the target username and password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_7\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Use win_dsc with PsDscRunAsCredential to run as a different user\n  win_dsc:\n    resource_name: Registry\n    Ensure: Present\n    Key: HKEY_CURRENT_USER\\ExampleKey\n    ValueName: TestValue\n    ValueData: TestData\n    PsDscRunAsCredential_username: '{{ ansible_user }}'\n    PsDscRunAsCredential_password: '{{ ansible_password }}'\n  no_log: true\n```\n\n----------------------------------------\n\nTITLE: Return Value Placeholder for frontend_cookie_secret (Ansible)\nDESCRIPTION: Refers to the `frontend_cookie_secret` return value from the `utm_proxy_auth_profile` module (`community.general`). This value is now a placeholder string rather than the actual secret provided as a parameter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_22\n\nLANGUAGE: ansible\nCODE:\n```\nfrontend_cookie_secret\n```\n\n----------------------------------------\n\nTITLE: Illustrating Implicit Boolean Conversion Error in Ansible Conditionals\nDESCRIPTION: This Ansible playbook snippet demonstrates a broken conditional where the `inventory_hostname` variable (a string) is used directly as a condition. Ansible 12 requires conditionals to result in an explicit boolean value, and this implicit 'truthy' evaluation now raises an error ('Conditional result was ... of type 'str', which evaluates to True. Conditionals must have a boolean result.').\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname\n```\n\n----------------------------------------\n\nTITLE: Installing DSC Resources Using win_psmodule - Ansible YAML+Jinja\nDESCRIPTION: Shows how to install custom DSC resources (e.g., xWebAdministration) on a Windows host using the Ansible win_psmodule module. Module installation is necessary for subsequent usage of associated resources in win_dsc. The example specifies module name and desired state.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_9\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Install xWebAdministration DSC resource\n  win_psmodule:\n    name: xWebAdministration\n    state: present\n```\n\n----------------------------------------\n\nTITLE: Initializing Vagrant Windows Server 2016 VM with Shell Commands\nDESCRIPTION: This shell snippet demonstrates the initialization and provisioning of a Windows Server 2016 VM using Vagrant. It requires the user to have Vagrant and VirtualBox installed. 'vagrant init' sets up the box, while 'vagrant up' downloads and boots the VM. No parameters need to be customized unless changing the Windows image; expected output is an operational Windows VM with WinRM enabled for Ansible. Errors may occur if the specified port is in use or prerequisites are missing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nvagrant init jborean93/WindowsServer2016\\nvagrant up\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Collection with Additional GPG Signatures using Bash\nDESCRIPTION: This command installs the `my_namespace.my_collection` collection using `ansible-galaxy`, verifying its authenticity. It uses the GPG keyring at `~/.ansible/pubring.kbx` (unless configured elsewhere) and checks against an additional signature provided via the URI specified with the `--signature` option, alongside any signatures from the distribution server. Multiple `--signature` options can be provided.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install my_namespace.my_collection --signature https://examplehost.com/detached_signature.asc --keyring ~/.ansible/pubring.kbx\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Facts in Jinja2 Templates (Jinja)\nDESCRIPTION: This Jinja2 expression shows how to access a custom fact (asdf) from the general section in the preferences fact set under ansible_local. Used within Ansible templates or playbooks, it retrieves the value of asdf. Requires that the fact has already been gathered and is available in ansible_local. Input is template context; output is the value '1'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_11\n\nLANGUAGE: jinja\nCODE:\n```\n{{ ansible_local['preferences']['general']['asdf'] }}\n```\n\n----------------------------------------\n\nTITLE: Importing AnsibleModule from ansible.module_utils.basic (Python)\nDESCRIPTION: This snippet demonstrates how to import the AnsibleModule class from the basic utility module, which is essential for any custom Ansible Python module. The AnsibleModule is the entry point for argument parsing, result reporting, and integration with Ansible's execution environment. This import is required for developing standard Ansible modules; the code has no inputs. Dependency: ansible.module_utils.basic must be available in the Python path when running the module via Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_module_utilities.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import AnsibleModule\n```\n\n----------------------------------------\n\nTITLE: Defensive Optional Import for Module Utilities (Python)\nDESCRIPTION: This Python snippet imports respawn_module from ansible.module_utils.common.respawn within a try/except block, assigning None on ImportError. At runtime, the code conditionally calls respawn_module only if the import succeeded. If the required module is not found (such as with Ansible < 2.11), it fails gracefully with a fallback error message. This pattern enables compatibility with multiple Ansible core versions and supports new features without breaking on older installations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_shared.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from ansible.module_utils.common.respawn import respawn_module\nexcept ImportError:\n    respawn_module = None\n...\nif needs_respawn:\n    if respawn_module:\n        respawn_module(target)\n    else:\n        module.fail_json('respawn is not available in Ansible < 2.11, ensure that foopkg is installed')\n```\n\n----------------------------------------\n\nTITLE: Wildcard Host Patterns - Ansible Playbooks (YAML)\nDESCRIPTION: These YAML snippet patterns use wildcards to match FQDNs or IP addresses in the inventory. This requires hosts in the inventory named by FQDN or IP. Useful for targeting dynamic or pattern-matching hostnames.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n192.0.*\n```\n\nLANGUAGE: yaml\nCODE:\n```\n*.example.com\n```\n\nLANGUAGE: yaml\nCODE:\n```\n*.com\n```\n\n----------------------------------------\n\nTITLE: Defining Role Parameters in Ansible Metadata (YAML)\nDESCRIPTION: Example definitions for role parameters within an Ansible role's metadata (likely `meta/main.yml` or `argument_specs`). Shows boolean, path, and list-of-strings types with descriptions and requirement settings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n              type: \"bool\"\n              required: true\n              description: \"A boolean value.\"\n\n            myapp_path:\n              type: \"path\"\n              required: true\n              description: \"A path value.\"\n\n            original_name:\n              type: list\n              elements: \"str\"\n              required: false\n              description: \"An optional list of string values.\"\n```\n\n----------------------------------------\n\nTITLE: Example Structured Output from pyATS Parser\nDESCRIPTION: Shows an example of the structured data stored in the `interfaces` fact after parsing the `show interface` command output using the `pyATS` parser. The output is a dictionary where keys are interface names. Each interface contains a deeply nested structure representing various configuration and operational state details as defined by the corresponding pyATS parser.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nmgmt0:\n  admin_state: up\n  auto_mdix: 'off'\n  auto_negotiate: true\n  bandwidth: 1000000\n  counters:\n    in_broadcast_pkts: 3\n    in_multicast_pkts: 1652395\n    in_octets: 556155103\n    in_pkts: 2236713\n    in_unicast_pkts: 584259\n    rate:\n      in_rate: 320\n      in_rate_pkts: 0\n      load_interval: 1\n      out_rate: 48\n      out_rate_pkts: 0\n    rx: true\n    tx: true\n  delay: 10\n  duplex_mode: full\n  enabled: true\n  encapsulations:\n    encapsulation: arpa\n  ethertype: '0x0000'\n  ipv4:\n    192.168.101.14/24:\n      ip: 192.168.101.14\n      prefix_length: '24'\n  link_state: up\n  # ...\n```\n\n----------------------------------------\n\nTITLE: Dynamically Including Tasks via include_tasks after Attribute Inheritance Fix - Ansible Playbook YAML\nDESCRIPTION: In Ansible 2.5, this snippet shows a dynamic include using 'include_tasks' with an explicit 'tags' attribute ('distro_include'). However, with improved separation of dynamic and static includes, this tag is no longer inherited by tasks in the included file, requiring users to apply the tag within the included YAML as well, if inheritance is needed. The templating of 'ansible_distribution' allows conditional logic. Dependencies: Ansible 2.5+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- include_tasks: \"{{ ansible_distribution }}.yml\"\n  tags:\n    - distro_include\n```\n\n----------------------------------------\n\nTITLE: Illustrating Jinja Order of Operations Error in Ansible Conditionals\nDESCRIPTION: This Ansible playbook snippet shows a conditional error caused by Jinja's order of operations. The string concatenation operator `~` is evaluated after the `contains` test, resulting in a non-empty string ('Truehost') instead of a boolean. This triggers a non-boolean conditional error in Ansible 12.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname is contains \"local\" ~ \"host\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Rolling Update and Testing Gates with Ansible Playbooks in YAML\nDESCRIPTION: This YAML playbook implements a rolling update pattern with pre-tasks to remove nodes from the load balancer, sequential role execution, configuration testing, and post-tasks to re-add to the pool. It also showcases the use of loops to include multiple roles and the 'meta: flush_handlers' action. Requirements: Ansible, custom roles for common/webserver/apply_testing_checks, and appropriate commands/scripts on the load balancer. Inputs: host inventory, outputs: coordinated rolling upgrade with testing gate.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\n\n- hosts: webservers\n  serial: 5\n\n  pre_tasks:\n\n    - name: take out of load balancer pool\n      ansible.builtin.command: /usr/bin/take_out_of_pool {{ inventory_hostname }}\n      delegate_to: 127.0.0.1\n\n  tasks:\n\n    - ansible.builtin.include_role:\n        name: \"{{ item }}\"\n      loop:\n        - common\n        - webserver\n\n    - name: run any notified handlers\n      ansible.builtin.meta: flush_handlers\n\n    - name: test the configuration\n      ansible.builtin.include_role:\n        name: apply_testing_checks\n\n  post_tasks:\n\n    - name: add back to load balancer pool\n      ansible.builtin.command: /usr/bin/add_back_to_pool {{ inventory_hostname }}\n      delegate_to: 127.0.0.1\n```\n\n----------------------------------------\n\nTITLE: Defining a DSC Registry Resource in PowerShell\nDESCRIPTION: This snippet shows the standard PowerShell syntax for defining the built-in 'Registry' DSC resource, as documented by Microsoft. It outlines the parameters available for managing Windows registry keys and values, including Key, ValueName, Ensure, Force, Hex, ValueData, and ValueType. This definition serves as the basis for mapping Ansible task parameters when using the `win_dsc` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nRegistry [string] #ResourceName\n{\n    Key = [string]\n    ValueName = [string]\n    [ Ensure = [string] { Enable | Disable }  ]\n    [ Force =  [bool]   ]\n    [ Hex = [bool] ]\n    [ DependsOn = [string[]] ]\n    [ ValueData = [string[]] ]\n    [ ValueType = [string] { Binary | Dword | ExpandString | MultiString | Qword | String }  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Ansible Includes (Text/Variable Name)\nDESCRIPTION: Example parameter name `user` used in the context of Ansible includes. Included playbooks or task lists can accept variables (parameters), allowing them to be reused with different values (e.g., creating resources for different users like 'alice' and 'bob').\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nuser\n```\n\n----------------------------------------\n\nTITLE: Defining the `get_vars` Method in Modern Ansible Vars Plugins (Python)\nDESCRIPTION: This Python snippet displays the signature for the `get_vars` method, the standard way to implement functionality in modern Ansible vars plugins (Ansible 2.4+). This method receives the data loader, relevant paths, and host/group entities, and is expected to return a dictionary of variables. It's called lazily when variables are needed for a task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n    def get_vars(self, loader, path, entities):\n        pass # your code goes here\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Lists and Dictionaries in YAML\nDESCRIPTION: Shows a more complex data structure: a list of dictionaries. Each dictionary represents an employee record, and the 'skills' key within each dictionary holds a list of strings. This demonstrates nesting capabilities in YAML.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Employee records\n- martin:\n    name: Martin D'vloper\n    job: Developer\n    skills:\n      - python\n      - perl\n      - pascal\n- tabitha:\n    name: Tabitha Bitumen\n    job: Developer\n    skills:\n      - lisp\n      - fortran\n      - erlang\n```\n\n----------------------------------------\n\nTITLE: Referencing the Ansible Yum Module (Text)\nDESCRIPTION: Reference to the Ansible `yum` module (`yum_module`). It's mentioned as an example of a module that can accept a list of packages directly, potentially avoiding the need for an explicit `loop` construct for package installation on systems using YUM.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_19\n\nLANGUAGE: text\nCODE:\n```\nyum_module\n```\n\n----------------------------------------\n\nTITLE: Listing Version Types for the Ansible 'version' Test in Console\nDESCRIPTION: Lists the available values for the `version_type` parameter (introduced in Ansible 2.11, mutually exclusive with `strict`) for the `version` test. These values specify different parsing and comparison rules: 'loose' (LooseVersion), 'strict' (StrictVersion), 'semver'/'semantic' (SemVer), and 'pep440' (PEP-440, added in 2.14).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nloose, strict, semver, semantic, pep440\n```\n\n----------------------------------------\n\nTITLE: Properly Quoting Complex Values with Ansible Variables\nDESCRIPTION: Provides examples demonstrating that the entire value must be quoted if it starts with an Ansible variable or contains characters like backslashes that might need escaping or interpretation. Partial quoting is not allowed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\nfoo: \"{{ variable }}/additional/string/literal\"\nfoo2: \"{{ variable }}\\\\backslashes\\\\are\\\\also\\\\special\\\\characters\"\nfoo3: \"even if it is just a string literal it must all be quoted\"\n```\n\n----------------------------------------\n\nTITLE: Installing the Removed inspur.sm Collection using Bash\nDESCRIPTION: This command specifically installs the `inspur.sm` Ansible collection using `ansible-galaxy`. This collection was removed from the Ansible 11 package because it was considered unmaintained, but users can still install it manually if needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_11.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install inspur.sm\n```\n\n----------------------------------------\n\nTITLE: Setting Per-Task ansible_command_timeout in Ansible Playbook - YAML\nDESCRIPTION: Shows using the 'ansible_command_timeout' variable within a vars block to alter the timeout for a specific task in an Ansible playbook when the module does not directly support a 'timeout' parameter. This is useful for longer-running operations; ensure the variable is appropriately scoped in the playbook context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_30\n\nLANGUAGE: yaml\nCODE:\n```\n- name: save running-config\n  cisco.ios.ios_command:\n    commands: copy running-config startup-config\n  vars:\n    ansible_command_timeout: 60\n```\n\n----------------------------------------\n\nTITLE: Execution Order of Nested Ansible Role Dependencies (Text)\nDESCRIPTION: Illustrates the execution order when a role ('car') depends multiple times on another role ('wheel' with parameter 'n'), which in turn depends on roles ('tire', 'brake') that allow duplicates. Shows the interleaved execution based on parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_25\n\nLANGUAGE: text\nCODE:\n```\ntire(n=1)\nbrake(n=1)\nwheel(n=1)\ntire(n=2)\nbrake(n=2)\nwheel(n=2)\n...\ncar\n```\n\n----------------------------------------\n\nTITLE: Importing Basic Utility Module - Ansible (Python)\nDESCRIPTION: Demonstrates how to import the complete ansible.module_utils.basic utility module using a generic import. This provides access to foundational helper classes and functions for module authors. Requires Ansible as a dependency, and is used when multiple helpers are needed from the basic utility package.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/module_utils.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport ansible.module_utils.basic\n```\n\n----------------------------------------\n\nTITLE: Replacing with_sequence by Looping over a Range and Formatting in Ansible YAML+Jinja\nDESCRIPTION: Converts with_sequence to direct looping via range() and the format filter, supporting iteration over a numeric sequence with custom formatting. Inputs are start, end, stride, and a format string. Outputs are formatted usernames as debug messages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/shared_snippets/with2loop.txt#_snippet_7\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_sequence\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_sequence: start=0 end=4 stride=2 format=testuser%02x\n```\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: with_sequence -> loop\n  ansible.builtin.debug:\n    msg: \"{{ 'testuser%02x' | format(item) }}\"\n  loop: \"{{ range(0, 4 + 1, 2)|list }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining TextFSM Template for Cisco NX-OS 'show interface'\nDESCRIPTION: This is a TextFSM template designed to parse the output of the `show interface` command on Cisco NX-OS devices. It defines `Value` entries to capture specific data points (like INTERFACE, LINK_STATUS, IP_ADDRESS, MTU, SPEED, etc.) and uses state transitions (`Start` section) with regular expressions to match lines in the command output and record the extracted values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_14\n\nLANGUAGE: textfsm\nCODE:\n```\nValue Required INTERFACE (\\S+)\nValue LINK_STATUS (.+?)\nValue ADMIN_STATE (.+?)\nValue HARDWARE_TYPE (.\\*)\nValue ADDRESS ([a-zA-Z0-9]+.[a-zA-Z0-9]+.[a-zA-Z0-9]+)\nValue BIA ([a-zA-Z0-9]+.[a-zA-Z0-9]+.[a-zA-Z0-9]+)\nValue DESCRIPTION (.\\*)\nValue IP_ADDRESS (\\d+\\.\\d+\\.\\d+\\.\\d+\\/\\d+)\nValue MTU (\\d+)\nValue MODE (\\S+)\nValue DUPLEX (.+duplex?)\nValue SPEED (.+?)\nValue INPUT_PACKETS (\\d+)\nValue OUTPUT_PACKETS (\\d+)\nValue INPUT_ERRORS (\\d+)\nValue OUTPUT_ERRORS (\\d+)\nValue BANDWIDTH (\\d+\\s+\\w+)\nValue DELAY (\\d+\\s+\\w+)\nValue ENCAPSULATION (\\w+)\nValue LAST_LINK_FLAPPED (.+?)\n\nStart\n  ^\\S+\\s+is.+ -> Continue.Record\n  ^${INTERFACE}\\s+is\\s+${LINK_STATUS},\\sline\\sprotocol\\sis\\s${ADMIN_STATE}$$\n  ^${INTERFACE}\\s+is\\s+${LINK_STATUS}$$\n  ^admin\\s+state\\s+is\\s+${ADMIN_STATE},\n  ^\\s+Hardware(:|\\s+is)\\s+${HARDWARE_TYPE},\\s+address(:|\\s+is)\\s+${ADDRESS}(.*bia\\s+${BIA})*\n  ^\\s+Description:\\s+${DESCRIPTION}\n  ^\\s+Internet\\s+Address\\s+is\\s+${IP_ADDRESS}\n  ^\\s+Port\\s+mode\\s+is\\s+${MODE}\n  ^\\s+${DUPLEX}, ${SPEED}(,|$$)\n  ^\\s+MTU\\s+${MTU}.\\*BW\\s+${BANDWIDTH}.\\*DLY\\s+${DELAY}\n  ^\\s+Encapsulation\\s+${ENCAPSULATION}\n  ^\\s+${INPUT_PACKETS}\\s+input\\s+packets\\s+\\d+\\s+bytes\\s\\*$$\n  ^\\s+${INPUT_ERRORS}\\s+input\\s+error\\s+\\d+\\s+short\\s+frame\\s+\\d+\\s+overrun\\s+\\d+\\s+underrun\\s+\\d+\\s+ignored\\s\\*$$\n  ^\\s+${OUTPUT_PACKETS}\\s+output\\s+packets\\s+\\d+\\s+bytes\\s\\*$$\n  ^\\s+${OUTPUT_ERRORS}\\s+output\\s+error\\s+\\d+\\s+collision\\s+\\d+\\s+deferred\\s+\\d+\\s+late\\s+collision\\s\\*$$\n  ^\\s+Last\\s+link\\s+flapped\\s+${LAST_LINK_FLAPPED}\\s\\*$$\n```\n\n----------------------------------------\n\nTITLE: Verifying Collection Signatures from requirements.yml - ansible-galaxy CLI - Bash\nDESCRIPTION: Uses the -r flag to verify signatures for all collections defined in a requirements.yml file, combined with --keyring to specify the public keyring. All collections listed in the file are processed for signature authenticity; dependencies are not verified.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify -r requirements.yml --keyring ~/.ansible/pubring.kbx\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Role Multiple Times with Different Parameters (Dict Syntax) (YAML)\nDESCRIPTION: Demonstrates forcing an Ansible role ('foo') to run multiple times within a single play by providing different parameters for each invocation using dictionary syntax within the `roles` list.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: webservers\n  roles:\n    - { role: foo, message: \"first\" }\n    - { role: foo, message: \"second\" }\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Python Installation on FreeBSD via Raw Module\nDESCRIPTION: This command uses the Ansible 'raw' module to install Python on a FreeBSD managed node ('myfreebsdhost') using the 'pkg' package manager. This step is necessary for most Ansible modules to function, as they require Python on the target machine.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible -m raw -a \"pkg install -y python\" myfreebsdhost\n```\n\n----------------------------------------\n\nTITLE: Downloading a Source Collection Directory with Ansible Galaxy - Bash\nDESCRIPTION: Demonstrates downloading an Ansible collection from a local or git-based source directory using ansible-galaxy. The collection source must contain a mandatory galaxy.yml file. The commands show downloading from a filesystem path and a git repository URL, respectively. Dependencies are resolved automatically and outputs placed in the default directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection download /path/to/collection\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection download git+file:///path/to/collection/.git\n```\n\n----------------------------------------\n\nTITLE: Mocking run_command in Ansible Module Unit Test (Python)\nDESCRIPTION: This Python snippet demonstrates how to use `unittest.mock.patch.object` to mock the `run_command` method of `AnsibleModule` within a unit test. It simulates a successful external command execution by providing return values for `rc`, `stdout`, and `stderr`, asserts that the module exits with the expected JSON payload using `assertRaises(AnsibleExitJson)`, checks the `changed` status, and verifies that `run_command` was invoked with the correct arguments. This pattern is essential for testing modules that interact with the system via commands.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n            with patch.object(basic.AnsibleModule, 'run_command') as mock_run_command:\n                stdout = 'configuration updated'\n                stderr = ''\n                rc = 0\n                mock_run_command.return_value = rc, stdout, stderr  # successful execution\n\n                with self.assertRaises(AnsibleExitJson) as result:\n                    my_module.main()\n                self.assertFalse(result.exception.args[0]['changed']) # ensure result is changed\n\n            mock_run_command.assert_called_once_with('/usr/bin/my_command --value 10 --name test')\n```\n\n----------------------------------------\n\nTITLE: Setting Default Strategy in ansible.cfg (Ansible, INI)\nDESCRIPTION: This ini-formatted snippet configures the Ansible default strategy by specifying the 'strategy' parameter in the ansible.cfg configuration file. It requires access to the project's or global ansible.cfg file. The '[defaults]' section is modified to include 'strategy=linear', which sets the linear strategy as the default for all plays executed unless overridden.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/strategy.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nstrategy=linear\n```\n\n----------------------------------------\n\nTITLE: Defining Connection Variables Inline - Ansible Inventory - Text\nDESCRIPTION: Demonstrates how to assign connection-related variables such as ansible_connection and ansible_user directly to hosts within an INI inventory group. This allows for customized connection types and credentials per host. No external prerequisites required; key parameters are the connection type and user per inventory host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n[targets]\\n\\nlocalhost              ansible_connection=local\\nother1.example.com     ansible_connection=ssh        ansible_user=myuser\\nother2.example.com     ansible_connection=ssh        ansible_user=myotheruser\n```\n\n----------------------------------------\n\nTITLE: Specifying Strategy Plugin in Playbook (Ansible, YAML)\nDESCRIPTION: This YAML snippet is an Ansible playbook example that sets the strategy plugin at the play level to 'debug'. It includes multiple tasks and a handler. Dependencies include Ansible and an existing 'debug' strategy plugin. 'hosts' defines the target group, tasks use 'copy' and 'package' modules with parameters for file transfer and package installation, and a 'handler' is triggered by a notify event. The snippet demonstrates explicit use of the play-level 'strategy' attribute, allowing per-play control over execution order.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/strategy.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: all\n  strategy: debug\n  tasks:\n    - copy:\n        src: myhosts \n        dest: /etc/hosts\n      notify: restart_tomcat\n\n    - package:\n        name: tomcat\n        state: present\n\n  handlers:\n    - name: restart_tomcat\n      service:\n        name: tomcat\n        state: restarted\n```\n\n----------------------------------------\n\nTITLE: Creating a New Release Branch from Default - Git Bash Script\nDESCRIPTION: This Bash command checks out a new branch named 'release_branch' from the current HEAD (expected to be the default branch). It is a preparation step for making isolated release changes. The command requires Git but no other dependencies and helps organize release-specific commits.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b release_branch\n```\n\n----------------------------------------\n\nTITLE: Quoting Boolean-Like Strings in YAML\nDESCRIPTION: Demonstrates how to ensure strings that look like boolean values (e.g., 'yes', 'False') are treated as literal strings by enclosing them in quotes. Without quotes, YAML might automatically convert them to boolean types.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nnon_boolean: \"yes\"\nother_string: \"False\"\n```\n\n----------------------------------------\n\nTITLE: Including Ansible Playbook for WinRM Certificate Setup (YAML)\nDESCRIPTION: A reStructuredText directive (`literalinclude`) indicating the inclusion of an Ansible playbook located at `yaml/winrm_cert_auth_setup.yaml`. This playbook is intended to automate the creation of a local user and the mapping of a provided certificate for WinRM authentication on a Windows host, requiring `username` and `cert_pem` variables.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n.. literalinclude:: yaml/winrm_cert_auth_setup.yaml\n   :language: yaml\n```\n\n----------------------------------------\n\nTITLE: Using Lookup Plugins in Jinja2 Templates\nDESCRIPTION: Demonstrates how to use an Ansible lookup plugin (`file`) within a Jinja2 template. The expression `{{ lookup('file','/path/to/file') }}` retrieves data from an external source (reads the content of the specified file) and makes it available within the template.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_15\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ lookup('file','/path/to/file') }}\n```\n\n----------------------------------------\n\nTITLE: Changing hashi_vault VAULT_ADDR Precedence in community.hashi_vault\nDESCRIPTION: In community.hashi_vault version 1.0.0, the precedence of the `VAULT_ADDR` environment variable for setting the `url` option in the `hashi_vault` lookup plugin will be lowered. Use the `ANSIBLE_HASHI_VAULT_ADDR` environment variable to intentionally override configuration values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_19\n\nLANGUAGE: Environment Variable\nCODE:\n```\nVAULT_ADDR\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_get_system_inventory Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_get_system_inventory` module is deprecated. Use the `idrac_system_info` module instead for retrieving system inventory data from Dell EMC iDRAC.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_28\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_get_system_inventory\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible Navigator CLI Command\nDESCRIPTION: Specifies using `ansible-navigator` when referring to the command-line interface for Ansible Navigator. Subsequent mentions can use 'Navigator'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule Class\nDESCRIPTION: Stub documentation reference for the `AnsibleModule` class, which is the main class used for developing Ansible modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_14\n\nLANGUAGE: rst\nCODE:\n```\n.. py:class:: AnsibleModule\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_setup_idrac_syslog Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_setup_idrac_syslog` module is deprecated. Use the `idrac_syslog` module for configuring syslog settings on Dell EMC iDRAC.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_39\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_setup_idrac_syslog\n```\n\n----------------------------------------\n\nTITLE: Using Relative Imports for Module Utils in Ansible Collections (Python)\nDESCRIPTION: Shows how to use the new relative import syntax introduced in Ansible 2.9 within a Python module file inside a collection (`ansible_collections/my_namespace/my_collection/plugins/modules/my_module.py`) to import a utility file (`my_util`) from the collection's `module_utils` directory. This contrasts with the older absolute import method.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.9.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# File: ansible_collections/my_namespace/my_collection/plugins/modules/my_module.py\n# Old way to use an absolute import to import module_utils from the collection:\nfrom ansible_collections.my_namespace.my_collection.plugins.module_utils import my_util\n# New way using a relative import:\nfrom ..module_utils import my_util\n```\n\n----------------------------------------\n\nTITLE: Deprecating Return Values in Ansible Modules using Python\nDESCRIPTION: Demonstrates using the `deprecate_value` function from `ansible.module_utils.datatag` within a Python-based Ansible module. This function wraps a return value (e.g., \"blue\" for `color_name`) to signal its deprecation, providing a warning message and optional help text when the value is accessed. It's used within the `module.exit_json` call.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.datatag import deprecate_value\n\n...\n\nmodule.exit_json(\n    color_name=deprecate_value(\n        value=\"blue\",\n        msg=\"The `color_name` return value is deprecated.\",\n        help_text=\"Use `color_code` instead.\",\n    ),\n    color_code=\"#0000ff\",\n)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Become Method and Flags - Ansible YAML\nDESCRIPTION: This snippet executes 'somecommand' as the 'nobody' user using the 'su' method and custom shell flags ('-s /bin/sh'). Requires Ansible, proper become plugin (e.g., 'su'), and correct privileges. Key parameters: 'command', 'become', 'become_method', 'become_user', and 'become_flags'. Input: command to run and customization options. Output: runs the command as 'nobody' with shell set to /bin/sh. Limitation: target system must support specified become method and flags.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run a command as nobody\\n  command: somecommand\\n  become: true\\n  become_method: su\\n  become_user: nobody\\n  become_flags: '-s /bin/sh'\n```\n\n----------------------------------------\n\nTITLE: Defining Jinja Test Syntax in Console\nDESCRIPTION: Shows the required basic syntax for applying a Jinja test (`test_name`) to a variable (`variable`) in Ansible 2.9 and later. This syntax replaces the deprecated filter syntax for tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nvariable is test_name\n```\n\n----------------------------------------\n\nTITLE: Ansible Output When File Not Found (Error Ignored)\nDESCRIPTION: This snippet shows the Ansible output when the 'file' lookup cannot locate '/nosuchfile' and the 'errors' parameter is set to 'ignore.' Ansible emits a warning but continues running the playbook, displaying an empty message. This output illustrates how non-fatal lookup warnings appear, useful for verifying correct error configuration in playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/lookup.rst#_snippet_4\n\nLANGUAGE: ansible-output\nCODE:\n```\n    [WARNING]: Unable to find '/nosuchfile' in expected paths (use -vvvvv to see paths)\n\n    ok: [localhost] => {\n        \"msg\": \"\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Referencing ansible.module_utils.basic._load_params() Function\nDESCRIPTION: Stub documentation reference for the `_load_params()` function within the `ansible.module_utils.basic` module, responsible for loading module parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_15\n\nLANGUAGE: rst\nCODE:\n```\n.. py:function:: ansible.module_utils.basic._load_params()\n```\n\n----------------------------------------\n\nTITLE: Optional Documentation Fragments Path in Ansible Collections\nDESCRIPTION: Shows the conventional location for documentation fragments within an Ansible collection. These optional Python files, stored under `/plugins/doc_fragments/`, contain reusable documentation sections (like common argument details) that can be included in multiple module documentation strings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_in_groups.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n/plugins/doc_fragments/$topic.py\n```\n\n----------------------------------------\n\nTITLE: Configuring DNS-based Kerberos KDC Lookup (INI)\nDESCRIPTION: This configuration file snippet provides krb5.conf entries for enabling DNS-based lookup for KDC resolution. The [libdefaults] section is configured with a default realm and instructs Kerberos to discover KDCs via DNS SRV records. Place this configuration in /etc/krb5.conf to enable automatic detection of domain KDCs if hostname-based detection is insufficient.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n[libdefaults]\n    # Not required but helpful if the realm cannot be determined from\n    # the hostname\n    default_realm = MY.DOMAIN.COM\n\n    # Enabled KDC lookups from DNS SRV records\n    dns_lookup_kdc = true\n```\n\n----------------------------------------\n\nTITLE: Running Commands and Scripts with win_shell, win_command in Ansible Playbook YAML\nDESCRIPTION: This set of snippets demonstrates executing scripts, PowerShell, CMD, or executable commands on Windows hosts using win_shell and win_command modules. It covers shell vs command differences, running multiple commands, specifying shell executables, and running scripts or binaries. Inputs are command lines or scripts and optional shell; outputs are stderr/stdout from the executed process. Limitations include no support for become/async for raw/script modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Run a command under PowerShell\\n  win_shell: Get-Service -Name service | Stop-Service\\n\\n- name: Run a command under cmd\\n  win_shell: mkdir C:\\\\temp\\n  args:\\n    executable: cmd.exe\\n\\n- name: Run a multiple shell commands\\n  win_shell: |\\n    New-Item -Path C:\\\\temp -ItemType Directory\\n    Remove-Item -Path C:\\\\temp -Force -Recurse\\n    $path_info = Get-Item -Path C:\\\\temp\\n    $path_info.FullName\\n\\n- name: Run an executable using win_command\\n  win_command: whoami.exe\\n\\n- name: Run a cmd command\\n  win_command: cmd.exe /c mkdir C:\\\\temp\\n\\n- name: Run a vbs script\\n  win_command: cscript.exe script.vbs\n```\n\n----------------------------------------\n\nTITLE: Cloning Ansible Core Repository Parts using Nox (Bash)\nDESCRIPTION: This command executes the `clone-core` nox session. Its purpose is to clone the necessary parts of the main `ansible/ansible` repository, which is a prerequisite for building the documentation locally. This ensures that required source files are available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnox -s clone-core\n```\n\n----------------------------------------\n\nTITLE: Generating Navigation Tree for Ansible Roadmaps in reStructuredText\nDESCRIPTION: This reStructuredText snippet uses the `toctree` directive to automatically generate a table of contents (navigation tree) for Ansible roadmap documents. It includes options `:maxdepth: 1` to limit the depth of the tree, `:glob:` to enable wildcard matching for file names (though no wildcards are used here explicitly, the option is present), and `:caption:` to provide a title for the generated list, \"Ansible Release Roadmaps\". The listed items (e.g., `COLLECTIONS_12`, `old_roadmap_index`) refer to other reStructuredText files or documents that will be included in the table of contents.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/roadmap/ansible_roadmap_index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n   :glob:\n   :caption: Ansible Release Roadmaps\n   \n   COLLECTIONS_12\n   COLLECTIONS_11\n   COLLECTIONS_10\n   COLLECTIONS_9\n   COLLECTIONS_8\n   COLLECTIONS_7\n   COLLECTIONS_6\n   COLLECTIONS_5\n   COLLECTIONS_4\n   COLLECTIONS_3_0\n   COLLECTIONS_2_10\n   old_roadmap_index\n```\n\n----------------------------------------\n\nTITLE: Example YAML Structure for Complex Module Arguments\nDESCRIPTION: Illustrates a nested YAML data structure representing complex arguments that might be passed to an Ansible module via the 'test-module.py' script. This structure includes a parent key with a child list containing dictionaries.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/README.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n```yaml\nparent:\n  child:\n    - item: first\n      val: foo\n    - item: second\n      val: boo\n```\n```\n\n----------------------------------------\n\nTITLE: Example: Building a Specific RST File with sphinx-build (Bash)\nDESCRIPTION: This is an example command demonstrating how to use `sphinx-build` to build a specific rST file (`developing_modules_documenting.rst`) located in the `rst/dev_guide/` directory. It specifies the builder (`html`), configuration directory (`rst/`), source directory (`rst/dev_guide/`), output directory (`_build/html/dev_guide/`), and the specific file to build.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsphinx-build -b html -c rst/ rst/dev_guide/ _build/html/dev_guide/ rst/dev_guide/developing_modules_documenting.rst\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Ad-hoc Command in Community EE Minimal Container - Bash\nDESCRIPTION: Executes an ad-hoc Ansible 'setup' module call against 'localhost' inside the 'community-ee-minimal' container via ansible-navigator. Requires ansible-navigator, access to the Docker container image, and basic Ansible configuration. Users can adjust the '-m' module parameter as needed for other ad-hoc tasks. Outputs module results in stdout format.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_community_ee_image.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator exec \"ansible localhost -m setup\" --execution-environment-image ghcr.io/ansible-community/community-ee-minimal:latest --mode stdout\n```\n\n----------------------------------------\n\nTITLE: Including Standard AWS Documentation Fragments in YAML\nDESCRIPTION: This YAML snippet provides a practical example for Ansible AWS modules, showing how to include common documentation fragments related to AWS generic options (`aws`) and EC2 specific options (`ec2`) using `extends_documentation_fragment`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    extends_documentation_fragment:\n    - aws\n    - ec2\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Login Prompts via Host Variables (YAML)\nDESCRIPTION: Example host variables file (`host_vars/<inventory-hostname>.yaml`) demonstrating how to handle multiple sequential login prompts using lists for `ansible_terminal_initial_prompt` and `ansible_terminal_initial_answer`. `ansible_terminal_initial_prompt_checkall: True` ensures all prompts are matched in sequence. Requires Ansible 2.9+ for the `network_cli` connection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_35\n\nLANGUAGE: console\nCODE:\n```\n$ cat host_vars/<inventory-hostname>.yaml\n---\nansible_terminal_initial_prompt:\n  - \"Press any key to enter main menu\"\n  - \"Connect to a host\"\nansible_terminal_initial_answer:\n  - \"\\\\r\"\n  - \"3\"\nansible_terminal_initial_prompt_checkall: True\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Ansible Playbook for Localhost Fact Gathering (YAML)\nDESCRIPTION: This YAML snippet defines an Ansible playbook named 'test_localhost.yml'. The playbook targets 'localhost' and its primary task is to gather facts using the 'ansible.builtin.gather_facts' module. It's designed to be run inside an Execution Environment to demonstrate local execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_execution_environment.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: Test localhost\n  hosts: localhost\n  gather_facts: true\n  tasks:\n    - name: Gather facts\n      ansible.builtin.gather_facts:\n\n```\n\n----------------------------------------\n\nTITLE: Example Structured Data from TTP Parsing (YAML)\nDESCRIPTION: This YAML snippet illustrates the structured data (a list of dictionaries) obtained after parsing the `show interface` command output using the example TTP template and the `cli_parse` module. Each dictionary contains the extracted `interface`, `state`, and `admin_state`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\n   - admin_state: up,\n     interface: mgmt0\n     state: up\n   - admin_state: up,\n     interface: Ethernet1/1\n     state: up\n   - admin_state: up,\n     interface: Ethernet1/2\n     state: up\n```\n\n----------------------------------------\n\nTITLE: Starting Ansible Playbook Execution at a Specific Task (Shell)\nDESCRIPTION: This command demonstrates how to start executing an Ansible playbook (`playbook.yml`) beginning at a specific task named \"install packages\". This is useful for resuming a playbook run after a failure without re-running preceding tasks. Note that this feature has limitations with dynamically included roles or tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_startnstep.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook playbook.yml --start-at-task=\"install packages\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespaced Fact Cache Plugin in ansible.cfg using INI\nDESCRIPTION: Demonstrates how to specify a fact cache plugin located within an Ansible collection using its Fully Qualified Collection Name (FQCN) in the `ansible.cfg` file. The `fact_caching` parameter under the `[defaults]` section is set to the FQCN `namespace.collection_name.cache_plugin_name`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nfact_caching = namespace.collection_name.cache_plugin_name\n```\n\n----------------------------------------\n\nTITLE: Clearing Module Defaults at Task Level in Ansible YAML\nDESCRIPTION: This Ansible task demonstrates how to remove previously established module defaults for a specific module (`file` in this case, short name for `ansible.builtin.file`) at the task level. Assigning an empty dictionary `{}` to the module within `module_defaults` clears any inherited defaults for that specific task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\n- name: Create file1\n  ansible.builtin.file:\n    state: touch\n    path: /tmp/file1\n  module_defaults:\n    file: {}\n```\n\n----------------------------------------\n\nTITLE: Running Validate-Modules Sanity Test for Ansible Plugins - Bash\nDESCRIPTION: Executes the 'ansible-test sanity' command targeting the 'validate-modules' test, checking that the plugin or module's argspec and documentation structures are correct. The command requires prior installation of dependencies and is meant to be run from the root of an Ansible repo or module directory. The 'mymodule' should be replaced with the specific plugin/module name to be validated.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_documentation.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-test sanity --test validate-modules mymodule\n```\n\n----------------------------------------\n\nTITLE: Defining Static Custom Facts with INI in Ansible (INI)\nDESCRIPTION: This snippet demonstrates how to define static custom facts for Ansible by creating an INI-formatted .fact file within the /etc/ansible/facts.d directory. The [general] section contains key-value pairs that will be transformed into variables accessible in Ansible playbooks. The file must have a .fact extension and should not be executable. Input is the file content; output is the presence of these facts under ansible_local. No special dependencies except Ansible setup module and standard INI formatting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_8\n\nLANGUAGE: ini\nCODE:\n```\n[general]\\nasdf=1\\nbar=2\n```\n\n----------------------------------------\n\nTITLE: Enforcing Role Variables with High Precedence in Ansible Roles - YAML\nDESCRIPTION: This snippet places the variable http_port in roles/x/vars/main.yml, ensuring that it is used for the role unless a parameter or extra-var explicitly overrides it. Variables set in vars have higher precedence than defaults and inventory, making them harder to override. This technique is useful for critical app or service configuration inside private roles.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_variables.rst#_snippet_24\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n# file: roles/x/vars/main.yml\\n# this will absolutely be used in this role\\nhttp_port: 80\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible NX-API Connection for Cisco NXOS (YAML)\nDESCRIPTION: Example `group_vars/nxos.yml` configuration for connecting to Cisco NXOS devices using the NX-API method over HTTP/S. It specifies the connection type (`ansible.netcommon.httpapi`), network OS, user credentials (using Ansible Vault for password), and optionally defines proxy environment variables (`proxy_env`) for accessing the device through a web proxy. Remove `proxy_env` if accessing the host directly. Use `https_proxy` instead of `http_proxy` for HTTPS proxies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nxos.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.httpapi\nansible_network_os: cisco.nxos.nxos\nansible_user: myuser\nansible_password: !vault...\nproxy_env:\n  http_proxy: http://proxy.example.com:8080\n```\n\n----------------------------------------\n\nTITLE: Enabling Debugger on Skipped Tasks within a Play (YAML)\nDESCRIPTION: This Ansible play configuration uses the `debugger` keyword set to `on_skipped` at the play level. The debugger will be invoked for any task within this play that results in a 'skipped' status, such as the example task which has a `when: False` condition.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: My play\n  hosts: all\n  debugger: on_skipped\n  tasks:\n    - name: Execute a command\n      ansible.builtin.command: \"true\"\n      when: False\n```\n\n----------------------------------------\n\nTITLE: Installing a Single Ansible Role via ansible-galaxy (Bash)\nDESCRIPTION: Uses the `ansible-galaxy role install` command to download and install a single role named `example.role`. The role is typically fetched from Ansible Galaxy and installed into the configured roles path (e.g., `/home/user/.ansible/roles/`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy role install example.role\n\n# SNIPPED_OUTPUT\n- extracting example.role to /home/user/.ansible/roles/example.role\n- example.role was installed successfully\n```\n\n----------------------------------------\n\nTITLE: Discouraged Methods for Command Execution in Ansible Modules\nDESCRIPTION: Specifies Python functions and classes (`subprocess`, `Popen`, `os.system`) that should NOT be used for executing commands within Ansible modules. Developers must use `module.run_command` instead for security and integration reasons.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsubprocess\n```\n\nLANGUAGE: python\nCODE:\n```\nPopen\n```\n\nLANGUAGE: python\nCODE:\n```\nos.system\n```\n\n----------------------------------------\n\nTITLE: Viewing Ansible Collection Plugin Documentation with ansible-doc - bash\nDESCRIPTION: This shell command uses ansible-doc to retrieve and display help for a specific plugin (of type 'lookup') within a named collection, using its Fully Qualified Collection Name (FQCN). It requires ansible-core and a properly installed collection, and assumes the plugin is available under the specified namespace and collection. Replace 'my_namespace.my_collection.lookup1' with your actual FQCN as input. The output is the plugin's documentation rendered to the terminal.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-doc -t lookup my_namespace.my_collection.lookup1\n```\n\n----------------------------------------\n\nTITLE: Setting up a Python Virtual Environment in Bash\nDESCRIPTION: Creates a Python 3 virtual environment named 'venv' in the current directory and activates it. This is a prerequisite for installing documentation dependencies in an isolated environment. Requires Python 3 to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv ./venv\nsource ./venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Ad hoc Execution of Custom Ansible Module (Shell)\nDESCRIPTION: Demonstrates the shell command for running a custom Ansible module against a remote host using an ad hoc command. The ANSIBLE_LIBRARY environment variable must be set to the directory containing the module. Expects the module (my_test) and its arguments (name, new) to be properly implemented and located. Output is shown on the console; no external Python import necessary, only an Ansible runtime.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nANSIBLE_LIBRARY=./library ansible -m my_test -a 'name=hello new=true' remotehost\n```\n\n----------------------------------------\n\nTITLE: Creating User Account with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Creates a new user account named 'foo' on all managed nodes (`all`) using the `ansible.builtin.user` module. A pre-encrypted password must be provided via the `password` argument.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m ansible.builtin.user -a \"name=foo password=<encrypted password here>\"\n```\n\n----------------------------------------\n\nTITLE: Defining Local Connection in a Single Ansible Play (YAML)\nDESCRIPTION: Demonstrates how to specify the use of a local connection in a playbook play by setting connection: local and hosts: 127.0.0.1. This enables running tasks locally, even within a playbook that may include other plays using remote connections. Requirements: Ansible, playbook structure. Inputs: N/A. Output: Tasks run on the local machine. Note: Without ansible_python_interpreter set, modules run under default python.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_delegation.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- hosts: 127.0.0.1\n  connection: local\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Template Path in `cli_parse` (YAML)\nDESCRIPTION: This Ansible task demonstrates how to override the default template path determination in `ansible.utils.cli_parse`. By specifying `parser/template_path`, the task explicitly tells the module to use the template located at `/home/user/templates/filename.yaml` for parsing the `show interface` command output with the `native` parser.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: \"Run command and parse with native\"\n     ansible.utils.cli_parse:\n       command: show interface\n       parser:\n         name: ansible.netcommon.native\n         template_path: /home/user/templates/filename.yaml\n```\n\n----------------------------------------\n\nTITLE: Specifying Numeric Host Ranges (INI)\nDESCRIPTION: Shows how to define a sequence of hosts with similar numeric patterns in an INI inventory file using range notation (`[01:50]`). This avoids listing each hostname individually.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n[webservers]\nwww[01:50].example.com\n```\n\n----------------------------------------\n\nTITLE: Pattern Alias Error Output - Ansible (Console)\nDESCRIPTION: This console output is shown when using an IP address that is only referenced as an alias in inventory, rather than the alias itself. Demonstrates the importance of matching the inventory alias in patterns.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n[WARNING]: Could not match supplied host pattern, ignoring: 127.0.0.2\n```\n\n----------------------------------------\n\nTITLE: Referencing sys.path Attribute\nDESCRIPTION: Stub documentation reference likely related to Python's module search path `sys.path`, potentially relevant within the context of Ansible module execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_12\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: sys.path\n```\n\n----------------------------------------\n\nTITLE: Defining Native Parser Template for 'ip addr show' (YAML)\nDESCRIPTION: Begins defining a native parser template (`templates/fedora_ip_addr_show.yaml`) for the `ansible.netcommon.native` parser to handle the output of the Linux `ip addr show` command. This partial snippet shows the start of the first rule, using an `example` line and a regular expression (`getval`) with the `(?x)` flag (PCRE_EXTENDED) for free-spacing mode and comments, aimed at capturing the interface name (`?P<name>`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- example: '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000'\n  getval: |\n    (?x)                                                # free-spacing\n    \\d+:\\s                                              # the interface index\n    (?P<name>\\S+):\\s                                    # the name\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Connection Plugins\nDESCRIPTION: Execute `ansible-doc -t connection -l` in the shell to display a list of all connection plugins installed and available for use in your Ansible environment. This helps identify which connection methods are supported.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t connection -l\n```\n\n----------------------------------------\n\nTITLE: Checking Current Ansible Plugin Path Configuration\nDESCRIPTION: This command uses `ansible-config dump` to output all active Ansible configuration settings and pipes the output to `grep` to filter and display lines containing `plugin_type_PATH`. Users should replace `plugin_type_PATH` with the actual configuration setting for the desired plugin type (e.g., `DEFAULT_CALLBACK_PLUGIN_PATH` or `BECOME_PLUGIN_PATH`) to see where Ansible looks for those specific standalone local plugins intended for global use.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_locally.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nansible-config dump |grep plugin_type_PATH\n```\n\n----------------------------------------\n\nTITLE: Removing User Account with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Removes the user account 'foo' from all managed nodes (`all`). This is achieved using the `ansible.builtin.user` module with the `state=absent` argument.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible all -m ansible.builtin.user -a \"name=foo state=absent\"\n```\n\n----------------------------------------\n\nTITLE: Example TTP Template for Parsing `show interface` (Jinja)\nDESCRIPTION: This snippet presents a TTP (Template Text Parser) template designed to parse the output of a `show interface` command. It uses Jinja-like syntax to define capture groups for extracting the `interface` name, its operational `state`, and its `admin_state`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_17\n\nLANGUAGE: jinja\nCODE:\n```\n   {{ interface }} is {{ state }}\n   admin state is {{ admin_state }}{{ ignore(\".*\") }}\n```\n\n----------------------------------------\n\nTITLE: Lazy Variable Evaluation in Ansible Playbooks using YAML\nDESCRIPTION: This YAML snippet demonstrates the change to lazy evaluation for variables in Ansible 2.14, especially the use of the 'undefined' test with dictionaries containing undefined keys. Prior to 2.14, evaluation would fail when accessing undefined values, but now variables are only evaluated as used, allowing safe use of 'is undefined'. Requires no special dependencies beyond Ansible 2.14; variables and nested references are inputs, and the output is pass/fail on the assertion. Be mindful of evaluation order: undefined errors are avoided unless the specific undefined value is needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.14.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- assert:\n    that:\n      - some_defined_dict_with_undefined_values is undefined\n  vars:\n    dict_value: 1\n    some_defined_dict_with_undefined_values:\n      key1: value1\n      key2: '{{ dict_value }}'\n      key3: '{{ undefined_dict_value }}'\n```\n\n----------------------------------------\n\nTITLE: Retrieving Ansible Module Documentation via CLI - Ansible - shell-session\nDESCRIPTION: Demonstrates retrieving documentation for the 'yum' Ansible module with the 'ansible-doc' command-line tool. No arguments are required except the module name. Outputs formatted module documentation to the console. Requires Ansible installed on the local system. Used for on-demand module usage details.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/module_plugin_guide/modules_intro.rst#_snippet_3\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-doc yum\n```\n\n----------------------------------------\n\nTITLE: Merged State Final Resource Configuration Example - Text\nDESCRIPTION: This code sample demonstrates what the final configuration of a network interface looks like after applying the Ansible module with 'merged' state. It shows the effect of merging new IPv6 addresses with the existing interface settings. No dependencies or inputs beyond the merged configuration are needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_resource_modules.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ninterface loopback100\\n ip address 10.10.1.100 255.255.255.0\\n ipv6 address FC00:100/64\\n ipv6 address FC00:101/64\n```\n\n----------------------------------------\n\nTITLE: Creating Directory with Ansible Ad Hoc Command in Bash\nDESCRIPTION: Creates a directory (`state=directory`) at the specified path (`dest=/path/to/c`) on all 'webservers'. This command, using the `ansible.builtin.file` module, also sets the directory's mode (`755`), owner (`mdehaan`), and group (`mdehaan`). It functions similarly to `mkdir -p`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/intro_adhoc.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible webservers -m ansible.builtin.file -a \"dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory\"\n```\n\n----------------------------------------\n\nTITLE: Creating a VLAN with NETCONF on CloudEngine OS (YAML)\nDESCRIPTION: This Ansible task uses the community.network.ce_vlan module to create a VLAN (with ID 50 and name 'WEB') on a device running CloudEngine OS, utilizing a NETCONF connection. The task is conditionally executed for hosts identified as appropriate network OS targets. Requires proper inventory configuration and that NETCONF is enabled. Key parameters are 'vlan_id' and 'name'. Returns result of the operation including changed status.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Create a vlan, id is 50(ce)\n  community.network.ce_vlan:\n    vlan_id: 50\n    name: WEB\n  when: ansible_network_os == 'community.network.ce'\n```\n\n----------------------------------------\n\nTITLE: Implementing and Exporting Shared Argument Specs in PowerShell Module Utils\nDESCRIPTION: In this PowerShell snippet, a custom module util ('ServiceAuth.psm1') defines a function (Invoke-MyServiceResource) for common resource handling and another (Get-MyNamespaceMyCollectionServiceAuthSpec) that exposes a shared argument specification as a hashtable. At the end, both functions are exported using 'Export-ModuleMember'. This allows modules to reuse both the resource handler and argument spec for consistent authentication workflows. The util is intended for importing into other modules, which can invoke these exported functions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_11\n\nLANGUAGE: powershell\nCODE:\n```\nInvoke-MyServiceResource {\n    [CmdletBinding()]\n    param (\n        [Parameter(Mandatory=$true)]\n        [ValidateScript({ $_.GetType().FullName -eq 'Ansible.Basic.AnsibleModule' })]\n        $Module,\n\n        [Parameter(Mandatory=$true)]\n        [String]\n        $ResourceId,\n\n        [String]\n        $State = 'present'\n    )\n\n    # Process the common module options known to the util\n    $params = @{\n        ServerUri = $Module.Params.my_service_url\n    }\n    if ($Module.Params.my_service_username) {\n        $params.Credential = Get-MyServiceCredential\n    }\n\n    if ($State -eq 'absent') {\n        Remove-MyService @params -ResourceId $ResourceId\n    } else {\n        New-MyService @params -ResourceId $ResourceId\n    }\n}\n\nGet-MyNamespaceMyCollectionServiceAuthSpec {\n    # Output the util spec\n    @{\n        options = @{\n            my_service_url = @{ type = 'str'; required = $true }\n            my_service_username = @{ type = 'str' }\n            my_service_password = @{ type = 'str'; no_log = $true }\n        }\n\n        required_together = @(\n            ,@('my_service_username', 'my_service_password')\n        )\n    }\n}\n\n$exportMembers = @{\n    Function = 'Get-MyNamespaceMyCollectionServiceAuthSpec', 'Invoke-MyServiceResource'\n}\nExport-ModuleMember @exportMembers\n```\n\n----------------------------------------\n\nTITLE: Creating a Deprecated Module Alias using Symlink (Shell)\nDESCRIPTION: This shell command demonstrates how to create a deprecated alias ('_fileinfo.py') for an existing module ('stat.py') in the main Ansible repository using a symbolic link. The leading underscore marks the alias as deprecated. The subsequent 'ansible' commands show that both the original name ('stat') and the alias ('fileinfo') can be used interchangeably to invoke the module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/module_lifecycle.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nln -s stat.py _fileinfo.py\nansible -m stat -a \"path=/tmp\" localhost\nansible -m fileinfo -a \"path=/tmp\" localhost\n```\n\n----------------------------------------\n\nTITLE: Illustrating the Exploded Ansible Module Directory Structure\nDESCRIPTION: This snippet shows the typical file and directory structure created after running the 'explode' command on the Ansible wrapper script. It includes the original wrapper script, a 'debug_dir' containing the extracted module code ('ping.py'), necessary 'ansible/module_utils' files, and an 'args' file with the module parameters in JSON format.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/debugging.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n├── AnsiballZ_ping.py\n└── debug_dir\n    ├── ansible\n    │   ├── __init__.py\n    │   ├── module_utils\n    │   │   ├── __init__.py\n    │   │   ├── _text.py\n    │   │   ├── basic.py\n    │   │   ├── common\n    │   │   ├── compat\n    │   │   ├── distro\n    │   │   ├── parsing\n    │   │   ├── pycompat24.py\n    │   │   └── six\n    │   └── modules\n    │       ├── __init__.py\n    │       └── ping.py\n    └── args\n```\n\n----------------------------------------\n\nTITLE: Table with Title Markdown Markdown\nDESCRIPTION: Gives a markdown example of how to create a simple table with a section title (####) and column headers. The table summarizes file descriptions and configuration settings. Proper use of markdown table syntax and heading levels improves readability and accessibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_22\n\nLANGUAGE: Markdown\nCODE:\n```\n#### File descriptions\n\n  |File       |Purpose                     |\n  |---------- | -------------------------- |\n  |foo.txt    | foo configuration settings |\n  |bar.txt    | bar configuration settings |\n```\n\n----------------------------------------\n\nTITLE: Creating Hybrid Ansible Lookup Plugins (v1.9.x/v2.0) in Python\nDESCRIPTION: This Python code provides an example of a hybrid Ansible `fileglob` lookup plugin designed to work across both Ansible 1.9.x and 2.0. It employs conditional imports (`try...except ImportError`) to handle differing module structures and defines a fallback `LookupBase` class for v1.9.x compatibility. The `run` method uses capability checks (e.g., `'path_dwim' in globals()`) to adapt its path resolution and term processing logic based on the detected Ansible version before performing the file globbing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport glob\n\ntry:\n    # ansible-2.0\n    from ansible.plugins.lookup import LookupBase\nexcept ImportError:\n    # ansible-1.9.x\n\n    class LookupBase(object):\n        def __init__(self, basedir=None, runner=None, **kwargs):\n            self.runner = runner\n            self.basedir = self.runner.basedir\n\n        def get_basedir(self, variables):\n            return self.basedir\n\ntry:\n    # ansible-1.9.x\n    from ansible.utils import (listify_lookup_plugin_terms, path_dwim, warning)\nexcept ImportError:\n    # ansible-2.0\n    from ansible.utils.display import Display\n    warning = Display().warning\n\nclass LookupModule(LookupBase):\n\n    # For ansible-1.9.x, we added inject=None as valid argument\n    def run(self, terms, inject=None, variables=None, **kwargs):\n\n        # ansible-2.0, but we made this work for ansible-1.9.x too !\n        basedir = self.get_basedir(variables)\n\n        # ansible-1.9.x\n        if 'listify_lookup_plugin_terms' in globals():\n            terms = listify_lookup_plugin_terms(terms, basedir, inject)\n\n        ret = []\n        for term in terms:\n            term_file = os.path.basename(term)\n\n            # For ansible-1.9.x, we imported path_dwim() from ansible.utils\n            if 'path_dwim' in globals():\n                # ansible-1.9.x\n                dwimmed_path = path_dwim(basedir, os.path.dirname(term))\n            else:\n                # ansible-2.0\n                dwimmed_path = self._loader.path_dwim_relative(basedir, 'files', os.path.dirname(term))\n\n            globbed = glob.glob(os.path.join(dwimmed_path, term_file))\n            ret.extend(g for g in globbed if os.path.isfile(g))\n\n        return ret\n```\n\n----------------------------------------\n\nTITLE: Running Windows Commands Using win_command in Ansible (console)\nDESCRIPTION: This snippet demonstrates how to use the win_command Ansible module to correctly escape arguments and quotes in commands run on Windows. It explains the mapping between the provided win_command task and the resulting argv array passed to subprocesses, highlighting handling of whitespace, embedded quotes, and escaped backslashes. Correct escaping ensures that arguments containing spaces or quotes are parsed correctly by the Windows shell. There are no additional dependencies beyond Ansible and an accessible Windows host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n- win_command: C:\\temp\\executable.exe argument1 \"argument 2\" \"C:\\path\\with space\" \"double \\\"quoted\\\"\"\n\nargv[0] = C:\\temp\\executable.exe\nargv[1] = argument1\nargv[2] = argument 2\nargv[3] = C:\\path\\with space\nargv[4] = double \"quoted\"\n\n- win_command: '\"C:\\Program Files\\Program\\program.exe\" \"escaped \\\\\\\" backslash\" unquoted-end-backslash\\'\n\nargv[0] = C:\\Program Files\\Program\\program.exe\nargv[1] = escaped \\\" backslash\nargv[2] = unquoted-end-backslash\\\n\n# Due to YAML and Ansible parsing '\\\"' must be written as '{% raw %}\\\\{% endraw %}\"'\n- win_command: C:\\temp\\executable.exe C:\\no\\space\\path \"arg with end \\ before end quote{% raw %}\\\\{% endraw %}\"'\n\nargv[0] = C:\\temp\\executable.exe\nargv[1] = C:\\no\\space\\path\nargv[2] = arg with end \\ before end quote\\\"\n```\n\n----------------------------------------\n\nTITLE: Setting SSH Password Mechanism via Environment Variable (Shell)\nDESCRIPTION: Configures the SSH connection plugin to use 'sshpass' by exporting the ANSIBLE_SSH_PASSWORD_MECHANISM environment variable. This method overrides settings defined in the ansible.cfg file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_SSH_PASSWORD_MECHANISM=sshpass\n```\n\n----------------------------------------\n\nTITLE: Defining Option Removed by Version - Ansible Python\nDESCRIPTION: This snippet shows how to specify deprecation info for an argument in Ansible using the removed_in_version and removed_from_collection fields within an option dictionary. These fields specify the targeted version and collection for removal. This informs users and automation about planned deprecation schedules for module arguments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\noption = {\n  'type': 'str',\n  'removed_in_version': '2.0.0',\n  'removed_from_collection': 'testns.testcol',\n},\n```\n\n----------------------------------------\n\nTITLE: Using Test Plugins in Ansible Templates - YAML+Jinja\nDESCRIPTION: Demonstrates definition and usage of test plugins in Ansible variables and task conditionals. Dependencies include an Ansible playbook context and at least one defined task_result variable. The variable 'is_ready' is set using a Jinja2 expression that applies the 'success' test plugin, while tasks use test plugins with the 'is' statement in the 'when' clauses to control execution based on task results. Inputs are playbook or role variables; outputs are booleans determining conditional execution of tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/test.rst#_snippet_0\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n  vars:\n    is_ready: '{{ task_result is success }}'\n\n  tasks:\n  - name: conditionals are always in 'template' context\n    action: dostuff\n    when: task_result is failed\n```\n\n----------------------------------------\n\nTITLE: Starting an Ansible Lookup Plugin Implementation in Python\nDESCRIPTION: Shows the initial boilerplate code for creating an Ansible lookup plugin. This includes Python 3 compatibility imports (`absolute_import`, `division`, `print_function`, `__metaclass__`) required for contributions to Ansible, and the beginning of the `DOCUMENTATION` block using a raw string literal (`r\"\"\"...`). The full implementation details and the rest of the `DOCUMENTATION` block are omitted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# python 3 headers, required if submitting to Ansible\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = r\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Viewing Documentation for a Specific Ansible Cliconf Plugin (Shell)\nDESCRIPTION: This shell command utilizes 'ansible-doc' to show the documentation, including configuration options and usage examples, for a specific Cliconf plugin. Replace '<plugin name>' with the actual name of the plugin you want to inspect (e.g., 'ios'). Requires Ansible installation and the specified plugin to be available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cliconf.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t cliconf <plugin name>\n```\n\n----------------------------------------\n\nTITLE: Configuring Plugin Routing, Deprecation, and Removal in `meta/runtime.yml` (YAML)\nDESCRIPTION: Demonstrates the `plugin_routing` section in `meta/runtime.yml`. This allows redirecting plugins to new locations (`redirect`), marking them as deprecated with warnings and removal versions/dates (`deprecation`), or removing them entirely with a fatal error message (`tombstone`). The example covers inventory plugins, modules, and module_utils.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nplugin_routing:\n  inventory:\n    kubevirt:\n      redirect: community.general.kubevirt\n    my_inventory:\n      tombstone:\n        removal_version: \"2.0.0\"\n        warning_text: my_inventory has been removed. Please use other_inventory instead.\n  modules:\n    my_module:\n      deprecation:\n        removal_date: \"2021-11-30\"\n        warning_text: my_module will be removed in a future release of this collection. Use another.collection.new_module instead.\n      redirect: another.collection.new_module\n    podman_image:\n      redirect: containers.podman.podman_image\n  module_utils:\n    ec2:\n      redirect: amazon.aws.ec2\n    util_dir.subdir.my_util:\n      redirect: namespace.name.my_util\n```\n\n----------------------------------------\n\nTITLE: Controlling Ansible Variable Merge Priority with ansible_group_priority (YAML)\nDESCRIPTION: Demonstrates setting `ansible_group_priority` within inventory source definitions (Note: not typically set in group_vars files, but directly in inventory structure) to influence the merge order of variables between groups at the same level. Higher priority values (like 10 for `a_group`) cause those variables to overwrite variables from lower-priority groups (like `b_group` with default priority 1) during the merge process, overriding the default alphabetical sorting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_26\n\nLANGUAGE: yaml\nCODE:\n```\na_group:\n  vars:\n    testvar: a\n    ansible_group_priority: 10\nb_group:\n  vars:\n    testvar: b\n```\n\n----------------------------------------\n\nTITLE: Creating Files and Directories with win_dsc - Ansible YAML+Jinja\nDESCRIPTION: Shows two sample tasks: one for creating a file with sample contents, and another for creating a hidden directory using the File DSC resource with specific attributes. Defines DestinationPath, Contents, Type, Ensure parameters, and demonstrates multi-line content support using YAML. Requires the target paths to be valid and accessible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_12\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Create file with some text\n  win_dsc:\n    resource_name: File\n    DestinationPath: C:\\temp\\file\n    Contents: |\n        Hello\n        World\n    Ensure: Present\n    Type: File\n\n- name: Create directory that is hidden is set with the System attribute\n  win_dsc:\n    resource_name: File\n    DestinationPath: C:\\temp\\hidden-directory\n    Attributes: Hidden,System\n    Ensure: Present\n    Type: Directory\n```\n\n----------------------------------------\n\nTITLE: Fetching and Rebasing Local Branch from Upstream in Bash\nDESCRIPTION: Fetches the latest changes from the `upstream` remote repository and then rebases the current local branch (assumed to be `main`) onto the `upstream/main` branch. This integrates updates from the main project repository into the local branch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ git fetch upstream\n$ git rebase upstream/main\n```\n\n----------------------------------------\n\nTITLE: Collection-Based Directory Structure in Ansible (Bash)\nDESCRIPTION: Shows the directory structure for an Ansible collection, illustrating how roles and plugins are organized within the collection's folder tree. Requires no dependencies; useful for role and plugin maintainers to reorganize content for the Ansible ecosystem. Outputs a template reference for proper structure alignment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmynamespace/\\n└── mycollection/\\n  ├── docs/\\n  ├── galaxy.yml\\n  ├── plugins/\\n  │   ├── modules/\\n  │   │   └── module1.py\\n  │   ├── inventory/\\n  │   └── .../\\n  ├── README.md\\n  ├── roles/\\n  │   ├── role1/\\n  │   ├── role2/\\n  │   └── .../\\n  ├── playbooks/\\n  │   ├── files/\\n  │   ├── vars/\\n  │   ├── templates/\\n  │   └── tasks/\\n  └── tests/\\n\n```\n\n----------------------------------------\n\nTITLE: Invoking Windows Module Auth in PowerShell - PowerShell\nDESCRIPTION: This PowerShell snippet demonstrates how to invoke a module named ServiceAuth using a module object, passing in required parameters such as resource ID and state. The code then uses the module's ExitJson method to cleanly exit and return results. Dependencies include the ServiceAuth module's implementation and a correctly initialized $module object with Params/state values filled in. Inputs expected are the Ansible module object and its parameter set; outputs are the structured response via ExitJson. This is foundational for integrating custom PowerShell resources into Ansible modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_13\n\nLANGUAGE: powershell\nCODE:\n```\n# Call the ServiceAuth module util and pass in the module object so it can access the module options.\\nInvoke-MyServiceResource -Module $module -ResourceId $module.Params.resource_id -State $module.params.state\\n\\n$module.ExitJson()\n```\n\n----------------------------------------\n\nTITLE: Overriding Command-Line Options in Ansible Shell\nDESCRIPTION: Demonstrates how Ansible resolves conflicting single-value command-line options. The example shows running an ad hoc `ping` command where the `-u` (user) option is specified twice; the last instance (`-u carol`) overrides the earlier one (`-u mike`), illustrating the 'last defined wins' rule for command-line options.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/general_precedence.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible -u mike -m ping myhost -u carol\n```\n\n----------------------------------------\n\nTITLE: Deprecating connection=local for Network Platforms in community.network\nDESCRIPTION: Support for using `connection=local` with network platforms that utilize the persistent connection framework is deprecated. This practice will likely be removed or cease to function correctly in future releases.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_25\n\nLANGUAGE: Ansible\nCODE:\n```\nconnection=local\n```\n\n----------------------------------------\n\nTITLE: Setting Up Local PowerShell Debugging for Ansible Modules - PowerShell\nDESCRIPTION: This PowerShell script configures a local debugging environment for an Ansible module on Windows. It sets up error handling, prepares arguments from a JSON file or in-script variable, imports referenced PowerShell and C# utilities, and marks where to insert module code for execution. Dependencies are the presence of supporting Ansible module utility files and the correct module script structure. Inputs can be a JSON arguments file or an explicit $complex_args dictionary. The code enables step-through debugging before deploying with Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_15\n\nLANGUAGE: powershell\nCODE:\n```\n# Set $ErrorActionPreference to what's set during Ansible execution\\n$ErrorActionPreference = \"Stop\"\\n\\n# Set the first argument as the path to a JSON file that contains the module args\\n$args = @(\"$($pwd.Path)\\args.json\")\\n\\n# Or instead of an args file, set $complex_args to the pre-processed module args\\n$complex_args = @{\\n    _ansible_check_mode = $false\\n    _ansible_diff = $false\\n    path = \"C:\\\\temp\"\\n    state = \"present\"\\n}\\n\\n# Import any C# utils referenced with '#AnsibleRequires -CSharpUtil' or 'using Ansible.;\\n# The $_csharp_utils entries should be the context of the C# util files and not the path\\nImport-Module -Name \"$($pwd.Path)\\powershell\\Ansible.ModuleUtils.AddType.psm1\"\\n$_csharp_utils = @(\\n    [System.IO.File]::ReadAllText(\"$($pwd.Path)\\csharp\\Ansible.Basic.cs\")\\n)\\nAdd-CSharpType -References $_csharp_utils -IncludeDebugInfo\\n\\n# Import any PowerShell modules referenced with '#Requires -Module`\\nImport-Module -Name \"$($pwd.Path)\\powershell\\Ansible.ModuleUtils.Legacy.psm1\"\\n\\n# End of the setup code and start of the module code\\n#!powershell\n```\n\n----------------------------------------\n\nTITLE: Applying Unsafe Tag to Elements in Complex Ansible Variables (YAML)\nDESCRIPTION: Illustrates how to apply the `!unsafe` tag to individual elements within complex data structures like lists (arrays) and dictionaries (hashes) in Ansible YAML variables. This allows specific parts of a complex variable to be protected from templating while other elements ('safe element') remain templatable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_advanced_syntax.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\nmy_unsafe_array:\n  - !unsafe 'unsafe element'\n  - 'safe element'\n\nmy_unsafe_hash:\n  unsafe_key: !unsafe 'unsafe value'\n```\n\n----------------------------------------\n\nTITLE: Type Checking with binary_type and text_type using ansible.module_utils.six (Python)\nDESCRIPTION: This snippet replaces isinstance(s, basestring) with a check for binary_type and text_type, suitable for environments using Python 3. It requires importing binary_type and text_type from ansible.module_utils.six and ensures compatibility by explicitly distinguishing between binary and text string types. s is the input variable to be type-checked; returns True if s is either a binary or text type.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-basestring.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.six import binary_type, text_type\n\nif isinstance(s, (binary_type, text_type)):\n    # Do something with string or bytes\n```\n\n----------------------------------------\n\nTITLE: Collecting and Registering Network Interface Facts on NXOS Devices - YAML\nDESCRIPTION: This sequence illustrates runtime network interface detection for Ansible playbooks via nxos_command. It executes a 'show interface brief | json' command, registers and parses its output into structured facts, and sets variables for use in later tasks. Requires Ansible and cisco.nxos collection. Inputs: device connection and output; outputs: updated fact variables for interface testing. Ensures dynamic adaption of tests to available interfaces and avoids hard-coding.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Collect interface list\n  connection: ansible.netcommon.network_cli\n  register: intout\n  cisco.nxos.nxos_command:\n    commands:\n      - show interface brief | json\n\n- set_fact:\n    intdataraw: \"{{ intout.stdout_lines[0]['TABLE_interface']['ROW_interface'] }}\"\n\n- set_fact:\n    nxos_int1: '{{ intdataraw[1].interface }}'\n\n- set_fact:\n    nxos_int2: '{{ intdataraw[2].interface }}'\n\n- set_fact:\n    nxos_int3: '{{ intdataraw[3].interface }}'\n```\n\n----------------------------------------\n\nTITLE: Configuring Ubuntu PPA and Installing Ansible on Debian (Bash)\nDESCRIPTION: Sets up the Ubuntu Ansible PPA repository on a Debian system and installs Ansible. It requires selecting the correct Ubuntu codename corresponding to the Debian version. The script sets the codename variable, downloads and installs the PPA's GPG signing key securely, adds the PPA source to APT's configuration, updates the package list, and installs the 'ansible' package. Requires 'wget', 'gpg', and root privileges (sudo). Emphasizes secure key handling without using the deprecated 'apt-key add'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ UBUNTU_CODENAME=jammy\n$ wget -O- \"https://keyserver.ubuntu.com/pks/lookup?fingerprint=on&op=get&search=0x6125E2A8C77F2818FB7BD15B93C4A3FD7BB9C367\" | sudo gpg --dearmour -o /usr/share/keyrings/ansible-archive-keyring.gpg\n$ echo \"deb [signed-by=/usr/share/keyrings/ansible-archive-keyring.gpg] http://ppa.launchpad.net/ansible/ansible/ubuntu $UBUNTU_CODENAME main\" | sudo tee /etc/apt/sources.list.d/ansible.list\n$ sudo apt update && sudo apt install ansible\n```\n\n----------------------------------------\n\nTITLE: Implementing the parse Method for Data Fetching and Inventory Population in Python\nDESCRIPTION: This Python snippet demonstrates a more complete implementation of the `parse` method within an Ansible inventory plugin (`InventoryModule` named 'myplugin'). It first calls the base class `parse` method, then reads plugin configuration using `_read_config_data(path)`. It retrieves plugin options (like API credentials) using `self.get_option()`, connects to an external API (represented by `apilib`), fetches data (`mysession.getitall()`), and finally iterates through the data to populate the Ansible inventory using `self.inventory.add_host()` and `self.inventory.set_variable()`. This illustrates the core logic of fetching external data and translating it into Ansible hosts and variables.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n   NAME = 'myplugin'\n\n   def parse(self, inventory, loader, path, cache=True):\n\n        # call base method to ensure properties are available for use with other helper methods\n        super(InventoryModule, self).parse(inventory, loader, path, cache)\n\n        # this method will parse 'common format' inventory sources and\n        # update any options declared in DOCUMENTATION as needed\n        config = self._read_config_data(path)\n\n        # if NOT using _read_config_data you should call set_options directly,\n        # to process any defined configuration for this plugin,\n        # if you don't define any options you can skip\n        #self.set_options()\n\n        # example consuming options from inventory source\n        mysession = apilib.session(user=self.get_option('api_user'),\n                                   password=self.get_option('api_pass'),\n                                   server=self.get_option('api_server')\n        )\n\n\n        # make requests to get data to feed into inventory\n        mydata = mysession.getitall()\n\n        #parse data and create inventory objects:\n        for colo in mydata:\n            for server in mydata[colo]['servers']:\n                self.inventory.add_host(server['name'])\n                self.inventory.set_variable(server['name'], 'ansible_host', server['external_ip'])\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Collection with GPG Signature Verification using Bash\nDESCRIPTION: This command uses `ansible-galaxy` to install the collection `my_namespace.my_collection` while performing GPG signature verification. The `--keyring ~/.ansible/pubring.kbx` option specifies the path to the GnuPG keyring containing the necessary public keys obtained from the distribution server. If the signature cannot be verified using a key in this keyring, the installation fails. This option is not needed if the keyring path is configured via environment variable or `ansible.cfg`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install my_namespace.my_collection --keyring ~/.ansible/pubring.kbx\n```\n\n----------------------------------------\n\nTITLE: Running Verbose Integration Test Output in Shell\nDESCRIPTION: This example demonstrates running the lineinfile integration test with high verbosity using '-vvv'. The additional v's provide more detailed output, which aids in debugging test failures or investigating output. Syntax accepts standard verbosity flags as per ansible-test CLI.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration lineinfile -vvv\n```\n\n----------------------------------------\n\nTITLE: Fixing Jinja Order of Operations Issue with Parentheses in Ansible\nDESCRIPTION: This Ansible playbook snippet shows the corrected version of a conditional affected by Jinja's order of operations. By adding parentheses `(\"local\" ~ \"host\")`, the concatenation is performed first, and the `contains` test correctly operates on the resulting string, producing the required boolean result for the conditional.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname is contains(\"local\" ~ \"host\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Loop Variable Name Dynamically\nDESCRIPTION: This snippet shows how a role author can dynamically access the value associated with the loop variable specified by `loop_control.loop_var`. It uses `lookup('vars', ansible_loop_var)` where `ansible_loop_var` holds the *name* of the loop variable (e.g., 'outer_item'). This allows the role to work correctly regardless of the variable name chosen by the user calling the role.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_29\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n\"{{ lookup('vars', ansible_loop_var) }}\"\n```\n\n----------------------------------------\n\nTITLE: Adapting Callback Plugins for Ansible 2.0 API in Python\nDESCRIPTION: This Python snippet demonstrates how to modify an Ansible callback plugin for compatibility with the Ansible 2.0 API. It subclasses `CallbackBase` and manually stores playbook, play, and task information within the class instance using the `v2_*` methods (e.g., `v2_playbook_on_start`), as Ansible 2.0 no longer automatically populates `self.playbook`, `self.play`, or `self.task`. The `v2_on_any` method shows an example of accessing this stored context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom ansible.plugins.callback import CallbackBase\n\nclass CallbackModule(CallbackBase):\n    def __init__(self):\n        self.playbook = None\n        self.playbook_name = None\n        self.play = None\n        self.task = None\n\n    def v2_playbook_on_start(self, playbook):\n        self.playbook = playbook\n        self.playbook_name = os.path.basename(self.playbook._file_name)\n\n    def v2_playbook_on_play_start(self, play):\n        self.play = play\n\n    def v2_playbook_on_task_start(self, task, is_conditional):\n        self.task = task\n\n    def v2_on_any(self, *args, **kwargs):\n        self._display.display('%s: %s: %s' % (self.playbook_name,\n        self.play.name, self.task))\n```\n\n----------------------------------------\n\nTITLE: Debugging with regex_replace Filter: Ansible Playbook YAML Syntax (Ansible 1.9.x)\nDESCRIPTION: This YAML snippet demonstrates how to use the 'debug' module with a Jinja2 regex_replace filter to transform a string and handle escaping in Ansible 1.9.x. Dependencies include Jinja2 templating and the Ansible core debug module. The 'msg' parameter applies a regular expression pattern and replacement, where double-backslash escaping is required. The input is a debug playbook task, the output is the transformed message; care should be taken with Python and YAML string escapes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- debug:\n    msg: \"{{ 'test1_junk 1\\\\3' | regex_replace('(.*)_junk (.*)', '\\\\1 \\\\2') }}\"\n```\n\n----------------------------------------\n\nTITLE: Setting SSH Credential Delegation Option in Ansible Inventory - yaml+jinja\nDESCRIPTION: This YAML+Jinja inventory variable instructs Ansible to add the `GSSAPIDelegateCredentials=yes` SSH option, enabling Kerberos ticket delegation. Required for GSSAPI-based authentication when accessing network resources from the remote host. Set in host or group variables, it works alongside correct Ansible and Kerberos client configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nansible_ssh_common_args: -o GSSAPIDelegateCredentials=yes\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook with Invalid Package Name - YAML\nDESCRIPTION: This YAML playbook attempts to install a package using the ansible.builtin.apt module, but specifies an intentionally invalid package name using the variable 'pkg_name'. It demonstrates how a configuration error is introduced for the purposes of interactive debugging. Dependencies include Ansible itself, a reachable host in the 'test' inventory, and appropriate user permissions. Input is the variable 'pkg_name', and execution will result in a failure that triggers the debugger.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: test\n  strategy: debug\n  gather_facts: true\n  vars:\n    pkg_name: not_exist\n  tasks:\n    - name: Install a package\n      ansible.builtin.apt: name={{ pkg_name }}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Undefined Variables in Templates - Ansible Playbook - YAML\nDESCRIPTION: Shows various ways to declare undefined variables in Ansible 5's templating engine, using the new undef() function. This assists in template validation and signaling variables that must be overridden. The optional hint parameter in undef() supplies a message for intended overrides. No external dependencies beyond standard Ansible. Inputs: variable declarations; Outputs: undefined values, with optional hints for later definition.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_5.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  old: \"{{ undef }}\"\n  new: \"{{ undef() }}\"\n  new_with_hint: \"{{ undef(hint='You must override this variable') }}\"\n```\n\n----------------------------------------\n\nTITLE: Example Structured Output from ntc_templates Parser\nDESCRIPTION: Shows an example of the structured data stored in the `interfaces` fact after parsing the `show interface` command output using the `ntc_templates` parser. The output is a list of dictionaries, where each dictionary represents an interface and its properties as defined by the corresponding TextFSM template in the `ntc_templates` library.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/cli_parsing.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\ninterfaces:\n- address: 5254.005a.f8b5\n  admin_state: up\n  bandwidth: 1000000 Kbit\n  bia: 5254.005a.f8b5\n  delay: 10 usec\n  description: ''\n  duplex: full-duplex\n  encapsulation: ARPA\n  hardware_type: Ethernet\n  input_errors: ''\n  input_packets: ''\n  interface: mgmt0\n  ip_address: 192.168.101.14/24\n  last_link_flapped: ''\n  link_status: up\n  mode: ''\n  mtu: '1500'\n  output_errors: ''\n  output_packets: ''\n  speed: 1000 Mb/s\n- address: 5254.005a.f8bd\n  admin_state: up\n  bandwidth: 1000000 Kbit\n  bia: 5254.005a.f8bd\n  delay: 10 usec\n```\n\n----------------------------------------\n\nTITLE: Setting Per-Task Network Module Timeout in Ansible Playbook - YAML+Jinja\nDESCRIPTION: Demonstrates the use of the 'timeout' parameter in a network module task within an Ansible playbook (here, for cisco.ios.ios_command). This allows specifying a custom timeout for a single task, overriding global values. Key parameters include the command to run and timeout in seconds. Requires Ansible and Cisco IOS collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_29\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: save running-config\n  cisco.ios.ios_command:\n    commands: copy running-config startup-config\n    provider: \"{{ cli }}\"\n    timeout: 30\n```\n\n----------------------------------------\n\nTITLE: Configuring eAPI Connection Group Variables for Arista EOS in YAML\nDESCRIPTION: This YAML snippet defines Ansible group variables (`group_vars/eos.yml`) for connecting to Arista EOS devices using the eAPI connection (`ansible.netcommon.httpapi`). It sets the network OS, user credentials (using Vault), enables privilege escalation, and includes an example `proxy_env` dictionary for configuring an HTTP proxy. Remove `proxy_env` if no proxy is needed, or change `http_proxy` to `https_proxy` for HTTPS proxies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eos.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.httpapi\nansible_network_os: arista.eos.eos\nansible_user: myuser\nansible_password: !vault...\nansible_become: true\nansible_become_method: enable\nproxy_env:\n  http_proxy: http://proxy.example.com:8080\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: invocation\nDESCRIPTION: Provides an example of the `invocation` key, which contains details about how the Ansible module was called, including the specific arguments (`module_args`) passed to it during execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n\"invocation\": {\n        \"module_args\": {\n            \"_original_basename\": \"foo.txt\",\n            \"attributes\": null,\n            \"backup\": true,\n            \"checksum\": \"da39a3ee5e6b4b0d3255bfef95601890afd80709\",\n            \"content\": null,\n            \"delimiter\": null,\n            \"dest\": \"./foo.txt\",\n            \"directory_mode\": null,\n            \"follow\": false,\n            \"force\": true,\n            \"group\": null,\n            \"local_follow\": null,\n            \"mode\": \"666\",\n            \"owner\": null,\n            \"regexp\": null,\n            \"remote_src\": null,\n            \"selevel\": null,\n            \"serole\": null,\n            \"setype\": null,\n            \"seuser\": null,\n            \"src\": \"/Users/foo/.ansible/tmp/ansible-tmp-1596115458.110205-105717464505158/source\",\n            \"unsafe_writes\": null,\n            \"validate\": null\n        }\n\n```\n\n----------------------------------------\n\nTITLE: Generating Table of Contents for Plugin Indexes in RST\nDESCRIPTION: This reStructuredText snippet uses the Sphinx `toctree` directive to generate a table of contents. It sets a maximum depth of 1, assigns the caption 'Plugin indexes', and uses a glob pattern `index_*` to automatically include all files in the current directory whose names start with 'index_'. This is commonly used in Sphinx-based documentation to create structured navigation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections/all_plugins.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n   :caption: Plugin indexes\n   :glob:\n\n   index_*\n```\n\n----------------------------------------\n\nTITLE: Referencing Component Path in Bug Report - Markdown\nDESCRIPTION: This snippet shows the component file path (as an interpolated variable \\u2013 %(path)s) involved in the deprecation notice within the Ansible project. The path is intended to help maintainers to quickly identify which file is responsible for the deprecated usage. This display-only code expects substitution of %(path)s with the actual affected component path and does not perform any computation itself.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/deprecated_issue_template.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n```\n%(path)s\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Ansible Module with Complex Arguments using Shell\nDESCRIPTION: Demonstrates running 'test-module.py' with complex, nested arguments for a module (specified by '-m module'). The arguments, corresponding to the example YAML structure, are passed as a single JSON string enclosed in single quotes using the '-a' flag.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./hacking/test-module.py -m module \\\n    -a '{\"parent\": {\"child\": [{\"item\": \"first\", \"val\": \"foo\"}, {\"item\": \"second\", \"val\": \"bar\"}]}}'\n```\n\n----------------------------------------\n\nTITLE: Backing Up SLX-OS Configuration with community.network.slxos_config (YAML)\nDESCRIPTION: This YAML playbook task uses the community.network.slxos_config module to back up the running configuration from a SLX-OS switch. It requires the device to be accessible via Ansible with appropriate network_cli settings and the community.network collection installed. The main parameter is backup: yes; the resulting backup location is registered for later use. The operation is conditional, running only when ansible_network_os matches 'community.network.slxos'. The expected output is a registered variable storing the backup file path; limitations include requiring prior inventory/connection setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_slxos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (slxos)\\n  community.network.slxos_config:\\n    backup: yes\\n  register: backup_slxos_location\\n  when: ansible_network_os == 'community.network.slxos'\\n\n```\n\n----------------------------------------\n\nTITLE: Shutdown All WSL Instances - Shell\nDESCRIPTION: Demonstrates how to stop all running Windows Subsystem for Linux (WSL) instances as part of configuring Docker Desktop integration. Requires Windows with WSL enabled.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nwsl --shutdown\n```\n\n----------------------------------------\n\nTITLE: Retrieving Ansible Facts via Ad-Hoc Command in Shell\nDESCRIPTION: This shell command executes an Ansible ad-hoc command to gather and display facts for a specific `<hostname>` defined in the inventory. It explicitly runs the `ansible.builtin.setup` module (`-m ansible.builtin.setup`) on the target host. This requires Ansible to be installed, an inventory file configured, and working SSH access to the specified host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible <hostname> -m ansible.builtin.setup\n```\n\n----------------------------------------\n\nTITLE: Callback Handling of `meta` Tasks\nDESCRIPTION: Explicit `meta` tasks triggered within a playbook are now reported to callback plugins via the `v2_playbook_on_task_start` method, similar to regular tasks. By default, internal meta tasks (like `flush_handlers`) are not sent. Callback plugins can opt-in to receive these internal task events as well.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n# In a callback plugin\nclass CallbackModule(CallbackBase):\n    CALLBACK_VERSION = 2.0\n    CALLBACK_TYPE = 'stdout'\n    CALLBACK_NAME = 'my_callback'\n\n    # Set this to True to receive internal meta tasks\n    # V2_INTERNAL_TASK_INCLUDE = True \n\n    def v2_playbook_on_task_start(self, task, is_conditional):\n        # This method will now be called for explicit meta tasks\n        # (e.g., ansible.builtin.meta: refresh_inventory)\n        # If V2_INTERNAL_TASK_INCLUDE is True, it also triggers for implicit ones.\n        display.display(f\"Starting task: {task.get_name()}\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Task with the 'never' Tag in Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet shows a task making use of the reserved 'never' and an additional 'debug' tag within the 'tags' list. The debug task runs only if either '--tags debug' or '--tags never' is specified at runtime, and is skipped otherwise. The task demonstrates advanced selective execution: targeting rarely-used or explicitly requested operations. Dependencies include Ansible core, and 'showmevar' should be set prior to use.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tags.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\\n  - name: Run the rarely-used debug task, either with ``--tags debug`` or ``--tags never``\\n    ansible.builtin.debug:\\n     msg: '{{ showmevar }}'\\n    tags: [ never, debug ]\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Test File for an Ansible Collection Module\nDESCRIPTION: Shows the content of a pytest-based unit test file for the convert_to_supported function within an Ansible collection. Dependencies include pytest, datetime, and decimal; ansible_collections.community.mycollection.plugins.modules.my_module must be importable for the test to work. Test inputs are parametrized to cover multiple cases, and an explicit test checks exception raising. The file should be placed in the tests/units/plugins/modules/ directory, and asserts function correctness for various types.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_unit_tests.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# -*- coding: utf-8 -*-\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom datetime import timedelta\nfrom decimal import Decimal\n\nimport pytest\n\nfrom ansible_collections.community.mycollection.plugins.modules.my_module import (\n    convert_to_supported,\n)\n\n# We use the @pytest.mark.parametrize decorator to parametrize the function\n# https://docs.pytest.org/en/latest/how-to/parametrize.html\n# Simply put, the first element of each tuple will be passed to\n# the test_convert_to_supported function as the test_input argument\n# and the second element of each tuple will be passed as\n# the expected argument.\n# In the function's body, we use the assert statement to check\n# if the convert_to_supported function given the test_input,\n# returns what we expect.\n@pytest.mark.parametrize('test_input, expected', [\n    (timedelta(0, 43200), '12:00:00'),\n    (Decimal('1.01'), 1.01),\n    ('string', 'string'),\n    (None, None),\n    (1, 1),\n])\ndef test_convert_to_supported(test_input, expected):\n    assert convert_to_supported(test_input) == expected\n\ndef test_convert_to_supported_exception():\n    with pytest.raises(ValueError, match=r\"too cool\"):\n        convert_to_supported(42)\n\n```\n\n----------------------------------------\n\nTITLE: Example Hosts Definitions for Collection Playbooks (YAML+Jinja)\nDESCRIPTION: Provides several concise examples for specifying 'hosts' in playbooks distributed in collections. These demonstrate generic targeting, restricting to the control node, or dynamically using an input variable. Requires standard Ansible inventory layouts. Outputs are determined by subsequent tasks in the play.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_using_playbooks.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n - hosts: all  # Use --limit or customized inventory to restrict hosts targeted\\n\\n - hosts: localhost  # For things you want to restrict to the control node\\n\\n - hosts: '{{target|default(\"webservers\")}}'  # Assumes inventory provides a 'webservers' group, but can also use ``-e 'target=host1,host2'``\n```\n\n----------------------------------------\n\nTITLE: Automatically Accept SSH Host Keys via Environment Variable - Shell\nDESCRIPTION: Sets 'ANSIBLE_PARAMIKO_HOST_KEY_AUTO_ADD' to True before running ansible-playbook, instructing Paramiko to automatically trust and add new SSH host keys for remote connections. This approach bypasses manual host key verification and should be used with caution. Only an Ansible installation is required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_PARAMIKO_HOST_KEY_AUTO_ADD=True\nansible-playbook ...\n```\n\n----------------------------------------\n\nTITLE: Migrating Jinja Arithmetic and Concatenation in Ansible Playbooks - YAML\nDESCRIPTION: Illustrates the change in how arithmetic and concatenation with Jinja templates must be performed in Ansible 2.13 and newer. Prior to 2.13, arithmetic or list concatenation could be performed outside Jinja blocks; from 2.13, such operations must reside entirely within double curly braces. These examples demonstrate how to migrate existing playbook debug messages for compatibility. No external dependencies required; ensure the playbook targets at least Ansible-core 2.13 for the updated syntax to function as intended.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_6.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Prior to 2.13\\n  debug:\\n    msg: '[1] + {{ [2] }}'\\n\\n- name: 2.13 and forward\\n  debug:\\n    msg: '{{ [1] + [2] }}'\n```\n\n----------------------------------------\n\nTITLE: Failing Ansible Module Execution on Missing Dependency - Python\nDESCRIPTION: This snippet demonstrates invoking fail_json in an Ansible module when an optional library is missing. It uses the HAS_ANOTHER_LIBRARY flag and error info set by a guarded import. The call to module.fail_json gives a clear error message using missing_required_lib and includes exception details. Dependencies: Ansible's core module logic. Inputs: Import status flags. Output: A structured failure message to the user. Intended for use in the main execution path of a module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmodule = AnsibleModule(...)\n\nif not HAS_ANOTHER_LIBRARY:\n    module.fail_json(\n        msg=missing_required_lib('another_library'),\n        exception=ANOTHER_LIBRARY_IMPORT_ERROR)\n```\n\n----------------------------------------\n\nTITLE: Getting Ansible Galaxy Role Information via CLI\nDESCRIPTION: Shows how to use the `ansible-galaxy role info` command to fetch detailed metadata about a specific role from Ansible Galaxy. Replace `username.role_name` with the actual qualified role name. Requires the `ansible-galaxy` command-line tool.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role info username.role_name\n```\n\n----------------------------------------\n\nTITLE: Looping Over Hosts in the Current Play using 'ansible_play_batch'\nDESCRIPTION: This task utilizes `ansible.builtin.debug` to display the hostname for each host targeted in the current Ansible play execution. The loop iterates over the `ansible_play_batch` variable, which contains the list of hosts being acted upon in the specific run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_18\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Show all the hosts in the current play\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  loop: \"{{ ansible_play_batch }}\"\n```\n\n----------------------------------------\n\nTITLE: Corrected Complex Conditional without Quotes (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This resolves the earlier logic problem by removing improper quotes so that both parts of the expression are evaluated as Jinja tests, correctly enforcing boolean logic. Requirements: Ansible and 'inventory_hostname'. Output: assertion pass/fail, with logically correct evaluation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname is defined and inventory_hostname | length > 0\n```\n\n----------------------------------------\n\nTITLE: String Conversion using to_text, to_bytes, and to_native from ansible.module_utils.common.text.converters (Python)\nDESCRIPTION: This code demonstrates the usage of conversion utilities to_text, to_bytes, and to_native from ansible.module_utils.common.text.converters to convert values to Unicode text, bytes, or native Python string types, respectively. These converters are tailored for robust handling of type coercion across different Python versions. Dependencies include importing the functions from the specified Ansible utility module. Input can be any object; outputs are converted to the desired string type with default or specified encoding.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-basestring.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.common.text.converters import to_text, to_bytes, to_native\n\ntext_version = to_text(s)\nbytes_version = to_bytes(s)\nnative_version = to_native(s)\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible in Pull Mode\nDESCRIPTION: The `ansible-pull` command initiates Ansible's pull mode. Unlike the default push mode, pull mode involves target nodes periodically checking a version control repository (typically Git) for playbook updates and then executing `ansible-playbook` locally to apply the configuration. It relies on the local connection plugin and is often scheduled using cron.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nansible-pull\n```\n\n----------------------------------------\n\nTITLE: Pushing Ansible Backport Branch to Fork using Shell\nDESCRIPTION: Shows the `git push` command used to upload the local backport branch (e.g., 'backport/2.18/[PR_NUMBER_FROM_DEVEL]') to the contributor's fork on GitHub (assumed to be configured as the 'origin' remote). This step makes the backported changes available online for creating a pull request against the upstream stable branch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n   git push origin backport/2.18/[PR_NUMBER_FROM_DEVEL]\n```\n\n----------------------------------------\n\nTITLE: Dynamic Fileglob Lookup Based on Variable List in Ansible Jinja2\nDESCRIPTION: This Ansible task copies files matching patterns derived from the `mygroups` list. The `globlist` variable uses `map` and `regex_replace` to transform group names (e.g., 'prod') into glob patterns (e.g., 'files/prod/*.conf'). The `q(\"fileglob\", *globlist)` uses the `q` lookup (short for `query`) and Python argument list unpacking (`*`) to pass the generated list of patterns to the `fileglob` lookup, finding all matching files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_9\n\nLANGUAGE: YAML+Jinja\nCODE:\n```\n- hosts: all\n  vars:\n    mygroups:\n      - prod\n      - web\n  tasks:\n    - name: Copy a glob of files based on a list of groups\n      copy:\n        src: \"{{ item }}\"\n        dest: \"/tmp/{{ item }}\"\n      loop: '{{ q(\"fileglob\", *globlist) }}'\n      vars:\n        globlist: '{{ mygroups | map(\"regex_replace\", \"^(.*)$\", \"files/\\1/*.conf\") | list }}'\n```\n\n----------------------------------------\n\nTITLE: Defining CimInstance Property for win_dsc in YAML\nDESCRIPTION: This incomplete snippet demonstrates the start of defining a `[CimInstance]` DSC property type within an Ansible `win_dsc` task. CimInstance types, which represent complex dictionary-like objects in DSC, are defined using standard YAML dictionary syntax in the Ansible task. The example shows the key `AuthenticationInfo` which corresponds to a DSC property expecting a CimInstance object (specifically, `DSC_WebAuthenticationInformation`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# [CimInstance]AuthenticationInfo == DSC_WebAuthenticationInformation\nAuthenticationInfo:\n```\n\n----------------------------------------\n\nTITLE: Patching and Mocking Ansible Network Device Methods in Unit Tests - Python\nDESCRIPTION: This Python snippet shows how to use unittest.mock's patch to mock Ansible network module methods for configuration and connection in unit tests. Dependencies: Python standard/unittest.mock and Ansible's codebase. Inputs: method references; outputs: start()ed mock objects saved as instance attributes. This allows test authors to simulate device APIs and outputs in isolated, offline unit tests. Ensures repeatability and isolation in CI pipelines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nself.mock_get_config = patch( \"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.network.Config.get_config\"\n)\nself.get_config = self.mock_get_config.start()\n\nself.mock_load_config = patch(\n\"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.network.Config.load_config\"\n)\nself.load_config = self.mock_load_config.start()\n\nself.mock_get_resource_connection_config = patch(\n\"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.cfg.base.get_resource_connection\"\n)\nself.get_resource_connection_config = (self.mock_get_resource_connection_config.start())\n\nself.mock_get_resource_connection_facts = patch(\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of Concatenation and Contains Test in Conditional (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This snippet incorrectly applies the Jinja '~' concatenation after the 'contains' test, resulting in a truthy string instead of a boolean. It serves to show parsing precedence errors that are now caught in Ansible-core 2.19. Requirement: Jinja-aware Ansible playbook. Output: error due to the non-boolean conditional result.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_5\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname is contains \"local\" ~ \"host\"\n```\n\n----------------------------------------\n\nTITLE: Optional Import of `module_utils` in Custom Modules\nDESCRIPTION: Custom Ansible modules can now mark imports of Python `module_utils` as optional by wrapping the `import` statement within a `try...except ImportError` or `if` block. This allows modules to gracefully handle missing utilities, potentially falling back to alternative logic, enhancing compatibility across different Ansible or collection versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ntry:\n    from ansible.module_utils.some_utility import useful_function\n    HAS_UTILITY = True\nexcept ImportError:\n    HAS_UTILITY = False\n\ndef main():\n    # ... module setup ...\n    if HAS_UTILITY:\n        result = useful_function(module.params['input'])\n    else:\n        # Fallback logic if the utility is not present\n        result = fallback_implementation(module.params['input'])\n    # ... return result ...\n```\n\n----------------------------------------\n\nTITLE: Setting Global Strategy in Ansible Configuration (INI)\nDESCRIPTION: This snippet configures the ansible.cfg file, setting the global execution strategy to 'free' under the '[defaults]' section. This affects all Ansible runs unless overridden in an individual play. Dependencies: an existing ansible.cfg file. The 'strategy' parameter controls playbook execution sequencing; no special input beyond standard Ansible usage.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_strategies.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\\nstrategy = free\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Failure Case for Double-Quoted Windows Path in YAML (text)\nDESCRIPTION: This snippet shows an example YAML assignment where a Windows path is incorrectly specified using double quotes and an unescaped backslash, leading to YAML's interpretation of escape sequences (e.g., '\\\\t' as a TAB character). This illustrates a common pitfall when defining Windows paths in YAML and underscores the importance of proper escaping or quoting. No special dependencies are required apart from adherence to YAML syntax rules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_usage.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n# FAILS\ntempdir: \"C:\\Windows\\Temp\"\n```\n\n----------------------------------------\n\nTITLE: Moving Custom Module into Collection Plugins Directory in Bash\nDESCRIPTION: This bash snippet moves an existing module, 'manage_webserver.py', from a standalone role's library directory to the correct plugins/modules path under a collection, renaming it to 'manage.py' in the process. Shows the use of 'cp' for file migration and highlights the required path convention for Ansible collections. Useful for adapting custom modules for collection usage and FQCN.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ cp my-standalone-role.webapp/library/manage_webserver.py acme/webserver/plugins/modules/manage.py\n```\n\n----------------------------------------\n\nTITLE: Viewing Specific Ansible Module/Plugin Documentation (Shell)\nDESCRIPTION: Executes the `ansible-doc` command followed by a specific module or plugin name (represented by `<name>`) to retrieve detailed documentation and usage examples. The output clarifies if the specified module has an associated action plugin. Requires Ansible to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/action.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc <name>\n```\n\n----------------------------------------\n\nTITLE: Discouraged Method for Fetching URLs (Insecure for HTTPS)\nDESCRIPTION: Discourages the direct use of Python's `urllib2` module for fetching URLs within Ansible modules, particularly for HTTPS. `urllib2` does not natively verify TLS certificates, making connections potentially insecure. Use `fetch_url` or `open_url` from `ansible.module_utils.urls` instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nurllib2\n```\n\n----------------------------------------\n\nTITLE: Configuring File Exclusion in Galaxy.yml (YAML)\nDESCRIPTION: Shows how to configure the build_ignore option in galaxy.yml to exclude specific files or folders, such as a sensitive directory under playbooks or files with .tar.gz extensions, from collection tarballs during build. Requires Ansible Galaxy 2.10 or newer; build_ignore is not compatible with manifest. Inputs are list of paths or glob patterns; outputs are reduced tarballs omitting specified files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nbuild_ignore:\n- playbooks/sensitive\n- '*.tar.gz'\n```\n\n----------------------------------------\n\nTITLE: Adding an Upstream Remote in Git - Shell\nDESCRIPTION: Provides the command to add a new remote named \\\\\"upstream\\\\\" to an existing local Git repository, pointing to the official Ansible project. Requires Git, appropriate permissions, and assumes the repository hasn't already had this remote added. This is essential for pulling updates from the main project repository for rebasing purposes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ git remote add upstream https://github.com/ansible/ansible.git\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Modules via CLI - Ansible - shell-session\nDESCRIPTION: Shows how to list all available Ansible modules by passing '-l' to the 'ansible-doc' command. The output is a module name list printed to the console. No input except the option flag is required. This command requires a functioning Ansible environment. Useful for exploration and discovery of installed modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/module_plugin_guide/modules_intro.rst#_snippet_4\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-doc -l\n```\n\n----------------------------------------\n\nTITLE: Verifying Successful Kerberos Delegation via Ansible (klist.exe)\nDESCRIPTION: This shell command uses Ansible's `ansible.windows.win_command` module to execute `klist.exe` on a remote Windows host (`WINHOST`). The provided output demonstrates a successful Kerberos delegation scenario. Key indicators are the `Server` field showing `krbtgt/MY.DOMAIN.COM @ MY.DOMAIN.COM` and the `Ticket Flags` including the `forwarded` flag.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible WINHOST -m ansible.windows.win_command -a klist.exe\n\nWINHOST | CHANGED | rc=0 >>\n\nCurrent LogonId is 0:0x82b6977\n\nCached Tickets: (1)\n\n#0>     Client: username @ MY.DOMAIN.COM\n        Server: krbtgt/MY.DOMAIN.COM @ MY.DOMAIN.COM\n        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96\n        Ticket Flags 0x60a10000 -> forwardable forwarded renewable pre_authent name_canonicalize\n        Start Time: 8/30/2024 14:15:18 (local)\n        End Time:   8/31/2024 0:12:49 (local)\n        Renew Time: 9/6/2024 14:12:49 (local)\n        Session Key Type: AES-256-CTS-HMAC-SHA1-96\n        Cache Flags: 0x1 -> PRIMARY\n        Kdc Called:\n```\n\n----------------------------------------\n\nTITLE: Regular Expression Pattern - Ansible Playbooks (YAML)\nDESCRIPTION: This YAML snippet utilizes a regex pattern ('~(web|db).*\\.example\\.com') to select hosts whose names match the regular expression. Inventory entries must be named accordingly. Regular expression support requires a properly configured Ansible version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n~(web|db).*\\.example\\.com\n```\n\n----------------------------------------\n\nTITLE: Importing Ansible's Bundled six Library in Python\nDESCRIPTION: Demonstrates how to import the `six` compatibility library bundled within Ansible's `module_utils`. This ensures the library is available without requiring separate installation on managed nodes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils import six\n```\n\n----------------------------------------\n\nTITLE: Getting Documentation for a Specific Ansible Connection Plugin\nDESCRIPTION: Use the command `ansible-doc -t connection <plugin name>` (replacing `<plugin name>` with the actual plugin name, e.g., `ssh` or `winrm`) to view detailed documentation, configuration options, and usage examples for that specific Ansible connection plugin.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t connection <plugin name>\n```\n\n----------------------------------------\n\nTITLE: Correcting Ansible Conditional to Access Proper Attribute (YAML+Jinja)\nDESCRIPTION: Presents the corrected Ansible `stat` task. The `failed_when` condition now correctly references the nested attribute `result.stat.exists`, resolving the undefined variable issue and ensuring the conditional logic works as intended.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_17\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- stat:\n    path: /does-not-exist\n  register: result\n  failed_when: result.stat.exists is false\n```\n\n----------------------------------------\n\nTITLE: Handling Jinja2 Native Types in Ansible Templates\nDESCRIPTION: Details the change in behavior for the 'jinja2_native' setting. It no longer affects the template module/lookup by default. A new argument 'jinja2_native' (defaulting to false) is introduced for the template lookup to control native type handling, while other Jinja2 expressions still respect the global setting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n# Example of the new argument for template lookup\n- name: Template a file with native types\n  ansible.builtin.template:\n    src: my_template.j2\n    dest: /path/to/destination\n    jinja2_native: true\n```\n\n----------------------------------------\n\nTITLE: Initializing Ansible Collection with Custom Skeleton (Bash)\nDESCRIPTION: This bash command initializes a new Ansible collection using a custom skeleton template and an optional JSON variable file. It is useful when default collection scaffolding is not sufficient and development standards require template customization. Requires ansible-galaxy to be available, a valid skeleton path, and optionally a JSON file with extra variables. Output is a tailored collection directory structure matching the custom skeleton's layout.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_creating.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible_collections#> ansible-galaxy collection init --collection-skeleton /path/to/my/namespace/skeleton --extra-vars \"@my_vars_file.json\" my_namespace.my_collection\n```\n\n----------------------------------------\n\nTITLE: Specifying IdentityFile in SSH Config for Bastion Host (INI)\nDESCRIPTION: This snippet demonstrates how to specify a particular private key file within the SSH configuration file for authenticating to the jump host defined in the `ProxyCommand`. The `IdentityFile` directive points to the absolute path of the private key (`/absolute/path/to/private-key.pem`) required for the jump host connection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netconf_enabled.rst#_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\nIdentityFile \"/absolute/path/to/private-key.pem\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Handler Inclusion and Invocation with include_role in Ansible (YAML)\nDESCRIPTION: Illustrates updated behavior when including roles and handlers using include_role in ansible-core 2.15. The snippet shows two separate invocations of a role ('foo'), one directly and another within a conditional block applied only to a certain host. The code is designed to highlight that, as of 2.15, the last handler of a given name ('foo_handler') added to the play is the one executed, and handler notifications are de-duplicated. This affects which hosts actually execute the handler when using variables and conditionals on included roles. Prerequisites include existence of a role named 'foo' with a handler 'foo_handler'. Input consists of the order and context of role inclusions; output concerns which handlers are executed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.15.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- include_role:\\n    name: foo\\n  vars:\\n    invocation: 1\\n\\n- block:\\n   - include_role:\\n       name: foo\\n     vars:\\n       invocation: 2\\n  when: inventory_hostname == \\\"bar\\\"\\n\\n- meta: flush_handlers\n```\n\n----------------------------------------\n\nTITLE: Applying a Specific Jinja Test in Console\nDESCRIPTION: Provides a specific example of the Jinja test syntax, checking if the variable `result` evaluates to the boolean False using the `failed` test.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nresult is failed\n```\n\n----------------------------------------\n\nTITLE: Executing a CLI Command on WeOS 4 using Ansible (YAML)\nDESCRIPTION: This Ansible task demonstrates how to execute a simple CLI command (`show version`) on a WeOS 4 device. It uses the `ansible.netcommon.cli_command` module, specifies the command to run, registers the output in the `show_ver` variable, and uses a `when` condition to ensure the task only runs on hosts identified as WeOS 4.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_weos4.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Get version information (WeOS 4)\n  ansible.netcommon.cli_command:\n    commands: \"show version\"\n  register: show_ver\n  when: ansible_network_os == 'community.network.weos4'\n```\n\n----------------------------------------\n\nTITLE: Using Variables in Patterns - Ansible Playbooks (Bash)\nDESCRIPTION: This bash code demonstrates injecting variables into Ansible host patterns for dynamic exclusion ('!') and intersection ('&') via the '-e' argument, increasing pattern flexibility. Variables must be defined prior to use and supplied at runtime.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nwebservers:!{{ excluded }}:&{{ required }}\n```\n\n----------------------------------------\n\nTITLE: Searching Ansible Log Files by PID - Shell\nDESCRIPTION: Shows how to use the grep utility in the shell to filter log entries by process ID (PID) within an Ansible log file. Relies on having a known ANSIBLE_LOG_PATH and a relevant PID to search for connections and events related to a specific process. Outputs matching log lines. Useful for narrowing troubleshooting focus to specific task executions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngrep \"p=28990\" $ANSIBLE_LOG_PATH\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Collection from a Tarball using Bash\nDESCRIPTION: This command uses `ansible-galaxy` to install a collection from a local tarball file (`my_namespace-my_collection-1.0.0.tar.gz`). The `-p ./collections` option specifies that the collection should be installed into the `./collections/ansible_collections/` directory relative to the current working directory, unless `./collections` already exists and is named `ansible_collections`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install my_namespace-my_collection-1.0.0.tar.gz -p ./collections\n```\n\n----------------------------------------\n\nTITLE: Converting Unicode Filenames to Bytes for Filesystem Operations - Python\nDESCRIPTION: Illustrates converting a Unicode filename to bytes using to_bytes for robust cross-version filesystem operations. Depends on os.path and ansible.module_utils.common.text.converters.to_bytes. Issues can occur if non-ASCII chars are present and types are mixed, especially on POSIX systems. This pattern is recommended for safe open, stat, and path expansion on both Python 2 and 3.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os.path\n\nfrom ansible.module_utils.common.text.converters import to_bytes\n\nfilename = u'/var/tmp/くらとみ.txt'\nf = open(to_bytes(filename), 'wb')\nmtime = os.path.getmtime(to_bytes(filename))\nb_filename = os.path.expandvars(to_bytes(filename))\nif os.path.exists(to_bytes(filename)):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Initializing Check Mode Support for Ansible Modules (Python)\nDESCRIPTION: By passing `supports_check_mode=True` to `AnsibleModule`, this snippet enables the module to detect if execution should occur in check mode (dry run). Requires the `AnsibleModule` and an argument_spec. The boolean `module.check_mode` should be checked before making changes, ensuring idempotency and safe simulation. No parameters beyond argument_spec and the Boolean flag are needed; outputs as a module object with check mode capabilities.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nmodule = AnsibleModule(argument_spec, supports_check_mode=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Mutually Exclusive Options - Ansible Python\nDESCRIPTION: This snippet provides an example of declaring groups of mutually exclusive arguments for an Ansible module. Each tuple in the mutually_exclusive list denotes a set of arguments that cannot be specified together. If more than one argument from a group is provided, module execution will fail.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nmutually_exclusive=[\n  ('path', 'content'),\n  ('repository_url', 'repository_filename'),\n],\n```\n\n----------------------------------------\n\nTITLE: Role Directory Structure for CLIConf and Terminal Plugins - Ansible Plugins Bash\nDESCRIPTION: Demonstrates how to place cliconf and terminal plugins within the plugins directories of an Ansible role. This layout enables plugins to be used with the network_cli connection type within specific roles or collections. Requires the inclusion of actual Python plugin files inside these folders.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmyrole/cliconf_plugins/\\nmyrole/terminal_plugins/\\n\n```\n\n----------------------------------------\n\nTITLE: Parenthesized Concatenation Before Contains Test (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This corrects the earlier snippet by using parentheses to force concatenation before the 'contains' test. Ensures the conditional always evaluates to a boolean as required. Needs Ansible, Jinja, and suitable inventory context. Output: assertion result based on host string containing 'localhost'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname is contains(\"local\" ~ \"host\")\n```\n\n----------------------------------------\n\nTITLE: Type Checking with string_types using ansible.module_utils.six (Python)\nDESCRIPTION: This Python code snippet demonstrates how to check if a variable is an instance of any string type using string_types from ansible.module_utils.six. This approach replaces the deprecated isinstance(s, basestring) which is not available in Python 3. It requires importing string_types from Ansible's six compatibility module and is useful for code intended to run under both Python 2 and 3. Input is expected as the variable s, output is a boolean indicating type membership.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-basestring.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.six import string_types\n\nif isinstance(s, string_types):\n    # Do something with string\n```\n\n----------------------------------------\n\nTITLE: Checking Status of Asynchronous Jobs via Ansible CLI (bash)\nDESCRIPTION: Shows how to query the status of a previously launched asynchronous job using its job ID through the Ansible async_status module. Assumes a background job has been started and its jid is known. Outputs job status details. Used for follow-up or cleanup of asynchronous tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_async.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible web1.example.com -m async_status -a \"jid=488359678239.2844\"\n```\n\n----------------------------------------\n\nTITLE: Disabling Host Key Checking in Ansible Configuration - Ansible Config - Text\nDESCRIPTION: This text block should be placed in 'ansible.cfg' or '~/.ansible.cfg' files to disable host key checking by setting the configuration parameter 'host_key_checking' to 'False'. When set, Ansible will not validate remote hosts' SSH keys, streamlining automation but reducing security. Applies globally to all Ansible runs that use the config file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n[defaults]\\nhost_key_checking = False\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Scoped Ansible Changelog Entry Format in YAML\nDESCRIPTION: Specifies the standard YAML format for a scoped changelog entry within an Ansible fragment. It mandates starting with a scope (like a module or plugin name, e.g., 'foo_module' or 'foo inventory plugin'), followed by a lowercase description ending with a period and a parenthesized link to the relevant issue or PR.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- scope - description starting with a lowercase letter and ending with a period at the very end. Multiple sentences are allowed (https://github.com/reference/to/an/issue or, if there is no issue, reference to a pull request itself).\n```\n\n----------------------------------------\n\nTITLE: Including Common Module Boilerplate via Module Replacer (Python)\nDESCRIPTION: This placeholder comment, used in new-style Python modules processed by the Module Replacer framework, serves as a directive to include common Ansible module boilerplate code. It is functionally equivalent to importing 'ansible.module_utils.basic'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n#<<INCLUDE_ANSIBLE_MODULE_COMMON>>\n```\n\n----------------------------------------\n\nTITLE: Declaring resolvelib Dependency for Ansible Core (Python)\nDESCRIPTION: Specifies that `resolvelib` version `0.5.3` or higher, but less than `0.6.0`, is now a direct dependency of `ansible-core`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nresolvelib >= 0.5.3, < 0.6.0\n```\n\n----------------------------------------\n\nTITLE: Using Meta Tasks as Handlers - Ansible Documentation - Markdown\nDESCRIPTION: This section describes the support for meta tasks as handlers since Ansible 2.14. It cautions that the flush_handlers meta task cannot itself be used as a handler to avoid unintended execution side effects. The information is targeted at users seeking to leverage meta-level operations as part of their handler workflow.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_handlers.rst#_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\nSince Ansible 2.14 :ansplugin:`meta tasks <ansible.builtin.meta#module>` are allowed to be used and notified as handlers. Note that however ``flush_handlers`` cannot be used as a handler to prevent unexpected behavior.\n```\n\n----------------------------------------\n\nTITLE: Handling Expected Failures in PostgreSQL User Integration Tests with Ansible YAML\nDESCRIPTION: This YAML snippet demonstrates how to explicitly test failure scenarios for a module option in Ansible integration tests. It shows using 'ignore_errors: true' to allow an intentional failure, registering the module's output, and then asserting both the failed state and a specific expected message. Dependencies include presence of a module parameter that may trigger failure and assertion logic. Key parameters are test user data and module-specific trigger options. Expected input is a failing scenario; expected output is an assertion that failure state and message are as expected. This pattern helps ensure error handling functionality is thoroughly tested.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_updating.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Test for fail_when_true option\n  community.postgresql.postgresql_user:\n    name: test_user\n    fail_when_true: true\n  register: result\n  ignore_errors: true\n\n- name: Check the module fails and returns message we expect\n  assert:\n    that:\n      - result is failed\n      - result.msg == 'The message we expect'\n```\n\n----------------------------------------\n\nTITLE: Generating a Basic Ansible Configuration File (ansible.cfg) using Console\nDESCRIPTION: This command uses `ansible-config init --disabled` to generate a default `ansible.cfg` file containing all standard Ansible settings. The `--disabled` flag ensures all generated settings are initially commented out, allowing users to selectively uncomment and modify them. The output is redirected using `>` to create or overwrite the `ansible.cfg` file in the current directory. Requires Ansible to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_configuration.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ ansible-config init --disabled > ansible.cfg\n```\n\n----------------------------------------\n\nTITLE: Running a NOS Show Command via Ansible Task - YAML\nDESCRIPTION: This example illustrates a playbook task that runs the 'show version' command on an Extreme NOS device using the community.network.nos_command module. The result of the command is registered as show_ver for potential later use. The task is conditional on ansible_network_os being set to community.network.nos, ensuring correct targeting during multi-platform playbooks. This requires the community.network collection and assumes proper host and connection variables have been set elsewhere.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_nos.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Get version information (nos)\n  community.network.nos_command:\n    commands: \"show version\"\n  register: show_ver\n  when: ansible_network_os == 'community.network.nos'\n\n```\n\n----------------------------------------\n\nTITLE: Deprecating xbps force Option in community.general\nDESCRIPTION: The `force` option in the `xbps` module is deprecated because it never had any functional effect. It will be removed in community.general version 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_18\n\nLANGUAGE: Ansible\nCODE:\n```\nxbps: force\n```\n\n----------------------------------------\n\nTITLE: External Link Markdown Markdown\nDESCRIPTION: Shows the markdown syntax for an external hyperlink, which is important for referencing resources outside the local documentation set. The example links to the Ansible Documentation website. No additional dependencies other than markdown rendering are required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_17\n\nLANGUAGE: Markdown\nCODE:\n```\n[Ansible Documentation](https://docs.ansible.com)\n```\n\n----------------------------------------\n\nTITLE: Enabling NETCONF on Cisco IOS-XR with Ansible (YAML)\nDESCRIPTION: Playbook task to enable the NETCONF subsystem on a Cisco IOS-XR device. This uses the iosxr_netconf module via the network_cli connection and ensures the necessary prerequisites (such as ncclient Python library installed on control node) are in place. 'when' clause restricts execution to compatible devices. Connection and device credentials must be properly configured in inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_iosxr.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Enable NETCONF\\n  connection: ansible.netcommon.network_cli\\n  cisco.iosxr.iosxr_netconf:\\n  when: ansible_network_os == 'cisco.iosxr.iosxr'\\n\n```\n\n----------------------------------------\n\nTITLE: Retrieving Unique Cache Key for Inventory Plugin - Python\nDESCRIPTION: Here, the 'parse' method extends its logic to retrieve a unique cache key by calling 'get_cache_key' with the 'path'. This key is required to isolate and manage separate cache entries for different inventory sources. The code ensures that logic for custom inventory and caching is executed after superclass initialization and cache plugin loading.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef parse(self, inventory, loader, path, cache=True):\n    super(InventoryModule, self).parse(inventory, loader, path)\n\n    self.load_cache_plugin()\n    cache_key = self.get_cache_key(path)\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Host Key Checking via Environment Variable - Bash\nDESCRIPTION: This Bash command disables host key checking for Ansible in the current shell session by setting the 'ANSIBLE_HOST_KEY_CHECKING' environment variable to 'False'. This avoids interactive prompts during sessions (for example, when running from cron), but reduces SSH connection security. Ensure this is used consciously in trusted environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ export ANSIBLE_HOST_KEY_CHECKING=False\\n\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Modules with ansible-doc (Bash)\nDESCRIPTION: Executes `ansible-doc -t module -l` to list all available Ansible modules. The `-t module` flag filters the plugin types to show only modules, and `-l` requests a list format.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/cheatsheet.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nansible-doc -t module -l\n#...\n```\n\n----------------------------------------\n\nTITLE: Running Playbook with Become in Ansible CLI - Shell\nDESCRIPTION: Demonstrates the command line invocation for running a playbook with privilege escalation (become) and interactive password prompt. The --become and --ask-become-pass flags enable sudo or equivalent privileges depending on the become_method used. The CLI prompt output changes between Ansible versions; by default, version 2.8 uses 'BECOME password:'. Input is the site playbook (site.yml); output is a prompt for the become password. No dependencies beyond Ansible CLI and playbook YAML files. Recommended for users transitioning to new privilege prompts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook --become --ask-become-pass site.yml\nBECOME password:\n```\n\n----------------------------------------\n\nTITLE: Loading Cache Plugin via Plugin Loader in Ansible - Python\nDESCRIPTION: Demonstrates proper loading of a cache plugin using Ansible's plugin loader mechanism, as direct imports of cache plugins are deprecated. The code uses 'cache_loader.get' to fetch a cache plugin instance (e.g., 'redis'), allowing for configuration through variables and Ansible's config system. Dependency: ansible.plugins.loader. Key parameter is plugin name; additional options passed as kwargs. Input: plugin name (e.g., 'redis'), kwargs for config. Output: cache backend instance. Forward-compatible for custom cache plugins.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.loader import cache_loader\ncache = cache_loader.get('redis', **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Quoted Assertion Expression to Ensure String Type (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: The corrected version of the previous example, this snippet quotes the entire assertion expression, ensuring it's parsed as a string and processed correctly by the engine. Dependencies: 'result.msg' variable, Ansible 2.19+. Output: assertion based on string equality check.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_8\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that:\n         - 'result.msg == \"some_key: some_value\"'\n```\n\n----------------------------------------\n\nTITLE: Combining `until` and `with_items` for Retrying Tasks in Ansible\nDESCRIPTION: This YAML task demonstrates combining a loop (`with_items`) with retry logic (`until`, `retries`, `delay`). It attempts to access several URLs using the `uri` module. Each URL request is retried up to 2 times with a 1-second delay until the HTTP status code is 200 (`uri_output.status == 200`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n.. code-block:: yaml\n\n    - name: Retry combined with a loop\n      uri:\n        url: \"https://{{ item }}.ansible.com\"\n        method: GET\n      register: uri_output\n      with_items:\n      - \"galaxy\"\n      - \"docs\"\n      - \"forum\"\n      - \"www\"\n      retries: 2\n      delay: 1\n      until: \"uri_output.status == 200\"\n```\n\n----------------------------------------\n\nTITLE: Using Unsafe Variables in Ansible Playbooks (YAML)\nDESCRIPTION: Shows how to declare a variable using the `!unsafe` tag within the `vars` section of an Ansible playbook. This ensures the variable's value (`'unsafe % value'`) is treated as a literal string and is not processed by the Jinja2 templating engine during playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_advanced_syntax.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\nhosts: all\nvars:\n  my_unsafe_variable: !unsafe 'unsafe % value'\ntasks:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Importing CLI Tasks in Ansible Network Module Test Playbook - YAML\nDESCRIPTION: This YAML playbook snippet imports CLI-specific tasks for integration testing of the vyos_l3_interfaces Ansible module. It tags the included tasks with 'cli' for selective execution. There are no additional parameters, and the primary input is the 'cli.yaml' file; output is the execution of the referenced tasks. Requires the Ansible test folder structure and the referenced task file in place.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- import_tasks: cli.yaml\n  tags:\n    - cli\n```\n\n----------------------------------------\n\nTITLE: Logging in to Retrieve API Token - Ansible HTTPAPI Python\nDESCRIPTION: Defines the login method for an httpapi plugin, which authenticates with a remote API endpoint to acquire and store a session or token. Depends on the send_request function and a custom AnsibleAuthenticationFailure exception. Inputs are credentials (username and password); if successful, sets the connection's _auth dictionary with the obtained token from the response. Raises AnsibleAuthenticationFailure on failure. Intended for custom authentication workflows requiring an explicit login endpoint.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef login(self, username, password):\\n    login_path = '/my/login/path'\\n    data = {'user': username, 'password': password}\\n\\n    response = self.send_request(data, path=login_path)\\n    try:\\n        # This is still sent as an HTTP header, so we can set our connection's _auth\\n        # variable manually. If the token is returned to the device in another way,\\n        # you will have to keep track of it another way and make sure that it is sent\\n        # with the rest of the request from send_request()\\n        self.connection._auth = {'X-api-token': response['token']}\\n    except KeyError:\\n        raise AnsibleAuthenticationFailure(message=\"Failed to acquire login token.\")\\n\n```\n\n----------------------------------------\n\nTITLE: Checking User Account Delegation Eligibility in PowerShell\nDESCRIPTION: This PowerShell code snippet is part of a larger function (`Test-IsDelegatable`). It checks the 'useraccountcontrol' and 'memberof' properties of a user account object (`$res`) to determine if the account is marked as sensitive/not delegated (`$NOT_DELEGATED`) or is a member of the 'Protected Users' group. The function returns `$true` if the user is *not* sensitive and *not* in 'Protected Users', indicating potential delegatability, and `$false` otherwise. It requires the user object (`$res`) obtained likely via `Get-ADUser`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_12\n\nLANGUAGE: powershell\nCODE:\n```\n        }\n        else {\n            $uac = $res.Properties.useraccountcontrol[0]\n            $memberOf = @($res.Properties.memberof)\n\n            $isSensitive = [bool]($uac -band $NOT_DELEGATED)\n            $isProtectedUser = [bool]($memberOf -like 'CN=Protected Users,*').Count\n\n            -not ($isSensitive -or $isProtectedUser)\n        }\n    }\n\n    Test-IsDelegatable -UserName username\n```\n\n----------------------------------------\n\nTITLE: Performing Explicit Double-Interpolation with Jinja in YAML\nDESCRIPTION: Shows the correct and explicit way to achieve double variable interpolation in Ansible using Jinja2 syntax (`\"{{ other_variable }}\"`). This method works consistently across Ansible versions and clearly indicates the intent to interpolate the value of `other_variable` into `double_interpolated`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_8\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nvars:\n  double_interpolated: \"{{ other_variable }}\"\n  other_variable: false\n```\n\n----------------------------------------\n\nTITLE: Handling Syslog Facility in Ansible Modules (Python)\nDESCRIPTION: Compares the legacy `module_replacer` method with the current `Ansiballz` approach for initializing syslog logging within an Ansible module. The `Ansiballz` method retrieves the facility name from the `_syslog_facility` attribute of an `AnsibleModule` instance and uses `getattr` to find the corresponding `syslog` constant before calling `syslog.openlog`. This demonstrates how modules adapt to the `_ansible_syslog_facility` argument.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Old module_replacer way\nimport syslog\nsyslog.openlog(NAME, 0, syslog.LOG_USER)\n\n# New Ansiballz way\nimport syslog\nfacility_name = module._syslog_facility\nfacility = getattr(syslog, facility_name, syslog.LOG_USER)\nsyslog.openlog(NAME, 0, facility)\n```\n\n----------------------------------------\n\nTITLE: Transitioning Ansible PostgreSQL Info Module to New FQCN - Markdown\nDESCRIPTION: This entry explains the need to update FQCNs for the PostgreSQL info module from the general community collection to the dedicated community.postgresql collection in Ansible 2.9 environments. Installing the collection and updating the FQCN prevents lookup errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.postgresql_info`` → ``community.postgresql.postgresql_info``\n```\n\n----------------------------------------\n\nTITLE: Modifying Error Regex per Task (YAML)\nDESCRIPTION: Demonstrates overriding the default standard error regular expressions for a specific task using the `ansible_terminal_stderr_re` variable within `vars`. This example defines a specific pattern ('connection timed out') with case-insensitive matching ('re.I') as the *only* pattern to be considered an error for this task, preventing false positives from other output. Requires Ansible 2.9+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_45\n\nLANGUAGE: yaml\nCODE:\n```\n- name: fetch logs from remote host\n  cisco.ios.ios_command:\n    commands:\n      - show logging\n  vars:\n    ansible_terminal_stderr_re:\n      - pattern: 'connection timed out'\n        flags: 're.I'\n```\n\n----------------------------------------\n\nTITLE: Using RST code-block Directive for Bash Code\nDESCRIPTION: Demonstrates the usage of the reStructuredText `code-block` directive to embed code snippets within documentation. This example specifically shows how to format a block of `bash` commands, including `ssh` for connecting to a remote host and `show config` for displaying configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/basic_rules.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. code-block:: rst\n\n   .. code-block:: bash\n\n     ssh my_vyos_user@vyos.example.net\n     show config\n```\n\n----------------------------------------\n\nTITLE: Backing Up Junos OS Configuration via NETCONF (YAML)\nDESCRIPTION: Showcases a playbook task that uses the junipernetworks.junos.junos_config module with the backup option enabled to save the current Junos OS configuration. Requires NETCONF connection settings in the inventory and prior enabling of NETCONF on the device. The result of the backup is registered for further playbook use and the task applies only to properly detected Junos OS hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_junos.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (junos)\\n  junipernetworks.junos.junos_config:\\n    backup: yes\\n  register: backup_junos_location\\n  when: ansible_network_os == 'junipernetworks.junos.junos'\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing File- or Database-backed Cache Plugins with BaseCacheModule (Python)\nDESCRIPTION: Shows the initial template for creating a new cache plugin by subclassing BaseCacheModule. The __init__ method ensures arguments and keyword arguments are passed to the base class for compatibility with inventory plugin cache options. Plugin options should be accessed with self.get_option after initialization; typically requires options such as _uri, _prefix, and _timeout.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.cache import BaseCacheModule\n\nclass CacheModule(BaseCacheModule):\n    def __init__(self, *args, **kwargs):\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Ansible Inventory Structure - INI\nDESCRIPTION: This INI-formatted snippet provides an alternate representation of the same Ansible inventory described in YAML above. It defines groups, hosts within those groups, and children (nested grouping) using Ansible’s INI inventory format. The approach is suited for simpler or legacy environments and requires standard Ansible support for INI inventories.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[leafs]\nleaf01\nleaf02\n\n[spines]\nspine01\nspine02\n\n[network:children]\nleafs\nspines\n\n[webservers]\nwebserver01\nwebserver02\n\n[datacenter:children]\nnetwork\nwebservers\n\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible using pip (Bash)\nDESCRIPTION: This Bash command installs the Ansible automation tool using pip, the Python package installer. It requires Python and pip to be pre-installed and accessible in the system's PATH.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_ansible.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install ansible\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Group Variables for RouterOS CLI Connections (YAML)\nDESCRIPTION: This YAML snippet defines group variables typically placed in `group_vars/routeros.yml` for connecting to RouterOS devices using the `network_cli` connection type. It sets the network OS (`community.network.routeros`), user credentials (potentially using Ansible Vault for passwords), enables privilege escalation, and configures SSH options like using a bastion host via `ProxyCommand`. Requires the `community.network` collection and `ansible.netcommon.network_cli`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_routeros.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n   ansible_connection: ansible.netcommon.network_cli\n   ansible_network_os: community.network.routeros\n   ansible_user: myuser\n   ansible_password: !vault...\n   ansible_become: true\n   ansible_become_method: enable\n   ansible_become_password: !vault...\n   ansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Querying Recent Coverage Runs via Python Script (Shell)\nDESCRIPTION: This shell snippet demonstrates how to invoke the get_recent_coverage_runs.py script to query recent CI coverage test URLs and statuses from Azure Pipelines. The script accepts an optional branch name parameter, defaulting to \"devel\" if unspecified. It requires Python installed and the script available at hacking/azp/. The output provides URLs and statuses for test runs, suitable for reviewing coverage trends.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/azp/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nhacking/azp/get_recent_coverage_runs.py <optional branch name>\n```\n\n----------------------------------------\n\nTITLE: Updating Authentication via Token or Cookie - Ansible HTTPAPI Python\nDESCRIPTION: Implements update_auth for an httpapi plugin to process Set-Cookie headers in HTTP API responses, returning authorization data for subsequent requests. No dependencies except standard HTTP response objects. The method accepts the HTTP response and its text, returns a dictionary containing any set Cookie headers to merge with future request headers, or None if no authentication token is present.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef update_auth(self, response, response_text):\\n    cookie = response.info().get('Set-Cookie')\\n    if cookie:\\n        return {'Cookie': cookie}\\n\\n    return None\\n\n```\n\n----------------------------------------\n\nTITLE: Explicit Boolean Conversion with Length Test in Conditional (Ansible, YAML+Jinja)\nDESCRIPTION: This snippet corrects the previous problem by explicitly checking the length of 'inventory_hostname' and comparing it to zero, ensuring the conditional resolves to a boolean. It is valid under the new Ansible-core behavior. Required dependency: Ansible-core 2.19 or later. Parameters: 'inventory_hostname' (string). Returns assertion success/failure, with improved reliability and no hidden truthiness.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname | length > 0\n```\n\n----------------------------------------\n\nTITLE: Sample Output of Custom Facts in Ansible (JSON)\nDESCRIPTION: This JSON snippet shows the result structure after running Ansible's setup module to collect custom facts. It presents a nested dictionary where the preferences fact contains a general section with asdf and bar keys. No code execution is required; the snippet illustrates the data structure Ansible users should expect in their fact gathering output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_vars_facts.rst#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\\n    \"ansible_local\": {\\n        \"preferences\": {\\n            \"general\": {\\n                \"asdf\" : \"1\",\\n                \"bar\"  : \"2\"\\n            }\\n        }\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Backing Up Dell OS9 Switch Config with dellemc.os9.os9_config - YAML\nDESCRIPTION: This YAML snippet illustrates an Ansible task for backing up the current switch configuration on a Dell OS9 device using the dellemc.os9.os9_config module. It registers the backup location for later use and includes a conditional 'when' statement to restrict execution to Dell OS9 network devices. Proper privileges are required and variable registration enables later retrieval of backup path or data.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_dellos9.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Backup current switch config (dellos9)\\n  dellemc.os9.os9_config:\\n    backup: yes\\n  register: backup_dellos9_location\\n  when: ansible_network_os == 'dellemc.os9.os9'\n```\n\n----------------------------------------\n\nTITLE: Defining an Ansible Documentation Fragment in Python\nDESCRIPTION: This Python code defines a class `ModuleDocFragment` which serves as a container for reusable documentation snippets. It includes a standard `DOCUMENTATION` section and an additional named section `OTHER`, both containing documentation strings formatted for Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n.. code-block:: python\n\n    class ModuleDocFragment(object):\n        # Standard documentation\n        DOCUMENTATION = r'''\n        options:\n          # options here\n        '''\n\n        # Additional section\n        OTHER = r'''\n        options:\n          # other options here\n        '''\n```\n\n----------------------------------------\n\nTITLE: Generating Native .NET Images using Ansible win_dotnet_ngen Module\nDESCRIPTION: This Ansible task utilizes the `win_dotnet_ngen` module to trigger the generation of native .NET images on the target Windows host. This is intended to process the Ngen queue, often run during golden image creation, to prevent high CPU usage during the initial boot of instances spawned from that image. Requires the `win_dotnet_ngen` module and assumes consistent CPU architecture between image build and deployment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_performance.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: generate native .NET images for CPU\n  win_dotnet_ngen:\n```\n\n----------------------------------------\n\nTITLE: Inventory Alias Definition - Ansible Inventory (YAML)\nDESCRIPTION: This YAML code defines an inventory group 'atlanta' with a host alias 'host1', including host variables like http_port, maxRequestsPerChild, and ansible_host. These variables support host customization and connection details. Requires use of alias ('host1') when targeting; using the underlying IP in patterns causes an error.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\natlanta:\\n  hosts:\\n    host1:\\n      http_port: 80\\n      maxRequestsPerChild: 808\\n      ansible_host: 127.0.0.2\n```\n\n----------------------------------------\n\nTITLE: Creating Ansible Vault Password File\nDESCRIPTION: Demonstrates how to create a plain text file containing the password for Ansible Vault using the `echo` command and shell redirection. This file can then be referenced when encrypting or decrypting secrets.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_inventory.rst#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\necho \"my-ansible-vault-pw\" > ~/my-ansible-vault-pw-file\n```\n\n----------------------------------------\n\nTITLE: Setting Interpreter Paths for Multiple Languages (Python, Perl)\nDESCRIPTION: This Ansible inventory snippet (INI format) demonstrates setting interpreter paths for both Python and Perl within the variables for a 'freebsd' group. It sets 'ansible_python_interpreter' and 'ansible_perl_interpreter', which might be necessary for custom modules or plugins that rely on specific Perl versions or locations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_14\n\nLANGUAGE: ini\nCODE:\n```\n[freebsd:vars]\nansible_python_interpreter=/usr/local/bin/python\nansible_perl_interpreter=/usr/local/bin/perl\n```\n\n----------------------------------------\n\nTITLE: Installing Collections from an Offline Folder with Requirements File - Ansible Galaxy - Bash\nDESCRIPTION: Provides a two-step example for installing all previously downloaded collections from an offline folder using ansible-galaxy. The user navigates to the target directory containing the requirement.yml and all collection packages, and then runs the install command referencing the requirements file. Intended for scenarios where the host has no direct access to a Galaxy server.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# This must be run from the folder that contains the offline collections and requirements.yml file downloaded\n# by the internet-connected host\ncd ~/offline-collections\nansible-galaxy collection install -r requirements.yml\n```\n\n----------------------------------------\n\nTITLE: Using Literal Block Scalars for Multiline Strings in YAML\nDESCRIPTION: Demonstrates the literal block scalar ('|') for multiline strings. This preserves newlines and any trailing spaces exactly as they appear in the source.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ninclude_newlines: |\n            exactly as you see\n            will appear these three\n            lines of poetry\n```\n\n----------------------------------------\n\nTITLE: Passing PSCredential to win_dsc in YAML\nDESCRIPTION: This snippet illustrates how to provide credentials for a DSC resource property expecting a `[PSCredential]` object when using the `win_dsc` module in Ansible. Instead of a single parameter, two parameters are defined in the task, suffixed with `_username` and `_password`, corresponding to the original DSC property name (e.g., `PsDscRunAsCredential_username` and `PsDscRunAsCredential_password`). These parameters accept standard Ansible variables or string literals.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nPsDscRunAsCredential_username: '{{ ansible_user }}'\nPsDscRunAsCredential_password: '{{ ansible_password }}'\n\nSourceCredential_username: AdminUser\nSourceCredential_password: PasswordForAdminUser\n```\n\n----------------------------------------\n\nTITLE: Interacting with Azure Using win_psmodule and win_dsc - Ansible YAML+Jinja\nDESCRIPTION: Illustrates installation of the xAzure DSC resource using win_psmodule, then provisioning a new Azure virtual machine with xAzureVM via win_dsc. The playbook example includes credentials and parameters required for VM creation (image, name, service, storage, instance size). Requires Azure subscription and appropriate DSC modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_13\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Install xAzure DSC resources\n  win_psmodule:\n    name: xAzure\n    state: present\n\n- name: Create virtual machine in Azure\n  win_dsc:\n    resource_name: xAzureVM\n    ImageName: a699494373c04fc0bc8f2bb1389d6106__Windows-Server-2012-R2-201409.01-en.us-127GB.vhd\n    Name: DSCHOST01\n    ServiceName: ServiceName\n    StorageAccountName: StorageAccountName\n    InstanceSize: Medium\n    Windows: true\n    Ensure: Present\n    Credential_username: '{{ ansible_user }}'\n    Credential_password: '{{ ansible_password }}'\n```\n\n----------------------------------------\n\nTITLE: Importing Future Annotations Feature in Python\nDESCRIPTION: This Python code snippet demonstrates the standard boilerplate import required for Ansible project files. It imports the `annotations` feature from the `__future__` module, enabling postponed evaluation of type hints (PEP 563) for improved type hinting flexibility and forward compatibility, especially useful in projects supporting multiple Python versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/boilerplate.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n```\n\n----------------------------------------\n\nTITLE: Result of Assertions Output Example - Ansible JSON\nDESCRIPTION: This code shows an example JSON object output by Ansible tasks where all assertions have passed. The output indicates that no changes occurred and provides feedback via the 'msg' field. This could be used as a standard output reference when designing assertion checks in playbooks. Dependencies: produced automatically by successful Ansible assertion tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n{ \"changed\": false, \"msg\": \"All assertions passed\" }\n```\n\n----------------------------------------\n\nTITLE: Enabling Standard Output Callbacks for Ad Hoc Commands in ansible.cfg\nDESCRIPTION: This `ansible.cfg` configuration snippet demonstrates how to enable the use of the configured `stdout_callback` plugin for Ansible ad hoc commands (`ansible` command). Setting `bin_ansible_callbacks` to `True` under the `[defaults]` section applies the stdout setting defined elsewhere.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/callback.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nbin_ansible_callbacks=True\n```\n\n----------------------------------------\n\nTITLE: Saving PowerShell Modules for Offline Use - PowerShell\nDESCRIPTION: Demonstrates the Save-Module cmdlet to download and save a DSC resource module (e.g., xWebAdministration) to a specified path. This is useful for transferring modules to hosts without internet access, ensuring compliance with security or connectivity constraints. The saved folder can then be copied to appropriate PSModulePath directories.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_10\n\nLANGUAGE: powershell\nCODE:\n```\nSave-Module -Name xWebAdministration -Path C:\\temp\n```\n\n----------------------------------------\n\nTITLE: Installing Removed Ansible Collections Manually using ansible-galaxy\nDESCRIPTION: This shell command utilizes the `ansible-galaxy` tool to manually install an Ansible collection specified by the `<collection_name>` placeholder. This method is necessary for users who need to use collections that have been removed from the core Ansible 10.0 distribution package, such as those listed as unmaintained or deprecated in the document.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/roadmap/COLLECTIONS_10.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-galaxy collection install <collection_name>\n```\n\n----------------------------------------\n\nTITLE: Restructuring Ansible Module with Argument Spec for Testability (Python)\nDESCRIPTION: This Python code demonstrates restructuring an Ansible module for better testability. It first defines the `argument_spec` dictionary detailing module parameters, their types, defaults, choices, and aliases. Then, it separates module initialization into a `setup_module_object` function, which creates the `AnsibleAWSModule` instance using the `argument_spec` and handling constraints like `required_if` and `mutually_exclusive`. The `main` function orchestrates the workflow using the setup object. This separation allows isolated testing of the argument parsing and module setup logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nargument_spec = dict(\n    # module function variables\n    state=dict(choices=['absent', 'present', 'rebooted', 'restarted'], default='present'),\n    apply_immediately=dict(type='bool', default=False),\n    wait=dict(type='bool', default=False),\n    wait_timeout=dict(type='int', default=600),\n    allocated_storage=dict(type='int', aliases=['size']),\n    db_instance_identifier=dict(aliases=[\"id\"], required=True),\n)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef setup_module_object():\n    module = AnsibleAWSModule(\n        argument_spec=argument_spec,\n        required_if=required_if,\n        mutually_exclusive=[['old_instance_id', 'source_db_instance_identifier',\n                             'db_snapshot_identifier']],\n    )\n    return module\n\ndef main():\n    module = setup_module_object()\n    validate_parameters(module)\n    conn = setup_client(module)\n    return_dict = run_task(module, conn)\n    module.exit_json(**return_dict)\n```\n\n----------------------------------------\n\nTITLE: Installing a Specific Collection from a Multi-Collection Git Repo (Bash)\nDESCRIPTION: Shows the command syntax (using `text` block in source, but represents a shell command) to install a specific collection (e.g., `collection2`) from a Git repository containing multiple collections. This is achieved by appending a URI fragment (`#/collection2/`) to the Git URI, directing `ansible-galaxy` to the subdirectory containing the desired collection's metadata file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_git_repo.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install git+https://github.com/organization/repo_name.git#/collection2/\n```\n\n----------------------------------------\n\nTITLE: Required `__init__.py` for Ansible Collection Namespace Initialization\nDESCRIPTION: Indicates the necessity of an empty `__init__.py` file within an Ansible collection's directories. This file is crucial for Python to recognize the directory as a package, allowing imports and establishing the namespace. It is a mandatory component for the collection structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_in_groups.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n__init__.py\n```\n\n----------------------------------------\n\nTITLE: Installing Minimal ansible-core with pipx\nDESCRIPTION: Installs the minimal 'ansible-core' package using pipx. This provides the basic Ansible language and runtime without the extensive collection set included in the 'ansible' package.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ pipx install ansible-core\n```\n\n----------------------------------------\n\nTITLE: Import Guarding in Ansible Plugins - Python\nDESCRIPTION: This example illustrates how plugins can guard their imports similarly to modules. It catches ImportError during attempted import, storing the exception object for later use. No inputs or outputs beyond the flagging of ANOTHER_LIBRARY_IMPORT_ERROR. This pattern is vital in dynamic plugin loading scenarios to prevent failures during plugin discovery.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import another_library\nexcept ImportError as imp_exc:\n    ANOTHER_LIBRARY_IMPORT_ERROR = imp_exc\nelse:\n    ANOTHER_LIBRARY_IMPORT_ERROR = None\n```\n\n----------------------------------------\n\nTITLE: Displaying Name Server Configuration on Cisco IOS XE via CLI (Bash)\nDESCRIPTION: Displays the current DNS server configured on a Cisco IOS XE router by filtering the running configuration for lines containing `name-server`. Requires access to the device CLI, typically via SSH or direct console connection. Key command: `sh run | i name-server`. Output: Lists all configured IP name-servers; reflects changes made by previous playbook executions. Limitation: Only available to users with appropriate device access.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nrtr3#sh run | i name-server\nip name-server 192.168.1.1\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies and Exposing Apps with pipx\nDESCRIPTION: Installs an additional Python dependency (e.g., 'argcomplete') using 'pipx inject' and includes the '--include-apps' option. This makes any command-line applications provided by the injected package available directly in the system's PATH.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ pipx inject --include-apps ansible argcomplete\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenSSH authorized_keys for Administrators - Windows - text\nDESCRIPTION: This sshd_config snippet sets the location of the `AuthorizedKeysFile` for administrators on a Windows host. It is used to direct SSHD to use a different path for the public keys of administrator users. Dependencies include proper placement of the configuration in sshd_config, and the path must exist or be writable by the SSH daemon. Changing this setting can move administrative public key storage from the default to a user-specific location or vice versa.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nMatch Group administrators\n    AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys\n```\n\n----------------------------------------\n\nTITLE: Defining a Constructable Ansible Inventory Plugin - Python\nDESCRIPTION: This Python code declares an InventoryModule class that inherits from 'BaseInventoryPlugin' and 'Constructable', enabling support for Jinja2-based constructed features (compose, keyed_groups, groups). The 'NAME' attribute provides the namespace and identifier for the plugin. The class is intended as a base for further customization.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass InventoryModule(BaseInventoryPlugin, Constructable):\n\n    NAME = 'ns.coll.myplugin'\n\n```\n\n----------------------------------------\n\nTITLE: Including Common PowerShell Utilities via Module Replacer\nDESCRIPTION: This placeholder comment is used in new-style PowerShell modules. The Module Replacer framework substitutes this comment with the contents of the 'ansible/module_utils/powershell.ps1' file, providing common PowerShell functions and helpers.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n# POWERSHELL_COMMON\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Embedding Filter Plugins in an Ansible Role (Text)\nDESCRIPTION: Illustrates the directory layout for embedding custom filter plugins within an Ansible role. Filter plugins are placed in a 'filter_plugins' subdirectory within the role's directory (`roles/my_custom_filter/filter_plugins/`) and can be used in Jinja templates by this role and subsequent roles.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_reuse_roles.rst#_snippet_28\n\nLANGUAGE: text\nCODE:\n```\nroles/\n    my_custom_filter/\n        filter_plugins\n            filter1\n            filter2\n```\n\n----------------------------------------\n\nTITLE: Importing Custom Utility Class from Local Module Utility (Python)\nDESCRIPTION: This snippet illustrates importing a user-defined utility client (MySharedCodeClient) from a locally defined module_utils file, following Ansible's recommended approach for encapsulating shared code. This allows custom Ansible modules to reuse shared Python logic from ./module_utils/my_shared_code.py, promoting code reuse. Prerequisites: a file module_utils/my_shared_code.py containing MySharedCodeClient must exist and be discoverable; this pattern also depends on Ansible's dynamic import behavior in Playbook execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_module_utilities.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.my_shared_code import MySharedCodeClient\n```\n\n----------------------------------------\n\nTITLE: Defining DateTime Parameters for win_dsc - Ansible YAML+Jinja\nDESCRIPTION: Shows how to specify DateTime values in Ansible DSC playbooks using the ISO 8601 date format. Strings should be quoted to ensure they are properly serialized for Windows DSC. These parameters are necessary for tasks that depend on specific timestamps and require accuracy across different time zones.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_6\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n# As UTC-0 (No timezone)\nDateTime: '2019-02-22T13:57:31.2311892+00:00'\n\n# As UTC+4\nDateTime: '2019-02-22T17:57:31.2311892+04:00'\n\n# As UTC-4\nDateTime: '2019-02-22T09:57:31.2311892-04:00'\n```\n\n----------------------------------------\n\nTITLE: Rebasing Your Branch from Upstream - Shell\nDESCRIPTION: Outlines using \\\\\"git pull --rebase upstream devel\\\\\" to rebase the current branch onto the latest upstream \\\\\"devel\\\\\" branch, allowing local changes to replay over new upstream commits to avoid merge commits. Requires that the \\\\\"upstream\\\\\" remote is configured and that you are on the feature branch to rebase. Conflicts may appear and must be resolved manually for the rebase to complete.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ git pull --rebase upstream devel\n```\n\n----------------------------------------\n\nTITLE: Running Playbook with Become Prompt as SUDO in Ansible CLI - Shell\nDESCRIPTION: Shows how the become prompt previously appeared in Ansible 2.7 or when AGNOSTIC_BECOME_PROMPT is False in 2.8, displaying 'SUDO password:'. This command line usage is relevant for environments or configurations maintaining legacy prompt behavior. No external dependencies except for Ansible CLI. Suitable for scripts/playbooks requiring clear privilege distinction.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook --become --ask-become-pass site.yml\nSUDO password:\n```\n\n----------------------------------------\n\nTITLE: Installing Namespace-Based Collections from Git (Bash)\nDESCRIPTION: Demonstrates installing collections from a namespace-structured Git repository using `ansible-galaxy`. The first command installs all collections under the specified namespace directory by adding a fragment (`#/namespace/`) to the URI. The second command installs only `collectionA` from within the namespace at a specific commit hash (`7b60...`), combining the fragment and commit-ish syntax.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_collections_git_repo.txt#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Install all collections in the namespace\nansible-galaxy collection install git+https://github.com/organization/repo_name.git#/namespace/\n\n# Install an individual collection using a specific commit\nansible-galaxy collection install git+https://github.com/organization/repo_name.git#/namespace/collectionA/,7b60ddc245bc416b72d8ea6ed7b799885110f5e5\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule._selinux_special_fs Attribute\nDESCRIPTION: Stub documentation reference for the `_selinux_special_fs` attribute of the `AnsibleModule` class, related to SELinux special filesystems. This replaces the deprecated `ansible.module_utils.basic.SELINUX_SPECIAL_FS`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule._selinux_special_fs\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Aliases for the Same Host in INI - Ansible Inventory - Text\nDESCRIPTION: Illustrates how the same destination host can be referenced by multiple inventory aliases in INI format. This allows for the same host to be targeted in different contexts, but tasks may run in parallel across aliases.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_17\n\nLANGUAGE: text\nCODE:\n```\njumper1 ansible_port=5555 ansible_host=192.0.2.50\\njumper2 ansible_port=5555 ansible_host=192.0.2.50\n```\n\n----------------------------------------\n\nTITLE: Configuring SSH Password Mechanism via ansible.cfg (INI)\nDESCRIPTION: Shows how to configure the SSH connection plugin in Ansible to use the `sshpass` program for password handling instead of the default `SSH_ASKPASS`. This is achieved by setting the `password_mechanism` key to `sshpass` within the `[ssh_connection]` section of the `ansible.cfg` file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_21\n\nLANGUAGE: ini\nCODE:\n```\n[ssh_connection]\npassword_mechanism = sshpass\n```\n\n----------------------------------------\n\nTITLE: Extracting a ZIP File via DSC Archive Resource - Ansible YAML+Jinja\nDESCRIPTION: Provides a task for extracting the contents of a ZIP archive using the DSC Archive resource via win_dsc in Ansible. Specifies source path, destination, resource name, and desired state. The example assumes the zip file exists at the given location and that the Archive DSC resource is available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_11\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: Extract a zip file\n  win_dsc:\n    resource_name: Archive\n    Destination: C:\\temp\\output\n    Path: C:\\temp\\zip.zip\n    Ensure: Present\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies with pip - Shell\nDESCRIPTION: Installs required Python packages listed in 'requirements.txt' using pip. This command should be run in your terminal from the project root. It uses the '--user' flag to install only for the current user and assumes Python 3 is installed. Inputs: requirements.txt file path. Outputs: locally installed Python dependencies. Requires pip, Python 3, and local file permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_19\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip install --user -r ./requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: rc\nDESCRIPTION: Illustrates the `rc` (return code) key. This is common for modules executing command-line utilities (like `shell`, `command`) and contains the integer exit code of the executed command.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n\"rc\": 257\n```\n\n----------------------------------------\n\nTITLE: Signing an Ansible Collection Tarball with GPG (Bash)\nDESCRIPTION: Shows how to build an Ansible collection, extract its MANIFEST.json, and create a detached ASCII-armored GPG signature for it using the gpg CLI. Assumes the user has a GPG private key and that the ansible-galaxy collection build command outputs a tar.gz file. Inputs are the tarball and the user's email as a GPG signing key; outputs an .asc signature file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection build\ntar -Oxzf namespace-name-1.0.0.tar.gz MANIFEST.json | gpg --output namespace-name-1.0.0.asc --detach-sign --armor --local-user email@example.com -\n```\n\n----------------------------------------\n\nTITLE: Failed Ansible Task Output with Task Path: Unable to Open Shell - ansible-output\nDESCRIPTION: Shows another variant of a failed task in an Ansible playbook run that cannot open a shell on the remote system, including additional task path metadata. Designed to give more context to the operator for debugging authentication or network reachability problems. This output comes from Ansible in response to connection errors.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_14\n\nLANGUAGE: ansible-output\nCODE:\n```\nTASK [ios_system : configure name_servers] *************************************************************\ntask path:\nfatal: [ios-csr1000v]: FAILED! => {\n    \"changed\": false,\n    \"failed\": true,\n    \"msg\": \"unable to open shell\",\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Manifest Directives in Galaxy.yml (YAML)\nDESCRIPTION: Demonstrates using the manifest: directives: section in galaxy.yml to control file inclusions/exclusions for building a collection, with rules similar to those in MANIFEST.in. Sample excludes a folder and .tar.gz files. Requires ansible-core 2.14+ and the distlib Python module; mutually exclusive with build_ignore. directives is a list of manifest commands; produces tarballs with custom file layouts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  directives:\n    - recursive-exclude playbooks/sensitive **\n    - global-exclude *.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Executing an Ansible Playbook Utilizing a Custom Role (YAML)\nDESCRIPTION: An updated Ansible playbook that leverages the newly created 'system_demo' role. The `tasks` and `vars` sections from the original playbook have been removed and replaced with a `roles` section that includes `system_demo`. This playbook applies the tasks and variables defined within the role to the 'routers' host group.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: configure cisco routers\n  hosts: routers\n  connection: ansible.netcommon.network_cli\n  gather_facts: false\n\n  roles:\n    - system_demo\n```\n\n----------------------------------------\n\nTITLE: Mocking edit_config for Arista EOS in Python Unit Tests\nDESCRIPTION: This snippet uses `unittest.mock.patch` to mock the `edit_config` method of the `CliProvider` within the `arista.eos` collection's module utils. This allows tests to simulate configuration changes without interacting with a real device. The patch is started and the mock object is assigned to `self.edit_config`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nself.mock_edit_config = patch(\n\"ansible_collections.arista.eos.plugins.module_utils.network.eos.providers.providers.CliProvider.edit_config\"\n)\nself.edit_config = self.mock_edit_config.start()\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Interpreter Fallback Paths in Ansible\nDESCRIPTION: This configuration snippet demonstrates setting the 'ansible_interpreter_python_fallback' variable in Ansible. It provides a list of potential paths where Ansible should search for a Python interpreter if the primary one ('ansible_python_interpreter') is not found or specified. Ansible will use the first path found from this list.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_8\n\nLANGUAGE: ini\nCODE:\n```\nansible_interpreter_python_fallback=['/usr/local/bin/python', '/usr/local/bin/python3', '/usr/local/bin/python3.11']\n```\n\n----------------------------------------\n\nTITLE: Default Manifest Directives for Collection Packaging (Text)\nDESCRIPTION: Lists the default set of manifest inclusion/exclusion rules used when building Ansible collections, defining which file patterns and locations are added or omitted by default. These rules use MANIFEST.in syntax, covering various directories like meta, docs, plugins, and exclude build and internal artifacts. Useful for reference when customizing or omitting default directives in galaxy.yml manifest section.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\ninclude meta/*.yml\ninclude *.txt *.md *.rst COPYING LICENSE\nrecursive-include tests **\nrecursive-include docs **.rst **.yml **.yaml **.json **.j2 **.txt\nrecursive-include roles **.yml **.yaml **.json **.j2\nrecursive-include playbooks **.yml **.yaml **.json\nrecursive-include changelogs **.yml **.yaml\nrecursive-include plugins */**.py\nrecursive-include plugins/become **.yml **.yaml\nrecursive-include plugins/cache **.yml **.yaml\nrecursive-include plugins/callback **.yml **.yaml\nrecursive-include plugins/cliconf **.yml **.yaml\nrecursive-include plugins/connection **.yml **.yaml\nrecursive-include plugins/filter **.yml **.yaml\nrecursive-include plugins/httpapi **.yml **.yaml\nrecursive-include plugins/inventory **.yml **.yaml\nrecursive-include plugins/lookup **.yml **.yaml\nrecursive-include plugins/netconf **.yml **.yaml\nrecursive-include plugins/shell **.yml **.yaml\nrecursive-include plugins/strategy **.yml **.yaml\nrecursive-include plugins/test **.yml **.yaml\nrecursive-include plugins/vars **.yml **.yaml\nrecursive-include plugins/modules **.ps1 **.yml **.yaml\nrecursive-include plugins/module_utils **.ps1 **.psm1 **.cs\n# manifest.directives from galaxy.yml inserted here\nexclude galaxy.yml galaxy.yaml MANIFEST.json FILES.json <namespace>-<name>-*.tar.gz\nrecursive-exclude tests/output **\nglobal-exclude /.* /__pycache__\n```\n\n----------------------------------------\n\nTITLE: Collecting and Running Test Cases for vyos_l3_interfaces Module - YAML\nDESCRIPTION: This YAML snippet defines a sequence of tasks to collect test case files matching a pattern, extract their paths, and execute them as sub-tasks using both 'network_cli' and 'local' connections. Required dependencies: Ansible core, test task files in the expected CLI test directory, and variables 'role_path' and 'testcase'. Inputs include discovered test YAML files; outputs are executed sub-playbooks. Looping and variable setting ensure dynamic and scalable test execution. Designed for use in module test directories with connection flexibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n---\n- name: collect all cli test cases\n  find:\n    paths: \"{{ role_path }}/tests/cli\"\n    patterns: \"{{ testcase }}.yaml\"\n  register: test_cases\n  delegate_to: localhost\n\n- name: set test_items\n  set_fact: test_items=\"{{ test_cases.files | map(attribute='path') | list }}\"\n\n- name: run test cases (connection=network_cli)\n  include_tasks:\n     file: \"{{ test_case_to_run }}\"\n  vars:\n     ansible_connection: network_cli\n  with_items: \"{{ test_items }}\"\n  loop_control:\n    loop_var: test_case_to_run\n\n- name: run test case (connection=local)\n  include_tasks:\n     file: \"{{ test_case_to_run }}\"\n  vars:\n     ansible_connection: local\n     ansible_become: false\n  with_first_found: \"{{ test_items }}\"\n  loop_control:\n    loop_var: test_case_to_run\n```\n\n----------------------------------------\n\nTITLE: Example Error: Unable to Enter Configuration Mode (Console)\nDESCRIPTION: Shows a typical fatal error message from Ansible when a task requires privileged mode (e.g., configuration changes) but the connection is currently in user mode on the target network device (like Arista EOS or Cisco IOS). The suggested resolution involves using `connection: ansible.netcommon.network_cli` and enabling privilege escalation with `become: true`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_36\n\nLANGUAGE: console\nCODE:\n```\nTASK [ios_system : configure name_servers] *****************************************************************************\ntask path:\nfatal: [ios-csr1000v]: FAILED! => {\n    \"changed\": false,\n    \"failed\": true,\n   \"msg\": \"unable to enter configuration mode\",\n}\n```\n\n----------------------------------------\n\nTITLE: Using Stride in Numeric Host Ranges (INI)\nDESCRIPTION: Illustrates defining a numeric host range in INI format with a stride (increment) specified by the third number in the brackets (`[01:50:2]`). This selects hosts at specified intervals (e.g., 01, 03, 05...).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n[webservers]\nwww[01:50:2].example.com\n```\n\n----------------------------------------\n\nTITLE: Setting Ansible Command Timeout per Task using Vars (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to set the `ansible_command_timeout` specifically for a single Ansible task using the `vars` keyword within a playbook. The timeout is set to 30 seconds for the `cisco.ios.ios_command` task.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_connection_options.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: save running-config\n  cisco.ios.ios_command:\n    commands: copy running-config startup-config\n  vars:\n    ansible_command_timeout: 30\n```\n\n----------------------------------------\n\nTITLE: Failing on Missing Module Utilities Import (Python)\nDESCRIPTION: This Python snippet directly imports the respawn_module from ansible.module_utils.common.respawn. Because the import is not wrapped in a try/except or conditional block, the Ansible payload builder treats it as a required dependency; if the package is unavailable (e.g., running on Ansible 2.10 or lower), module payload build will fail, and the code will not be executed. This pattern is only suitable when certain the dependency exists in all target environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_shared.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.common.respawn import respawn_module\n```\n\n----------------------------------------\n\nTITLE: Illustrating Incorrect Jinja Filter Usage on Lists in Ansible (YAML+Jinja)\nDESCRIPTION: Shows an Ansible debug task using the `replace` filter directly on a list (`['test1', 'test2']`). This usage is erroneous because `replace` expects a string; the filter silently converts the list input to a string, which could lead to unexpected behavior or mask errors in older Ansible versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_12\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- debug:\n    msg: \"{{ ['test1', 'test2'] | replace('test', 'prod') }}\"\n```\n\n----------------------------------------\n\nTITLE: Installing an Ansible Role from Git using a Commit Hash\nDESCRIPTION: Demonstrates installing an Ansible role directly from a Git repository URL using the `ansible-galaxy role install` command. It specifies a particular commit hash (`0b7cd...`) after the URL (separated by a comma) as the version to install, ensuring reproducibility. Requires `git` and `ansible-galaxy` command-line tools.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role install git+https://github.com/geerlingguy/ansible-role-apache.git,0b7cd353c0250e87a26e0499e59e7fd265cc2f25\n```\n\n----------------------------------------\n\nTITLE: Checking Current Ansible Module Path Configuration\nDESCRIPTION: This command uses `ansible-config dump` to output all active Ansible configuration settings and pipes the output to `grep` to filter and display the line containing `DEFAULT_MODULE_PATH`. This helps users verify where Ansible is currently configured to look for standalone local modules intended for use across all playbooks and roles.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_locally.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nansible-config dump |grep DEFAULT_MODULE_PATH\n```\n\n----------------------------------------\n\nTITLE: Using Stride in Numeric Host Ranges (YAML)\nDESCRIPTION: Shows the YAML syntax for defining numeric host ranges with a stride (`www[01:50:2].example.com`), allowing selection of hosts at specified intervals within the sequence. The ellipsis `...` indicates this is part of a larger file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_inventory.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# ...\n  webservers:\n    hosts:\n      www[01:50:2].example.com:\n```\n\n----------------------------------------\n\nTITLE: Listing NETCONF-Compatible CloudEngine OS Modules for Ansible (YAML)\nDESCRIPTION: This YAML snippet documents the set of Ansible modules compatible with CloudEngine OS devices via ansible.netcommon.netconf connection. Used primarily for documentation and reference, it includes modules for advanced networking (AAA, BGP, VRF, etc.), configuration, and monitoring operations. Not meant for execution, but provides guidance for module selection in NETCONF-based playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ncommunity.network.ce_aaa_server\ncommunity.network.ce_aaa_server_host\ncommunity.network.ce_acl\ncommunity.network.ce_acl_advance\ncommunity.network.ce_bfd_global\ncommunity.network.ce_bfd_session\ncommunity.network.ce_bfd_view\ncommunity.network.ce_bgp\ncommunity.network.ce_bgp_af\ncommunity.network.ce_bgp_neighbor\ncommunity.network.ce_bgp_neighbor_af\ncommunity.network.ce_dldp\ncommunity.network.ce_dldp_interface\ncommunity.network.ce_eth_trunk\ncommunity.network.ce_evpn_bd_vni\ncommunity.network.ce_file_copy\ncommunity.network.ce_info_center_debug\ncommunity.network.ce_info_center_global\ncommunity.network.ce_info_center_log\ncommunity.network.ce_info_center_trap\ncommunity.network.ce_interface\ncommunity.network.ce_interface_ospf\ncommunity.network.ce_ip_interface\ncommunity.network.ce_lacp\ncommunity.network.ce_link_status\ncommunity.network.ce_lldp\ncommunity.network.ce_lldp_interface\ncommunity.network.ce_mlag_config\ncommunity.network.ce_netconf\ncommunity.network.ce_ntp\ncommunity.network.ce_ospf\ncommunity.network.ce_ospf_vrf\ncommunity.network.ce_reboot\ncommunity.network.ce_sflow\ncommunity.network.ce_snmp_community\ncommunity.network.ce_snmp_target_host\ncommunity.network.ce_snmp_user\ncommunity.network.ce_static_route\ncommunity.network.ce_static_route_bfd\ncommunity.network.ce_switchport\ncommunity.network.ce_vlan\ncommunity.network.ce_vrf\ncommunity.network.ce_vrf_af\ncommunity.network.ce_vrf_interface\ncommunity.network.ce_vrrp\ncommunity.network.ce_vxlan_tunnel\ncommunity.network.ce_vxlan_vap\n```\n\n----------------------------------------\n\nTITLE: Enable Persistent Log Messages with Environment Variable - Shell\nDESCRIPTION: Exports the ANSIBLE_PERSISTENT_LOG_MESSAGES variable to 'True' on the Ansible control node shell. This global environment setting activates device interaction logging for all relevant network tasks without modifying the configuration file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n# Enable device interaction logging\\nexport ANSIBLE_PERSISTENT_LOG_MESSAGES=True\n```\n\n----------------------------------------\n\nTITLE: Mocking get_device_data for Arista EOS L2 Interfaces Facts in Python Unit Tests\nDESCRIPTION: This snippet employs `unittest.mock.patch` to mock the `get_device_data` method within the `L2_interfacesFacts` class for the `arista.eos` collection. This is typically used to simulate the output of device show commands. The patch is started, and the resulting mock object is assigned to `self.execute_show_command` (likely renamed for clarity within the test context).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nself.mock_execute_show_command = patch(\n\"ansible_collections.arista.eos.plugins.module_utils.network.eos.facts.l2_interfaces.l2_interfaces.L2_interfacesFacts.get_device_data\"\n)\nself.execute_show_command = self.mock_execute_show_command.start()\n```\n\n----------------------------------------\n\nTITLE: Setting Syslog Facility for Managed Node Logging\nDESCRIPTION: Specifies the syslog facility (e.g., 'daemon', 'user', 'local7') to be used when logging Ansible output to syslog on managed nodes. This setting requires corresponding configuration of `no_target_syslog` to enable per-node logging.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/logging.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n`syslog_facility`\n```\n\n----------------------------------------\n\nTITLE: Installing Minimal Ansible Core Package on Arch Linux (Bash)\nDESCRIPTION: Installs only the minimal 'ansible-core' package on Arch Linux using the Pacman package manager. Requires root privileges (sudo). Collections need to be installed separately.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo pacman -S ansible-core\n```\n\n----------------------------------------\n\nTITLE: Ansible Step Mode Interactive Prompt Example (Shell)\nDESCRIPTION: This snippet shows an example of the interactive prompt displayed when running `ansible-playbook` with the `--step` option. It pauses execution before the task named \"configure ssh\" and asks the user for input (y/n/c) to determine the next action: execute, skip, or continue without further prompts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_startnstep.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nPerform task: configure ssh (y/n/c):\n```\n\n----------------------------------------\n\nTITLE: Example Resource Module Model Definition - YAML\nDESCRIPTION: Provides a comprehensive YAML configuration model for an example Ansible resource module (myos_interfaces). The model specifies generator metadata, documentation content, argument specification (including types, choices, and version information), and references to example files. Dependencies include the resource module builder which uses this YAML as the single source of truth. The YAML should be placed in the models directory and updated as functionality or documentation changes. The expected output is a scaffolded Ansible collection structure and up-to-date docstring and argspec in generated modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\nGENERATOR_VERSION: '1.0'\n\nNETWORK_OS: myos\nRESOURCE: interfaces\nCOPYRIGHT: Copyright 2019 Red Hat\nLICENSE: gpl-3.0.txt\n\nDOCUMENTATION: |\n  module: myos_interfaces\n  version_added: 1.0.0\n  short_description: 'Manages <xxxx> attributes of <network_os> <resource>'\n  description: 'Manages <xxxx> attributes of <network_os> <resource>.'\n  author: Ansible Network Engineer\n  notes:\n    - 'Tested against <network_os> <version>'\n  options:\n    config:\n      description: The provided configuration\n      type: list\n      elements: dict\n      suboptions:\n        name:\n          type: str\n          description: The name of the <resource>\n        some_string:\n          type: str\n          description:\n          - The some_string_01\n          choices:\n          - choice_a\n          - choice_b\n          - choice_c\n          default: choice_a\n        some_bool:\n          description:\n          - The some_bool.\n          type: bool\n        some_int:\n          description:\n          - The some_int.\n          type: int\n          version_added: '1.1.0'\n        some_dict:\n          type: dict\n          description:\n          - The some_dict.\n          suboptions:\n            property_01:\n              description:\n              - The property_01\n              type: str\n    state:\n      description:\n      - The state of the configuration after module completion.\n      type: str\n      choices:\n      - merged\n      - replaced\n      - overridden\n      - deleted\n      default: merged\nEXAMPLES:\n  - deleted_example_01.txt\n  - merged_example_01.txt\n  - overridden_example_01.txt\n  - replaced_example_01.txt\n```\n\n----------------------------------------\n\nTITLE: Explicitly Gathering Facts with 'always' Tag in YAML\nDESCRIPTION: Demonstrates how to replicate the pre-Ansible 2.8 behavior where facts were always gathered, regardless of play-level tags. This is achieved by disabling implicit fact gathering (`gather_facts: false`) and adding an explicit `gather_facts` task tagged with `always`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Configure Webservers\n  hosts: webserver\n  gather_facts: false\n  tags:\n    - webserver\n  tasks:\n    - name: Gathering Facts\n      gather_facts:\n      tags:\n        - always\n\n    - name: Install nginx\n      package:\n        name: nginx\n      tags:\n        - nginx\n```\n\n----------------------------------------\n\nTITLE: Publishing Ansible Collection with Command-Line Token (Bash)\nDESCRIPTION: This Bash command shows how to publish a pre-built Ansible collection tarball to a distribution server using the `ansible-galaxy collection publish` command. It specifies the path to the tarball and provides the API token directly via the `--token` argument. This method is noted as insecure because the token might be exposed in the system's process list or command history.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection publish path/to/my_namespace-my_collection-1.0.0.tar.gz --token abcdefghijklmnopqrtuvwxyz\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Buggy `file` Module Behavior with `src` and `state=directory` (Ansible Shell)\nDESCRIPTION: This example demonstrates a deprecated behavior in the Ansible `file` module prior to version 2.6. Using `src` with `state=directory` could lead to unintended subdirectory creation (`/tmp/lib` derived from `src=/tmp/` and `path=/var/lib`) instead of acting solely on the `path`. This usage is now deprecated and triggers a warning.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.6.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible localhost -m file -a 'path=/var/lib src=/tmp/ state=directory'\n```\n\n----------------------------------------\n\nTITLE: Removed Command `ansible-galaxy login` in Shell\nDESCRIPTION: The `ansible-galaxy login` command has been removed due to the shutdown of the underlying GitHub authentication API it used. Users publishing to Galaxy must now use an API token via a token file (default `~/.ansible/galaxy_token`) or the `--token` argument.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# Old command (removed):\n# ansible-galaxy login\n\n# New methods (using token):\nansible-galaxy collection publish my_namespace-my_collection-1.0.0.tar.gz\n# (Reads token from ~/.ansible/galaxy_token by default)\n\n# Or explicitly:\nansible-galaxy collection publish my_namespace-my_collection-1.0.0.tar.gz --token YOUR_GALAXY_API_TOKEN\n# Or (less secure):\nansible-galaxy collection publish my_namespace-my_collection-1.0.0.tar.gz --token=YOUR_GALAXY_API_TOKEN\n```\n\n----------------------------------------\n\nTITLE: Resource Module Main Entrypoint Example - Ansible Module - Text\nDESCRIPTION: A minimal Python pseudo-code block showing the main() function of a resource module. Demonstrates calling the execute_module API from an imported resource package for a given module instance, which processes input and produces module output. Used as a structural reference for how modules are expected to invoke logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\ndef main():\n    result = <resource_package>(module).execute_module()\n```\n\n----------------------------------------\n\nTITLE: Image with Alt Text reStructuredText reStructuredText\nDESCRIPTION: Provides an RST code example for inserting an image with explicit width and alternative text for accessibility support. The :alt: directive is crucial for users with assistive technologies, ensuring descriptive content for non-text elements. Images should avoid being used for CLI output and convey meaningful context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_19\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. image:: path/networkdiag.png\n   :width: 400\n   :alt: SpiffyCorp network diagram\n```\n\n----------------------------------------\n\nTITLE: Example Namespace Directory Structure for Multiple Collections - Text\nDESCRIPTION: Presents the layout of a namespace directory containing multiple source collections, each with its own galaxy.yml file and plugins directory. This structure allows batch operations on collections organized under a single namespace directory, such as installation or packaging. Each subdirectory represents a collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nns/\n├── collection1/\n│   ├── galaxy.yml\n│   └── plugins/\n└── collection2/\n    ├── galaxy.yml\n    └── plugins/\n```\n\n----------------------------------------\n\nTITLE: Upgrading Ansible with pipx\nDESCRIPTION: Upgrades an existing Ansible installation (managed by pipx) to the latest released version. The '--include-injected' flag ensures any previously injected dependencies are preserved during the upgrade.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ pipx upgrade --include-injected ansible\n```\n\n----------------------------------------\n\nTITLE: Using Prompted Password with --vault-id (No Label) - CLI Usage (Bash)\nDESCRIPTION: Prompts for the vault password using the --vault-id option without a label. Equivalent to --ask-vault-pass. Good for simple vault scenarios or backward compatibility. Input: CLI command; Output: Interactive prompt for vault password.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook --vault-id @prompt site.yml\n```\n\n----------------------------------------\n\nTITLE: Sample Values for ansible_facts['os_family'] (Text)\nDESCRIPTION: This snippet presents a sample list of possible string values for the `ansible_facts['os_family']` fact. This fact provides a broader classification of the operating system (e.g., 'RedHat' for CentOS/Fedora/RHEL, 'Debian' for Ubuntu/Debian, 'Windows'). It's frequently used in Ansible conditionals (`when`) to group tasks or variable definitions applicable to related operating systems. If a specific mapping isn't found based on the OS, Ansible defaults this fact to the value of `platform.system()`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_conditionals.rst#_snippet_35\n\nLANGUAGE: text\nCODE:\n```\nAIX\nAlpine\nAltlinux\nArchlinux\nDarwin\nDebian\nFreeBSD\nGentoo\nHP-UX\nMandrake\nRedHat\nSMGL\nSlackware\nSolaris\nSuse\nWindows\n```\n\n----------------------------------------\n\nTITLE: Refactoring Ansible FQCNs for Migrated Google Image Module - Markdown\nDESCRIPTION: This snippet details how to update the Fully Qualified Collection Name (FQCN) for the Google Compute Engine image module when migrating from community.general to community.google or google.cloud, specifically targeting users on Ansible 2.9. Users must ensure the appropriate collection is installed and update any task references accordingly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.gce_img`` → ``community.google.gce_img``\n```\n\n----------------------------------------\n\nTITLE: Fixing Implicit Boolean Conversion with Explicit Check in Ansible\nDESCRIPTION: This Ansible playbook snippet shows the corrected version of a conditional that previously relied on implicit boolean conversion. By adding an explicit check like `| length > 0`, the conditional now correctly evaluates to a boolean (`True` or `False`), satisfying Ansible 12's requirement for boolean results in conditionals.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_1\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname | length > 0\n```\n\n----------------------------------------\n\nTITLE: Static Grouping of Dynamic Groups - Text - Ansible Inventory File\nDESCRIPTION: This snippet demonstrates how to define a static group with dynamic child groups in Ansible inventory files. It shows empty group headers for dynamic groups (which are defined elsewhere or via dynamic sources) and a 'children' group linking them. Inputs are plain inventory file entries; outputs are logical grouping made available during playbook execution. Place this snippet inside a static inventory file for proper group inheritance.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n[tag_Name_staging_foo]\n\n[tag_Name_staging_bar]\n\n[staging:children]\ntag_Name_staging_foo\ntag_Name_staging_bar\n```\n\n----------------------------------------\n\nTITLE: Running Specific Integration Tests for Ansible Collections by Target Directory\nDESCRIPTION: Executes integration tests located within a specific target directory (`connection_bar`) inside `tests/integration/targets/`. The command uses `ansible-test integration`, runs tests in a specified Docker container (`--docker fedora35`), and provides verbose output (`-v`). Multiple target directory names can be specified on the command line.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_testing.rst#_snippet_5\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-test integration --docker fedora35 -v connection_bar\n```\n\n----------------------------------------\n\nTITLE: Disabling Paramiko SSH Key Search with Shell Command - Shell\nDESCRIPTION: This shell snippet sets the environment variable 'ANSIBLE_PARAMIKO_LOOK_FOR_KEYS' to False, preventing Paramiko from searching for SSH keys and thus enforcing explicit credential use. Required dependencies: Ansible, Paramiko. Used when troubleshooting unwanted use of SSH keys during authentication and must be set before invoking Ansible commands.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_PARAMIKO_LOOK_FOR_KEYS=False\n```\n\n----------------------------------------\n\nTITLE: Writing Test Task for Abstract Service Info (YAML)\nDESCRIPTION: An Ansible playbook task that uses the hypothetical `abstract_service_info` module to fetch information from the service. It registers the output in the `result` variable and then uses the `assert` module to verify that the returned `version` field matches the expected value '1.0.0'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Fetch info from abstract service\n  abstract_service_info:\n    host: 127.0.0.1  # We assume the service accepts local connection by default\n    port: 1234       # We assume that the service is listening to this port by default\n  register: result   # This variable will contain the returned JSON including the server version\n\n- name: Test the output\n  assert:\n    that:\n      - result.version == '1.0.0'  # Check version field contains what we expect\n```\n\n----------------------------------------\n\nTITLE: Pinging Host Group with Ansible ad hoc Command - bash\nDESCRIPTION: This command runs the 'ping' module on all hosts in the 'myhosts' group in the specified inventory file, verifying connectivity and SSH access. 'ansible' must be installed and the SSH key properly set up. Add '-u <username>' if needed. Output is success or failure per host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_inventory.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible myhosts -m ping -i inventory.ini\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Changelog Bugfix Entry (apt_repository) in YAML\nDESCRIPTION: Presents a specific YAML example of a 'bugfixes' entry for the 'apt_repository' module in an Ansible changelog fragment. It details fixing a crash caused by an IOError during 'apt update' timeouts, following the standard scoped format with a link to the GitHub issue.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nbugfixes:\n  - apt_repository - fix crash caused by ``cache.update()`` raising an ``IOError``\n    due to a timeout in ``apt update`` (https://github.com/ansible/ansible/issues/51995).\n```\n\n----------------------------------------\n\nTITLE: Running All Integration Tests for Ansible Collections using ansible-test\nDESCRIPTION: Executes all integration tests defined within the `tests/integration/targets/` directory for an Ansible collection. The tests are run inside a specified Docker container (`--docker fedora35`) using the `ansible-test integration` command with verbose output (`-v`). This is useful for testing interactions with external systems or services in a controlled environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_testing.rst#_snippet_4\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-test integration --docker fedora35 -v\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook in Community EE Minimal Container - Bash\nDESCRIPTION: Runs a user-authored Ansible playbook ('test_localhost.yml') against 'localhost' inside the 'community-ee-minimal' container with ansible-navigator. Requires the playbook file to be present, Docker container access, and ansible-navigator installed. Outputs playbook run results in stdout format; replace the playbook file as necessary for different tasks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_community_ee_image.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator run test_localhost.yml --execution-environment-image ghcr.io/ansible-community/community-ee-minimal:latest --mode stdout\n```\n\n----------------------------------------\n\nTITLE: Committing and Pushing Changelog Updates - Git Bash Script\nDESCRIPTION: This Bash code commits all open changes and pushes the release branch to the origin repository. The commit message should refer to the release version. These commands require a clean working directory and appropriate permissions for pushing to the remote repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -a -m \"Release VERSION commit\"\\ngit push origin release_branch\n```\n\n----------------------------------------\n\nTITLE: Upgrading an Ansible Collection from Galaxy using Bash\nDESCRIPTION: This command utilizes `ansible-galaxy` with the `--upgrade` option to install or upgrade the specified collection (`my_namespace.my_collection`) to the latest available version from the configured Ansible Galaxy server. If the collection is already installed, it will be replaced by the newer version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection install my_namespace.my_collection --upgrade\n```\n\n----------------------------------------\n\nTITLE: Cloning Resource Module Builder with Git - Bash\nDESCRIPTION: Demonstrates how to clone the resource module builder repository from GitHub using the git command. Requires git to be installed on your system and network access to github.com. The command downloads a copy of the resource_module_builder repository into a local folder, required for all subsequent scaffolding and model operations. No additional input is required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ansible-network/resource_module_builder.git\n```\n\n----------------------------------------\n\nTITLE: Verbose Collection Verification Output - ansible-galaxy CLI - Bash\nDESCRIPTION: Shows use of the -vvv flag to get detailed diagnostic output when verifying a collection. This includes information like installed and remote collection paths/URLs, specific version details, and confirmation messages. Useful for troubleshooting or confirming which resources are compared.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection -vvv\n...\nVerifying 'my_namespace.my_collection:1.0.0'.\nInstalled collection found at '/path/to/ansible_collections/my_namespace/my_collection/'\nRemote collection found at 'https://galaxy.ansible.com/download/my_namespace-my_collection-1.0.0.tar.gz'\nSuccessfully verified that checksums for 'my_namespace.my_collection:1.0.0' match the remote collection\n```\n\n----------------------------------------\n\nTITLE: Listing Obtained Kerberos Tickets (Bash)\nDESCRIPTION: This command and included sample output lists the current ticket cache contents with klist, displaying all principal tickets including their validity, expiration, and associated services. Use klist to confirm TGT acquisition and other service tickets. The cache details help diagnose configuration or authentication issues.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n> klist\nTicket cache: KCM:1000\nDefault principal: username@MY.DOMAIN.COM\n\nValid starting     Expires            Service principal\n29/08/24 13:54:51  29/08/24 23:54:51  krbtgt/MY.DOMAIN.COM@MY.DOMAIN.COM\n        renew until 05/09/24 13:54:48\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Buffer Read Timeout in ansible.cfg (INI)\nDESCRIPTION: Shows how to set the buffer read timeout globally for persistent connections in the `ansible.cfg` file. Adding `buffer_read_timeout = 2` under the `[persistent_connection]` section applies a 2-second timeout to all tasks using connections like `ansible.netcommon.network_cli`, potentially improving reliability.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_42\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\nbuffer_read_timeout = 2\n```\n\n----------------------------------------\n\nTITLE: Illustrating Expected Output of Running the Extended Ansible Network Playbook using Shell\nDESCRIPTION: This block displays the sample console output from running the 'first_playbook_ext.yml'. It shows the successful execution ('ok') of tasks retrieving information and the 'changed' status for the task that updated the hostname. The final debug message confirms the hostname was indeed changed. A PLAY RECAP summarizes the overall results, indicating one change was made.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible-playbook -i vyos.example.net, -u ansible -k -e ansible_network_os=vyos.vyos.vyos first_playbook_ext.yml\n\nPLAY [Network Getting Started First Playbook Extended]\n************************************************************************************************************************************\n\nTASK [Get config for VyOS devices]\n**********************************************************************************************************************************\nok: [vyos.example.net]\n\nTASK [Display the config]\n*************************************************************************************************************************************\nok: [vyos.example.net] => {\n    \"msg\": \"The hostname is vyos and the OS is VyOS 1.1.8\"\n}\n\nTASK [Update the hostname]\n*************************************************************************************************************************************\nchanged: [vyos.example.net]\n\nTASK [Get changed config for VyOS devices]\n*************************************************************************************************************************************\nok: [vyos.example.net]\n\nTASK [Display the changed config]\n*************************************************************************************************************************************\nok: [vyos.example.net] => {\n    \"msg\": \"The new hostname is vyos-changed and the OS is VyOS 1.1.8\"\n}\n\nPLAY RECAP\n************************************************************************************************************************************\nvyos.example.net           : ok=5    changed=1    unreachable=0    failed=0\n```\n\n----------------------------------------\n\nTITLE: Running the Resource Module Builder Playbook - Bash\nDESCRIPTION: Demonstrates the command for running the resource module builder via ansible-playbook, providing required variables for destination, structure type, organization, collection name, and model file. Dependencies include ansible and the resource module builder checked out locally. Parameters include: rm_dest (destination directory), structure (role or collection), collection_org, collection_name, and the model file path. The output is a scaffolded Ansible collection or role according to the resource model.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -e rm_dest=<destination for modules and module utils> \\\n                 -e structure=collection \\\n                 -e collection_org=<collection_org> \\\n                 -e collection_name=<collection_name> \\\n                 -e model=<model> \\\n                 site.yml\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Netconf Plugins (Shell)\nDESCRIPTION: This shell command utilizes `ansible-doc` with the `-t netconf` option to specify the plugin type (netconf) and the `-l` flag to list all available Netconf plugins installed on the system. This is useful for discovering which network platforms are supported via Netconf in the current Ansible environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/netconf.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t netconf -l\n```\n\n----------------------------------------\n\nTITLE: Testing Ansible Command Module Locally using Shell\nDESCRIPTION: Executes the 'test-module.py' script to run the specified Ansible module ('lib/ansible/modules/command.py') locally on the current machine. The '-m' flag specifies the module path, and the '-a' flag passes simple string arguments ('echo hi') to the module. Useful for development and debugging.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./hacking/test-module.py -m lib/ansible/modules/command.py -a \"echo hi\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Persistent Command Timeout in ansible.cfg - INI\nDESCRIPTION: Edits the '[persistent_connection]' section in ansible.cfg to set a site-wide default for the 'command_timeout' parameter (in seconds). Used when administrators require consistently longer allowance for command execution in persistent connections. Requires access to ansible.cfg; no other dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_28\n\nLANGUAGE: ini\nCODE:\n```\n[persistent_connection]\ncommand_timeout = 60\n```\n\n----------------------------------------\n\nTITLE: Conditionally Importing Assemblies and Ignoring Warnings in C# for Ansible Modules\nDESCRIPTION: This C# snippet demonstrates conditional imports and compiler directive comments for targeting both .NET Core and .NET Framework environments. Depending on the 'CORECLR' symbol, it uses either 'Newtonsoft.Json' or 'System.Web.Script.Serialization'. Special comments control assembly references and compiler warnings: 'AssemblyReference' includes DLLs as needed for the runtime, and 'NoWarn' suppresses specific warnings. The snippet is designed to maximize cross-platform compatibility for module_utils and must be placed at the start of a C# util.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n#if CORECLR\nusing Newtonsoft.Json;\n#else\nusing System.Web.Script.Serialization;\n#endif\n\n//AssemblyReference -Name Newtonsoft.Json.dll -CLR Core\n//AssemblyReference -Name System.Web.Extensions.dll -CLR Framework\n\n// Ignore error CS1702 for all .NET types\n//NoWarn -Name CS1702\n\n// Ignore error CS1956 only for .NET Framework\n//NoWarn -Name CS1956 -CLR Framework\n```\n\n----------------------------------------\n\nTITLE: Importing a Role into Ansible Galaxy - Bash\nDESCRIPTION: Imports a new role from a GitHub repository to Ansible Galaxy using 'ansible-galaxy role import'. Requires API token authentication provided via ansible.cfg or --token parameter. Key parameters are GitHub user and repository name. The command submits an import request and tracks the import process, displaying the import status.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role import github_user github_repo\n```\n\n----------------------------------------\n\nTITLE: Defining Ansible Plugin Documentation in Adjacent YAML\nDESCRIPTION: This YAML snippet illustrates the alternative method of providing Ansible plugin documentation using an adjacent YAML file (introduced in ansible-core 2.14). The structure mirrors the Python embedded format but uses native YAML syntax with top-level keys `DOCUMENTATION` and `EXAMPLES`. This format is useful for non-Python plugins or multi-plugin files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/sidecar.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nDOCUMENTATION:\n  description: something\n  options:\n    option_name:\n      description: describe this config option\n      default: default value for this config option\n      env:\n        - name: NAME_OF_ENV_VAR\n      ini:\n        - section: section_of_ansible.cfg_where_this_config_option_is_defined\n          key: key_used_in_ansible.cfg\n      vars:\n        - name: name_of_ansible_var\n        - name: name_of_second_var\n          version_added: X.x\n      required: True/False\n      type: boolean/float/integer/list/none/path/pathlist/pathspec/string/tmppath\n      version_added: X.x\n\nEXAMPLES: # TODO: write examples\n```\n\n----------------------------------------\n\nTITLE: No Authentication Methods Available Log Output - Plain Text\nDESCRIPTION: Sample log output for an error where Ansible (via Paramiko) cannot find any available authentication methods (password or SSH key) for the remote connection. Used in diagnosing misconfiguration of credentials in environment variables, config files, or playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_22\n\nLANGUAGE: text\nCODE:\n```\n2017-04-04 12:19:05,670 p=18591 u=fred |  creating new control socket for host veos01:None as user admin\n2017-04-04 12:19:05,670 p=18591 u=fred |  control socket path is /home/fred/.ansible/pc/ca5960d27a\n2017-04-04 12:19:05,670 p=18591 u=fred |  current working directory is /home/fred/git/ansible-inc/ansible-workspace-2/test/integration\n2017-04-04 12:19:05,670 p=18591 u=fred |  using connection plugin network_cli\n2017-04-04 12:19:06,606 p=18591 u=fred |  connecting to host veos01 returned an error\n2017-04-04 12:19:06,606 p=18591 u=fred |  No authentication methods available\n2017-04-04 12:19:35,708 p=18591 u=fred |  connect retry timeout expired, unable to connect to control socket\n2017-04-04 12:19:35,709 p=18591 u=fred |  persistent_connect_retry_timeout is 15 secs\n```\n\n----------------------------------------\n\nTITLE: Discouraged Use of `lookup` within `loop` Keyword in Ansible\nDESCRIPTION: This YAML+Jinja snippet illustrates a scenario where converting a `with_*` construct to `loop` is not recommended. Using `lookup` directly within the `loop` keyword, like `lookup('fileglob', '*.txt', wantlist=True)`, is less clear than using the corresponding `with_fileglob` keyword.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_2\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n  loop: \"{{ lookup('fileglob', '*.txt', wantlist=True) }}\"\n```\n\n----------------------------------------\n\nTITLE: Ensuring Command Success Using Shell Logic (YAML)\nDESCRIPTION: This Ansible task uses the `ansible.builtin.shell` module to run a command (`/usr/bin/somecommand`) that might exit with a non-zero (failure) return code even on success. By appending `|| /bin/true` using the shell's OR operator, the task ensures that the overall command sequence passed to the shell always exits with a return code of 0 (success) as long as `/bin/true` executes successfully, thus preventing Ansible from interpreting the original command's non-zero exit code as a task failure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_error_handling.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - name: Run this command and ignore the result\n    ansible.builtin.shell: /usr/bin/somecommand || /bin/true\n```\n\n----------------------------------------\n\nTITLE: Displaying Documentation for a Specific Ansible Netconf Plugin (Shell)\nDESCRIPTION: This shell command uses `ansible-doc` with the `-t netconf` option to specify the plugin type and requires providing a specific `<plugin name>` to display detailed documentation and examples for that particular Netconf plugin. Replace `<plugin name>` with the actual name of the plugin you want to inspect.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/netconf.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t netconf <plugin name>\n```\n\n----------------------------------------\n\nTITLE: Fixing Unintentional Truthy Conditional by Removing Quotes in Ansible\nDESCRIPTION: This Ansible playbook snippet presents the corrected version of a conditional where erroneous quotes were removed. By removing the quotes around `inventory_hostname | length > 0`, the Jinja2 expression is evaluated correctly, resulting in a boolean value as required by Ansible 12's conditional logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_3\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname is defined and inventory_hostname | length > 0\n```\n\n----------------------------------------\n\nTITLE: Obtaining a Forwardable Kerberos Ticket and Checking Ticket Flags - bash\nDESCRIPTION: This bash code demonstrates obtaining a forwardable Kerberos ticket using `kinit -f` and then inspecting the ticket flags with `klist -f`. The forwardable ticket allows GSSAPI credential delegation in SSH sessions, required for accessing remote network resources. Prerequisites include a functioning Kerberos setup and a properly configured user environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_ssh.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n> kinit -f username@REALM.COM\nPassword for username@REALM.COM\n\n# -f will show the ticket flags, we want to see F\n> klist -f\nTicket cache: KCM:1000\nDefault principal: username@REALM.COM\n\nValid starting     Expires            Service principal\n29/08/24 13:54:51  29/08/24 23:54:51  krbtgt/REALM.COM@REALM.COM\n        renew until 05/09/24 13:54:48, Flags: FRIA\n```\n\n----------------------------------------\n\nTITLE: Copy Standalone Role into Collection Roles Directory (Bash CLI)\nDESCRIPTION: Commands to create a role subfolder in a collection and recursively copy a standalone role's files into it. Requires access to the filesystem and the source role folder. Ensures correct directory preparation and content migration within collection standards.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir mynamespace/mycollection/roles/my_role/\\n$ cp -r /path/to/standalone/role/mynamespace/my_role/* mynamespace/mycollection/roles/my_role/\\n\n```\n\n----------------------------------------\n\nTITLE: Importing C# Module Util with #AnsibleRequires in PowerShell\nDESCRIPTION: This snippet shows how to import a C#-implemented module utility using the #AnsibleRequires statement in a PowerShell script. 'Ansible.Basic' is a C# utility stored in the Ansible source code, and upon import its types are loaded into the execution environment. This is an Ansible-specific extension supporting collection utils, relative names, and optional imports. The file must reside at the designated location or module_utils path.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\n#AnsibleRequires -CSharpUtil Ansible.Basic\n```\n\n----------------------------------------\n\nTITLE: Offline Verification of Signed Collection - ansible-galaxy CLI - Bash\nDESCRIPTION: Adds the --offline option to verify the signature and internal consistency of a collection without querying the distribution server. Public keyring remains necessary for the signature check. This is useful in restricted environments or for CI/CD automation without network access.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_verifying.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection verify my_namespace.my_collection --offline --keyring ~/.ansible/pubring.kbx\n```\n\n----------------------------------------\n\nTITLE: Configuring Extended Loop Variables without 'allitems'\nDESCRIPTION: This configuration snippet demonstrates how to enable extended loop variables while excluding the potentially memory-intensive `ansible_loop.allitems` variable. By setting `extended: true` and `extended_allitems: false` within `loop_control`, other extended variables are available, but memory consumption related to storing all loop items is reduced.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_28\n\nLANGUAGE: none\nCODE:\n```\nloop_control:\n  extended: true\n  extended_allitems: false\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unintentional Truthy Conditional Error due to Quoting in Ansible\nDESCRIPTION: This Ansible playbook snippet shows a broken conditional where the second part of the expression (`'inventory_hostname | length > 0'`) is erroneously quoted. This causes the string itself to become the result, which evaluates as 'truthy', masking the intended logic and triggering a non-boolean conditional error in Ansible 12.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_2\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: inventory_hostname is defined and 'inventory_hostname | length > 0'\n```\n\n----------------------------------------\n\nTITLE: Specifying Collection Signatures in requirements.yml (YAML)\nDESCRIPTION: This snippet demonstrates how to include a `signatures` key within a collection definition in `requirements.yml`. It accepts a list of URIs pointing to detached signature files (e.g., hosted remotely or on the local filesystem) used for verifying collections installed from Galaxy servers. Using this feature requires providing the `--keyring` command-line option during installation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/shared_snippets/installing_multiple_collections.txt#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ncollections:\n  - name: namespace.name\n    version: 1.0.0\n    type: galaxy\n    signatures:\n      - https://examplehost.com/detached_signature.asc\n      - file:///path/to/local/detached_signature.asc\n```\n\n----------------------------------------\n\nTITLE: Setting Ansible Connection Plugin via Command Line\nDESCRIPTION: Use the `-c` or `--connection` command-line arguments with Ansible commands (like `ansible` or `ansible-playbook`) to specify the connection plugin to use for the current execution, overriding default or configured settings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/connection.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n-c\n```\n\nLANGUAGE: shell\nCODE:\n```\n--connection\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Dictionary Items Using Native Python 3 Syntax - Python\nDESCRIPTION: This code demonstrates iterating over key-value pairs in a dictionary using the inbuilt items() method, which is the standard approach in Python 3. No additional dependencies are needed. The loop variables KEY and VALUE represent each entry in the dictionary DICT, enabling straightforward access and manipulation of dictionary contents. The expected input is any Python dictionary; the code yields individual key/value pairs in each iteration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-dict-iteritems.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfor KEY, VALUE in DICT.items():\n   pass\n```\n\n----------------------------------------\n\nTITLE: Running an Ansible Playbook via CLI in Bash\nDESCRIPTION: This bash command invokes the Ansible playbook using 'ansible-playbook', targeting the specified inventory and playbook YAML files. Prerequisites: Ansible must be installed, and both the 'inventory.ini' and 'playbook.yaml' files must exist. The command executes all defined plays and tasks against the listed hosts, outputting result details to the console. Input: inventory and playbook file paths; Output: console printout of operation results.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_playbook.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-playbook -i inventory.ini playbook.yaml\n```\n\n----------------------------------------\n\nTITLE: Erroneous Template Delimiter in Expression (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This shows an incorrect use of Jinja template delimiters within an expression. Ansible-core 2.19 forbids such embedded templates for security, and expects plain variable references. Required context: Ansible with variable 'value'. Output: error due to syntax violation; highlights limitation of new secure templating.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_9\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: 1 + {{ value }} == 2\n      vars:\n        value: 1\n```\n\n----------------------------------------\n\nTITLE: Python Import Statement for Custom Module Utils in Collection (Text)\nDESCRIPTION: Example Python import that references module utility code within a collection by fully qualified namespace. Dependency: code must reside in the specified module_utils path within the collection. Input is the collection's FQCN and util name, and output is the correct import statement.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nfrom ansible_collections.{namespace}.{collectionname}.plugins.module_utils.{util} import {something}\\n\n```\n\n----------------------------------------\n\nTITLE: Sample Output of a Successful Ansible Role Import - Text\nDESCRIPTION: Shows the expected console output messages as the import process executes for an Ansible role. Includes status updates such as request submission, parsing, and validation steps, and concludes with the import status. Output is informational for users importing and troubleshooting Ansible Galaxy role submissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n    Successfully submitted import request 41\n    Starting import 41: role_name=myrole repo=githubuser/ansible-role-repo ref=\n    Retrieving GitHub repo githubuser/ansible-role-repo\n    Accessing branch: devel\n    Parsing and validating meta/main.yml\n    Parsing galaxy_tags\n    Parsing platforms\n    Adding dependencies\n    Parsing and validating README.md\n    Adding repo tags as role versions\n    Import completed\n    Status SUCCESS : warnings=0 errors=0\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Network Integration Tests via CLI - Bash\nDESCRIPTION: This series of Bash commands demonstrates running network module integration tests with various filtering options using ansible-test. Requires an Ansible development/test environment, prepared inventory, and test cases. Inputs: inventory path and test/module expression; outputs: executed tests with logs. Includes regex-based test selection, transport- or tag-filtered runs, and illustrates use for single or all-module test execution. Users must update inventory and have test files staged.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ncd test/integration\ncp inventory.network.template inventory.networking\n${EDITOR:-vi} inventory.networking\n# Add in machines for the platform(s) you wish to test\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-test network-integration --inventory ~/myinventory -vvv vyos_facts\nansible-test network-integration --inventory ~/myinventory -vvv vyos_.*\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking vyos_.*\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking vyos_l3_interfaces\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Only run vyos_l3_interfaces/tests/cli/gathered.yaml\nansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking vyos_l3_interfaces --testcase gathered\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Only run nxapi test\nansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking  --tags=\"nxapi\" nxos_.*\n\n# Skip any cli tests\nansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking  --skip-tags=\"cli\" nxos_.*\n```\n\nLANGUAGE: bash\nCODE:\n```\nansible-test network-integration --help\n```\n\n----------------------------------------\n\nTITLE: Importing a GPG Public Key for Ansible Collection Signature Verification using Bash\nDESCRIPTION: This command uses the `gpg` utility to import a public key from the file `my-public-key.asc` into a specific GnuPG keyring located at `~/.ansible/pubring.kbx`. The `--no-default-keyring` option prevents modification of the user's default GPG keyring. This step is necessary before installing signed collections to verify their authenticity.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngpg --import --no-default-keyring --keyring ~/.ansible/pubring.kbx my-public-key.asc\n```\n\n----------------------------------------\n\nTITLE: Ansible Inventory Graph Output Example (text)\nDESCRIPTION: Displays a text-formatted output from ansible-inventory --graph showing hierarchical groupings of hosts detected by an enabled inventory plugin. Used for visual verification of inventory composition and plugin effectiveness. Output is read-only and provided as illustrative sample.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/inventory.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n@all:\\n  |--@aws_ec2:\\n  |  |--ec2-12-345-678-901.compute-1.amazonaws.com\\n  |  |--ec2-98-765-432-10.compute-1.amazonaws.com\\n  |--@ungrouped:\n```\n\n----------------------------------------\n\nTITLE: Deprecated: Using Dictionary Variable for Task Parameters: Ansible Playbook YAML Syntax\nDESCRIPTION: This YAML snippet exemplifies the deprecated method of passing a variable dictionary directly to a module call in Ansible, which is currently supported with warnings but will be removed in future versions. It includes two forms: passing the dictionary with both 'debug: {{debug_params}}' and using the 'args' property. This approach may lead to ambiguity and security risks if not updated.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: localhost\n  gather_facts: no\n  vars:\n    debug_params:\n      msg: \"hello there\"\n  tasks:\n    - debug: \"{{debug_params}}\"\n    - debug:\n      args: \"{{debug_params}}\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Standard Output Callbacks for Ad Hoc Commands via Environment Variable\nDESCRIPTION: This shell command shows an alternative method to enable the configured `stdout_callback` plugin for Ansible ad hoc commands by setting the `ANSIBLE_LOAD_CALLBACK_PLUGINS` environment variable to `1`. This achieves the same result as setting `bin_ansible_callbacks=True` in `ansible.cfg`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/callback.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_LOAD_CALLBACK_PLUGINS=1\n```\n\n----------------------------------------\n\nTITLE: Installing Collection Locally from Git Repository (Bash)\nDESCRIPTION: Illustrates installing an Ansible collection directly from a Git repository and a specified branch using the ansible-galaxy collection install command. The input is a VCS-style reference (git+URL,branch); outputs the collection installed in the configured collection path. Useful for testing unreleased or in-development code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncollection_dir#> ansible-galaxy collection install git+https://github.com/org/repo.git,devel\n```\n\n----------------------------------------\n\nTITLE: Injecting Complex Module Arguments via Module Replacer (Internal)\nDESCRIPTION: This internal replacement pattern is substituted by the Module Replacer with a Python `repr` string of the JSON-encoded module parameters. This format ensures safe embedding within a Python file. In Ansiballz, parameters are accessed via `AnsibleModule.params`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n\"<<INCLUDE_ANSIBLE_MODULE_COMPLEX_ARGS>>\"\n```\n\n----------------------------------------\n\nTITLE: Increasing Persistent Connection Idle Timeout via Shell - Shell\nDESCRIPTION: Sets the 'ANSIBLE_PERSISTENT_CONNECT_TIMEOUT' environment variable in a shell to extend the idle timeout for persistent connections from the default of 30 seconds. This command is run in the shell prior to launching Ansible playbooks. Requires no dependencies except the shell and Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_PERSISTENT_CONNECT_TIMEOUT=60\n```\n\n----------------------------------------\n\nTITLE: Including Shared SSH Warning Snippet in Ansible Docs (Text)\nDESCRIPTION: This text snippet demonstrates the reStructuredText directive (`.. include::`) used to incorporate the content of `shared_snippets/SSH_warning.txt` into a platform-specific documentation file (`platform_<name>.rst`). This inclusion is recommended at the bottom of the file if the network platform supports SSH connections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/documenting_modules_network.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n.. include:: shared_snippets/SSH_warning.txt\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Task Arguments in Ansible Output\nDESCRIPTION: Configures Ansible to include variable values (task arguments) in the standard output (STDOUT). This setting, when enabled in the Ansible configuration file, helps differentiate similar tasks in logs, especially when used with `log_path`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/logging.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n`display_args_to_stdout`\n```\n\n----------------------------------------\n\nTITLE: Collection Plugin Structure for Terminal and CLIConf Plugins - Ansible Plugins Bash\nDESCRIPTION: Shows the recommended folder hierarchy for terminal and cliconf plugins inside an Ansible Collection, allowing for modular packaging and distribution. Directories should be populated with Python plugin files conforming to Ansible standards for collection plugins.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmyorg/mycollection/plugins/terminal/\\nmyorg/mycollection/plugins/cliconf/\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Module Default Groups in Ansible Collection runtime.yml\nDESCRIPTION: This YAML snippet shows the content of a `meta/runtime.yml` file within an Ansible collection (`ns.coll`). It defines a custom action group named `my_group` (fully qualified as `ns.coll.my_group`) that includes modules `sample_module` from the same collection and `another_module` from a different collection (`another.collection`). This group can then be targeted by `module_defaults` in playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_module_defaults.rst#_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\n# collections/ansible_collections/ns/coll/meta/runtime.yml\naction_groups:\n  my_group:\n    - sample_module\n    - another.collection.another_module\n```\n\n----------------------------------------\n\nTITLE: Ansible Vault Labeled Encrypted File Header Format - Example (Text)\nDESCRIPTION: Demonstrates the header of an Ansible Vault file specifying format version, encryption algorithm, and a vault ID label. Useful for identifying which vault password or ID was used during encryption with the --vault-id option. Header fields are separated by semi-colons and line is terminated by newline.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n$ANSIBLE_VAULT;1.2;AES256;vault-id-label\n```\n\n----------------------------------------\n\nTITLE: Using Download Path Option with Ansible Galaxy Collection Download - Bash\nDESCRIPTION: Explains how to specify a custom output location for downloaded collections using the -p or --download-path option. This enables users to collect all downloaded artifacts in a designated directory, such as for transfer to an offline environment. Default directory ('./collections') is overridden by the given path.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_downloading.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection download my_namespace.my_collection -p ~/offline-collections\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Modules (Shell)\nDESCRIPTION: This shell command utilizes the `ansible-doc` utility with the `-l` flag to display a list of all available Ansible modules. Since Action Plugins often correspond to modules, this command indirectly helps in identifying available actions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/action.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -l\n```\n\n----------------------------------------\n\nTITLE: Testing a Windows Module via Ansible Playbook - YAML\nDESCRIPTION: This YAML snippet is an example Ansible playbook that tests a custom Windows module ('win_module'). It defines target hosts, tasks, and module-specific options like 'name.' To run this, you need an inventory file specifying Windows hosts and the custom module available in the Ansible environment. The task sends the 'name' parameter to the module and expects execution feedback; suitable for local or CI testing of new modules. There are no complex constraints, but all referenced hosts need to be reachable, and 'win_module' must be implemented.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n---\\n- name: test out windows module\\n  hosts: windows\\n  tasks:\\n  - name: test out module\\n    win_module:\\n      name: test name\n```\n\n----------------------------------------\n\nTITLE: Asserting Human-Readable Sizes with Filters - Ansible YAML/Jinja\nDESCRIPTION: This snippet checks whether byte and bit values are correctly converted to and from human-readable size strings in an Ansible playbook using 'human_readable' and 'human_to_bytes' filters. Dependencies include Ansible's Jinja2 templating and the presence of these filters. The main parameters are numeric or string size values, optionally specifying unit or bit representation. The output is asserted strings comparing converted results for correctness, with limitations based on filter availability and strictness of equality.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_17\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- name: \"Human Readable\"\n  assert:\n    that:\n      - '\"1.00 Bytes\" == 1|human_readable'\n      - '\"1.00 bits\" == 1|human_readable(isbits=True)'\n      - '\"10.00 KB\" == 10240|human_readable'\n      - '\"97.66 MB\" == 102400000|human_readable'\n      - '\"0.10 GB\" == 102400000|human_readable(unit=\"G\")'\n      - '\"0.10 Gb\" == 102400000|human_readable(isbits=True, unit=\"G\")'\n```\n\n----------------------------------------\n\nTITLE: Granting SeTcbPrivilege to a User on Windows using Ansible - YAML\nDESCRIPTION: This snippet shows how to assign the SeTcbPrivilege ('Act as part of the operating system') user right to a specified user account via the 'ansible.windows.win_user_right' Ansible module. It requires Ansible connectivity to a Windows machine and sufficient privileges to modify user rights. The 'users' parameter should be provided with the login for which the right is to be granted. This task is potentially dangerous and should be used judiciously, as it grants full system control.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n- name: grant the ansible user the SeTcbPrivilege right\\n  ansible.windows.win_user_right:\\n    name: SeTcbPrivilege\\n    users: '{{ansible_user}}'\\n    action: add\n```\n\n----------------------------------------\n\nTITLE: ipaddress Package Requirement (Python/Ansible)\nDESCRIPTION: States that the `ipaddress` package is now required for certain collections (`cisco.iosxr`, `vyos.vyos`) when using Python versions less than 3.0, as this package is no longer included in `ansible.netcommon`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nipaddress\n```\n\n----------------------------------------\n\nTITLE: Refactoring HashiCorp Vault Lookup Plugin FQCN for Ansible - Markdown\nDESCRIPTION: This snippet provides the updated FQCN for the hashi_vault plugin, instructing users to transition from the general collection to the dedicated community.hashi_vault collection and update playbook references for legacy Ansible compatibility.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.hashi_vault`` → ``community.hashi_vault.hashi_vault``\n```\n\n----------------------------------------\n\nTITLE: Handling Single Login Prompt via Host Variables (YAML)\nDESCRIPTION: Example host variables file (`host_vars/<hostname>.yaml`) defining `ansible_terminal_initial_prompt` and `ansible_terminal_initial_answer` to automatically handle a single login menu prompt. This is used with the `network_cli` connection type in Ansible 2.9+ to interact with initial device prompts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_34\n\nLANGUAGE: console\nCODE:\n```\n$ cat host_vars/<hostname>.yaml\n---\nansible_terminal_initial_prompt:\n  - \"Connect to a host\"\nansible_terminal_initial_answer:\n  - \"3\"\n```\n\n----------------------------------------\n\nTITLE: Custom Async Directory in Ansible Task - YAML\nDESCRIPTION: This YAML snippet shows how to assign a custom async directory for a backgrounded task using the ansible_async_dir variable. It replaces the deprecated ANSIBLE_ASYNC_DIR environment key, allowing users to specify where Ansible stores async job data at the task/play level. Key parameters are 'async' (background execution timeout), 'command', and 'vars'. The variable is set per-task. No external dependencies. Inputs: command task, async value, custom path. Outputs: async data written to specified path.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n- name: run task with custom async directory\n  command: sleep 5\n  async: 10\n  vars:\n    ansible_async_dir: /tmp/.ansible_async\n```\n\n----------------------------------------\n\nTITLE: Sanitizing Dictionary Keys Containing Sensitive Data\nDESCRIPTION: Recommends calling `ansible.module_utils.basic.sanitize_keys()` on return dictionaries if sensitive values (originally marked with `no_log=True`) might appear as part of a dictionary key name. This function removes the sensitive value from the key itself. The `uri` module is cited as an example implementation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_best_practices.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nansible.module_utils.basic.sanitize_keys()\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing Ansible Collection with Multiple GPG Signatures via Environment Variables\nDESCRIPTION: This set of bash commands first exports environment variables to set the GPG keyring path (`ANSIBLE_GALAXY_GPG_KEYRING`) and require at least two valid signatures (`ANSIBLE_GALAXY_REQUIRED_VALID_SIGNATURE_COUNT=2`). Then, it installs `my_namespace.my_collection` using `ansible-galaxy`, providing two additional signature URIs via the `--signature` option for verification against the configured keyring and requirement count.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport ANSIBLE_GALAXY_GPG_KEYRING=~/.ansible/pubring.kbx\nexport ANSIBLE_GALAXY_REQUIRED_VALID_SIGNATURE_COUNT=2\nansible-galaxy collection install my_namespace.my_collection --signature https://examplehost.com/detached_signature.asc --signature file:///path/to/local/detached_signature.asc\n```\n\n----------------------------------------\n\nTITLE: Defining a Cacheable Ansible Inventory Module Class - Python\nDESCRIPTION: This Python code snippet demonstrates how to create a custom Ansible Inventory plugin class by subclassing 'BaseInventoryPlugin', 'Constructable', and 'Cacheable', enabling both constructed and cache-related features. Declaring the 'NAME' class variable specifies the inventory plugin's unique identifier. The class can be extended with custom logic for parsing, caching, and initialization. Dependencies include the Ansible Python plugin classes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):\n\n    NAME = 'myplugin'\n\n```\n\n----------------------------------------\n\nTITLE: Using Assert on Implicit Boolean Conversion in Ansible Playbook (YAML+Jinja)\nDESCRIPTION: This snippet shows the use of the assert module with a conditional relying on the implicit truthy evaluation of the 'inventory_hostname' variable. No explicit boolean conversion is used, leading Ansible 2.19 to raise an error requiring the result to be strictly boolean. The example demonstrates the old pattern now considered invalid. Requires Ansible, with 'inventory_hostname' accessible in context. Output is an assertion result; the limitation is that implicit string-to-boolean conversions are now rejected.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_0\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname\n```\n\n----------------------------------------\n\nTITLE: Structuring the EXAMPLES Block in Ansible Module Documentation (Text/YAML)\nDESCRIPTION: This snippet illustrates the recommended structure for the `EXAMPLES` block within Ansible module documentation. It shows a basic YAML example task with a descriptive `name` and the module call using its Fully Qualified Collection Name (FQCN). The code itself is presented as a raw string literal (text) typically assigned to the EXAMPLES variable in the module's Python code, but represents YAML.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n.. code-block:: text\n\n    EXAMPLES = r'''\n    - name: Ensure foo is installed\n      namespace.collection.modulename:\n        name: foo\n        state: present\n    '''\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Collection 'community.general' on Fedora Linux (Bash)\nDESCRIPTION: Installs the 'community.general' Ansible collection as a standalone package from Fedora repositories using the DNF package manager. This is typically done when only 'ansible-core' is installed. Requires root privileges (sudo).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo dnf install ansible-collection-community-general\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests for postgresql_info Target on Fedora34 - Bash Command\nDESCRIPTION: This snippet provides a concrete example of running Ansible integration tests for the 'postgresql_info' target using the Fedora 34 Docker image. It replaces the generic placeholders with actual directory and distribution values. Prerequisites include Docker installed and accessible, and being in the appropriate Ansible collection directory. The output will show the integration test results within a containerized Fedora 34 environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_running.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-test integration postgresql_info --docker fedora34\n```\n\n----------------------------------------\n\nTITLE: Querying failed logon attempts in Windows Event Log - PowerShell\nDESCRIPTION: This PowerShell snippet retrieves details of the most recent failed logon attempt from the Security event log, which can assist in diagnosing credential rejection issues when connecting to a Windows host. It uses Get-WinEvent with a filter for event ID 4625 (failed logon), selects the first such event, and expands its Message property. No dependencies beyond standard PowerShell are needed; requires execution privileges on the target Windows host. The output includes status and sub status error codes that indicate the reason for logon failure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_windows.rst#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nGet-WinEvent -FilterHashtable @{LogName = 'Security'; Id = 4625} |\n    Select-Object -First 1 -ExpandProperty Message\n```\n\n----------------------------------------\n\nTITLE: Debugging with regex_replace Filter: Ansible Playbook YAML Syntax (Ansible 2.0.x)\nDESCRIPTION: This YAML snippet shows the syntax used in Ansible 2.0.x for the same regex_replace filter and debug module functionality, demonstrating how escaping requirements have changed. It requires the same modules and templating dependencies, but uses single-backslash escaping compatible with Ansible 2.0.x. The code illustrates correct message rendering after Ansible's update in handling escapes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.0.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- debug:\n    msg: \"{{ 'test1_junk 1\\\\3' | regex_replace('(.*)_junk (.*)', '\\1 \\2') }}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Paramiko SSH Key Search in ansible.cfg File - INI\nDESCRIPTION: Configures Paramiko's behavior in the ansible.cfg file to prevent it from looking for SSH keys automatically. Place the '[paramiko_connection]' section into ansible.cfg and set 'look_for_keys = False' to globally disable automatic SSH key lookup. No external dependencies required beyond Ansible and presence of ansible.cfg.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_18\n\nLANGUAGE: ini\nCODE:\n```\n[paramiko_connection]\nlook_for_keys = False\n```\n\n----------------------------------------\n\nTITLE: Requesting a Kerberos Service Ticket for WinRM (Bash)\nDESCRIPTION: This command requests a service ticket for http/server.my.domain.com using the kvno utility, demonstrating Kerberos authentication against a WinRM host. It outputs the service principal and kvno value. Requires an existing TGT and properly configured krb5.conf.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ kvno http/server.my.domain.com\nhttp/server2025.domain.test@DOMAIN.TEST: kvno = 2\n```\n\n----------------------------------------\n\nTITLE: Configuring Control Node Log Path in Ansible\nDESCRIPTION: Sets the path to a single log file on the Ansible control node where all playbook output will be saved. This is a setting configured in the Ansible configuration file (`ansible.cfg`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/logging.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n`log_path`\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites with DNF - Bash\nDESCRIPTION: Installs Podman, Python 3, and Python 3 pip packages using the DNF package manager. Requires a Linux distribution that supports DNF (such as Fedora or RHEL-based systems). The command must be run with appropriate privileges, usually via sudo, and is intended to bootstrap the basic runtime for subsequent Ansible tooling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/setup_environment.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf install -y podman python3 python3-pip\n```\n\n----------------------------------------\n\nTITLE: Listing Available Ansible Shell Plugins (Shell)\nDESCRIPTION: Executes the `ansible-doc` command to list all available shell plugins installed in the Ansible environment. The `-t shell` flag specifies the plugin type as 'shell', and the `-l` flag requests the list output format. This command helps users discover which shell plugins are available for configuration.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/shell.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-doc -t shell -l\n```\n\n----------------------------------------\n\nTITLE: Finding Custom DSC Resources via PowerShell\nDESCRIPTION: Provides PowerShell commands to discover additional DSC resources available in configured repositories using Find-DscResource. Useful for administrators seeking to extend or customize managed configuration states on Windows hosts. Requires PowerShell and suitable user permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_dsc.rst#_snippet_8\n\nLANGUAGE: powershell\nCODE:\n```\n# Find all DSC resources in the configured repositories\nFind-DscResource\n\n# Find all DSC resources that relate to SQL\nFind-DscResource -ModuleName \"*sql*\"\n```\n\n----------------------------------------\n\nTITLE: Persistent Connection Idle Timeout Log Output - Plain Text\nDESCRIPTION: Logs an event where the persistent connection has been closed due to inactivity, showing receipt of an idle timeout. Helpful in debugging session persistence and tuning persistent timeout values. No dependencies; standard Ansible logging output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_23\n\nLANGUAGE: text\nCODE:\n```\n2017-04-04 12:19:05,670 p=18591 u=fred |  persistent connection idle timeout triggered, timeout value is 30 secs\n```\n\n----------------------------------------\n\nTITLE: Import Guarding and Error Capturing in Ansible Modules - Python\nDESCRIPTION: This example shows how to guard imports of optional dependencies in an Ansible module. By using try/except around the import statement, the snippet sets flags indicating whether the library is available and captures traceback or exception information. The snippet requires the 'ansible.module_utils.basic' for missing_required_lib and uses the built-in traceback module. Inputs: none directly; imports an optional library. Outputs: Boolean flag and error info variables reflecting the import status. This pattern avoids unhandled tracebacks and prepares informative error handling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport traceback\n\nfrom ansible.module_utils.basic import missing_required_lib\n\ntry:\n    import another_library\nexcept ImportError:\n    HAS_ANOTHER_LIBRARY = False\n    ANOTHER_LIBRARY_IMPORT_ERROR = traceback.format_exc()\nelse:\n    HAS_ANOTHER_LIBRARY = True\n    ANOTHER_LIBRARY_IMPORT_ERROR = None\n```\n\n----------------------------------------\n\nTITLE: Refactoring Ansible FQCNs for Docker Modules - Markdown\nDESCRIPTION: This entry documents the FQCN migration for the Ansible Docker container module and emphasizes that users should install the 'community.docker' collection and change playbooks to reference the new namespace. Failure to do so on Ansible 2.9 will result in unresolved modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.docker_container`` → ``community.docker.docker_container``\n```\n\n----------------------------------------\n\nTITLE: Verifying Kerberos Utilities Installation (Bash)\nDESCRIPTION: This snippet shows how to verify Kerberos utility installation by checking the installed version of krb5-config. The command outputs the current Kerberos version and should be run after package installation to confirm availability of key utilities like kinit, klist, and krb5-config.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ krb5-config --version\n\nKerberos 5 release 1.21.3\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Socket Path Error (MODULE FAILURE) - Ansible Output\nDESCRIPTION: Sample output from Ansible showing a fatal error due to a missing or inaccessible socket path. Output includes module_stderr, result code, and diagnostic traceback indicating where the socket path issue was encountered. Used to help identify failure conditions related to underlying transport infrastructure between Ansible and the managed network device.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_9\n\nLANGUAGE: ansible-output\nCODE:\n```\nfatal: [spine02]: FAILED! => {\\n    \"changed\": false,\\n    \"failed\": true,\\n    \"module_stderr\": \"Traceback (most recent call last):\\n  File \\\"/tmp/ansible_TSqk5J/ansible_modlib.zip/ansible/module_utils/connection.py\\\", line 115, in _exec_jsonrpc\\nansible.module_utils.connection.ConnectionError: Socket path XX does not exist or cannot be found. See Troubleshooting socket path issues in the Network Debug and Troubleshooting Guide\\n\",\\n    \"module_stdout\": \"\",\\n    \"msg\": \"MODULE FAILURE\",\\n    \"rc\": 1\\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling PowerShell Remoting on Windows Host via Shell\nDESCRIPTION: This command, which should be run directly on a Windows host, enables PowerShell Remoting required for ansible-test Windows integration. The '-Force' flag suppresses user prompts. Prerequisite: Administrator rights on the Windows host.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nEnable-PSRemoting -Force\n```\n\n----------------------------------------\n\nTITLE: Stand-Alone Role Directory Structure in Ansible (Bash)\nDESCRIPTION: Displays the typical folder layout for a traditional Ansible standalone role prior to migration to a collection. No dependencies are required; it represents a file and folder structure. Takes no inputs and serves as a template for comparison when refactoring to collections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrole/\\n├── defaults\\n├── files\\n├── handlers\\n├── library\\n├── meta\\n├── module_utils\\n├── [*_plugins]\\n├── tasks\\n├── templates\\n├── tests\\n└── vars\\n\n```\n\n----------------------------------------\n\nTITLE: Listing Operators for the Ansible 'version' Test in Console\nDESCRIPTION: Lists the valid comparison operators that can be used as the second argument to the `version` test in Ansible for comparing version strings. Both short and long forms are accepted.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_tests.rst#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n<, lt, <=, le, >, gt, >=, ge, ==, =, eq, !=, <>, ne\n```\n\n----------------------------------------\n\nTITLE: Migrating KubeVirt Ansible Modules to New FQCN - Markdown\nDESCRIPTION: This snippet presents the FQCN change for the KubeVirt VM module, instructing users to replace 'community.general.kubevirt_vm' with 'community.kubevirt.kubevirt_vm' after installing the new 'community.kubevirt' collection. This is necessary for proper module resolution in Ansible 2.9 environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n``community.general.kubevirt_vm`` → ``community.kubevirt.kubevirt_vm``\n```\n\n----------------------------------------\n\nTITLE: Setting Inventory Cache Plugin via Environment Variable in Shell\nDESCRIPTION: Configures the specific plugin to use for inventory caching via the `ANSIBLE_INVENTORY_CACHE_PLUGIN` environment variable in a shell. This example sets the plugin to `jsonfile`. Inventory caching must also be enabled (e.g., using `ANSIBLE_INVENTORY_CACHE=True`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/plugins/cache.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_INVENTORY_CACHE_PLUGIN=jsonfile\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unintentional String Conversion in Jinja (Ansible)\nDESCRIPTION: This Ansible task uses the `debug` module to display a message processed by Jinja. It incorrectly attempts to use the `replace` filter on a list (`['test1', 'test2']`). Since `replace` operates on strings, Jinja silently converts the list input to its string representation before applying the filter. This unintentional conversion could be masked in previous Ansible versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_14\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    - debug:\n        msg: \"{{ ['test1', 'test2'] | replace('test', 'prod') }}\"\n```\n\n----------------------------------------\n\nTITLE: Executing RouterOS Commands via Ansible Task (YAML)\nDESCRIPTION: This Ansible task demonstrates using the `community.network.routeros_command` module to run the `/system resource print` command on target RouterOS devices configured for CLI access. The output is registered to the `routeros_resources` variable, and the task only executes on hosts where `ansible_network_os` is set to `community.network.routeros`. Requires the `community.network` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_routeros.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: Display resource statistics (routeros)\n     community.network.routeros_command:\n       commands: /system resource print\n     register: routeros_resources\n     when: ansible_network_os == 'community.network.routeros'\n```\n\n----------------------------------------\n\nTITLE: Testing Awaiting Multiple Mock RDS States - Python\nDESCRIPTION: Invokes a function to wait for a mocked RDS resource to reach a specified state, providing the prepared mock client as input. Asserts that the sleep/mock call count exceeds a threshold, ensuring the await logic properly loops through all intermediate states. Suitable for verifying asynchronous module transitions against sequences of simulated states; assumes mocks for client and sleeper objects are in place.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nrds_i.await_resource(rds_client_double, \"some-instance\", \"available\", mod_mock,\\n                     await_pending=1)\\nassert(len(sleeper_double.mock_calls) > 5), \"await_pending didn't wait enough\"\n```\n\n----------------------------------------\n\nTITLE: Equivalent Non-Looped Tasks for Adding Users in Ansible\nDESCRIPTION: These two YAML tasks demonstrate the equivalent actions of the previous loop example (`Add several users`) written out as individual tasks without using a loop. This illustrates the verbosity that loops help avoid.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_loops.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n.. code-block:: yaml\n\n    - name: Add user testuser1\n      ansible.builtin.user:\n        name: \"testuser1\"\n        state: present\n        groups: \"wheel\"\n\n    - name: Add user testuser2\n      ansible.builtin.user:\n        name: \"testuser2\"\n        state: present\n        groups: \"wheel\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Class Definition Based on Import Status - Python\nDESCRIPTION: This snippet shows how to define a class that only exists if a required library was successfully imported. It checks ANOTHER_LIBRARY_IMPORT_ERROR and only defines the subclass if no error is present. Inputs: ANOTHER_LIBRARY_IMPORT_ERROR. Outputs: Class definition is conditional. Useful for scenarios where plugin/module extensibility is modular.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nif not ANOTHER_LIBRARY_IMPORT_ERROR:\n    class CustomThing(UsefulThing):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Installing Test Dependencies with ansible-test - Shell\nDESCRIPTION: This shell command demonstrates installing required dependencies for running unit tests in Ansible by specifying the --requirements option and, optionally, the Python version. It requires ansible-test to be installed and available in the environment. The main parameter is the name of the requirements group or file; it installs all dependencies recorded for that group prior to running the tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-test units --python 2.7 --requirements apache2_module\n```\n\n----------------------------------------\n\nTITLE: Tag Handling Change for `meta` Module Tasks\nDESCRIPTION: User-defined tasks using the `meta` module now respect tags like regular tasks. Previously, they always ran. To restore the old behavior where a specific meta task always runs regardless of tags specified on the command line, assign it the tag 'always'. Internal meta tasks (like `flush_handlers`) continue to always run.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\n- name: This meta task now respects tags\n  ansible.builtin.meta: refresh_inventory\n  tags:\n    - inventory_update\n\n- name: This meta task will always run\n  ansible.builtin.meta: reset_connection\n  tags:\n    - always\n```\n\n----------------------------------------\n\nTITLE: Overriding and Verifying L3 Interface Configuration in vyos_l3_interfaces Test - YAML+Jinja\nDESCRIPTION: This YAML+Jinja playbook runs end-to-end tests for overriding L3 interface configuration using the vyos.vyos.vyos_l3_interfaces module. Key tasks: remove config setup, apply full interface configuration, and assert idempotency via before/after checks and Ansible's 'assert' module. Dependencies include vyos.vyos collection and supporting test task files. Inputs: interface configuration objects; outputs: test pass/fail status based on device state and generated commands. Playbook maintains cleanup and is designed for idempotence validation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_15\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n---\n- debug: null\n  msg: START vyos_l3_interfaces merged integration tests on connection={{ ansible_connection }}\n\n- import_tasks: _remove_config.yaml\n\n- block:\n  - import_tasks: _populate.yaml\n  - name: Overrides all device configuration with provided configuration\n    register: result\n    vyos.vyos.vyos_l3_interfaces:\n      config:\n        - name: eth0\n          ipv4:\n            - address: dhcp\n        - name: eth1\n          ipv4:\n            - address: 192.0.2.15/24\n      state: overridden\n  - name: Assert that before dicts were correctly generated\n    assert:\n      that:\n        - \"{{ populate | symmetric_difference(result['before']) | length == 0 }}\"\n  - name: Assert that correct commands were generated\n    assert:\n      that:\n        - >-\n          overridden['commands']\n          | symmetric_difference(result['commands'])\n          | length\n          == 0\n  - name: Assert that after dicts were correctly generated\n    assert:\n      that:\n        - \"{{ overridden['after'] | symmetric_difference(result['after'])\n          | length == 0 }}\"\n  - name: Override device configuration with provided configuration (IDEMPOTENT)\n    register: result\n    vyos.vyos.vyos_l3_interfaces:\n      config:\n        - name: eth0\n          ipv4:\n            - address: dhcp\n        - name: eth1\n          ipv4:\n            - address: 192.0.2.15/24\n      state: overridden\n  - name: Assert that the previous task was idempotent\n    assert:\n      that:\n        - result is not changed\n  - name: Assert that before dicts were correctly generated\n    assert:\n      that:\n        - \"{{ overridden['after'] | symmetric_difference(result['before'])\n          | length == 0 }}\"\nalways:\n- import_tasks: _remove_config.yaml\n```\n\n----------------------------------------\n\nTITLE: Referencing Another C# Module Util with using Statement\nDESCRIPTION: This C# snippet illustrates how to reference another C# module utility by importing its namespace at the top of the script. 'Ansible.Become' refers to a shared utility whose classes or methods can now be accessed in the current util. Place this statement among other 'using' lines. The referenced util must be present and compiled alongside the current module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nusing Ansible.Become;\n```\n\n----------------------------------------\n\nTITLE: Copying, Tagging, and Executing a Script File on z/OS UNIX with ansible.builtin Modules (YAML)\nDESCRIPTION: This YAML example highlights a multi-step pattern for deploying and running a shell script on a z/OS UNIX node with Ansible. It first copies a local script using ansible.builtin.copy, then tags it as ISO8859-1 text using ansible.builtin.command, and finally executes it via another command module invocation. This approach ensures the script is properly tagged for the EBCDIC-vs-UTF-8 environment on z/OS. Dependencies include Ansible's copy and command modules and permissions to execute the script.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Copy local script file to remote node.\\n  ansible.builtin.copy:\\n    src: \"{{ playbook_dir }}/local/scripts/sample.sh\"\\n    dest: /u/ibmuser/scripts/\\n\\n- name: Tag remote script file.\\n  ansible.builtin.command: \"chtag -tc ISO8859-1 /u/ibmuser/scripts/sample.sh\"\\n\\n- name: Run script.\\n  ansible.builtin.command: \"/u/ibmuser/scripts/sample.sh\"\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Playbook in Interactive Step Mode (Shell)\nDESCRIPTION: This command runs an Ansible playbook (`playbook.yml`) in step mode. In this mode, Ansible pauses before each task, prompting the user whether to execute the task (y), skip it (n), or continue executing all remaining tasks without further prompts (c). This allows for interactive debugging and verification.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_startnstep.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-playbook playbook.yml --step\n```\n\n----------------------------------------\n\nTITLE: Verifying Configuration After Role Execution on Cisco IOS XE (Bash)\nDESCRIPTION: Shows the verification command `show run | i name` executed on the 'rtr1' Cisco IOS XE router after running the playbook that utilizes the 'system_demo' role. The output confirms that the hostname and DNS server configuration remains correctly set as applied by the role.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nrtr1#sh run | i name\nhostname rtr1\nip name-server 8.8.8.8 8.8.4.4\n```\n\n----------------------------------------\n\nTITLE: Targeting Specific Integration Tests in Shell\nDESCRIPTION: This command targets only the 'ping' integration test module. By specifying 'ping' as an argument, ansible-test runs tests only related to that functionality. Requires that the ping module is available and relevant credentials/configs are set up if needed. Output is limited to the selected test's execution details.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration ping\n```\n\n----------------------------------------\n\nTITLE: Including a Specific Section from a Documentation Fragment in YAML\nDESCRIPTION: This YAML snippet demonstrates how to include a specific section (named 'other') from a documentation fragment (`example_fragment`) within an Ansible module's documentation using the `extends_documentation_fragment` directive.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n.. code-block:: yaml+jinja\n\n    extends_documentation_fragment: example_fragment.other\n```\n\n----------------------------------------\n\nTITLE: Injecting Python Dependencies with pipx\nDESCRIPTION: Installs an additional Python dependency (e.g., 'argcomplete') into the isolated environment where Ansible was installed using pipx. This allows extending Ansible's functionality with libraries not included by default.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ pipx inject ansible argcomplete\n```\n\n----------------------------------------\n\nTITLE: Importing Module Utility with #Requires in PowerShell\nDESCRIPTION: This snippet demonstrates how to force the import of a PowerShell module utility into a module using the #Requires statement. The module 'Ansible.ModuleUtils.Legacy' provides general helper functions and is loaded from a specific path in the Ansible source tree. The only requirement is that the referenced module exists on the system or in the user's environment. Once imported, all functions within the utility become available to the calling module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n#Requires -Module Ansible.ModuleUtils.Legacy\n```\n\n----------------------------------------\n\nTITLE: Reading File as Bytes and Decoding to Text with Ansible Converter - Python\nDESCRIPTION: Demonstrates reading a file as bytes and converting it to a text string using Ansible's to_text utility. Requires ansible.module_utils.common.text.converters.to_text. Accepts a bytes object from file IO and decodes it to a str, handling UnicodeError where necessary. Expects filename-with-utf8-data.txt to exist and contain UTF-8 encoded text; outputs a Unicode string internally, or handles decode failure gracefully.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.common.text.converters import to_text\n\nwith open('filename-with-utf8-data.txt', 'rb') as my_file:\n    b_data = my_file.read()\n    try:\n        data = to_text(b_data, errors='surrogate_or_strict')\n    except UnicodeError:\n        # Handle the exception gracefully -- usually by displaying a good\n        # user-centric error message that can be traced back to this piece\n        # of code.\n        pass\n```\n\n----------------------------------------\n\nTITLE: Ansible Deprecation Warnings for Top-level Connection Arguments (Bash Output)\nDESCRIPTION: Gives example warnings emitted when deprecated top-level connection arguments (username, host, password) are used in network modules. No dependencies; triggers if deprecated module argument formatting is used. Input is a YAML playbook with top-level parameters, output is warning messages shown to the user.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.3.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[WARNING]: argument username has been deprecated and will be removed in a future version\\n[WARNING]: argument host has been deprecated and will be removed in a future version\\n[WARNING]: argument password has been deprecated and will be removed in a future version\n```\n\n----------------------------------------\n\nTITLE: Querying Container Images for ansible-test in Bash\nDESCRIPTION: This command lists available container images supported by ansible-test for integration tests. Running 'ansible-test integration --help' in bash displays the current list under a dedicated heading. No prerequisites beyond a working ansible-test install.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nansible-test integration --help\n```\n\n----------------------------------------\n\nTITLE: Illustrating Double-Interpolation Behavior (Pre-2.8) in YAML\nDESCRIPTION: This YAML snippet demonstrates the unexpected double-interpolation behavior present in Ansible 2.7 and earlier when using bare variables in conditionals. The `when: double_interpolated` condition evaluates the *value* of the variable whose *name* is stored in `double_interpolated` (i.e., it evaluates `bare_variable`, resulting in `False`). This behavior changes in 2.8+ when `conditional_bare_variables` is disabled.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  double_interpolated: 'bare_variable'\n  bare_variable: false\n\ntasks:\n  - debug:\n    when: double_interpolated\n```\n\n----------------------------------------\n\nTITLE: Parameter Exclusivity Change in `apt_key` Module\nDESCRIPTION: The `apt_key` module now enforces mutual exclusivity for the `file` parameter against `data`, `keyserver`, and `url`. These parameters cannot be used simultaneously with `file` in Ansible 4.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_9\n\nLANGUAGE: YAML\nCODE:\n```\n# Invalid combination in Ansible 4+:\n# - name: Add key (Invalid)\n#   ansible.builtin.apt_key:\n#     url: https://example.com/key.gpg\n#     file: /path/to/downloaded/key.gpg # Cannot use file with url\n\n# Valid usage:\n- name: Add key from URL\n  ansible.builtin.apt_key:\n    url: https://example.com/key.gpg\n    state: present\n\n- name: Add key from file\n  ansible.builtin.apt_key:\n    file: /path/to/existing/key.gpg\n    state: present\n```\n\n----------------------------------------\n\nTITLE: Patching Ansible Module Exit Handling with Exception Raising - Python\nDESCRIPTION: Defines a replacement for 'exit_json' that raises a custom exception instead of writing output, making it possible to capture and assert exit events in tests. Ensures the 'changed' field exists in the returned dictionary. This function is intended to be patched onto AnsibleModule instances within the test setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef exit_json(*args, **kwargs):\\n    if 'changed' not in kwargs:\\n        kwargs['changed'] = False\\n    raise AnsibleExitJson(kwargs)\n```\n\n----------------------------------------\n\nTITLE: Expression Syntax Error with Trailing Comma (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This demonstrates an invalid conditional, where a trailing comma after the expression causes a syntax error in recent Ansible-core versions. Previous versions could mask such errors, but 2.19 surfaces them immediately. Dependencies: Ansible running a playbook. Output: Syntax error; limitation: invalid syntax.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: 1 == 2,\n    #               ^ invalid comma\n```\n\n----------------------------------------\n\nTITLE: Using 'deprecate_value' Function in Ansible Python Modules/Plugins (Python)\nDESCRIPTION: Demonstrates how Ansible Python modules or plugins can use the `deprecate_value` function from `ansible.module_utils.datatag`. This function wraps a return value (e.g., 'blue') to mark it as deprecated, attaching metadata like a deprecation message and help text, which triggers a runtime warning upon access.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.datatag import deprecate_value\n\n...\n\nmodule.exit_json(\n    color_name=deprecate_value(\n        value=\"blue\",\n        msg=\"The `color_name` return value is deprecated.\",\n        help_text=\"Use `color_code` instead.\",\n    ),\n    color_code=\"#0000ff\",\n)\n```\n\n----------------------------------------\n\nTITLE: Running Python Module with Custom Python Path (Shell)\nDESCRIPTION: Displays the export of a PYTHONPATH environment variable to include collection paths, followed by direct execution of the module via `python -m`. Ensures Python can resolve additional dependencies or _module_utils_ used inside collections. Required when testing or integrating modules that utilize external code in module_utils.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nexport PYTHONPATH=PATH_TO_COLLECTIONS:$PYTHONPATH\npython -m ansible_collections.my_namespace.my_collection.plugins.modules.my_test /tmp/args.json\n```\n\n----------------------------------------\n\nTITLE: Persistent Connection Retry Timeout Expired Log Output - Plain Text\nDESCRIPTION: Provides an example log from Ansible where the retry window for establishing a persistent control socket has expired (persistent_connect_retry_timeout), indicating that multiple retry attempts to connect to the remote host have failed. Used to trigger troubleshooting of connectivity, host reachability, or retry settings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_31\n\nLANGUAGE: text\nCODE:\n```\n2017-04-04 12:19:35,708 p=18591 u=fred |  connect retry timeout expired, unable to connect to control socket\n```\n\n----------------------------------------\n\nTITLE: Stricter Validation for Configuration Setting Choices\nDESCRIPTION: The Ansible configuration system now strictly validates values against the defined `choices` for each setting. Previously ignored invalid values (like `0` for `ANSIBLE_COLLECTIONS_ON_ANSIBLE_VERSION_MISMATCH`) will now cause an error. Configurations must use valid choices (e.g., `ignore`, `warn`, `error`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n# Invalid setting (causes error in 2.11+):\n# export ANSIBLE_COLLECTIONS_ON_ANSIBLE_VERSION_MISMATCH=0\n\n# Valid settings:\nexport ANSIBLE_COLLECTIONS_ON_ANSIBLE_VERSION_MISMATCH=ignore\n# or\nexport ANSIBLE_COLLECTIONS_ON_ANSIBLE_VERSION_MISMATCH=warn\n# or\nexport ANSIBLE_COLLECTIONS_ON_ANSIBLE_VERSION_MISMATCH=error\n```\n\n----------------------------------------\n\nTITLE: Conditional Yielding a Mapping by Mistake (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This snippet gives a mapping (YAML dictionary) instead of a string or boolean in the conditional assertion, due to unquoted string with colon and space. Demonstrates that the new Ansible requires conditionals to be explicit strings or booleans. Needs Ansible and a task context with 'result.msg' available. Output: Type error if run as is.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_7\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that:\n         - result.msg == \"some_key: some_value\"\n    #                             ^^ colon+space == problem\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Module on Localhost with Custom Interpreter - Ansible CLI - Bash\nDESCRIPTION: This Bash command runs the Ansible 'ping' module against the control node itself using 'localhost' and specifies a custom Python interpreter. The '-e' argument passes an extra variable, ensuring the Python runtime path is chosen explicitly, which is necessary in environments where the default Python may not be suitable (e.g., virtualenvs or alternative Python installs).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/connection_details.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible localhost -m ping -e 'ansible_python_interpreter=\"/usr/bin/env python\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Importing Python 3 Semantics with __future__ - Python\nDESCRIPTION: This snippet demonstrates the use of the __future__ imports in Python to enable Python 3 behaviors (absolute imports, division, print_function) in Python 2 code. This boilerplate is intended to be included at the top of most Python files, immediately following any file-level comment headers. It ensures code portability between Python 2 and Python 3 by enforcing consistent import, division, and print semantics. No external dependencies are required; this feature is built into Python 2.6 and beyond. The snippet does not take parameters and does not produce an output; it simply impacts parsing and runtime behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/future-import-boilerplate.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import (absolute_import, division, print_function)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for Ansible Plugin Testing - Bash\nDESCRIPTION: Installs the required Python packages for running Ansible plugin sanity tests by referencing the requirements file from the Ansible test suite. Uses pip with --user to perform a user-level installation, but advises removing --user inside Python virtual environments. This ensures all dependencies are available for subsequent validation and testing commands.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_documentation.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install --user -r test/lib/ansible_test/_data/requirements/sanity.txt\n```\n\n----------------------------------------\n\nTITLE: Importing Public Certificate to TrustedPeople Store (PowerShell)\nDESCRIPTION: A PowerShell script to import a public certificate (`cert.pem`) into the `LocalMachine\\TrustedPeople` certificate store on the Windows host. This step ensures the host trusts the certificate for authentication purposes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_certificate.rst#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(\"cert.pem\")\n\n$store = Get-Item -LiteralPath Cert:\\LocalMachine\\TrustedPeople\n$store.Open('ReadWrite')\n$store.Add($cert)\n$store.Dispose()\n```\n\n----------------------------------------\n\nTITLE: Executing Ansible Task without Loading User Profile via Become Flags (YAML)\nDESCRIPTION: This Ansible task runs the `ansible.windows.win_whoami` (Note: original code uses `win_whomai`) module with privilege escalation (`become: true`). It explicitly sets `become_flags: logon_flags=` to override the default `with_profile` flag, thus preventing the Windows system from loading the become user's profile during execution. This might be required in specific scenarios or for performance reasons.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n- name: run a command and not load the user profile\n  ansible.windows.win_whomai:\n  become: true\n  become_flags: logon_flags=\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Deprecation in Collection meta/runtime.yml (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to configure the deprecation of a module named 'old_cloud' within an Ansible collection. It involves adding a 'deprecation' entry under 'plugin_routing' -> 'modules' in the collection's 'meta/runtime.yml' file, specifying the 'removal_version' and a 'warning_text' to guide users towards an alternative.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/module_lifecycle.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nplugin_routing:\n    modules:\n        old_cloud:\n            deprecation:\n                removal_version: 2.0.0\n                warning_text: Use foo.bar.new_cloud instead.\n```\n\n----------------------------------------\n\nTITLE: Providing a Stand-in Base Class When Import Fails - Python\nDESCRIPTION: This example provides a fallback definition for a required base class in case the import fails. The try/except block imports UsefulThing, and upon ImportError, defines a no-op placeholder class. This allows downstream code to define classes inheriting from UsefulThing regardless of its source, preventing breakage during documentation, introspection, or partial operation. Inputs: none. Outputs: Either the real or stand-in UsefulThing class.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from another_library import UsefulThing\nexcept ImportError:\n    class UsefulThing:\n        pass\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining WeOS 4 Connection Settings in Ansible Group Variables (YAML)\nDESCRIPTION: This YAML snippet shows an example configuration within a `group_vars/weos4.yml` file for connecting to WeOS 4 devices. It sets the connection type to `ansible.netcommon.network_cli`, specifies the network OS as `community.network.weos4`, defines the username, uses Ansible Vault for the password, and includes an optional SSH argument for connecting via a bastion host using `ProxyCommand`. The password and bastion host settings can be omitted if using SSH keys or direct access, respectively.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_weos4.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\nansible_network_os: community.network.weos4\nansible_user: myuser\nansible_password: !vault...\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Deleting an Ansible Role from Galaxy - Bash\nDESCRIPTION: Removes a role from Ansible Galaxy using the 'ansible-galaxy role delete' command. Requires authenticated API access via token. Expects GitHub user and repo name as parameters. The role is deleted only from Galaxy, not from the source repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy role delete github_user github_repo\n```\n\n----------------------------------------\n\nTITLE: Configuring Paramiko Connection for FreeBSD Hosts\nDESCRIPTION: This Ansible inventory snippet demonstrates how to set the connection type to 'paramiko' for a specific FreeBSD host ('myfreebsdhost'). This is recommended when using SSH password authentication with BSD hosts, as the default OpenSSH connection method via 'sshpass' may have issues with BSD login prompts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[freebsd]\nmyfreebsdhost ansible_connection=paramiko\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Inventory for Debugging Python Discovery\nDESCRIPTION: This INI snippet shows an example Ansible inventory file ('hosts'). It defines a group 'test' with several hosts and sets group variables, including connection settings, privilege escalation details, and the 'ansible_interpreter_python_fallback' list for Python discovery.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_9\n\nLANGUAGE: ini\nCODE:\n```\nshell> cat hosts\n[test]\ntest_11\ntest_12\ntest_13\n\n[test:vars]\nansible_connection=ssh\nansible_user=admin\nansible_become=true\nansible_become_user=root\nansible_become_method=sudo\nansible_interpreter_python_fallback=['/usr/local/bin/python', '/usr/local/bin/python3', '/usr/local/bin/python3.11']\nansible_perl_interpreter=/usr/local/bin/perl\n```\n\n----------------------------------------\n\nTITLE: Included File with Explicit Tag Inheritance - Ansible Playbook YAML\nDESCRIPTION: In this Ansible 2.5+ example, the included file explicitly applies the 'distro_include' tag to a block of tasks. This is required since, after the attribute inheritance fix in 2.5, tags from the including 'include_tasks' are not passed down. This pattern ensures all tasks in the block are associated with the desired tag for subsequent task selection or execution. Requires Ansible 2.5 or newer.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- block:\n    - debug:\n        msg: \"In included file\"\n\n    - apt:\n        name: nginx\n        state: latest\n  tags:\n    - distro_include\n```\n\n----------------------------------------\n\nTITLE: OpenBSD OS Fact Assignments in Ansible (Bash Output Example)\nDESCRIPTION: Shows the structure and content of 'ansible_distribution', 'ansible_distribution_release', and 'ansible_distribution_version' host facts collected by Ansible. Illustrates the format changes in variable assignment between versions 2.2 and 2.3. No dependencies exist since these are output facts; input is an OpenBSD host running under Ansible, and outputs are JSON-style host facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.3.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\\\"ansible_distribution\\\": \\\"OpenBSD\\\"\\n\\\"ansible_distribution_release\\\": \\\"6.0\\\",\\n\\\"ansible_distribution_version\\\": \\\"release\\\",\n```\n\nLANGUAGE: bash\nCODE:\n```\n\\\"ansible_distribution\\\": \\\"OpenBSD\\\",\\n\\\"ansible_distribution_release\\\": \\\"release\\\",\\n\\\"ansible_distribution_version\\\": \\\"6.0\\\",\n```\n\n----------------------------------------\n\nTITLE: Configuring Manual Kerberos KDCs and Domain Realms (INI)\nDESCRIPTION: This krb5.conf snippet configures Kerberos to disable DNS KDC lookup, explicitly lists available KDCs for a given realm, and maps DNS domains to Kerberos realms for ticket routing. Required parameters include default_realm, list of KDC hosts, and domain-to-realm associations. Use this configuration when you want precise control over KDC resolution for your environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\n[libdefaults]\n    default_realm = MY.DOMAIN.COM\n    dns_lookup_kdc = false\n\n[realms]\n    MY.DOMAIN.COM = {\n        kdc = domain-controller1.my.domain.com\n        kdc = domain-controller2.my.domain.com\n    }\n\n[domain_realm]\n    .my.domain.com = MY.DOMAIN.COM\n    my.domain.com = MY.DOMAIN.COM\n```\n\n----------------------------------------\n\nTITLE: Running Sanity Checks on Ansible Codebase (Shell)\nDESCRIPTION: This shell-session snippet runs static code analysis (sanity tests), including style checks and validation of module documentation, using ansible-test. Dependencies: An initialized Ansible development environment and ansible-test installed. Invoked command will check against coding standards and requirements, showing results in the console. Input is optional sub-tests; output is a terminal report of found issues.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-test sanity --test pep8\nansible-test sanity --test validate-modules\n```\n\n----------------------------------------\n\nTITLE: Replacing Syslog Facility Identifier via Module Replacer (Python Context)\nDESCRIPTION: Within modules processed by the Module Replacer, occurrences of the string `syslog.LOG_USER` are replaced with the syslog facility configured in ansible.cfg or inventory variables. In Ansiballz, the facility name is accessed via `AnsibleModule._syslog_facility`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsyslog.LOG_USER\n```\n\n----------------------------------------\n\nTITLE: Jinja Test Used as Filter (Deprecated) - Ansible Playbook YAML\nDESCRIPTION: This YAML snippet demonstrates deprecated usage of Jinja tests as filters in Ansible 2.4 and below. It uses 'result | failed' and 'not result | success' in when clauses. Such patterns are discouraged and will result in deprecation warnings in Ansible 2.5+, as filters and tests serve different roles. Input is a result dict; output is a Boolean condition. Scripted conversion is recommended for updating playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nwhen:\n    - result | failed\n    - not result | success\n```\n\n----------------------------------------\n\nTITLE: Displaying Command Timeout Error Log Output - Plain Text\nDESCRIPTION: This snippet shows an example log message generated when a persistent connection hits a command timeout (default 30 seconds) while running Ansible against a remote network device. It is used for identifying timeout conditions and troubleshooting process interruptions in playbook runs. No dependencies are needed; it is output from Ansible's own logging mechanism.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n2017-04-04 12:19:05,670 p=18591 u=fred |  command timeout triggered, timeout value is 30 secs\n```\n\n----------------------------------------\n\nTITLE: Cloning and Provisioning Multi-Host Windows Domain Lab with Shell Commands\nDESCRIPTION: This shell snippet enables provisioning of a complex Ansible testing environment, including a Windows Domain Controller and several child hosts, via git and Vagrant. Dependencies are git, Vagrant, and VirtualBox. The 'git clone' pulls the predefined configuration, 'cd vagrant' enters the lab directory, and 'vagrant up' creates and provisions all the virtual machines according to the provided inventory. Provisioning requires significant time and resources; rerunning 'vagrant provision' fixes failed Ansible steps. No direct input parameters are needed beyond verifying system prerequisites.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/jborean93/ansible-windows.git\\ncd vagrant\\nvagrant up\n```\n\n----------------------------------------\n\nTITLE: Using Generated Role and Tasks in a Playbook - Ansible - YAML\nDESCRIPTION: Shows how to use a generated Ansible role and resource modules directly in YAML playbooks. Includes role-based inclusion and direct invocation of the resource and facts modules, illustrating task registration and debugging. Suitable for local or CI use provided resources are built and available.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: myos101\n  gather_facts: False\n  roles:\n  - my_role\n\n- hosts: myos101\n  gather_facts: False\n  tasks:\n  - myos_interfaces:\n    register: result\n  - debug:\n      var: result\n  - myos_facts:\n  - debug:\n      var: ansible_network_resources\n```\n\n----------------------------------------\n\nTITLE: Importing Module Utilities via Module Replacer (Python)\nDESCRIPTION: In the Module Replacer framework for new-style Python modules, this import statement is replaced with the actual contents of the specified Python module utility file located in 'ansible/module_utils/'. This allows modules to reuse common code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.MOD_LIB_NAME import *\n```\n\n----------------------------------------\n\nTITLE: Direct Inheritance from Optional Imports in Base Classes - Python\nDESCRIPTION: This code demonstrates direct inheritance from a class in an optionally-imported library. It assumes a successful import and defines a subclass with no additional implementation. Input: none. Output: A new class inheriting from UsefulThing. Limitation: Will fail with ImportError if the library is not available, hence should only be used if the import was successful.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/import.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom another_library import UsefulThing\n\nclass CustomThing(UsefulThing):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Configuring SSH Password Mechanism via ansible.cfg (INI)\nDESCRIPTION: Sets the SSH connection plugin's password mechanism to use 'sshpass' instead of the default 'SSH_ASKPASS' within the ansible.cfg configuration file. This configuration needs to be placed under the [ssh_connection] section.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_19\n\nLANGUAGE: ini\nCODE:\n```\n[ssh_connection]\npassword_mechanism = sshpass\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: skipped\nDESCRIPTION: Shows the `skipped` boolean return value. This key indicates whether the task execution was skipped, typically due to a conditional (`when` statement) evaluating to false.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n\"skipped\": true\n```\n\n----------------------------------------\n\nTITLE: Setting SSH Password Mechanism via Ansible Variable (YAML)\nDESCRIPTION: Specifies the use of 'sshpass' for the SSH connection plugin by defining the 'ansible_ssh_password_mechanism' Ansible variable. This variable can be set in inventory, playbooks, or other variable sources.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\nansible_ssh_password_mechanism: sshpass\n```\n\n----------------------------------------\n\nTITLE: Illustrating Dictionary Interpretation Error in Ansible Conditionals\nDESCRIPTION: This Ansible playbook snippet demonstrates an error where an unquoted string containing a colon followed by a space (`some_key: some_value`) within a YAML list is interpreted as a dictionary (mapping) instead of a string comparison. Since dictionaries are non-boolean, this triggers an error ('Conditional expressions must be strings.') in Ansible 12.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_7\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that:\n     - result.msg == \"some_key: some_value\"\n#                             ^^ colon+space == problem\n```\n\n----------------------------------------\n\nTITLE: Defining Mock RDS Instance State for Testing - Python\nDESCRIPTION: Defines a helper function that returns a mock representation of AWS RDS instance states for use in unit tests. This function produces a dictionary consistent with the structure of AWS responses, simplifying the process of simulating complex instance states and transitions. Requires no external dependencies beyond the Python standard library; intended to be called with status and pending modification arguments, returning a minimal mock suitable for tests that check state-dependent logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_units_modules.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef simple_instance_list(status, pending):\\n    return {u'DBInstances': [{u'DBInstanceArn': 'arn:aws:rds:us-east-1:1234567890:db:fakedb',\\n                              u'DBInstanceStatus': status,\\n                              u'PendingModifiedValues': pending,\\n                              u'DBInstanceIdentifier': 'fakedb'}]}\n```\n\n----------------------------------------\n\nTITLE: Displaying Project Directory Structure with Playbook and Role (Bash)\nDESCRIPTION: Uses the `tree` command to show the current working directory's structure. It includes the main `playbook.yml` file at the root level and the 'system_demo' role directory, which contains the `tasks` and `vars` subdirectories, each with their respective `main.yml` files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/network_roles.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n[user@ansible ~]$ tree\n.\n├── playbook.yml\n└── system_demo\n    ├── tasks\n    │   └── main.yml\n    └── vars\n        └── main.yml\n```\n\n----------------------------------------\n\nTITLE: Executing a Command on ERIC_ECCLI Devices using Ansible (YAML)\nDESCRIPTION: This Ansible task demonstrates how to run the `show version` command on remote Extreme ERIC_ECCLI devices. It utilizes the `community.network.eric_eccli_command` module and includes a conditional (`when`) statement to ensure the task only executes on hosts where the `ansible_network_os` is set to `community.network.eric_eccli`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_eric_eccli.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: run show version on remote devices (eric_eccli)\n     community.network.eric_eccli_command:\n        commands: show version\n     when: ansible_network_os == 'community.network.eric_eccli'\n\n```\n\n----------------------------------------\n\nTITLE: Importing from Collection Plugin __init__.py in Python - python\nDESCRIPTION: This Python import illustrates how to correctly import classes or objects from the __init__.py file in a collection plugin directory. It is necessary to specify the full path including '__init__', even though __init__.py is normally implicit, to ensure Python correctly locates and loads the module from within the collection structure. This pattern depends on the Ansible collection being installed, and the import path matching the internal structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible_collections.namespace.collection_name.plugins.callback.__init__ import CustomBaseClass\n```\n\n----------------------------------------\n\nTITLE: Conditional Task Inclusion Based on Bare Variable in YAML\nDESCRIPTION: Example Ansible playbook tasks demonstrating conditional execution using `include_tasks` based on the boolean evaluation of a variable named `teardown`. This pattern is discussed in the context of behavioral changes in Ansible 2.8 regarding how bare string variables are treated in `when` conditions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntasks:\n  - include_tasks: teardown.yml\n    when: teardown\n\n  - include_tasks: provision.yml\n    when: not teardown\n```\n\n----------------------------------------\n\nTITLE: Inventory Cache Plugin `flush()` Behavior Change\nDESCRIPTION: In inventory plugins, `CachePluginAdjudicator.flush()` now delegates directly to the underlying cache plugin's `flush()` method, potentially clearing the entire cache backend, including facts if they share the same backend. Inventory plugins should use `delete()` for specific key removal. Users might need separate cache backends for inventory and facts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n# Inside an inventory plugin's clear_cache method\n# Old behavior might have selectively deleted keys.\n# New behavior:\n def clear_cache(self):\n     # This now calls the configured cache plugin's flush(),\n     # potentially clearing more than just inventory keys.\n     self.cache_manager.flush(self._cache_key)\n```\n\n----------------------------------------\n\nTITLE: Manifest Directives with Omitted Defaults in Galaxy.yml (YAML)\nDESCRIPTION: Provides an example galaxy.yml manifest where omit_default_directives: true disables built-in manifest includes, requiring explicit definition of each file pattern. This example includes only runtime meta, README, LICENSE, Python plugin code, and a small set of excludes. Inputs are detailed explicit directives; produces tarball with only listed files. Useful when fine-grained control over tarball contents is needed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  directives:\n    - include meta/runtime.yml\n    - include README.md LICENSE\n    - recursive-include plugins */**.py\n    - exclude galaxy.yml MANIFEST.json FILES.json <namespace>-<name>-*.tar.gz\n    - recursive-exclude tests/output **\n  omit_default_directives: true\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Builder Only with Pip - Bash\nDESCRIPTION: Installs only ansible-builder via pip3, useful for users who want to build Ansible Execution Environments without using ansible-navigator. Assumes Python 3 and pip3 are installed. Ensures the minimum required Ansible EE build tooling is present.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/setup_environment.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip3 install ansible-builder\n```\n\n----------------------------------------\n\nTITLE: Variable Reference Without Template for Expression (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: This is the correct pattern after disabling multi-pass templating: the variable is directly referenced in the expression without using Jinja delimiters. Suitable for Ansible-core 2.19 or above. Needs 'value' variable. Output: boolean assertion.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_10\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: 1 + value == 2\n      vars:\n        value: 1\n```\n\n----------------------------------------\n\nTITLE: Running a CLI Command on CloudEngine OS with Ansible (YAML)\nDESCRIPTION: This Ansible task executes a CLI command (\"display version\") on devices running CloudEngine OS using the community.network.ce_command module. The 'when' clause ensures that the task only runs if the managed host is explicitly identified as running the correct network OS. Requires previously defined host connection variables and the Ansible community.network collection. Expects a command string and returns device command output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve CE OS version\n  community.network.ce_command:\n    commands: display version\n  when: ansible_network_os == 'community.network.ce'\n```\n\n----------------------------------------\n\nTITLE: Invalid YAML: Partial Quoting\nDESCRIPTION: Shows an example of invalid YAML where only part of the scalar value is enclosed in quotes. The entire value must be quoted if quoting is necessary (e.g., due to starting with '{' or containing special characters).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nfoo: \"E:\\\\path\\\\\"rest\\\\of\\\\path\n```\n\n----------------------------------------\n\nTITLE: Importing Custom Cache Plugins with cache_loader (Python)\nDESCRIPTION: Illustrates loading a custom cache plugin through Ansible's cache_loader interface, enabling proper initialization and option management. Inputs are the plugin name ('custom_cache') and keyword arguments for configuration. This technique ensures compatibility and allows integration with inventory plugins. Requires proper setup of cache_kwargs and use of cache_loader.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_plugins.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.plugins.loader import cache_loader\n[...]\nplugin = cache_loader.get('custom_cache', **cache_kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing verify_file for Host List Strings in Python\nDESCRIPTION: This Python code provides an alternative implementation of the `verify_file` method for an Ansible inventory plugin designed to handle comma-separated host lists directly as the inventory source string, rather than a file path. It bypasses the base class check for file existence and instead verifies that the input string (`path`, treated as `host_list`) does not correspond to an existing file path and contains a comma, indicating it's likely a host list suitable for this plugin. Requires `os` and `ansible.module_utils.basic.to_bytes`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef verify_file(self, path):\n    ''' don't call base class as we don't expect a path, but a host list '''\n    host_list = path\n    valid = False\n    b_path = to_bytes(host_list, errors='surrogate_or_strict')\n    if not os.path.exists(b_path) and ',' in host_list:\n        # the path does NOT exist and there is a comma to indicate this is a 'host list'\n        valid = True\n    return valid\n```\n\n----------------------------------------\n\nTITLE: Initializing a New Ansible Collection and Listing Top-Level Directories in Bash\nDESCRIPTION: This snippet describes how to create a new Ansible collection named 'acme.webserver' using 'ansible-galaxy collection init', followed by listing its immediate subdirectories with a tree command. It demonstrates basic steps for setting up collection scaffolding. Requires ansible-galaxy and tree commands. Used when preparing to migrate roles and modules into a collection context.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-galaxy collection init acme.webserver\n- Collection acme.webserver was created successfully\n$ tree acme -d 1\nacme\n└── webserver\n\t ├── docs\n\t ├── plugins\n\t └── roles\n```\n\n----------------------------------------\n\nTITLE: Creating Base Collection Directory (Bash)\nDESCRIPTION: Creates the standard directory structure `~/ansible_collections/community` to house Ansible collections locally, preparing for cloning the `community.postgresql` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/ansible_collections/community\n```\n\n----------------------------------------\n\nTITLE: Example Playbook for Fact Gathering Tag Behavior Context\nDESCRIPTION: This YAML playbook structure is used to illustrate the context for the change in implicit fact gathering behavior in Ansible 2.8. In versions prior to 2.8, the implicit 'Gathering Facts' step would run even if `--tags nginx` was specified, ignoring the play-level `webserver` tag. In 2.8+, fact gathering inherits play tags.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Configure Webservers\n  hosts: webserver\n  tags:\n    - webserver\n  tasks:\n    - name: Install nginx\n      package:\n        name: nginx\n      tags:\n        - nginx\n```\n\n----------------------------------------\n\nTITLE: Implementing Python 2/3 Forward-Compatibility Boilerplate\nDESCRIPTION: Standard Python boilerplate using `__future__` imports (`absolute_import`, `division`, `print_function`) and `__metaclass__ = type` to ensure consistent behavior and new-style classes across Python 2 and Python 3 environments within Ansible code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n```\n\n----------------------------------------\n\nTITLE: Executing CLI Commands on VOSS using community.network.voss_command in YAML\nDESCRIPTION: Shows an example Ansible task that uses the `community.network.voss_command` module to execute the `show sys-info` command on Extreme VOSS devices. The task includes a conditional (`when`) clause to ensure it only runs on hosts where the `ansible_network_os` variable is set to `community.network.voss`. This demonstrates a basic interaction with VOSS devices via the CLI using Ansible.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_voss.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Retrieve VOSS info\n  community.network.voss_command:\n    commands: show sys-info\n  when: ansible_network_os == 'community.network.voss'\n```\n\n----------------------------------------\n\nTITLE: Outlining Ansible Collection Directory Structure - shell-session\nDESCRIPTION: This snippet presents a schematic directory tree for a standard Ansible collection, highlighting standard subfolders like docs, meta, plugins, roles, playbooks, and tests, as well as mandatory files such as galaxy.yml and README.md. It serves as a blueprint for organizing Ansible collection content, demonstrating where to place roles, modules, and other resources as per best practices. No execution or dependencies are provided, as this is for illustration only and requires manual directory/file creation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_0\n\nLANGUAGE: shell-session\nCODE:\n```\ncollection/\\n├── docs/\\n├── galaxy.yml\\n├── meta/\\n│   └── runtime.yml\\n├── plugins/\\n│   ├── modules/\\n│   │   └── module1.py\\n│   ├── inventory/\\n│   └── .../\\n├── README.md\\n├── roles/\\n│   ├── role1/\\n│   ├── role2/\\n│   └── .../\\n├── playbooks/\\n│   ├── files/\\n│   ├── vars/\\n│   ├── templates/\\n│   └── tasks/\\n└── tests/\n```\n\n----------------------------------------\n\nTITLE: Injecting argcomplete with pipx for Ansible - Shell\nDESCRIPTION: Installs the 'argcomplete' dependency into the Ansible pipx environment to enable shell completion for Ansible commands. This command should be run if Ansible was installed via pipx. Dependencies include pipx and Ansible already installed in a pipx environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_23\n\nLANGUAGE: console\nCODE:\n```\n$ pipx inject --include-apps ansible argcomplete\n```\n\n----------------------------------------\n\nTITLE: Deprecating Mode/Option Values in mysql_replication (Ansible)\nDESCRIPTION: Lists deprecated mode option values (`getslave`, `startslave`, `stopslave`, `resetslave`, `resetslaveall`) and the `master_use_gtid` option value `slave_pos` for the `mysql_replication` module (`community.mysql`). These will be removed in `community.mysql` 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_42\n\nLANGUAGE: ansible\nCODE:\n```\nmysql_replication\n```\n\nLANGUAGE: ansible\nCODE:\n```\ngetslave\n```\n\nLANGUAGE: ansible\nCODE:\n```\nstartslave\n```\n\nLANGUAGE: ansible\nCODE:\n```\nstopslave\n```\n\nLANGUAGE: ansible\nCODE:\n```\nresetslave\n```\n\nLANGUAGE: ansible\nCODE:\n```\nresetslaveall\n```\n\nLANGUAGE: ansible\nCODE:\n```\nmaster_use_gtid\n```\n\nLANGUAGE: ansible\nCODE:\n```\nslave_pos\n```\n\n----------------------------------------\n\nTITLE: Discouraged Use of Underscore Variable in Python Loop\nDESCRIPTION: This Python code snippet demonstrates the discouraged practice of using the underscore `_` as a loop variable within a `for` loop, specifically in a retry mechanism. This usage is avoided in Ansible to prevent potential conflicts with future internationalization where `_` might be reserved. The loop iterates `retries` times, calling `retry_thing()` until success.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-underscore-variable.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. code-block:: python\n\n    for _ in range(0, retries):\n        success = retry_thing()\n        if success:\n            break\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible for Python 3 using Pip (Shell)\nDESCRIPTION: Demonstrates how to install Ansible using the Python 3 version of pip (`pip3`). This method makes the default `/usr/bin/ansible` command run with Python 3. The second command verifies the Python version associated with the installed Ansible executable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/python_3_support.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ pip3 install ansible\n$ ansible --version | grep \"python version\"\n  python version = 3.10.5 (main, Jun 9 2022, 00:00:00) [GCC 12.1.1 20220507 (Red Hat 12.1.1-1)] (/usr/bin/python)\n```\n\n----------------------------------------\n\nTITLE: Deprecating hashi_vault VAULT_TOKEN_PATH Variable in community.hashi_vault\nDESCRIPTION: The `VAULT_TOKEN_PATH` environment variable used to set the `token_path` option for the `hashi_vault` lookup plugin is deprecated. It will be removed in community.hashi_vault version 2.0.0. Use `ANSIBLE_HASHI_VAULT_TOKEN_PATH` instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_24\n\nLANGUAGE: Environment Variable\nCODE:\n```\nVAULT_TOKEN_PATH\n```\n\n----------------------------------------\n\nTITLE: Defining Target Dependencies (YAML)\nDESCRIPTION: Specifies that the `abstract_service_info` test target depends on the `setup_abstract_service` target. This ensures the setup tasks run before the test tasks. This configuration is placed in the `meta/main.yml` file of the dependent target.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  - setup_abstract_service\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for a Specific Python Version in Ansible Collections\nDESCRIPTION: Executes all unit tests for an Ansible collection specifically for Python 3.6 using the `ansible-test units` command. It runs the tests within a default Docker container (`--docker default`), provides verbose output (`-v`), and targets Python 3.6 using the `--python 3.6` parameter.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_testing.rst#_snippet_2\n\nLANGUAGE: shell-session\nCODE:\n```\nansible-test units --docker default -v --python 3.6\n```\n\n----------------------------------------\n\nTITLE: Pattern Match Warning Output - Ansible (Text)\nDESCRIPTION: This text output shows a typical warning message when an Ansible pattern fails to match any hosts due to missing inventory definitions. This signals that the pattern or targeted host(s) are not present in the active inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_patterns.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n[WARNING]: No inventory was parsed, only implicit localhost is available\\n[WARNING]: Could not match supplied host pattern, ignoring: *.not_in_inventory.com\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Return Value: stdout_lines\nDESCRIPTION: Demonstrates the `stdout_lines` key, which always accompanies the `stdout` key. It presents the standard output as a list of strings, where each element corresponds to a line from the original `stdout`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/common_return_values.rst#_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n\"stdout_lines\": [\n\"foo!\"\n]\n```\n\n----------------------------------------\n\nTITLE: Verifying Ansible Installation Version using Bash\nDESCRIPTION: This command checks the installed version of Ansible. It's used as a prerequisite check to ensure Ansible version 2.10 or higher is installed before proceeding with the tutorial. The command outputs the Ansible version information to the standard output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible --version\n```\n\n----------------------------------------\n\nTITLE: Customizing Group Name Sanitization for Constructed Features - Python\nDESCRIPTION: This Python code segment demonstrates how to override the default group name sanitization behavior for constructed inventory features by assigning a custom static method ('custom_sanitizer') to 'self._sanitize_group_name'. The custom function uses 'to_safe_group_name' to transform group names, allowing users to adjust character replacement policies. The method is set during parsing, and requires importing the utility from Ansible's inventory group module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.inventory.group import to_safe_group_name\n\nclass InventoryModule(BaseInventoryPlugin, Constructable):\n\n    NAME = 'ns.coll.myplugin'\n\n    @staticmethod\n    def custom_sanitizer(name):\n        return to_safe_group_name(name, replacer='')\n\n    def parse(self, inventory, loader, path, cache=True):\n        super(InventoryModule, self).parse(inventory, loader, path)\n\n        self._sanitize_group_name = custom_sanitizer\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Managed Node Syslog Logging Control in Ansible\nDESCRIPTION: An Ansible configuration setting that, along with `syslog_facility`, controls whether Ansible output is logged to the syslog service on each managed node. Setting this influences the destination of logs for play execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/logging.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n`no_target_syslog`\n```\n\n----------------------------------------\n\nTITLE: Increasing Persistent Command Timeout via Shell - Shell\nDESCRIPTION: Exporting the 'ANSIBLE_PERSISTENT_COMMAND_TIMEOUT' environment variable in shell increases the allowed command duration before a timeout occurs. Set this variable prior to invoking Ansible to override the default command timeout. Only the shell and Ansible are required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\nexport ANSIBLE_PERSISTENT_COMMAND_TIMEOUT=60\n```\n\n----------------------------------------\n\nTITLE: Checking ansible-community Package Version - Shell\nDESCRIPTION: Displays the installed version of the 'ansible-community' package. This is useful for distinguishing between core and community package versions. Requires 'ansible-community' to be installed and on PATH. No input parameters. Outputs version text.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_22\n\nLANGUAGE: console\nCODE:\n```\n$ ansible-community --version\n```\n\n----------------------------------------\n\nTITLE: Allowing Blank Passwords for Become Accounts on Windows with Ansible - YAML\nDESCRIPTION: This snippet updates the Windows registry to disable the policy that limits blank password usage, thus enabling accounts without a password to leverage 'become' escalation in Ansible. It uses the 'ansible.windows.win_regedit' module to set 'LimitBlankPasswordUse' to 0 under the appropriate registry key. This task should be used only when intended and is recommended to be avoided in non-secure environments.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n- name: allow blank password on become\\n  ansible.windows.win_regedit:\\n    path: HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\n    name: LimitBlankPasswordUse\\n    data: 0\\n    type: dword\\n    state: present\n```\n\n----------------------------------------\n\nTITLE: Structuring the RETURN Block for Simple Values (Text/YAML)\nDESCRIPTION: This snippet demonstrates how to format the `RETURN` block in Ansible module documentation for simple, non-nested return values. It defines three return fields (`dest`, `src`, `md5sum`) with their descriptions, return conditions, types, and sample values. The code represents the YAML structure expected within the raw string literal assigned to the RETURN variable in the module's Python code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n.. code-block:: text\n\n    RETURN = r'''\n    dest:\n        description: Destination file/path.\n        returned: success\n        type: str\n        sample: /path/to/file.txt\n    src:\n        description: Source file used for the copy on the target machine.\n        returned: changed\n        type: str\n        sample: /home/httpd/.ansible/tmp/ansible-tmp-1423796390.97-147729857856000/source\n    md5sum:\n        description: MD5 checksum of the file after running copy.\n        returned: when supported\n        type: str\n        sample: 2a5aeecc61dc98c4d780b14b330e3282\n    '''\n```\n\n----------------------------------------\n\nTITLE: Loading Fixture Data for Mocked Device Output in Python\nDESCRIPTION: This Python method, `load_fixtures`, is designed to be used within a unit test class. It defines an inner function `load_from_file` which uses an assumed `load_fixture` helper function to read data from a specified file (e.g., 'eos_l2_interfaces_config.cfg'). This inner function is then assigned as the `side_effect` of a previously mocked method (`self.execute_show_command`), causing the mock to return the fixture data whenever it's called.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef load_fixtures(self, commands=None, transport='cli'):\n    def load_from_file(*args, **kwargs):\n        return load_fixture('eos_l2_interfaces_config.cfg')\n    self.execute_show_command.side_effect = load_from_file\n```\n\n----------------------------------------\n\nTITLE: Creating Base Directory for Ansible Collections using Bash\nDESCRIPTION: This Bash command creates the necessary parent directory structure within the user's home directory to house Ansible collections locally. The `-p` flag ensures that parent directories are created as needed and suppresses errors if the directory already exists. Replace `NAMESPACE` and `COLLECTION_NAME` with the actual namespace and name of the collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_test_pr_locally.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Verifying Python Executables and Links on FreeBSD\nDESCRIPTION: This snippet displays example output from 'ls -l /usr/local/bin/ | grep python' on FreeBSD. It shows the created Python executables and symbolic links in '/usr/local/bin', demonstrating how the meta ports link generic names like 'python' and 'python3' to the specific installed version (python3.11).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nshell> ls -l /usr/local/bin/ | grep python\nlrwxr-xr-x  1 root wheel       7 Nov  1 18:55 python -> python3\nlrwxr-xr-x  1 root wheel      14 Nov  1 18:55 python-config -> python3-config\nlrwxr-xr-x  1 root wheel      10 Oct 31 11:40 python3 -> python3.11\nlrwxr-xr-x  1 root wheel      17 Oct 31 11:40 python3-config -> python3.11-config\n-r-xr-xr-x  1 root wheel    4744 Oct 31 11:14 python3.11\n-r-xr-xr-x  1 root wheel    3113 Oct 31 11:14 python3.11-config\n```\n\n----------------------------------------\n\nTITLE: Adding and Editing Cobbler System/Profile Entries - Bash - Cobbler\nDESCRIPTION: This snippet shows CLI commands to add and edit Cobbler profiles and systems for integration with Ansible. It uses the 'cobbler' tool to define profiles, assign management classes, and set custom metadata. These commands should be run on a Cobbler server and require proper user permissions. Inputs are specific CLI options; outputs are modified records in Cobbler’s inventory, directly affecting host grouping and variable assignment in Ansible’s dynamic inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncobbler profile add --name=webserver --distro=CentOS6-x86_64\ncobbler profile edit --name=webserver --mgmt-classes=\"webserver\" --ksmeta=\"a=2 b=3\"\ncobbler system edit --name=foo --dns-name=\"foo.example.com\" --mgmt-classes=\"atlanta\" --ksmeta=\"c=4\"\ncobbler system edit --name=bar --dns-name=\"bar.example.com\" --mgmt-classes=\"atlanta\" --ksmeta=\"c=5\"\n```\n\n----------------------------------------\n\nTITLE: Behavior Change in java_keystore Module (Alias Change) (Ansible)\nDESCRIPTION: Details a behavior change in the `java_keystore` module (`community.general`). If the alias (name) parameter is changed for an existing keystore, the module now overwrites the keystore instead of failing. Users should ensure playbooks do not rely on the old failure behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_18\n\nLANGUAGE: ansible\nCODE:\n```\njava_keystore\n```\n\n----------------------------------------\n\nTITLE: Sample Collection Directory Tree Output - Ansible - Text\nDESCRIPTION: Shows a text-based tree of the file structure generated for a collection-based resource module build. Used for reference to verify scaffold correctness and expected file locations (docs, LICENSE, playbooks, plugins, roles, etc.), including nested python package paths and module locations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n├── docs\n├── LICENSE.txt\n├── playbooks\n├── plugins\n|   ├── action\n|   ├── filter\n|   ├── inventory\n|   ├── modules\n|   |   ├── __init__.py\n|   |   ├── myos_facts.py\n|   |   └──  myos_interfaces.py\n|   └──  module_utils\n|       ├── __init__.py\n|       └──  network\n|           ├── __init__.py\n|           └──  myos\n|               ├── argspec\n|               |   ├── facts\n|               |   |   ├── facts.py\n|               |   |   └──  __init__.py\n|               |   ├── __init__.py\n|               |   └──  interfaces\n|               |       ├── __init__.py\n|               |       └──  interfaces.py\n|               ├── config\n|               |   ├── __init__.py\n|               |   └──  interfaces\n|               |       ├── __init__.py\n|               |       └──  interfaces.py\n|               ├── facts\n|               |   ├── facts.py\n|               |   ├── __init__.py\n|               |   └──  interfaces\n|               |       ├── __init__.py\n|               |       └──  interfaces.py\n|               ├── __init__.py\n|               └──  utils\n|                   ├── __init__.py\n|                   └──  utils.py\n├── README.md\n└──  roles\n```\n\n----------------------------------------\n\nTITLE: Displaying Persistent Connection Idle Timeout Log Output - Plain Text\nDESCRIPTION: This code sample demonstrates the log output for a persistent connection idle timeout event in Ansible, where the session automatically disconnects after the configured inactive period. It is used for diagnosing session drops in persistent network device management. No external dependencies are required; standard Ansible output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/network_debug_troubleshooting.rst#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n2017-04-04 12:19:05,670 p=18591 u=fred |  persistent connection idle timeout triggered, timeout value is 30 secs\n```\n\n----------------------------------------\n\nTITLE: Installing Resource Module Builder Requirements - Bash\nDESCRIPTION: Illustrates installing the Python dependencies for the resource module builder using pip. Requires pip to be installed and assumes the current directory contains the cloned resource_module_builder. The requirements.txt file specifies all Python packages needed for running the builder Playbook and related scripts. Installs dependencies into the active Python environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Stricter Validation of `choices` in Plugins\nDESCRIPTION: Ansible 4 enforces validation of the `choices` attribute defined for options in custom plugins (like modules or inventory sources). If a plugin defines `choices` but the provided configuration or parameter value doesn't match one of the choices, an error will occur. Plugin developers must ensure their `choices` lists are accurate and complete.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n# Example in a custom module's argument_spec\nargument_spec = dict(\n    state=dict(type='str', choices=['present', 'absent', 'latest'], required=True),\n    # ... other options\n)\n\n# If a user provides state=enabled, Ansible 4 will raise an error\n# because 'enabled' is not in the defined choices.\n# Ensure the choices list accurately reflects all valid inputs.\n```\n\n----------------------------------------\n\nTITLE: Referencing Ansible.get_bin_path() Method\nDESCRIPTION: Stub documentation reference for the `get_bin_path()` method, likely associated with finding executable paths. Note: The class seems to be `Ansible`, which might be a typo or refer to a different context than `AnsibleModule`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_18\n\nLANGUAGE: rst\nCODE:\n```\n.. py:method:: Ansible.get_bin_path()\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Redirection with Deprecation in Collection meta/runtime.yml (YAML)\nDESCRIPTION: This YAML snippet illustrates how to both redirect an old module name ('old_cloud') to a new one ('foo.bar.new_cloud') and simultaneously deprecate the old name within an Ansible collection. It combines the 'redirect' and 'deprecation' entries within the 'plugin_routing' -> 'modules' section of 'meta/runtime.yml'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/module_lifecycle.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nplugin_routing:\n    modules:\n        old_cloud:\n            redirect: foo.bar.new_cloud\n            deprecation:\n                removal_version: 2.0.0\n                warning_text: Use foo.bar.new_cloud instead.\n```\n\n----------------------------------------\n\nTITLE: Creating a New Git Branch for Changes in Bash\nDESCRIPTION: Creates a new local Git branch named `name_of_my_branch` using `git checkout -b` and switches the working directory to this new branch. Development work should be done on this dedicated feature branch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ git checkout -b name_of_my_branch\n```\n\n----------------------------------------\n\nTITLE: Staging and Committing Changes in Git in Bash\nDESCRIPTION: Stages a modified file (`/path/to/changed/file`) for commit using `git add` and then commits the staged changes with a descriptive commit message using `git commit -m`. The message should follow conventions, typically mentioning the module fixed and a brief summary of the fix.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ git add /path/to/changed/file\n$ git commit -m \"module_name_you_fixed: fix crash when ...\"\n```\n\n----------------------------------------\n\nTITLE: Installing Full Ansible Package on Fedora Linux (Bash)\nDESCRIPTION: Installs the complete 'ansible' package, which includes ansible-core and a curated set of Ansible Collections, on Fedora Linux using the DNF package manager. Requires root privileges (sudo).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo dnf install ansible\n```\n\n----------------------------------------\n\nTITLE: Pushing Local Branch to Forked Repository (Origin) in Bash\nDESCRIPTION: Pushes the local feature branch (`name_of_my_branch`) and its committed changes to the remote repository named `origin` using `git push`. The `origin` remote typically points to the user's fork on GitHub.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ git push origin name_of_my_branch\n```\n\n----------------------------------------\n\nTITLE: Replacing Return Values in mysql_replication (Future) (Ansible)\nDESCRIPTION: Specifies the future return values `Is_Primary` and `Is_Replica` that will replace `Is_Master` and `Is_Slave` in the `mysql_replication` module (`community.mysql`) version 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_39\n\nLANGUAGE: ansible\nCODE:\n```\nIs_Primary\n```\n\nLANGUAGE: ansible\nCODE:\n```\nIs_Replica\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Tasks and Playbook Recap - Ansible CLI - Console\nDESCRIPTION: This snippet shows the actual console output generated when executing an Ansible playbook that runs three tasks—Gathering Facts, Ping, and Print message—across multiple hosts. It details success status and prints a custom message for each host, culminating in a recap summarizing the number of successful, changed, unreachable, failed, and skipped tasks per host. No external dependencies are required beyond Ansible itself, and the output is intended for direct user feedback and status reporting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/ansible_output/first_playbook_output.txt#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nPLAY [My first play] ****************************************************************************\n\nTASK [Gathering Facts] **************************************************************************\nok: [192.0.2.50]\nok: [192.0.2.51]\nok: [192.0.2.52]\n\nTASK [Ping my hosts] ****************************************************************************\nok: [192.0.2.50]\nok: [192.0.2.51]\nok: [192.0.2.52]\n\nTASK [Print message] ****************************************************************************\nok: [192.0.2.50] => {\n    \"msg\": \"Hello world\"\n}\nok: [192.0.2.51] => {\n    \"msg\": \"Hello world\"\n}\nok: [192.0.2.52] => {\n    \"msg\": \"Hello world\"\n}\n\nPLAY RECAP **************************************************************************************\n192.0.2.50: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n192.0.2.51: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n192.0.2.52: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n```\n\n----------------------------------------\n\nTITLE: Defining Seealso References in Ansible Documentation (YAML+Jinja)\nDESCRIPTION: This YAML snippet demonstrates the various valid formats for defining references within the `:seealso:` section of Ansible module or plugin documentation. It shows examples for referencing other modules (by FQCN, optionally with a description), plugins (specifying `plugin` and `plugin_type`), internal documentation anchors (`ref`), and external internet resources (`name`, `description`, `link`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_2\n\nLANGUAGE: yaml+jinja\nCODE:\n```\nseealso:\n\n# Reference by module name\n- module: cisco.aci.aci_tenant\n\n# Reference by module name, including description\n- module: cisco.aci.aci_tenant\n  description: ACI module to create tenants on a Cisco ACI fabric.\n\n# Reference by plugin name\n- plugin: ansible.builtin.file\n  plugin_type: lookup\n\n# Reference by plugin name, including description\n- plugin: ansible.builtin.file\n  plugin_type: lookup\n  description: You can use the ansible.builtin.file lookup to read files on the control node.\n\n# Reference by rST documentation anchor\n- ref: aci_guide\n  description: Detailed information on how to manage your ACI infrastructure using Ansible.\n\n# Reference by rST documentation anchor (with custom title)\n- ref: The official Ansible ACI guide <aci_guide>\n  description: Detailed information on how to manage your ACI infrastructure using Ansible.\n\n# Reference by Internet resource\n- name: APIC Management Information Model reference\n  description: Complete reference of the APIC object model.\n  link: https://developer.cisco.com/docs/apic-mim-ref/\n```\n\n----------------------------------------\n\nTITLE: Illustrating Jinja2 Filter Syntax in Ansible\nDESCRIPTION: This snippet demonstrates the standard Jinja2 syntax for applying a filter to a variable within Ansible. Filters are intended for data manipulation. The use of Ansible's built-in tests with this filter syntax is deprecated since version 2.5.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-tests-as-filters.rst#_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\nvariable | filter_name\n```\n\n----------------------------------------\n\nTITLE: Generating Changelogs for a Release with antsibull-changelog (Shell)\nDESCRIPTION: This command creates a consolidated changelog for an Ansible collection release by processing all changelog fragments using antsibull-changelog. It supports an optional --version argument for specifying the release version. The tool requires properly prepared changelog fragments and can use --reload-plugins to update its plugin cache if the collection version is unchanged.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_changelogs.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nantsibull-changelog release [--version version_number]\n```\n\n----------------------------------------\n\nTITLE: Defining Setup Tasks for Abstract Service (YAML)\nDESCRIPTION: Ansible tasks defined in `tests/integration/targets/setup_abstract_service/tasks/main.yml` for installing and starting a hypothetical `abstract_service`. It uses the `package` module for installation and the `systemd` module to ensure the service is started. This serves as a setup dependency for other tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Install abstract service\n  package:\n    name: abstract_service\n\n- name: Run the service\n  systemd:\n    name: abstract_service\n    state: started\n```\n\n----------------------------------------\n\nTITLE: Defining Action Groups in `meta/runtime.yml` (YAML)\nDESCRIPTION: Shows how to define `action_groups` in `meta/runtime.yml`. This allows grouping related action plugins and modules under custom names. Groups can include specific action/module names (as strings) and can also extend other groups (including those from different collections) using a special `metadata` dictionary with the `extend_group` key.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\naction_groups:\n  groupname:\n    # The special metadata dictionary. All action/module names should be strings.\n    - metadata:\n        extend_group:\n          - another.collection.groupname\n          - another_group\n    - my_action\n  another_group:\n    - my_module\n    - another.collection.another_module\n```\n\n----------------------------------------\n\nTITLE: Sample SyntaxError Due to Incorrect Encoding in Python - Text\nDESCRIPTION: Shows a typical error message produced by Python when the expected encoding is not correctly set, especially when processing pipelined input containing EBCDIC characters. The hex value (e.g., '\\x81') may vary by source. Useful for troubleshooting encoding issues during remote Ansible task execution. No dependencies, but relates to Python's encoding declaration requirements (PEP-0263). Input: erroneous input with EBCDIC bytes. Output: SyntaxError message.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nSyntaxError: Non-UTF-8 code starting with '\\\\x81' in file <stdin> on line 1, but no encoding declared; see https://peps.python.org/pep-0263/ for details\n```\n\n----------------------------------------\n\nTITLE: Sending Requests using HTTPAPI Plugin Wrappers - Ansible Python\nDESCRIPTION: Shows how to implement a send_request method within an httpapi plugin to prepare and send HTTP(S) requests using Ansible's connection.send(). It handles fixed headers, wraps the lower-level send() call, and demonstrates error catching and response handling. Dependencies include ansible.module_utils.six.moves.urllib.error.HTTPError and a separate handle_response function. Inputs are data, path, and method; output is a processed response suitable for module consumption.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.six.moves.urllib.error import HTTPError\\n\\ndef send_request(self, data, path, method='POST'):\\n    # Fixed headers for requests\\n    headers = {'Content-Type': 'application/json'}\\n    try:\\n        response, response_content = self.connection.send(path, data, method=method, headers=headers)\\n    except HTTPError as exc:\\n        return exc.code, exc.read()\\n\\n    # handle_response (defined separately) will take the format returned by the device\\n    # and transform it into something more suitable for use by modules.\\n    # This may be JSON text to Python dictionaries, for example.\\n    return handle_response(response_content)\\n\n```\n\n----------------------------------------\n\nTITLE: Viewing Built Ansible Collection Tarball (Shell)\nDESCRIPTION: This Shell output snippet illustrates the directory structure of an Ansible collection after the build process. It shows that the `ansible-galaxy collection build` command creates the collection tarball (e.g., `my_namespace-my_collection-1.0.0.tar.gz`) within the collection's root directory, alongside the source files like `galaxy.yml`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmy_collection/\n├── galaxy.yml\n├── ...\n├── my_namespace-my_collection-1.0.0.tar.gz\n└── ...\n```\n\n----------------------------------------\n\nTITLE: Importing PowerShell/C# Module Utils in Ansible 2.9 Collections\nDESCRIPTION: Illustrates the updated, more verbose syntax required in Ansible 2.9 for importing PowerShell or C# module utilities from a collection. This change standardizes imports and prevents potential naming conflicts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.9.rst#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n#AnsibleRequires -CSharpUtil ansible_collections.namespace_name.collection_name.plugins.module_utils.util_filename\n#AnsibleRequires -PowerShell ansible_collections.namespace_name.collection_name.plugins.module_utils.util_filename\n```\n\n----------------------------------------\n\nTITLE: Configuring Ansible Network CLI for SLX-OS (YAML)\nDESCRIPTION: This YAML snippet shows how to configure group_vars or host_vars for managing SLX-OS devices with Ansible via network_cli. Required dependencies are community.network collection and netcommon plugins. Core parameters include ansible_connection (set to ansible.netcommon.network_cli), ansible_network_os (platform identifier), ansible_user and ansible_password for authentication, and ansible_ssh_common_args for proxying through a bastion host (optional). Inputs are inventory variables. This configuration enables SSH-based automation for SLX-OS; remove ansible_password if using SSH keys and remove ansible_ssh_common_args if not using a bastion.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_slxos.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nansible_connection: ansible.netcommon.network_cli\\nansible_network_os: community.network.slxos\\nansible_user: myuser\\nansible_password: !vault...\\nansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\\n\n```\n\n----------------------------------------\n\nTITLE: Installing antsibull-changelog via pip (Shell)\nDESCRIPTION: This snippet demonstrates how to install the antsibull-changelog tool using pip, the Python package manager. The command fetches and installs the package from the Python Package Index, making the antsibull-changelog CLI available for use. Prerequisites include Python and pip installed on the system; no input parameters are required, and the tool will be accessible upon successful installation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_changelogs.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install antsibull-changelog\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible Package with pipx\nDESCRIPTION: Installs the full 'ansible' package, including its dependencies, using the pipx tool. This command ensures Ansible and its dependencies are isolated in their own virtual environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pipx install --include-deps ansible\n```\n\n----------------------------------------\n\nTITLE: Loading SELinux Module with semodule - Bash\nDESCRIPTION: This command loads the compiled SELinux module (ansible-podman.pp) into the system policies using the semodule tool. It must be executed with elevated privileges, as shown by the use of 'sudo'. Dependencies: an existing ansible-podman.pp file in the current directory, available semodule tool, and appropriate sudo permissions. The command expects no output on success and modifies system SELinux policies, so it should be run with care.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/tests/selinux/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo semodule -i ansible-podman.pp\n```\n\n----------------------------------------\n\nTITLE: Tagging and Publishing A New Release with Git and Zuul - Bash\nDESCRIPTION: Creates an annotated Git tag for a new release, then pushes it to upstream to trigger Zuul for publishing the collection to Ansible Galaxy. The comment should include the collection and version. Inputs: tag name/version and message; Output: published release artifact and published version. Requires Zuul integration and correct GitHub permissions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -n    # see current tags and their comments\\ngit tag -a NEW_VERSION -m \"comment here\"    # the comment can be, for example, \"community.foo: 2.0.0\"\\ngit push upstream NEW_VERSION\n```\n\n----------------------------------------\n\nTITLE: Illustrating Jinja Expression Syntax Error Detection in Ansible\nDESCRIPTION: This Ansible playbook snippet demonstrates how Ansible 12 detects syntax errors in Jinja expressions that might have been masked previously. The trailing comma after `1 == 2` causes a syntax error ('Syntax error in expression: chunk after expression') which is now reported.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_4\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n- assert:\n    that: 1 == 2,\n#               ^ invalid comma\n```\n\n----------------------------------------\n\nTITLE: Example Changelog Fragment for Minor Release - YAML Format\nDESCRIPTION: This snippet demonstrates an actual YAML changelog fragment for the community.mysql collection. It provides a detailed 'release_summary' in reStructuredText for documenting module and plugin changes. This example should be adjusted for the relevant collection and version when preparing a release.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nrelease_summary: |-\\n  This is the minor release of the ``community.mysql`` collection.\\n  This changelog contains all changes to the modules and plugins in this collection\\n  that have been made after the previous release.\n```\n\n----------------------------------------\n\nTITLE: Referencing ansible.module_utils.basic.AnsibleModule Class\nDESCRIPTION: Stub documentation reference for the `AnsibleModule` class located in `ansible.module_utils.basic`. This class provides basic utilities for Ansible modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_13\n\nLANGUAGE: rst\nCODE:\n```\n.. py:class:: ``ansible.module_utils.basic.AnsibleModule``\\n   :noindex:\n```\n\n----------------------------------------\n\nTITLE: Verifying Ansible Tool Installations - Bash\nDESCRIPTION: Runs version-check commands for ansible-navigator and ansible-builder to confirm successful installations. Produces version output for each tool if present in the user's environment. Useful for debugging and environment validation before proceeding with further setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/setup_environment.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-navigator --version\nansible-builder --version\n```\n\n----------------------------------------\n\nTITLE: Defining an Ansible Module Reject List in YAML\nDESCRIPTION: This YAML snippet demonstrates the structure of the `plugin_filters.yml` file used to reject specific Ansible modules. It includes a `filter_version` (currently \"1.0\") and a `module_rejectlist` containing the names of modules to prevent from loading, such as deprecated ones (`docker`) or disallowed alternatives (`easy_install`). This file is typically located at `/etc/ansible/plugin_filters.yml` but its path can be configured via the `PLUGIN_FILTERS_CFG` setting in `ansible.cfg`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/module_plugin_guide/plugin_filtering_config.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n---\nfilter_version: '1.0'\nmodule_rejectlist:\n  # Deprecated\n  - docker\n  # We only allow pip, not easy_install\n  - easy_install\n```\n\n----------------------------------------\n\nTITLE: Publishing a Collection Tarball to Galaxy via CLI (Bash)\nDESCRIPTION: Shows how to upload an Ansible collection tarball to Galaxy (or Automation Hub) using ansible-galaxy collection publish. Requires user to have a valid API token configured. Inputs are the path to the collection tarball and, optionally, flags such as --no-wait. Outputs a published collection, triggering the import process remotely.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_distributing.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nansible-galaxy collection publish path/to/my_namespace-my_collection-1.0.0.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Using Ansible-Test with Docker/Podman for Module Validation - Bash\nDESCRIPTION: Runs the 'ansible-test sanity' command with the '--docker' flag to utilize a container that comes with all necessary dependencies pre-installed. This method allows consistent validation across environments supporting Docker or Podman by testing the specified module ('mymodule') for documentation and argspec compliance in isolation from the host system.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_documentation.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nansible-test sanity --docker --test validate-modules mymodule\n```\n\n----------------------------------------\n\nTITLE: Checking Branch State After Rebase - Shell\nDESCRIPTION: Provides the output of \\\\\"git status\\\\\" after a successful rebase, indicating the local branch and origin have diverged and suggesting a merge (which should be ignored due to the rebased history). Useful for understanding expected post-rebase status, no extra setup required.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ git status\\nOn branch YOUR_BRANCH\\nYour branch and 'origin/YOUR_BRANCH' have diverged,\\nand have 4 and 1 different commits each, respectively.\\n  (use \\\"git pull\\\" to merge the remote branch into yours)\\nnothing to commit, working tree clean\n```\n\n----------------------------------------\n\nTITLE: Tagging and Publishing a New Release - Git Commands (Bash)\nDESCRIPTION: This Bash snippet provides Git commands to inspect tags, add an annotated tag with a version and comment, and push the tag to the upstream repository. This triggers the publication of the collection on Ansible Galaxy. The key parameters are the NEW_VERSION (which specifies the version tag) and the tag message (-m). Dependencies include a configured Git environment with push access to the upstream repository. The output is a new tag propagated to the central repository; appropriate for both manual and CI-assisted release workflows.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -n    # see current tags and their comments\\ngit tag -a NEW_VERSION -m \\\"comment here\\\"    # the comment can be, for example, \\\"community.foo: 2.1.1\\\"\\ngit push upstream NEW_VERSION\\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Collection module_utils in Ansible PowerShell Plugin - powershell\nDESCRIPTION: This PowerShell snippet demonstrates usage of custom module_utils provided by a collection in a PowerShell-based Ansible module. It begins with #AnsibleRequires directives to declare dependencies on the core Ansible.Basic utility and the specific collection module_utils, ensuring they are loaded by Ansible before running. The code creates a module specification, instantiates the AnsibleModule object in PowerShell, invokes a custom HyperV-related function, and signals module exit. Inputs include module parameters and outputs are module exit results; dependent on Ansible's PowerShell execution environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n#!powershell\\n#AnsibleRequires -CSharpUtil Ansible.Basic\\n#AnsibleRequires -PowerShell ansible_collections.community.test_collection.plugins.module_utils.hyperv\\n\\n$spec = @{\\n    name = @{ required = $true; type = \"str\" }\\n    state = @{ required = $true; choices = @(\"present\", \"absent\") }\\n}\\n$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec)\\n\\nInvoke-HyperVFunction -Name $module.Params.name\\n\\n$module.ExitJson()\n```\n\n----------------------------------------\n\nTITLE: Linking to Ansible Options/Return Values with :ansopt:/:ansretval: in reStructuredText (rst)\nDESCRIPTION: Demonstrates the `:ansopt:` and `:ansretval:` roles in reStructuredText for referencing specific options (e.g., `ansible.builtin.file#module:path`) and return values (e.g., `ansible.builtin.stat#module:stat.exists`) of Ansible modules/plugins. It also shows how to display assignments (e.g., `path=...`) and handle simple markup without links.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_11\n\nLANGUAGE: rst\nCODE:\n```\n  :ansopt:`ansible.builtin.file#module:path` references the ``path`` parameter of the\n  ``ansible.builtin.file`` module; :ansopt:`ansible.builtin.file#module:path=/root/.ssh/known_hosts`\n  shows the assignment ``path=/root/.ssh/known_hosts`` as a clickable link.\n\n  :ansretval:`ansible.builtin.stat#module:stat.exists` references the ``stat.exists`` return value\n  of the ``ansible.builtin.stat`` module. You can also use ``=`` as for option values:\n  :ansretval:`ansible.builtin.stat#module:stat.exists=true` shows ``stat.exists=true``.\n\n  :ansopt:`foo` and :ansopt:`foo=bar` use the same markup for an option and an option\n  assignment without a link; the same is true for return values: :ansretval:`foo` and\n  :ansretval:`foo=bar`.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Expected Output of Running the First Ansible Network Playbook using Shell\nDESCRIPTION: This block shows the sample console output generated when executing the 'first_playbook.yml' using the `ansible-playbook` command. It displays the play name, the status of each task ('ok' indicates success), and the output from the debug task, confirming the retrieved hostname and OS version. This helps users verify their playbook ran correctly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/getting_started/first_playbook.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ ansible-playbook -i vyos.example.net, -u ansible -k -e ansible_network_os=vyos.vyos.vyos first_playbook.yml\n\nPLAY [Network Getting Started First Playbook]\n***************************************************************************************************************************\n\nTASK [Get config for VyOS devices]\n***************************************************************************************************************************\nok: [vyos.example.net]\n\nTASK [Display the config]\n***************************************************************************************************************************\nok: [vyos.example.net] => {\n    \"msg\": \"The hostname is vyos and the OS is VyOS 1.1.8\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Changelog Management with antsibull-changelog (Shell)\nDESCRIPTION: This command initializes changelog management for an Ansible collection repository using antsibull-changelog. It prepares the specified collection directory for changelog tracking by creating the necessary configuration and fragment directories. The required parameter is the path to your collection (replace <path/to/your/collection> accordingly). Dependencies are antsibull-changelog installed and a valid collection directory structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_changelogs.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nantsibull-changelog init <path/to/your/collection>\n```\n\n----------------------------------------\n\nTITLE: Running PEP 8 Sanity Test with ansible-test (Shell)\nDESCRIPTION: This shell command executes the `pep8` sanity test using the `ansible-test` tool. It checks the specified file or directory paths for compliance with Python's PEP 8 style guidelines, utilizing `pycodestyle` internally. The command requires `ansible-test` to be available in the execution environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/pep8.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nansible-test sanity --test pep8 [file-or-directory-path-to-check] ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Tombstone in Collection meta/runtime.yml (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to tombstone a removed module ('old_cloud') in an Ansible collection's 'meta/runtime.yml' file. After deleting the actual module file, a 'tombstone' entry is added under 'plugin_routing' -> 'modules', providing a 'removal_version' (or 'removal_date') and 'warning_text' to inform users about the removal and suggest alternatives.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/module_lifecycle.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nplugin_routing:\n    modules:\n        old_cloud:\n            tombstone:\n                removal_version: 2.0.0\n                warning_text: Use foo.bar.new_cloud instead.\n```\n\n----------------------------------------\n\nTITLE: Listing CLI-Compatible CloudEngine OS Modules for Ansible (YAML)\nDESCRIPTION: This snippet enumerates all Ansible modules compatible with CloudEngine OS devices when using the ansible.netcommon.network_cli connection. It is a documentation/annotation list, not directly executable, and helps users identify valid modules for CLI-based management. Modules include ACL management, command execution, configuration, and advanced features.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ncommunity.network.ce_acl_interface\ncommunity.network.ce_command\ncommunity.network.ce_config\ncommunity.network.ce_evpn_bgp\ncommunity.network.ce_evpn_bgp_rr\ncommunity.network.ce_evpn_global\ncommunity.network.ce_facts\ncommunity.network.ce_mlag_interface\ncommunity.network.ce_mtu\ncommunity.network.ce_netstream_aging\ncommunity.network.ce_netstream_export\ncommunity.network.ce_netstream_global\ncommunity.network.ce_netstream_template\ncommunity.network.ce_ntp_auth\ncommunity.network.ce_rollback\ncommunity.network.ce_snmp_contact\ncommunity.network.ce_snmp_location\ncommunity.network.ce_snmp_traps\ncommunity.network.ce_startup\ncommunity.network.ce_stp\ncommunity.network.ce_vxlan_arp\ncommunity.network.ce_vxlan_gateway\ncommunity.network.ce_vxlan_global\n```\n\n----------------------------------------\n\nTITLE: Defining Utility Conversion Function in Python\nDESCRIPTION: Implements a Python function that converts inputs of certain types (decimal.Decimal to float, datetime.timedelta to string, enforces a specific exception for the value 42, and otherwise returns the input unmodified). No external dependencies are required for this code itself, but usage assumes the decimal and datetime modules are imported. Inputs are any type, and output varies by input type as described above. Exceptions will be raised for specifically defined input values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_unit_tests.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef convert_to_supported(val):\n    \"\"\"Convert unsupported types to appropriate.\"\"\"\n    if isinstance(val, decimal.Decimal):\n        return float(val)\n\n    if isinstance(val, datetime.timedelta):\n        return str(val)\n\n    if val == 42:\n        raise ValueError(\"This number is just too cool for us ;)\")\n\n    return val\n\n```\n\n----------------------------------------\n\nTITLE: Defining NETCONF Inventory Variables for CloudEngine OS in Ansible (INI)\nDESCRIPTION: This example shows the required inventory group variables to connect to CloudEngine OS devices via NETCONF (XML over SSH) in Ansible. It switches the connection type and may use a bastion host for indirect access. 'ansible_connection' is set to NETCONF, with user and authentication parameters. This snippet is intended to be placed in an inventory file and requires NETCONF to be enabled on the device.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_ce.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[ce:vars]\nansible_connection=ansible.netcommon.netconf\nansible_network_os=community.network.ce\nansible_user=myuser\nansible_password=!vault |\nansible_ssh_common_args='-o ProxyCommand=\"ssh -W %h:%p -q bastion01\"'\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote to Local Clone - Shell\nDESCRIPTION: Illustrates how to configure the upstream remote for a locally-forked clone of the community.general collection. This allows contributors to pull updates from the original repository even if they are working with their own fork. Presumes the contributor is inside the general directory and has already cloned their fork of the collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_contributing.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd ~/dev/ansible/collections/ansible_collections/community/general\ngit remote add upstream git@github.com:ansible-collections/community.general.git\n```\n\n----------------------------------------\n\nTITLE: Providing Breaking Changes in Changelog Fragments - YAML\nDESCRIPTION: This YAML code snippet demonstrates how to document breaking changes within a changelog fragment for an Ansible collection. It uses the 'breaking_changes' key followed by a list of significant changes that require user intervention, along with a description and a link to the related pull request for traceability. The fragment should be placed in the 'changelogs/fragments/' directory, and each entry clearly outlines a change that may necessitate altering user playbooks.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nbreaking_changes:\n  - ec2_instance - instance wait for state behavior no longer waits for the instance monitoring status to become OK when launching a new instance. If plays require the old behavior, the action will need to specify ``state: started`` (https://github.com/ansible-collections/amazon.aws/pull/481).\n\n```\n\n----------------------------------------\n\nTITLE: Executing NETVISOR Access List Task with Ansible - YAML\nDESCRIPTION: This snippet defines an Ansible task to create an access list on a Pluribus NETVISOR device using the 'community.network.pn_access_list' module. It sets parameters such as the access list name, scope, and desired state. The task is conditionally executed only if the target host's network OS matches NETVISOR. The necessary prerequisite is the 'community.network' collection. Input: parameters for the access list; Output: result registered to 'acc_list'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_netvisor.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Create access list\\n  community.network.pn_access_list:\\n    pn_name: \"foo\"\\n    pn_scope: \"local\"\\n    state: \"present\"\\n  register: acc_list\\n  when: ansible_network_os == 'community.network.netvisor'\\n\n```\n\n----------------------------------------\n\nTITLE: Example Bugfix Entry for apt_repository in Ansible Changelog (YAML)\nDESCRIPTION: Shows a specific example of a `bugfixes` entry in an Ansible changelog fragment for the `apt_repository` module. It follows the scoped entry format, detailing the fix related to an `IOError` during `cache.update()` and includes the relevant GitHub issue link.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nbugfixes:\n  - apt_repository - fix crash caused by ``cache.update()`` raising an ``IOError``\n    due to a timeout in ``apt update`` (https://github.com/ansible/ansible/issues/51995).\n```\n\n----------------------------------------\n\nTITLE: Using --force Flag for Collection Reinstallation (Ansible CLI)\nDESCRIPTION: Mentions the `--force` flag for `ansible-galaxy collection install`. It is noted that reinstalling a collection with new version requirements no longer necessitates using this flag.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_24\n\nLANGUAGE: plaintext\nCODE:\n```\n--force\n```\n\n----------------------------------------\n\nTITLE: Cloning Forked Ansible Collection Repository via HTTPS in Bash\nDESCRIPTION: Clones the user's forked collection repository from GitHub using the HTTPS protocol into the previously created local directory structure (`~/ansible_collections/NAMESPACE/COLLECTION_NAME`). Replace `YOURACC`, `COLLECTION_REPO`, `NAMESPACE`, and `COLLECTION_NAME` with actual values.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/YOURACC/COLLECTION_REPO.git ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Cloning the ansible-core Repository - Shell\nDESCRIPTION: Shows how to clone the ansible-core source repository using git for direct testing or development work. Requires git and access to the public ansible GitHub repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/ansible/ansible ~/dev/ansible\n```\n\n----------------------------------------\n\nTITLE: New Module fortios_configuration_fact in fortinet.fortios (Ansible)\nDESCRIPTION: Announces the addition of the new module `fortios_configuration_fact` to the `fortinet.fortios` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_47\n\nLANGUAGE: ansible\nCODE:\n```\nfortios_configuration_fact\n```\n\n----------------------------------------\n\nTITLE: Checking Git Remotes - Shell\nDESCRIPTION: Demonstrates how to list current Git remotes for a repository using the \\\\\"git remote -v\\\\\" command, which helps verify what origins and remote URLs the local repository recognizes. No dependencies other than a valid Git installation are required. Output includes each remote's fetch/push URLs, assisting in ensuring your remote configuration is correct before attempting a rebase.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ git remote -v\\norigin  git@github.com:YOUR_GITHUB_USERNAME/ansible.git (fetch)\\norigin  git@github.com:YOUR_GITHUB_USERNAME/ansible.git (push)\n```\n\n----------------------------------------\n\nTITLE: Listing Configured Git Remotes in Bash\nDESCRIPTION: Shows the URLs of the remote repositories configured for the local Git repository using `git remote -v`. Initially, after cloning a fork, only the `origin` remote (pointing to the user's fork) should be listed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ git remote -v\n```\n\n----------------------------------------\n\nTITLE: Recommended Shebangs for Executable Scripts (Shell/Make/Python)\nDESCRIPTION: Provides a list of standard shebang lines recommended for most executable files within the project. It includes options for `sh`, `bash` (with strict error handling and execution tracing flags), `make`, and using `/usr/bin/env` to locate `python` or `bash`. Note that Ansible modules require `#!/usr/bin/python` specifically and should not be executable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/shebang.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n#!/bin/sh\n```\n\nLANGUAGE: sh\nCODE:\n```\n#!/bin/bash -eu\n```\n\nLANGUAGE: sh\nCODE:\n```\n#!/bin/bash -eux\n```\n\nLANGUAGE: sh\nCODE:\n```\n#!/usr/bin/make\n```\n\nLANGUAGE: sh\nCODE:\n```\n#!/usr/bin/env python\n```\n\nLANGUAGE: sh\nCODE:\n```\n#!/usr/bin/env bash\n```\n\n----------------------------------------\n\nTITLE: Importing Network Module Utilities in Python (Ansible 2.5+)\nDESCRIPTION: Shows the updated Python import statement required in Ansible 2.5+ to access shared module utilities. Network utilities have been moved to the 'ansible.module_utils.network' namespace, with platform-specific utilities residing under subdirectories like 'vyos'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.network.vyos.vyos import get_config, load_config\n```\n\n----------------------------------------\n\nTITLE: Verifying All Remotes in Git - Shell\nDESCRIPTION: Uses the \\\\\"git remote -v\\\\\" command to list all configured remotes, verifying the addition of both \\\\\"origin\\\\\" and \\\\\"upstream\\\\\" remotes. No external dependencies beyond Git. Ensures that the remote pointing to the upstream repository was successfully added for later rebase operations.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ git remote -v\\norigin  git@github.com:YOUR_GITHUB_USERNAME/ansible.git (fetch)\\norigin  git@github.com:YOUR_GITHUB_USERNAME/ansible.git (push)\\nupstream        https://github.com/ansible/ansible.git (fetch)\\nupstream        https://github.com/ansible/ansible.git (push)\n```\n\n----------------------------------------\n\nTITLE: Disabling Python 3.8 Controller Warning via Environment Variable\nDESCRIPTION: Ansible Core 2.11 introduces a warning if the controller node is running Python < 3.8, as Python 3.8+ will be required in version 2.12. This warning can be suppressed by setting the environment variable `ANSIBLE_CONTROLLER_PYTHON_WARNING` to `False`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nexport ANSIBLE_CONTROLLER_PYTHON_WARNING=False\nansible-playbook my_playbook.yml\n```\n\n----------------------------------------\n\nTITLE: Using Explicit Newline Characters in Quoted Strings (YAML)\nDESCRIPTION: Shows an alternative way to achieve the same output as preserving newlines in folded blocks, by using explicit newline escape characters ('\\n') within a double-quoted string.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/YAMLSyntax.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nfold_same_newlines: \"a b\\nc d\\n  e\\nf\\n\"\n```\n\n----------------------------------------\n\nTITLE: Activating Global Python argcomplete for Shell Completion - Shell\nDESCRIPTION: Configures system-wide or user-specific bash shell completion for Python applications, including Ansible, using 'argcomplete'. Requires bash version 4.2 or newer, and 'argcomplete' must be installed. The '--user' flag writes completion to a user location. For custom locations or a global setup, use '--dest' or run with sudo.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_25\n\nLANGUAGE: console\nCODE:\n```\n$ activate-global-python-argcomplete --user\n```\n\n----------------------------------------\n\nTITLE: Updating Conditionals Using the `bool` Filter in YAML\nDESCRIPTION: Demonstrates how to update Ansible playbooks for compatibility with the changed behavior of bare variables in conditionals (starting in Ansible 2.8). It uses the `bool` filter to explicitly cast a string variable (`teardown: 'false'`) to a boolean value within the `when` condition, ensuring consistent evaluation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  teardown: 'false'\n\ntasks:\n  - include_tasks: teardown.yml\n    when: teardown | bool\n\n  - include_tasks: provision.yml\n    when: not teardown | bool\n```\n\n----------------------------------------\n\nTITLE: Example Playbook Triggering Debugger on Variable Error (YAML)\nDESCRIPTION: This playbook is designed to fail and trigger the debugger (if enabled with `on_failed`). It defines `var1` but attempts to use an undefined variable `wrong_var` in the `ansible.builtin.ping` task, causing a failure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: test\n  debugger: on_failed\n  gather_facts: false\n  vars:\n    var1: value1\n  tasks:\n    - name: Use a wrong variable\n      ansible.builtin.ping: data={{ wrong_var }}\n```\n\n----------------------------------------\n\nTITLE: Regenerate Role and Test Directory Before Running Tests - Bash\nDESCRIPTION: Script removes the prior generated test role and reruns the ansible-playbook resource module builder to produce a fresh scaffold under the test directory. Ensures up-to-date module structure before running tests. Key steps: rm -rf deletes the old directory, then ansible-playbook creates the new one based on given inputs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf rmb_tests/roles/my_role\nansible-playbook -e rm_dest=./rmb_tests/roles/my_role \\\n                 -e structure=role \\\n                 -e model=models/myos/interfaces/myos_interfaces.yml \\\n                 site.yml\n```\n\n----------------------------------------\n\nTITLE: Dynamically Including Tasks via include_tasks - Ansible Playbook YAML\nDESCRIPTION: This YAML snippet demonstrates how, in Ansible 2.4, the 'include_tasks' task includes another YAML file with an applied 'tags' attribute. The tag 'distro_include' is applied only to the include task, not to individual tasks within the included file itself. This is prior to 2.5 behavior, where attribute inheritance for dynamic includes remained incomplete. The 'ansible_distribution' variable is templated to select the file. No dependencies required besides Ansible 2.4+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- include_tasks: \"{{ ansible_distribution }}.yml\"\n  tags:\n    - distro_include\n```\n\n----------------------------------------\n\nTITLE: Checking and Switching Branches with Git - Bash\nDESCRIPTION: Checks the current Git status and switches to the main branch if necessary. Useful as an initial step before making further updates for a release. No extra dependencies beyond Git are required. Inputs: standard Git repository location; Output: repository checked out to 'main'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit status\\ngit checkout main     # if needed\n```\n\n----------------------------------------\n\nTITLE: Referencing ansible.module_utils.basic Module\nDESCRIPTION: Stub documentation reference for the `ansible.module_utils.basic` module, containing fundamental utilities and the `AnsibleModule` class.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_23\n\nLANGUAGE: rst\nCODE:\n```\n.. py:module:: ansible.module_utils.basic\\n  :noindex:\n```\n\n----------------------------------------\n\nTITLE: Changing ec2_vpc_igw_info convert_tags Default in community.aws\nDESCRIPTION: The default value for the `convert_tags` parameter in the `ec2_vpc_igw_info` module will change from `False` to `True` after 2022-06-22. This change aligns the module's tag handling behavior with the standard practice within the community.aws collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_9\n\nLANGUAGE: Ansible\nCODE:\n```\nec2_vpc_igw_info: convert_tags\n```\n\n----------------------------------------\n\nTITLE: Reporting Security Fixes in Changelog Fragments - YAML\nDESCRIPTION: This YAML snippet provides a template for reporting security fixes in a changelog fragment. The 'security_fixes' key is documented with items describing the vulnerability addressed and linking to the associated CVE or issue. Entries clarify the nature of the fix for transparency and auditing purposes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nsecurity_fixes:\n  - win_psexec - ensure password is masked in ``psexec_``command return result (https://github.com/ansible-collections/community.windows/issues/43).\n\n```\n\n----------------------------------------\n\nTITLE: Checking Git Branch Status - Shell\nDESCRIPTION: Shows how to use \\\\\"git status\\\\\" to confirm that the current branch is up-to-date with its remote counterpart, specifically \\\\\"origin/YOUR_BRANCH\\\\\". This step validates that your local environment is synchronized before attempting a rebase. No additional configuration is needed beyond having a cloned repository and available remotes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ git status\\nOn branch YOUR_BRANCH\\nYour branch is up-to-date with 'origin/YOUR_BRANCH'.\\nnothing to commit, working tree clean\n```\n\n----------------------------------------\n\nTITLE: Listing Minor Changes in Changelog Fragments - YAML\nDESCRIPTION: This YAML code example details the inclusion of minor enhancements or parameter additions in a changelog fragment. The 'minor_changes' key is supplied with a list of new features that do not break existing behavior, specifically noting any added parameters or capabilities. All such changes should be clearly described and optionally reference the related issue or pull request.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nminor_changes:\n  - nmcli - adds ``routes6`` and ``route_metric6`` parameters for supporting IPv6 routes (https://github.com/ansible-collections/community.general/issues/4059).\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Shell Executable Path for z/OS Nodes - INI\nDESCRIPTION: Sets the shell executable path on a z/OS UNIX managed node by defining the ansible_shell_executable variable in the inventory. This informs Ansible which shell to use for command execution on the remote z/OS host. The snippet uses INI configuration format and should be customized with your shell's location as needed. Requirements: a valid z/OS shell path (e.g., /bin/sh) and Ansible inventory management. Input: hostname and shell path. Output: shell selection for remote execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\nzos1 ansible_shell_executable=/bin/sh\n```\n\n----------------------------------------\n\nTITLE: Prefixing Byte String Variables with b_ in Python\nDESCRIPTION: Illustrates the Ansible convention of prefixing variables containing byte strings with `b_` for clarity. This example converts a text filename to bytes using `to_bytes` (assumed to be an Ansible utility) before opening the file, clearly marking the byte string variable.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_python_3.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfilename = u'/var/tmp/café.txt'\nb_filename = to_bytes(filename)\nwith open(b_filename) as f:\n    data = f.read()\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated Features in Ansible Changelog Fragments (YAML)\nDESCRIPTION: This YAML snippet demonstrates the `deprecated_features` section within an Ansible changelog fragment. This section lists features that are marked for removal in a future release. It should be written in the past tense and ideally provide an alternative. The example shows the deprecation of the `include` action, recommending `include_tasks`, `import_tasks`, or `import_playbook` as replacements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndeprecated_features:\n  - include action - is deprecated in favor of ``include_tasks``, ``import_tasks`` and ``import_playbook`` (https://github.com/ansible/ansible/pull/71262).\n```\n\n----------------------------------------\n\nTITLE: Cache Read/Update Pattern in Inventory parse Method - Python\nDESCRIPTION: This Python code implements a standard pattern in the 'parse' method for reading from and updating the inventory cache according to the user's caching preferences and current cache state. It conditionally reads from the cache or invokes the inventory parsing logic if a refresh is triggered or the cache is missing/expired, and updates the cache if needed. It also submits the final results to the inventory object, which may call methods like 'add_host' or 'set_variable'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_inventory.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef parse(self, inventory, loader, path, cache=True):\n    super(InventoryModule, self).parse(inventory, loader, path)\n\n    self.load_cache_plugin()\n    cache_key = self.get_cache_key(path)\n\n    # cache may be True or False at this point to indicate if the inventory is being refreshed\n    # get the user's cache option too to see if we should save the cache if it is changing\n    user_cache_setting = self.get_option('cache')\n\n    # read if the user has caching enabled and the cache isn't being refreshed\n    attempt_to_read_cache = user_cache_setting and cache\n    # update if the user has caching enabled and the cache is being refreshed; update this value to True if the cache has expired below\n    cache_needs_update = user_cache_setting and not cache\n\n    # attempt to read the cache if inventory isn't being refreshed and the user has caching enabled\n    if attempt_to_read_cache:\n        try:\n            results = self._cache[cache_key]\n        except KeyError:\n            # This occurs if the cache_key is not in the cache or if the cache_key expired, so the cache needs to be updated\n            cache_needs_update = True\n    if not attempt_to_read_cache or cache_needs_update:\n        # parse the provided inventory source\n        results = self.get_inventory()\n    if cache_needs_update:\n        self._cache[cache_key] = results\n\n    # submit the parsed data to the inventory object (add_host, set_variable, etc)\n    self.populate(results)\n\n```\n\n----------------------------------------\n\nTITLE: Removing an Installed Ansible Collection using Bash\nDESCRIPTION: These bash commands demonstrate how to remove the `community.general` Ansible collection by forcefully and recursively deleting its installation directory (`rm -rf`). The first command targets the default user installation path (`~/.ansible/collections/ansible_collections/community/general`), while the second targets a potential installation within a specific Python virtual environment (`./venv/lib/python3.9/site-packages/ansible_collections/community/general`). The correct path depends on where the collection was originally installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/collections_guide/collections_installing.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf ~/.ansible/collections/ansible_collections/community/general\nrm -rf ./venv/lib/python3.9/site-packages/ansible_collections/community/general\n```\n\n----------------------------------------\n\nTITLE: Cloning an Ansible Collection Repository - Shell\nDESCRIPTION: Demonstrates how to use git to clone a specific Ansible collection repository into the expected directory structure for testing. Requires git to be installed and assumes the destination directory structure follows /ansible_collections/{namespace}/{name}. Input: git repository URL; Output: Local copy of the collection codebase.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/ansible-collections/community.windows ~/dev/ansible_collections/community/windows\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_configure_idrac_timezone Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_configure_idrac_timezone` module is deprecated. Use the `idrac_timezone_ntp` module for configuring timezone and NTP settings on Dell EMC iDRAC.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_32\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_configure_idrac_timezone\n```\n\n----------------------------------------\n\nTITLE: Changing proxmox_kvm proxmox_default_behavior Default in community.general\nDESCRIPTION: The default value for the `proxmox_default_behavior` option in the `proxmox_kvm` module will change from `compatibility` to `no_defaults` in community.general version 4.0.0. Set this option explicitly to avoid deprecation warnings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_16\n\nLANGUAGE: Ansible\nCODE:\n```\nproxmox_kvm: proxmox_default_behavior\n```\n\n----------------------------------------\n\nTITLE: Cloning Ansible Collection Dependencies - Shell\nDESCRIPTION: Shows how to clone required dependency collections for your Ansible test setup using git. Dependencies must be cloned into the same collection root for ansible-test to find them. Requires git and appropriate collection URLs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/ansible-collections/ansible.windows ~/dev/ansible_collections/ansible/windows\n```\n\n----------------------------------------\n\nTITLE: Verifying Python Package Installation on FreeBSD\nDESCRIPTION: This snippet shows example output from the 'pkg info | grep python' command on a FreeBSD system. It lists the installed Python-related packages, including the meta ports and the specific Python 3.11 version, confirming a successful installation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nshell> pkg info | grep python\npython-3.11_3,2                \"meta-port\" for the default version of Python interpreter\npython3-3_4                    Meta-port for the Python interpreter 3.x\npython311-3.11.10              Interpreted object-oriented programming language\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for CLIConf and Terminal Plugins - Ansible Plugins Bash\nDESCRIPTION: Outlines possible directory arrangements for storing cliconf and terminal plugins used by the network_cli connection. Intended for system organization rather than execution, these directory names indicate which plugin types are supported and where Ansible will search for them. Each directory must house Python files implementing the respective interfaces; no script execution is intended here.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_plugins_network.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncliconf_plugins/\\nterminal_plugins/\\n\n```\n\n----------------------------------------\n\nTITLE: Importing Collection and Core Module Utilities in Ansible Python Plugin - python\nDESCRIPTION: This Python snippet demonstrates how to import both standard Ansible module utilities and custom collection module_utils for use in a collection's plugin or module. It outlines required dependencies such as ansible-core, the target collection installed in the correct location, and the referenced module_utils being present. The code shows key imports of types and classes for module processing and a realistic use-case where arguments are defined, the AnsibleModule instance is created, and then a custom QRadarRequest object is instantiated with the AnsibleModule context. Inputs are the module arguments and output is the invoked custom request logic.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import AnsibleModule\\nfrom ansible.module_utils.common.text.converters import to_text\\n\\nfrom ansible.module_utils.six.moves.urllib.parse import urlencode, quote_plus\\nfrom ansible.module_utils.six.moves.urllib.error import HTTPError\\nfrom ansible_collections.community.test_collection.plugins.module_utils.qradar import QRadarRequest\\n\\nargspec = dict(\\n    name=dict(required=True, type='str'),\\n    state=dict(choices=['present', 'absent'], required=True),\\n)\\n\\nmodule = AnsibleModule(\\n    argument_spec=argspec,\\n    supports_check_mode=True\\n)\\n\\nqradar_request = QRadarRequest(\\n    module,\\n    headers={\"Content-Type\": \"application/json\"},\\n    not_rest_data_keys=['state']\\n)\n```\n\n----------------------------------------\n\nTITLE: Deprecating django_manage liveserver Parameter in community.general\nDESCRIPTION: The `liveserver` parameter within the `django_manage` module is deprecated because it relates to an unmaintained third-party Django module. This parameter will be removed in community.general version 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_14\n\nLANGUAGE: Ansible\nCODE:\n```\ndjango_manage: liveserver\n```\n\n----------------------------------------\n\nTITLE: Required `pip uninstall` Before Upgrading Ansible Core via Pip\nDESCRIPTION: When upgrading from `ansible < 2.10` or `ansible-base` to `ansible-core` using pip, it is mandatory to first uninstall the older package (`ansible` or `ansible-base`) to prevent potential package conflicts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n# Before installing ansible-core, if ansible < 2.10 is installed:\npip uninstall ansible\n\n# Or, if ansible-base is installed:\npip uninstall ansible-base\n\n# Then install ansible-core:\npip install ansible-core\n```\n\n----------------------------------------\n\nTITLE: Replacing 'master' State Choice with 'primary' in mysql_replication (Future) (Ansible)\nDESCRIPTION: Indicates that the term `primary` will replace `master` in choices for the `state` option in the `mysql_replication` module (`community.mysql`) version 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_41\n\nLANGUAGE: ansible\nCODE:\n```\nprimary\n```\n\n----------------------------------------\n\nTITLE: Injecting SELinux Special Filesystems via Module Replacer (Internal)\nDESCRIPTION: This internal replacement pattern is substituted by the Module Replacer with a comma-separated string of filesystems requiring special SELinux handling. In Ansiballz, this information (as a Python list) is accessible via `AnsibleModule._selinux_special_fs`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n<<SELINUX_SPECIAL_FILESYSTEMS>>\n```\n\n----------------------------------------\n\nTITLE: Cloning Ansible Source Repository\nDESCRIPTION: Clones the 'ansible-core' source code repository from GitHub into the current directory and changes the current directory to the newly cloned 'ansible' folder. This is the first step for setting up a development environment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\n$ git clone https://github.com/ansible/ansible.git\n$ cd ./ansible\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Deprecated Top-Level Network Connection Arguments in Ansible YAML\nDESCRIPTION: This YAML snippet shows an Ansible task using the `ios_command` module. It illustrates the old method (pre-Ansible 2.4) of defining connection parameters like `host`, `username`, `password`, `authorize`, and `auth_pass` directly within the task definition. This approach is deprecated and was removed in Ansible 2.9; users should now use connection types like `network_cli` and define these properties in inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.9.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n- name: example of using top-level options for connection properties\n  ios_command:\n    commands: show version\n    host: \"{{ inventory_hostname }}\"\n    username: cisco\n    password: cisco\n    authorize: yes\n    auth_pass: cisco\n```\n\n----------------------------------------\n\nTITLE: Creating Test Target Directory Structure (Bash)\nDESCRIPTION: Creates the necessary directory structure for a test target named `abstract_service_info`, including subdirectories for tasks and metadata. This prepares the layout for the actual test plays and their dependencies.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p tests/integration/targets/abstract_service_info/tasks\nmkdir -p tests/integration/targets/abstract_service_info/meta\n```\n\n----------------------------------------\n\nTITLE: Ignored Inventory File Extensions - Text - Ansible Inventory Exclusions\nDESCRIPTION: This snippet lists file extensions that Ansible will ignore when scanning an inventory directory for hosts and groups. It can be used as a default or referenced in ansible.cfg or the ANSIBLE_INVENTORY_IGNORE environment variable. Inputs are file extensions to match; output is files that will be skipped during inventory loading.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n~, .orig, .bak, .ini, .cfg, .retry, .pyc, .pyo\n```\n\n----------------------------------------\n\nTITLE: Checking and Enabling Unconstrained Delegation for a Windows Host in PowerShell\nDESCRIPTION: This PowerShell script demonstrates how to check and enable unconstrained delegation for a specific Windows computer host (`WINHOST`) in Active Directory. The first command retrieves the computer object and displays the boolean value of its `TrustedForDelegation` property. The second command sets this property to `$true`, enabling unconstrained delegation. Requires the Active Directory module for PowerShell.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_13\n\nLANGUAGE: powershell\nCODE:\n```\n# Check if the server allows unconstrained delegation\n(Get-ADComputer -Identity WINHOST -Properties TrustedForDelegation).TrustedForDelegation\n\n# Enable unconstrained delegation\nSet-ADComputer -Identity WINHOST -TrustedForDelegation $true\n```\n\n----------------------------------------\n\nTITLE: Sample Role Directory Tree Output - Ansible - Text\nDESCRIPTION: Describes the generated file and directory structure for a role-based scaffold with detailed nested paths for libraries, module_utils, network platform code, and resources. Useful for confirming output of the module builder and for orienting development or usage.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/developing_resource_modules_network.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nroles\n└── my_role\n    ├── library\n    │   ├── __init__.py\n    │   ├── myos_facts.py\n    │   └── myos_interfaces.py\n    ├── LICENSE.txt\n    ├── module_utils\n    │   ├── __init__.py\n    │   └── network\n    │       ├── __init__.py\n    │       └── myos\n    │           ├── argspec\n    │           │   ├── facts\n    │           │   │   ├── facts.py\n    │           │   │   └── __init__.py\n    │           │   ├── __init__.py\n    │           │   └── interfaces\n    │           │       ├── __init__.py\n    │           │       └── interfaces.py\n    │           ├── config\n    │           │   ├── __init__.py\n    │           │   └── interfaces\n    │           │       ├── __init__.py\n    │           │       └── interfaces.py\n    │           ├── facts\n    │           │   ├── facts.py\n    │           │   ├── __init__.py\n    │           │   └── interfaces\n    │           │       ├── __init__.py\n    │           │       └── interfaces.py\n    │           ├── __init__.py\n    │           └── utils\n    │               ├── __init__.py\n    │               └── utils.py\n    └── README.md\n```\n\n----------------------------------------\n\nTITLE: Adding REST Support to na_ontap_autosupport Module (Ansible)\nDESCRIPTION: Notes that REST support has been added to the `na_ontap_autosupport` module within the `netapp.ontap` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_51\n\nLANGUAGE: ansible\nCODE:\n```\nna_ontap_autosupport\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for Python Encoding in Ansible Tasks - YAML\nDESCRIPTION: Defines the PYTHONSTDINENCODING environment variable within an Ansible YAML configuration to ensure correct character encoding when pipelining is enabled. This variable instructs Python to treat stdin as using the 'cp1047' (EBCDIC) encoding, which is crucial for z/OS UNIX nodes to prevent encoding-related errors. Input: environment key and 'cp1047' value. Output: sets appropriate encoding for remote tasks. Requirements: Ansible playbooks or tasks targeting z/OS UNIX.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nPYTHONSTDINENCODING: \"cp1047\"\n```\n\n----------------------------------------\n\nTITLE: Example: Building a Specific reStructuredText Page with Make in Bash\nDESCRIPTION: Provides a specific example of using `make htmlsingle` to build the `community/documentation_contributions.rst` file. Demonstrates the required path format relative to `docs/docsite/rst/`. Should be run from the `docs/docsite` directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake htmlsingle rst=community/documentation_contributions.rst\n```\n\n----------------------------------------\n\nTITLE: Extracting Nested Data with Python Loops\nDESCRIPTION: This Python code snippet demonstrates iterating through a list (`chains`) and using its elements as keys to access a dictionary (`chains_config`). It then iterates through a nested list (`configs`) within the dictionary and prints the value of the 'type' key for each nested dictionary. This serves as a reference for the equivalent Ansible Jinja2 implementation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/complex_data_manipulation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nchains = [1, 2]\nfor chain in chains:\n    for config in chains_config[chain]['configs']:\n        print(config['type'])\n```\n\n----------------------------------------\n\nTITLE: Adding, Committing, and Pushing Changelog Fragment in Bash\nDESCRIPTION: Stages the newly created changelog fragment file (e.g., `changelogs/fragments/myfragment.yml`) using `git add`, commits it with a standard message (`Add changelog fragment`), and pushes the commit containing the fragment to the `origin` remote on the current feature branch (`name_of_my_branch`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n$ git add changelogs/fragments/myfragment.yml\n$ git commit -m \"Add changelog fragment\"\n$ git push origin name_of_my_branch\n```\n\n----------------------------------------\n\nTITLE: Implementing Metaclass Boilerplate with Future Imports in Python\nDESCRIPTION: This example combines standard `__future__` imports for Python 3 compatibility (`absolute_import`, `division`, `print_function`) with the `__metaclass__ = type` boilerplate. It defines a simple class `Foo` which, due to the preceding boilerplate, is guaranteed to be a new-style class even when run with Python 2.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/metaclass-boilerplate.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nclass Foo:\n    # This is a new-style class even on Python 2 because of the __metaclass__\n    pass\n```\n\n----------------------------------------\n\nTITLE: Deprecating hashi_vault VAULT_TOKEN_FILE Variable in community.hashi_vault\nDESCRIPTION: The `VAULT_TOKEN_FILE` environment variable used to set the `token_file` option for the `hashi_vault` lookup plugin is deprecated. It will be removed in community.hashi_vault version 2.0.0. Use `ANSIBLE_HASHI_VAULT_TOKEN_FILE` instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_23\n\nLANGUAGE: Environment Variable\nCODE:\n```\nVAULT_TOKEN_FILE\n```\n\n----------------------------------------\n\nTITLE: Ansible Vault Encrypted File Header Format - Example (Text)\nDESCRIPTION: Shows the standard header of a file encrypted with Ansible Vault using format version 1.1 and AES256. The header specifies the file is vault-protected, format version, and encryption algorithm. Input: N/A; Output: File header as appears in encrypted files. Header is terminated by newline.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/vault_guide/vault_using_encrypted_content.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n$ANSIBLE_VAULT;1.1;AES256\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Imports in Ansible Python Code - Python\nDESCRIPTION: Demonstrates the problematic use of wildcard (import *) statements in Python, as seen in Ansible modules. The code relies on importing all symbols from a module, which can lead to namespace pollution and debugging difficulties. No specific dependencies beyond the referenced Ansible module_utils are required, but key input is the assumption of imported symbols such as string_types and AnsibleModule being available in the scope. This style is discouraged for maintainability and static analysis reasons.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-wildcard-import.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.six import *\nif isinstance(variable, string_types):\n    do_something(variable)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import *\nmodule = AnsibleModule()\n```\n\n----------------------------------------\n\nTITLE: Consuming a Shared Module Util Argument Spec in a PowerShell Module\nDESCRIPTION: This PowerShell snippet provides an example of how an Ansible module consumes a shared argument specification by importing a module util with '#AnsibleRequires'. The spec from 'Get-MyNamespaceMyCollectionServiceAuthSpec' is merged into the module's own argument spec when creating the module object via 'Ansible.Basic.AnsibleModule'. The import statement supports relative util names, and the shared options can then be accessed via the AnsibleModule object.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_general_windows.rst#_snippet_12\n\nLANGUAGE: powershell\nCODE:\n```\n#!powershell\n\n# Include the module util ServiceAuth.psm1 from the my_namespace.my_collection collection\n#AnsibleRequires -PowerShell ansible_collections.my_namespace.my_collection.plugins.module_utils.ServiceAuth\n\n# Create the module spec like normal\n$spec = @{\n    options = @{\n        resource_id = @{ type = 'str'; required = $true }\n        state = @{ type = 'str'; choices = 'absent', 'present' }\n    }\n}\n\n# Create the module from the module spec but also include the util spec to merge into our own.\n$module = [Ansible.Basic.AnsibleModule]::Create($args, $spec, @(Get-MyNamespaceMyCollectionServiceAuthSpec))\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_export_lc_logs Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_export_lc_logs` module is deprecated. Exporting logs from the Dell EMC Lifecycle Controller should now be done using the `idrac_lifecycle_controller_logs` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_35\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_export_lc_logs\n```\n\n----------------------------------------\n\nTITLE: Configuring BOTMETA.yml for Ansible Collection Migration (YAML)\nDESCRIPTION: This YAML snippet shows how to configure the `.github/BOTMETA.yml` file in the source (old) collection repository to indicate that specific modules, plugins, and documentation fragments have been moved to a new collection. The `migrated_to` key is added for each migrated file path, specifying the target collection's FQCN (e.g., `community.grafana`). This configuration enables `ansibullbot` to redirect issues/PRs and the documentation build process to redirect users to the new location.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_migrating.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n$modules/monitoring/grafana/grafana_plugin.py:\n    migrated_to: community.grafana\n$modules/monitoring/grafana/grafana_dashboard.py:\n    migrated_to: community.grafana\n$modules/monitoring/grafana/grafana_datasource.py:\n    migrated_to: community.grafana\n$plugins/callback/grafana_annotations.py:\n    maintainers: $team_grafana\n    labels: monitoring grafana\n    migrated_to: community.grafana\n$plugins/doc_fragments/grafana.py:\n    maintainers: $team_grafana\n    labels: monitoring grafana\n    migrated_to: community.grafana\n```\n\n----------------------------------------\n\nTITLE: Erroneous Quoted Expression in Conditional (Ansible Playbook, YAML+Jinja)\nDESCRIPTION: Here, part of the conditional is incorrectly quoted, making the right side a literal string. This will always be 'truthy' regardless of logic, which previous Ansible versions allowed. Deprecated in 2.19, this shows unintended logic always passing the assertion. Ansible with variable 'inventory_hostname' is required. Output: Assertion (incorrectly always True). Limitation: Error-prone expression structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_core_2.19.rst#_snippet_2\n\nLANGUAGE: yaml+jinja\nCODE:\n```\n    - assert:\n        that: inventory_hostname is defined and 'inventory_hostname | length > 0'\n```\n\n----------------------------------------\n\nTITLE: Linting and Formatting Python Scripts using Nox (Bash)\nDESCRIPTION: This command runs the `lint` nox session. It executes various linters (including `actionlint`), type checkers, and formatters against the Python scripts present in the repository to enforce code style and quality. Requires `podman` or `docker` for `actionlint`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnox -s lint\n```\n\n----------------------------------------\n\nTITLE: New Module fortios_json_generic in fortinet.fortios (Ansible)\nDESCRIPTION: Announces the addition of the new module `fortios_json_generic` to the `fortinet.fortios` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_48\n\nLANGUAGE: ansible\nCODE:\n```\nfortios_json_generic\n```\n\n----------------------------------------\n\nTITLE: Running POSIX Integration Tests in Ubuntu Container via ansible-test in Shell\nDESCRIPTION: This command runs all integration tests for POSIX platforms using ansible-test with the shippable/ target in a Ubuntu 18.04 Docker container. The '--docker' flag runs tests in an isolated, reproducible container environment. Prerequisites are similar to other ansible-test runs with container support.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_integration.rst#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration shippable/ --docker ubuntu1804\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_configure_idrac_users Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_configure_idrac_users` module is deprecated. User management for Dell EMC iDRAC should now be performed using the `idrac_user` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_33\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_configure_idrac_users\n```\n\n----------------------------------------\n\nTITLE: Checking RST Syntax Errors using Nox (Bash)\nDESCRIPTION: This command executes the `rstcheck` tool within the `checkers` nox session. It is used to scan the reStructuredText source files for syntax errors, helping to ensure the documentation source is valid.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnox -s \"checkers(rstcheck)\"\n```\n\n----------------------------------------\n\nTITLE: Travis CI Notification Webhook Configuration - Text\nDESCRIPTION: Snippet from a .travis.yml configuration file instructing Travis to send build notifications to the Ansible Galaxy API endpoint. The 'notifications' section specifies a webhook URL. Required so Galaxy is notified on every Travis build completion.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nnotifications:\n    webhooks: https://galaxy.ansible.com/api/v1/notifications/\n```\n\n----------------------------------------\n\nTITLE: Verifying Ansible Installation Version - Shell\nDESCRIPTION: Checks the installed version of Ansible to confirm installation success. Running this command prints the ansible-core package version to the terminal. Requires ansible to be installed and on the system PATH. No input parameters required. Output is version text.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_21\n\nLANGUAGE: console\nCODE:\n```\n$ ansible --version\n```\n\n----------------------------------------\n\nTITLE: Move Filter Plugins to Collection Plugins Directory (Bash CLI)\nDESCRIPTION: Bash command to transfer filter_plugins from an individual role to the collection's plugin filter directory. Assumes both paths exist and are writable. Ensures proper plugin organization and discoverability in the refactored collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ mv -r mynamespace/mycollection/roles/my_role/filter_plugins/* mynamespace/mycollection/plugins/filter/\\n\n```\n\n----------------------------------------\n\nTITLE: Deprecating hashi_vault VAULT_AUTH_METHOD Variable in community.hashi_vault\nDESCRIPTION: The `VAULT_AUTH_METHOD` environment variable used to set the `auth_method` option for the `hashi_vault` lookup plugin is deprecated. It will be removed in community.hashi_vault version 2.0.0. Use `ANSIBLE_HASHI_VAULT_AUTH_METHOD` instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_20\n\nLANGUAGE: Environment Variable\nCODE:\n```\nVAULT_AUTH_METHOD\n```\n\n----------------------------------------\n\nTITLE: Building RST Files Directly with sphinx-build (Bash)\nDESCRIPTION: This command shows the general syntax for using the `sphinx-build` utility directly to build specific reStructuredText (rST) files. It allows for more granular control and provides detailed syntax feedback, although it might produce misleading 'undefined label' warnings when building single pages due to missing internal links.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsphinx-build [options] sourcedir outdir [filenames...]\n```\n\n----------------------------------------\n\nTITLE: Example Ansible Collection Sanity Test Skip Entries (Text)\nDESCRIPTION: Illustrates how to completely skip a sanity test for specific files within an Ansible collection using the `!skip` directive in the `tests/sanity/ignore-X.Y.txt` file. This is done by appending `!skip` to the sanity test name in the second column. This approach is used when ignoring specific errors isn't possible, such as when a test causes a traceback or has a bug, or when the test is fundamentally inapplicable (like Python 2.6 tests on modern control nodes).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/ignores.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nplugins/module_utils/my_util.py validate-modules!skip # waiting for bug fix in module validator\nplugins/lookup/my_plugin.py compile-2.6!skip # Python 2.6 is not supported on the control node\n```\n\n----------------------------------------\n\nTITLE: Linking to Specific Ansible Plugin Types with :ansplugin: in reStructuredText (rst)\nDESCRIPTION: Shows further examples of the `:ansplugin:` role in reStructuredText, linking to specific plugin types like modules (`#module`), connection plugins (`#connection`), and lookup plugins (`#lookup`) using their FQCNs and optional custom text.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_10\n\nLANGUAGE: rst\nCODE:\n```\n   :ansplugin:`arista.eos.eos_config <arista.eos.eos_config#module>`\n   :ansplugin:`kubernetes.core.kubectl connection plugin <kubernetes.core.kubectl#connection>`\n   :ansplugin:`ansible.builtin.file lookup plugin <ansible.builtin.file#lookup>`\n```\n\n----------------------------------------\n\nTITLE: Managing Ansible Inventory (Shell)\nDESCRIPTION: Refers to the Ansible command-line tool used for managing and inspecting the inventory. This command is run on the control node to list hosts, view inventory variables, or validate inventory structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/index.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nansible-inventory\n```\n\n----------------------------------------\n\nTITLE: Listing Integration Test Targets via Bash with Argcomplete (Shell)\nDESCRIPTION: This shell command demonstrates the use of tab completion (with bash and the argcomplete package installed) to list all available ansible-test integration targets. It's a productivity feature to help users quickly find existing test targets by auto-completing commands. Depends on shell configuration and argcomplete integration with ansible-test.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_about.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nansible-test integration <tab><tab>\n```\n\n----------------------------------------\n\nTITLE: Using Legacy authorize/auth_pass for Network Enable Mode in Ansible YAML\nDESCRIPTION: This YAML snippet illustrates the older, now deprecated, method for entering enable mode on network devices using `connection: local`. It utilizes the `provider` dictionary within the task, setting `authorize: true` and providing the enable password via `auth_pass`. The documentation recommends migrating to the `become` method.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_privilege_escalation.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: eos-switches\n  ansible_connection: local\n  tasks:\n    - name: Gather facts (eos)\n      eos_facts:\n        gather_subset:\n          - \"!hardware\"\n      provider:\n        authorize: true\n        auth_pass: \" {{ secret_auth_pass }}\"\n```\n\n----------------------------------------\n\nTITLE: Formatting Scoped Ansible Changelog Fragment Entries (YAML)\nDESCRIPTION: Defines the standard YAML structure for a scoped changelog entry, typically used when the change affects a specific module or plugin. It requires a scope (module or plugin name), a description starting with a lowercase letter and ending with a period, and a reference link to the relevant issue or pull request.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n- scope - description starting with a lowercase letter and ending with a period at the very end. Multiple sentences are allowed (https://github.com/reference/to/an/issue or if there is no issue, reference to a pull request itself).\n```\n\n----------------------------------------\n\nTITLE: Internal Variable for Ansiballz Argument Passing (Python)\nDESCRIPTION: In the Ansiballz framework, the wrapper script monkey-patches this private variable (`_ANSIBLE_ARGS`) within `basic.py` with the JSON-ified module arguments before importing the main module code. Module authors should not rely on this internal variable directly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n_ANSIBLE_ARGS\n```\n\n----------------------------------------\n\nTITLE: Setting Required Environment Variables for z/OS UNIX Managed Nodes (YAML)\nDESCRIPTION: This code block shows the minimal set of environment variables (in YAML dict format) crucial for enabling file auto-conversion and correct tagging when using Ansible with z/OS UNIX System Services. These settings apply to various points in the Ansible inventory, playbook, block, or task, and affect the interpretation of file encodings and behavior of the Python interpreter. No direct input/output; ensures modules operate correctly with text encodings on z/OS.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_zos.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n_BPXK_AUTOCVT: \"ON\"\\n_CEE_RUNOPTS: \"FILETAG(AUTOCVT,AUTOTAG) POSIX(ON)\"\\n\\n_TAG_REDIR_ERR: \"txt\"\\n_TAG_REDIR_IN: \"txt\"\\n_TAG_REDIR_OUT: \"txt\"\n```\n\n----------------------------------------\n\nTITLE: Navigating to Collection Directory Using Bash\nDESCRIPTION: Demonstrates changing directories to the root of an Ansible collection, a prerequisite for creating or running tests locally. No dependencies except Unix shell support. The target directory must exist, and this is often the first setup step for local development.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_unit_tests.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/ansible_collection/community/mycollection\n\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule.run_command() Method\nDESCRIPTION: Stub documentation reference for the `run_command()` method of the `AnsibleModule` class, used to execute external commands from within a module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_19\n\nLANGUAGE: rst\nCODE:\n```\n.. py:method:: AnsibleModule.run_command()\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_change_power_state Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_change_power_state` module is deprecated. Functionality is replaced by the `redfish_powerstate` module for managing the power state of Dell EMC servers via Redfish.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_29\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_change_power_state\n```\n\n----------------------------------------\n\nTITLE: Setting Up Ansible Development Environment (Fish)\nDESCRIPTION: Sources the 'env-setup.fish' script using the Fish shell to configure the environment for running Ansible directly from the cloned source code. This is the Fish shell equivalent of the Bash setup.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_17\n\nLANGUAGE: console\nCODE:\n```\n$ source ./hacking/env-setup.fish\n```\n\n----------------------------------------\n\nTITLE: Verifying Multiple Tickets in Kerberos Cache (Bash)\nDESCRIPTION: This bash command uses klist after requesting a service ticket, showing both the TGT and a service ticket in the user's ticket cache. This helps confirm that delegation and service ticket acquisition are successful. Sample ticket listing output is included.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/windows_winrm_kerberos.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ klist\nTicket cache: KCM:1000\nDefault principal: username@MY.DOMAIN.COM\n\nValid starting     Expires            Service principal\n29/08/24 13:54:51  29/08/24 23:54:51  krbtgt/MY.DOMAIN.COM@MY.DOMAIN.COM\n        renew until 05/09/24 13:54:48\n29/08/24 13:55:30  29/08/24 23:55:30  http/server.my.domain.com@MY.DOMAIN.COM\n        renew until 05/09/24 13:55:30\n```\n\n----------------------------------------\n\nTITLE: Formatting Entries for New Jinja2 Plugins, Roles, Playbooks in Ansible Changelog (YAML)\nDESCRIPTION: Details the required YAML structure for documenting new additions like Jinja2 filter/test plugins, roles, and playbooks in Ansible changelog fragments, as these are not automatically included in the generated changelog. It specifies the use of `add plugin.filter`, `add plugin.test`, `add object.role`, or `add object.playbook` keys, along with `name` and `description` sub-keys. Descriptions should follow the `short_description` format (start uppercase, no period).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n# A new jinja2 filter plugin:\nadd plugin.filter:\n  - # The following needs to be the name of the filter itself, not of the file\n    # the filter is included in!\n    name: to_time_unit\n    # The description should be in the same format as short_description for\n    # other plugins and modules: it should start with an upper-case letter and\n    # not have a period at the end.\n    description: Converts a time expression to a given unit\n\n# A new jinja2 test plugin:\nadd plugin.test:\n  - # The following needs to be the name of the test itself, not of the file\n    # the test is included in!\n    name: asn1time\n    # The description should be in the same format as short_description for\n    # other plugins and modules: it should start with an upper-case letter and\n    # not have a period at the end.\n    description: Check whether the given string is an ASN.1 time\n\n# A new role:\nadd object.role:\n  - # This should be the short (non-FQCN) name of the role.\n    name: nginx\n    # The description should be in the same format as short_description for\n    # plugins and modules: it should start with an upper-case letter and\n    # not have a period at the end.\n    description: A nginx installation role\n\n# A new playbook:\nadd object.playbook:\n  - # This should be the short (non-FQCN) name of the playbook.\n    name: wipe_server\n    # The description should be in the same format as short_description for\n    # plugins and modules: it should start with an upper-case letter and\n    # not have a period at the end.\n    description: Wipes a server\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Defaults with Jinja in Ansible 2.7 (Method 2)\nDESCRIPTION: Illustrates an alternative verbose method using an `if/else` structure with multiple `is defined` checks to safely access nested attributes in Ansible 2.7 and older. This avoids errors when intermediate keys might be missing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_2\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ foo.bar.baz if (foo is defined and foo.bar is defined and foo.bar.baz is defined) else 'DEFAULT' }}\n```\n\n----------------------------------------\n\nTITLE: Explanation of Ansible Python Fallback Warning\nDESCRIPTION: This text quotes Ansible documentation regarding the warning issued when Python interpreter discovery relies on the fallback mechanism. It explains that the warning exists because future Python installations could alter which interpreter is found at a given path, and suggests setting the interpreter explicitly or silencing the warning.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/os_guide/intro_bsd.rst#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\nThe fallback behavior will issue a warning that the interpreter\nshould be set explicitly (since interpreters installed later may\nchange which one is used). This warning behavior can be disabled by\nsetting auto_silent or auto_legacy_silent. ...\n```\n\n----------------------------------------\n\nTITLE: Deprecating 'REQUIRESSL' Alias in mysql_user (Ansible)\nDESCRIPTION: Specifies that `REQUIRESSL` is an alias for the `ssl` key within the `tls_requires` option in the `mysql_user` module (`community.mysql`) as of version 2.0.0. Support for the `REQUIRESSL` alias will be removed entirely in `community.mysql` 3.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_46\n\nLANGUAGE: ansible\nCODE:\n```\nmysql_user\n```\n\nLANGUAGE: ansible\nCODE:\n```\nREQUIRESSL\n```\n\nLANGUAGE: ansible\nCODE:\n```\nssl\n```\n\nLANGUAGE: ansible\nCODE:\n```\ntls_requires\n```\n\n----------------------------------------\n\nTITLE: Retrieving Module Parameters Before AnsibleModule Instantiation (Python)\nDESCRIPTION: This function, `_load_params`, can be used by very dynamic custom modules to access module parameters before instantiating `AnsibleModule`. While potentially more stable than relying on internal variables like `_ANSIBLE_ARGS`, it is still subject to change.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n_load_params\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory Structure - Bash\nDESCRIPTION: This snippet demonstrates how to create a new directory named 'my_first_ee' and navigate into it for setting up an Ansible Execution Environment project. It has no external dependencies. The directory serves as a workspace for subsequent files and operations, and is the initial setup step for building an EE.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/build_execution_environment.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir my_first_ee && cd my_first_ee\n```\n\n----------------------------------------\n\nTITLE: Cloning Ansible Repository for PR Testing (Shell)\nDESCRIPTION: This shell-session example demonstrates how to clone the Ansible source code into a dedicated directory for pull request testing. This fresh workspace reduces risk and isolates test activity. Prerequisite: git installed and network access to GitHub. Input is a repository URL and optional directory name; output is a new local copy of the repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/ansible/ansible.git ansible-pr-testing\ncd ansible-pr-testing\n```\n\n----------------------------------------\n\nTITLE: Example: Running Integration Tests for test_mysql_user in Bash\nDESCRIPTION: Provides a specific example command to run integration tests for the `test_mysql_user` target, typically found in a collection like `community.mysql`. Uses `ansible-test` with Docker and verbose output.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test integration test_mysql_user --docker -v\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Info Test Target Directories (Bash)\nDESCRIPTION: Creates the necessary directory structure for the `postgresql_info` test target, including subdirectories for tasks and metadata.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p tests/integration/targets/postgresql_info/tasks tests/integration/targets/postgresql_info/meta\n```\n\n----------------------------------------\n\nTITLE: Legacy Display Object Initialization in Ansible - Python\nDESCRIPTION: This snippet shows the deprecated method for accessing the display object in Ansible plugins or scripts, with fallback import mechanisms based on earlier versions. It first attempts to import display from the __main__ context, then falls back to explicitly importing and instantiating Display if import fails. Requires the ansible.utils.display module in the environment. Input and output relate to the instantiation and usage of the global display logger.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n```\n\n----------------------------------------\n\nTITLE: Example of Expanded JSON Arguments in Python\nDESCRIPTION: This Python snippet shows the result after Ansible replaces the `<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>` placeholder in a JSONARGS module. The `json_arguments` variable now holds a JSON string containing the module parameters, with string values properly quoted and internal quotes escaped. The module script would then typically parse this JSON string using a suitable library to access the parameters.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\njson_arguments = \"\"\"{\"param1\": \"test's quotes\", \"param2\": \"\\\"To be or not to be\\\" - Hamlet\"}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Adding Context Metadata to Argument Spec - Ansible Python\nDESCRIPTION: This example shows how to assign arbitrary context metadata to an argument in the Ansible argument specification. The context field is a dictionary that is not validated or used by the Ansible core engine, but can provide custom metadata for plugin consumers or documentation tooling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\noption = {\n    'type': 'str',\n    'context': {\n        'disposition': '/properties/apiType',\n    },\n    'choices': ['http', 'soap'],\n}\n```\n\n----------------------------------------\n\nTITLE: Tagging and Pushing a New Collection Release - Git Bash Script\nDESCRIPTION: This Bash snippet is used to create an annotated tag for the newly released collection version and push it to the upstream repository. The tag message should denote the collection and version. The commands require sufficient permissions and a configured 'upstream' remote. This step triggers the publication of the collection to Ansible Galaxy via Zuul.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -n    # see current tags and their comments\\ngit tag -a NEW_VERSION -m \"comment here\"    # the comment can be, for example,  \"community.postgresql: 1.2.0\"\\ngit push upstream NEW_VERSION\n```\n\n----------------------------------------\n\nTITLE: Displaying Deprecation Warnings for Network Arguments in Ansible Console\nDESCRIPTION: Shows the console output generated in Ansible 2.5 when using the deprecated top-level connection arguments ('username', 'password', 'host') shown in the previous YAML example. These warnings indicate that the parameters will be removed in Ansible version 2.9.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n[DEPRECATION WARNING]: Param 'username' is deprecated. See the module docs for more information. This feature will be removed in version\n2.9. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.\n[DEPRECATION WARNING]: Param 'password' is deprecated. See the module docs for more information. This feature will be removed in version\n2.9. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.\n[DEPRECATION WARNING]: Param 'host' is deprecated. See the module docs for more information. This feature will be removed in version 2.9.\nDeprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.\n```\n\n----------------------------------------\n\nTITLE: Cloning Collection Repository via HTTPS (Bash)\nDESCRIPTION: Clones a forked `community.postgresql` collection repository from GitHub using the HTTPS protocol into the previously created local collections directory. Replace `YOURACC` with the actual GitHub username.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/YOURACC/community.postgresql.git ~/ansible_collections/community/postgresql\n```\n\n----------------------------------------\n\nTITLE: Installing pip using get-pip.py\nDESCRIPTION: Downloads the official 'get-pip.py' script using curl and then executes it with the chosen Python interpreter to install the latest version of pip for the current user (--user flag). This method is used when pip is not already installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\n$ python3 get-pip.py --user\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Dependency Lock Files without Upgrades using Nox (Bash)\nDESCRIPTION: This command runs the `pip-compile` nox session, passing the `--no-upgrade` flag to `pip-compile`. It synchronizes the lock files with the base requirements specified in the `.in` files but avoids upgrading transitive dependencies unless necessary to satisfy the base requirements.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnox -s pip-compile -- --no-upgrade\n```\n\n----------------------------------------\n\nTITLE: Updating Local Fork with Upstream Main - Git Bash Script\nDESCRIPTION: This snippet updates the local repository by rebasing it onto the main branch from the upstream remote. It ensures the local fork is current before making release changes. The command 'git pull --rebase upstream main' requires remote 'upstream' to be configured. This is a standard Git operation supporting a clean commit history.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_without_branches.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull --rebase upstream main\n```\n\n----------------------------------------\n\nTITLE: Referencing Deprecated Call Line in Bug Report - Markdown\nDESCRIPTION: This snippet displays a line of code (as an interpolated variable \\u2013 %(line)s) that references where a deprecated function or method is called within an Ansible component. It is used to bring attention to the specific location that triggers the deprecation warning as part of the bug report. Inputs expected are template variables replaced with context-specific values (e.g., actual line content referring to Display.deprecated), with no functional output except structured display; constraints are that it provides reference only and relies on upstream metadata preparation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/deprecated_issue_template.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```\n%(line)s\n```\n```\n\n----------------------------------------\n\nTITLE: Building Minimal Ansible Core Docs using Nox (Bash)\nDESCRIPTION: This command runs the `make` nox session. It sets up a build environment and uses the project's Makefile to generate a minimal HTML version of the Ansible Core documentation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnox -s make\n```\n\n----------------------------------------\n\nTITLE: Importing Annotations from __future__ - Python\nDESCRIPTION: This snippet shows the mandatory import of annotations from the __future__ module in Python for all '_internal' code used by 'ansible-test'. The dependency is the standard library 'from __future__ import annotations', and there are no external prerequisites. This import enables the use of postponed evaluation of type annotations, allowing forward references and reducing typing-related import cycles. There are no parameters; the import affects the module-level type hint behavior.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/ansible-test-future-boilerplate.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n```\n\n----------------------------------------\n\nTITLE: Force Pushing a Rebasing Branch to GitHub - Shell\nDESCRIPTION: Shows how to update the pull request on GitHub after a local rebase with the command \\\\\"git push --force-with-lease\\\\\". This force-push is required because rebasing rewrites commit history. Ensures that the remote PR will reflect the rebased changes; use with caution to avoid overwriting others' work.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_rebasing.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ git push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Introducing skip_version_check Parameter in community.grafana (Ansible)\nDESCRIPTION: Notes the introduction of the `skip_version_check` parameter in the `grafana_teams` and `grafana_folder` modules within the `community.grafana` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_37\n\nLANGUAGE: ansible\nCODE:\n```\nskip_version_check\n```\n\n----------------------------------------\n\nTITLE: Preparing Git Branches for Ansible Backporting using Shell\nDESCRIPTION: Provides the initial git commands for preparing the local repository to backport an Ansible change. It involves fetching updates from the 'upstream' remote (assumed to be the main ansible/ansible repository) and creating a new local backport branch (e.g., 'backport/2.18/[PR_NUMBER_FROM_DEVEL]') based on the target upstream stable branch (e.g., 'upstream/stable-2.18').\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n   git fetch upstream\n   git checkout -b backport/2.18/[PR_NUMBER_FROM_DEVEL] upstream/stable-2.18\n```\n\n----------------------------------------\n\nTITLE: Updating Local Fork from Upstream - Bash\nDESCRIPTION: Updates the local fork's default branch with the latest changes from the upstream main branch using a rebase. This ensures the release is based on the latest commits. Requires Git and an 'upstream' remote configured. No inputs/outputs besides updated local repository state.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull --rebase upstream main\n```\n\n----------------------------------------\n\nTITLE: Documenting Removed Features in Changelog Fragments - YAML\nDESCRIPTION: This YAML example illustrates how to specify features that have been removed after prior deprecation. Using the 'removed_features' key, each entry lists the removed feature and the recommended alternative, alongside a reference to the corresponding pull request. This ensures users are informed about feature removal and migration paths.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nremoved_features:\n  - acme_account_facts - the deprecated redirect has been removed. Use ``community.crypto.acme_account_info`` instead (https://github.com/ansible-collections/community.crypto/pull/290).\n\n```\n\n----------------------------------------\n\nTITLE: Support for ansible_network_single_user_mode (Ansible)\nDESCRIPTION: Indicates that support for the `ansible_network_single_user_mode` feature in various network collections (arista.eos, cisco.asa, cisco.ios, cisco.iosxr, cisco.nxos, junipernetworks.junos, vyos.vyos) requires `ansible.netcommon` v2.0.0+.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_34\n\nLANGUAGE: ansible\nCODE:\n```\nansible_network_single_user_mode\n```\n\n----------------------------------------\n\nTITLE: Declaring Copyright for Ansible Module Contributions in Python\nDESCRIPTION: This minimal header snippet shows the copyright notation required for Ansible Python modules. It must immediately follow the encoding line and is only editable or extended with explicit permission. This serves as the authoritative authorship attribution for Ansible contributions, and no additional copyright lines should be added in new code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_modules_documenting.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Copyright: Contributors to the Ansible project\\n\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Dictionary Keys in Python 3 - Python\nDESCRIPTION: Demonstrates how to iterate over dictionary keys in Python 3 by using a for-loop directly on the dictionary object, which implicitly iterates over its keys. This code replaces the removed dict.iterkeys() method and requires Python 3. The DICT variable should be a dictionary, and each iteration yields one of its keys. No additional dependencies are needed. Inputs: a dictionary DICT. Outputs: each KEY in DICT's keys.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-dict-iterkeys.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfor KEY in DICT:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Example Output of Ansible Galaxy Role Search\nDESCRIPTION: Illustrates the typical output format when searching for roles using `ansible-galaxy role search`. The output lists matching roles with their names and descriptions. This is sample output, not executable code.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/user_guide.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nFound 6 roles matching your search:\n\n Name                             Description\n ----                             -----------\n geerlingguy.elasticsearch         Elasticsearch for Linux.\n geerlingguy.elasticsearch-curator Elasticsearch curator for Linux.\n geerlingguy.filebeat              Filebeat for Linux.\n geerlingguy.fluentd               Fluentd for Linux.\n geerlingguy.kibana                Kibana for Linux.\n```\n\n----------------------------------------\n\nTITLE: RPM Spec File for Delivering Ansible Collection and Standalone Role\nDESCRIPTION: This RPM spec file outlines packaging logic for both a collection and a legacy standalone role to enable co-existence and migration in downstream distributions (e.g., RHEL). It sets up variables for packaging directories, copies role and collection files to appropriate locations, and handles document and license files for compliance. Requires rpmbuild tools, an existing tarball source, and collection/role content. Inputs include role and collection folders; outputs are properly structured package installations. Used for providing backwards-compatible Ansible automation content in system packages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/migrating_roles.rst#_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nName: acme-ansible-content\nSummary: Ansible Collection for deploying and configuring ACME webapp\nVersion: 1.0.0\nRelease: 1%{?dist}\nLicense: GPLv3+\nSource0: acme-webserver-1.0.0.tar.gz\n\nUrl: https://github.com/acme/webserver-ansible-collection\nBuildArch: noarch\n\n%global roleprefix my-standalone-role.\n%global collection_namespace acme\n%global collection_name webserver\n\n%global collection_dir %{_datadir}/ansible/collections/ansible_collections/%{collection_namespace}/%{collection_name}\n\n%description\nAnsible Collection and standalone role (for backward compatibility and migration) to deploy, configure, and manage the ACME webapp software.\n\n%prep\n%setup -qc\n\n%build\n\n%install\n\nmkdir -p %{buildroot}/%{collection_dir}\ncp -r ./* %{buildroot}/%{collection_dir}/\n\nmkdir -p %{buildroot}/%{_datadir}/ansible/roles\nfor role in %{buildroot}/%{collection_dir}/roles/*\n  do\n\t cp -pR ${role} %{buildroot}/%{_datadir}/ansible/roles/%{roleprefix}$(basename ${role})\n\n\t mkdir -p %{buildroot}/%{_pkgdocdir}/$(basename ${role})\n\t for docfile in README.md COPYING LICENSE\n\t  do\n     if [ -f ${role}/${docfile} ]\n        then\n           cp -p ${role}/${docfile} %{buildroot}/%{_pkgdocdir}/$(basename ${role})/${docfile}\n     fi\n\t done\n done\n\n\n%files\n%dir %{_datadir}/ansible\n%dir %{_datadir}/ansible/roles\n%dir %{_datadir}/ansible/collections\n%dir %{_datadir}/ansible/collections/ansible_collections\n%{_datadir}/ansible/roles/\n%doc %{_pkgdocdir}/*/README.md\n%doc %{_datadir}/ansible/roles/%{roleprefix}*/README.md\n%{collection_dir}\n%doc %{collection_dir}/roles/*/README.md\n%license %{_pkgdocdir}/*/COPYING\n%license %{_pkgdocdir}/*/LICENSE\n```\n\n----------------------------------------\n\nTITLE: Checking for systemd Cgroup Hierarchy - Shell\nDESCRIPTION: Greps the contents of the current process\\'s cgroup information to check for a systemd subsystem, important for WSL/Docker Desktop configurations. Outputs any matching cgroup entries containing 'systemd'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ngrep systemd /proc/self/cgroup\n```\n\n----------------------------------------\n\nTITLE: Running Docs Build Check with Unpinned Dependencies using Nox (Bash)\nDESCRIPTION: This command executes the `docs-build` check within the `checkers` nox session, but with the environment variable `PINNED` set to `false`. This forces `nox` to use the latest available dependencies as defined in the `.in` files, rather than the exact versions specified in the lock files (`.txt`), allowing testing against untested dependency versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nPINNED=false nox -s \"checkers(docs-build)\"\n```\n\n----------------------------------------\n\nTITLE: Defining Removed Features in Ansible Changelog Fragments (YAML)\nDESCRIPTION: This YAML snippet illustrates the `removed_features` section in an Ansible changelog fragment. This section documents features that were previously deprecated and have now been completely removed from the codebase. It should be written in the past tense and mention alternatives if available. There is no specific example content provided in this snippet block, but it shows the key where such entries would be listed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nremoved_features:\n```\n\n----------------------------------------\n\nTITLE: Example: Creating Directory for ansible.posix Collection using Bash\nDESCRIPTION: This Bash command shows another example, creating the directory structure for the `ansible.posix` Ansible collection. It utilizes `mkdir -p` to ensure the path `~/ansible_collections/ansible/posix` exists.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_test_pr_locally.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/ansible_collections/ansible/posix\n```\n\n----------------------------------------\n\nTITLE: Example Release Summary Fragment - YAML\nDESCRIPTION: Concrete example of a changelog YAML fragment, summarizing the collection release. The summary is concise and direct, to be inserted into the main changelog. Input: summary for a specific release; Output: YAML-compatible fragment.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nrelease_summary: This is release 2.0.0 of ``community.foo``, released on YYYY-MM-DD.\n```\n\n----------------------------------------\n\nTITLE: Checking Documentation Spelling using Nox (Bash)\nDESCRIPTION: This command runs the `spelling` nox session, which utilizes the `codespell` tool. It checks the documentation source files for common spelling mistakes.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnox -s spelling\n```\n\n----------------------------------------\n\nTITLE: Cloning the Collection Repository - Shell\nDESCRIPTION: Shows the commands for changing into the collection's parent directory and cloning the community.general collection repository from GitHub. It prepares the general folder as a local development copy and is required before making any code contributions. Assumes git is installed and the target directory is created.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_contributing.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd ~/dev/ansible/collections/ansible_collections/community\ngit clone git@github.com:ansible-collections/community.general.git general\n```\n\n----------------------------------------\n\nTITLE: Continuous Deployment Workflow Steps for Ansible (Local Development to Production) in Text\nDESCRIPTION: Details a continuous deployment pipeline as a plaintext list, covering the automation of local VM deployment, CI integration with every code change, running test scripts as part of deployment, and promoting changes to production. This snippet is conceptual and serves as a checklist for teams adopting automated deployment strategies with Ansible and CI/CD tooling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/test_strategies.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n- Write and use automation to deploy local development VMs\n- Have a CI system like Jenkins deploy to a staging environment on every code change\n- The deploy job calls testing scripts to pass/fail a build on every deploy\n- If the deploy job succeeds, it runs the same deploy playbook against production inventory\n```\n\n----------------------------------------\n\nTITLE: Formatting Ansible Changelog Entries for New Playbooks in YAML\nDESCRIPTION: Defines the specific YAML structure required in an Ansible changelog fragment to announce a new playbook, placed under 'add object.playbook:'. It requires specifying the playbook's short 'name' (e.g., 'wipe_server') and a 'description' formatted like a module's short_description (uppercase start, no period end).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n# A new playbook:\nadd object.playbook:\n  - # This should be the short (non-FQCN) name of the playbook.\n    name: wipe_server\n    # The description should be in the same format as short_description for\n    # plugins and modules: it should start with an upper-case letter and\n    # not have a period at the end.\n    description: Wipes a server\n```\n\n----------------------------------------\n\nTITLE: Example: Re-running test_mysql_user Integration Tests in Bash\nDESCRIPTION: Provides a specific example command for re-running the `test_mysql_user` integration tests using `ansible-test` with Docker. This confirms that fixes related to the `mysql_user` module allow the corresponding tests to pass.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ ansible-test integration test_mysql_user --docker -v\n```\n\n----------------------------------------\n\nTITLE: Equivalent Import for Common Module Boilerplate (Python)\nDESCRIPTION: This Python import statement is functionally equivalent to using the `#<<INCLUDE_ANSIBLE_MODULE_COMMON>>` placeholder in the Module Replacer framework. It imports necessary components from the basic module utilities.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ansible.module_utils.basic import *\n```\n\n----------------------------------------\n\nTITLE: Defining Known Issues in Ansible Changelog Fragments (YAML)\nDESCRIPTION: Demonstrates the YAML structure for documenting known issues in an Ansible changelog fragment under the `known_issues` key. It includes the scope or identifier (e.g., `idrac_user`), a description of the issue in the present tense, any workaround in imperative tense, and a reference link to the relevant issue or pull request.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nknown_issues:\n  - idrac_user - module may error out with the message ``unable to perform the import or export operation`` because there are pending attribute changes or a configuration job is in progress. Wait for the job to complete and run the task again.(https://github.com/dell/dellemc-openmanage-ansible-modules/pull/303).\n```\n\n----------------------------------------\n\nTITLE: Defining Minor Changes in Ansible Changelog Fragments (YAML)\nDESCRIPTION: This YAML snippet shows the format for the `minor_changes` section in an Ansible changelog fragment. It's used for enhancements and non-breaking behavioral changes to modules or plugins, like adding new parameters or expanding existing choices. These are considered enhancements, not bug fixes. The example documents adding a warning to the `lineinfile` module when an empty regular expression is used.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nminor_changes:\n  - lineinfile - add warning when using an empty regexp (https://github.com/ansible/ansible/issues/29443).\n```\n\n----------------------------------------\n\nTITLE: Injecting Ansible Version via Module Replacer (Internal)\nDESCRIPTION: This internal replacement pattern is substituted with the current Ansible version string by the Module Replacer framework. The recommended way to access the version in new-style Python modules under Ansiballz is via `AnsibleModule.ansible_version`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n\"<<ANSIBLE_VERSION>>\"\n```\n\n----------------------------------------\n\nTITLE: Updating Local git Branch with Rebase - Shell\nDESCRIPTION: Updates the local 'devel' branch of the 'ansible-core' repository by rebasing on upstream changes. This command should be run inside the ansible-core git repository. It replays local commits on top of the updated remote branch, minimizing merge conflicts and keeping history linear. Assumes that git is installed and a remote is configured.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_20\n\nLANGUAGE: console\nCODE:\n```\n$ git pull --rebase\n```\n\n----------------------------------------\n\nTITLE: Referencing ansible.module_utils.url Module\nDESCRIPTION: Stub documentation reference for the `ansible.module_utils.url` module, likely containing utilities for handling URLs and making HTTP requests within Ansible modules.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_24\n\nLANGUAGE: rst\nCODE:\n```\n.. py:module:: ansible.module_utils.url\n```\n\n----------------------------------------\n\nTITLE: New Module fortios_monitor in fortinet.fortios (Ansible)\nDESCRIPTION: Announces the addition of the new module `fortios_monitor` to the `fortinet.fortios` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_49\n\nLANGUAGE: ansible\nCODE:\n```\nfortios_monitor\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible Lint CLI Command\nDESCRIPTION: Specifies using `ansible-lint` when referring to the command-line tool for Ansible Lint. This term should be used in all occurrences referencing the CLI.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nansible-lint\n```\n\n----------------------------------------\n\nTITLE: Rendered MOTD Output from Template (bar) - Text - Sample Output\nDESCRIPTION: This snippet displays example output for the host 'bar' after Jinja template rendering in Ansible. It emphasizes the per-host customization possible with dynamic inventory data, showing values for 'a', 'b', and 'c'. Inputs are inventory variables from Cobbler; result is a host-specific /etc/motd file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/inventory_guide/intro_dynamic_inventory.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nWelcome, I am templated with a value of a=2, b=3, and c=5\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule.log() Method\nDESCRIPTION: Stub documentation reference for the `log()` method of the `AnsibleModule` class. This method is used for logging messages from an Ansible module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_16\n\nLANGUAGE: rst\nCODE:\n```\n.. py:method:: AnsibleModule.log()\n```\n\n----------------------------------------\n\nTITLE: Creating Release Tags with Custom Core Repo Path using Nox (Bash)\nDESCRIPTION: This command runs the `tag` nox session, specifying a custom path to the `ansible/ansible` repository checkout using the `--core` option. This is necessary if the core repository is not located in the default assumed location (sibling directory).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# If your core repo is not in the same filesystem location, specify the path.\nnox -s tag -- --core <path> tag\n```\n\n----------------------------------------\n\nTITLE: Example Table Row for New Ansible Network Platform (Text)\nDESCRIPTION: This snippet provides an example text format for adding a new network platform ('My OS' with `myos` prefix) to the `settings_by_platform` table in the Ansible documentation. It shows which connection types (implied by columns, likely CLI, HTTPAPI, etc.) are supported using checkmarks (✓). The formatting must align with the existing table structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/dev_guide/documenting_modules_network.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+-------------------+-------------------------+-------------+---------+---------+----------+\n| My OS             | ``myos``                | ✓           | ✓       |         | ✓        |\n\n```\n\n----------------------------------------\n\nTITLE: Using Relative Imports for Module Utils in Core Ansible (Python)\nDESCRIPTION: Demonstrates how relative imports can be used within core Ansible Python modules (e.g., `ansible/modules/system/ping.py`) to import utilities from `ansible.module_utils`. It compares the new relative import syntax with the previous absolute import method for importing `AnsibleModule` from `basic.py`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.9.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# File: ansible/modules/system/ping.py\n# Old way to use an absolute import to import module_utils from core:\nfrom ansible.module_utils.basic import AnsibleModule\n# New way using a relative import:\nfrom ...module_utils.basic import AnsibleModule\n```\n\n----------------------------------------\n\nTITLE: Cloning Required Ansible Core Parts in Bash\nDESCRIPTION: Executes a Python script to clone necessary components from the Ansible Core repository into the local environment. This is required for the documentation build process to access relevant source files. Requires Python 3 and the 'ansible-documentation' repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 docs/bin/clone-core.py\n```\n\n----------------------------------------\n\nTITLE: Creating Missing Release Tags using Nox (Bash)\nDESCRIPTION: This command runs the `tag` nox session with default settings. It checks for release tags present in the `ansible/ansible` repository (assuming it's checked out sibling to `ansible-documentation` and uses 'origin' as remote) and creates corresponding tags in the local `ansible-documentation` repository if they are missing.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n# The tagger scripts assumes \"origin\" as the upstream remote.\nnox -s tag\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible Creator CLI Command\nDESCRIPTION: Specifies using `ansible-creator` when referring directly to the command-line tool associated with Ansible Creator.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible-creator\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_configure_bios Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_configure_bios` module is deprecated. Users should use the `idrac_bios` module for configuring BIOS settings on Dell EMC iDRAC.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_30\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_configure_bios\n```\n\n----------------------------------------\n\nTITLE: Installing Ansible on OpenSUSE Tumbleweed/Leap (Bash)\nDESCRIPTION: Installs the 'ansible' package on OpenSUSE Tumbleweed or Leap using the Zypper package manager. Requires root privileges (sudo).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/installation_distros.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo zypper install ansible\n```\n\n----------------------------------------\n\nTITLE: Deprecating nxos_ospf_vrf Module in Ansible NX-OS\nDESCRIPTION: The `nxos_ospf_vrf` module is deprecated. Functionality is replaced by the `nxos_ospfv2` and `nxos_ospfv3` Resource Modules for configuring OSPFv2 and OSPFv3 within VRFs on Cisco NX-OS devices.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_8\n\nLANGUAGE: Ansible\nCODE:\n```\nnxos_ospf_vrf\n```\n\n----------------------------------------\n\nTITLE: Deprecated Inline Variable Syntax for include_tasks in YAML\nDESCRIPTION: Demonstrates the pre-Ansible 2.7 syntax for passing variables directly inline with the `include_tasks` directive. This method is deprecated in Ansible 2.7 and later versions require using the `vars` keyword instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.7.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- include_tasks: include_me.yml variable=value\n```\n\n----------------------------------------\n\nTITLE: Defining Trivial Changes in Ansible Changelog Fragments (YAML)\nDESCRIPTION: Illustrates the YAML format for `trivial` changes in Ansible changelog fragments, which are excluded from the published changelog output. These are typically used for housekeeping, documentation, or test-only changes. The example shows the scope (`aws_ec2`), a description of the change, and a reference link.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_development_process.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\ntrivial:\n  - aws_ec2 - fix broken integration test (https://github.com/ansible-collections/amazon.aws/pull/1269).\n```\n\n----------------------------------------\n\nTITLE: Setting Up Ansible Dev Environment Quietly\nDESCRIPTION: Sources the 'env-setup' script with the '-q' flag to suppress spurious warnings or errors during the environment setup process for running Ansible from source.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_18\n\nLANGUAGE: console\nCODE:\n```\n$ source ./hacking/env-setup -q\n```\n\n----------------------------------------\n\nTITLE: Defining Extra Documentation Structure in Ansible Collection - yaml\nDESCRIPTION: This YAML snippet defines the extra documentation structure for a collection as used in docs/docsite/extra-docs.yml. It establishes documentation sections and their respective toctree entries to customize navigation and display in documentation websites. It requires that the collection documentation follows the markdown or reStructuredText file convention as appropriate, and that the YAML be placed at docs/docsite/extra-docs.yml. Inputs are section objects with toctree lists, and outputs influence the documentation site's navigation tree.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_collections_structure.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\\nsections:\\n- title: Scenario Guide\\n  toctree:\\n    - scenario_guide\n```\n\n----------------------------------------\n\nTITLE: Example pip Verification Output\nDESCRIPTION: Shows example output indicating that pip version 21.0.1 is installed for Python 3.9 and located in the system site-packages directory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/installation_guide/intro_installation.rst#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -m pip -V\npip 21.0.1 from /usr/lib/python3.9/site-packages/pip (python 3.9)\n```\n\n----------------------------------------\n\nTITLE: Importing PowerShell/C# Module Utils in Ansible 2.8 Collections\nDESCRIPTION: Demonstrates the syntax used in Ansible 2.8 to import PowerShell or C# module utilities located within an Ansible collection. This syntax is deprecated in Ansible 2.9.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.9.rst#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n#AnsibleRequires -CSharpUtil AnsibleCollections.namespace_name.collection_name.util_filename\n#AnsibleRequires -PowerShell AnsibleCollections.namespace_name.collection_name.util_filename\n```\n\n----------------------------------------\n\nTITLE: Checking Git Repository Status (Bash)\nDESCRIPTION: Uses the `git status` command to display the current state of the Git repository, ensuring the user is in the correct branch (usually the default main branch after cloning).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit status\n```\n\n----------------------------------------\n\nTITLE: Defining Major Changes in Ansible Changelog Fragments (YAML)\nDESCRIPTION: This YAML snippet illustrates the `major_changes` section in an Ansible changelog fragment. This section is used for significant, non-breaking changes impacting a collection broadly, such as new SDK support or announcing future EOLs. Users might choose to adapt but aren't forced to. The example details an enhancement in `ansible-test` allowing cloud plugins using containers to work across POSIX and Windows hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/development_process.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nmajor_changes:\n  - ansible-test - all cloud plugins which use containers can now be used with all POSIX and Windows hosts. Previously the plugins did not work with Windows at all, and support for hosts created with the ``--remote`` option was inconsistent (https://github.com/ansible/ansible/pull/74216).\n```\n\n----------------------------------------\n\nTITLE: Example: Creating Directory for community.mysql Collection in Bash\nDESCRIPTION: Provides a concrete example of the `mkdir -p` command to create the local directory structure specifically for the `community.mysql` Ansible collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir -p ~/ansible_collections/community/mysql\n```\n\n----------------------------------------\n\nTITLE: Checking reStructuredText File Syntax with rstcheck in Bash\nDESCRIPTION: Uses the `rstcheck` command-line tool to validate the syntax of a specified reStructuredText (`.rst`) file. This helps identify formatting errors before attempting a full documentation build. Requires `rstcheck` to be installed (usually via the dependencies).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrstcheck changed_file.rst\n```\n\n----------------------------------------\n\nTITLE: Upgrading a Single Dependency using Nox (Bash)\nDESCRIPTION: This command runs the `pip-compile` nox session, passing the `--upgrade-package` flag followed by a package name to `pip-compile`. It specifically upgrades the named package and its dependencies within the lock files, while keeping other dependencies pinned.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnox -s pip-compile -- --upgrade-package <package_name>\n```\n\n----------------------------------------\n\nTITLE: Creating and Switching Branches for Repository Updates - Bash\nDESCRIPTION: Creates a new branch (update_repo) from 'main' and switches to it for making necessary updates (like bumping versions or cleaning up changelogs). Used as an isolated workspace for non-release branch changes prior to pull requests. Input: new branch name; Output: checked-out working branch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_release_with_branches.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b update_repo\n```\n\n----------------------------------------\n\nTITLE: Referencing the 'with_items' Loop Construct (YAML)\nDESCRIPTION: Mentions `with_items`, an older Ansible construct for looping over lists within tasks. It's noted that such constructs are often implemented using lookup plugins. Modern Ansible generally uses the `loop` keyword instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/glossary.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\nwith_items\n```\n\n----------------------------------------\n\nTITLE: Creating an Inventory Directory (Bash)\nDESCRIPTION: This simple Bash command creates a directory named 'inventory'. This directory is intended to hold Ansible inventory files, such as 'hosts.yml', used for managing remote hosts.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started_ee/run_execution_environment.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir inventory\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to ansible-core Source - Shell\nDESCRIPTION: Command for changing the current shell working directory to the cloned ansible-core source code tree. Prepares for further commands such as environment setup or running ansible-test.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncd ~/dev/ansible\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Test File Using Bash\nDESCRIPTION: Creates a new empty Python test file at the specified location in the Ansible collection directory structure. Usage requires file system write permissions and is run from the shell or terminal. This command prepares the environment for writing unit tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_unit_tests.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntouch tests/units/plugins/modules/test_my_module.py\n\n```\n\n----------------------------------------\n\nTITLE: Sample Output of Travis Integrations Listing - Text\nDESCRIPTION: Shows the tabular output format for Travis CI integrations linked with a role on Galaxy, including integration IDs, sources, and associated repositories. This output helps in managing and referencing integrations, especially for deletion.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/galaxy/dev_guide.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n  ID         Source     Repo\n  ---------- ---------- ----------\n  2          travis     github_user/github_repo\n  1          travis     github_user/github_repo\n```\n\n----------------------------------------\n\nTITLE: Running flake8 Linter on Python File in Bash\nDESCRIPTION: Executes the `flake8` Python linter on a specified file (`path/to/changed_file.py`) to check for PEP 8 style guide violations, unused imports, and other common coding issues. Requires `flake8` to be installed (`pip install flake8`).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ flake8 path/to/changed_file.py\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_configure_idrac_network Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_configure_idrac_network` module is deprecated. Migrate to the `idrac_network` module for managing iDRAC network settings.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_31\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_configure_idrac_network\n```\n\n----------------------------------------\n\nTITLE: Configuring Deprecated Top-Level Network Connection Arguments in Ansible YAML (< 2.4)\nDESCRIPTION: Demonstrates the old method (pre-Ansible 2.5) of specifying network connection details like host, username, and password directly within an Ansible task using top-level arguments. This approach is deprecated in Ansible 2.5 and will be removed in version 2.9.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.5.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- name: example of using top-level options for connection properties\n  ios_command:\n    commands: show version\n    host: \"{{ inventory_hostname }}\"\n    username: cisco\n    password: cisco\n    authorize: yes\n    auth_pass: cisco\n```\n\n----------------------------------------\n\nTITLE: Adding a Local TOC reStructuredText reStructuredText\nDESCRIPTION: Demonstrates how to insert a local table of contents (TOC) in a reStructuredText (RST) document using the contents directive. The snippet highlights the correct placement and option for including only section headings below the main heading. This is essential for large documentation pages to enhance navigation without including the main page heading.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_12\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. contents::\n   :local:\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for PR Labeler Tests\nDESCRIPTION: This snippet lists the specific versions of Python packages required for the `pr_labeler` tests in the Ansible documentation project. It follows the standard `requirements.txt` format, with comments indicating the source or reason for each dependency (e.g., `# via package_name` or `# via -r input_file`). This file ensures that the test environment is consistent across different setups by pinning exact versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/pr_labeler.txt#_snippet_0\n\nLANGUAGE: pip-requirements\nCODE:\n```\n# This file was autogenerated by uv via the following command:\n#    uv pip compile --universal --output-file tests/pr_labeler.txt tests/pr_labeler.in\ncertifi==2025.1.31\n    # via requests\ncffi==1.17.1\n    # via\n    #   cryptography\n    #   pynacl\ncharset-normalizer==3.4.1\n    # via requests\nclick==8.1.8\n    # via typer-slim\ncodeowners==0.7.0\n    # via -r tests/pr_labeler.in\ncolorama==0.4.6 ; sys_platform == 'win32'\n    # via click\ncryptography==44.0.2\n    # via pyjwt\ndeprecated==1.2.18\n    # via pygithub\nidna==3.10\n    # via requests\njinja2==3.1.6\n    # via -r tests/pr_labeler.in\nmarkupsafe==3.0.2\n    # via jinja2\npycparser==2.22\n    # via cffi\npygithub==2.6.1\n    # via -r tests/pr_labeler.in\npyjwt==2.10.1\n    # via pygithub\npynacl==1.5.0\n    # via pygithub\nrequests==2.32.3\n    # via pygithub\ntyper-slim==0.15.2\n    # via -r tests/pr_labeler.in\ntyping-extensions==4.13.1\n    # via\n    #   codeowners\n    #   pygithub\n    #   typer-slim\nurllib3==2.3.0\n    # via\n    #   pygithub\n    #   requests\nwrapt==1.17.2\n    # via deprecated\n\n```\n\n----------------------------------------\n\nTITLE: Referring to the ansible-pylibssh Library\nDESCRIPTION: States that `ansible-pylibssh` should be used consistently whenever referring to this specific Python library dependency. It should be used on all occurrences.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nansible-pylibssh\n```\n\n----------------------------------------\n\nTITLE: Referencing centos6 Test Container for ansible-test (Ansible)\nDESCRIPTION: Refers to the `centos6` test container used by `ansible-test`. Tests run with this container now use a PyPI proxy when Python 2.6 is involved, ensuring continued functionality despite PyPI discontinuing support for non-SNI clients.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_30\n\nLANGUAGE: plaintext\nCODE:\n```\ncentos6\n```\n\n----------------------------------------\n\nTITLE: Creating New Stable Branches using Git (Bash)\nDESCRIPTION: This sequence of Git commands fetches the latest changes from the upstream repository, creates a new local stable branch (e.g., `stable-2.18`) based on the `devel` branch from upstream, and then pushes this new branch to the upstream repository. This process is essential when a new stable version of Ansible core is released.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Make sure your checkout is up to date.\ngit fetch upstream\n\n# Create a new stable branch against the devel branch.\ngit checkout -b stable-2.18 upstream/devel\n\n# Push the new stable branch to the repository.\ngit push upstream stable-2.18\n```\n\n----------------------------------------\n\nTITLE: Referencing self.play Attribute\nDESCRIPTION: Stub documentation reference potentially indicating access to play context information via `self.play` within a module method or class.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_10\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: self.play\n```\n\n----------------------------------------\n\nTITLE: Configuring Toctree Navigation for Ansible CLI Tools - reStructuredText\nDESCRIPTION: This snippet defines a toctree in reStructuredText to organize links to documentation pages for multiple Ansible CLI utilities. Each entry in the toctree references a different utility documentation file, enabling structured navigation within the Ansible documentation system. The maxdepth parameter limits the depth of displayed subpages, aiding readability and site navigation. Requires Sphinx or compatible documentation tooling.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/command_guide/command_line_tools.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\\n   :maxdepth: 1\\n\\n   ../cli/ansible.rst\\n   ../cli/ansible-config.rst\\n   ../cli/ansible-console.rst\\n   ../cli/ansible-doc.rst\\n   ../cli/ansible-galaxy.rst\\n   ../cli/ansible-inventory.rst\\n   ../cli/ansible-playbook.rst\\n   ../cli/ansible-pull.rst\\n   ../cli/ansible-vault.rst\n```\n\n----------------------------------------\n\nTITLE: Creating and Checking Out a Git Branch (Bash)\nDESCRIPTION: Creates a new Git branch named `postgresql_info_tests` and switches the working directory to this new branch. This is standard practice for developing new features or tests.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b postgresql_info_tests\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_idrac_reset Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_idrac_reset` module is deprecated. Resetting the Dell EMC iDRAC should now be performed using the `idrac_reset` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_38\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_idrac_reset\n```\n\n----------------------------------------\n\nTITLE: Creating and Entering an Ansible Project Directory (Bash)\nDESCRIPTION: This Bash command creates a new directory named 'ansible_quickstart' and then immediately changes the current working directory into it. This sets up a dedicated folder for organizing Ansible project files like playbooks and inventory.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/get_started_ansible.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir ansible_quickstart && cd ansible_quickstart\n```\n\n----------------------------------------\n\nTITLE: Creating Release Tags with Custom Remote using Nox (Bash)\nDESCRIPTION: This command runs the `tag` nox session, specifying a custom upstream remote name using the `--remote` option. This is used when the upstream remote for the `ansible/ansible` repository checkout is not named 'origin'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# If you use a different upstream remote, specify the name.\nnox -s tag -- --remote <name> tag\n```\n\n----------------------------------------\n\nTITLE: Navigating into Cloned Collection Repository Directory in Bash\nDESCRIPTION: Changes the current working directory to the root of the locally cloned Ansible collection repository located at `~/ansible_collections/NAMESPACE/COLLECTION_NAME`. Replace `NAMESPACE` and `COLLECTION_NAME` accordingly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Displaying Ansible Ping Output as JSON - Shell/CLI Output\nDESCRIPTION: This snippet shows the standard JSON-formatted output generated by the Ansible ping module when executed on multiple remote hosts via the command line. It displays essential information returned per host: the python interpreter path found by Ansible, whether any state changes occurred, and the response to the ping ('pong') command. No external dependencies are required other than Ansible and Python installed on the target hosts. Inputs are the inventory hostnames; outputs are the structured connectivity results for each.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/getting_started/ansible_output/ping_output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n192.0.2.50 | SUCCESS => {\n  \"ansible_facts\": {\n    \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n    }\n192.0.2.51 | SUCCESS => {\n  \"ansible_facts\": {\n    \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n    }\n192.0.2.52 | SUCCESS => {\n  \"ansible_facts\": {\n    \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Referencing default Test Container for ansible-test (Ansible)\nDESCRIPTION: Refers to the `default` test container used by `ansible-test`. Tests run with this container now use a PyPI proxy when Python 2.6 is involved, ensuring continued functionality despite PyPI discontinuing support for non-SNI clients.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_31\n\nLANGUAGE: plaintext\nCODE:\n```\ndefault\n```\n\n----------------------------------------\n\nTITLE: Building a Single reStructuredText Page with Make in Bash\nDESCRIPTION: Uses the `make` utility to build a single specified reStructuredText file into HTML format using the `htmlsingle` target. The path to the `.rst` file should be relative to the `docs/docsite/rst/` directory. This command should be executed from the `docs/docsite` directory. Requires `make` and the documentation build tools (like Sphinx) to be installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake htmlsingle rst=path/to/your_file.rst\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule._debug Attribute\nDESCRIPTION: Stub documentation reference for the `_debug` attribute of the `AnsibleModule` class, likely related to module debugging flags.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule._debug\n```\n\n----------------------------------------\n\nTITLE: Deprecating syspatch apply Argument in community.general\nDESCRIPTION: The `apply` argument for the `syspatch` module is deprecated as it is redundant. This argument will be removed in a future version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_17\n\nLANGUAGE: Ansible\nCODE:\n```\nsyspatch: apply\n```\n\n----------------------------------------\n\nTITLE: Using Deprecated Top-level Connection Arguments in Ansible Network Modules (YAML)\nDESCRIPTION: Displays prior usage in Ansible 2.2 where network connection information (host, username, password, etc.) was specified directly at the module level. These arguments are deprecated as of 2.3 and will trigger warnings. Requires Ansible with network modules; inputs are host connection parameters, outputs are deprecation warnings and network command execution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.3.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- name: example of using top-level options for connection properties\\n  ios_command:\\n    commands: show version\\n    host: \\\"{{ inventory_hostname }}\\\"\\n    username: cisco\\n    password: cisco\\n    authorize: yes\\n    auth_pass: cisco\n```\n\n----------------------------------------\n\nTITLE: Defining Option Removed by Date - Ansible Python\nDESCRIPTION: This snippet defines a deprecation for an Ansible argument using a removal date (removed_at_date) and specifies the collection (removed_from_collection) from which the option will be removed. This is helpful in communicating a timeline for deprecating arguments in modules and is part of good lifecycle management.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\noption = {\n  'type': 'str',\n  'removed_at_date': '2020-12-31',\n  'removed_from_collection': 'testns.testcol',\n},\n```\n\n----------------------------------------\n\nTITLE: Deprecating dellemc_get_lc_job_status Module in dellemc.openmanage\nDESCRIPTION: The `dellemc_get_lc_job_status` module is deprecated. Use the `idrac_lifecycle_controller_job_status_info` module to retrieve the status of Dell EMC Lifecycle Controller jobs.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_36\n\nLANGUAGE: Ansible\nCODE:\n```\ndellemc_get_lc_job_status\n```\n\n----------------------------------------\n\nTITLE: Deprecating hashi_vault VAULT_SECRET_ID Variable in community.hashi_vault\nDESCRIPTION: The `VAULT_SECRET_ID` environment variable used to set the `secret_id` option for the `hashi_vault` lookup plugin is deprecated. It will be removed in community.hashi_vault version 2.0.0. Use `ANSIBLE_HASHI_VAULT_SECRET_ID` instead.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_3.rst#_snippet_22\n\nLANGUAGE: Environment Variable\nCODE:\n```\nVAULT_SECRET_ID\n```\n\n----------------------------------------\n\nTITLE: Example Incidental Coverage Report Format (Markdown and Python)\nDESCRIPTION: This snippet shows an example of how a coverage report is formatted. It includes details such as the target incidental test, links to the test and the source code on GitHub, the affected source file, and annotated lines showing which lines/arcs are covered. Python-specific arc coverage comments clarify execution flow. The output is intended for human readers and is generated by the incidental.py script post-analysis. The markdown formatting is used for documentation display.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/azp/README.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n```\nTarget: incidental_win_psexec\nGitHub: https://github.com/ansible/ansible/blob/6994ef0b554a816f02e0771cb14341a421f7cead/test/integration/targets/incidental_win_psexec\n\nSource: lib/ansible/executor/task_executor.py (2 arcs, 3/1141 lines):\nGitHub: https://github.com/ansible/ansible/blob/6994ef0b554a816f02e0771cb14341a421f7cead/lib/ansible/executor/task_executor.py\n\n 705                  if 'rc' in result and result['rc'] not in [0, \"0\"]:  ### (here) -> 706\n 706                      result['failed'] = True  ### 705 -> (here)  ### (here) -> 711\n\n 711              if self._task.until:  ### 706 -> (here)\n```\n```\n\n----------------------------------------\n\nTITLE: Analyzing Coverage Data with Env Setup and Python Script (Shell)\nDESCRIPTION: This shell snippet chains setup of the environment via env-setup script and execution of the incidental.py analysis script on locally downloaded coverage results. It assumes ansible-test is available in $PATH and that the hacked/azp/incidental.py script and a corresponding results directory (named after the run number or source) exist. Reports are generated for the analyzed run, typically under test/results/.tmp/incidental/{hash}/reports/.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/azp/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# make sure ansible-test is in $PATH\nsource hacking/env-setup\n# run the script using whichever directory results were downloaded into\nhacking/azp/incidental.py 14075/\n```\n\n----------------------------------------\n\nTITLE: Updating Dependency Lock Files using Nox (Bash)\nDESCRIPTION: This command runs the `pip-compile` nox session. It uses `pip-tools` to update the dependency lock files (e.g., `tests/requirements.txt`) based on the direct dependencies specified in the corresponding `.in` files (e.g., `tests/requirements.in`), ensuring reproducible builds with the latest compatible packages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnox -s pip-compile\n```\n\n----------------------------------------\n\nTITLE: Installing Documentation Dependencies using Pip in Bash\nDESCRIPTION: Installs Python dependencies required for building the Ansible documentation using pip within the activated virtual environment. The first command installs specific tested versions pinned in `tests/requirements.txt`, while the second installs the latest versions specified in `tests/requirements.in`. Requires an active Python virtual environment and the `tests/requirements.in` and `tests/requirements.txt` files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/documentation_contributions.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r tests/requirements.in -c tests/requirements.txt # Installs tested dependency versions.\npip install -r tests/requirements.in # Installs the unpinned dependency versions.\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule.params Attribute in Python\nDESCRIPTION: Stub documentation reference for the `params` attribute of the `AnsibleModule` class. This attribute holds the parameters accepted by the Ansible module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule.params\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule.ansible_version Attribute\nDESCRIPTION: Stub documentation reference for the `ansible_version` attribute of the `AnsibleModule` class.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule.ansible_version\n```\n\n----------------------------------------\n\nTITLE: Internal Link to Section Markdown Markdown\nDESCRIPTION: Demonstrates how to link directly to a specific heading within a Markdown file by appending a fragment identifier (#heading) to the URL. This pattern aids users in quickly navigating to detailed sections. Mkdocs processes these links for intra-document navigation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_16\n\nLANGUAGE: Markdown\nCODE:\n```\n[dependency](/configuration/#dependency)\n```\n\n----------------------------------------\n\nTITLE: Updating Core Branch Reference using sed (Bash)\nDESCRIPTION: Uses the `sed` command to perform an in-place replacement within the `docs/ansible-core-branch.txt` file. It changes the specified branch from `devel` to the newly created stable branch name (e.g., `stable-2.18`). This file is used by scripts that graft content from the core repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsed -i 's/devel/stable-2.18/g' docs/ansible-core-branch.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying UV Package Dependency Version\nDESCRIPTION: This line pins the `uv` package dependency to the exact version `0.6.14`. The accompanying comment indicates that this dependency originates from the input file `tests/pip-compile.in` used during the `uv pip compile` process.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/pip-compile.txt#_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\n# This file was autogenerated by uv via the following command:\n#    uv pip compile --universal --output-file tests/pip-compile.txt tests/pip-compile.in\nuv==0.6.14\n    # via -r tests/pip-compile.in\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule.debug() Method\nDESCRIPTION: Stub documentation reference for the `debug()` method of the `AnsibleModule` class, used for logging debug messages.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_17\n\nLANGUAGE: rst\nCODE:\n```\n.. py:method:: AnsibleModule.debug()\n```\n\n----------------------------------------\n\nTITLE: Code Block in Markdown Markdown\nDESCRIPTION: Exhibits the markdown triple-backtick syntax for multi-line code blocks, used to display raw file or directory structures in documentation. The example represents a typical project directory layout. Syntax highlighting can be specified after the opening backticks; here, 'text' is used for plain formatting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_18\n\nLANGUAGE: Markdown\nCODE:\n```\n```text\ndocs/\n    index.md\n    user-guide/getting-started.md\n    user-guide/configuration-options.md\n    license.md\n```\n```\n\n----------------------------------------\n\nTITLE: Removing Tagger Dependency Reference using sed (Bash)\nDESCRIPTION: Uses the `sed` command to remove the line containing `-r tag.in` from the `tests/typing.in` file. This step removes a dependency reference related to the tagger script, which is being removed from the stable branch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsed -i '/-r tag.in/d' tests/typing.in\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Version in Read the Docs (YAML)\nDESCRIPTION: Example snippet from a `.readthedocs.yaml` configuration file. It specifies the build environment settings for Read the Docs, including the operating system (`ubuntu-lts-latest`) and the required Python version (`3.11`). This Python version must align with the version used for building documentation in the corresponding `ansible-documentation` branch.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nbuild:\n  os: ubuntu-lts-latest\n  tools:\n    python: >-\n      3.11\n```\n\n----------------------------------------\n\nTITLE: Applying Apache License 2.0 Boilerplate Notice (Text)\nDESCRIPTION: This boilerplate text provides the standard copyright and license notice recommended by the Apache License, Version 2.0. It should be included in project source files, typically within comments appropriate for the file format, after replacing the `{yyyy}` and `{name of copyright owner}` placeholders.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/licenses/Apache-License.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCopyright {yyyy} {name of copyright owner}\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Creating Package Documentation Build Branches using Git (Bash)\nDESCRIPTION: This sequence of Git commands creates and pushes a new branch (e.g., `11`) in the `ansible-community/package-doc-builds` repository. This branch corresponds to a new Ansible package version and is based on the `devel` branch, preparing the repository for hosting the documentation build for that specific package version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Make sure your checkout is up to date.\ngit fetch upstream\n\n# Create the new package version branch against the devel branch.\ngit checkout -b 11 upstream/devel\n\n# Push the new package version branch to the repository.\ngit push upstream 11\n```\n\n----------------------------------------\n\nTITLE: Correcting Spelling Errors Interactively using Nox (Bash)\nDESCRIPTION: This command runs the `spelling` nox session with the `-w` flag passed to `codespell`. It checks for spelling errors and interactively prompts the user to apply corrections found.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnox -s spelling -- -w\n```\n\n----------------------------------------\n\nTITLE: Referencing AnsibleModule._syslog_facility Attribute\nDESCRIPTION: Stub documentation reference for the `_syslog_facility` attribute of the `AnsibleModule` class, used for configuring syslog.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_8\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: AnsibleModule._syslog_facility\n```\n\n----------------------------------------\n\nTITLE: Running Specific Makefile Target via Nox (Bash)\nDESCRIPTION: This command demonstrates running a specific Makefile target through the `make` nox session by passing additional arguments after `--`. It executes `make clean htmlsingle rst=community/documentation_contributions.rst`, cleaning previous builds and building a single HTML page for a specific RST file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnox -s make -- clean htmlsingle rst=community/documentation_contributions.rst\n```\n\n----------------------------------------\n\nTITLE: Enabling Debugger Using Strategy Keyword in Play (YAML - Legacy)\nDESCRIPTION: This Ansible play demonstrates the legacy method (pre-Ansible 2.5) of enabling the debugger by setting `strategy: debug` at the play level. This method applies the debug strategy to all tasks within the play and may be removed in future Ansible versions.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- hosts: test\n  strategy: debug\n  tasks:\n    - name: Example task\n      debug:\n        msg: \"This is a debug message\"\n```\n\n----------------------------------------\n\nTITLE: Output Showing String Conversion from Incorrect Filter Usage (Console)\nDESCRIPTION: Displays the console output resulting from the incorrect Ansible task where the `replace` filter was applied directly to a list. The `msg` field confirms the result is a string (`\"['prod1', 'prod2']\"`), not a list, due to the implicit type conversion.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_12.rst#_snippet_13\n\nLANGUAGE: console\nCODE:\n```\nok: [localhost] => {\n    \"msg\": \"['prod1', 'prod2']\"\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Tagger Path from LINT_FILES in noxfile.py (Python)\nDESCRIPTION: Instructs the maintainer to manually edit the `noxfile.py` file and remove the specified string literal `\"hacking/tagger/tag.py\",` from the `LINT_FILES` tuple. This is part of removing the development-only tagger tool from stable branches.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# In noxfile.py, find the LINT_FILES tuple and remove this string element:\n\"hacking/tagger/tag.py\",\n```\n\n----------------------------------------\n\nTITLE: Removing Development-Only Tooling using Git (Bash)\nDESCRIPTION: This command uses `git rm -r` to remove specific workflow files, scripts (like the tagger), and test files that are intended only for the `devel` branch. This cleanup is performed on newly created stable branches.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Remove the following workflow files, the tagger script, and tagger requirements.\ngit rm -r .github/workflows/pip-compile-dev.yml .github/workflows/pip-compile-docs.yml .github/workflows/reusable-pip-compile.yml .github/workflows/tag.yml .github/workflows/build-package-docs.yaml hacking/tagger tests/tag.*\n```\n\n----------------------------------------\n\nTITLE: Defining reStructuredText Hyperlink Targets for Ansible Core Changelogs\nDESCRIPTION: This reStructuredText snippet defines external hyperlink targets using the `.. _label: URL` syntax. Each target links a specific `ansible-core` version label (e.g., `_2.9`) to its corresponding changelog file located in the Ansible GitHub repository, allowing references like `` `2.9`_ `` elsewhere in the document to link correctly.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/release_and_maintenance.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. _2.9: https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst\n.. _2.10: https://github.com/ansible/ansible/blob/stable-2.10/changelogs/CHANGELOG-v2.10.rst\n.. _2.11: https://github.com/ansible/ansible/blob/stable-2.11/changelogs/CHANGELOG-v2.11.rst\n.. _2.12: https://github.com/ansible/ansible/blob/stable-2.12/changelogs/CHANGELOG-v2.12.rst\n.. _2.13: https://github.com/ansible/ansible/blob/stable-2.13/changelogs/CHANGELOG-v2.13.rst\n.. _2.14: https://github.com/ansible/ansible/blob/stable-2.14/changelogs/CHANGELOG-v2.14.rst\n.. _2.15: https://github.com/ansible/ansible/blob/stable-2.15/changelogs/CHANGELOG-v2.15.rst\n.. _2.16: https://github.com/ansible/ansible/blob/stable-2.16/changelogs/CHANGELOG-v2.16.rst\n.. _2.17: https://github.com/ansible/ansible/blob/stable-2.17/changelogs/CHANGELOG-v2.17.rst\n.. _2.18: https://github.com/ansible/ansible/blob/stable-2.18/changelogs/CHANGELOG-v2.18.rst\n.. _2.19: https://github.com/ansible/ansible/blob/stable-2.19/changelogs/CHANGELOG-v2.19.rst\n```\n\n----------------------------------------\n\nTITLE: Commented-Out Future Release Projections in reStructuredText Table\nDESCRIPTION: This reStructuredText snippet shows commented-out rows within the `list-table` directive, likely representing projected support information for future `ansible-core` releases (2.20 to 2.25). Comments are denoted by `..` at the start of the line, preventing them from being rendered in the final documentation.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/reference_appendices/release_and_maintenance.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n..    * - 2.20\n..      - Nov 2025\n..      - May 2026\n..      - Nov 2026\n..      - May 2027\n..      - | Python 3.12 - 3.14\n..      - | Python 3.9 - 3.14\n..        | PowerShell 5.1\n..    * - 2.21\n..      - May 2026\n..      - Nov 2026\n..      - May 2027\n..      - Nov 2027\n..      - | Python 3.12 - 3.14\n..      - | Python 3.9 - 3.14\n..        | PowerShell 5.1\n..    * - 2.22\n..      - Nov 2026\n..      - May 2027\n..      - Nov 2027\n..      - May 2028\n..      - | Python 3.13 - 3.15\n..      - | Python 3.9 - 3.15\n..        | PowerShell 5.1\n..    * - 2.23\n..      - May 2027\n..      - Nov 2027\n..      - May 2028\n..      - Nov 2028\n..      - | Python 3.13 - 3.15\n..      - | Python 3.10 - 3.15\n..        | PowerShell 5.1\n..    * - 2.24\n..      - Nov 2027\n..      - May 2028\n..      - Nov 2028\n..      - May 2029\n..      - | Python 3.14 - 3.16\n..      - | Python 3.11 - 3.16\n..        | PowerShell 5.1\n..    * - 2.25\n..      - May 2028\n..      - Nov 2028\n..      - May 2029\n..      - Nov 2029\n..      - | Python 3.14 - 3.16\n..      - | Python 3.11 - 3.16\n..        | PowerShell 5.1\n```\n\n----------------------------------------\n\nTITLE: Section Heading Markdown Markdown\nDESCRIPTION: Illustrates how to define a section heading in markdown with two hash symbols (##). Intended for organizing documentation into clear sections that are easy to navigate and edit. Should be used after the main title for major subsections.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_14\n\nLANGUAGE: Markdown\nCODE:\n```\n## Installing on Linux\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Setup Target Directory (Bash)\nDESCRIPTION: Creates the task directory structure for the `setup_postgresql_db` integration test target within the `community.postgresql` collection.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_integration_add.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p tests/integration/targets/setup_postgresql_db/tasks\n```\n\n----------------------------------------\n\nTITLE: Referencing self.task Attribute\nDESCRIPTION: Stub documentation reference potentially indicating access to task context information via `self.task` within a module method or class.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_11\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: self.task\n```\n\n----------------------------------------\n\nTITLE: Defining Paragraph Headings in reStructuredText (rst)\nDESCRIPTION: Displays the reStructuredText syntax using '\\\"' underlines to define a 'paragraph' level heading, used for titling specific paragraphs when necessary.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n      Paragraph that needs a title\n      \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Anchors (Labels) in reStructuredText (rst)\nDESCRIPTION: Illustrates the reStructuredText syntax `.. _anchor_name::` for creating an internal anchor or label, like `_unique_page::`. This allows other parts of the documentation to link directly to this location using the `:ref:` role.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n   .. _unique_page::\n```\n\n----------------------------------------\n\nTITLE: Styling Network Platform Table - HTML\nDESCRIPTION: This HTML snippet provides inline CSS to customize the appearance of a specific table in the documentation. The styles add left border delimiters between header columns of the table with the id 'network-platform-table'. It requires embedding within a Sphinx documentation page using the 'raw:: html' directive. The code targets only table headers with the class 'head' inside the specified table.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/network/user_guide/platform_index.rst#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<style>\\n/* Style for this single table.  Add delimiters between header columns */\\ntable#network-platform-table thead tr th.head {\\n  border-left-width: 1px;\\n  border-left-color: rgb(225, 228, 229);\\n  border-left-style: solid;\\n}\\n</style>\n```\n\n----------------------------------------\n\nTITLE: Referencing self.playbook Attribute\nDESCRIPTION: Stub documentation reference potentially indicating access to playbook context information via `self.playbook` within a module method or class.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: self.playbook\n```\n\n----------------------------------------\n\nTITLE: Correcting Spelling Errors with Multiple Options using Nox (Bash)\nDESCRIPTION: This command runs the `spelling` nox session, passing `-w -i 3` to `codespell`. It interactively corrects spelling errors and sets the interaction level to 3, which might influence how multiple correction suggestions are handled.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnox -s spelling -- -w -i 3\n```\n\n----------------------------------------\n\nTITLE: Enabling Debugger Using Strategy in ansible.cfg (INI - Legacy)\nDESCRIPTION: This configuration snippet shows the legacy method (pre-Ansible 2.5) of enabling the debugger globally by setting `strategy = debug` in the `[defaults]` section of `ansible.cfg`. This approach may be deprecated in future Ansible releases.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/playbook_guide/playbooks_debugger.rst#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\n[defaults]\nstrategy = debug\n```\n\n----------------------------------------\n\nTITLE: Replacing 'SLAVE' with 'REPLICA' in mysql_replication Messages (Ansible)\nDESCRIPTION: States that the word `SLAVE` in messages returned by the `mysql_replication` module (`community.mysql`) will be changed to `REPLICA` in `community.mysql` 2.0.0.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/porting_guides/porting_guide_4.rst#_snippet_43\n\nLANGUAGE: ansible\nCODE:\n```\nSLAVE\n```\n\nLANGUAGE: ansible\nCODE:\n```\nREPLICA\n```\n\n----------------------------------------\n\nTITLE: Checking Git Repository Status in Bash\nDESCRIPTION: Executes `git status` to display the state of the working directory and staging area of the current Git repository, typically used here to confirm the current branch (usually `main` initially).\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/create_pr_quick_start.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ git status\n```\n\n----------------------------------------\n\nTITLE: Generating Table of Contents for Older Roadmaps in reStructuredText\nDESCRIPTION: This reStructuredText snippet uses the `toctree` directive to automatically generate a hierarchical table of contents. It includes links to files named ROADMAP_2_9, ROADMAP_2_8, ROADMAP_2_7, ROADMAP_2_6, and ROADMAP_2_5, displaying them under the caption 'Older Roadmaps' with a maximum depth of 1 level. The `glob` option indicates that filenames matching the pattern should be included.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/roadmap/old_roadmap_index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n   :glob:\n   :caption: Older Roadmaps\n\n   ROADMAP_2_9\n   ROADMAP_2_8\n   ROADMAP_2_7\n   ROADMAP_2_6\n   ROADMAP_2_5\n```\n\n----------------------------------------\n\nTITLE: Creating Tables of Committee Members - reStructuredText - reStructuredText\nDESCRIPTION: This snippet demonstrates the use of reStructuredText (reST) syntax to create and format tables listing committee members, their GitHub handles, and years of service. No external dependencies are required, but reStructuredText-compatible tooling (such as Sphinx) is necessary for proper rendering. The input consists of member data manually entered in the table; output is human-readable tables in generated documentation. The tables require consistent column widths and separators for valid reST formatting.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/steering/steering_committee_past_members.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. table:: Steering Committee past members\n\n  +------------------+-----------+-------------------+\n  | Name             | GitHub    | Years of service  |\n  +==================+===========+===================+\n  | Brad Thornton    | cidrblock | 2021-2024         |\n  +------------------+-----------+-------------------+\n  | Jill Rouleau     | jillr     | 2021-2022         |\n  +------------------+-----------+-------------------+\n  | Tadej Borov\\u0161ak   | tadeboro  | 2021-2022         |\n  +------------------+-----------+-------------------+\n  | Toshio Kuratomi  | abadger   | 2021              |\n  +------------------+-----------+-------------------+\n  | Dylan Silva      | thaumos   | 2021-2025         |\n  +------------------+-----------+-------------------+\n```\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. table:: Steering Committee past chairpersons\n\n  +------------------+-----------+-------------------+\n  | Name             | GitHub    | Years of service  |\n  +==================+===========+===================+\n  | Tadej Borov\\u0161ak   | tadeboro  | 2021-2022         |\n  +------------------+-----------+-------------------+\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible Builder CLI Command\nDESCRIPTION: Indicates that `ansible-builder` should be used when specifically referencing the command-line tool for Ansible Builder. Subsequent occurrences can use 'Builder'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nansible-builder\n```\n\n----------------------------------------\n\nTITLE: Example Build Workflow Options (YAML)\nDESCRIPTION: Shows an example snippet from a GitHub Actions workflow file, specifically the `options` list under inputs. This list defines the available Ansible package versions (like `devel`, `11`, `10`, `9`) that can be selected when triggering the workflow. Maintainers need to ensure new package version branches are added here.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/MAINTAINERS.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\noptions:\n- devel\n- '11'\n- '10'\n- '9'\n```\n\n----------------------------------------\n\nTITLE: Structuring Advanced Contributor Guide Navigation with reStructuredText\nDESCRIPTION: This snippet uses reStructuredText markup to structure the table of contents and section headers for advanced contributors in the Ansible documentation. It includes the use of section underlines, a named anonymous label (for Sphinx linking), and a toctree directive for organizing sub-guides. Required dependencies include a Sphinx documentation environment configured to process reStructuredText files. Inputs include section titles and file references for the toctree, producing a navigable multi-page guide for advanced roles. There are no dynamic parameters; modifications to structure require editing the file.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/advanced_index.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _advanced_community_guide:\n\n**********************************************\nAdvanced Contributor Guide\n**********************************************\n\nThis guide focuses on contributors who are committers, GitHub admins, release managers, or Ansible ecosystem project developers.\n\n.. toctree::\n   :maxdepth: 1\n\n   committer_guidelines\n   release_managers\n   github_admins\n   ecosystem_project_resources\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible CLI Command\nDESCRIPTION: Specifies using the lowercase `ansible` when referring specifically to the Ansible command-line interface tool. This distinguishes it from the capitalized 'Ansible' used for the community package.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nansible\n```\n\n----------------------------------------\n\nTITLE: Defining Part Headings in reStructuredText (rst)\nDESCRIPTION: Shows the reStructuredText syntax using '#' with an overline to define a 'part' level heading in Ansible documentation, typically used for major sections like 'Developer guide'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n      ###############\n      Developer guide\n      ###############\n```\n\n----------------------------------------\n\nTITLE: Illustrating Em Dash Usage Instead of Commas\nDESCRIPTION: This example demonstrates how a pair of em dashes can replace commas to emphasize parenthetical content within a sentence. It contrasts the use of parentheses with the use of em dashes, noting that surrounding punctuation is omitted when dashes replace parentheses.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/grammar_punctuation.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUpon discovering the errors (all 124 of them), the publisher immediately recalled the books.\n```\n\nLANGUAGE: text\nCODE:\n```\nUpon discovering the errors—all 124 of them—the publisher immediately recalled the books.\n```\n\n----------------------------------------\n\nTITLE: Referring to the Molecule CLI Command\nDESCRIPTION: Indicates that `molecule` should be used when referring to the command-line interface for Ansible Molecule. This is often used after the first full mention of 'Ansible Molecule'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmolecule\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible Runner CLI Command\nDESCRIPTION: Indicates using `ansible-runner` when specifically referencing the command-line tool for Ansible Runner. Subsequent occurrences can use 'Runner'.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nansible-runner\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to Cloned Repository using Bash\nDESCRIPTION: This Bash command changes the current working directory to the path where the collection repository was just cloned (`~/ansible_collections/NAMESPACE/COLLECTION_NAME`). This is necessary to perform Git operations specific to that repository.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/community/collection_contributors/collection_test_pr_locally.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/ansible_collections/NAMESPACE/COLLECTION_NAME\n```\n\n----------------------------------------\n\nTITLE: Illustrating Em Dash Usage at Sentence End\nDESCRIPTION: This example shows how a single em dash is used when replacing parentheses at the end of a sentence for emphasis or a less formal tone. It contrasts the parenthetical version with the em dash version.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/grammar_punctuation.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nAfter three weeks on set, the cast was fed up with his direction (or, rather, lack of direction).\n```\n\nLANGUAGE: text\nCODE:\n```\nAfter three weeks on set, the cast was fed up with his direction—or, rather, lack of direction.\n```\n\n----------------------------------------\n\nTITLE: Internal Link to File Markdown Markdown\nDESCRIPTION: Provides the syntax for creating an internal link to another file in a Markdown document using Mkdocs. This helps maintain effective cross-referencing within the project documentation by using relative paths. Requires Mkdocs for local file link resolution.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_15\n\nLANGUAGE: Markdown\nCODE:\n```\n[configuration](/configuration)\n```\n\n----------------------------------------\n\nTITLE: Injecting Raw JSON Module Arguments via Module Replacer (Internal)\nDESCRIPTION: This internal replacement pattern is substituted by the Module Replacer with the raw JSON string of module parameters. Proper quoting is essential as JSON may contain quotes. This pattern is not used in new-style Python modules under Ansiballz.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/developing_program_flow_modules.rst#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>\n```\n\n----------------------------------------\n\nTITLE: List All WSL Instances - Shell\nDESCRIPTION: Lists available WSL distributions and their current states, useful for verifying all instances have stopped before proceeding with configuration steps. Requires WSL installed.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/testing_running_locally.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nwsl -l -v\n```\n\n----------------------------------------\n\nTITLE: Referring to the Receptor CLI Command\nDESCRIPTION: Specifies using `receptor` when referring to the command-line tool associated with the Receptor project.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nreceptor\n```\n\n----------------------------------------\n\nTITLE: Page Title Heading Markdown Markdown\nDESCRIPTION: Shows the standard heading notation for defining a markdown page title using a single hash (#). This convention is recommended for clarity and consistency across documentation pages. No dependencies are required, and it should appear once per document as the main title.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_13\n\nLANGUAGE: Markdown\nCODE:\n```\n# Installation\n```\n\n----------------------------------------\n\nTITLE: Defining Sub-subsection Headings in reStructuredText (rst)\nDESCRIPTION: Illustrates the reStructuredText syntax using '^' underlines to create a 'sub-subsection' level heading, such as 'Adding anchors', nested further within the document structure.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n      Adding anchors\n      ^^^^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Table with Title reStructuredText reStructuredText\nDESCRIPTION: Demonstrates constructing a titled table in RST, using the .. table:: directive followed by a grid table with header and data rows. All tables should include heading rows and logical reading order for accessibility. The example lists file names and their purposes, showcasing how to represent configuration files.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_21\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. table:: File descriptions\n\n  +----------+----------------------------+\n  |File      |Purpose                     |\n  +==========+============================+\n  |foo.txt   |foo configuration settings  |\n  +----------+----------------------------+\n  |bar.txt   |bar configuration settings  |\n  +----------+----------------------------+\n```\n\n----------------------------------------\n\nTITLE: Referring to Ansible Core Component Name\nDESCRIPTION: Suggests using `ansible-core` after the first mention of 'Ansible Core' to clearly distinguish it from the broader 'Ansible' community package. This represents the component name.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nansible-core\n```\n\n----------------------------------------\n\nTITLE: Formatting Command Names: gcc Example\nDESCRIPTION: Illustrates the guideline to use lowercase formatting, enclosed in double backticks, when referring to a command like 'gcc' within the text, as shown in the example sentence: \"To start GCC, type ``gcc``.\"\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/spelling_word_choice.rst#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n``gcc``\n```\n\n----------------------------------------\n\nTITLE: Referencing ansible.module_utils.basic.ANSIBLE_VERSION Attribute\nDESCRIPTION: Stub documentation reference for the `ANSIBLE_VERSION` constant within the `ansible.module_utils.basic` module.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: ansible.module_utils.basic.ANSIBLE_VERSION\n```\n\n----------------------------------------\n\nTITLE: Referencing Deprecated ansible.module_utils.basic.SELINUX_SPECIAL_FS Attribute\nDESCRIPTION: Stub documentation reference for the deprecated `SELINUX_SPECIAL_FS` constant in `ansible.module_utils.basic`. It is superseded by `AnsibleModule._selinux_special_fs`.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/api/index.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. py:attribute:: ansible.module_utils.basic.SELINUX_SPECIAL_FS\n```\n\n----------------------------------------\n\nTITLE: Formatting Command Names: vi Exception\nDESCRIPTION: Specifies the formatting rule that the command name 'vi' should always be written in lowercase, enclosed in double backticks. This is presented as an exception or specific note.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/spelling_word_choice.rst#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n``vi``\n```\n\n----------------------------------------\n\nTITLE: Referring to the Ansible Sign CLI Command\nDESCRIPTION: Specifies using `ansible-sign` when referring to the command-line tool for Ansible Sign. This term should be used in all occurrences referencing the CLI.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/preferred_terms.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nansible-sign\n```\n\n----------------------------------------\n\nTITLE: Listing Python Package Dependencies\nDESCRIPTION: This snippet lists the required Python packages for the project. These packages are typically installed using a package manager like pip. `codeowners` might relate to managing code ownership information, `jinja2` is a templating engine, `pygithub` is likely used for GitHub API interactions, and `typer-slim` is a library for building command-line interfaces.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/pr_labeler/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncodeowners\njinja2\npygithub\ntyper-slim\n```\n\n----------------------------------------\n\nTITLE: Referencing Affected Ansible Version in Bug Report - Markdown\nDESCRIPTION: This snippet marks the relevant Ansible version (via the variable %(version)s) associated with the deprecated code. It helps maintainers determine when deprecation was detected and potentially scope the bug fix. Inputs are template variables to be dynamically replaced with an actual version string by the bug reporting system.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/hacking/deprecated_issue_template.md#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n```\n%(version)s\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Ruff Dependency Version for Static Analysis\nDESCRIPTION: Defines the specific version `0.11.6` for the `ruff` Python package. This dependency is intended for static analysis tools within the testing environment, as indicated by the autogeneration comment referencing the input file `tests/static.in`. This ensures a consistent version of the Ruff linter/formatter is used.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/tests/static.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nruff==0.11.6\n    # via -r tests/static.in\n```\n\n----------------------------------------\n\nTITLE: Image with Alt Text Markdown Markdown\nDESCRIPTION: Presents the markdown syntax for embedding an image with alt text for accessibility. The alt text, enclosed in brackets, describes the image for screen readers and other assistive tools. Applies to all images and diagrams, consistent with accessibility guidelines.\nSOURCE: https://github.com/ansible/ansible-documentation/blob/devel/docs/docsite/rst/dev_guide/style_guide/index.rst#_snippet_20\n\nLANGUAGE: Markdown\nCODE:\n```\n![SpiffyCorp network diagram](path/networkdiag.png)\n```"
  }
]